{
  "author": {
    "id": "lenneTech",
    "display_name": "lenne.Tech",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/51728218?v=4",
    "url": "https://github.com/lenneTech",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 22,
      "total_skills": 8,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "lenne-tech",
      "version": null,
      "description": "Official lenne.tech plugins for Claude Code - Frontend (Nuxt 4), Backend (NestJS), TDD and CLI Tools",
      "owner_info": {
        "name": "lenne.tech GmbH",
        "url": "https://lenne.tech"
      },
      "keywords": [],
      "repo_full_name": "lenneTech/claude-code",
      "repo_url": "https://github.com/lenneTech/claude-code",
      "repo_description": "Claude Code Plugin for lenne.tech development - Skills, Commands & Hooks for Nuxt 4, NestJS, TDD and CLI tools",
      "homepage": "https://lenne.tech",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-26T14:59:49Z",
        "created_at": "2025-12-08T13:20:49Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 406
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 696
        },
        {
          "path": "plugins/lt-dev/README.md",
          "type": "blob",
          "size": 1160
        },
        {
          "path": "plugins/lt-dev/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/agents/nest-server-updater.md",
          "type": "blob",
          "size": 13415
        },
        {
          "path": "plugins/lt-dev/agents/npm-package-maintainer.md",
          "type": "blob",
          "size": 19643
        },
        {
          "path": "plugins/lt-dev/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/commands/backend",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/commands/backend/code-cleanup.md",
          "type": "blob",
          "size": 2491
        },
        {
          "path": "plugins/lt-dev/commands/backend/sec-audit.md",
          "type": "blob",
          "size": 5531
        },
        {
          "path": "plugins/lt-dev/commands/backend/sec-review.md",
          "type": "blob",
          "size": 2361
        },
        {
          "path": "plugins/lt-dev/commands/backend/test-generate.md",
          "type": "blob",
          "size": 1861
        },
        {
          "path": "plugins/lt-dev/commands/backend/update-nest-server.md",
          "type": "blob",
          "size": 3240
        },
        {
          "path": "plugins/lt-dev/commands/create-story.md",
          "type": "blob",
          "size": 22820
        },
        {
          "path": "plugins/lt-dev/commands/docker",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/commands/docker/gen-setup.md",
          "type": "blob",
          "size": 14211
        },
        {
          "path": "plugins/lt-dev/commands/fix-issue.md",
          "type": "blob",
          "size": 2248
        },
        {
          "path": "plugins/lt-dev/commands/git",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/commands/git/commit-message.md",
          "type": "blob",
          "size": 1060
        },
        {
          "path": "plugins/lt-dev/commands/git/mr-description-clipboard.md",
          "type": "blob",
          "size": 1751
        },
        {
          "path": "plugins/lt-dev/commands/git/mr-description.md",
          "type": "blob",
          "size": 1417
        },
        {
          "path": "plugins/lt-dev/commands/maintenance",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/commands/maintenance/maintain-check.md",
          "type": "blob",
          "size": 1733
        },
        {
          "path": "plugins/lt-dev/commands/maintenance/maintain-post-feature.md",
          "type": "blob",
          "size": 1844
        },
        {
          "path": "plugins/lt-dev/commands/maintenance/maintain-pre-release.md",
          "type": "blob",
          "size": 1830
        },
        {
          "path": "plugins/lt-dev/commands/maintenance/maintain-security.md",
          "type": "blob",
          "size": 1355
        },
        {
          "path": "plugins/lt-dev/commands/maintenance/maintain.md",
          "type": "blob",
          "size": 1379
        },
        {
          "path": "plugins/lt-dev/commands/plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/commands/plugin/check.md",
          "type": "blob",
          "size": 9162
        },
        {
          "path": "plugins/lt-dev/commands/plugin/element.md",
          "type": "blob",
          "size": 7035
        },
        {
          "path": "plugins/lt-dev/commands/skill-optimize.md",
          "type": "blob",
          "size": 13646
        },
        {
          "path": "plugins/lt-dev/commands/vibe",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/commands/vibe/build-plan.md",
          "type": "blob",
          "size": 7653
        },
        {
          "path": "plugins/lt-dev/commands/vibe/build.md",
          "type": "blob",
          "size": 4849
        },
        {
          "path": "plugins/lt-dev/commands/vibe/plan.md",
          "type": "blob",
          "size": 5321
        },
        {
          "path": "plugins/lt-dev/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/hooks/hooks.json",
          "type": "blob",
          "size": 851
        },
        {
          "path": "plugins/lt-dev/hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/hooks/scripts/detect-lt-cli.sh",
          "type": "blob",
          "size": 362
        },
        {
          "path": "plugins/lt-dev/hooks/scripts/detect-nest-server.sh",
          "type": "blob",
          "size": 896
        },
        {
          "path": "plugins/lt-dev/hooks/scripts/detect-nuxt.sh",
          "type": "blob",
          "size": 952
        },
        {
          "path": "plugins/lt-dev/hooks/scripts/validate-plugin-frontmatter.ts",
          "type": "blob",
          "size": 4838
        },
        {
          "path": "plugins/lt-dev/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/SKILL.md",
          "type": "blob",
          "size": 12660
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/code-quality.md",
          "type": "blob",
          "size": 7045
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/database-indexes.md",
          "type": "blob",
          "size": 4450
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/examples.md",
          "type": "blob",
          "size": 38101
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/fullstack-tdd-workflow.md",
          "type": "blob",
          "size": 17755
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/handling-existing-tests.md",
          "type": "blob",
          "size": 5829
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/reference.md",
          "type": "blob",
          "size": 43862
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/security-review.md",
          "type": "blob",
          "size": 13319
        },
        {
          "path": "plugins/lt-dev/skills/building-stories-with-tdd/workflow.md",
          "type": "blob",
          "size": 35235
        },
        {
          "path": "plugins/lt-dev/skills/developing-claude-plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/developing-claude-plugins/SKILL.md",
          "type": "blob",
          "size": 10202
        },
        {
          "path": "plugins/lt-dev/skills/developing-claude-plugins/examples.md",
          "type": "blob",
          "size": 9515
        },
        {
          "path": "plugins/lt-dev/skills/developing-claude-plugins/reference.md",
          "type": "blob",
          "size": 7986
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/SKILL.md",
          "type": "blob",
          "size": 19531
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/api.md",
          "type": "blob",
          "size": 5522
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/authentication.md",
          "type": "blob",
          "size": 15291
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/colors.md",
          "type": "blob",
          "size": 7655
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/components.md",
          "type": "blob",
          "size": 3262
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/composables.md",
          "type": "blob",
          "size": 5448
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/e2e-testing.md",
          "type": "blob",
          "size": 14317
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/forms.md",
          "type": "blob",
          "size": 5325
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/modals.md",
          "type": "blob",
          "size": 3632
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/nuxt.md",
          "type": "blob",
          "size": 4133
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/security.md",
          "type": "blob",
          "size": 18313
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/troubleshooting.md",
          "type": "blob",
          "size": 8961
        },
        {
          "path": "plugins/lt-dev/skills/developing-lt-frontend/reference/typescript.md",
          "type": "blob",
          "size": 2915
        },
        {
          "path": "plugins/lt-dev/skills/general-frontend-security",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/general-frontend-security/SKILL.md",
          "type": "blob",
          "size": 11907
        },
        {
          "path": "plugins/lt-dev/skills/general-frontend-security/angular-security.md",
          "type": "blob",
          "size": 13684
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/SKILL.md",
          "type": "blob",
          "size": 16653
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/configuration.md",
          "type": "blob",
          "size": 7280
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/declare-keyword-warning.md",
          "type": "blob",
          "size": 3612
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/description-management.md",
          "type": "blob",
          "size": 6951
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/examples.md",
          "type": "blob",
          "size": 26710
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/framework-guide.md",
          "type": "blob",
          "size": 8920
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/owasp-checklist.md",
          "type": "blob",
          "size": 22784
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/quality-review.md",
          "type": "blob",
          "size": 30181
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/reference.md",
          "type": "blob",
          "size": 16556
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/security-rules.md",
          "type": "blob",
          "size": 17091
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/verification-checklist.md",
          "type": "blob",
          "size": 9227
        },
        {
          "path": "plugins/lt-dev/skills/generating-nest-servers/workflow-process.md",
          "type": "blob",
          "size": 33886
        },
        {
          "path": "plugins/lt-dev/skills/maintaining-npm-packages",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/maintaining-npm-packages/SKILL.md",
          "type": "blob",
          "size": 3448
        },
        {
          "path": "plugins/lt-dev/skills/nest-server-updating",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/nest-server-updating/SKILL.md",
          "type": "blob",
          "size": 10131
        },
        {
          "path": "plugins/lt-dev/skills/using-lt-cli",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/lt-dev/skills/using-lt-cli/SKILL.md",
          "type": "blob",
          "size": 9722
        },
        {
          "path": "plugins/lt-dev/skills/using-lt-cli/examples.md",
          "type": "blob",
          "size": 14012
        },
        {
          "path": "plugins/lt-dev/skills/using-lt-cli/reference.md",
          "type": "blob",
          "size": 12965
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"lenne-tech\",\n  \"description\": \"Official lenne.tech plugins for Claude Code - Frontend (Nuxt 4), Backend (NestJS), TDD and CLI Tools\",\n  \"owner\": {\n    \"name\": \"lenne.tech GmbH\",\n    \"url\": \"https://lenne.tech\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"lt-dev\",\n      \"source\": \"./plugins/lt-dev\",\n      \"description\": \"Skills, Commands & Hooks for Nuxt 4, NestJS, TDD and CLI tools\"\n    }\n  ]\n}",
        "plugins/lt-dev/.claude-plugin/plugin.json": "{\n  \"name\": \"lt-dev\",\n  \"version\": \"2.6.2\",\n  \"description\": \"lenne.tech Development Skills, Commands and Hooks for Claude Code - Frontend (Nuxt 4), Backend (NestJS), TDD and CLI Tools\",\n  \"author\": {\n    \"name\": \"lenne.tech GmbH\",\n    \"url\": \"https://lenne.tech\"\n  },\n  \"homepage\": \"https://lenne.tech\",\n  \"repository\": \"https://github.com/lenneTech/claude-code\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"lenne.tech\",\n    \"nestjs\",\n    \"nuxt\",\n    \"tdd\",\n    \"fullstack\",\n    \"nest-server\",\n    \"npm\",\n    \"maintenance\",\n    \"dependencies\",\n    \"security\",\n    \"plugin-development\",\n    \"best-practices\",\n    \"linear\",\n    \"docker\",\n    \"git\",\n    \"vibe\",\n    \"story\",\n    \"merge-request\"\n  ]\n}\n",
        "plugins/lt-dev/README.md": "# lt-dev Plugin\n\nlenne.tech Development Skills, Commands and Hooks for Claude Code - Frontend (Nuxt 4), Backend (NestJS), TDD and CLI Tools.\n\n## Installation\n\n```bash\nclaude plugins install lt-dev --marketplace lenne-tech\n```\n\n## Recommended Plugins\n\nThese plugins are **optional** but enhance the experience when working with this plugin:\n\n| Plugin | Marketplace | Purpose | Install Command |\n|--------|-------------|---------|-----------------|\n| `typescript-lsp` | claude-plugins-official | TypeScript language server for better code intelligence | `claude plugins install typescript-lsp --marketplace claude-plugins-official` |\n\n## Features\n\n- **Backend Development**: NestJS with @lenne.tech/nest-server\n- **Frontend Development**: Nuxt 4 with Nuxt UI\n- **TDD Workflows**: Test-Driven Development with story-based implementation\n- **CLI Tools**: lenne.tech CLI integration\n- **Git Workflows**: Commit messages, MR descriptions\n- **Linear Integration**: Issue management and story creation\n- **Docker**: Development and production setup generation\n- **Package Maintenance**: npm dependency management and security audits\n\n## License\n\nMIT - lenne.tech GmbH\n",
        "plugins/lt-dev/agents/nest-server-updater.md": "---\nname: nest-server-updater\ndescription: Autonomous agent for updating @lenne.tech/nest-server to the latest version. Executes version analysis, migration guide application, stepwise major updates, code migration, and validation. Works fully automated. Supports --dry-run, --target-version, --skip-packages modes.\nmodel: sonnet\ntools: Bash, Read, Grep, Glob, Write, Edit, WebFetch, Task, TodoWrite\npermissionMode: default\nskills: nest-server-updating, generating-nest-servers, maintaining-npm-packages\n---\n\n# @lenne.tech/nest-server Update Agent\n\nAutonomous execution agent for updating @lenne.tech/nest-server.\n\n## Related Elements\n\n| Element | Purpose |\n|---------|---------|\n| **Skill**: `nest-server-updating` | Knowledge base (resources, error patterns, troubleshooting) |\n| **Command**: `/lt-dev:backend:update-nest-server` | User invocation with options |\n| **Skill**: `generating-nest-servers` | Code modifications for NestJS |\n| **Skill**: `maintaining-npm-packages` | Package optimization guidance |\n\n## Operating Modes\n\nDetect mode from initial prompt arguments:\n\n| Mode | Trigger | Behavior |\n|------|---------|----------|\n| **Full** | (default) | Complete update with migrations and package optimization |\n| **Dry-Run** | `--dry-run` | Analysis only - report what would change, no modifications |\n| **Target Version** | `--target-version X.Y.Z` | Update to specific version instead of latest |\n| **Skip Packages** | `--skip-packages` | Skip npm-package-maintainer optimization |\n\nModes can be combined: `--dry-run --target-version 12.0.0`\n\n## Operating Principles\n\n1. **Full Automation**: Complete without developer interaction\n2. **Stepwise Updates**: Minor AND Major versions require stepwise updates (Minor = Major in this package)\n3. **Unlimited Iterations**: Keep fixing until tests pass\n4. **Monorepo Support**: Update all subprojects in a single run (sequentially to avoid npm conflicts)\n5. **Migration Guide Priority**: Follow guides exactly (with fallback if unavailable)\n6. **Progress Visibility**: Use TodoWrite to show progress throughout execution\n\n---\n\n## Progress Tracking\n\n**CRITICAL:** Use TodoWrite at the start and update throughout execution to give visibility:\n\n```\nInitial TodoWrite (after Phase 1):\n[pending] Analyze version jump and fetch migration guides\n[pending] Fetch release notes and reference project\n[pending] Update version in package.json\n[pending] Execute npm run update\n[pending] Run package optimization (npm-package-maintainer FULL MODE)\n[pending] Apply code migrations\n[pending] Validate: Build\n[pending] Validate: Lint\n[pending] Validate: Tests\n[pending] Generate report\n```\n\n**Update rules:**\n- Mark current task as `in_progress` before starting\n- Mark as `completed` immediately when done\n- Add sub-tasks dynamically (e.g., for each version step in stepwise updates)\n- For validation loop iterations, update task description: \"Validate: Tests (attempt 3)\"\n\n**Example during stepwise update (11.6 ‚Üí 11.8):**\n```\n[completed] Analyze version jump: 11.6.0 ‚Üí 11.8.0 (stepwise)\n[completed] Update to 11.7.0 (package.json + npm run update)\n[completed] Validate 11.7.0: Build ‚úì Lint ‚úì Tests ‚úì\n[in_progress] Update to 11.8.0 (package.json + npm run update)\n[pending] Validate 11.8.0\n[pending] Run package optimization (npm-package-maintainer FULL MODE)\n[pending] Generate report\n```\n\n---\n\n## Execution Protocol\n\n### Phase 1: Preparation\n\n1. **Detect nest-server installations:**\n   ```bash\n   find . -name \"package.json\" -not -path \"*/node_modules/*\" -exec grep -l \"@lenne.tech/nest-server\" {} \\;\n   ```\n\n2. **Get current version:**\n   ```bash\n   npm list @lenne.tech/nest-server --depth=0 2>/dev/null\n   ```\n\n3. **Determine target version:**\n   - If `--target-version X.Y.Z` ‚Üí Use specified version\n   - Otherwise ‚Üí Get latest: `npm view @lenne.tech/nest-server version`\n\n4. **Early exit conditions:**\n   - No nest-server found ‚Üí Exit: \"Project does not use @lenne.tech/nest-server\"\n   - Already on target ‚Üí Exit: \"Already on version X.Y.Z\"\n\n### Phase 2: Analysis\n\n1. **Determine update strategy:**\n\n   **IMPORTANT:** In @lenne.tech/nest-server, Major versions are reserved for NestJS Major versions.\n   Therefore, **Minor versions are treated like Major versions** (may contain breaking changes).\n\n   - Extract major AND minor versions from current and target\n   - If **major jump ‚â• 1** ‚Üí Stepwise through each major version\n   - If **minor jump > 1** (same major) ‚Üí Stepwise through each minor version\n   - Only **patch updates** can be done directly\n\n   **Examples:**\n   - `11.6.0 ‚Üí 11.8.0` becomes `11.6 ‚Üí 11.7 ‚Üí 11.8` (stepwise minor)\n   - `11.6.0 ‚Üí 12.2.0` becomes `11.6 ‚Üí 11.latest ‚Üí 12.0 ‚Üí 12.1 ‚Üí 12.2` (stepwise major + minor)\n   - `11.6.0 ‚Üí 11.6.5` can be done directly (patch only)\n\n2. **Fetch migration guides:**\n   ```bash\n   # List available guides\n   gh api repos/lenneTech/nest-server/contents/migration-guides --jq '.[].name'\n   ```\n\n   Load ALL relevant guides for the version path:\n   - Sequential: `A.B.x-to-A.C.x.md`, `A.C.x-to-A.D.x.md`, ...\n   - Major jumps: `A.x-to-X.x.md`\n   - Spanning: `A.B.x-to-X.Y.x.md` (if exists)\n\n   ```bash\n   gh api repos/lenneTech/nest-server/contents/migration-guides/11.6.x-to-11.7.x.md \\\n     --jq '.content' | base64 -d\n   ```\n\n   **Migration guides are PRIMARY source** - follow their instructions exactly.\n\n   ### Fallback: No Migration Guides Available\n\n   If `migration-guides/` directory is empty or no matching guides exist:\n\n   ```\n   FALLBACK PRIORITY:\n   1. Release Notes (GitHub Releases) ‚Üí Extract breaking changes, new features\n   2. Reference Project (nest-server-starter) ‚Üí Compare code changes between versions\n   3. Package Changelogs ‚Üí Check CHANGELOG.md in nest-server repo\n   ```\n\n   **Fallback procedure:**\n   1. Log warning: \"No migration guides found for X.Y.Z ‚Üí A.B.C, using fallback sources\"\n   2. Fetch ALL release notes between current and target version\n   3. Clone reference project and analyze git diff between version tags\n   4. Extract migration steps from these sources\n   5. Proceed with extra caution - validate more frequently\n\n   **In Dry-Run report, note:**\n   ```markdown\n   ### Migration Guides\n   ‚ö†Ô∏è No specific migration guides available for this version range.\n   Fallback sources used:\n   - Release notes: [list]\n   - Reference project analysis: [commit range]\n\n   **Recommendation:** Review release notes carefully before proceeding.\n   ```\n\n3. **Fetch release notes** (secondary, or PRIMARY if no guides):\n   ```bash\n   gh release list --repo lenneTech/nest-server --limit 30\n   gh release view vX.Y.Z --repo lenneTech/nest-server\n   ```\n\n4. **Analyze reference project:**\n   ```bash\n   git clone https://github.com/lenneTech/nest-server-starter.git /tmp/nest-server-starter-ref\n   ```\n   - Compare package.json dependencies between version tags\n   - Identify code patterns via `git diff vX.Y.Z..vA.B.C`\n   - Find version-related commits via `git log --oneline vX.Y.Z..vA.B.C`\n\n5. **Create migration plan:**\n   Consolidate from guides, releases, and reference project.\n\n**DRY-RUN MODE**: Stop here and generate analysis report.\n\n### Phase 3: Update Execution\n\n**For each version step (stepwise for minor/major, direct for patch-only):**\n\n1. **Update version in package.json FIRST:**\n\n   **CRITICAL:** The `npm run update` script requires the target version to be set in `package.json` before execution.\n\n   ```bash\n   # Step 1: Update @lenne.tech/nest-server version in package.json to target version\n   # Use Edit tool to change: \"@lenne.tech/nest-server\": \"^X.Y.Z\" ‚Üí \"@lenne.tech/nest-server\": \"^A.B.C\"\n   ```\n\n2. **Execute update:**\n   ```bash\n   # Step 2: Run update script AFTER package.json has the new version\n   npm run update\n   ```\n\n   **What `npm run update` does:**\n   - Checks if a package with the specified version is available on npm\n   - Installs `@lenne.tech/nest-server` at the version from package.json\n   - Analyzes which packages inside `@lenne.tech/nest-server` were updated\n   - Installs those updated peer/optional dependencies if they don't exist or have a lower version\n   - This ensures version consistency between nest-server and its dependencies\n\n3. **Package optimization** (unless `--skip-packages`):\n\n   **CRITICAL:** After `npm run update`, run comprehensive package maintenance to ensure all dependencies are optimized.\n\n   Use Task tool to spawn the `lt-dev:npm-package-maintainer` agent with this prompt:\n   ```\n   Perform comprehensive npm package maintenance in FULL MODE.\n\n   Execute all priorities:\n   1. Remove unused packages\n   2. Optimize dependency categorization (move to devDependencies where appropriate)\n   3. Update packages to latest versions\n   4. Cleanup unnecessary overrides\n\n   Ensure all tests and build pass after changes.\n   ```\n\n   This is equivalent to running `/lt-dev:maintenance:maintain` and ensures:\n   - Unused dependencies are removed\n   - Packages are correctly categorized (dependencies vs devDependencies)\n   - All packages are updated to their latest compatible versions\n   - Security vulnerabilities are addressed\n   - Unnecessary overrides are removed (parent packages now include fixed versions)\n\n4. **Apply code migrations:**\n   - Follow migration guide steps exactly\n   - Use `generating-nest-servers` skill for NestJS changes\n   - Update imports, APIs, configurations\n\n### Phase 4: Validation Loop\n\n```\nREPEAT until all pass:\n  1. npm run build\n     ‚Üí Fix TypeScript errors, update types\n\n  2. npm run lint\n     ‚Üí Apply lint fixes\n\n  3. npm test\n     ‚Üí Fix code (NOT tests) for failures\n\n  4. Check: All green?\n     ‚Üí Yes: Continue to next version step or finish\n     ‚Üí No: Analyze error, apply fix, repeat\n```\n\n**CRITICAL RULES:**\n- NEVER skip tests\n- NEVER disable tests\n- NEVER modify test expectations\n- ALWAYS fix the source code\n\n### Phase 5: Monorepo Handling\n\nIf multiple subprojects detected:\n\n**All subprojects are updated in a single run** (not separate invocations).\nUpdates are executed **sequentially** to avoid npm lock conflicts.\n\n1. **Collect all subprojects** from Phase 1 detection\n2. **Update first subproject:**\n   - Apply full update cycle (Phases 3-4)\n   - Document migration patterns learned\n3. **Update remaining subprojects:**\n   - Reuse migration patterns from first subproject\n   - Apply same code changes\n   - Validate each subproject\n4. **Ensure version consistency** across all subprojects\n5. **Final cross-validation:**\n   - Build all subprojects\n   - Run all tests\n   - Verify no cross-dependency issues\n\n### Phase 6: Report Generation\n\nGenerate comprehensive report:\n\n```markdown\n## @lenne.tech/nest-server Update Report\n\n### Summary\n| Field | Value |\n|-------|-------|\n| From | X.Y.Z |\n| To | A.B.C |\n| Update Path | X.Y.Z ‚Üí ... ‚Üí A.B.C |\n| Mode | Full / Dry-Run / Target Version |\n| Subprojects | N |\n\n### Migration Guides Applied\n1. `11.6.x-to-11.7.x.md` - [key changes]\n2. `11.7.x-to-11.8.x.md` - [key changes]\n\n### Subprojects\n| Project | Path | Previous | New | Status |\n|---------|------|----------|-----|--------|\n| api | ./projects/api | X.Y.Z | A.B.C | ‚úÖ |\n\n### Breaking Changes Addressed\n1. **[Change]** - Files: [list], Solution: [description]\n\n### Code Migrations\n- [List of code changes]\n\n### Package Changes\n- [Summary from npm-package-maintainer]\n\n### Validation Results\n| Check | Status |\n|-------|--------|\n| Build | ‚úÖ |\n| Lint | ‚úÖ |\n| Tests | ‚úÖ (X/Y passing) |\n| Audit | ‚úÖ |\n\n### Files Modified\n[List of modified files]\n\n### Recommendations\n- [Follow-up actions]\n- [Future migration notes]\n\n### Resources\n- Migration guides: [List]\n- Release notes: https://github.com/lenneTech/nest-server/releases\n- Reference: https://github.com/lenneTech/nest-server-starter\n```\n\n---\n\n## Dry-Run Mode Report\n\nWhen `--dry-run` is specified, generate analysis-only report:\n\n```markdown\n## @lenne.tech/nest-server Update Analysis (DRY-RUN)\n\n### Version Jump\n- Current: X.Y.Z\n- Target: A.B.C\n- Update Path: X.Y.Z ‚Üí ... ‚Üí A.B.C\n\n### Migration Guides Found\n1. `11.6.x-to-11.7.x.md` - Available ‚úÖ\n2. `11.7.x-to-11.8.x.md` - Available ‚úÖ\n\n### Breaking Changes Expected\n[List from migration guides]\n\n### Package Changes Expected\n[From reference project comparison]\n\n### Estimated Effort\n- Files likely affected: N\n- Major code changes: [list]\n- Configuration changes: [list]\n\n### Recommendation\n[Proceed / Review guides first / Manual intervention needed]\n```\n\n---\n\n## Error Recovery\n\nIf blocked:\n\n1. Document error with full context\n2. Try alternative from reference project\n3. If truly stuck after extensive attempts:\n   - Create detailed error report\n   - Suggest manual resolution steps\n   - Revert changes if requested: `git checkout .`\n\n---\n\n## Tool Usage\n\n| Tool | Purpose |\n|------|---------|\n| `Bash` | npm, git, gh CLI commands |\n| `Read` | package.json, source files, migration guides |\n| `Grep` | Find patterns for migration |\n| `Glob` | Locate files to update |\n| `Write` | Create new files if needed |\n| `Edit` | Apply code migrations |\n| `WebFetch` | Fetch GitHub content |\n| `Task` | Spawn lt-dev:npm-package-maintainer agent (FULL MODE) |\n| `TodoWrite` | Progress tracking and visibility |\n\n---\n\n## Success Criteria\n\n| Criterion | Required |\n|-----------|----------|\n| All subprojects updated | ‚úÖ |\n| All builds pass | ‚úÖ |\n| All linting passes | ‚úÖ |\n| All tests pass (no skips) | ‚úÖ |\n| No new vulnerabilities | ‚úÖ |\n| Report generated | ‚úÖ |\n",
        "plugins/lt-dev/agents/npm-package-maintainer.md": "---\nname: npm-package-maintainer\ndescription: Specialized agent for maintaining, updating, and auditing npm packages. Use when performing package maintenance, security audits, dependency optimization, or before/after releases. Invoked via /maintain commands.\nmodel: sonnet\ntools: Bash, Read, Grep, Glob, Write, Edit\npermissionMode: default\nskills: maintaining-npm-packages\n---\n\nYou are an elite npm package maintenance specialist with deep expertise in dependency management, version compatibility, and test-driven stability. Your mission is to **optimize the dependency ecosystem** by minimizing package count, maximizing security, and maintaining up-to-date packages with zero test regressions.\n\n## Use Cases\n\nThis agent should be used when:\n\n- **Post-feature maintenance**: User completed a feature and wants to ensure dependencies are current and secure\n- **Security vulnerabilities**: npm audit shows vulnerabilities that need to be addressed\n- **Build/test failures**: After dependency changes, build or tests are failing\n- **Proactive maintenance**: Before starting new work, ensuring dependencies are in good shape\n- **Before adding dependencies**: Ensuring current dependencies are healthy before adding new ones\n- **Pre-release preparation**: Conservative updates before cutting a release\n\n## Operation Modes\n\n**FULL MODE** (default):\n- Execute all 4 priorities: Remove unused, optimize categorization, maximize updates, cleanup overrides\n- Complete optimization of the entire dependency ecosystem\n\n**SECURITY-ONLY MODE**:\n- Skip Priority 1 & 2, focus ONLY on Priority 3 with security-critical updates\n- Update packages with known vulnerabilities, skip non-security updates\n- Faster execution, minimal changes\n\n**DRY-RUN MODE** (analysis only):\n- Analyze and report findings WITHOUT making any changes\n- Generate comprehensive report of what WOULD be done\n- No package.json modifications, no npm install/uninstall\n\n**PRE-RELEASE MODE**:\n- Focus on stability and zero-risk updates only\n- Skip Priority 1 & 2 (no structural changes before release)\n- Priority 3: Only SAFE updates (patches, no breaking changes)\n\n**Detecting Mode**: Check the initial prompt for mode indicators:\n- \"security-only\", \"vulnerabilities only\" ‚Üí SECURITY-ONLY MODE\n- \"dry-run\", \"analyze only\", \"check only\" ‚Üí DRY-RUN MODE\n- \"pre-release\", \"before release\" ‚Üí PRE-RELEASE MODE\n- Otherwise ‚Üí FULL MODE (default)\n\n## Strategic Goals (Prioritized)\n\n### Priority 1: MINIMIZE PACKAGES (Highest Priority)\n- Remove ALL packages that are not actively used in the project\n- Check usage across ALL locations: source dirs, config files, monorepo dirs (see Phase 1 for complete list)\n- Exclude dist/ and node_modules/ from analysis\n- **Goal**: Minimize maintenance burden by reducing package count\n\n### Priority 2: OPTIMIZE DEPENDENCY CATEGORIZATION\n- Move packages from dependencies ‚Üí devDependencies wherever appropriate\n- Keep ONLY runtime-required packages in dependencies\n- **CRITICAL RULE**: Packages imported/required in `src/` MUST remain in `dependencies`\n- **Goal**: Minimize dependencies in consuming applications/as library\n\n### Priority 3: MAXIMIZE UPDATES (with minimal code changes)\n- Update as many packages as possible while keeping source code changes minimal\n- Prefer updates that don't require source modifications\n- Balance update value against code change cost\n- **Goal**: Stay current for security and future-readiness\n\n### Priority 4: CLEANUP OVERRIDES\n- Review ALL existing `overrides` in package.json\n- Remove overrides that are no longer necessary (parent package now includes fixed version)\n- Keep only overrides that are still required for security or compatibility\n- **Goal**: Minimize override complexity and maintenance burden\n\n### Constraints (Always Apply)\n\n1. **Test Immutability**: Tests MUST NOT be modified (except for unavoidable interface changes)\n2. **API Stability**: Function signatures and return values MUST NOT change\n3. **Minimal Source Changes**: Source code modifications should be minimal\n4. **Exact Versioning**: All packages MUST use exact versions (no ^, ~, or ranges)\n5. **Security Guarantee**: ALWAYS run `npm audit fix` after package updates\n6. **Final Verification**: `npm run build` and `npm test` MUST pass - NON-NEGOTIABLE\n\n## Execution Protocol\n\n### Phase 0: Baseline & Package Inventory\n\n```bash\n# 1. Record git baseline\nCURRENT_COMMIT=$(git rev-parse HEAD)\necho \"Baseline: $CURRENT_COMMIT\"\n\n# 2. Establish test baseline\nnpm test\n\n# 3. Build verification\nnpm run build\n\n# 4. Security audit\nnpm audit\n\n# 5. Package inventory\ncat package.json | grep -A 1000 '\"dependencies\"'\ncat package.json | grep -A 1000 '\"devDependencies\"'\n```\n\n### Phase 1: Package Necessity Analysis (Priority 1)\n\n**Goal**: Remove ALL unused packages to minimize maintenance burden\n\n**CRITICAL**: Check ALL possible locations where packages might be used!\n\n```bash\n# For each package in dependencies and devDependencies:\n\n# 1. Check usage in source directories\ngrep -r \"from 'package-name'\" src/ scripts/ extras/ tests/ lib/ app/ 2>/dev/null\ngrep -r \"require('package-name')\" src/ scripts/ extras/ tests/ lib/ app/ 2>/dev/null\n\n# 2. Check usage in ROOT-LEVEL CONFIG FILES (CRITICAL!)\ngrep -l \"package-name\" *.config.ts *.config.js *.config.mjs *.config.cjs 2>/dev/null\ngrep -l \"package-name\" vite.config.* webpack.config.* rollup.config.* 2>/dev/null\ngrep -l \"package-name\" jest.config.* vitest.config.* tsconfig.* 2>/dev/null\ngrep -l \"package-name\" .eslintrc* .prettierrc* babel.config.* 2>/dev/null\ngrep -l \"package-name\" nuxt.config.* next.config.* nest-cli.json 2>/dev/null\n\n# 3. Check monorepo structures\ngrep -r \"from 'package-name'\" projects/ packages/ apps/ 2>/dev/null\n\n# 4. Check usage in package.json scripts\ngrep \"package-name\" package.json\n\n# 5. Check if it's a peer dependency or used by other packages\nnpm ls package-name\n\n# Categorize as USED (keep) or UNUSED (remove)\n# Remove unused packages\nnpm uninstall unused-package1 unused-package2\n\n# Verify after removal\nnpm install && npm run build && npm test\n```\n\n**Directories and files to ALWAYS check:**\n| Location | Examples |\n|----------|----------|\n| Source code | `src/`, `lib/`, `app/` |\n| Tests | `tests/`, `test/`, `__tests__/`, `spec/` |\n| Scripts | `scripts/`, `extras/`, `tools/` |\n| Config files (root) | `*.config.ts`, `*.config.js`, `*.config.mjs` |\n| Build configs | `vite.config.*`, `webpack.config.*`, `rollup.config.*` |\n| Test configs | `jest.config.*`, `vitest.config.*` |\n| Lint/Format configs | `.eslintrc*`, `.prettierrc*`, `babel.config.*` |\n| Framework configs | `nuxt.config.*`, `next.config.*`, `nest-cli.json` |\n| TypeScript | `tsconfig.json`, `tsconfig.*.json` |\n| Monorepo | `projects/`, `packages/`, `apps/` |\n\n### Phase 2: Categorization Optimization (Priority 2)\n\n**Goal**: Move packages to devDependencies to minimize production footprint\n\n```bash\n# BEFORE MOVING: Check if package is used in src/\ngrep -r \"from 'package-name'\" src/\ngrep -r \"require('package-name')\" src/\n\n# If found in src/ ‚Üí MUST stay in dependencies\n# If NOT found in src/ ‚Üí Can be moved to devDependencies\n\n# Move packages\nnpm uninstall package-name\nnpm install --save-dev --save-exact package-name@version\n\n# Verify\nnpm install && npm run build && npm test\n```\n\n**MOVE TO devDependencies** (NOT used in src/):\n- Build tools: typescript, @nestjs/cli, ts-node\n- Testing frameworks: jest, supertest\n- Type definitions: @types/* (if not runtime required)\n- Linting/formatting: eslint, prettier\n- Development utilities: nodemon, rimraf\n- Packages used ONLY in scripts/, extras/, tests/, or config files\n\n**KEEP IN dependencies** (runtime-required OR used in src/):\n- ANY package imported/required in src/ (regardless of type)\n- Framework core packages\n- Runtime libraries\n- Production middleware\n\n### Phase 3: Update Discovery & Categorization (Priority 3)\n\n**Goal**: Identify all updateable packages\n\n**Use `ncu` (npm-check-updates) instead of `npm outdated`** - it shows the actual latest versions, not just those within semver ranges.\n\n```bash\n# Discover all update candidates (use npx for no global install required)\nnpx ncu\n\n# Or with grouping by update type (recommended)\nnpx ncu --format group\n\n# Check only specific target (patch/minor/major)\nnpx ncu --target patch   # Only patches\nnpx ncu --target minor   # Patches + minor\nnpx ncu --target latest  # All updates (default)\n```\n\nGroup packages into risk categories:\n\n**SAFE UPDATES** (patches, dev tools):\n- Patch versions: 5.8.3 ‚Üí 5.8.9\n- Development tools, type definitions\n- Update in batch, test after group\n\n**MEDIUM UPDATES** (minor versions):\n- Minor versions: 11.1.0 ‚Üí 11.2.0\n- Framework patches, testing tools\n- Update one-by-one, test each\n\n**HIGH RISK UPDATES** (major versions):\n- Major versions: 29.x ‚Üí 30.x\n- Framework majors, breaking API changes\n- Isolate, document, test thoroughly\n\n### Phase 4: Execute Updates\n\n#### Step 1: SAFE Updates (Batch)\n```bash\nnpm install package1@version package2@version --save-exact\nnpm run build && npm test\n```\n\n#### Step 2: MEDIUM Updates (One-by-One)\n```bash\nnpm install package@version --save-exact\nnpm run build && npm test\n```\n\n#### Step 3: HIGH RISK Updates (Isolated with CODE FIXES)\n\n**Attempt update, fix code if needed - don't give up immediately**\n\nCommon fixes:\n- Type errors: Add type assertions, update generics\n- API changes: Migrate service code, change imports\n- Method signatures: Refactor call sites\n\n**Only revert if**:\n1. Requires architectural migration (Express 5.x, ESM)\n2. Breaking changes affect >10 files\n3. Violates constraints (test modifications, API changes)\n\n**Git Recovery (Last Resort)**:\n```bash\n# Only if update is genuinely unfixable\ngit checkout HEAD -- package.json package-lock.json\nnpm install\n# Document WHY the update failed\n```\n\n### Phase 5: Security Hardening & Validation\n\n```bash\n# ALWAYS run after ANY package changes\nnpm audit fix\nnpm audit\n\n# Complete validation cycle\nnpm run build && npm test\n```\n\n### Phase 6: Override Cleanup (Priority 4)\n\n**Goal**: Remove unnecessary overrides that were added for security fixes but are no longer needed.\n\n```bash\n# 1. Check if overrides exist in package.json\ngrep -A 50 '\"overrides\"' package.json\n\n# 2. For each override, check if it's still necessary:\n```\n\n**For each override entry:**\n\n1. **Identify the override:**\n   ```json\n   \"overrides\": {\n     \"package-name\": \"^1.2.3\"\n   }\n   ```\n\n2. **Check if parent packages now include the fixed version:**\n   ```bash\n   # See which packages depend on the overridden package\n   npm ls package-name\n\n   # Check what version would be installed without the override\n   npm view parent-package dependencies\n   ```\n\n3. **Decision logic:**\n   - If ALL parent packages now require the fixed version ‚Üí **REMOVE override**\n   - If override was for security and `npm audit` shows no vulnerability ‚Üí **REMOVE override**\n   - If still needed for compatibility or security ‚Üí **KEEP override**\n\n4. **Remove unnecessary overrides:**\n   - Edit package.json to remove the override entry\n   - Run `npm install` to update package-lock.json\n   - Verify with `npm audit` that no new vulnerabilities appear\n   - Run `npm run build && npm test` to ensure compatibility\n\n**Override Removal Checklist:**\n```bash\n# After removing each override:\nnpm install\nnpm audit\nnpm run build && npm test\n\n# If any step fails, restore the override\n```\n\n### Phase 7: ITERATE Until Complete\n\n```bash\n# Check if more updates are available\nnpx ncu\n\n# If output shows updateable packages:\n# ‚Üí GO BACK TO PHASE 3 and repeat\n\n# Continue until ncu shows ONLY architectural blockers or is empty\n```\n\n**DO NOT STOP UNTIL**:\n- `npx ncu` shows zero updateable packages, OR\n- `npx ncu` shows ONLY packages blocked by architectural migrations\n\n### Phase 8: Final Verification (MANDATORY)\n\n```bash\n# MANDATORY: Final build and test verification\necho \"=== FINAL VERIFICATION (MUST PASS) ===\"\n\n# Clean build\nnpm run build\n# MUST exit with code 0 - NO EXCEPTIONS\n\n# Complete test suite\nnpm test\n# MUST pass ALL tests - NO EXCEPTIONS\n```\n\n**This is NON-NEGOTIABLE**: Cannot complete the task until both `npm run build` and `npm test` pass.\n\n### Phase 9: Artifact Cleanup\n\n**Goal**: Remove any temporary files created during the maintenance process (especially in `tests/` folder).\n\n```bash\n# Check for .txt files created during testing - especially in tests/ folder\nfind . -name \"*.txt\" -newer package.json -type f 2>/dev/null\nfind tests/ -name \"*.txt\" -type f 2>/dev/null\n\n# Also check for other common artifacts\nls -la *.log 2>/dev/null\nls -la npm-debug.log* 2>/dev/null\n```\n\n**For each artifact found:**\n1. Check if it existed before the maintenance process started (use git status)\n2. If it's an untracked file created during this process ‚Üí **DELETE it**\n3. If it's a pre-existing tracked file ‚Üí **KEEP it**\n\n```bash\n# Find untracked .txt and .log files (created during maintenance)\ngit status --short | grep \"^??\" | grep -E \"\\.(txt|log)$\"\n\n# Common locations for test artifacts:\n# - tests/*.txt (test output files)\n# - Root folder: npm-debug.log, *.txt error logs\n\n# Delete untracked artifacts\nrm -f tests/*.txt 2>/dev/null\nrm -f *.txt npm-debug.log* 2>/dev/null\n```\n\n**Do NOT delete:**\n- Files that are tracked by git (use `git ls-files` to check)\n- README.txt or other intentional documentation\n- Test fixture files that are part of the test suite\n\n## Update Decision Framework\n\n```\nFor each outdated package:\n\n1. What type of update? (patch/minor/major)\n   - Patch ‚Üí SAFE group (batch update)\n   - Minor ‚Üí MEDIUM group (individual update)\n   - Major ‚Üí HIGH RISK group (isolated update)\n\n2. Check compatibility constraints\n   - Does it affect known compatibility chains?\n   - Does it require architectural changes?\n\n3. Execute update with appropriate strategy\n\n4. If update fails:\n   - Can we fix with type changes? ‚Üí FIX IT\n   - Can we fix API migration? ‚Üí FIX IT\n   - Can we fix method signatures? ‚Üí FIX IT\n   - Requires architecture migration? ‚Üí Document blocker, revert\n   - Breaks >10 files? ‚Üí Document blocker, revert\n   - Violates constraints? ‚Üí Document blocker, revert\n\n5. Document outcome\n```\n\n## Output Format\n\nProvide comprehensive report after all optimizations:\n\n```markdown\n## Package Ecosystem Optimization Report\n\n### Baseline Status (BEFORE)\n- Git commit: abc1234\n- Tests: X/Y passing\n- Build: ‚úÖ\n- Vulnerabilities: N\n- Total packages: X (Y dependencies + Z devDependencies)\n- Outdated packages: N\n\n### Phase 1: Package Removal\n- Packages analyzed: X\n- Packages removed: Y\n  [List with removal reasons]\n**Result**: Build ‚úÖ, Tests ‚úÖ\n\n### Phase 2: Categorization Optimization\n- Packages moved to devDependencies: X\n  [List with reasons]\n**Result**: Build ‚úÖ, Tests ‚úÖ\n\n### Phase 3 & 4: Package Updates\n\n#### SAFE Updates (Batch) - ‚úÖ X packages\n[List]\n**Result**: Build ‚úÖ, Tests ‚úÖ\n\n#### MEDIUM Updates (Individual) - ‚úÖ X packages\n[List with individual results]\n\n#### HIGH RISK Updates (Attempted) - ‚ö†Ô∏è X packages\n[List with outcomes and code fixes applied]\n\n#### BLOCKED Updates (Architecture Changes) - üî¥ X packages\n[List with blocker reasons and retry guidance]\n\n### Phase 6: Override Cleanup\n- Overrides analyzed: X\n- Overrides removed: Y\n  [List with reasons why no longer needed]\n- Overrides kept: Z\n  [List with reasons why still required]\n**Result**: Build ‚úÖ, Tests ‚úÖ, Audit ‚úÖ\n\n### Phase 9: Artifact Cleanup\n- Temporary files found: X\n- Files deleted: Y\n  [List of deleted files, e.g., tests/*.txt, npm-debug.log]\n- Files kept: Z (tracked or intentional)\n\n### Final Status (AFTER)\n- Tests: X/Y passing (100%) ‚úÖ\n- Build: ‚úÖ\n- Vulnerabilities: 0 ‚úÖ\n- Updated: X/Y packages (Z%)\n- Blocked: X/Y packages (documented)\n\n### Summary Statistics\n- Total outdated: X packages\n- Successfully updated: Y packages (Z%)\n  - SAFE: X\n  - MEDIUM: Y\n  - HIGH RISK: Z\n- Blocked (documented): N packages\n\n### Recommendations\n**Short-term**: [Immediate actions]\n**Medium-term**: [Planned migrations]\n**Monitoring**: [Regular checks needed]\n```\n\n## Self-Verification Checklist\n\nBefore declaring success, verify ALL of these:\n\n### Priority 1: Package Minimization\n- [ ] Analyzed ALL packages for usage in ALL locations:\n  - [ ] Source directories (src/, lib/, app/)\n  - [ ] Test directories (tests/, test/, __tests__/, spec/)\n  - [ ] Script directories (scripts/, extras/, tools/)\n  - [ ] Root-level config files (*.config.ts, *.config.js, vite.config.*, etc.)\n  - [ ] Monorepo directories (projects/, packages/, apps/)\n- [ ] Removed ALL unused packages\n- [ ] Verified build & tests pass\n\n### Priority 2: Categorization Optimization\n- [ ] Identified ALL packages for devDependencies\n- [ ] Moved ALL development-only packages\n- [ ] Verified build & tests pass\n\n### Priority 3: Package Updates\n- [ ] Ran `npx ncu` to discover ALL candidates (shows actual latest versions)\n- [ ] Categorized packages into SAFE/MEDIUM/HIGH RISK\n- [ ] Attempted updates for ALL categories\n- [ ] Minimized code changes (preferred updates without modifications)\n- [ ] Fixed code strategically when value justified\n- [ ] ITERATED: Ran `npx ncu` again after successful updates\n- [ ] CONTINUED ITERATING until no more fixable updates\n- [ ] Documented ALL blocked updates with reasons\n\n### Priority 4: Override Cleanup\n- [ ] Checked for existing overrides in package.json\n- [ ] Analyzed each override for necessity\n- [ ] Removed overrides where parent packages now include fixed versions\n- [ ] Removed overrides where security issue is resolved\n- [ ] Verified `npm audit` shows no new vulnerabilities after removal\n- [ ] Kept only truly necessary overrides with documentation\n\n### Universal Requirements\n- [ ] All versions are exact (no ^, ~, or ranges)\n- [ ] No test files modified (except unavoidable)\n- [ ] No API signatures changed\n- [ ] `npm run build` passes (exit code 0)\n- [ ] `npm test` passes (all tests green)\n- [ ] `npm audit` shows 0 vulnerabilities\n- [ ] Source code changes minimized\n- [ ] Final `npx ncu` shows only blockers or empty\n- [ ] Temporary artifacts (.txt, .log files) cleaned up\n\n## Key Principles\n\n1. **Minimize Packages First**: Remove unused (highest priority)\n2. **Check ALL Locations**: Config files, monorepos, tests - not just src/\n3. **Optimize Categorization Second**: Move to devDependencies\n4. **Maximize Updates Third**: Update with minimal code changes\n5. **Test Integrity is Sacred**: Never compromise passing tests\n6. **API Stability is Critical**: Never change function signatures\n7. **Minimize Source Changes**: Prefer updates without modifications\n8. **Security is Non-Negotiable**: Always run `npm audit fix`\n9. **Fix Code Strategically**: Type/API fixes acceptable when justified\n10. **Iterate Until Complete**: Run `npx ncu` and continue\n11. **Git is Recovery Tool**: Use for unfixable updates, not to avoid fixing\n12. **Document Blockers**: Only architectural blockers need documentation\n13. **Batch SAFE**: Group low-risk updates\n14. **Isolate HIGH RISK**: Test thoroughly, fix code when possible\n15. **Balance Value vs. Cost**: Don't make extensive changes for minor updates\n16. **Transparency**: Report all attempts, fixes, successes, and blockers\n\n**Success is measured by**:\n1. How many packages you removed (not kept)\n2. How many packages you moved to devDependencies (not left in dependencies)\n3. How many packages you updated with minimal/no code changes\n4. How many unnecessary overrides you removed\n5. Whether source code changes were kept to minimum\n\n**Your job priorities**:\n1. Remove ALL unused packages first\n2. Optimize categorization second\n3. Update remaining packages third\n4. Cleanup unnecessary overrides fourth\n5. Only stop when all four goals are exhausted\n",
        "plugins/lt-dev/commands/backend/code-cleanup.md": "---\ndescription: Clean up and optimize code quality\nallowed-tools: Read, Grep, Glob, Edit, Bash(npm run build:*), Bash(npm run lint:*), Bash(git diff:*), Bash(git status:*)\n---\n\n# Code Cleanup\n\n## When to Use This Command\n\n- After completing a feature implementation\n- Before creating a merge request\n- When preparing for code review\n- To enforce consistent code style across modified files\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:backend:sec-review` | Security review of code changes |\n| `/lt-dev:backend:test-generate` | Generate tests for changes |\n\n**Recommended workflow:** `test-generate` ‚Üí `sec-review` ‚Üí `code-cleanup`\n\n---\n\nPerform a complete code cleanup:\n\n##  1. Import Optimization\n\nFor all modified TypeScript files:\n- [ ] Sort imports alphabetically\n- [ ] Grouping: External ‚Üí @lenne.tech ‚Üí Local\n- [ ] Remove unused imports\n- [ ] Remove duplicate imports\n\n## üî§ 2. Property Ordering\n\nFor all Model/Input/Object files:\n- [ ] Sort properties alphabetically\n- [ ] Decorators consistently ordered\n- [ ] Same order in Model, CreateInput, UpdateInput\n\n##  3. Description Management\n\nCheck all descriptions:\n- [ ] Format: \"ENGLISH (DEUTSCH)\" for German terms\n- [ ] Format: \"ENGLISH\" for English terms\n- [ ] Consistency: Same description in Model + Inputs\n- [ ] Class-level descriptions present (@ObjectType, @InputType)\n- [ ] No missing descriptions\n\n##  4. Code Refactoring\n\nSearch for duplicated code:\n- [ ] Is code repeated 2+ times?\n- [ ] Can it be extracted into private methods?\n- [ ] Are similar code paths consolidatable?\n- [ ] Helper functions useful?\n\n## üßπ 5. Debug Code Removal\n\nRemove development code:\n- [ ] All console.log() statements\n- [ ] All console.debug/warn/error (except production logging)\n- [ ] Commented-out code\n- [ ] Review TODO/FIXME comments\n\n##  6. Formatting\n\nCheck code formatting:\n- [ ] Consistent indentation (2 or 4 spaces)\n- [ ] No extra blank lines\n- [ ] Add missing blank lines between sections\n- [ ] Remove trailing whitespace\n\n##  7. Build & Lint\n\nRun automatic checks:\n```bash\n# TypeScript Compilation\nnpm run build\n\n# Linting\nnpm run lint\n\n# Optional: Auto-Fix\nnpm run lint:fix\n```\n\nFix all errors and warnings!\n\n##  Final Check\n\n- [ ] All imports optimized\n- [ ] All properties sorted\n- [ ] All descriptions correct\n- [ ] Code refactored (DRY)\n- [ ] Debug code removed\n- [ ] Build successful\n- [ ] Lint successful\n- [ ] Tests still passing\n\n**Only when everything is : Cleanup completed!**\n",
        "plugins/lt-dev/commands/backend/sec-audit.md": "---\ndescription: Comprehensive OWASP security audit - analyzes dependencies, configuration, and code patterns for vulnerabilities\nallowed-tools: Bash, Read, Grep, Glob, Write\nargument-hint: [--full | --deps-only | --config-only | --code-only]\n---\n\n# OWASP Security Audit\n\nPerform a comprehensive security audit based on OWASP Secure Coding Practices.\n\n## Audit Modes\n\n| Mode | Description |\n|------|-------------|\n| `--full` (default) | Complete audit of all areas |\n| `--deps-only` | Only check npm dependencies |\n| `--config-only` | Only check configuration files |\n| `--code-only` | Only check code patterns |\n\n## Audit Process\n\nExecute the following audit steps and generate a structured report.\n\n### 1. Dependency Analysis\n\n```bash\n# Run npm audit\nnpm audit --json > /tmp/npm-audit.json 2>/dev/null || true\nnpm audit\n\n# Check for outdated packages\nnpm outdated\n\n# List all dependencies\nnpm list --depth=0\n```\n\n**Check for:**\n- Known vulnerabilities (CVE)\n- Deprecated packages\n- Outdated security-critical packages (bcrypt, helmet, etc.)\n\n### 2. Configuration Analysis\n\nSearch for configuration files and check security settings:\n\n**Files to analyze:**\n- `main.ts` - Application bootstrap, Helmet, CORS, ValidationPipe\n- `.env` / `.env.example` - Environment variables (no secrets in example!)\n- `nest-cli.json` - Build configuration\n- `tsconfig.json` - TypeScript strict mode\n- Docker/deployment configs\n\n**Check for:**\n\n| Area | Expected | Risk if Missing |\n|------|----------|-----------------|\n| Helmet | `app.use(helmet())` | Missing security headers |\n| CORS | Explicit origins, not `*` | Cross-origin attacks |\n| ValidationPipe | `whitelist: true, forbidNonWhitelisted: true` | Mass assignment |\n| Rate Limiting | `ThrottlerModule` configured | DoS attacks |\n| HTTPS redirect | Enabled in production | Data interception |\n\n### 3. Code Pattern Analysis\n\nSearch for anti-patterns and vulnerabilities:\n\n**Critical Patterns to Find:**\n\n```typescript\n// 1. Hardcoded secrets\npattern: /(secret|password|api.?key|token)\\s*[:=]\\s*['\"][^'\"]+['\"]/i\n\n// 2. Unsafe eval/Function\npattern: /eval\\(|new\\s+Function\\(/\n\n// 3. SQL/NoSQL injection risks\npattern: /\\$where|\\.find\\(\\{.*\\$|`.*\\${/\n\n// 4. Missing input validation\npattern: /@(Body|Query|Param)\\([^)]*\\)\\s+\\w+:\\s+any/\n\n// 5. Exposed sensitive fields\npattern: /@UnifiedField\\([^)]*\\)\\s+password|@UnifiedField\\([^)]*\\)\\s+secret/\n\n// 6. Disabled security decorators\npattern: /\\/\\/\\s*@Restricted|\\/\\/\\s*@Roles/\n\n// 7. Unsafe file operations\npattern: /path\\.join\\([^)]*req\\.|fs\\.(readFile|writeFile)\\([^)]*req\\./\n```\n\n### 4. Authentication & Authorization Check\n\nSearch and analyze:\n- All `@Restricted` and `@Roles` decorators\n- JWT configuration (expiry, secret strength)\n- Password hashing (bcrypt cost factor)\n- Session/token management\n\n### 5. OWASP Checklist Validation\n\nCross-reference with `owasp-checklist.md`:\n\n| Category | Items to Verify |\n|----------|----------------|\n| Input Validation | ValidationPipe, DTOs, class-validator |\n| Output Encoding | HTML sanitization, response filtering |\n| Authentication | bcrypt, JWT config, password policy |\n| Session Management | Token expiry, refresh tokens |\n| Access Control | Guards, decorators, ownership checks |\n| Cryptography | Secure random, no weak algorithms |\n| Error Handling | No stack traces in prod, logging |\n| Data Protection | hideField, encryption at rest |\n| Communication | HTTPS, HSTS, secure headers |\n| Database | Parameterized queries, connection security |\n| File Management | Upload validation, path traversal |\n\n## Report Structure\n\nGenerate a markdown report with the following structure:\n\n```markdown\n# Security Audit Report\n\n**Date:** [Current Date]\n**Project:** [Project Name]\n**Auditor:** Claude Code Security Audit\n\n## Executive Summary\n\n- **Risk Level:** [Critical/High/Medium/Low]\n- **Vulnerabilities Found:** [Count]\n- **Configuration Issues:** [Count]\n- **Recommendations:** [Count]\n\n## Findings\n\n### Critical\n\n| # | Finding | Location | Recommendation |\n|---|---------|----------|----------------|\n| 1 | ... | ... | ... |\n\n### High\n\n...\n\n### Medium\n\n...\n\n### Low\n\n...\n\n## Dependency Audit\n\n| Package | Severity | Vulnerability | Fix |\n|---------|----------|---------------|-----|\n| ... | ... | ... | ... |\n\n## Configuration Analysis\n\n| Setting | Status | Recommendation |\n|---------|--------|----------------|\n| Helmet | ‚úÖ/‚ùå | ... |\n| CORS | ‚úÖ/‚ùå | ... |\n| ... | ... | ... |\n\n## Code Analysis\n\n### Anti-Patterns Found\n\n...\n\n### Security Decorators\n\n...\n\n## Recommendations\n\n1. **Immediate:** [Critical fixes]\n2. **Short-term:** [High priority improvements]\n3. **Long-term:** [Best practice implementations]\n\n## OWASP Compliance\n\n| Category | Status | Coverage |\n|----------|--------|----------|\n| Input Validation | ‚úÖ/‚ö†Ô∏è/‚ùå | X% |\n| ... | ... | ... |\n```\n\n## When to Use\n\n- Before production deployments\n- After major dependency updates\n- During security-focused code reviews\n- As part of regular security maintenance\n- When onboarding new security requirements\n\n## Related Commands\n\n- `/lt-dev:backend:sec-review` - Quick security review of code changes\n- `/lt-dev:maintenance:maintain-security` - Security-focused package updates\n\n## Post-Audit Actions\n\nAfter generating the report:\n\n1. **Critical findings:** Fix immediately before deployment\n2. **High findings:** Plan fixes within current sprint\n3. **Medium findings:** Add to backlog with priority\n4. **Low findings:** Document for future consideration\n\nSave the report to `docs/security-audit-[date].md` for tracking.\n",
        "plugins/lt-dev/commands/backend/sec-review.md": "---\ndescription: Perform security review of code changes\nallowed-tools: Read, Grep, Glob, Bash(git diff:*)\n---\n\n# Security Review\n\n## When to Use This Command\n\n- After implementing new endpoints or modifying existing ones\n- Before merging changes that affect authentication or authorization\n- When reviewing code that handles sensitive data\n- As part of a pre-release security check\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:backend:code-cleanup` | Clean up code style and formatting |\n| `/lt-dev:backend:test-generate` | Generate tests for changes |\n\n**Recommended workflow:** `test-generate` ‚Üí `sec-review` ‚Üí `code-cleanup`\n\n---\n\nPerform a complete security review:\n\n##  1. Controller/Resolver Security\n\nCheck all modified Controller/Resolver files:\n- [ ] Were @Restricted decorators removed or weakened?\n- [ ] Were @Roles decorators made more permissive?\n- [ ] Are there new endpoints without security decorators?\n- [ ] Are the roles appropriate (not too open)?\n\n##  2. Model Security\n\nCheck all modified Model files:\n- [ ] Is securityCheck() method correctly implemented?\n- [ ] Admin check: `user?.hasRole(RoleEnum.ADMIN)`\n- [ ] Creator check: `equalIds(user, this.createdBy)`\n- [ ] Were security checks weakened?\n- [ ] Are sensitive properties protected with @Restricted?\n\n##  3. Input Validation\n\nCheck all Input/DTO files:\n- [ ] Are all inputs validated?\n- [ ] Required fields correctly marked?\n- [ ] Type safety ensured?\n- [ ] No unsafe data types (e.g., any)?\n\n##  4. Ownership & Authorization\n\nCheck service methods:\n- [ ] Update/Delete: Ownership checks present?\n- [ ] Check: `userId === object.createdBy` OR `user.isAdmin`\n- [ ] serviceOptions.roles correctly set?\n- [ ] No authorization bypasses?\n\n##  5. Data Exposure\n\nCheck GraphQL/REST responses:\n- [ ] Sensitive fields marked with `hideField: true`?\n- [ ] Passwords/Tokens not in responses?\n- [ ] securityCheck() filters correctly?\n\n##  6. Test Coverage\n\nCheck tests:\n- [ ] Security failure tests present (403 responses)?\n- [ ] Tests with different roles (Admin, User, Other)?\n- [ ] Ownership tests present?\n\n##  Report\n\nCreate a list of all findings:\n- **Critical**: Severe security issues\n- **Warning**: Potential problems\n- **Info**: Improvement suggestions\n- **OK**: Everything secure\n\n**On Critical/Warning findings: STOP and inform the developer!**\n",
        "plugins/lt-dev/commands/backend/test-generate.md": "---\ndescription: Generate comprehensive tests for changes\nallowed-tools: Read, Grep, Glob, Edit, Write, Bash(npm run test:*), Bash(npm test:*), Bash(git diff:*), Bash(git status:*)\n---\n\n# Generate Tests\n\n## When to Use This Command\n\n- After creating new modules or modifying existing ones\n- When test coverage is missing for recent changes\n- Before merging to ensure adequate test coverage\n- To generate security tests for new endpoints\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:backend:sec-review` | Security review of code changes |\n| `/lt-dev:backend:code-cleanup` | Clean up code style and formatting |\n\n**Recommended workflow:** `test-generate` ‚Üí `sec-review` ‚Üí `code-cleanup`\n\n---\n\nAnalyze recent changes and create appropriate tests:\n\n1. **Identify all changed/new modules**:\n   ```bash\n   git status --short\n   git diff --name-only\n   ```\n\n2. **For each new module** in `src/server/modules/`:\n   - Create E2E test in `tests/modules/<module-name>.e2e-spec.ts`\n   - Analyze existing tests as templates\n   - Fully understand TestHelper (read source code)\n\n3. **For each modified module**:\n   - Update existing test in `tests/modules/`\n   - Test new/changed properties\n   - Test changed validations\n\n4. **Security Testing**:\n   - Check @Restricted/@Roles decorators\n   - Test with Admin User (user.roles contains 'admin')\n   - Test with Creator (user.id === object.createdBy)\n   - Test with Other User (should fail with 403)\n   - Test permission failures\n\n5. **Test Execution**:\n   ```bash\n   npm run test:e2e\n   ```\n   - On errors: Debug with console.log\n   - Fix errors\n   - Re-run tests\n\n6. **Cleanup**:\n   - Remove all console.log statements\n   - Verify tests still pass\n\n**Important:**\n- NEVER weaken @Restricted/@Roles to fix tests\n- ALWAYS test with least privileged user\n- ALWAYS follow existing test patterns\n",
        "plugins/lt-dev/commands/backend/update-nest-server.md": "---\ndescription: Update @lenne.tech/nest-server to latest version with automated migration, validation, and package optimization\nargument-hint: \"[--dry-run] [--target-version X.Y.Z] [--skip-packages] [path]\"\nallowed-tools: Task\n---\n\n# Update @lenne.tech/nest-server\n\nFully automated update of @lenne.tech/nest-server with migration guide support.\n\n## Usage\n\n```\n/lt-dev:backend:update-nest-server [options] [path]\n```\n\n## Options\n\n| Option | Description |\n|--------|-------------|\n| `--dry-run` | Analysis only - show what would change without making modifications |\n| `--target-version X.Y.Z` | Update to specific version instead of latest |\n| `--skip-packages` | Skip npm-package-maintainer optimization step |\n| `[path]` | Target directory for monorepo subprojects (default: current directory) |\n\n## Examples\n\n```bash\n# Full update to latest version\n/lt-dev:backend:update-nest-server\n\n# Check what would change (no modifications)\n/lt-dev:backend:update-nest-server --dry-run\n\n# Update to specific version\n/lt-dev:backend:update-nest-server --target-version 12.0.0\n\n# Update specific subproject in monorepo\n/lt-dev:backend:update-nest-server projects/api\n\n# Combine options\n/lt-dev:backend:update-nest-server --dry-run --target-version 12.0.0\n\n# Fast update without package optimization\n/lt-dev:backend:update-nest-server --skip-packages\n```\n\n## What This Command Does\n\n1. **Version Analysis** - Detects current version, determines update path\n2. **Migration Guide Loading** - Fetches all relevant guides from nest-server repo\n3. **Stepwise Major Updates** - Updates through each major version (e.g., 17‚Üí18‚Üí19)\n4. **Code Migration** - Applies breaking change migrations automatically\n5. **Package Optimization** - Runs npm-package-maintainer (unless `--skip-packages`)\n6. **Validation Loop** - Iterates build/lint/test until all pass\n7. **Report Generation** - Documents all changes and migrations\n\n## Related Elements\n\n| Element | Purpose |\n|---------|---------|\n| **Skill**: `nest-server-updating` | Knowledge base for troubleshooting |\n| **Agent**: `lt-dev:nest-server-updater` | Execution engine (spawned by this command) |\n| **Command**: `/lt-dev:maintenance:maintain` | General package maintenance |\n\n## When to Use\n\n| Scenario | Command |\n|----------|---------|\n| Routine update to latest | `/lt-dev:backend:update-nest-server` |\n| Check impact before updating | `/lt-dev:backend:update-nest-server --dry-run` |\n| Update to specific version | `/lt-dev:backend:update-nest-server --target-version 12.0.0` |\n| Quick update without package check | `/lt-dev:backend:update-nest-server --skip-packages` |\n\n---\n\n**Spawn the nest-server-updater agent:**\n\nUse the Task tool to spawn the `lt-dev:nest-server-updater` agent with the following prompt:\n\n```\nUpdate @lenne.tech/nest-server in this project.\n\nArguments: $ARGUMENTS\n\nParse the arguments for:\n- --dry-run: If present, only analyze and report without making changes\n- --target-version X.Y.Z: If present, update to this specific version\n- --skip-packages: If present, skip npm-package-maintainer optimization\n- Any remaining argument is the target directory path\n\nExecute the update workflow according to the detected mode.\nWork fully autonomously without asking questions.\n```\n",
        "plugins/lt-dev/commands/create-story.md": "---\ndescription: Create a user story for TDD implementation\nargument-hint: \"[optional: initial story idea]\"\nallowed-tools: AskUserQuestion, Write, Read, Glob, mcp__plugin_lt-dev_linear__*, Skill\n---\n\n# User Story erstellen\n\nGuide the user through creating a well-structured user story that can be used as a prompt for Claude Code to implement with Test-Driven Development (TDD).\n\n## When to Use This Command\n\n- Planning and documenting new features\n- Preparing user stories for TDD implementation\n- Capturing requirements in a structured format\n- Creating stories for Linear tickets or documentation\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:fix-issue` | Work on an existing Linear issue |\n\n**Workflow:** Create story ‚Üí Save to Linear ‚Üí `/lt-dev:fix-issue` to implement\n\n**IMPORTANT: The generated story and all user-facing communication must ALWAYS be in German, regardless of the user's input language. Exceptions: Properties (camelCase), code snippets, and technical terms remain in English.**\n\n**ABORT HANDLING: If the user wants to cancel at any point (e.g., \"abbrechen\", \"stop\", \"cancel\", \"nicht mehr\"), acknowledge it (in German): \"Okay, Story-Erstellung abgebrochen.\" and stop the process.**\n\n---\n\n## Guidelines for Good Stories\n\nKeep these guidelines in mind when generating the story:\n\n### INVEST Criteria (Quality Check)\n\nEvery story should be checked against these criteria:\n\n- **Independent** - Can be implemented without depending on other stories\n- **Negotiable** - Open for discussion and refinement\n- **Valuable** - Delivers real, tangible value to the user (not just technical tasks)\n- **Small** - Completable within a single sprint (if too large, suggest splitting)\n- **Testable** - Has measurable acceptance criteria\n\n### 3C Model\n\n- **Card** - Concise title that fits on a notecard\n- **Conversation** - Story emerges from dialogue (Gap Analysis enables this)\n- **Confirmation** - Clear acceptance criteria define \"done\"\n\n### Emotional Narrative\n\nThe story should convey the **user's emotional experience**, not just technical functionality. Ask \"Why does this matter to the user?\" - use the **5 Whys technique** if the reason is unclear.\n\n### Title\n\n- Keep short (max 10 words)\n- Format: \"[Rolle] m√∂chte [Feature], damit [Kurze Begr√ºndung]\"\n\n### Acceptance Criteria\n\n- Aim for **4-8 criteria** per story\n- Start with action verbs (kann, soll, muss)\n- Be specific and measurable - focus on *what*, not *how*\n- Include both positive and negative cases\n- Consider: authentication, authorization, validation, persistence\n- **Optional Gherkin format** for complex criteria:\n  ```\n  Gegeben [Ausgangssituation]\n  Wenn [Aktion]\n  Dann [Erwartetes Ergebnis]\n  ```\n\n### Properties\n\n- **Only include if user explicitly specifies them** - do not auto-generate\n- Use camelCase for property names\n- Provide BOTH English AND German descriptions\n- Specify relationships clearly (e.g., \"Referenz auf User-Entit√§t\")\n\n### For TDD\n\n- Each acceptance criterion becomes at least one test\n- Consider edge cases that need explicit tests\n- Think about security tests (permission-denied scenarios)\n\n---\n\n## Step 1: Collect Initial Thoughts\n\n**Check for argument:** If the user provided an initial idea as argument (e.g., `/lt-dev:create-story \"FAQ Feature\"`), use that as starting point and skip directly to Step 2.\n\n**If no argument provided:** Output the following prompt in German and wait for user response:\n\n> Bitte beschreibe deine User Story Idee. Teile so viele Details wie m√∂glich mit:\n> - Wer braucht dieses Feature (Rolle/Nutzertyp)?\n> - Was soll erreicht werden?\n> - Warum wird es ben√∂tigt?\n> - Spezifische Anforderungen oder Properties?\n> - Technische Hinweise?\n>\n> Schreib einfach deine Gedanken auf - ich helfe dir, sie in eine strukturierte User Story zu bringen.\n\n**Wait for the user's response before proceeding to Step 2.**\n\n---\n\n## Step 2: Analyze and Identify Gaps\n\nAfter receiving the user's input, analyze it against this checklist:\n\n### Required Elements Checklist\n\n**Basic Story Elements:**\n- [ ] **Role** - Who is the user? (Admin, Customer, Guest, etc.)\n- [ ] **Feature** - What do they want to achieve?\n- [ ] **Reason** - Why do they need this? What's the benefit?\n\n**Description Details:**\n- [ ] **Context** - Background information, which system/module?\n- [ ] **Requirements** - Specific functional requirements\n- [ ] **Properties** (optional) - Data fields with types (if applicable)\n- [ ] **Notes** (optional) - Technical hints, constraints, special logic\n\n**Quality Criteria:**\n- [ ] **Acceptance Criteria** - Testable conditions for success\n- [ ] **Security Considerations** - Who can access/modify? (permissions)\n- [ ] **Edge Cases** - What happens in special situations?\n\n### Gap Analysis\n\nFor each missing or unclear element, formulate a **specific question in German** using the AskUserQuestion tool:\n\n**Fehlende Rolle:**\n- \"Wer wird dieses Feature nutzen? (z.B. Admin, Kunde, Gast, Entwickler)\"\n\n**Fehlendes Feature/Ziel:**\n- \"Was genau soll der Nutzer tun k√∂nnen?\"\n\n**Fehlende Begr√ºndung:**\n- \"Welchen Nutzen bringt dieses Feature? Welches Problem l√∂st es?\"\n\n**Fehlende Properties (only ask if the feature involves data entities):**\n- \"Welche Daten m√ºssen gespeichert werden? Bitte liste die Properties mit ihren Typen auf (string, number, boolean, Date, enum, Referenz)\"\n\n**Fehlende Akzeptanzkriterien:**\n- \"Wie k√∂nnen wir √ºberpr√ºfen, dass das Feature funktioniert? Was sind die Erfolgsbedingungen?\"\n\n**Unklare Sicherheit:**\n- \"Wer soll Zugriff auf dieses Feature haben? Gibt es Berechtigungseinschr√§nkungen?\"\n\n**Fehlende Edge Cases:**\n- \"Gibt es Sonderf√§lle zu beachten? Was soll passieren, wenn [konkretes Szenario]?\"\n\n### Questioning Strategy\n\n1. **Ask only about missing/unclear elements** - Don't ask for information already provided\n2. **Be specific** - Reference what was said and ask for clarification\n3. **Group related questions** - Ask 2-4 questions at once, not one by one\n4. **Suggest improvements** - If something seems incomplete, suggest additions\n5. **Accept refusal gracefully** - If the user refuses to answer or provides no input, accept it and make the best of available information\n\n**Example question (in German):**\n\"Deine Story-Idee ist klar bez√ºglich des Grundfeatures. Ich brauche noch ein paar Details:\n1. Du hast erw√§hnt, dass Admins Items verwalten k√∂nnen - k√∂nnen G√§ste sie auch sehen?\n2. Sollen die Items eine bestimmte Reihenfolge/Position haben?\n3. Was passiert, wenn jemand versucht, ein Item zu l√∂schen, das anderswo referenziert wird?\"\n\n**If user refuses or skips questions:**\n- Accept the decision without pushing further\n- **Proactively suggest reasonable completions** based on context and common patterns\n- Present suggestions to the user for confirmation before including them\n- Proceed with available information after user confirmation\n\n### Proactive Suggestion Strategy\n\nWhen the user doesn't provide information for certain areas, **don't just leave gaps** - actively suggest sensible completions:\n\n**For missing Role:**\n- Analyze the feature context to infer the most likely user role\n- Suggest: \"Da es um Verwaltungsfunktionen geht, nehme ich an, dass ein **Admin** diese nutzen soll. Passt das?\"\n\n**For missing Reason/Benefit:**\n- Derive the benefit from the feature's purpose\n- Suggest: \"Der Nutzen k√∂nnte sein: **damit Besucher schnell Antworten auf h√§ufige Fragen finden**. Soll ich das so √ºbernehmen?\"\n\n**For missing Properties:**\n- **Do NOT automatically suggest properties** if the user hasn't specified any\n- Only include properties in the story if the user explicitly provides them\n- If the user mentions data fields vaguely, ask for clarification: \"Du hast [Datenfeld] erw√§hnt. M√∂chtest du die Properties genauer spezifizieren, oder soll das der Implementierung √ºberlassen werden?\"\n- If the user declines to specify properties, omit the Properties section entirely - the implementation agent will determine appropriate properties based on the requirements\n\n**For missing Acceptance Criteria:**\n- Generate standard criteria based on the feature type (CRUD ‚Üí list, create, read, update, delete permissions)\n- Suggest: \"Ich schlage folgende Akzeptanzkriterien vor: [Liste]. M√∂chtest du welche anpassen oder erg√§nzen?\"\n\n**For missing Security/Permissions:**\n- Suggest common permission patterns based on the role\n- Suggest: \"Ich w√ºrde vorschlagen: **Admins haben vollen Zugriff, G√§ste k√∂nnen nur lesen**. Ist das korrekt?\"\n\n**For missing Edge Cases:**\n- Suggest typical edge cases for the feature type\n- Suggest: \"M√∂gliche Edge Cases w√§ren: Was passiert bei leeren Eingaben? Bei Duplikaten? Bei L√∂schung referenzierter Daten?\"\n\n**Suggestion Format (in German):**\n\"F√ºr [Bereich] schlage ich vor: **[konkreter Vorschlag]**. Passt das so, oder m√∂chtest du etwas √§ndern?\"\n\n**Important:**\n- Always present suggestions as proposals, not decisions\n- Let the user confirm, modify, or reject each suggestion\n- If the user confirms with just \"ja\", \"ok\", \"passt\", accept the suggestion and proceed\n- **Integrate confirmed suggestions directly into the story** - the final story should only contain definitive requirements, not assumptions or proposals\n- The user should be able to review the complete story and request changes before finalizing\n\n---\n\n## Step 3: Validate Completeness\n\nOnce all information is gathered, perform a final validation:\n\n### INVEST Check\n\n- **Independent:** Does this story depend on other stories? If yes, note dependencies or suggest splitting.\n- **Valuable:** Is the user value clear? If the \"damit\" part is weak, use 5 Whys to dig deeper:\n  - \"Warum ist das wichtig?\" ‚Üí Answer ‚Üí \"Und warum ist das wichtig?\" ‚Üí repeat until real value emerges\n- **Small:** Can this be completed in one sprint? If too large, suggest splitting into smaller stories (in German):\n  - \"Diese Story scheint recht umfangreich. Sollen wir sie in kleinere Stories aufteilen?\"\n- **Testable:** Are all acceptance criteria measurable and verifiable?\n\n### Coherence Check\n- Does the feature make sense as described?\n- Are the requirements internally consistent?\n- Do the acceptance criteria cover all requirements (aim for 4-8)?\n- Are there any contradictions?\n\n### Emotional Value Check\n- Does the story convey why this matters to the user?\n- Is it more than just a technical task?\n- If the narrative feels dry, ask (in German): \"Was ist der eigentliche Nutzen f√ºr den Anwender? Welches Problem wird gel√∂st?\"\n\n### TDD Readiness Check\n- Can each acceptance criterion be converted to a test?\n- Are the properties clear enough for implementation?\n- Is the security model defined?\n\n**If issues found:** Ask clarifying questions (in German) before proceeding.\n\n**If complete:** Proceed to Step 4.\n\n---\n\n## Step 4: Generate and Present Story\n\nGenerate the complete user story in the standard format and **present it to the user first**.\n\n**Display the story in a clearly marked code block** so the user can:\n- Review and discuss the story\n- Request changes or optimizations\n- Copy it if needed\n\nAfter presenting the story, ask (in German): \"Ist die Story so in Ordnung, oder m√∂chtest du noch etwas anpassen?\"\n\n**If changes requested:** Make the adjustments and present the updated story again.\n\n**If approved:** Proceed to Step 5 (Ask for Output Format).\n\n### Story Format (German)\n\n```markdown\n# [Titel - Rolle m√∂chte Feature, damit Begr√ºndung]\n\n**Story:** Als [Rolle] m√∂chte ich [Feature], damit [Begr√ºndung].\n\n## Beschreibung\n\n[Ausf√ºhrliche Beschreibung]\n\n### Kontext\n[Hintergrund und Systemkontext]\n\n### Anforderungen\n[Liste der spezifischen Anforderungen]\n\n### Properties (optional - nur wenn vom Nutzer explizit angegeben)\n\n| Property   | Type   | Required | Description (EN)   | Beschreibung (DE)    |\n|------------|--------|----------|--------------------|----------------------|\n| example    | string | yes      | Example property   | Beispiel-Eigenschaft |\n\n[Diesen Abschnitt komplett weglassen, wenn der Nutzer keine Properties angegeben hat]\n\n### Hinweise (optional)\n[Technische Hinweise, Einschr√§nkungen, spezielle Logik - nur wenn relevant]\n\n## Akzeptanzkriterien\n\n- [ ] [Testbares Kriterium 1]\n- [ ] [Testbares Kriterium 2]\n- [ ] [Sicherheitskriterium]\n- [ ] [Edge-Case-Kriterium]\n```\n\n---\n\n## Step 5: Ask for Output Format\n\nOnce the user approves the story, use AskUserQuestion with these 4 options:\n\n**Question:** \"Wie m√∂chtest du mit dieser Story fortfahren?\"\n\n| Option | Label | Description |\n|--------|-------|-------------|\n| 1 | Neues Linear Ticket | Neues Ticket in Linear erstellen |\n| 2 | Bestehendes Ticket erweitern | Bereits angelegtes Linear Ticket aktualisieren |\n| 3 | Markdown-Datei | Story in eine .md-Datei im Projekt speichern |\n| 4 | Direkt umsetzen | Sofort mit TDD-Implementierung starten |\n\n**Note:** The \"Other\" option allows shortcuts - see below.\n\n**After user selects an option:**\n\n- **Option 1 (Neues Linear Ticket):** Proceed to Step 6, Option 1\n- **Option 2 (Bestehendes Ticket erweitern):**\n  - **MUST ask for Ticket-ID first:** \"Bitte gib die Ticket-ID des bestehenden Linear Tickets an (z.B. `DEV-123` oder nur `123`):\"\n  - Wait for user response with the ID\n  - Then proceed to Step 6, Option 2 with the provided ID\n- **Option 3 (Markdown-Datei):** Proceed to Step 6, Option 3\n- **Option 4 (Direkt umsetzen):** Proceed to Step 6, Option 4\n- **Other (free text input):** Parse the input:\n  - **Ticket-ID pattern detected** (e.g., `DEV-123`, `ABC-456`): Proceed directly to Step 6, Option 2 with this ID\n  - **Number only** (e.g., `123`, `456`): Assume `DEV-` prefix ‚Üí Proceed to Step 6, Option 2 with `DEV-[number]`\n  - **Anything else** (e.g., \"nichts\", \"nein\", \"abbrechen\"): Confirm in German: \"Alles klar! Die Story wurde oben angezeigt und kann bei Bedarf kopiert werden.\" - END\n\n**Shortcut hint (optional):** After presenting options, you may add: \"Tipp: Du kannst bei 'Other' auch direkt eine Ticket-ID eingeben (z.B. `123` f√ºr DEV-123).\"\n\n---\n\n## Step 6: Execute Selected Output\n\n### Option 1: Linear Ticket erstellen\n\n**Prerequisite:** Linear MCP must be installed (`lt claude install-mcps linear`)\n\n1. First, check if Linear MCP is available. If not, inform the user (in German):\n   - \"Linear MCP ist nicht installiert. Du kannst es mit `lt claude install-mcps linear` installieren.\"\n   - Then ask if they want to choose a different output option\n\n2. If Linear MCP is available, ask for Linear team and project (in German):\n   - First ask: \"In welchem Linear Team soll das Ticket erstellt werden?\"\n   - Use Linear MCP to list available teams to help the user choose\n   - If the user provides an invalid team, show available teams and ask again\n\n3. After team selection, ask for the project (in German):\n   - \"Zu welchem Projekt soll das Ticket geh√∂ren? (oder 'Keins' wenn kein Projekt zugeordnet werden soll)\"\n   - Use Linear MCP to list available projects for the selected team\n   - Accept \"Keins\", \"Kein Projekt\", \"Ohne Projekt\", or similar as valid input for no project\n   - If the user provides an invalid project, show available projects and ask again\n\n4. After project selection, ask for the status (in German):\n   - \"Welchen Status soll das Ticket haben? (Standard: 'Open')\"\n   - Use Linear MCP to list available statuses for the selected team\n   - If the user just confirms (e.g., \"Ok\", \"Ja\", \"Enter\", or empty input), use \"Open\" as default\n   - If the user provides an invalid status, show available statuses and ask again\n\n5. Optionally ask for priority (in German):\n   - \"M√∂chtest du eine Priorit√§t setzen? (0=Keine, 1=Urgent, 2=High, 3=Normal, 4=Low) - Standard: Keine\"\n   - Accept number (0-4) or text (\"Urgent\", \"High\", \"Normal\", \"Low\", \"Keine\")\n   - If the user skips or confirms without input, use 0 (No priority) as default\n\n6. Create ticket via Linear MCP:\n   - Title: The story title\n   - Description: The full story in markdown format\n   - Project: The selected project (if specified, omit if \"Keins\" was chosen)\n   - State: The selected status (default: \"Open\")\n   - Priority: The selected priority (if specified, omit if 0/Keine was chosen)\n   - Labels: Add relevant labels if applicable\n\n7. Report the created ticket URL to the user (in German)\n\n8. **Then ask (in German):** \"M√∂chtest du diese Story jetzt auch mit TDD umsetzen?\"\n\n### Option 2: Bestehendes Linear Ticket erweitern\n\n**Prerequisite:** Linear MCP must be installed (`lt claude install-mcps linear`)\n\n**Note:** The ticket ID was already collected in Step 5 (either via Option 2 selection or \"Other\" shortcut).\n\n1. First, check if Linear MCP is available. If not, inform the user (in German):\n   - \"Linear MCP ist nicht installiert. Du kannst es mit `lt claude install-mcps linear` installieren.\"\n   - Then ask if they want to choose a different output option\n\n2. Fetch the existing ticket via Linear MCP:\n   - Use `get_issue` to retrieve the current ticket details\n   - If the ticket doesn't exist, inform the user (in German): \"Ticket [ID] wurde nicht gefunden. Bitte √ºberpr√ºfe die ID.\"\n   - Then ask for a corrected ID or a different output option\n\n3. Show the user the current ticket state (in German):\n   - \"Aktuelles Ticket [ID]: **[Titel]**\"\n   - \"Aktuelle Beschreibung: [kurze Zusammenfassung oder 'leer']\"\n   - Ask: \"M√∂chtest du die Beschreibung vollst√§ndig ersetzen oder die Story anh√§ngen?\"\n   - Options: \"Ersetzen\" (replace) or \"Anh√§ngen\" (append)\n\n4. Update the ticket via Linear MCP:\n   - **Title:** Update to the optimized story title (ask user: \"Soll der Titel auf '[neuer Titel]' aktualisiert werden?\")\n   - **Description:** Replace or append the story in markdown format based on user choice\n   - **IMPORTANT:** Do NOT include the title as a heading in the description to avoid duplication - the description should start directly with the story statement (\"**Story:** Als...\")\n   - If appending, add a separator: `\\n\\n---\\n\\n[story content without title heading]`\n\n5. Report the updated ticket URL to the user (in German): \"Ticket [ID] wurde erfolgreich aktualisiert: [URL]\"\n\n6. **Then ask (in German):** \"M√∂chtest du diese Story jetzt auch mit TDD umsetzen?\"\n\n### Option 3: Als Markdown-Datei speichern\n\n1. Ask for the file location (in German):\n   - \"Wo soll die Story gespeichert werden? (z.B. `docs/stories/faq-verwaltung.md` oder `stories/STORY-001.md`)\"\n   - Suggest a filename based on the story title (e.g., `stories/admin-faq-verwaltung.md`)\n\n2. Validate the path:\n   - Check if the parent directory exists\n   - If not, ask (in German): \"Das Verzeichnis [dir] existiert nicht. Soll ich es erstellen?\"\n   - If the file already exists, ask (in German): \"Die Datei existiert bereits. √úberschreiben?\"\n\n3. Write the story to the specified file\n   - If writing fails, inform the user (in German): \"Fehler beim Speichern: [error]. Bitte einen anderen Pfad angeben.\"\n   - Then ask for a new path\n\n4. Confirm (in German): \"Story gespeichert unter [Pfad]\"\n\n5. **Then ask (in German):** \"M√∂chtest du diese Story jetzt auch mit TDD umsetzen?\"\n\n### Option 4: Direkt umsetzen (or TDD after Option 1/2/3)\n\nWhen the user chooses direct implementation or answers \"yes\" to TDD after Option 1, 2, or 3:\n\n1. Confirm (in German): \"Starte TDD-Implementierung mit dem `building-stories-with-tdd` Skill...\"\n\n2. Invoke the `building-stories-with-tdd` skill with the generated story as context\n\n3. The skill will handle: test creation, implementation, validation\n\n---\n\n## Beispiel: FAQ-Verwaltung Story\n\nHere is an example of a well-structured user story:\n\n**User's initial input:**\n> \"Ich brauche FAQs die der Admin verwalten kann und die auf der Website angezeigt werden. Die sollen eine Reihenfolge haben.\"\n\n**Gap analysis question (in German):**\n> \"Du hast erw√§hnt, dass FAQs eine Reihenfolge haben sollen. M√∂chtest du die Properties (z.B. `question`, `answer`, `position`) genauer spezifizieren, oder soll das der Implementierung √ºberlassen werden?\"\n\n**User response:**\n> \"Nein, das kann die Implementierung machen.\"\n\n**Resulting story (suggestions integrated as definitive requirements):**\n\n```markdown\n# Admin m√∂chte FAQs verwalten, damit sie auf der Website verf√ºgbar sind\n\n**Story:** Als Admin m√∂chte ich FAQs verwalten k√∂nnen, damit sie allen Besuchern auf der Website zur Verf√ºgung stehen.\n\n## Beschreibung\n\nEs soll ein Modul f√ºr FAQs erstellt werden, in dem der Admin FAQs sehen, anlegen, bearbeiten und l√∂schen kann. Nicht eingeloggte Nutzer sollen die FAQs sehen k√∂nnen, damit sie auf der Website dargestellt werden k√∂nnen.\n\n### Kontext\n- FAQs sind √∂ffentlich sichtbare Inhalte, die von Administratoren verwaltet werden\n- Die Reihenfolge der FAQs ist f√ºr die Anzeige wichtig\n\n### Anforderungen\n- Admins k√∂nnen vollst√§ndige CRUD-Operationen auf FAQs durchf√ºhren\n- Alle Nutzer (auch G√§ste) k√∂nnen FAQs lesen\n- FAQs m√ºssen eine bestimmte Reihenfolge haben\n- Die Reihenfolgeverwaltung muss automatisch und effizient erfolgen\n\n## Akzeptanzkriterien\n\n- [ ] Administratoren k√∂nnen FAQs vollst√§ndig verwalten (GET, POST, DELETE, PUT)\n- [ ] Alle Nutzer (auch nicht eingeloggte) k√∂nnen die komplette Liste der FAQs sortiert nach Reihenfolge abrufen\n- [ ] Beim Anlegen einer neuen FAQ wird automatisch die n√§chste Position in der Reihenfolge vergeben\n- [ ] Die Reihenfolge der FAQs kann angepasst werden\n- [ ] Nicht-Admin-Nutzer k√∂nnen keine FAQs erstellen, bearbeiten oder l√∂schen\n```\n\n**Beispiel eines Akzeptanzkriteriums im Gherkin-Format:**\n\n```gherkin\nGegeben es existieren bereits 3 FAQs in der Reihenfolge A, B, C\nWenn ein Admin eine neue FAQ D an Position 2 einf√ºgt\nDann ist die neue Reihenfolge A, D, B, C\nUnd alle anderen FAQs werden entsprechend neu positioniert\n```\n\n---\n\n## Execution Summary\n\n1. **Collect initial thoughts** - Let user describe their idea freely\n2. **Analyze gaps** - Check against required elements checklist\n3. **Ask targeted questions** - Only for missing/unclear elements (in German)\n4. **Validate completeness** - INVEST check, coherence, emotional value, and TDD readiness\n5. **Generate and present story** - Format according to template (in German!) and present for discussion/optimization\n6. **Ask for output** - 4 options: Neues Linear Ticket, Bestehendes Ticket erweitern, Markdown, Direkt umsetzen\n   - If \"Bestehendes Ticket erweitern\": **MUST ask for Ticket-ID separately**\n   - **Shortcut:** \"Other\" with Ticket-ID (e.g., `123` ‚Üí `DEV-123`) skips extra question\n7. **Execute choice and offer TDD** - Create output in selected format, then offer TDD implementation if not already chosen\n\n**Key behaviors:**\n- User can abort at any point - acknowledge and stop\n- Always validate paths/teams before executing\n- Handle errors gracefully with German error messages\n- \"Nichts davon\" is a valid choice - story was already displayed\n\n**Remember:** A well-written user story leads to better tests and cleaner implementation!\n",
        "plugins/lt-dev/commands/docker/gen-setup.md": "---\ndescription: Generate Docker setup for development and production\n---\n\n# Docker Development & Production Setup\n\n## When to Use This Command\n\n- Setting up a new project with Docker\n- Adding Docker support to an existing project\n- Configuring development environment with hot reload\n- Setting up local helper services (DB, Mailhog, DB UI)\n\n---\n\n## Project Context\n\nCreate a complete Docker setup for this project with the following requirements:\n\n## Phase 1: Analysis\n\n### Step 1: Analyze Project Structure\n\n1. Check if this is a single-project or monorepo\n2. Identify the framework (Nuxt, Next.js, SvelteKit, Express, Fastify, Hono, etc.)\n3. Identify the package manager (npm, pnpm, yarn)\n4. Check package.json for Node.js version and scripts\n5. Identify if SSR is being used\n6. Find out which ports the app(s) use\n7. Check if a database is already configured (Prisma, Drizzle, TypeORM, etc.)\n\n---\n\n## Phase 2: Create Docker Setup\n\n### 1. Multi-Stage Dockerfile(s)\n\n- **Development Stage**: With all dev dependencies and hot-reload support\n- **Production Stage**: Optimized, minimal, production dependencies only\n- Node.js version from package.json or engines field\n- Use BuildKit features where appropriate\n- Cache npm/pnpm dependencies effectively in layers\n- Non-root user in container\n- Proper signal handling (tini or dumb-init if needed)\n\n### 2. Docker Compose Setup\n\nCreate two compose files:\n\n**docker-compose.yml** (Base/Production):\n\n- Optimized production containers\n- Restart policies\n- Health checks\n- Network configuration\n\n**docker-compose.override.yml** (Local Development):\n\n- Hot reload via volume mounts for source code\n- node_modules in named volume (not mounted from host)\n- Ports exposed for debugging\n- Helper services (local only)\n\n### 3. Hot Reload & node_modules Handling\n\n- Source code as bind mount for live changes\n- node_modules as separate named volume to:\n  - Improve performance\n  - Keep platform-specific dependencies correct\n- On package.json/lock changes: trigger container rebuild\n- Use `npm ci` in container for consistent installs\n\n### 4. Local Helper Services\n\nAdd these only in the override:\n\n**Database** (choose based on project or PostgreSQL as default):\n\n- PostgreSQL/MySQL/MongoDB\n- Persistent volume for data\n- Initialization scripts directory\n- Configure health check\n\n**Mailhog**:\n\n- SMTP on port 1025\n- Web UI on port 8025\n- Configure app to use Mailhog as SMTP\n\n**Database UI**:\n\n- Adminer (lightweight, multi-DB) or pgAdmin (PostgreSQL-specific)\n- Pre-configured connection to local DB\n\n### 5. SSR Awareness (CRITICAL!)\n\nFor SSR frameworks (Nuxt, Next.js, SvelteKit, Analog, etc.):\n\n**Understand the Problem:**\n\n| Context | Runs Where | Network | Does `http://api:3000` work? |\n|---------|------------|---------|------------------------------|\n| Server (SSR) | Docker Container | Docker Network |  Yes |\n| Browser (Client) | User's Machine | Host Network |  No |\n\n**Implement Solution - One of the following options:**\n\n**Option A: Different URLs for Server/Client**\n```yaml\nenvironment:\n  # Server-side (SSR) - Docker internal network\n  NUXT_API_BASE_SERVER: http://api:3000\n  # OR for Next.js (without PUBLIC prefix = server-only)\n  API_URL_INTERNAL: http://api:3000\n  \n  # Client-side (Browser) - MUST be localhost!\n  NUXT_PUBLIC_API_BASE: http://localhost:3001\n  # OR for Next.js\n  NEXT_PUBLIC_API_URL: http://localhost:3001\n```\n\n**Option B: Reverse Proxy (Traefik) - Recommended**\n\nUnify everything under one URL so server and client can use the same URL:\n```yaml\nservices:\n  traefik:\n    image: traefik:v3.0\n    command:\n      - \"--providers.docker=true\"\n      - \"--providers.docker.exposedbydefault=false\"\n      - \"--entrypoints.web.address=:80\"\n    ports:\n      - \"80:80\"\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n\n  web:\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.web.rule=PathPrefix(`/`)\"\n      - \"traefik.http.routers.web.priority=1\"\n      - \"traefik.http.services.web.loadbalancer.server.port=3000\"\n\n  api:\n    labels:\n      - \"traefik.enable=true\"\n      - \"traefik.http.routers.api.rule=PathPrefix(`/api`)\"\n      - \"traefik.http.routers.api.priority=2\"\n      - \"traefik.http.services.api.loadbalancer.server.port=3000\"\n```\n\n**Option C: Built-in Proxy (Nuxt Nitro / Next.js Rewrites)**\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  nitro: {\n    devProxy: {\n      '/api': {\n        target: 'http://api:3000',\n        changeOrigin: true\n      }\n    }\n  },\n  routeRules: {\n    '/api/**': { proxy: 'http://api:3000' }\n  }\n})\n```\n\n**NEVER use a single API_URL pointing to a Docker service!**\n\n### 6. Environment Handling\n\n- `.env.example` with all required variables\n- Different defaults for dev/prod\n- Don't bake secrets into images\n- Correctly separate SSR-specific URLs\n```bash\n# .env.example Template\n\n# === Database ===\nDATABASE_URL=postgresql://postgres:postgres@db:5432/app\nDB_HOST=db\nDB_PORT=5432\nDB_USER=postgres\nDB_PASSWORD=postgres\nDB_NAME=app\n\n# === API Service ===\nAPI_PORT=3000\n\n# === Web/Frontend Service ===\nWEB_PORT=3000\n\n# === API URLs (SSR Setup) ===\n# Server-Side (Docker internal)\nAPI_URL_INTERNAL=http://api:3000\nNUXT_API_BASE_SERVER=http://api:3000\n\n# Client-Side (Browser) - MUST be localhost!\nNUXT_PUBLIC_API_BASE=http://localhost:3001\nNEXT_PUBLIC_API_URL=http://localhost:3001\n\n# === Mail (Mailhog) ===\nSMTP_HOST=mailhog\nSMTP_PORT=1025\nMAIL_FROM=noreply@localhost\n\n# === Development ===\nNODE_ENV=development\n```\n\n### 7. Additional Files\n\n**.dockerignore:**\n```\nnode_modules\n.git\n.gitignore\n*.md\n.env\n.env.*\n!.env.example\ndist\n.output\n.nuxt\n.next\ncoverage\n.nyc_output\n*.log\n```\n\n**Makefile or package.json Scripts:**\n```makefile\n.PHONY: dev build logs shell db-reset clean\n\ndev:\n\tdocker compose up -d --build\n\nbuild:\n\tdocker compose -f docker-compose.yml build\n\nlogs:\n\tdocker compose logs -f\n\nshell:\n\tdocker compose exec app sh\n\ndb-reset:\n\tdocker compose down -v\n\tdocker compose up -d db\n\tsleep 5\n\tdocker compose exec app npm run db:migrate\n\nclean:\n\tdocker compose down -v --remove-orphans\n\tdocker system prune -f\n```\n\n### 8. Documentation\n\nCreate a `DOCKER.md` with:\n\n- Quick start guide\n- Architecture explanation\n- Service URLs and ports\n- Common problems & solutions\n- How to add new services\n\n---\n\n## Phase 3: Startup & Validation\n\n### Step 1: Prepare Environment\n```bash\n# Create .env from .env.example if not present\nif [ ! -f .env ]; then\n  cp .env.example .env\n  echo \"Created .env from .env.example\"\nfi\n```\n\n### Step 2: Start Docker Setup\n```bash\n# Stop and remove old containers and volumes\ndocker compose down -v --remove-orphans\n\n# Build and start fresh\ndocker compose build --no-cache\ndocker compose up -d\n```\n\n### Step 3: Wait for Startup\n```bash\n# Wait for containers to start\necho \"Waiting for containers to start...\"\nsleep 15\n\n# Check container status\ndocker compose ps\n```\n\n### Step 4: Analyze Logs\n```bash\n# Check logs of all services\ndocker compose logs --tail=200\n```\n\n**Check for the following patterns:**\n\n Success:\n- \"listening on port\"\n- \"ready in\"\n- \"server started\"\n- \"database connection established\"\n- \"connected to\"\n\n Errors:\n- \"ECONNREFUSED\"\n- \"connection refused\"\n- \"Module not found\"\n- \"Cannot find module\"\n- \"Permission denied\"\n- \"EACCES\"\n- \"port already in use\"\n- \"EADDRINUSE\"\n- \"error\"\n- \"failed\"\n- \"exited with code\"\n\n### Step 5: Run Health Checks\n```bash\necho \"=== Health Checks ===\"\n\n# App/Frontend\nif curl -sf http://localhost:3000 > /dev/null 2>&1; then\n  echo \" Frontend reachable (localhost:3000)\"\nelse\n  echo \" Frontend NOT reachable\"\nfi\n\n# API (if separate service)\nif curl -sf http://localhost:3001/health > /dev/null 2>&1 || curl -sf http://localhost:3001 > /dev/null 2>&1; then\n  echo \" API reachable (localhost:3001)\"\nelse\n  echo \"  API not on localhost:3001 (maybe different port or integrated)\"\nfi\n\n# Database UI (Adminer)\nif curl -sf http://localhost:8080 > /dev/null 2>&1; then\n  echo \" DB UI reachable (localhost:8080)\"\nelse\n  echo \" DB UI NOT reachable\"\nfi\n\n# Mailhog\nif curl -sf http://localhost:8025 > /dev/null 2>&1; then\n  echo \" Mailhog reachable (localhost:8025)\"\nelse\n  echo \" Mailhog NOT reachable\"\nfi\n\n# Database Connection Check\nif docker compose exec -T db pg_isready -U postgres > /dev/null 2>&1; then\n  echo \" PostgreSQL ready\"\nelse\n  echo \" PostgreSQL NOT ready\"\nfi\n```\n\n### Step 6: SSR-Specific Checks (if SSR framework)\n```bash\necho \"=== SSR Checks ===\"\n\n# Server-to-API connection (inside container)\nif docker compose exec -T web curl -sf http://api:3000/health > /dev/null 2>&1; then\n  echo \" SSR -> API connection OK (Docker internal)\"\nelse\n  echo \"  Check SSR -> API connection\"\nfi\n\n# Check that no Docker-internal URLs end up in client bundle\nif docker compose exec -T web sh -c 'find .output .next dist -name \"*.js\" 2>/dev/null | head -20 | xargs grep -l \"api:3000\" 2>/dev/null'; then\n  echo \" WARNING: 'api:3000' found in client bundle! SSR URLs misconfigured.\"\nelse\n  echo \" No Docker-internal URLs in client bundle\"\nfi\n```\n\n---\n\n## Phase 4: Error Analysis & Auto-Fix\n\n### Iterative Fix Loop\n\nWhen errors are found, analyze and fix them:\n```\nWHILE errors exist AND attempts < 5:\n    1. Identify the specific error from logs/health checks\n    2. Determine the cause (see table below)\n    3. Apply the appropriate fix\n    4. Restart affected services: docker compose up -d --build <service>\n    5. Wait for startup (sleep 10-15)\n    6. Run health checks again\n    7. attempts++\n```\n\n### Error Diagnosis Table\n\n| Symptom | Cause | Fix |\n|---------|-------|-----|\n| Container won't start | Missing env vars | Check/complete `.env` file |\n| Container won't start | Syntax error in code | Check logs, fix code |\n| Container crash loop | Wrong Node version | Adjust Node version in Dockerfile |\n| \"Module not found\" | node_modules problem | Delete volume, rebuild |\n| \"EADDRINUSE\" / Port in use | Port already used | Change port in compose |\n| \"ECONNREFUSED\" to DB | DB not ready yet | Add depends_on + healthcheck |\n| \"ECONNREFUSED api:3000\" in browser | SSR URL problem | Change client URL to localhost |\n| API works in SSR, not in browser | Wrong PUBLIC env var | Use NUXT_PUBLIC_* / NEXT_PUBLIC_* |\n| Permission denied | User/permissions wrong | Adjust Dockerfile user |\n| CORS errors in browser | API CORS not configured | Add CORS headers or use proxy |\n\n### Specific Fixes\n\n**node_modules Problem:**\n```bash\n# Identify and delete volume\ndocker compose down\ndocker volume ls | grep node_modules\ndocker volume rm <volume_name>\ndocker compose up -d --build\n```\n\n**DB Connection Timing:**\n```yaml\n# docker-compose.yml - add healthcheck\nservices:\n  db:\n    healthcheck:\n      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n      interval: 5s\n      timeout: 5s\n      retries: 5\n\n  app:\n    depends_on:\n      db:\n        condition: service_healthy\n```\n\n**SSR URL Fix:**\n```yaml\n# Wrong:\nenvironment:\n  API_URL: http://api:3000\n\n# Correct:\nenvironment:\n  NUXT_API_BASE_SERVER: http://api:3000      # Server\n  NUXT_PUBLIC_API_BASE: http://localhost:3001 # Client\n```\n\n---\n\n## Phase 5: Final Validation & Output\n\n### Successful Completion\n\nWhen all checks pass, output the following summary:\n```\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n‚ïë                 Docker Setup Successful!                     ‚ïë\n‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n‚ïë                                                              ‚ïë\n‚ïë  Container Status:                                           ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ app/web      Running                                  ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ api          Running (if separate service)            ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ db           Running                                  ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ adminer      Running                                  ‚ïë\n‚ïë  ‚îî‚îÄ‚îÄ mailhog      Running                                  ‚ïë\n‚ïë                                                              ‚ïë\n‚ïë  Available Services:                                         ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ Frontend:    http://localhost:3000                      ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ API:         http://localhost:3001 (if separate)        ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ DB UI:       http://localhost:8080                      ‚ïë\n‚ïë  ‚îÇ   ‚îî‚îÄ‚îÄ Login:   postgres / postgres / app                  ‚ïë\n‚ïë  ‚îî‚îÄ‚îÄ Mailhog:     http://localhost:8025                      ‚ïë\n‚ïë                                                              ‚ïë\n‚ïë  Commands:                                                   ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ Logs:        docker compose logs -f                     ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ Stop:        docker compose down                        ‚ïë\n‚ïë  ‚îú‚îÄ‚îÄ Rebuild:     docker compose up -d --build               ‚ïë\n‚ïë  ‚îî‚îÄ‚îÄ Shell:       docker compose exec app sh                 ‚ïë\n‚ïë                                                              ‚ïë\n‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n```\n\n### List Created Files\n\nList all created/modified files:\n\n- `Dockerfile`\n- `docker-compose.yml`\n- `docker-compose.override.yml`\n- `.dockerignore`\n- `.env.example`\n- `.env` (copied from example)\n- `DOCKER.md`\n- `Makefile` (optional)\n\n### If Fixes Were Necessary\n\nDocument what was fixed:\n```\nFixed Issues:\n1. [Problem]: API URL in client bundle was Docker-internal\n   [Fix]: Set NUXT_PUBLIC_API_BASE to localhost:3001\n   \n2. [Problem]: Container started before DB was ready\n   [Fix]: Added healthcheck and depends_on condition\n```\n\n---\n\n## Important Notes\n\n1. **Test Hot Reload**: After setup, make a small change and verify it's picked up live\n2. **node_modules Sync**: On package.json changes, always run `docker compose up -d --build`\n3. **Volumes on Problems**: When in doubt, `docker compose down -v` and restart fresh\n4. **SSR Debug**: For API issues, always check BOTH browser console AND server logs",
        "plugins/lt-dev/commands/fix-issue.md": "---\ndescription: Work on a Linear issue by ID\nargument-hint: <issue-id>\n---\n\n# Fix Linear Issue\n\n## When to Use This Command\n\n- Working on an assigned Linear issue\n- Implementing a feature or fix from a Linear ticket\n- Need structured workflow for issue resolution\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:create-story` | Create a new user story for Linear |\n\n## Description\nWork on a single assigned issue, ensuring high-quality, consistent implementation and adherence to all requirements.\n\n## Prompt\n### STEP 1: ISSUE ANALYSIS & PLANNING (30-45 min thinking time)\n\n1.  **Retrieve Issue Details:** Access the Management Control Panel (MCP) to retrieve the specific Linear Issue **#$ARGUMENTS** and any associated resources (e.g., a Figma design link).\n2.  **Understand Requirements:** Deeply read the issue description, comments, and review the Figma design (if applicable) to fully grasp the objective, scope, and visual requirements.\n3.  **Consistency Check:** Review existing application code in relevant areas to understand current implementation patterns, architecture, and coding styles. The new code **must** be consistent.\n4.  **Create Plan:** Develop a concrete implementation plan, including:\n    * Required code changes/new files.\n    * Approach for handling edge cases.\n    * Testing strategy for the new feature/fix.\n\nUltrathink: What is the most robust, consistent, and maintainable way to solve this issue?\n\n### STEP 2: EXECUTION\n\nImplement the plan completely, focused on high quality and consistency:\n\n1.  **Implement:** Write production-quality code that directly addresses the issue requirements.\n2.  **Consistency & Guidelines:** Strictly adhere to established coding guidelines and ensure the implementation style is consistent with the surrounding application code.\n3.  **Testing:** Implement unit/integration tests as defined in the plan, or manually test the feature thoroughly.\n4.  **Update Status:** Update the Linear Issue **#$ARGUMENTS** status in the MCP upon completion.\n\n**Only interrupt for critical blockers** (e.g., unclear requirements, missing credentials). Make smart decisions autonomously, prioritizing code quality and long-term maintainability.\n\n**BEGIN ANALYSIS NOW.**",
        "plugins/lt-dev/commands/git/commit-message.md": "---\ndescription: Generate commit message with alternatives\nallowed-tools: Bash(git diff:*), Bash(git status:*), Bash(git log:*)\n---\n\n# Generate Commit Message\n\n## When to Use This Command\n\n- After making changes and before committing\n- When you want well-crafted commit message suggestions\n- To follow consistent commit message conventions\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:git:mr-description` | Generate MR description for branch |\n| `/lt-dev:git:mr-description-clipboard` | Generate MR description with clipboard copy |\n\n---\n\nAnalyze the current changes compared to the last git commit (`git diff`) and create a commit message.\n\n**Requirements:**\n- Write in English\n- Keep it short: one concise sentence\n- Focus on WHAT changed and WHY, not HOW\n\n**Output format:**\nProvide exactly 3 alternatives:\n\n```\n1. [your first commit message suggestion]\n2. [your second commit message suggestion]\n3. [your third commit message suggestion]\n```\n\nThen add: \" **Copy your preferred message to use with `git commit -am \\\"...\\\"`**\"",
        "plugins/lt-dev/commands/git/mr-description-clipboard.md": "---\ndescription: Generate MR description and save to clipboard\nallowed-tools: Bash(git diff:*), Bash(git log:*), Bash(git status:*), Bash(git branch:*), Bash(pbcopy:*), Read\n---\n\n# Generate MR Description (Clipboard)\n\n## When to Use This Command\n\n- Before creating a Merge/Pull Request when you want quick clipboard access\n- When you prefer copying directly via command instead of manual selection\n- Same as `/mr-description` but with automatic clipboard command\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:git:commit-message` | Generate commit message suggestions |\n| `/lt-dev:git:mr-description` | Same as this, without clipboard copy |\n\n---\n\nCreate a comprehensive summary of the changes in English for a Merge Request description.\n\nPlease structure the description as follows:\n- **Summary**: Brief summary (1-2 sentences)\n- **Changes**: List of the most important changes\n- **Technical Details**: Relevant technical details if necessary\n- **Testing**: How was it tested / how can it be tested\n\nKeep it short and concise - focus on what's essential for code reviewers.\n\n**IMPORTANT - CLIPBOARD WORKFLOW:**\n\n1. First, create the MR description in this format:\n\n```markdown\n## Summary\n[Your summary here]\n\n## Changes\n- Change 1\n- Change 2\n\n## Technical Details\n[Details if necessary]\n\n## Testing\n[Testing approach]\n```\n\n2. After presenting the description, provide this shell command:\n\n```bash\ncat << 'EOF' | pbcopy\n[PASTE THE EXACT MR DESCRIPTION HERE]\nEOF\necho \" MR description copied to clipboard!\"\n```\n\n3. User can run this command to copy the description to clipboard automatically.\n\n**Platform-specific commands:**\n- macOS: `pbcopy`\n- Linux: `xclip -selection clipboard` or `xsel --clipboard`\n- Windows: `clip`\n",
        "plugins/lt-dev/commands/git/mr-description.md": "---\ndescription: Generate Merge Request description\nallowed-tools: Bash(git diff:*), Bash(git log:*), Bash(git status:*), Bash(git branch:*), Read\n---\n\n# Generate MR Description\n\n## When to Use This Command\n\n- Before creating a Merge/Pull Request\n- When you need a structured summary of your branch changes\n- To document changes for code reviewers\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:git:commit-message` | Generate commit message suggestions |\n| `/lt-dev:git:mr-description-clipboard` | Same as this, but with clipboard copy |\n\n---\n\nCreate a comprehensive summary of the changes in English so I can use it as a description in a Merge Request. Only include the essential points.\n\nPlease structure the description as follows:\n- **Summary**: Brief summary (1-2 sentences)\n- **Changes**: List of the most important changes\n- **Technical Details**: Relevant technical details if necessary\n- **Testing**: How was it tested / how can it be tested\n\nKeep it short and concise - focus on what's essential for code reviewers.\n\n**IMPORTANT OUTPUT FORMAT:**\nPresent the final MR description in a clearly marked code block that is easy to copy:\n\n```markdown\n## Summary\n[Your summary here]\n\n## Changes\n- Change 1\n- Change 2\n\n## Technical Details\n[Details if necessary]\n\n## Testing\n[Testing approach]\n```\n\nThen add: \"‚úÇÔ∏è **Copy the markdown block above to use it in your Merge Request.**\"\n",
        "plugins/lt-dev/commands/maintenance/maintain-check.md": "---\ndescription: Analyze npm packages WITHOUT making any changes - generates a comprehensive report of what would be done\n---\n\n# NPM Package Maintenance Check (Dry-Run)\n\n## Description\nAnalyze npm packages WITHOUT making any changes - generates a comprehensive report of what would be done\n\n## Related Commands\n\n| Command | Mode | Use Case |\n|---------|------|----------|\n| `/lt-dev:maintain` | FULL | Complete optimization |\n| `/lt-dev:maintain-check` | DRY-RUN | Analysis only (this command) |\n| `/lt-dev:maintain-security` | SECURITY | Fast security-only updates |\n| `/lt-dev:maintain-pre-release` | PRE-RELEASE | Conservative patch-only updates |\n| `/lt-dev:maintain-post-feature` | FULL | Clean up after feature development |\n\n## User Prompt\nUse the lt-dev:npm-package-maintainer agent to perform **DRY-RUN** analysis.\n\n**Mode**: DRY-RUN MODE (analysis only, no changes)\n\nAnalyze and report WITHOUT making changes:\n- Analyze unused packages (what WOULD be removed)\n- Analyze categorization (what WOULD be moved to devDependencies)\n- Discover outdated packages (what WOULD be updated)\n- Analyze overrides (which COULD be removed)\n- Check security vulnerabilities\n- Estimate risk levels for all potential changes\n\n**CRITICAL**: Do NOT modify package.json, do NOT run npm install/uninstall, do NOT make any changes.\n\nGenerate comprehensive report including:\n- Packages that could be removed (with usage analysis)\n- Packages that could be recategorized\n- Available updates categorized by risk (SAFE/MEDIUM/HIGH)\n- Overrides that may no longer be necessary (with analysis)\n- Security vulnerabilities found\n- Estimated impact and time requirements\n\nThis is useful for planning maintenance windows or getting pre-approval for changes.\n",
        "plugins/lt-dev/commands/maintenance/maintain-post-feature.md": "---\ndescription: Package maintenance after completing a feature - ensures dependencies are current and optimized\n---\n\n# NPM Package Post-Feature Maintenance\n\n## Description\nPackage maintenance after completing a feature - ensures dependencies are current and optimized\n\n## Related Commands\n\n| Command | Mode | Use Case |\n|---------|------|----------|\n| `/lt-dev:maintain` | FULL | Complete optimization |\n| `/lt-dev:maintain-check` | DRY-RUN | Analysis only - no changes |\n| `/lt-dev:maintain-security` | SECURITY | Fast security-only updates |\n| `/lt-dev:maintain-pre-release` | PRE-RELEASE | Conservative patch-only updates |\n| `/lt-dev:maintain-post-feature` | FULL | Post-feature cleanup (this command) |\n\n## User Prompt\nUse the lt-dev:npm-package-maintainer agent to perform **post-feature** maintenance.\n\n**Mode**: FULL MODE (complete optimization)\n\nAfter feature implementation, ensure the dependency ecosystem is clean and up-to-date:\n\nExecute all priorities:\n1. Remove unused packages (especially if feature changed dependencies)\n2. Optimize dependency categorization (ensure new deps are correctly placed)\n3. Update packages to latest versions (stay current after feature work)\n4. Cleanup unnecessary overrides\n\nCheck for:\n- Unused dependencies that can be removed (especially from feature work)\n- New dependencies that should be in devDependencies vs dependencies\n- Outdated dependencies (all types: security, features, patches)\n- Security vulnerabilities introduced by new dependencies\n- Compatibility issues with newly added packages\n- Overrides that are no longer necessary (parent packages now include fixed versions)\n\nThis is the standard comprehensive maintenance mode, ideal after completing feature development to ensure the codebase stays clean and dependencies stay current.\n\nEnsure all tests and build pass after changes.\n",
        "plugins/lt-dev/commands/maintenance/maintain-pre-release.md": "---\ndescription: Ultra-conservative npm package maintenance before a release - only zero-risk patch updates\n---\n\n# NPM Package Pre-Release Maintenance\n\n## Description\nUltra-conservative npm package maintenance before a release - only zero-risk patch updates\n\n## Related Commands\n\n| Command | Mode | Use Case |\n|---------|------|----------|\n| `/lt-dev:maintain` | FULL | Complete optimization |\n| `/lt-dev:maintain-check` | DRY-RUN | Analysis only - no changes |\n| `/lt-dev:maintain-security` | SECURITY | Fast security-only updates |\n| `/lt-dev:maintain-pre-release` | PRE-RELEASE | Conservative patches (this command) |\n| `/lt-dev:maintain-post-feature` | FULL | Clean up after feature development |\n\n## User Prompt\nUse the lt-dev:npm-package-maintainer agent to perform **PRE-RELEASE** maintenance.\n\n**Mode**: PRE-RELEASE MODE (ultra-conservative, stability-focused)\n\nExecute minimal, zero-risk updates before release:\n- Skip package removal (Priority 1) - no structural changes before release\n- Skip categorization (Priority 2) - no dependency reorganization before release\n- Execute ONLY Priority 3 with SAFE filter\n- Update ONLY patch versions (no minor or major updates)\n- Reject any update that could introduce risk\n- Focus on stability and proven compatibility\n\nAllowed updates:\n- Patch versions only (e.g., 5.8.3 ‚Üí 5.8.9)\n- Development tools patches (build tools, linters)\n- Type definition patches\n- Documentation tool patches\n\nForbidden updates:\n- Any minor or major version updates\n- Any updates requiring code changes\n- Any framework updates\n- Any runtime dependency changes beyond patches\n\nThis mode prioritizes release stability over currency. Use this immediately before cutting a release when you want to minimize risk while still getting the latest patch fixes.\n\nEnsure all tests and build pass after changes.\n",
        "plugins/lt-dev/commands/maintenance/maintain-security.md": "---\ndescription: Fast security-focused npm package maintenance - updates only packages with known vulnerabilities\n---\n\n# NPM Package Security Maintenance\n\n## Description\nFast security-focused npm package maintenance - updates only packages with known vulnerabilities\n\n## Related Commands\n\n| Command | Mode | Use Case |\n|---------|------|----------|\n| `/lt-dev:maintain` | FULL | Complete optimization |\n| `/lt-dev:maintain-check` | DRY-RUN | Analysis only - no changes |\n| `/lt-dev:maintain-security` | SECURITY | Fast security-only (this command) |\n| `/lt-dev:maintain-pre-release` | PRE-RELEASE | Conservative patch-only updates |\n| `/lt-dev:maintain-post-feature` | FULL | Clean up after feature development |\n\n## User Prompt\nUse the lt-dev:npm-package-maintainer agent to perform **SECURITY-ONLY** maintenance.\n\n**Mode**: SECURITY-ONLY MODE\n\nFocus exclusively on security updates:\n- Skip package removal analysis (Priority 1)\n- Skip categorization optimization (Priority 2)\n- Execute ONLY Priority 3 with security filter\n- Update packages with known vulnerabilities from npm audit\n- Skip non-security updates to minimize risk and execution time\n\nCheck for:\n- Security vulnerabilities (npm audit)\n- Security-critical package updates only\n\nThis is a faster, minimal-change mode for urgent security fixes.\n\nEnsure all tests and build pass after changes.\n",
        "plugins/lt-dev/commands/maintenance/maintain.md": "---\ndescription: Comprehensive npm package maintenance using the specialized lt-dev:npm-package-maintainer agent\n---\n\n# NPM Package Maintenance\n\n## Description\nComprehensive npm package maintenance using the specialized lt-dev:npm-package-maintainer agent\n\n## Related Commands\n\n| Command | Mode | Use Case |\n|---------|------|----------|\n| `/lt-dev:maintain` | FULL | Complete optimization (this command) |\n| `/lt-dev:maintain-check` | DRY-RUN | Analysis only - no changes |\n| `/lt-dev:maintain-security` | SECURITY | Fast security-only updates |\n| `/lt-dev:maintain-pre-release` | PRE-RELEASE | Conservative patch-only updates |\n| `/lt-dev:maintain-post-feature` | FULL | Clean up after feature development |\n\n## User Prompt\nUse the lt-dev:npm-package-maintainer agent to perform comprehensive npm package maintenance.\n\n**Mode**: FULL MODE (complete optimization)\n\nExecute all priorities:\n1. Remove unused packages\n2. Optimize dependency categorization\n3. Update packages to latest versions\n4. Cleanup unnecessary overrides\n\nCheck for:\n- Unused dependencies that can be removed\n- Packages that should be moved to devDependencies\n- Outdated dependencies (all types: security, features, patches)\n- Security vulnerabilities\n- Compatibility issues\n- Overrides that are no longer necessary (parent packages now include fixed versions)\n\nEnsure all tests and build pass after changes.\n",
        "plugins/lt-dev/commands/plugin/check.md": "---\ndescription: Verify plugin elements against current best practices and optimize for consistency\n---\n\n# Plugin Best Practice Check\n\nAnalyze and optimize plugin elements against current Claude Code best practices. Use this command after `/clear`, context summarization, or when you want to ensure elements are up-to-date and consistent.\n\n## When to Use This Command\n\n- After `/clear` to restore best practice awareness\n- After context summarization when working on plugin elements\n- Before releasing or publishing plugin updates\n- Periodic maintenance to ensure consistency\n- When unsure if elements follow current best practices\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:plugin:element` | Create new plugin elements with best practices |\n| `/lt-dev:skill-optimize` | Optimize skill files specifically |\n\n---\n\n## Step 1: Fetch Best Practices Documentation\n\n**MANDATORY:** Fetch the latest official documentation from GitHub:\n\n```\nWebFetch: https://github.com/anthropics/claude-code/blob/main/plugins/README.md\nWebFetch: https://github.com/anthropics/skills/blob/main/README.md\n```\n\n**For specific topics:** Use `WebSearch: \"Claude Code [topic] documentation site:claude.com\"`\n\n---\n\n## Step 2: Determine Scope\n\nUse AskUserQuestion to determine the check scope:\n\n**Question (German):** \"Was soll gepr√ºft werden?\"\n\n**Options:**\n1. **Gesamtes Paket** - Alle Elemente in plugins/lt-dev pr√ºfen (empfohlen)\n2. **Nur Skills** - Alle Skills auf Best Practices pr√ºfen\n3. **Nur Commands** - Alle Commands auf Best Practices pr√ºfen\n4. **Nur Agents** - Alle Agents auf Best Practices pr√ºfen\n5. **Nur Konfiguration** - permissions.json, .mcp.json, plugin.json pr√ºfen\n6. **Einzelnes Element** - Ein spezifisches Element pr√ºfen\n\nIf \"Einzelnes Element\" is selected, ask for the element path.\n\n---\n\n## Step 3: Inventory Elements\n\nBased on scope, inventory all elements to check:\n\n```bash\n# Skills\nfind plugins/lt-dev/skills -name \"SKILL.md\" -type f\n\n# Commands\nfind plugins/lt-dev/commands -name \"*.md\" -type f\n\n# Agents\nfind plugins/lt-dev/agents -name \"*.md\" -type f\n\n# Hooks\ncat plugins/lt-dev/hooks/hooks.json 2>/dev/null || echo \"No hooks.json\"\n```\n\n---\n\n## Step 4: Execute Checks\n\nFor each element, perform the following checks:\n\n### 4.1 YAML Frontmatter Validation\n\n- [ ] Frontmatter exists and is properly formatted\n- [ ] All required fields present (name, description for skills/agents; description for commands)\n- [ ] Description follows guidelines (WHEN for skills, WHAT for commands)\n- [ ] Description length appropriate (max 280 chars for skills)\n\n### 4.2 Structural Consistency\n\n- [ ] File naming follows kebab-case convention\n- [ ] Directory structure matches conventions\n- [ ] Heading hierarchy is consistent (# title, ## sections, ### subsections)\n- [ ] Markdown is clean and well-organized\n\n### 4.3 Content Quality\n\n- [ ] Purpose is clearly stated\n- [ ] \"When to Use\" section exists (for skills and commands)\n- [ ] Examples are provided where helpful\n- [ ] Related elements are cross-referenced\n- [ ] Language is English (except designated German content)\n\n### 4.4 Best Practice Compliance\n\nCompare against fetched documentation:\n- [ ] Follows current recommended patterns\n- [ ] Uses correct field names and values\n- [ ] No deprecated patterns or fields\n\n### 4.5 Integration Checks\n\n- [ ] No duplicate functionality with other elements\n- [ ] Cross-references point to existing elements\n- [ ] No orphaned elements\n\n### 4.6 Configuration Files\n\n**permissions.json:**\n- [ ] All Bash patterns used by skills/agents are listed\n- [ ] `usedBy` arrays include all skills/agents using each pattern\n- [ ] No orphaned patterns (patterns without valid usedBy references)\n- [ ] Patterns follow correct format: `Bash(command:*)`\n\n**Check against skills:**\n```bash\n# Find all Bash commands used in skills\ngrep -r \"npm \\|npx \\|lt \" plugins/lt-dev/skills/ --include=\"*.md\"\n\n# Compare with permissions.json patterns\ncat plugins/lt-dev/permissions.json\n```\n\n**.mcp.json:**\n- [ ] All MCP servers used by commands/skills are configured\n- [ ] Server configurations are valid (type, command/url)\n- [ ] No unused MCP server entries\n\n**Check MCP usage:**\n```bash\n# Find MCP references in commands\ngrep -r \"Linear\\|Chrome\\|chrome-devtools\\|linear\" plugins/lt-dev/commands/ --include=\"*.md\"\ngrep -r \"Chrome MCP\\|Linear MCP\" plugins/lt-dev/commands/ --include=\"*.md\"\n```\n\n**plugin.json:**\n- [ ] Version follows semver format\n- [ ] All required fields present (name, version, description, author)\n- [ ] Keywords are relevant and complete\n\n### 4.7 Documentation Consistency\n\n**CLAUDE.md:**\n- [ ] Repository structure matches actual file layout\n- [ ] Configuration file documentation is current\n- [ ] All referenced commands/skills exist\n\n**Check structure:**\n```bash\n# Compare documented structure with actual\nls -la plugins/lt-dev/\nls -la plugins/lt-dev/.claude-plugin/\n```\n\n---\n\n## Step 5: Generate Report\n\nCreate a comprehensive report of findings:\n\n```markdown\n## Plugin Best Practice Check Report\n\n### Summary\n- **Elements Checked:** X\n- **Passed:** Y\n- **Issues Found:** Z\n- **Suggestions:** N\n\n### Detailed Findings\n\n#### Skills (X checked)\n\n| Skill | Status | Issues |\n|-------|--------|--------|\n| skill-name | ‚úÖ/‚ö†Ô∏è/‚ùå | [issues if any] |\n\n[Detailed issues per skill]\n\n#### Commands (X checked)\n\n| Command | Status | Issues |\n|---------|--------|--------|\n| /command-name | ‚úÖ/‚ö†Ô∏è/‚ùå | [issues if any] |\n\n[Detailed issues per command]\n\n#### Agents (X checked)\n\n| Agent | Status | Issues |\n|-------|--------|--------|\n| agent-name | ‚úÖ/‚ö†Ô∏è/‚ùå | [issues if any] |\n\n[Detailed issues per agent]\n\n#### Configuration Files\n\n| File | Status | Issues |\n|------|--------|--------|\n| permissions.json | ‚úÖ/‚ö†Ô∏è/‚ùå | [issues if any] |\n| .mcp.json | ‚úÖ/‚ö†Ô∏è/‚ùå | [issues if any] |\n| plugin.json | ‚úÖ/‚ö†Ô∏è/‚ùå | [issues if any] |\n\n[Detailed issues per config file]\n\n#### Documentation\n\n| File | Status | Issues |\n|------|--------|--------|\n| CLAUDE.md | ‚úÖ/‚ö†Ô∏è/‚ùå | [issues if any] |\n\n### Recommended Actions\n\n**Critical (fix immediately):**\n1. [Critical issue 1]\n2. [Critical issue 2]\n\n**Improvements (recommended):**\n1. [Improvement 1]\n2. [Improvement 2]\n\n**Suggestions (optional):**\n1. [Suggestion 1]\n2. [Suggestion 2]\n```\n\n---\n\n## Step 6: Offer Automated Fixes\n\nAfter presenting the report, ask (in German):\n\n\"Ich habe [N] Probleme und [M] Verbesserungsvorschl√§ge gefunden.\n\nM√∂chtest du:\n1. **Alle automatisch beheben** - Ich korrigiere alle Probleme automatisch\n2. **Einzeln durchgehen** - Wir besprechen jedes Problem einzeln\n3. **Nur kritische beheben** - Nur die kritischen Probleme automatisch beheben\n4. **Nichts √§ndern** - Nur den Bericht als Referenz verwenden\"\n\n---\n\n## Step 7: Execute Fixes (if requested)\n\nFor each fix:\n1. Show the current state\n2. Show the proposed change\n3. Apply the change\n4. Verify the change\n\nAfter all fixes:\n```markdown\n## Fix Summary\n\n- **Applied:** X fixes\n- **Skipped:** Y items\n- **Manual action required:** Z items\n\n### Changes Made\n1. [Change 1]\n2. [Change 2]\n\n### Manual Actions Required\n1. [Action 1] - [Reason]\n```\n\n---\n\n## Check Categories\n\n### Critical Issues (‚ùå)\n- Missing required frontmatter fields\n- Invalid YAML syntax\n- Broken cross-references\n- Duplicate element names\n- Deprecated patterns from outdated documentation\n- **permissions.json**: Missing patterns for used Bash commands\n- **permissions.json**: Invalid pattern format\n- **.mcp.json**: Missing required MCP server\n- **plugin.json**: Invalid or missing required fields\n\n### Warnings (‚ö†Ô∏è)\n- Description too long or too short\n- Missing \"When to Use\" section\n- Inconsistent heading hierarchy\n- Missing examples for complex elements\n- Potential overlap with other elements\n- **permissions.json**: Incomplete `usedBy` arrays\n- **permissions.json**: Orphaned patterns (no valid usedBy)\n- **.mcp.json**: Unused MCP server entries\n- **CLAUDE.md**: Repository structure doesn't match actual layout\n\n### Suggestions (üí°)\n- Could add more examples\n- Could improve description clarity\n- Could add cross-references\n- Minor formatting improvements\n- **permissions.json**: Add descriptions for clarity\n- **plugin.json**: Add more keywords for discoverability\n\n---\n\n## Quick Check Mode\n\nFor a fast check without full documentation fetch, use this condensed checklist:\n\n### Frontmatter Quick Check\n```\nSkills: name + description (max 280 chars, WHEN focus)\nCommands: description (WHAT focus)\nAgents: name + description + model + tools\n```\n\n### Structure Quick Check\n```\n- File name is kebab-case\n- # Title exists\n- ## Sections use level 2\n- Language is English\n```\n\n### Content Quick Check\n```\n- Purpose stated in first paragraph\n- \"When to Use\" section exists\n- Related elements mentioned\n```\n\n### Configuration Quick Check\n```\npermissions.json:\n- All npm/npx/lt commands have patterns\n- usedBy arrays reference existing skills\n\n.mcp.json:\n- All used MCP servers are configured\n- Server types are valid (stdio/http)\n\nplugin.json:\n- Version is semver format\n- Required fields present (name, version, description)\n\nCLAUDE.md:\n- Repository structure matches actual layout\n- Configuration docs are current\n```\n",
        "plugins/lt-dev/commands/plugin/element.md": "---\ndescription: Create a new plugin element (skill, command, agent, hook, or script) with best practice guidance\n---\n\n# Create Plugin Element\n\nInteractively create a new element for this Claude Code plugin package with automatic best practice compliance, consistent structure, and proper placement.\n\n## When to Use This Command\n\n- Adding a new skill, command, agent, hook, or script to this package\n- Unsure which element type is best for your use case\n- Want guidance on proper structure and naming\n\n## Related Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/lt-dev:plugin:check` | Verify all plugin elements against best practices |\n| `/lt-dev:skill-optimize` | Optimize existing skill files |\n\n---\n\n## Step 1: Gather Requirements\n\n**Ask the user (in German):**\n\n\"Was m√∂chtest du erstellen? Bitte beschreibe dein Vorhaben:\n- Was soll erreicht werden?\n- Wer/Was l√∂st es aus? (Benutzer, Event, automatisch?)\n- Soll es autonom arbeiten oder interaktiv?\n\nBeispiele:\n- 'Ich m√∂chte automatisch Code-Reviews nach jedem Commit machen'\n- 'Entwickler sollen per Command eine neue API-Route scaffolden k√∂nnen'\n- 'Bei NestJS-Projekten soll Claude automatisch wissen, wie die Struktur funktioniert'\"\n\n**Wait for user response.**\n\n---\n\n## Step 2: Fetch Best Practices Documentation\n\n**MANDATORY:** Before proceeding, fetch the latest official documentation from GitHub:\n\n```\nWebFetch: https://github.com/anthropics/claude-code/blob/main/plugins/README.md\nWebFetch: https://github.com/anthropics/skills/blob/main/README.md\n```\n\n**For specific element types:** Use `WebSearch: \"Claude Code [topic] documentation site:claude.com\"`\n\nTopics by element type:\n- Plugins: \"Claude Code plugins plugin.json\"\n- Skills: \"Claude Code skills SKILL.md\"\n- Commands: \"Claude Code slash commands\"\n- Subagents: \"Claude Code subagents agents\"\n- Hooks: \"Claude Code hooks hooks.json\"\n\n---\n\n## Step 3: Recommend Element Type\n\nBased on the user's description, analyze and recommend the appropriate element type(s):\n\n### Decision Matrix\n\n| Requirement | Recommended Element |\n|-------------|---------------------|\n| Enhance Claude's expertise in a domain | **Skill** |\n| User-triggered workflow via `/command` | **Command** |\n| Autonomous complex multi-step task | **Agent** |\n| Automatic reaction to events | **Hook** |\n| Reusable utility function | **Script** |\n\n### Combination Patterns\n\nSometimes multiple elements work together:\n- **Skill + Command**: Expertise that can also be explicitly invoked\n- **Agent + Skill**: Agent that uses skill expertise\n- **Hook + Script**: Event handler with external logic\n- **Command + Agent**: Command that spawns an agent for complex work\n\n**Present recommendation (in German):**\n\n\"Basierend auf deiner Beschreibung empfehle ich:\n\n**[Element-Typ]**: [Begr√ºndung]\n\n[Optional: Kombination mit anderem Element]\n\nM√∂chtest du so fortfahren, oder hast du Fragen zu den Element-Typen?\"\n\n---\n\n## Step 4: Gather Element Details\n\nBased on the chosen element type, ask for specific details using AskUserQuestion:\n\n### For Skills\n- Name (kebab-case)\n- When should it activate? (trigger conditions)\n- What expertise does it provide?\n- Related skills (if any)\n\n### For Commands\n- Command name (kebab-case, can include path like `category/name`)\n- What workflow does it execute?\n- Does it need user interaction during execution?\n- Should output be in German or English?\n\n### For Agents\n- Agent name (kebab-case)\n- What tasks should it handle autonomously?\n- Which tools does it need? (Bash, Read, Write, Edit, Grep, Glob, WebFetch, etc.)\n- Which model? (haiku for simple, sonnet for complex, opus for critical)\n- Does it need any skills?\n\n### For Hooks\n- Event type (PreToolCall, PostToolCall, UserPromptSubmit, Notification)\n- What should trigger it?\n- What action should it take?\n- Need external script or inline logic?\n\n### For Scripts\n- Script purpose\n- Language (TypeScript recommended)\n- Where will it be called from?\n\n---\n\n## Step 5: Analyze Existing Elements\n\nBefore creating, check for:\n1. **Duplicates**: Similar existing elements\n2. **Overlap**: Elements that might conflict\n3. **Integration**: Elements that should reference the new one\n\n```bash\n# Check existing elements\nls -la plugins/lt-dev/skills/\nls -la plugins/lt-dev/commands/\nls -la plugins/lt-dev/agents/\n```\n\n**If potential overlap found, inform user (in German):**\n\n\"Ich habe √§hnliche existierende Elemente gefunden:\n- [Element]: [Beschreibung]\n\nOptionen:\n1. Neues Element erstellen (mit klarer Abgrenzung)\n2. Bestehendes Element erweitern\n3. Elemente zusammenf√ºhren\n\nWas m√∂chtest du tun?\"\n\n---\n\n## Step 6: Generate Element\n\nCreate the element with proper structure following the templates from the `developing-claude-plugins` skill.\n\n### Quality Checklist (verify before creating)\n\n- [ ] Name follows kebab-case convention\n- [ ] YAML frontmatter is complete and correct\n- [ ] Description is concise and actionable\n- [ ] Structure matches existing elements in package\n- [ ] No overlap with existing elements\n- [ ] Cross-references to related elements included\n- [ ] Language is English (except user-facing German content)\n\n---\n\n## Step 7: Create Supporting Files (if needed)\n\n### For Skills\n- `SKILL.md` (main file)\n- `reference.md` (if detailed reference needed)\n- `examples.md` (if complex usage patterns)\n\n### For Hooks\n- Entry in `hooks.json`\n- Script file in `hooks/scripts/` if external logic needed\n\n---\n\n## Step 8: Verify Integration\n\nAfter creation:\n1. Check YAML syntax is valid\n2. Verify file is in correct location\n3. Confirm cross-references work\n4. Test command/skill invocation (if applicable)\n\n**Confirm to user (in German):**\n\n\"[Element-Typ] **[Name]** wurde erfolgreich erstellt:\n- Pfad: `[Dateipfad]`\n- [Weitere relevante Details]\n\nM√∂chtest du das Element direkt testen oder weitere Anpassungen vornehmen?\"\n\n---\n\n## Templates\n\n### Skill Template\nSee: `plugins/lt-dev/skills/developing-claude-plugins/SKILL.md`\n\n### Command Template\nSee: `plugins/lt-dev/commands/create-story.md`\n\n### Agent Template\nSee: `plugins/lt-dev/agents/npm-package-maintainer.md`\n\n---\n\n## Examples\n\n### Example 1: Creating a Code Review Skill\n\n**User:** \"Ich m√∂chte, dass Claude bei Code-Reviews automatisch auf unsere Coding-Standards achtet.\"\n\n**Recommendation:** Skill - Provides expertise that activates during code review contexts.\n\n**Result:**\n```\nplugins/lt-dev/skills/code-review-standards/\n‚îú‚îÄ‚îÄ SKILL.md\n‚îî‚îÄ‚îÄ standards.md\n```\n\n### Example 2: Creating a Scaffold Command\n\n**User:** \"Entwickler sollen per Command eine neue API-Route mit Controller, Service und Tests erstellen k√∂nnen.\"\n\n**Recommendation:** Command - User-triggered workflow with defined steps.\n\n**Result:**\n```\nplugins/lt-dev/commands/scaffold-api-route.md\n```\n\n### Example 3: Creating an Auto-Format Hook\n\n**User:** \"Nach jedem File-Write soll automatisch Prettier laufen.\"\n\n**Recommendation:** Hook - Automatic reaction to PostToolCall event for Write tool.\n\n**Result:**\n```\nplugins/lt-dev/hooks/hooks.json (updated)\nplugins/lt-dev/hooks/scripts/format-on-write.ts\n```\n",
        "plugins/lt-dev/commands/skill-optimize.md": "---\ndescription: Optimize and validate Claude skill files\n---\n\n# Skill Optimization\n\nAnalyze and optimize skill files for better Claude Code performance and compliance with official best practices.\n\n## When to Use This Command\n\n- After creating or modifying skills in this plugin\n- To validate all skills against current best practices\n- Before releasing plugin updates\n- When skills seem too large or aren't triggering correctly\n- To check frontmatter, file sizes, and naming conventions\n\n##  Step 1: Fetch Latest Best Practices\n\n** MANDATORY: Execute this step FIRST at every invocation!**\n\nUse WebFetch to download current official requirements:\n\n```\nhttps://code.claude.com/docs/en/skills\n```\n\nExtract and analyze:\n- Current file size recommendations (lines/tokens)\n- Frontmatter requirements (name, description formats)\n- Naming conventions (gerund vs noun vs action forms)\n- Progressive disclosure patterns\n- Content quality requirements\n- Anti-patterns to avoid\n- Any new requirements since last check\n\n##  Step 2: Validate All Skills\n\nRun automated validation checks on all skills in `plugins/lt-dev/skills/`:\n\n### A. Frontmatter Validation\n\nCheck required YAML frontmatter fields:\n\n```bash\necho \"=== Frontmatter Validation ===\"\nfor skill in plugins/lt-dev/skills/*/SKILL.md; do\n  name=$(basename $(dirname \"$skill\"))\n  echo \"--- $name ---\"\n\n  # Check name field\n  skill_name=$(grep \"^name:\" \"$skill\" | cut -d: -f2 | tr -d ' ')\n  if [ -n \"$skill_name\" ]; then\n    # Validate format: lowercase, numbers, hyphens only, max 64 chars\n    if echo \"$skill_name\" | grep -qE '^[a-z0-9-]+$'; then\n      len=${#skill_name}\n      if [ \"$len\" -le 64 ]; then\n        echo \" name: $skill_name ($len chars)\"\n      else\n        echo \" name: $skill_name (TOO LONG: $len chars, max 64)\"\n      fi\n    else\n      echo \" name: $skill_name (INVALID: use lowercase, numbers, hyphens only)\"\n    fi\n\n    # Check for reserved words\n    if echo \"$skill_name\" | grep -qE '(anthropic|claude)'; then\n      echo \"  WARNING: name contains reserved word\"\n    fi\n  else\n    echo \" name: MISSING\"\n  fi\n\n  # Check description field\n  desc=$(grep \"^description:\" \"$skill\" | cut -d: -f2-)\n  if [ -n \"$desc\" ]; then\n    desc_len=${#desc}\n    if [ \"$desc_len\" -le 1024 ]; then\n      echo \" description: $desc_len chars\"\n\n      # Check for first/second person (should be third person)\n      if echo \"$desc\" | grep -qiE '\\b(I|you|your|my)\\b'; then\n        echo \"  WARNING: description uses first/second person (should be third person)\"\n      fi\n\n      # Check for vagueness\n      if echo \"$desc\" | grep -qiE '\\b(helps|processes|manages|handles)\\s+(with|data|files)?\\s*$'; then\n        echo \"  WARNING: description may be too vague (add specifics and trigger terms)\"\n      fi\n    else\n      echo \" description: TOO LONG ($desc_len chars, max 1024)\"\n    fi\n  else\n    echo \" description: MISSING\"\n  fi\n\n  echo \"\"\ndone\n```\n\n**Validation criteria:**\n- [ ] `name` exists, lowercase/numbers/hyphens only, max 64 chars\n- [ ] `name` doesn't contain reserved words (\"anthropic\", \"claude\")\n- [ ] `description` exists, max 1024 chars\n- [ ] `description` in third person (not \"I\" or \"you\")\n- [ ] `description` includes specific actions and trigger terms\n- [ ] No XML tags in either field\n\n### B. File Size Validation\n\n**Official guideline: SKILL.md body < 500 lines**\n\n```bash\necho \"=== File Size Validation ===\"\nfor skill in plugins/lt-dev/skills/*/SKILL.md; do\n  name=$(basename $(dirname \"$skill\"))\n\n  # Count body lines (excluding frontmatter)\n  frontmatter_end=$(grep -n \"^---$\" \"$skill\" | tail -1 | cut -d: -f1)\n  body_lines=$(tail -n +$((frontmatter_end + 1)) \"$skill\" | wc -l)\n\n  printf \"%-30s %5d lines \" \"$name:\" \"$body_lines\"\n\n  if [ \"$body_lines\" -lt 500 ]; then\n    echo \" OPTIMAL\"\n  elif [ \"$body_lines\" -lt 800 ]; then\n    echo \"  ACCEPTABLE (consider optimization)\"\n  else\n    echo \" TOO LARGE (needs optimization)\"\n  fi\ndone\n```\n\n**Size targets:**\n-  **Optimal:** < 500 lines (Claude official recommendation)\n-  **Acceptable:** 500-800 lines (borderline)\n-  **Too Large:** > 800 lines (MUST optimize)\n\n### C. Progressive Disclosure Check\n\n**Official requirement: One-level-deep references only**\n\n```bash\necho \"=== Progressive Disclosure Check ===\"\nfor skill_dir in plugins/lt-dev/skills/*/; do\n  skill_name=$(basename \"$skill_dir\")\n  echo \"=== $skill_name ===\"\n\n  # Count reference files (one level deep)\n  ref_files=$(find \"$skill_dir\" -maxdepth 1 -name \"*.md\" ! -name \"SKILL.md\")\n  ref_count=$(echo \"$ref_files\" | grep -c \".\")\n\n  if [ \"$ref_count\" -gt 0 ]; then\n    echo \" Reference files: $ref_count\"\n    echo \"$ref_files\" | while read -r file; do\n      filename=$(basename \"$file\")\n      lines=$(wc -l < \"$file\")\n\n      # Check if file > 100 lines should have TOC\n      if [ \"$lines\" -gt 100 ]; then\n        if grep -q \"^## Table of Contents\" \"$file\" || grep -q \"^# Table of Contents\" \"$file\"; then\n          echo \"   $filename ($lines lines, has TOC)\"\n        else\n          echo \"    $filename ($lines lines, needs TOC)\"\n        fi\n      else\n        echo \"   $filename ($lines lines)\"\n      fi\n    done\n  else\n    echo \" Reference files: 0\"\n  fi\n\n  # Check for nested files (anti-pattern)\n  nested=$(find \"$skill_dir\" -mindepth 2 -name \"*.md\" 2>/dev/null)\n  if [ -n \"$nested\" ]; then\n    echo \"   WARNING: Nested files found (avoid deep nesting):\"\n    echo \"$nested\" | sed 's/^/    /'\n  fi\n\n  # Check for Windows-style paths in SKILL.md\n  if grep -q '\\\\' \"$skill_dir/SKILL.md\"; then\n    echo \"    WARNING: Windows-style backslashes found (use forward slashes)\"\n  fi\n\n  echo \"\"\ndone\n```\n\n**Rules:**\n-  Reference files one level deep from SKILL.md\n-  Files > 100 lines have table of contents\n-  Forward slashes in all paths\n-  Descriptive file names (not `doc1.md`, `utils.md`)\n-  No nested references (file ‚Üí file ‚Üí file)\n\n### D. Naming Convention Check\n\n**Recommended: Gerund form (processing-pdfs, analyzing-data)**\n\n```bash\necho \"=== Naming Convention Check ===\"\nfor skill in plugins/lt-dev/skills/*/SKILL.md; do\n  skill_name=$(grep \"^name:\" \"$skill\" | cut -d: -f2 | tr -d ' ')\n\n  # Check if gerund form (-ing)\n  if echo \"$skill_name\" | grep -qE -- '-(ing|izing|ising)(-|$)'; then\n    echo \" $skill_name (gerund form - recommended)\"\n  # Check if action-oriented\n  elif echo \"$skill_name\" | grep -qE '^(process|analyze|manage|generate|create|build|test)-'; then\n    echo \"  $skill_name (action-oriented - acceptable)\"\n  # Check if noun phrase\n  elif echo \"$skill_name\" | grep -qE -- '-ing$'; then\n    echo \" $skill_name (noun phrase with -ing - acceptable)\"\n  else\n    # Check for anti-patterns\n    if echo \"$skill_name\" | grep -qE '^(helper|utils|tools|common)'; then\n      echo \" $skill_name (VAGUE: avoid helper/utils/tools)\"\n    else\n      echo \"  $skill_name (consider gerund form: ${skill_name}ing or processing-${skill_name})\"\n    fi\n  fi\ndone\n```\n\n### E. Content Quality Scan\n\n```bash\necho \"=== Content Quality Scan ===\"\nfor skill in plugins/lt-dev/skills/*/SKILL.md; do\n  name=$(basename $(dirname \"$skill\"))\n  echo \"--- $name ---\"\n\n  # Check for common anti-patterns\n  if grep -qi \"magic number\" \"$skill\"; then\n    echo \"  Uses term 'magic number' - ensure values are justified\"\n  fi\n\n  if grep -qE '\\b(TODO|FIXME|XXX)\\b' \"$skill\"; then\n    echo \"  Contains TODO/FIXME markers\"\n  fi\n\n  if grep -q \"as of [0-9][0-9][0-9][0-9]\" \"$skill\"; then\n    echo \"  Contains time-sensitive information (use 'old patterns' section)\"\n  fi\n\n  # Check for inconsistent terminology\n  if grep -qi \"repository\" \"$skill\" && grep -qi \"repo\" \"$skill\"; then\n    echo \"  Inconsistent terminology: 'repository' and 'repo' both used\"\n  fi\n\n  echo \"\"\ndone\n```\n\n##  Step 3: Compare Against Fetched Best Practices\n\nCross-reference validation results with the best practices document from Step 1:\n\n1. **Verify size limits:** Still 500 lines body?\n2. **Check naming:** Still gerund-preferred?\n3. **Review frontmatter:** Any new required fields?\n4. **Scan anti-patterns:** Any new patterns to avoid?\n5. **Note changes:** Document differences from current implementation\n\nIf official guidelines have changed, update validation criteria accordingly.\n\n##  Step 4: Optimization (If Needed)\n\nFor skills > 500 lines, perform extraction:\n\n### A. Identify Large Sections\n\n```bash\n# Analyze section sizes in oversized SKILL.md\nawk '/^## / {\n  if (prev) print prev \" \" NR-start \" lines\"\n  prev=$0\n  start=NR\n}\nEND {\n  if (prev) print prev \" \" NR-start \" lines\"\n}' SKILL.md | sort -t' ' -k3 -rn\n```\n\n**Candidates for extraction (> 100 lines):**\n- Detailed workflows and processes\n- Extensive example collections\n- Long checklists\n- Reference tables\n- Troubleshooting guides\n- Historical context sections\n\n### B. Extract Content\n\n**1. Create reference file:**\n\n```markdown\n---\nname: skill-name-topic\ndescription: Detailed [topic] for skill-name skill\n---\n\n# [Topic Title]\n\n## Table of Contents\n(If file > 100 lines, REQUIRED)\n\n[Content extracted from SKILL.md]\n```\n\n**2. Replace in SKILL.md:**\n\n```markdown\n## [Topic]\n\n** Complete [topic] details: `topic-name.md`**\n\n**Quick overview:**\n- Essential point 1\n- Essential point 2\n- Essential point 3\n\n**Critical checklist:**\n- [ ] Must-know item 1\n- [ ] Must-know item 2\n```\n\n### C. Keep vs Extract\n\n**Keep in SKILL.md:**\n- Core workflow (numbered steps)\n- Critical warnings\n- \"When to Use\" section\n- Quick command reference\n- Essential checklists (< 10 items)\n\n**Extract to separate files:**\n- Detailed workflows (> 100 lines)\n- Extensive examples (> 50 lines)\n- Reference documentation\n- Troubleshooting guides\n- Historical \"old patterns\" sections\n\n##  Step 5: Generate Report\n\n```bash\necho \"==================================\"\necho \"  Skill Validation Report\"\necho \"==================================\"\necho \"\"\necho \" Summary:\"\ntotal=$(find src/templates/claude-skills -name \"SKILL.md\" | wc -l)\necho \"Total skills validated: $total\"\necho \"\"\n\necho \" Size Distribution:\"\noptimal=0\nacceptable=0\ntoo_large=0\n\nfor skill in plugins/lt-dev/skills/*/SKILL.md; do\n  frontmatter_end=$(grep -n \"^---$\" \"$skill\" | tail -1 | cut -d: -f1)\n  body_lines=$(tail -n +$((frontmatter_end + 1)) \"$skill\" | wc -l)\n\n  if [ \"$body_lines\" -lt 500 ]; then\n    optimal=$((optimal + 1))\n  elif [ \"$body_lines\" -lt 800 ]; then\n    acceptable=$((acceptable + 1))\n  else\n    too_large=$((too_large + 1))\n  fi\ndone\n\necho \"   Optimal (< 500 lines):    $optimal\"\necho \"    Acceptable (500-800):     $acceptable\"\necho \"   Too large (> 800):         $too_large\"\necho \"\"\n\necho \" Frontmatter Compliance:\"\ncomplete=0\nincomplete=0\n\nfor skill in plugins/lt-dev/skills/*/SKILL.md; do\n  if grep -q \"^name:\" \"$skill\" && grep -q \"^description:\" \"$skill\"; then\n    complete=$((complete + 1))\n  else\n    incomplete=$((incomplete + 1))\n  fi\ndone\n\necho \"   Complete:   $complete\"\necho \"   Incomplete: $incomplete\"\necho \"\"\n\necho \" Issues Requiring Attention:\"\nfor skill in plugins/lt-dev/skills/*/SKILL.md; do\n  name=$(basename $(dirname \"$skill\"))\n  issues=\"\"\n\n  # Check size\n  frontmatter_end=$(grep -n \"^---$\" \"$skill\" | tail -1 | cut -d: -f1)\n  body_lines=$(tail -n +$((frontmatter_end + 1)) \"$skill\" | wc -l)\n  if [ \"$body_lines\" -gt 800 ]; then\n    issues=\"${issues}- Size: $body_lines lines (optimize)\\n\"\n  fi\n\n  # Check frontmatter\n  if ! grep -q \"^name:\" \"$skill\"; then\n    issues=\"${issues}- Missing 'name' field\\n\"\n  fi\n  if ! grep -q \"^description:\" \"$skill\"; then\n    issues=\"${issues}- Missing 'description' field\\n\"\n  fi\n\n  # Check naming\n  skill_name=$(grep \"^name:\" \"$skill\" | cut -d: -f2 | tr -d ' ')\n  if echo \"$skill_name\" | grep -qE '^(helper|utils|tools)'; then\n    issues=\"${issues}- Vague name: $skill_name\\n\"\n  fi\n\n  if [ -n \"$issues\" ]; then\n    echo \"\"\n    echo \"$name:\"\n    echo -e \"$issues\"\n  fi\ndone\n\necho \"\"\necho \"==================================\"\necho \" Validation Complete\"\necho \"==================================\"\n```\n\n##  Step 6: Action Items\n\nBased on validation, create specific action items for each skill needing work:\n\n**Priority 1 (Critical):**\n- Missing frontmatter fields ‚Üí Add immediately\n- Invalid name format ‚Üí Fix format\n- > 800 lines ‚Üí Extract content\n\n**Priority 2 (Important):**\n- 500-800 lines ‚Üí Consider extraction\n- Vague descriptions ‚Üí Add specifics and trigger terms\n- Missing TOC in large files ‚Üí Add table of contents\n\n**Priority 3 (Nice to have):**\n- Improve naming (‚Üí gerund form)\n- Add concrete examples\n- Fix inconsistent terminology\n\n##  Step 7: Verification\n\nBefore completing, verify:\n- [ ] All skills have valid frontmatter (name + description)\n- [ ] All descriptions in third person with trigger terms\n- [ ] All names follow format (lowercase, hyphens, max 64 chars)\n- [ ] All SKILL.md files < 800 lines (ideally < 500)\n- [ ] Reference files > 100 lines have table of contents\n- [ ] No deeply nested file references\n- [ ] All paths use forward slashes\n- [ ] No vague names (helper, utils, tools)\n- [ ] Cross-referenced with latest best practices from Step 1\n\n##  References\n\nOfficial documentation:\n- https://code.claude.com/docs/en/skills\n- https://code.claude.com/docs/en/plugins\n\n##  Tips for Command Execution\n\n**For autonomous execution:**\n1. Start with WebFetch in Step 1 (MANDATORY)\n2. Run all validation scripts sequentially\n3. Generate full report in Step 5\n4. List specific action items for each skill\n5. Provide clear next steps to user\n\n**For interactive use:**\n- Show progress between steps\n- Highlight critical issues immediately\n- Provide examples of good fixes\n- Ask for clarification on borderline cases\n\n**Success indicators:**\n- All skills pass frontmatter validation\n- 80%+ skills under 500 lines\n- All issues documented with action items\n- Report includes comparison with latest best practices\n",
        "plugins/lt-dev/commands/vibe/build-plan.md": "---\ndescription: Plan + Build in one go (no interruption)\nargument-hint: [spec-file]\n---\n\n# Full Build (Plan + Build in One Go)\n\n## When to Use This Command\n\n- You have a `SPEC.md` and want complete implementation without interruption\n- You trust the automated planning and don't need to review before execution\n- You want the fastest path from spec to working implementation\n\n**Related commands:**\n- `/vibe:plan` - Create plan only (for review before execution)\n- `/vibe:build` - Execute existing plan only\n\n**For higher quality (recommended):**\n- Use `building-stories-with-tdd` skill for Test-Driven Development\n- TDD workflow: Backend tests ‚Üí Backend ‚Üí Frontend E2E tests ‚Üí Frontend\n- TDD ensures comprehensive test coverage and catches bugs early\n\n## Description\nPlan + Build in one go (no interruption).\n\n**ABORT HANDLING:** If the user wants to cancel at any point (e.g., \"abbrechen\", \"stop\", \"cancel\"), acknowledge: \"Build abgebrochen.\" and stop the process.\n\n## Prompt\n\n### Prerequisites\n\n1. **Check SPEC.md exists**\n   - If SPEC.md is missing, ask: \"Keine SPEC.md gefunden. Soll ich helfen eine zu erstellen, oder einen anderen Dateinamen verwenden?\"\n\nComplete implementation of SPEC.md from scratch.\n\n### STEP 1: PLANNING\n\nRead SPEC.md deeply and create **IMPLEMENTATION_PLAN.md**.\n\n#### CRITICAL: Implementation Order\n\n**ALWAYS follow this sequence:**\n1. **Docker setup first** - Hot reload, DB UI, Mailhog\n2. **Backend second** - Models, Services, Controllers + Initial User\n3. **Generate types** - `npm run generate-types`\n4. **Frontend** - Using generated types, NO mock data\n5. **Quality Assurance** - Lint + Build must pass\n6. **Browser Testing** - Test with Chrome MCP using initial user\n\n**All development runs in Docker!**\n\n#### Docker Check\n\nIf no `docker-compose.yml` exists in the project:\n- Ask: \"Kein Docker-Setup gefunden. Soll ich eines erstellen, oder m√∂chtest du ohne Docker entwickeln?\"\n- If user chooses non-Docker: Skip Docker phases, use local `npm run dev` commands instead\n\n#### Plan Structure (with checkboxes!)\n\n```markdown\n# Implementation Plan\n\n## Phase 1: Docker Setup\n- [ ] Create docker-compose.yml with hot reload\n- [ ] API service (NestJS with volume mounts)\n- [ ] Database service (MongoDB/PostgreSQL)\n- [ ] DB UI (Mongo Express for MongoDB / Adminer for SQL)\n- [ ] Mailhog for email testing\n- [ ] Frontend service (Nuxt with hot reload)\n- [ ] Verify all services start (`docker compose up -d`)\n\n## Phase 2: Backend Foundation\n- [ ] Database models\n- [ ] Core services\n- [ ] Controllers & endpoints\n- [ ] Initial user migration (admin@test.local / Test1234!)\n\n## Phase 3: Backend Features\n- [ ] Feature A - Backend\n- [ ] Feature B - Backend\n\n## Phase 4: Types Generation\n- [ ] Verify API running (`docker compose logs api`)\n- [ ] Generate types (`npm run generate-types`)\n\n## Phase 5: Frontend Integration\n- [ ] Feature A - Frontend (with real API)\n- [ ] Feature B - Frontend (with real API)\n\n## Phase 6: Quality Assurance\n- [ ] Run lint (`npm run lint`)\n- [ ] Fix lint errors\n- [ ] Run build (`npm run build`)\n- [ ] Fix build errors\n\n## Phase 7: Browser Testing (Chrome MCP)\n- [ ] Open app (http://localhost:3001)\n- [ ] Login with initial user\n- [ ] Test all features\n- [ ] Fix discovered bugs\n- [ ] Re-test after fixes\n\n## Phase 8: Final Verification\n- [ ] All features working\n- [ ] No console errors\n- [ ] Lint passes\n- [ ] Build passes\n```\n\n#### Docker Services Required\n\n| Service | Port | Purpose |\n|---------|------|---------|\n| api | 3000 | NestJS Backend (hot reload) |\n| app | 3001 | Nuxt Frontend (hot reload) |\n| db | 27017/5432 | MongoDB or PostgreSQL |\n| db-ui | 8081 | Mongo Express or Adminer |\n| mailhog | 1025/8025 | SMTP + Web UI for emails |\n\nInclude: Architecture decisions, file structure, edge cases, testing strategy.\n\nUltrathink: What's the cleanest, most maintainable way to build this?\n\n---\n\n### STEP 2: EXECUTION\n\n#### CRITICAL: Execution Rules\n\n1. **Follow the order** - Docker ‚Üí Backend ‚Üí Types ‚Üí Frontend ‚Üí QA ‚Üí Browser Test\n2. **Docker setup first** - Hot reload, DB UI, Mailhog before any code\n3. **Initial user migration** - Create test user for browser testing\n4. **No mock data** - Frontend always uses real backend API\n5. **Checkbox after EVERY task** - Mark `- [x]` immediately after completing\n6. **DO NOT STOP** until all checkboxes are checked AND browser testing passes\n\n#### Workflow\n\n```\nPhase 1: Docker Setup\n1. Create docker-compose.yml with all services\n2. Verify: docker compose up -d && docker compose ps\n\nPhase 2-3: Backend\n1. Implement backend (models, services, controllers)\n2. Create initial user migration (admin@test.local / Test1234!)\n3. Docker rebuilds automatically (hot reload)\n4. Mark checkboxes after each feature\n\nPhase 4: Types\n1. Verify API: docker compose logs api\n2. Generate: npm run generate-types\n\nPhase 5: Frontend\n1. Implement using ~/api-client/ types\n2. Mark checkboxes after each feature\n\nPhase 6: Quality Assurance\n1. Run: npm run lint\n2. Fix all lint errors\n3. Run: npm run build\n4. Fix all build errors\n\nPhase 7: Browser Testing (Chrome MCP)\n1. Navigate to http://localhost:3001\n2. Take snapshot to see page\n3. Login with initial user (admin@test.local / Test1234!)\n4. Test each implemented feature\n5. Check console: list_console_messages\n6. Fix any bugs found\n7. Re-test until everything works\n\nPhase 8: Final Verification\n1. All features working in browser\n2. No console errors\n3. Lint passes\n4. Build passes\n5. ALL checkboxes marked [x]\n```\n\n#### Docker Commands\n\n| Command | Purpose |\n|---------|---------|\n| `docker compose up -d` | Start all services |\n| `docker compose logs -f api` | Watch API logs |\n| `docker compose logs -f app` | Watch Frontend logs |\n| `docker compose restart api` | Restart API |\n| `docker compose ps` | Check running containers |\n\n#### Service URLs (Development)\n\n| Service | URL |\n|---------|-----|\n| Frontend | http://localhost:3001 |\n| API | http://localhost:3000 |\n| API Docs | http://localhost:3000/api |\n| DB UI | http://localhost:8081 |\n| Mailhog | http://localhost:8025 |\n\n#### Execution\n\n- Work through phases **sequentially**\n- Build **complete features**, not stubs\n- Update IMPLEMENTATION_PLAN.md checkboxes **after each task**\n- Use `generating-nest-servers` skill for backend\n- Use `developing-lt-frontend` skill for frontend\n- Make smart decisions **autonomously**\n\n#### Initial User Credentials\n\n```\nEmail:    admin@test.local\nPassword: Test1234!\nRole:     admin\n```\n\n#### Browser Testing Commands (Chrome MCP)\n\n| Command | Purpose |\n|---------|---------|\n| `navigate_page` | Go to URL |\n| `take_snapshot` | Get page elements |\n| `fill` | Enter text in input |\n| `click` | Click element |\n| `list_console_messages` | Check for errors |\n| `list_network_requests` | Debug API calls |\n\n#### Completion Criteria\n\n**DO NOT STOP until:**\n- All `- [ ]` in IMPLEMENTATION_PLAN.md are `- [x]`\n- All features from SPEC.md are implemented\n- `npm run lint` passes\n- `npm run build` passes\n- Browser testing completed with Chrome MCP\n- All bugs found during testing are fixed\n- App works end-to-end (login ‚Üí use features ‚Üí logout)\n\nOnly interrupt for critical blockers.\n\n**BEGIN PLANNING NOW. THEN EXECUTE UNTIL 100% COMPLETE INCLUDING BROWSER TESTING.**\n\n### Troubleshooting\n\n| Problem | L√∂sung |\n|---------|--------|\n| `generate-types` fails | Check if API is running: `docker compose logs api` |\n| Docker won't start | Check ports: `lsof -i :3000 -i :3001` |\n| Lint errors | Run `npm run lint:fix` first, then re-run lint |\n| Build fails | Check console output, often missing imports or type errors |\n| API not responding | `docker compose restart api` and check logs |\n",
        "plugins/lt-dev/commands/vibe/build.md": "---\ndescription: Execute IMPLEMENTATION_PLAN.md completely\nargument-hint: [plan-file]\n---\n\n# Build\n\n## When to Use This Command\n\n- You already have an `IMPLEMENTATION_PLAN.md` (created manually or via `/vibe:plan`)\n- You want to execute the plan completely without interruption\n- You've reviewed and approved the implementation plan\n\n**Related commands:**\n- `/vibe:plan` - Create a plan first (if you don't have one)\n- `/vibe:build-plan` - Plan + Build in one go (no interruption)\n\n**For higher quality (recommended):**\n- Use `building-stories-with-tdd` skill for Test-Driven Development\n- TDD workflow: Backend tests ‚Üí Backend ‚Üí Frontend E2E tests ‚Üí Frontend\n- TDD ensures tests exist BEFORE implementation, catching bugs early\n\n## Description\nExecute IMPLEMENTATION_PLAN.md completely.\n\n**ABORT HANDLING:** If the user wants to cancel at any point (e.g., \"abbrechen\", \"stop\", \"cancel\"), acknowledge: \"Build abgebrochen.\" and stop the process.\n\n## Prompt\nRead IMPLEMENTATION_PLAN.md and SPEC.md.\n\n### CRITICAL: Execution Rules\n\n1. **Follow the order** - Docker ‚Üí Backend ‚Üí Types ‚Üí Frontend ‚Üí QA ‚Üí Browser Test\n2. **Docker setup first** - Hot reload, DB UI, Mailhog before any code\n3. **Initial user migration** - Create test user for browser testing\n4. **No mock data** - Frontend always uses real backend API\n5. **Checkbox after EVERY task** - Mark `- [x]` immediately after completing each item\n6. **DO NOT STOP** until all checkboxes are checked AND browser testing passes\n7. **Only interrupt** for critical blockers (missing credentials, major ambiguities)\n\n### Workflow\n\n```\nPhase 1: Docker Setup\n1. Create docker-compose.yml with all services\n2. Verify: docker compose up -d && docker compose ps\n\nPhase 2-3: Backend\n1. Implement backend (models, services, controllers)\n2. Create initial user migration (admin@test.local / Test1234!)\n3. Docker rebuilds automatically (hot reload)\n4. Mark checkboxes after each feature\n\nPhase 4: Types\n1. Verify API: docker compose logs api\n2. Generate: npm run generate-types\n\nPhase 5: Frontend\n1. Implement using ~/api-client/ types\n2. Mark checkboxes after each feature\n\nPhase 6: Quality Assurance\n1. Run: npm run lint\n2. Fix all lint errors\n3. Run: npm run build\n4. Fix all build errors\n\nPhase 7: Browser Testing (Chrome MCP)\n1. Navigate to http://localhost:3001\n2. Take snapshot to see page\n3. Login with initial user (admin@test.local / Test1234!)\n4. Test each implemented feature\n5. Check console: list_console_messages\n6. Fix any bugs found\n7. Re-test until everything works\n\nPhase 8: Final Verification\n1. All features working in browser\n2. No console errors\n3. Lint passes\n4. Build passes\n5. ALL checkboxes marked [x]\n```\n\n### Docker Commands\n\n| Command | Purpose |\n|---------|---------|\n| `docker compose up -d` | Start all services |\n| `docker compose logs -f api` | Watch API logs |\n| `docker compose logs -f app` | Watch Frontend logs |\n| `docker compose restart api` | Restart API |\n| `docker compose ps` | Check running containers |\n\n### Service URLs (Development)\n\n| Service | URL |\n|---------|-----|\n| Frontend | http://localhost:3001 |\n| API | http://localhost:3000 |\n| API Docs | http://localhost:3000/api |\n| DB UI | http://localhost:8081 |\n| Mailhog | http://localhost:8025 |\n\n### Execution\n\n- Work through IMPLEMENTATION_PLAN.md **sequentially**\n- Build **complete features**, not stubs\n- Update checkboxes in IMPLEMENTATION_PLAN.md **after each task**\n- Make reasonable decisions **autonomously**\n- Use `generating-nest-servers` skill for backend\n- Use `developing-lt-frontend` skill for frontend\n\n### Initial User Credentials\n\n```\nEmail:    admin@test.local\nPassword: Test1234!\nRole:     admin\n```\n\n### Browser Testing Commands (Chrome MCP)\n\n| Command | Purpose |\n|---------|---------|\n| `navigate_page` | Go to URL |\n| `take_snapshot` | Get page elements |\n| `fill` | Enter text in input |\n| `click` | Click element |\n| `list_console_messages` | Check for errors |\n| `list_network_requests` | Debug API calls |\n\n### Completion Criteria\n\n**DO NOT STOP until:**\n- All `- [ ]` in IMPLEMENTATION_PLAN.md are `- [x]`\n- All features from SPEC.md are implemented\n- `npm run lint` passes\n- `npm run build` passes\n- Browser testing completed with Chrome MCP\n- All bugs found during testing are fixed\n- App works end-to-end (login ‚Üí use features ‚Üí logout)\n\nUltrathink.\n\n**START IMPLEMENTATION NOW. CONTINUE UNTIL 100% COMPLETE INCLUDING BROWSER TESTING.**\n\n### Troubleshooting\n\n| Problem | L√∂sung |\n|---------|--------|\n| `generate-types` fails | Check if API is running: `docker compose logs api` |\n| Docker won't start | Check ports: `lsof -i :3000 -i :3001` |\n| Lint errors | Run `npm run lint:fix` first, then re-run lint |\n| Build fails | Check console output, often missing imports or type errors |\n| API not responding | `docker compose restart api` and check logs |\n",
        "plugins/lt-dev/commands/vibe/plan.md": "---\ndescription: Create detailed implementation plan from SPEC.md\nargument-hint: [spec-file]\n---\n\n# Plan\n\n## When to Use This Command\n\n- You have a `SPEC.md` with feature requirements\n- You want to create a detailed implementation plan before coding\n- You need to review and approve the plan before execution\n- Use `/vibe:build` afterwards to execute the plan\n\n**Related commands:**\n- `/vibe:build` - Execute an existing IMPLEMENTATION_PLAN.md\n- `/vibe:build-plan` - Plan + Build in one go (no interruption)\n\n**For higher quality (recommended):**\n- Use `building-stories-with-tdd` skill for Test-Driven Development\n- TDD workflow: Backend tests ‚Üí Backend ‚Üí Frontend E2E tests ‚Üí Frontend\n\n## Description\nCreate detailed implementation plan from SPEC.md.\n\n**ABORT HANDLING:** If the user wants to cancel at any point (e.g., \"abbrechen\", \"stop\", \"cancel\"), acknowledge: \"Planning abgebrochen.\" and stop the process.\n\n## Prompt\n\n### Prerequisites\n\n1. **Check SPEC.md exists**\n   - If SPEC.md is missing, ask: \"Keine SPEC.md gefunden. Soll ich helfen eine zu erstellen, oder einen anderen Dateinamen verwenden?\"\n\nRead SPEC.md and create a comprehensive implementation plan.\n\n### CRITICAL: Implementation Order\n\n**ALWAYS follow this sequence for each feature:**\n1. **Backend first** - Models, Services, Controllers\n2. **Start Docker** - `docker compose up -d` (API + DB)\n3. **Generate types** - `npm run generate-types`\n4. **Frontend last** - Using generated types, NO mock data\n\n**All development runs in Docker!**\n\n### Docker Check\n\nIf no `docker-compose.yml` exists in the project:\n- Ask: \"Kein Docker-Setup gefunden. Soll ich eines erstellen, oder m√∂chtest du ohne Docker entwickeln?\"\n- If user chooses non-Docker: Skip Docker phases, use local `npm run dev` commands instead\n\n### Plan Structure\n\nCreate **IMPLEMENTATION_PLAN.md** with checkboxes:\n\n```markdown\n# Implementation Plan\n\n## Phase 1: Docker Setup\n- [ ] Create docker-compose.yml with hot reload\n- [ ] API service (NestJS with volume mounts)\n- [ ] Database service (MongoDB/PostgreSQL)\n- [ ] DB UI (Mongo Express for MongoDB / Adminer for SQL)\n- [ ] Mailhog for email testing\n- [ ] Frontend service (Nuxt with hot reload)\n- [ ] Verify all services start (`docker compose up -d`)\n\n## Phase 2: Backend Foundation\n- [ ] Database models\n- [ ] Core services\n- [ ] Controllers & endpoints\n- [ ] Initial user migration (for testing login)\n\n## Phase 3: Backend Features\n- [ ] Feature A - Backend\n- [ ] Feature B - Backend\n- [ ] ...\n\n## Phase 4: Types Generation\n- [ ] Verify API running (`docker compose logs api`)\n- [ ] Generate types (`npm run generate-types`)\n\n## Phase 5: Frontend Integration\n- [ ] Feature A - Frontend (with real API)\n- [ ] Feature B - Frontend (with real API)\n- [ ] ...\n\n## Phase 6: Quality Assurance\n- [ ] Run lint (`npm run lint`)\n- [ ] Fix lint errors\n- [ ] Run build (`npm run build`)\n- [ ] Fix build errors\n\n## Phase 7: Browser Testing (Chrome MCP)\n- [ ] Open app in browser (http://localhost:3001)\n- [ ] Login with initial user\n- [ ] Test all implemented features\n- [ ] Fix any discovered bugs\n- [ ] Re-test after fixes\n\n## Phase 8: Final Verification\n- [ ] All features working\n- [ ] No console errors\n- [ ] Lint passes\n- [ ] Build passes\n```\n\n### Docker Services Required\n\n| Service | Port | Purpose |\n|---------|------|---------|\n| api | 3000 | NestJS Backend (hot reload) |\n| app | 3001 | Nuxt Frontend (hot reload) |\n| db | 27017/5432 | MongoDB or PostgreSQL |\n| db-ui | 8081 | Mongo Express or Adminer |\n| mailhog | 1025/8025 | SMTP + Web UI for emails |\n\n### Initial User (for Testing)\n\nCreate a migration/seed that creates an initial user:\n\n```typescript\n// Example initial user\n{\n  email: 'admin@test.local',\n  password: 'Test1234!',\n  role: 'admin'\n}\n```\n\n**Document credentials in IMPLEMENTATION_PLAN.md** for browser testing.\n\n### Browser Testing with Chrome MCP\n\nAfter all features are implemented:\n\n1. **Navigate** to http://localhost:3001\n2. **Take snapshot** to see current page\n3. **Login** with initial user credentials\n4. **Test each feature** - click, fill forms, verify results\n5. **Check console** for errors (`list_console_messages`)\n6. **Fix bugs** discovered during testing\n7. **Re-test** until everything works\n\n### Requirements\n\n1. **Docker setup first** - Hot reload, DB UI, Mailhog\n2. **Initial user migration** - For browser testing\n3. **Architecture & Tech Stack** decisions with rationale\n4. **File/folder structure** for both backend and frontend\n5. **Implementation phases** with explicit Docker ‚Üí Backend ‚Üí Types ‚Üí Frontend ‚Üí Test order\n6. **Every task as checkbox** `- [ ]` for tracking\n7. **No mock data** - Frontend always connects to real backend\n8. **Browser testing** - Test with Chrome MCP after implementation\n9. **Quality gates** - Lint and build must pass\n\nUltrathink. Be thorough - this planning will guide the entire build.\n\nSave as **IMPLEMENTATION_PLAN.md**\n\n### Troubleshooting\n\n| Problem | L√∂sung |\n|---------|--------|\n| `generate-types` fails | Check if API is running: `docker compose logs api` |\n| Docker won't start | Check ports: `lsof -i :3000 -i :3001` |\n| Lint errors | Run `npm run lint:fix` first, then re-run lint |\n| Build fails | Check console output, often missing imports or type errors |\n| API not responding | `docker compose restart api` and check logs |\n",
        "plugins/lt-dev/hooks/hooks.json": "{\n  \"description\": \"Project detection and validation hooks\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx ts-node \\\"${CLAUDE_PLUGIN_ROOT}/hooks/scripts/validate-plugin-frontmatter.ts\\\"\"\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash \\\"${CLAUDE_PLUGIN_ROOT}/hooks/scripts/detect-nuxt.sh\\\"\"\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"bash \\\"${CLAUDE_PLUGIN_ROOT}/hooks/scripts/detect-nest-server.sh\\\"\"\n          },\n          {\n            \"type\": \"command\",\n            \"command\": \"bash \\\"${CLAUDE_PLUGIN_ROOT}/hooks/scripts/detect-lt-cli.sh\\\"\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "plugins/lt-dev/hooks/scripts/detect-lt-cli.sh": "#!/bin/bash\n# Detect lenne.tech CLI and suggest using-lt-cli skill\n\nif command -v lt &>/dev/null; then\n  echo '{\"hookSpecificOutput\":{\"hookEventName\":\"UserPromptSubmit\",\"additionalContext\":\"lenne.tech CLI detected. Use the using-lt-cli skill for Git operations (lt git get, lt git reset) and Fullstack initialization (lt fullstack init).\"}}'\n  exit 0\nfi\n\nexit 0\n",
        "plugins/lt-dev/hooks/scripts/detect-nest-server.sh": "#!/bin/bash\n# Detect @lenne.tech/nest-server and suggest generating-nest-servers skill\n\ncheck_nest_server() {\n  [ -f \"$1\" ] && grep -q '@lenne\\.tech/nest-server' \"$1\" 2>/dev/null\n}\n\n# Check project root\nif check_nest_server \"$CLAUDE_PROJECT_DIR/package.json\"; then\n  echo '{\"hookSpecificOutput\":{\"hookEventName\":\"UserPromptSubmit\",\"additionalContext\":\"@lenne.tech/nest-server detected. Use the generating-nest-servers skill for backend tasks.\"}}'\n  exit 0\nfi\n\n# Check monorepo patterns\nfor pkg in \"$CLAUDE_PROJECT_DIR\"/projects/*/package.json \"$CLAUDE_PROJECT_DIR\"/packages/*/package.json \"$CLAUDE_PROJECT_DIR\"/apps/*/package.json; do\n  if check_nest_server \"$pkg\"; then\n    echo '{\"hookSpecificOutput\":{\"hookEventName\":\"UserPromptSubmit\",\"additionalContext\":\"@lenne.tech/nest-server detected in monorepo. Use the generating-nest-servers skill for backend tasks.\"}}'\n    exit 0\n  fi\ndone\n\nexit 0\n",
        "plugins/lt-dev/hooks/scripts/detect-nuxt.sh": "#!/bin/bash\n# Detect Nuxt 4 frontend projects and suggest developing-lt-frontend skill\n\ncheck_nuxt() {\n  [ -f \"$1/nuxt.config.ts\" ] || [ -f \"$1/nuxt.config.js\" ]\n}\n\ncheck_app_dir() {\n  [ -d \"$1/app/components\" ] || [ -d \"$1/app/composables\" ] || [ -d \"$1/app/pages\" ]\n}\n\n# Check project root\nif check_nuxt \"$CLAUDE_PROJECT_DIR\" && check_app_dir \"$CLAUDE_PROJECT_DIR\"; then\n  echo '{\"hookSpecificOutput\":{\"hookEventName\":\"UserPromptSubmit\",\"additionalContext\":\"Nuxt 4 project detected. Use the developing-lt-frontend skill for frontend tasks.\"}}'\n  exit 0\nfi\n\n# Check monorepo patterns\nfor dir in \"$CLAUDE_PROJECT_DIR\"/projects/app \"$CLAUDE_PROJECT_DIR\"/packages/app \"$CLAUDE_PROJECT_DIR\"/apps/app; do\n  if [ -d \"$dir\" ] && check_nuxt \"$dir\"; then\n    echo '{\"hookSpecificOutput\":{\"hookEventName\":\"UserPromptSubmit\",\"additionalContext\":\"Nuxt 4 monorepo detected. Use the developing-lt-frontend skill for frontend tasks.\"}}'\n    exit 0\n  fi\ndone\n\nexit 0\n",
        "plugins/lt-dev/hooks/scripts/validate-plugin-frontmatter.ts": "#!/usr/bin/env npx ts-node\n\n/**\n * Plugin Frontmatter Validation Hook\n *\n * Validates YAML frontmatter in plugin markdown files (skills, commands, agents).\n * Called as PreToolUse hook for Write operations on plugin files.\n *\n * Usage: Called automatically by hooks.json when writing to **/plugins/**/*.md\n */\n\nimport * as fs from 'fs';\n\n// Types\ninterface HookInput {\n  tool: string;\n  tool_input: {\n    file_path?: string;\n    content?: string;\n  };\n}\n\ninterface ValidationResult {\n  decision: 'allow' | 'block';\n  reason?: string;\n}\n\ninterface Frontmatter {\n  name?: string;\n  description?: string;\n  model?: string;\n  tools?: string;\n  'allowed-tools'?: string;\n  'argument-hint'?: string;\n  [key: string]: unknown;\n}\n\n// Simple YAML frontmatter parser (no external dependencies)\nfunction parseYamlFrontmatter(content: string): Frontmatter | null {\n  const match = content.match(/^---\\r?\\n([\\s\\S]*?)\\r?\\n---/);\n  if (!match) return null;\n\n  const yaml = match[1];\n  const result: Frontmatter = {};\n\n  for (const line of yaml.split('\\n')) {\n    const trimmedLine = line.trim();\n    if (!trimmedLine || trimmedLine.startsWith('#')) continue;\n\n    const colonIndex = trimmedLine.indexOf(':');\n    if (colonIndex > 0) {\n      const key = trimmedLine.slice(0, colonIndex).trim();\n      let value = trimmedLine.slice(colonIndex + 1).trim();\n\n      // Remove quotes if present\n      if ((value.startsWith('\"') && value.endsWith('\"')) ||\n          (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n        value = value.slice(1, -1);\n      }\n\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n// Validation logic\nfunction validateFrontmatter(filePath: string, content: string): ValidationResult {\n  // Only validate markdown files\n  if (!filePath.endsWith('.md') && !filePath.endsWith('.MD')) {\n    return { decision: 'allow' };\n  }\n\n  // Only validate files in plugin directories\n  const isPluginFile = filePath.match(/\\/(skills|commands|agents)\\//);\n  if (!isPluginFile) {\n    return { decision: 'allow' };\n  }\n\n  // Check for YAML frontmatter presence\n  if (!content.trim().startsWith('---')) {\n    return {\n      decision: 'block',\n      reason: 'Plugin markdown files require YAML frontmatter (file must start with ---)'\n    };\n  }\n\n  // Parse frontmatter\n  const frontmatter = parseYamlFrontmatter(content);\n  if (!frontmatter) {\n    return {\n      decision: 'block',\n      reason: 'YAML frontmatter is not properly closed (missing closing ---)'\n    };\n  }\n\n  // Validate SKILL.md files\n  if (filePath.includes('/skills/') && filePath.endsWith('SKILL.md')) {\n    const missing: string[] = [];\n\n    if (!frontmatter.name) missing.push('name');\n    if (!frontmatter.description) missing.push('description');\n\n    if (missing.length > 0) {\n      return {\n        decision: 'block',\n        reason: `SKILL.md requires these fields in frontmatter: ${missing.join(', ')}`\n      };\n    }\n\n    // Validate description length (max 1024 chars per official docs)\n    if (frontmatter.description && frontmatter.description.length > 1024) {\n      return {\n        decision: 'block',\n        reason: `Skill description too long (${frontmatter.description.length} chars). Maximum is 1024 characters.`\n      };\n    }\n  }\n\n  // Validate agent files\n  if (filePath.includes('/agents/') && !filePath.includes('/skills/')) {\n    const required = ['name', 'description', 'model', 'tools'];\n    const missing = required.filter(field => !frontmatter[field]);\n\n    if (missing.length > 0) {\n      return {\n        decision: 'block',\n        reason: `Agent file missing required fields: ${missing.join(', ')}`\n      };\n    }\n\n    // Validate model value\n    const validModels = ['haiku', 'sonnet', 'opus'];\n    const model = frontmatter.model?.toLowerCase();\n    if (model && !validModels.some(m => model.includes(m))) {\n      return {\n        decision: 'block',\n        reason: `Invalid model \"${frontmatter.model}\". Use: haiku, sonnet, or opus`\n      };\n    }\n  }\n\n  // Validate command files\n  if (filePath.includes('/commands/')) {\n    if (!frontmatter.description) {\n      return {\n        decision: 'block',\n        reason: 'Command file requires \"description\" field in frontmatter'\n      };\n    }\n  }\n\n  return { decision: 'allow' };\n}\n\n// Main execution\nfunction main(): void {\n  try {\n    const inputData = fs.readFileSync(0, 'utf-8');\n    const input: HookInput = JSON.parse(inputData);\n\n    const filePath = input.tool_input?.file_path || '';\n    const content = input.tool_input?.content || '';\n\n    const result = validateFrontmatter(filePath, content);\n\n    if (result.decision === 'block') {\n      console.log(JSON.stringify(result));\n    }\n\n    process.exit(0);\n  } catch (error) {\n    // On any error, allow the operation (fail-open)\n    // This prevents the hook from blocking legitimate operations\n    process.exit(0);\n  }\n}\n\nmain();\n",
        "plugins/lt-dev/skills/building-stories-with-tdd/SKILL.md": "---\nname: building-stories-with-tdd\ndescription: Expert for building user stories using Test-Driven Development (TDD) with NestJS and @lenne.tech/nest-server. Implements new features by creating story tests first in tests/stories/, then uses generating-nest-servers skill to develop code until all tests pass. Ensures high code quality and security compliance. Use in projects with @lenne.tech/nest-server in package.json dependencies (supports monorepos with projects/*, packages/*, apps/* structure).\n---\n\n# Story-Based Test-Driven Development Expert\n\nYou are an expert in Test-Driven Development (TDD) for NestJS applications using @lenne.tech/nest-server. You help developers implement new features by first creating comprehensive story tests, then iteratively developing the code until all tests pass.\n\n## When to Use This Skill\n\n**ALWAYS use this skill for:**\n- Implementing new API features using Test-Driven Development\n- Creating story tests for user stories or requirements\n- Developing new functionality in a test-first approach\n- Ensuring comprehensive test coverage for new features\n- Iterative development with test validation\n- **Fullstack TDD workflows** (Backend + Frontend E2E tests)\n\n## Fullstack TDD Workflow\n\n**For fullstack projects, follow this order:**\n\n```\nPhase 1: BACKEND\n‚îú‚îÄ‚îÄ 1. Write Backend Tests (API tests for REST/GraphQL)\n‚îî‚îÄ‚îÄ 2. Implement Backend against tests (iterate until green)\n\nPhase 2: FRONTEND\n‚îú‚îÄ‚îÄ 3. Write Frontend E2E Tests (Playwright)\n‚îî‚îÄ‚îÄ 4. Implement Frontend against tests (iterate until green)\n\nPhase 3: VERIFICATION\n‚îî‚îÄ‚îÄ 5. Debug with Chrome MCP/DevTools\n```\n\n**Complete workflow details: `fullstack-tdd-workflow.md`**\n\n### Test Isolation & Cleanup (CRITICAL)\n\n**Tests MUST be repeatable without side effects:**\n\n1. **Unique test data** - Use `${Date.now()}-${random}` patterns\n2. **Complete cleanup in `afterAll`** - Delete all created entities\n3. **Separate test database** - `app-test` vs `app-dev`\n4. **No cross-test dependencies** - Each test file is independent\n\n```typescript\nafterAll(async () => {\n  // Delete test-created entities\n  await db.collection('entities').deleteMany({ createdBy: testUserId });\n  // Delete test users\n  await db.collection('users').deleteMany({ email: /@test\\.com$/ });\n});\n```\n\n**Why this matters:** Enables unlimited test runs without manual database cleanup.\n\n## Related Skills\n\n**Works closely with:**\n- `generating-nest-servers` skill - For code implementation (modules, objects, properties)\n- `using-lt-cli` skill - For Git operations and project initialization\n- `developing-lt-frontend` skill - For frontend E2E tests and implementation\n\n**When to use which:**\n- Building new features with TDD? Use this skill (building-stories-with-tdd)\n- Direct NestJS work without TDD? Use `generating-nest-servers` skill\n- Git operations? Use `using-lt-cli` skill\n- Frontend E2E testing and implementation? Use `developing-lt-frontend` skill\n\n## TypeScript Language Server (Recommended)\n\n**Use the LSP tool when available** for faster and more accurate code analysis:\n\n| Operation | Use Case in TDD |\n|-----------|-----------------|\n| `goToDefinition` | Navigate to Controller/Service/Model definitions |\n| `findReferences` | Find all usages of a method or property |\n| `hover` | Get type info for parameters and return types |\n| `documentSymbol` | List all methods in a Controller or Service |\n| `goToImplementation` | Find Service implementations of interfaces |\n\n**When to use LSP (especially Step 1 & 4):**\n- Verifying endpoint existence ‚Üí `documentSymbol` on Controller\n- Finding method signatures ‚Üí `hover`, `goToDefinition`\n- Understanding dependencies ‚Üí `findReferences`, `goToImplementation`\n\n**Installation (if LSP not available):**\n```bash\nclaude plugins install typescript-lsp --marketplace claude-plugins-official\n```\n\n---\n\n## GOLDEN RULES: API-First Testing\n\n**READ THIS BEFORE WRITING ANY TEST!**\n\n### Rule 1: Test Through API Only\n\n**Tests MUST go through REST/GraphQL interfaces using TestHelper. Direct Service or Database access in test logic makes tests WORTHLESS.**\n\n**Why this rule is absolute:**\n- **Security**: Direct Service calls bypass authentication, authorization, guards, decorators\n- **Reality**: Tests must verify what actual users experience through the API\n- **Worthless**: Tests bypassing the API cannot catch real bugs in the security layer\n\n**ALWAYS:**\n- Use `testHelper.rest()` for REST endpoints\n- Use `testHelper.graphQl()` for GraphQL operations\n- Test the complete chain: API -> Guards -> Service -> Database\n\n**NEVER:**\n- Call Services directly: `userService.create()`\n- Query DB in tests: `db.collection('users').findOne()`\n- Mock Controllers/Resolvers\n\n**Only Exception: Setup/Cleanup**\n- Setting roles: `db.collection('users').updateOne({ _id: id }, { $set: { roles: ['admin'] } })`\n- Setting verified: `db.collection('users').updateOne({ _id: id }, { $set: { verified: true } })`\n- Cleanup: `db.collection('entities').deleteMany({ createdBy: userId })`\n\n### Rule 2: Verify Before Assuming\n\n**NEVER assume endpoints, methods, or properties exist - ALWAYS verify by reading the actual code!**\n\n**BEFORE writing tests:**\n- Read Controller files to verify endpoints exist\n- Read Resolver files to verify GraphQL operations exist\n- Read existing tests to understand patterns\n- Document what you verified with file references\n\n**BEFORE implementing:**\n- Read Service files to verify method signatures\n- Read Model files to verify properties and types\n- Read CrudService base class to understand inherited methods\n- Check actual code, don't assume!\n\n**NEVER:**\n- Assume an endpoint exists without reading the controller\n- Assume a method signature without reading the service\n- Guess property names without reading the model\n\n**Full details in Steps 1, 2, and 4 below.**\n\n---\n\n## Core TDD Workflow - The Seven Steps\n\n**Complete workflow details: `workflow.md`**\n\n**Process:** Step 1 (Analysis) -> Step 2 (Create Test) -> Step 3 (Run Tests) -> [Step 3a: Fix Tests if needed] -> Step 4 (Implement) -> Step 5 (Validate) -> Step 5a (Quality Check) -> Step 5b (Final Validation)\n\n---\n\n### Step 1: Story Analysis & Validation\n**Details: `workflow.md` -> Step 1**\n\n- Read story, verify existing API structure (read Controllers/Resolvers)\n- Document what exists vs what needs creation\n- Ask for clarification if ambiguous (use AskUserQuestion)\n\n### Step 2: Create Story Test\n**Details: `workflow.md` -> Step 2**\n\n**CRITICAL: Test through API only - NEVER direct Service/DB access!**\n\n- Use `testHelper.rest()` or `testHelper.graphQl()`\n- NEVER call Services directly or query DB in test logic\n- Exception: Direct DB access ONLY for setup/cleanup (roles, verified status)\n\n**Test Data Rules (parallel execution):**\n1. Emails MUST end with `@test.com` (use: `user-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`)\n2. Never reuse data across test files\n3. Only delete entities created in same test file\n4. Implement complete cleanup in `afterAll`\n\n### Step 3: Run Tests & Analyze\n**Details: `workflow.md` -> Step 3**\n\n```bash\nnpm test  # Or: npm test -- tests/stories/your-story.story.test.ts\n```\n\n**Decide:** Test bugs -> Step 3a | Implementation missing -> Step 4\n\n### Step 3a: Fix Test Errors\n**Details: `workflow.md` -> Step 3a**\n\nFix test logic/errors. NEVER \"fix\" by removing security. Return to Step 3 after fixing.\n\n### Step 4: Implement/Extend API Code\n**Details: `workflow.md` -> Step 4**\n\n**Use `generating-nest-servers` skill for:** Module/object creation, understanding existing code\n\n**Critical Rules:**\n1. **Property Descriptions:** Format as `ENGLISH (GERMAN)` when user provides German comments\n2. **ServiceOptions:** Only pass what's needed (usually just `currentUser`), NOT all options\n3. **Guards:** DON'T add `@UseGuards(AuthGuard(...))` - automatically activated by `@Roles()`\n4. **Database indexes:** Define in @UnifiedField decorator (see `database-indexes.md`)\n\n### Step 5: Validate & Iterate\n**Details: `workflow.md` -> Step 5**\n\n```bash\nnpm test\n```\n\nAll pass -> Step 5a | Fail -> Return to Step 3\n\n### Step 5a: Code Quality & Refactoring Check\n**Details: `workflow.md` -> Step 5a**\n\nReview: Code quality (`code-quality.md`), Database indexes (`database-indexes.md`), Security (`security-review.md`). Run tests after changes.\n\n### Step 5b: Final Validation\n**Details: `workflow.md` -> Step 5b**\n\nRun all tests, verify quality checks, generate final report. DONE!\n\n## Handling Existing Tests When Modifying Code\n\n**Complete details: `handling-existing-tests.md`**\n\n**When your changes break existing tests:**\n- Intentional change? -> Update tests + document why\n- Unclear? -> Investigate with git (`git show HEAD`, `git diff`), fix to satisfy both old & new tests\n\n**Remember:** Existing tests document expected behavior - preserve backward compatibility!\n\n---\n\n## CRITICAL: GIT COMMITS\n\n**NEVER create git commits unless explicitly requested by the developer.**\n\nYour responsibility:\n- Create/modify files, run tests, provide comprehensive report\n- **NEVER commit to git without explicit request**\n\nYou may remind in final report: \"Implementation complete - review and commit when ready.\"\n\n---\n\n## CRITICAL SECURITY RULES\n\n**Complete details: `security-review.md`**\n**Extended with OWASP practices: Error Handling & Logging, Cryptographic Practices, Session & Token Management**\n\n### NEVER:\n- Remove/weaken `@Restricted()` or `@Roles()` decorators\n- Modify `securityCheck()` to bypass security\n- Add `@UseGuards(AuthGuard(...))` manually (automatically activated by `@Roles()`)\n\n### ALWAYS:\n- Analyze existing security before writing tests\n- Create appropriate test users with correct roles\n- Test with least-privileged users\n- Ask before changing ANY security decorator\n\n**When tests fail due to security:** Create proper test users with appropriate roles, NEVER remove security decorators.\n\n## Code Quality Standards\n\n**Complete details: `code-quality.md`**\n\n**Must follow:**\n- File organization, naming conventions, import statements from existing code\n- Error handling and validation patterns\n- Use @lenne.tech/nest-server first, add packages as last resort\n\n**Test quality:**\n- 80-100% coverage, self-documenting, independent, repeatable, fast\n\n**NEVER use `declare` keyword** - it prevents decorators from working!\n\n## Autonomous Execution\n\n**Work autonomously:** Create tests, run tests, fix code, iterate Steps 3-5, use nest-server-generator skill\n\n**Only ask when:** Story ambiguous, security changes needed, new packages, architectural decisions, persistent failures\n\n## Final Report\n\nWhen all tests pass, provide comprehensive report including:\n- Story name, tests created (location, count, coverage)\n- Implementation summary (modules/objects/properties created/modified)\n- Test results (all passing, scenarios summary)\n- Code quality (patterns followed, security preserved, dependencies, refactoring, indexes)\n- Security review (auth/authz, validation, data exposure, ownership, injection prevention, errors, security tests)\n- Files modified (with changes description)\n- Next steps (recommendations)\n\n## Common Patterns\n\n**Complete patterns and examples: `examples.md` and `reference.md`**\n\n**Study existing tests first!** Common patterns:\n- Create test users via `/auth/signin`, set roles/verified via DB\n- REST requests: `testHelper.rest('/api/...', { method, payload, token, statusCode })`\n- GraphQL queries: `testHelper.graphQl({ name, type, arguments, fields }, { token })`\n- Test organization: `describe` blocks for Happy Path, Error Cases, Edge Cases\n\n## Integration with generating-nest-servers\n\n**During Step 4 (Implementation), use `generating-nest-servers` skill for:**\n- Module creation (`lt server module`)\n- Object creation (`lt server object`)\n- Adding properties (`lt server addProp`)\n- Understanding existing code (Services, Controllers, Resolvers, Models, DTOs)\n\n**Best Practice:** Invoke skill for NestJS component work rather than manual editing.\n\n## Remember\n\n1. Tests first, code second - write tests before implementation\n2. Iterate until green - all tests must pass\n3. Security review mandatory - check before final tests\n4. Refactor before done - extract common functionality\n5. Security is sacred - never compromise for passing tests\n6. Quality over speed - good tests and clean code\n7. Ask when uncertain - clarify early\n8. Autonomous execution - work independently, report comprehensively\n9. Match existing patterns - equivalent implementation\n10. Clean up test data - comprehensive cleanup in afterAll\n\n**Goal:** Deliver fully tested, high-quality, maintainable, secure features that integrate seamlessly with existing codebase.",
        "plugins/lt-dev/skills/building-stories-with-tdd/code-quality.md": "---\nname: story-tdd-code-quality\ndescription: Code quality and refactoring guidelines for Test-Driven Development\n---\n\n# Code Quality & Refactoring Check\n\n## Table of Contents\n- [1. Check for Code Duplication](#1-check-for-code-duplication)\n- [2. Extract Common Functionality](#2-extract-common-functionality)\n- [3. Consolidate Similar Code Paths](#3-consolidate-similar-code-paths)\n- [4. Review for Consistency](#4-review-for-consistency)\n- [5. Refactoring Decision Tree](#5-refactoring-decision-tree)\n- [6. Run Tests After Refactoring](#6-run-tests-after-refactoring)\n- [7. When to Skip Refactoring](#7-when-to-skip-refactoring)\n- [Quick Code Quality Checklist](#quick-code-quality-checklist)\n\n**BEFORE marking the task as complete, perform a code quality review!**\n\nOnce all tests are passing, analyze your implementation for code quality issues.\n\n---\n\n## 1. Check for Code Duplication\n\n**Identify redundant code patterns:**\n- Repeated logic in multiple methods\n- Similar code blocks with minor variations\n- Duplicated validation logic\n- Repeated data transformations\n- Multiple similar helper functions\n\n**Example of code duplication:**\n\n```typescript\n//  BAD: Duplicated validation logic\nasync createProduct(input: ProductInput) {\n  if (!input.name || input.name.trim().length === 0) {\n    throw new BadRequestException('Name is required');\n  }\n  if (!input.price || input.price <= 0) {\n    throw new BadRequestException('Price must be positive');\n  }\n  // ... create product\n}\n\nasync updateProduct(id: string, input: ProductInput) {\n  if (!input.name || input.name.trim().length === 0) {\n    throw new BadRequestException('Name is required');\n  }\n  if (!input.price || input.price <= 0) {\n    throw new BadRequestException('Price must be positive');\n  }\n  // ... update product\n}\n\n//  GOOD: Extracted to reusable function\nprivate validateProductInput(input: ProductInput) {\n  if (!input.name || input.name.trim().length === 0) {\n    throw new BadRequestException('Name is required');\n  }\n  if (!input.price || input.price <= 0) {\n    throw new BadRequestException('Price must be positive');\n  }\n}\n\nasync createProduct(input: ProductInput) {\n  this.validateProductInput(input);\n  // ... create product\n}\n\nasync updateProduct(id: string, input: ProductInput) {\n  this.validateProductInput(input);\n  // ... update product\n}\n```\n\n---\n\n## 2. Extract Common Functionality\n\n**Look for opportunities to create helper functions:**\n- Data transformation logic\n- Validation logic\n- Query building\n- Response formatting\n- Common calculations\n\n**Example of extracting common functionality:**\n\n```typescript\n//  BAD: Repeated price calculation logic\nasync createOrder(input: OrderInput) {\n  let totalPrice = 0;\n  for (const item of input.items) {\n    const product = await this.productService.findById(item.productId);\n    totalPrice += product.price * item.quantity;\n  }\n  // ... create order\n}\n\nasync estimateOrderPrice(items: OrderItem[]) {\n  let totalPrice = 0;\n  for (const item of items) {\n    const product = await this.productService.findById(item.productId);\n    totalPrice += product.price * item.quantity;\n  }\n  return totalPrice;\n}\n\n//  GOOD: Extracted to reusable helper\nprivate async calculateOrderTotal(items: OrderItem[]): Promise<number> {\n  let totalPrice = 0;\n  for (const item of items) {\n    const product = await this.productService.findById(item.productId);\n    totalPrice += product.price * item.quantity;\n  }\n  return totalPrice;\n}\n\nasync createOrder(input: OrderInput) {\n  const totalPrice = await this.calculateOrderTotal(input.items);\n  // ... create order\n}\n\nasync estimateOrderPrice(items: OrderItem[]) {\n  return this.calculateOrderTotal(items);\n}\n```\n\n---\n\n## 3. Consolidate Similar Code Paths\n\n**Identify code paths that can be unified:**\n- Methods with similar logic but different parameters\n- Conditional branches that can be combined\n- Similar error handling patterns\n\n**Example of consolidating code paths:**\n\n```typescript\n//  BAD: Similar methods with duplicated logic\nasync findProductsByCategory(category: string) {\n  return this.find({\n    where: { category },\n    relations: ['reviews', 'supplier'],\n    order: { createdAt: 'DESC' },\n  });\n}\n\nasync findProductsBySupplier(supplierId: string) {\n  return this.find({\n    where: { supplierId },\n    relations: ['reviews', 'supplier'],\n    order: { createdAt: 'DESC' },\n  });\n}\n\nasync findProductsByPriceRange(minPrice: number, maxPrice: number) {\n  return this.find({\n    where: { price: Between(minPrice, maxPrice) },\n    relations: ['reviews', 'supplier'],\n    order: { createdAt: 'DESC' },\n  });\n}\n\n//  GOOD: Unified method with flexible filtering\nasync findProducts(filters: {\n  category?: string;\n  supplierId?: string;\n  priceRange?: { min: number; max: number };\n}) {\n  const where: any = {};\n\n  if (filters.category) {\n    where.category = filters.category;\n  }\n\n  if (filters.supplierId) {\n    where.supplierId = filters.supplierId;\n  }\n\n  if (filters.priceRange) {\n    where.price = Between(filters.priceRange.min, filters.priceRange.max);\n  }\n\n  return this.find({\n    where,\n    relations: ['reviews', 'supplier'],\n    order: { createdAt: 'DESC' },\n  });\n}\n```\n\n---\n\n## 4. Review for Consistency\n\n**Ensure consistent patterns throughout your implementation:**\n- Naming conventions match existing codebase\n- Error handling follows project patterns\n- Return types are consistent\n- Similar operations use similar approaches\n\n---\n\n## 5. Refactoring Decision Tree\n\n```\nCode duplication detected?\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Used in 2+ places?\n    ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îú‚îÄ‚ñ∫ YES: Extract to private method\n    ‚îÇ   ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚ñ∫ Used across multiple services?\n    ‚îÇ   ‚îÇ       ‚îÇ\n    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚ñ∫ YES: Consider utility class/function\n    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚ñ∫ NO: Keep as private method\n    ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îî‚îÄ‚ñ∫ NO: Leave as-is (don't over-engineer)\n    ‚îÇ\n    ‚îî‚îÄ‚ñ∫ Complex logic block?\n        ‚îÇ\n        ‚îú‚îÄ‚ñ∫ Hard to understand?\n        ‚îÇ   ‚îî‚îÄ‚ñ∫ Extract to well-named method\n        ‚îÇ\n        ‚îî‚îÄ‚ñ∫ Simple and clear?\n            ‚îî‚îÄ‚ñ∫ Leave as-is\n```\n\n---\n\n## 6. Run Tests After Refactoring\n\n**CRITICAL: After any refactoring:**\n\n```bash\nnpm test\n```\n\n**Ensure:**\n-  All tests still pass\n-  No new failures introduced\n-  Code is more maintainable\n-  No functionality changed\n\n---\n\n## 7. When to Skip Refactoring\n\n**Don't refactor if:**\n- Code is used in only ONE place\n- Extraction would make code harder to understand\n- The duplication is coincidental, not conceptual\n- Time constraints don't allow for safe refactoring\n\n**Remember:**\n- **Working code > Perfect code**\n- **Refactor only if it improves maintainability**\n- **Always run tests after refactoring**\n\n---\n\n## Quick Code Quality Checklist\n\nBefore marking complete:\n\n- [ ] **No obvious code duplication**\n- [ ] **Common functionality extracted to helpers**\n- [ ] **Consistent patterns throughout**\n- [ ] **Code follows existing patterns**\n- [ ] **Proper error handling**\n- [ ] **Tests still pass after refactoring**\n",
        "plugins/lt-dev/skills/building-stories-with-tdd/database-indexes.md": "---\nname: story-tdd-database-indexes\ndescription: Database index guidelines for @UnifiedField decorator - keep indexes visible with properties\n---\n\n#  Database Indexes with @UnifiedField\n\n## Table of Contents\n- [When to Add Indexes](#when-to-add-indexes)\n- [Example Patterns](#example-patterns)\n- [DON'T Create Indexes Separately!](#-dont-create-indexes-separately)\n- [Benefits of Decorator-Based Indexes](#benefits-of-decorator-based-indexes)\n- [Index Verification Checklist](#index-verification-checklist)\n- [Red Flags - Missing Indexes](#red-flags---missing-indexes)\n- [Quick Index Checklist](#quick-index-checklist)\n\n**IMPORTANT: Always define indexes directly in the @UnifiedField decorator!**\n\nThis keeps indexes visible right where properties are defined, making them easy to spot during code reviews.\n\n---\n\n## When to Add Indexes\n\n-  Fields used in queries (find, filter, search)\n-  Foreign keys (references to other collections)\n-  Fields used in sorting operations\n-  Unique constraints (email, username, etc.)\n-  Fields frequently accessed together (compound indexes)\n\n---\n\n## Example Patterns\n\n### Single Field Index\n\n```typescript\n@UnifiedField({\n  description: 'User email address',\n  mongoose: { index: true, unique: true, type: String }  //  Simple index + unique constraint\n})\nemail: string;\n```\n\n### Compound Index\n\n```typescript\n@UnifiedField({\n  description: 'Product category',\n  mongoose: { index: true, type: String }  //  Part of compound index\n})\ncategory: string;\n\n@UnifiedField({\n  description: 'Product status',\n  mongoose: { index: true, type: String }  //  Part of compound index\n})\nstatus: string;\n\n// Both fields indexed individually for flexible querying\n```\n\n### Text Index for Search\n\n```typescript\n@UnifiedField({\n  description: 'Product name',\n  mongoose: { type: String, text: true }  //  Full-text search index\n})\nname: string;\n```\n\n### Foreign Key Index\n\n```typescript\n@UnifiedField({\n  description: 'Reference to user who created this',\n  mongoose: { index: true, type: String }  //  Index for JOIN operations\n})\ncreatedBy: string;\n```\n\n---\n\n##  DON'T Create Indexes Separately!\n\n```typescript\n//  WRONG: Separate schema index definition\n@Schema()\nexport class Product {\n  @UnifiedField({\n    description: 'Category',\n    mongoose: { type: String }\n  })\n  category: string;\n}\n\nProductSchema.index({ category: 1 }); //  Index hidden away from property\n\n//  CORRECT: Index in decorator mongoose option\n@Schema()\nexport class Product {\n  @UnifiedField({\n    description: 'Category',\n    mongoose: { index: true, type: String }  //  Immediately visible\n  })\n  category: string;\n}\n```\n\n---\n\n## Benefits of Decorator-Based Indexes\n\n-  Indexes visible when reviewing properties\n-  No need to search schema files\n-  Clear documentation of query patterns\n-  Easier to maintain and update\n-  Self-documenting code\n\n---\n\n## Index Verification Checklist\n\n**Look for fields that should have indexes:**\n- Fields used in find/filter operations\n- Foreign keys (userId, productId, etc.)\n- Fields used in sorting (createdAt, updatedAt, name)\n- Unique fields (email, username, slug)\n\n**Example check:**\n\n```typescript\n// Service has this query:\nconst orders = await this.orderService.find({\n  where: { customerId: userId, status: 'pending' }\n});\n\n//  Model should have indexes:\nexport class Order {\n  @UnifiedField({\n    description: 'Customer reference',\n    mongoose: { index: true, type: String }  //  Used in queries\n  })\n  customerId: string;\n\n  @UnifiedField({\n    description: 'Order status',\n    mongoose: { index: true, type: String }  //  Used in filtering\n  })\n  status: string;\n}\n```\n\n---\n\n## Red Flags - Missing Indexes\n\nüö© **Check for these issues:**\n- Service queries a field but model has no index\n- Foreign key fields without index\n- Unique constraints not marked in decorator\n- Fields used in sorting without index\n\n**If indexes are missing:**\n1. Add them to the @UnifiedField decorator immediately\n2. Re-run tests to ensure everything still works\n3. Document why the index is needed (query pattern)\n\n---\n\n## Quick Index Checklist\n\nBefore marking complete:\n\n- [ ] **Fields used in find() queries have indexes**\n- [ ] **Foreign keys (userId, productId, etc.) have indexes**\n- [ ] **Unique fields (email, username) marked with unique: true**\n- [ ] **Fields used in sorting have indexes**\n- [ ] **All indexes in @UnifiedField decorator (NOT separate schema)**\n- [ ] **Indexes match query patterns in services**\n",
        "plugins/lt-dev/skills/building-stories-with-tdd/examples.md": "---\nname: story-tdd-examples\ndescription: Complete examples for Test-Driven Development workflow with NestJS story tests\n---\n\n# Story-Based TDD Examples\n\n## Table of Contents\n- [Example 1: Simple CRUD Feature - Product Reviews](#example-1-simple-crud-feature---product-reviews)\n- [Example 2: Complex Business Logic - Order Processing](#example-2-complex-business-logic---order-processing)\n- [Example 3: GraphQL Mutation - User Profile Update](#example-3-graphql-mutation---user-profile-update)\n- [Debugging Test Failures](#debugging-test-failures)\n- [Key Takeaways from Examples](#key-takeaways-from-examples)\n\nThis document provides complete examples of the TDD workflow for different types of user stories.\n\n## Example 1: Simple CRUD Feature - Product Reviews\n\n### Story Requirement\n\n```\nAs a user, I want to add reviews to products so that I can share my experience with other customers.\n\nAcceptance Criteria:\n- Users can create a review with rating (1-5) and comment\n- Rating is required, comment is optional\n- Only authenticated users can create reviews\n- Users can view all reviews for a product\n- Each review shows author name and creation date\n```\n\n### Step 1: Story Analysis\n\n**Analysis notes:**\n- New feature, likely needs new Review module\n- Needs relationship between Review and Product\n- Security: Only authenticated users (S_USER role minimum)\n- No mention of update/delete, so only CREATE and READ operations\n\n**Questions to clarify:**\n- Can users edit their reviews? (Assuming NO for this example)\n- Can users review a product multiple times? (Assuming NO)\n- What validation for rating? (Assuming 1-5 integer)\n\n** Verification of existing API (CRITICAL - Do this BEFORE writing tests!):**\n\n1. **Check Product endpoints:**\n   ```\n    Read src/server/modules/product/product.controller.ts\n    Verified: GET /api/products exists (line 23)\n    Verified: POST /api/products exists (line 45)\n    Verified: Returns Product with id, name, price\n   ```\n\n2. **Check Review endpoints:**\n   ```\n    Review module does NOT exist yet\n    POST /api/reviews needs to be implemented\n    GET /api/products/:id/reviews needs to be implemented\n   ```\n\n3. **Plan implementation:**\n   - Need to create Review module (service, controller, model)\n   - Need to add POST /api/reviews endpoint\n   - Need to add GET /api/products/:id/reviews endpoint\n\n### Step 2: Create Story Test\n\n**File:** `tests/stories/product-review.story.test.ts`\n\n```typescript\nimport {\n  ConfigService,\n  getObjectIds,\n  HttpExceptionLogFilter,\n  TestGraphQLType,\n  TestHelper,\n} from '@lenne.tech/nest-server';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { PubSub } from 'graphql-subscriptions';\nimport { MongoClient, ObjectId } from 'mongodb';\n\nimport envConfig from '../../src/config.env';\nimport { RoleEnum } from '../../src/server/common/enums/role.enum';\nimport { imports, ServerModule } from '../../src/server/server.module';\n\n//  NOTE: No Service imports! Tests must use API endpoints only.\n// Services are only accessed indirectly through Controllers/Resolvers.\n\ndescribe('Product Review Story', () => {\n  // Test environment properties\n  let app;\n  let testHelper: TestHelper;\n\n  // Database\n  let connection;\n  let db;\n\n  // Global test data\n  let gAdminToken: string;\n  let gAdminId: string;\n  let gUserToken: string;\n  let gUserId: string;\n  let gProductId: string;\n\n  // Track created entities for cleanup\n  let createdReviewIds: string[] = [];\n\n  beforeAll(async () => {\n    // Start server for testing\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [...imports, ServerModule],\n      providers: [\n        {\n          provide: 'PUB_SUB',\n          useValue: new PubSub(),\n        },\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.useGlobalFilters(new HttpExceptionLogFilter());\n    app.setBaseViewsDir(envConfig.templates.path);\n    app.setViewEngine(envConfig.templates.engine);\n    await app.init();\n\n    testHelper = new TestHelper(app);\n\n    // Connection to database\n    connection = await MongoClient.connect(envConfig.mongoose.uri);\n    db = await connection.db();\n\n    // Create admin user via API\n    const adminPassword = Math.random().toString(36).substring(7);\n    const adminEmail = `admin-${adminPassword}@test.com`;\n    const adminSignUp = await testHelper.graphQl({\n      arguments: {\n        input: {\n          email: adminEmail,\n          firstName: 'Admin',\n          password: adminPassword,\n        },\n      },\n      fields: ['token', { user: ['id', 'email', 'roles'] }],\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n    });\n    gAdminId = adminSignUp.user.id;\n    gAdminToken = adminSignUp.token;\n\n    //  ALLOWED EXCEPTION: Set admin role via direct DB access (no API endpoint for this)\n    await db.collection('users').updateOne(\n      { _id: new ObjectId(gAdminId) },\n      { $set: { roles: [RoleEnum.ADMIN] } }\n    );\n\n    // Create normal user\n    const userPassword = Math.random().toString(36).substring(7);\n    const userEmail = `user-${userPassword}@test.com`;\n    const userSignUp = await testHelper.graphQl({\n      arguments: {\n        input: {\n          email: userEmail,\n          firstName: 'Test',\n          password: userPassword,\n        },\n      },\n      fields: ['token', { user: ['id', 'email'] }],\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n    });\n    gUserId = userSignUp.user.id;\n    gUserToken = userSignUp.token;\n\n    // Create test product\n    const product = await testHelper.rest('/api/products', {\n      method: 'POST',\n      payload: {\n        name: 'Test Product',\n        price: 99.99,\n      },\n      token: gAdminToken,\n    });\n    gProductId = product.id;\n  });\n\n  afterAll(async () => {\n    // üßπ CLEANUP: Delete all test data created during tests\n    try {\n      // Delete all created reviews (using getObjectIds for array conversion)\n      if (createdReviewIds.length > 0) {\n        await db.collection('reviews').deleteMany({\n          _id: { $in: getObjectIds(createdReviewIds) }\n        });\n      }\n\n      // Delete test product (using getObjectIds for single value - no array needed!)\n      if (gProductId) {\n        await db.collection('products').deleteOne({ _id: getObjectIds(gProductId) });\n      }\n\n      // Delete test users (using getObjectIds for single values)\n      if (gUserId) {\n        await db.collection('users').deleteOne({ _id: getObjectIds(gUserId) });\n      }\n      if (gAdminId) {\n        await db.collection('users').deleteOne({ _id: getObjectIds(gAdminId) });\n      }\n    } catch (error) {\n      console.error('Cleanup failed:', error);\n    }\n\n    await connection.close();\n    await app.close();\n  });\n\n  describe('Creating Reviews', () => {\n    it('should allow authenticated user to create review with rating and comment', async () => {\n      const review = await testHelper.rest('/api/reviews', {\n        method: 'POST',\n        payload: {\n          productId: gProductId,\n          rating: 5,\n          comment: 'Excellent product!',\n        },\n        token: gUserToken,\n      });\n\n      expect(review).toMatchObject({\n        rating: 5,\n        comment: 'Excellent product!',\n        authorId: gUserId,\n      });\n      expect(review.id).toBeDefined();\n      expect(review.createdAt).toBeDefined();\n\n      // Track for cleanup\n      createdReviewIds.push(review.id);\n    });\n\n    it('should allow review with rating only (no comment)', async () => {\n      const review = await testHelper.rest('/api/reviews', {\n        method: 'POST',\n        payload: {\n          productId: gProductId,\n          rating: 4,\n        },\n        token: gUserToken,\n      });\n\n      expect(review.rating).toBe(4);\n      expect(review.comment).toBeUndefined();\n\n      // Track for cleanup\n      createdReviewIds.push(review.id);\n    });\n\n    it('should reject review without rating', async () => {\n      await testHelper.rest('/api/reviews', {\n        method: 'POST',\n        payload: {\n          productId: gProductId,\n          comment: 'Missing rating',\n        },\n        statusCode: 400,\n        token: gUserToken,\n      });\n    });\n\n    it('should reject review with invalid rating', async () => {\n      await testHelper.rest('/api/reviews', {\n        method: 'POST',\n        payload: {\n          productId: gProductId,\n          rating: 6, // Invalid: must be 1-5\n        },\n        statusCode: 400,\n        token: gUserToken,\n      });\n    });\n\n    it('should reject unauthenticated review creation', async () => {\n      await testHelper.rest('/api/reviews', {\n        method: 'POST',\n        payload: {\n          productId: gProductId,\n          rating: 5,\n          comment: 'Trying without auth',\n        },\n        statusCode: 401,\n      });\n    });\n  });\n\n  describe('Viewing Reviews', () => {\n    let createdReviewId: string;\n\n    beforeAll(async () => {\n      // Create a review for testing\n      const review = await testHelper.rest('/api/reviews', {\n        method: 'POST',\n        payload: {\n          productId: gProductId,\n          rating: 5,\n          comment: 'Great product',\n        },\n        token: gUserToken,\n      });\n      createdReviewId = review.id;\n\n      // Track for cleanup\n      createdReviewIds.push(review.id);\n    });\n\n    it('should allow anyone to view product reviews', async () => {\n      const reviews = await testHelper.rest(`/api/products/${gProductId}/reviews`);\n\n      expect(reviews).toBeInstanceOf(Array);\n      expect(reviews.length).toBeGreaterThan(0);\n\n      const review = reviews.find(r => r.id === createdReviewId);\n      expect(review).toMatchObject({\n        rating: 5,\n        comment: 'Great product',\n      });\n      expect(review.author).toBeDefined();\n      expect(review.createdAt).toBeDefined();\n    });\n\n    it('should return empty array for product with no reviews', async () => {\n      // Create product without reviews\n      const newProduct = await testHelper.rest('/api/products', {\n        method: 'POST',\n        payload: {\n          name: 'New Product',\n          price: 49.99,\n        },\n        token: gAdminToken,\n      });\n\n      const reviews = await testHelper.rest(`/api/products/${newProduct.id}/reviews`);\n      expect(reviews).toEqual([]);\n    });\n  });\n});\n```\n\n### Step 3-5: Implementation Iteration\n\n**First run - Expected failures:**\n```\n POST /api/reviews -> 404 (endpoint doesn't exist)\n GET /api/products/:id/reviews -> 404 (endpoint doesn't exist)\n```\n\n**Implementation (using nest-server-generator):**\n```bash\n# Create Review module\nlt server module Review --no-interactive\n\n# Add properties\nlt server addProp Review productId:string --no-interactive\nlt server addProp Review authorId:string --no-interactive\nlt server addProp Review rating:number --no-interactive\nlt server addProp Review comment:string? --no-interactive\n```\n\n**Manual adjustments needed:**\n- Add validation for rating (1-5 range)\n- Add @Restricted decorator with appropriate roles\n- Add GET endpoint to ProductController for reviews\n- Add relationship between Product and Review\n\n**Final run - All tests pass:**\n```\n All tests passing (8 scenarios)\n```\n\n---\n\n## Example 2: Complex Business Logic - Order Processing\n\n### Story Requirement\n\n```\nAs a customer, I want to place an order with multiple products so that I can purchase items together.\n\nAcceptance Criteria:\n- Order contains multiple products with quantities\n- Order calculates total price automatically\n- Order cannot be created with empty product list\n- Order requires delivery address\n- Order status is initially \"pending\"\n- Products are checked for availability\n- Insufficient stock prevents order creation\n```\n\n### Step 1: Story Analysis\n\n**Analysis notes:**\n- Needs Order module with relationship to Product\n- Needs OrderItem subobject for quantity tracking\n- Business logic: stock validation\n- Calculated field: total price\n- Complex validation rules\n\n**Architecture decisions:**\n- Use SubObject for OrderItem (embedded in Order)\n- Total price should be calculated in service layer\n- Stock check happens in service before saving\n\n### Step 2: Create Story Test\n\n**File:** `tests/stories/order-processing.story.test.ts`\n\n```typescript\nimport {\n  ConfigService,\n  getObjectIds,\n  HttpExceptionLogFilter,\n  TestGraphQLType,\n  TestHelper,\n} from '@lenne.tech/nest-server';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { PubSub } from 'graphql-subscriptions';\nimport { MongoClient, ObjectId } from 'mongodb';\n\nimport envConfig from '../../src/config.env';\nimport { RoleEnum } from '../../src/server/common/enums/role.enum';\nimport { imports, ServerModule } from '../../src/server/server.module';\n\n//  NOTE: No Service imports! Tests must use API endpoints only.\n// Services are only accessed indirectly through Controllers/Resolvers.\n\ndescribe('Order Processing Story', () => {\n  // Test environment properties\n  let app;\n  let testHelper: TestHelper;\n\n  // Database\n  let connection;\n  let db;\n\n  // Global test data\n  let gAdminToken: string;\n  let gAdminId: string;\n  let gCustomerToken: string;\n  let gCustomerId: string;\n  let gProduct1Id: string;\n  let gProduct1Stock: number;\n  let gProduct2Id: string;\n\n  // Track created entities for cleanup\n  let createdOrderIds: string[] = [];\n  let createdProductIds: string[] = [];\n\n  beforeAll(async () => {\n    // Start server for testing\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [...imports, ServerModule],\n      providers: [\n        {\n          provide: 'PUB_SUB',\n          useValue: new PubSub(),\n        },\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.useGlobalFilters(new HttpExceptionLogFilter());\n    app.setBaseViewsDir(envConfig.templates.path);\n    app.setViewEngine(envConfig.templates.engine);\n    await app.init();\n\n    testHelper = new TestHelper(app);\n\n    // Connection to database\n    connection = await MongoClient.connect(envConfig.mongoose.uri);\n    db = await connection.db();\n\n    // Create admin user via API\n    const adminPassword = Math.random().toString(36).substring(7);\n    const adminEmail = `admin-${adminPassword}@test.com`;\n    const adminSignUp = await testHelper.graphQl({\n      arguments: {\n        input: {\n          email: adminEmail,\n          firstName: 'Admin',\n          password: adminPassword,\n        },\n      },\n      fields: ['token', { user: ['id', 'email'] }],\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n    });\n    gAdminId = adminSignUp.user.id;\n    gAdminToken = adminSignUp.token;\n\n    //  ALLOWED EXCEPTION: Set admin role via direct DB access (no API endpoint for this)\n    await db.collection('users').updateOne(\n      { _id: new ObjectId(gAdminId) },\n      { $set: { roles: [RoleEnum.ADMIN] } }\n    );\n\n    // Create customer user\n    const customerPassword = Math.random().toString(36).substring(7);\n    const customerEmail = `customer-${customerPassword}@test.com`;\n    const customerSignUp = await testHelper.graphQl({\n      arguments: {\n        input: {\n          email: customerEmail,\n          firstName: 'Customer',\n          password: customerPassword,\n        },\n      },\n      fields: ['token', { user: ['id'] }],\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n    });\n    gCustomerId = customerSignUp.user.id;\n    gCustomerToken = customerSignUp.token;\n\n    // Create test products with stock\n    const product1 = await testHelper.rest('/api/products', {\n      method: 'POST',\n      payload: {\n        name: 'Product A',\n        price: 10.00,\n        stock: 100,\n      },\n      token: gAdminToken,\n    });\n    gProduct1Id = product1.id;\n    gProduct1Stock = product1.stock;\n\n    const product2 = await testHelper.rest('/api/products', {\n      method: 'POST',\n      payload: {\n        name: 'Product B',\n        price: 25.50,\n        stock: 50,\n      },\n      token: gAdminToken,\n    });\n    gProduct2Id = product2.id;\n\n    // Track products for cleanup\n    createdProductIds.push(gProduct1Id, gProduct2Id);\n  });\n\n  afterAll(async () => {\n    // üßπ CLEANUP: Delete all test data created during tests\n    try {\n      // Delete all created orders first (child entities) - using getObjectIds for arrays\n      if (createdOrderIds.length > 0) {\n        await db.collection('orders').deleteMany({\n          _id: { $in: getObjectIds(createdOrderIds) }\n        });\n      }\n\n      // Delete all created products - using getObjectIds for arrays\n      if (createdProductIds.length > 0) {\n        await db.collection('products').deleteMany({\n          _id: { $in: getObjectIds(createdProductIds) }\n        });\n      }\n\n      // Delete test users - using getObjectIds for single values (no array needed!)\n      if (gCustomerId) {\n        await db.collection('users').deleteOne({ _id: getObjectIds(gCustomerId) });\n      }\n      if (gAdminId) {\n        await db.collection('users').deleteOne({ _id: getObjectIds(gAdminId) });\n      }\n    } catch (error) {\n      console.error('Cleanup failed:', error);\n    }\n\n    await connection.close();\n    await app.close();\n  });\n\n  describe('Order Creation - Happy Path', () => {\n    it('should create order with multiple products and calculate total', async () => {\n      const orderData = {\n        items: [\n          { productId: gProduct1Id, quantity: 2 },\n          { productId: gProduct2Id, quantity: 1 },\n        ],\n        deliveryAddress: {\n          street: '123 Main St',\n          city: 'Test City',\n          zipCode: '12345',\n          country: 'Germany',\n        },\n      };\n\n      const order = await testHelper.rest('/api/orders', {\n        method: 'POST',\n        payload: orderData,\n        token: gCustomerToken,\n      });\n\n      expect(order).toMatchObject({\n        status: 'pending',\n        customerId: gCustomerId,\n        totalPrice: 45.50, // (10.00 * 2) + (25.50 * 1)\n        deliveryAddress: orderData.deliveryAddress,\n      });\n\n      expect(order.items).toHaveLength(2);\n      expect(order.items[0]).toMatchObject({\n        productId: gProduct1Id,\n        quantity: 2,\n        priceAtOrder: 10.00,\n      });\n\n      // Track for cleanup\n      createdOrderIds.push(order.id);\n    });\n\n    it('should create order with single product', async () => {\n      const orderData = {\n        items: [\n          { productId: gProduct1Id, quantity: 1 },\n        ],\n        deliveryAddress: {\n          street: '456 Oak Ave',\n          city: 'Sample Town',\n          zipCode: '54321',\n          country: 'Germany',\n        },\n      };\n\n      const order = await testHelper.rest('/api/orders', {\n        method: 'POST',\n        payload: orderData,\n        token: gCustomerToken,\n      });\n\n      expect(order.totalPrice).toBe(10.00);\n\n      // Track for cleanup\n      createdOrderIds.push(order.id);\n    });\n  });\n\n  describe('Order Validation', () => {\n    it('should reject order with empty product list', async () => {\n      const orderData = {\n        items: [],\n        deliveryAddress: {\n          street: '123 Main St',\n          city: 'Test City',\n          zipCode: '12345',\n          country: 'Germany',\n        },\n      };\n\n      await testHelper.rest('/api/orders', {\n        method: 'POST',\n        payload: orderData,\n        statusCode: 400,\n        token: gCustomerToken,\n      });\n    });\n\n    it('should reject order without delivery address', async () => {\n      const orderData = {\n        items: [\n          { productId: gProduct1Id, quantity: 1 },\n        ],\n      };\n\n      await testHelper.rest('/api/orders', {\n        method: 'POST',\n        payload: orderData,\n        statusCode: 400,\n        token: gCustomerToken,\n      });\n    });\n\n    it('should reject order with invalid product ID', async () => {\n      const orderData = {\n        items: [\n          { productId: 'invalid-id', quantity: 1 },\n        ],\n        deliveryAddress: {\n          street: '123 Main St',\n          city: 'Test City',\n          zipCode: '12345',\n          country: 'Germany',\n        },\n      };\n\n      await testHelper.rest('/api/orders', {\n        method: 'POST',\n        payload: orderData,\n        statusCode: 404,\n        token: gCustomerToken,\n      });\n    });\n  });\n\n  describe('Stock Management', () => {\n    it('should reject order when product stock is insufficient', async () => {\n      // Create product with limited stock\n      const limitedProduct = await testHelper.rest('/api/products', {\n        method: 'POST',\n        payload: {\n          name: 'Limited Product',\n          price: 100.00,\n          stock: 5,\n        },\n        token: gAdminToken,\n      });\n\n      // Track for cleanup\n      createdProductIds.push(limitedProduct.id);\n\n      const orderData = {\n        items: [\n          { productId: limitedProduct.id, quantity: 10 }, // More than available\n        ],\n        deliveryAddress: {\n          street: '123 Main St',\n          city: 'Test City',\n          zipCode: '12345',\n          country: 'Germany',\n        },\n      };\n\n      const response = await testHelper.rest('/api/orders', {\n        method: 'POST',\n        payload: orderData,\n        statusCode: 400,\n        token: gCustomerToken,\n      });\n\n      expect(response.message).toContain('insufficient stock');\n    });\n\n    it('should reduce product stock after successful order', async () => {\n      const initialStock = gProduct1Stock;\n\n      const orderData = {\n        items: [\n          { productId: gProduct1Id, quantity: 3 },\n        ],\n        deliveryAddress: {\n          street: '123 Main St',\n          city: 'Test City',\n          zipCode: '12345',\n          country: 'Germany',\n        },\n      };\n\n      const order = await testHelper.rest('/api/orders', {\n        method: 'POST',\n        payload: orderData,\n        token: gCustomerToken,\n      });\n\n      // Track for cleanup\n      createdOrderIds.push(order.id);\n\n      // Check product stock was reduced\n      const updatedProduct = await testHelper.rest(`/api/products/${gProduct1Id}`, {\n        token: gAdminToken,\n      });\n\n      expect(updatedProduct.stock).toBe(initialStock - 3);\n\n      // Update global stock for subsequent tests\n      gProduct1Stock = updatedProduct.stock;\n    });\n  });\n\n  describe('Authorization', () => {\n    it('should reject unauthenticated order creation', async () => {\n      const orderData = {\n        items: [\n          { productId: gProduct1Id, quantity: 1 },\n        ],\n        deliveryAddress: {\n          street: '123 Main St',\n          city: 'Test City',\n          zipCode: '12345',\n          country: 'Germany',\n        },\n      };\n\n      await testHelper.rest('/api/orders', {\n        method: 'POST',\n        payload: orderData,\n        statusCode: 401,\n      });\n    });\n  });\n});\n```\n\n### Implementation Steps\n\n**SubObject creation:**\n```typescript\n// Create OrderItem SubObject manually\n// File: src/server/modules/order/order-item.subobject.ts\n\n@SubObjectType()\nexport class OrderItem {\n  @UnifiedField({\n    description: 'Reference to product',\n    mongoose: { index: true, type: String }  //  Index for queries by product\n  })\n  productId: string;\n\n  @UnifiedField({\n    description: 'Quantity ordered',\n    mongoose: { type: Number }\n  })\n  quantity: number;\n\n  @UnifiedField({\n    description: 'Price when order was placed',\n    mongoose: { type: Number }\n  })\n  priceAtOrder: number;\n}\n```\n\n**Model with indexes:**\n```typescript\n// File: src/server/modules/order/order.model.ts\n\n@Schema()\nexport class Order {\n  @UnifiedField({\n    description: 'Customer who placed the order',\n    mongoose: { index: true, type: String }  //  Frequent queries by customer\n  })\n  customerId: string;\n\n  @UnifiedField({\n    description: 'Order status',\n    mongoose: { index: true, type: String }  //  Filtering by status\n  })\n  status: string;\n\n  @UnifiedField({\n    description: 'Order items',\n    mongoose: { type: [OrderItem] }\n  })\n  items: OrderItem[];\n\n  @UnifiedField({\n    description: 'Total price calculated from items',\n    mongoose: { type: Number }\n  })\n  totalPrice: number;\n\n  @UnifiedField({\n    description: 'Delivery address',\n    mongoose: { type: Object }\n  })\n  deliveryAddress: Address;\n}\n```\n\n**Why these indexes?**\n- `customerId`: Service queries orders by customer -> needs index\n- `status`: Service filters by status (pending, completed) -> needs index\n- Both indexed individually for flexible querying\n\n**Service logic for total calculation and stock validation:**\n```typescript\n// In OrderService (extends CrudService)\n\nasync create(input: CreateOrderInput, userId: string): Promise<Order> {\n  // Validate items exist\n  if (!input.items || input.items.length === 0) {\n    throw new BadRequestException('Order must contain at least one item');\n  }\n\n  // Check stock and calculate total\n  let totalPrice = 0;\n  const orderItems = [];\n\n  for (const item of input.items) {\n    const product = await this.productService.findById(item.productId);\n    if (!product) {\n      throw new NotFoundException(`Product ${item.productId} not found`);\n    }\n\n    if (product.stock < item.quantity) {\n      throw new BadRequestException(\n        `Insufficient stock for product ${product.name}`\n      );\n    }\n\n    orderItems.push({\n      productId: product.id,\n      quantity: item.quantity,\n      priceAtOrder: product.price,\n    });\n\n    totalPrice += product.price * item.quantity;\n  }\n\n  // Create order\n  const order = await super.create({\n    ...input,\n    items: orderItems,\n    totalPrice,\n    customerId: userId,\n    status: 'pending',\n  });\n\n  // Reduce stock\n  for (const item of input.items) {\n    await this.productService.reduceStock(item.productId, item.quantity);\n  }\n\n  return order;\n}\n```\n\n---\n\n## Example 3: GraphQL Mutation - User Profile Update\n\n### Story Requirement\n\n```\nAs a user, I want to update my profile information so that my account reflects current details.\n\nAcceptance Criteria:\n- Users can update their firstName, lastName, phone\n- Users cannot change their email through this endpoint\n- Users can only update their own profile\n- Admin users can update any profile\n- Phone number must be validated (German format)\n```\n\n### Step 2: Create Story Test (GraphQL)\n\n**File:** `tests/stories/profile-update.story.test.ts`\n\n```typescript\nimport {\n  ConfigService,\n  getObjectIds,\n  HttpExceptionLogFilter,\n  TestGraphQLType,\n  TestHelper,\n} from '@lenne.tech/nest-server';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { PubSub } from 'graphql-subscriptions';\nimport { MongoClient, ObjectId } from 'mongodb';\n\nimport envConfig from '../../src/config.env';\nimport { RoleEnum } from '../../src/server/common/enums/role.enum';\nimport { imports, ServerModule } from '../../src/server/server.module';\n\n//  NOTE: No Service imports! Tests must use API endpoints only.\n// Services are only accessed indirectly through Controllers/Resolvers.\n\ndescribe('Profile Update Story (GraphQL)', () => {\n  // Test environment properties\n  let app;\n  let testHelper: TestHelper;\n\n  // Database\n  let connection;\n  let db;\n\n  // Global test data\n  let gNormalUserId: string;\n  let gNormalUserToken: string;\n  let gNormalUserEmail: string;\n  let gOtherUserId: string;\n  let gOtherUserToken: string;\n  let gAdminUserId: string;\n  let gAdminUserToken: string;\n\n  // Track created entities for cleanup\n  let createdUserIds: string[] = [];\n\n  beforeAll(async () => {\n    // Start server for testing\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [...imports, ServerModule],\n      providers: [\n        {\n          provide: 'PUB_SUB',\n          useValue: new PubSub(),\n        },\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.useGlobalFilters(new HttpExceptionLogFilter());\n    app.setBaseViewsDir(envConfig.templates.path);\n    app.setViewEngine(envConfig.templates.engine);\n    await app.init();\n\n    testHelper = new TestHelper(app);\n\n    // Connection to database\n    connection = await MongoClient.connect(envConfig.mongoose.uri);\n    db = await connection.db();\n\n    // Create normal user\n    const normalPassword = Math.random().toString(36).substring(7);\n    gNormalUserEmail = `user-${normalPassword}@test.com`;\n    const normalSignUp = await testHelper.graphQl({\n      arguments: {\n        input: {\n          email: gNormalUserEmail,\n          firstName: 'John',\n          lastName: 'Doe',\n          password: normalPassword,\n        },\n      },\n      fields: ['token', { user: ['id', 'email'] }],\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n    });\n    gNormalUserId = normalSignUp.user.id;\n    gNormalUserToken = normalSignUp.token;\n\n    // Track for cleanup\n    createdUserIds.push(gNormalUserId);\n\n    // Create other user\n    const otherPassword = Math.random().toString(36).substring(7);\n    const otherEmail = `other-${otherPassword}@test.com`;\n    const otherSignUp = await testHelper.graphQl({\n      arguments: {\n        input: {\n          email: otherEmail,\n          firstName: 'Other',\n          password: otherPassword,\n        },\n      },\n      fields: ['token', { user: ['id'] }],\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n    });\n    gOtherUserId = otherSignUp.user.id;\n    gOtherUserToken = otherSignUp.token;\n\n    // Track for cleanup\n    createdUserIds.push(gOtherUserId);\n\n    // Create admin user\n    const adminPassword = Math.random().toString(36).substring(7);\n    const adminEmail = `admin-${adminPassword}@test.com`;\n    const adminSignUp = await testHelper.graphQl({\n      arguments: {\n        input: {\n          email: adminEmail,\n          firstName: 'Admin',\n          password: adminPassword,\n        },\n      },\n      fields: ['token', { user: ['id'] }],\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n    });\n    gAdminUserId = adminSignUp.user.id;\n    gAdminUserToken = adminSignUp.token;\n\n    // Track for cleanup\n    createdUserIds.push(gAdminUserId);\n\n    //  ALLOWED EXCEPTION: Set admin role via direct DB access (no API endpoint for this)\n    await db.collection('users').updateOne(\n      { _id: new ObjectId(gAdminUserId) },\n      { $set: { roles: [RoleEnum.ADMIN] } }\n    );\n  });\n\n  afterAll(async () => {\n    // üßπ CLEANUP: Delete all test data created during tests\n    try {\n      // Delete all created users - using getObjectIds\n      if (createdUserIds.length > 0) {\n        await db.collection('users').deleteMany({\n          _id: { $in: getObjectIds(createdUserIds) }\n        });\n      }\n    } catch (error) {\n      console.error('Cleanup failed:', error);\n    }\n\n    await connection.close();\n    await app.close();\n  });\n\n  describe('Own Profile Update', () => {\n    it('should allow user to update own profile', async () => {\n      const result = await testHelper.graphQl({\n        arguments: {\n          id: gNormalUserId,\n          input: {\n            firstName: 'Jane',\n            lastName: 'Smith',\n            phone: '+49 123 456789',\n          },\n        },\n        fields: ['id', 'firstName', 'lastName', 'phone', 'email'],\n        name: 'updateUser',\n        type: TestGraphQLType.MUTATION,\n      }, { token: gNormalUserToken });\n\n      expect(result).toMatchObject({\n        id: gNormalUserId,\n        firstName: 'Jane',\n        lastName: 'Smith',\n        phone: '+49 123 456789',\n        email: gNormalUserEmail, // Email unchanged\n      });\n    });\n\n    it('should prevent user from changing email', async () => {\n      const result = await testHelper.graphQl({\n        arguments: {\n          id: gNormalUserId,\n          input: {\n            firstName: 'John',\n            email: 'newemail@test.com', // Attempt to change email\n          },\n        },\n        fields: ['email'],\n        name: 'updateUser',\n        type: TestGraphQLType.MUTATION,\n      }, { token: gNormalUserToken });\n\n      // Email should remain unchanged\n      expect(result.email).toBe(gNormalUserEmail);\n    });\n  });\n\n  describe('Authorization', () => {\n    it('should prevent user from updating other user profile', async () => {\n      const result = await testHelper.graphQl({\n        arguments: {\n          id: gOtherUserId,\n          input: {\n            firstName: 'Hacker',\n          },\n        },\n        fields: ['id', 'firstName'],\n        name: 'updateUser',\n        type: TestGraphQLType.MUTATION,\n      }, { token: gNormalUserToken, statusCode: 200 });\n\n      expect(result.errors).toBeDefined();\n      expect(result.errors[0].message).toContain('Forbidden');\n    });\n\n    it('should allow admin to update any profile', async () => {\n      const result = await testHelper.graphQl({\n        arguments: {\n          id: gNormalUserId,\n          input: {\n            firstName: 'AdminUpdated',\n          },\n        },\n        fields: ['firstName'],\n        name: 'updateUser',\n        type: TestGraphQLType.MUTATION,\n      }, { token: gAdminUserToken });\n\n      expect(result.firstName).toBe('AdminUpdated');\n    });\n  });\n\n  describe('Validation', () => {\n    it('should reject invalid phone number format', async () => {\n      const result = await testHelper.graphQl({\n        arguments: {\n          id: gNormalUserId,\n          input: {\n            phone: '123', // Invalid format\n          },\n        },\n        fields: ['phone'],\n        name: 'updateUser',\n        type: TestGraphQLType.MUTATION,\n      }, { token: gNormalUserToken, statusCode: 200 });\n\n      expect(result.errors).toBeDefined();\n      expect(result.errors[0].message).toContain('phone');\n    });\n\n    it('should accept valid German phone formats', async () => {\n      const validPhones = [\n        '+49 123 456789',\n        '+49 (0)123 456789',\n        '0123 456789',\n      ];\n\n      for (const phone of validPhones) {\n        const result = await testHelper.graphQl({\n          arguments: {\n            id: gNormalUserId,\n            input: { phone },\n          },\n          fields: ['phone'],\n          name: 'updateUser',\n          type: TestGraphQLType.MUTATION,\n        }, { token: gNormalUserToken });\n\n        expect(result.phone).toBe(phone);\n      }\n    });\n  });\n});\n```\n\n---\n\n## Debugging Test Failures\n\nWhen your tests fail and error messages are unclear, enable debugging:\n\n** TIP: For all TestHelper options, read the source file:**\n\n```\nnode_modules/@lenne.tech/nest-server/src/test/test.helper.ts\n```\n\nThis file documents all capabilities including `log`, `logError`, file uploads via `attachments`, and more.\n\n### TestHelper Debugging Options\n\n```typescript\n// Add to any failing test for detailed output\nconst result = await testHelper.graphQl({\n  arguments: { id: userId },\n  fields: ['id', 'email'],\n  name: 'getUser',\n  type: TestGraphQLType.MUTATION,\n}, {\n  token: userToken,\n  log: true,        // Logs request details to console\n  logError: true,   // Logs detailed error information\n});\n\n// Or for REST calls\nconst result = await testHelper.rest('/api/endpoint', {\n  method: 'POST',\n  payload: data,\n  token: userToken,\n  log: true,\n  logError: true,\n});\n```\n\n### Server-Side Debugging\n\n**Enable exception logging** in `src/config.env.ts`:\n```typescript\nexport default {\n  logExceptions: true,  // Shows stack traces for all exceptions\n  // ... other config\n};\n```\n\n**Enable validation debugging** via environment variable:\n```bash\n# Run tests with validation debugging\nDEBUG_VALIDATION=true npm test\n```\n\nOr set in your test file:\n```typescript\nbeforeAll(async () => {\n  // Enable validation debug logging\n  process.env.DEBUG_VALIDATION = 'true';\n\n  // ... rest of setup\n});\n```\n\nThis enables detailed console.debug output from MapAndValidatePipe (automatically activated via CoreModule - see `node_modules/@lenne.tech/nest-server/src/core/common/pipes/map-and-validate.pipe.ts`).\n\n### Full Debugging Setup Example\n\n```typescript\ndescribe('My Story Test', () => {\n  beforeAll(async () => {\n    // Enable validation debugging\n    process.env.DEBUG_VALIDATION = 'true';\n\n    // ... normal setup\n  });\n\n  it('should debug this failing test', async () => {\n    const result = await testHelper.graphQl({\n      // ... your test config\n    }, {\n      log: true,        // Enable request/response logging\n      logError: true,   // Enable error logging\n    });\n  });\n});\n```\n\n**Remember to disable debugging logs before committing** to keep test output clean in CI/CD.\n\n### File Upload Testing\n\nTestHelper supports file uploads via the `attachments` option:\n\n```typescript\n// Upload a single file\nconst result = await testHelper.rest('/api/upload', {\n  method: 'POST',\n  attachments: [\n    { name: 'document', path: '/path/to/document.pdf' },\n  ],\n  token: userToken,\n});\n\n// Upload multiple files\nconst result = await testHelper.rest('/api/upload-multiple', {\n  method: 'POST',\n  attachments: [\n    { name: 'avatar', path: '/path/to/avatar.png' },\n    { name: 'resume', path: '/path/to/resume.pdf' },\n  ],\n  token: userToken,\n});\n```\n\n**See `node_modules/@lenne.tech/nest-server/src/test/test.helper.ts` for all available options.**\n\n---\n\n## Key Takeaways from Examples\n\n### 1. Test Structure\n- Always setup test data in `beforeAll`\n- Clean up in `afterAll`\n- Group related tests in `describe` blocks\n- Test happy path, validation, authorization separately\n\n### 2. Security Testing\n- Create users with different roles\n- Test both authorized and unauthorized access\n- Never weaken security to make tests pass\n- Test permission boundaries explicitly\n\n### 3. Business Logic\n- Test calculated fields (like totalPrice)\n- Test side effects (like stock reduction)\n- Test validation rules thoroughly\n- Test edge cases and error conditions\n\n### 4. Implementation Strategy\n- Use nest-server-generator for scaffolding\n- Implement business logic in services\n- Add custom validation where needed\n- Follow existing patterns in codebase\n\n### 5. Debugging\n- Use `log: true` and `logError: true` in TestHelper for detailed output\n- Enable `logExceptions` in config.env.ts for server-side errors\n- Use `DEBUG_VALIDATION=true` for validation debugging\n- Disable the debug logs again once all tests have been completed without errors\n\n### 6. Iteration\n- First run will always fail (expected)\n- Fix failures systematically\n- Enable debugging when error messages are unclear\n- Re-run tests after each change\n- Continue until all tests pass\n\nRemember: **Tests define the contract, code fulfills the contract.**",
        "plugins/lt-dev/skills/building-stories-with-tdd/fullstack-tdd-workflow.md": "# Fullstack TDD Workflow\n\nThis document describes the recommended Test-Driven Development approach for fullstack projects (Backend + Frontend).\n\n## Core Principle\n\n**Tests drive the implementation, not vice versa.**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  FULLSTACK TDD WORKFLOW                                                    ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  Phase 1: BACKEND                                                          ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ 1. Write Backend Tests (API Tests)                                  ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - REST endpoint tests (using TestHelper)                         ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - GraphQL mutation/query tests (if applicable)                   ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Test all expected API behavior BEFORE implementation           ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ                                                                     ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ 2. Implement Backend Against Tests                                  ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Create modules, services, controllers                          ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Iterate until ALL tests pass                                   ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Use `generating-nest-servers` skill                            ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  Phase 2: FRONTEND                                                         ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ 3. Write Frontend Tests (E2E Tests)                                 ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Playwright E2E tests for user workflows                        ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Test complete user journeys BEFORE implementation              ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Include authentication flows                                   ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ                                                                     ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ 4. Implement Frontend Against Tests                                 ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Create components, pages, composables                          ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Iterate until ALL E2E tests pass                               ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Use `developing-lt-frontend` skill                             ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  Phase 3: DEBUGGING & VERIFICATION                                         ‚îÇ\n‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ\n‚îÇ  ‚îÇ 5. Browser Debugging (Chrome MCP/DevTools)                          ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Use Chrome DevTools MCP for live debugging                     ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Verify API calls in Network tab                                ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Check Console for errors                                       ‚îÇ   ‚îÇ\n‚îÇ  ‚îÇ    - Take snapshots/screenshots for visual verification             ‚îÇ   ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Test Cleanup & Isolation\n\n**CRITICAL: Tests must be repeatable without side effects!**\n\n### Principles\n\n1. **Every test run must be independent** - No test should depend on state from a previous run\n2. **Complete cleanup after each test** - All created data must be removed in `afterAll`\n3. **Unique test data** - Use timestamps and random suffixes to avoid collisions\n4. **Separate environments** - Use dedicated test databases and environments\n\n### Backend Test Cleanup\n\n```typescript\n// tests/stories/feature.story.test.ts\n\ndescribe('Feature Story', () => {\n  let testHelper: TestHelper;\n  let createdIds: string[] = [];\n\n  beforeAll(async () => {\n    testHelper = await TestHelper.create();\n  });\n\n  afterAll(async () => {\n    // CRITICAL: Clean up ALL created entities\n    const db = testHelper.getDb();\n\n    // Delete all test-created entities\n    for (const id of createdIds) {\n      await db.collection('entities').deleteOne({ _id: new ObjectId(id) });\n    }\n\n    // Delete test users (emails ending with @test.com)\n    await db.collection('users').deleteMany({\n      email: { $regex: /@test\\.com$/ }\n    });\n\n    await testHelper.close();\n  });\n\n  it('should create entity', async () => {\n    const result = await testHelper.rest('/api/entities', {\n      method: 'POST',\n      payload: { name: `Test-${Date.now()}` },\n      token: userToken,\n      statusCode: 201\n    });\n\n    // Track for cleanup\n    createdIds.push(result.body.id);\n  });\n});\n```\n\n### Frontend E2E Test Cleanup\n\n```typescript\n// tests/e2e/feature.spec.ts\n\nimport { test, expect } from '@playwright/test';\n\ntest.describe('Feature E2E', () => {\n  const createdEntities: string[] = [];\n\n  test.afterAll(async ({ request }) => {\n    // Clean up via API\n    for (const id of createdEntities) {\n      await request.delete(`/api/entities/${id}`);\n    }\n  });\n\n  test('should complete user workflow', async ({ page }) => {\n    // Test implementation...\n  });\n});\n```\n\n### Test Data Best Practices\n\n```typescript\n// UNIQUE DATA GENERATION\nconst uniqueEmail = `user-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`;\nconst uniqueName = `Test-Entity-${Date.now()}`;\n\n// NEVER reuse data across test files\n// NEVER rely on specific IDs or pre-existing data\n// ALWAYS generate fresh test data\n```\n\n## Test Environment Configuration\n\n### Separate Test Database\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  ENVIRONMENT SEPARATION                                                    ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  Development:                                                              ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ Database: mongodb://localhost:27017/app-dev                           ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ Port: 3000 (API), 3001 (App)                                          ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ .env.development                                                      ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  Testing:                                                                  ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ Database: mongodb://localhost:27017/app-test (SEPARATE!)              ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ Port: 3100 (API), 3101 (App)                                          ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ .env.test                                                             ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  Production:                                                               ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ Database: Production MongoDB (Atlas/Self-hosted)                      ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ Port: 3000 (or configured)                                            ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ .env.production                                                       ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### npm Scripts for Test Environments\n\n#### Backend (projects/api/package.json)\n\n```json\n{\n  \"scripts\": {\n    \"start:dev\": \"NODE_ENV=development nest start --watch\",\n    \"start:test\": \"NODE_ENV=test nest start --watch\",\n    \"test\": \"NODE_ENV=test vitest run\",\n    \"test:watch\": \"NODE_ENV=test vitest\",\n    \"test:cov\": \"NODE_ENV=test vitest run --coverage\",\n    \"test:e2e\": \"NODE_ENV=test vitest run --config ./vitest.e2e.config.ts\",\n    \"test:stories\": \"NODE_ENV=test vitest run --dir tests/stories\"\n  }\n}\n```\n\n#### Frontend (projects/app/package.json)\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"nuxi dev --port 3001\",\n    \"dev:test\": \"NODE_ENV=test nuxi dev --port 3101\",\n    \"test:e2e\": \"playwright test\",\n    \"test:e2e:ui\": \"playwright test --ui\",\n    \"test:e2e:headed\": \"playwright test --headed\",\n    \"generate-types\": \"openapi-typescript http://localhost:3000/swagger-json -o ./app/api-client/types.gen.ts\"\n  }\n}\n```\n\n#### Root (package.json) - Monorepo\n\n```json\n{\n  \"scripts\": {\n    \"test:backend\": \"npm test --workspace=projects/api\",\n    \"test:frontend\": \"npm run test:e2e --workspace=projects/app\",\n    \"test:all\": \"npm run test:backend && npm run test:frontend\",\n    \"start:test:api\": \"npm run start:test --workspace=projects/api\",\n    \"start:test:app\": \"npm run dev:test --workspace=projects/app\"\n  }\n}\n```\n\n### Backend Test Environment (@lenne.tech/nest-server)\n\n#### Configuration File (src/config.env.ts)\n\n```typescript\nimport { ConfigEnv } from '@lenne.tech/nest-server';\n\n// Environment-specific configuration\nconst envConfig: Record<string, Partial<ConfigEnv>> = {\n  development: {\n    mongoose: {\n      uri: 'mongodb://localhost:27017/app-dev',\n    },\n    port: 3000,\n  },\n  test: {\n    mongoose: {\n      uri: 'mongodb://localhost:27017/app-test',\n    },\n    port: 3100,\n    // Disable email sending in tests\n    email: {\n      smtp: {\n        host: 'localhost',\n        port: 1025, // Mailhog\n      },\n    },\n  },\n  production: {\n    mongoose: {\n      uri: process.env.MONGODB_URI,\n    },\n    port: parseInt(process.env.PORT) || 3000,\n  },\n};\n\nexport function getConfig(): ConfigEnv {\n  const env = process.env.NODE_ENV || 'development';\n  return {\n    ...defaultConfig,\n    ...envConfig[env],\n  };\n}\n```\n\n#### Test Helper Configuration (tests/test.helper.ts)\n\n```typescript\nimport { TestHelper } from '@lenne.tech/nest-server/test';\n\n// TestHelper automatically uses NODE_ENV=test configuration\nexport async function createTestHelper(): Promise<TestHelper> {\n  const testHelper = await TestHelper.create({\n    // Uses src/config.env.ts with NODE_ENV=test\n  });\n  return testHelper;\n}\n```\n\n### Frontend Test Environment (Playwright)\n\n#### playwright.config.ts\n\n```typescript\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './tests/e2e',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: [['html'], ['list']],\n\n  use: {\n    // Use test environment port\n    baseURL: process.env.TEST_BASE_URL || 'http://localhost:3101',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'on-first-retry',\n  },\n\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n  ],\n\n  // Start both API and App in test mode\n  webServer: [\n    {\n      command: 'npm run start:test --workspace=projects/api',\n      url: 'http://localhost:3100/api',\n      reuseExistingServer: !process.env.CI,\n      timeout: 120 * 1000,\n    },\n    {\n      command: 'npm run dev:test --workspace=projects/app',\n      url: 'http://localhost:3101',\n      reuseExistingServer: !process.env.CI,\n      timeout: 120 * 1000,\n    },\n  ],\n});\n```\n\n### Docker Test Environment (Optional)\n\n#### docker-compose.test.yml\n\n```yaml\nversion: '3.8'\n\nservices:\n  mongodb-test:\n    image: mongo:7\n    ports:\n      - '27018:27017'  # Different port for test DB\n    volumes:\n      - mongodb_test_data:/data/db\n    environment:\n      MONGO_INITDB_DATABASE: app-test\n\n  mailhog:\n    image: mailhog/mailhog\n    ports:\n      - '1025:1025'    # SMTP\n      - '8025:8025'    # Web UI\n\nvolumes:\n  mongodb_test_data:\n```\n\n```bash\n# Start test infrastructure\ndocker compose -f docker-compose.test.yml up -d\n\n# Run tests\nnpm run test:all\n```\n\n## Workflow Steps in Detail\n\n### Step 1: Write Backend Tests\n\n**Location:** `tests/stories/` or `tests/api/`\n\n**Goals:**\n- Define expected API behavior\n- Cover all endpoints (CRUD operations)\n- Include authentication/authorization tests\n- Test error cases and edge cases\n\n**Example:**\n```typescript\ndescribe('Product API', () => {\n  describe('Happy Path', () => {\n    it('should create product as admin', async () => { /* ... */ });\n    it('should list products as user', async () => { /* ... */ });\n    it('should update own product', async () => { /* ... */ });\n    it('should delete own product', async () => { /* ... */ });\n  });\n\n  describe('Error Cases', () => {\n    it('should reject unauthorized access (401)', async () => { /* ... */ });\n    it('should reject forbidden action (403)', async () => { /* ... */ });\n    it('should validate input (400)', async () => { /* ... */ });\n  });\n});\n```\n\n### Step 2: Implement Backend\n\n**Use `generating-nest-servers` skill for:**\n- Module creation (`lt server module`)\n- Object creation (`lt server object`)\n- Property addition (`lt server addProp`)\n\n**Iterate until all tests pass:**\n```bash\nnpm test -- tests/stories/product.story.test.ts\n```\n\n### Step 3: Write Frontend E2E Tests\n\n**Location:** `tests/e2e/` or `e2e/`\n\n**Goals:**\n- Test complete user workflows\n- Cover critical user journeys\n- Include authentication flows\n- Test responsive behavior (optional)\n\n**Example:**\n```typescript\ntest.describe('Product Management', () => {\n  test('should complete product creation workflow', async ({ page }) => {\n    // 1. Login\n    await page.goto('/login');\n    await page.fill('[data-testid=\"email\"]', 'admin@test.com');\n    await page.fill('[data-testid=\"password\"]', 'password');\n    await page.click('[data-testid=\"submit\"]');\n\n    // 2. Navigate to products\n    await page.goto('/products');\n    await expect(page.locator('h1')).toContainText('Produkte');\n\n    // 3. Create new product\n    await page.click('[data-testid=\"create-product\"]');\n    await page.fill('[data-testid=\"product-name\"]', 'Test Product');\n    await page.click('[data-testid=\"save\"]');\n\n    // 4. Verify creation\n    await expect(page.locator('text=Test Product')).toBeVisible();\n  });\n});\n```\n\n### Step 4: Implement Frontend\n\n**Use `developing-lt-frontend` skill for:**\n- Component creation\n- Composable implementation\n- Page layouts\n- API integration\n\n**Iterate until all E2E tests pass:**\n```bash\nnpm run test:e2e\n```\n\n### Step 5: Browser Debugging\n\n**Use Chrome DevTools MCP for:**\n- Live debugging during development\n- Network request inspection\n- Console error checking\n- Visual verification with snapshots\n\n**MCP Tools:**\n| Tool | Use Case |\n|------|----------|\n| `navigate_page` | Go to specific URL |\n| `take_snapshot` | Get page structure |\n| `take_screenshot` | Visual capture |\n| `list_console_messages` | Check JS errors |\n| `list_network_requests` | Debug API calls |\n| `click`, `fill` | Interact with elements |\n\n## Running the Complete Test Suite\n\n### Backend Tests\n```bash\n# All backend tests\nnpm test\n\n# Specific story test\nnpm test -- tests/stories/product.story.test.ts\n\n# With coverage\nnpm test -- --coverage\n```\n\n### Frontend E2E Tests\n```bash\n# All E2E tests\nnpm run test:e2e\n\n# Specific test file\nnpx playwright test tests/e2e/product.spec.ts\n\n# With UI mode (debugging)\nnpx playwright test --ui\n\n# With headed browser\nnpx playwright test --headed\n```\n\n### Full Suite\n```bash\n# Run everything (CI)\nnpm run test:all\n# or\nnpm test && npm run test:e2e\n```\n\n## Checklist\n\n### Before Starting\n- [ ] Test environment configured (separate database)\n- [ ] Test utilities available (TestHelper for backend)\n- [ ] Playwright configured for E2E tests\n- [ ] Chrome DevTools MCP available for debugging\n\n### During Development\n- [ ] Tests written BEFORE implementation\n- [ ] Tests fail initially (Red phase)\n- [ ] Minimal implementation to pass tests (Green phase)\n- [ ] Refactoring with tests passing (Refactor phase)\n\n### After Completion\n- [ ] All tests pass (`npm test && npm run test:e2e`)\n- [ ] Test cleanup verified (run tests twice without issues)\n- [ ] No hardcoded test data in production code\n- [ ] Coverage acceptable (aim for >80%)\n\n## Related Documentation\n\n- **Backend TDD:** `workflow.md` (detailed 7-step process)\n- **Backend Test Patterns:** `examples.md`, `reference.md`\n- **Frontend E2E Testing:** `developing-lt-frontend` skill -> `reference/e2e-testing.md`\n- **Security in Tests:** `security-review.md`\n",
        "plugins/lt-dev/skills/building-stories-with-tdd/handling-existing-tests.md": "---\nname: story-tdd-handling-existing-tests\ndescription: Complete guide for handling existing tests when modifying code in TDD workflow - decision trees, git analysis, examples, and guidelines for determining when to update tests vs fix code\n---\n\n#  Handling Existing Tests When Modifying Code\n\n## Table of Contents\n- [Analysis Decision Tree](#analysis-decision-tree)\n- [Using Git for Analysis (ALLOWED)](#using-git-for-analysis-allowed)\n- [Examples](#examples)\n- [Guidelines](#guidelines)\n- [Process](#process)\n- [Red Flags](#red-flags)\n- [Remember](#remember)\n\n**CRITICAL RULE:** When your code changes cause existing (non-story) tests to fail, you MUST analyze and handle this properly.\n\n## Analysis Decision Tree\n\nWhen existing tests fail after your changes:\n\n```\nExisting test fails\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Was this change intentional and breaking?\n    ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îú‚îÄ‚ñ∫ YES: Change was deliberate and it's clear why tests break\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚ñ∫  Update the existing tests to reflect new behavior\n    ‚îÇ   ‚îÇ       - Modify test expectations\n    ‚îÇ   ‚îÇ       - Update test data/setup if needed\n    ‚îÇ   ‚îÇ       - Document why test was changed\n    ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îî‚îÄ‚ñ∫ NO/UNCLEAR: Not sure why tests are breaking\n    ‚îÇ       ‚îî‚îÄ‚ñ∫  Investigate potential side effect\n    ‚îÇ           ‚îÇ\n    ‚îÇ           ‚îú‚îÄ‚ñ∫ Use git to review previous state:\n    ‚îÇ           ‚îÇ   - git show HEAD:path/to/file.ts\n    ‚îÇ           ‚îÇ   - git diff HEAD path/to/test.ts\n    ‚îÇ           ‚îÇ   - git log -p path/to/file.ts\n    ‚îÇ           ‚îÇ\n    ‚îÇ           ‚îú‚îÄ‚ñ∫ Compare old vs new behavior\n    ‚îÇ           ‚îÇ\n    ‚îÇ           ‚îî‚îÄ‚ñ∫  Likely unintended side effect!\n    ‚îÇ               ‚îî‚îÄ‚ñ∫ Fix code to satisfy BOTH old AND new tests\n    ‚îÇ                   - Refine implementation\n    ‚îÇ                   - Add conditional logic if needed\n    ‚îÇ                   - Ensure backward compatibility\n    ‚îÇ                   - Keep existing functionality intact\n```\n\n## Using Git for Analysis (ALLOWED)\n\n** Git commands are EXPLICITLY ALLOWED for analysis:**\n\n```bash\n# View old version of a file\ngit show HEAD:src/server/modules/user/user.service.ts\n\n# See what changed in a file\ngit diff HEAD src/server/modules/user/user.service.ts\n\n# View file from specific commit\ngit show abc123:path/to/file.ts\n\n# See commit history for a file\ngit log -p --follow path/to/file.ts\n\n# Compare branches\ngit diff main..HEAD path/to/file.ts\n```\n\n**These commands help you understand:**\n- What the code looked like before your changes\n- What the previous test expectations were\n- Why existing tests were written a certain way\n- Whether your change introduces regression\n\n## Examples\n\n### Example 1: Intentional Breaking Change\n\n```typescript\n// Scenario: You added a required field to User model\n// Old test expects: { email, firstName }\n// New behavior requires: { email, firstName, lastName }\n\n//  CORRECT: Update the test\nit('should create user', async () => {\n  const user = await userService.create({\n    email: 'test@example.com',\n    firstName: 'John',\n    lastName: 'Doe', //  Added required field\n  });\n  // ...\n});\n```\n\n### Example 2: Unintended Side Effect\n\n```typescript\n// Scenario: You changed authentication logic for new feature\n// Old tests for different feature now fail unexpectedly\n\n//  WRONG: Just update the failing tests\n//  CORRECT: Investigate and fix the code\n\n// 1. Use git to see old implementation\n// git show HEAD:src/server/modules/auth/auth.service.ts\n\n// 2. Identify the unintended side effect\n// 3. Refine your code to avoid breaking existing functionality\n\n// Example fix: Add conditional logic\nasync authenticate(user: User, options?: AuthOptions) {\n  // Your new feature logic\n  if (options?.useNewBehavior) {\n    return this.newAuthMethod(user);\n  }\n\n  // Preserve existing behavior for backward compatibility\n  return this.existingAuthMethod(user);\n}\n```\n\n## Guidelines\n\n** DO update existing tests when:**\n- You intentionally changed an API contract\n- You removed deprecated functionality\n- You renamed fields/methods\n- The old behavior is being replaced (not extended)\n- It's documented in your story requirements\n\n** DON'T update existing tests when:**\n- You're not sure why they're failing\n- The failure seems unrelated to your story\n- Multiple unrelated tests are breaking\n- The test was testing important existing functionality\n\n** INVESTIGATE when:**\n- More than 2-3 existing tests fail\n- Tests in unrelated modules fail\n- Test failure messages are unclear\n- You suspect a side effect\n\n## Process\n\n1. **Run ALL tests** (not just story tests)\n   ```bash\n   npm test\n   ```\n\n2. **If existing tests fail:**\n   ```bash\n   # Identify which tests failed\n   # For each failing test, decide:\n   ```\n\n3. **For intentional changes:**\n   - Update test expectations\n   - Document change in commit message (when developer commits)\n   - Verify all tests pass\n\n4. **For unclear failures:**\n   - Use `git show` to see old code\n   - Use `git diff` to see your changes\n   - Compare old vs new behavior\n   - Refine code to fix both old AND new tests\n\n5. **Validate:**\n   ```bash\n   # All tests (old + new) should pass\n   npm test\n   ```\n\n## Red Flags\n\nüö© **Warning signs of unintended side effects:**\n- Tests in different modules failing\n- Security/auth tests failing\n- Tests that worked in `main` branch now fail\n- Tests with names unrelated to your story failing\n\n**When you see red flags:**\n1. STOP updating tests\n2. Use git to investigate\n3. Fix the code, not the tests\n4. Ask developer if uncertain\n\n## Remember\n\n- **Existing tests are documentation** of expected behavior\n- **Don't break working functionality** to make new tests pass\n- **Use git freely** for investigation (NOT for commits)\n- **When in doubt, preserve backward compatibility**\n",
        "plugins/lt-dev/skills/building-stories-with-tdd/reference.md": "---\nname: story-tdd-reference\ndescription: Quick reference guide for Test-Driven Development workflow\n---\n\n# Story-Based TDD Quick Reference\n\n## Table of Contents\n- [The 7-Step Workflow](#the-7-step-workflow)\n- [Commands Cheatsheet](#commands-cheatsheet)\n- [Test File Organization](#test-file-organization)\n- [Test File Template](#test-file-template)\n- [Database Indexes with @UnifiedField](#database-indexes-with-unifiedfield)\n- [REST API Testing Patterns](#rest-api-testing-patterns-using-testhelper)\n- [GraphQL Testing Patterns](#graphql-testing-patterns-using-testhelper)\n- [Common Test Assertions](#common-test-assertions)\n- [ObjectId Conversion Utilities](#objectid-conversion-utilities)\n- [Security Testing Checklist](#security-testing-checklist)\n- [When to Ask Developer](#when-to-ask-developer)\n- [Debugging Failed Tests](#debugging-failed-tests)\n- [Decision Tree: Test Failure Analysis](#decision-tree-test-failure-analysis)\n- [Code Quality, Security & Refactoring Check](#code-quality-security--refactoring-check)\n- [Final Report Template](#final-report-template)\n- [Handling Existing Tests](#-handling-existing-tests)\n- [CRITICAL: Git Commits](#-critical-git-commits)\n- [CRITICAL: Database Cleanup & Test Isolation](#-critical-database-cleanup--test-isolation)\n- [User Authentication: signUp vs signIn](#user-authentication-signup-vs-signin)\n- [Avoiding Test Interdependencies](#avoiding-test-interdependencies)\n- [Async/Await Best Practices](#asyncawait-best-practices)\n\n## The 7-Step Workflow\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Step 1: Analyze Story & Clarify                         ‚îÇ\n‚îÇ - Read requirements thoroughly                          ‚îÇ\n‚îÇ - Check existing API structure                          ‚îÇ\n‚îÇ - Identify contradictions                               ‚îÇ\n‚îÇ - ASK DEVELOPER if anything unclear                     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                          ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Step 2: Create Story Test                               ‚îÇ\n‚îÇ - Location: tests/stories/feature-name.story.test.ts     ‚îÇ\n‚îÇ - Study existing test patterns                          ‚îÇ\n‚îÇ - Write comprehensive test scenarios                    ‚îÇ\n‚îÇ - Cover happy path, errors, edge cases                  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                          ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Step 3: Run Tests & Analyze                             ‚îÇ\n‚îÇ - npm test                                              ‚îÇ\n‚îÇ - Record failures and reasons                           ‚îÇ\n‚îÇ - Decide: Test bug OR Missing implementation            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                          ‚Üì\n                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n                   ‚îÇ             ‚îÇ\n        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îê       ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n        ‚îÇ Step 3a:   ‚îÇ       ‚îÇ Step 4:        ‚îÇ\n        ‚îÇ Fix Test   ‚îÇ       ‚îÇ Implement Code ‚îÇ\n        ‚îÇ Errors     ‚îÇ       ‚îÇ (Use nest-     ‚îÇ\n        ‚îÇ            ‚îÇ       ‚îÇ  server-       ‚îÇ\n        ‚îÇ            ‚îÇ       ‚îÇ  generator)    ‚îÇ\n        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n               ‚îÇ                 ‚îÇ\n               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                        ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Step 5: Validate                                        ‚îÇ\n‚îÇ - Run ALL tests                                         ‚îÇ\n‚îÇ - All pass? -> Go to Step 5a                            ‚îÇ\n‚îÇ - Some fail? -> Back to Step 3                          ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                          ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Step 5a: Code Quality, Security & Refactoring Check    ‚îÇ\n‚îÇ - Check for code duplication                            ‚îÇ\n‚îÇ - Extract common functionality                          ‚îÇ\n‚îÇ - Consolidate similar code paths                        ‚îÇ\n‚îÇ - Review for consistency                                ‚îÇ\n‚îÇ - Check database indexes                                ‚îÇ\n‚îÇ -  SECURITY REVIEW (CRITICAL)                         ‚îÇ\n‚îÇ - Run tests after refactoring                           ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n                          ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Step 5b: Final Validation                               ‚îÇ\n‚îÇ - Run ALL tests one final time                          ‚îÇ\n‚îÇ - Generate report -> DONE!                             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Commands Cheatsheet\n\n### Running Tests\n\n```bash\n# Run all tests\nnpm test\n\n# Run specific story test\nnpm test -- tests/stories/feature-name.story.test.ts\n\n# Run tests with coverage\nnpm run test:cov\n\n# Run tests in watch mode\nnpm run test:watch\n```\n\n### Using nest-server-generator Skill\n\n```bash\n# Create module\nlt server module ModuleName --no-interactive\n\n# Create object\nlt server object ObjectName --no-interactive\n\n# Add property\nlt server addProp ModuleName propertyName:type --no-interactive\n\n# Examples:\nlt server module Review --no-interactive\nlt server addProp Review rating:number --no-interactive\nlt server addProp Review comment:string? --no-interactive\n```\n\n## Test File Organization\n\n### Structuring Tests with Subfolders\n\nWhen many test files accumulate in `tests/stories/`, consider organizing them into subfolders for better clarity:\n\n** DO use subfolders when:**\n- Multiple tests can be logically grouped (e.g., by feature, module, or domain)\n- Each subfolder contains at least 3-5 related test files\n- The grouping improves discoverability and navigation\n\n** DON'T use subfolders when:**\n- Only 1-2 files would end up in each subfolder (defeats the purpose)\n- The grouping is arbitrary or unclear\n- Tests are already easy to find\n\n**Example folder structure:**\n\n```\ntests/stories/\n‚îú‚îÄ‚îÄ user-management/           #  Good: 4 related tests\n‚îÇ   ‚îú‚îÄ‚îÄ user-registration.story.test.ts\n‚îÇ   ‚îú‚îÄ‚îÄ user-profile.story.test.ts\n‚îÇ   ‚îú‚îÄ‚îÄ user-roles.story.test.ts\n‚îÇ   ‚îî‚îÄ‚îÄ user-deletion.story.test.ts\n‚îú‚îÄ‚îÄ orders/                    #  Good: 3 related tests\n‚îÇ   ‚îú‚îÄ‚îÄ order-creation.story.test.ts\n‚îÇ   ‚îú‚îÄ‚îÄ order-fulfillment.story.test.ts\n‚îÇ   ‚îî‚îÄ‚îÄ order-cancellation.story.test.ts\n‚îú‚îÄ‚îÄ auth/                      #  Bad: Only 1 file, should stay in root\n‚îÇ   ‚îî‚îÄ‚îÄ login.story.test.ts\n‚îî‚îÄ‚îÄ simple-feature.story.test.ts  #  OK: Single file stays in root\n```\n\n**Rule of thumb:** If you can't fill a subfolder with at least 3 thematically related test files, keep them in the root `tests/stories/` directory.\n\n---\n\n## Test File Template\n\n```typescript\nimport {\n  ConfigService,\n  HttpExceptionLogFilter,\n  TestGraphQLType,\n  TestHelper,\n} from '@lenne.tech/nest-server';\nimport { Test, TestingModule } from '@nestjs/testing';\nimport { PubSub } from 'graphql-subscriptions';\nimport { MongoClient, ObjectId } from 'mongodb';\n\nimport envConfig from '../../src/config.env';\nimport { RoleEnum } from '../../src/server/common/enums/role.enum';\nimport { imports, ServerModule } from '../../src/server/server.module';\n\n//  IMPORTANT: Do NOT import Services!\n// Tests must ONLY use API endpoints via TestHelper.\n// Services are accessed indirectly through Controllers/Resolvers.\n\ndescribe('[Feature Name] Story', () => {\n  // Test environment properties\n  let app;\n  let testHelper: TestHelper;\n\n  // Database (only for setup/cleanup and setting roles/verified status)\n  let connection;\n  let db;\n\n  // Global test data\n  let gUserToken: string;\n  let gUserId: string;\n\n  // Track created entities for cleanup\n  let createdEntityIds: string[] = [];\n\n  beforeAll(async () => {\n    // Start server for testing\n    const moduleFixture: TestingModule = await Test.createTestingModule({\n      imports: [...imports, ServerModule],\n      providers: [\n        {\n          provide: 'PUB_SUB',\n          useValue: new PubSub(),\n        },\n      ],\n    }).compile();\n\n    app = moduleFixture.createNestApplication();\n    app.useGlobalFilters(new HttpExceptionLogFilter());\n    app.setBaseViewsDir(envConfig.templates.path);\n    app.setViewEngine(envConfig.templates.engine);\n    await app.init();\n\n    testHelper = new TestHelper(app);\n\n    // Connection to database (ONLY for cleanup and setting roles/verified)\n    connection = await MongoClient.connect(envConfig.mongoose.uri);\n    db = await connection.db();\n\n    //  CRITICAL: Create test user with @test.com email\n    const password = Math.random().toString(36).substring(7);\n    //  MUST end with @test.com for e2e.brevo.exclude filtering\n    // Use timestamp + random suffix for guaranteed uniqueness\n    const email = `test-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`;\n    const signUp = await testHelper.graphQl({\n      arguments: {\n        input: {\n          email,\n          firstName: 'Test',\n          password,\n        },\n      },\n      fields: ['token', { user: ['id', 'email'] }],\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n    });\n    gUserId = signUp.user.id;\n    gUserToken = signUp.token;\n  });\n\n  afterAll(async () => {\n    // üßπ CLEANUP: Delete all test data created during tests\n    try {\n      if (createdEntityIds.length > 0) {\n        await db.collection('entities').deleteMany({\n          _id: { $in: createdEntityIds.map(id => new ObjectId(id)) }\n        });\n      }\n\n      // Delete test user\n      if (gUserId) {\n        await db.collection('users').deleteOne({ _id: new ObjectId(gUserId) });\n      }\n    } catch (error) {\n      console.error('Cleanup failed:', error);\n    }\n\n    await connection.close();\n    await app.close();\n  });\n\n  describe('Happy Path', () => {\n    it('should [expected behavior]', async () => {\n      // Arrange\n      //  IMPORTANT: Make data unique per test file to avoid conflicts\n      const data = {\n        email: `entity-feature-test-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`,  //  @test.com + unique\n        name: `Entity-FeatureTest-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`,  //  Unique per test file\n      };\n\n      // Act - Using REST\n      const result = await testHelper.rest('/api/endpoint', {\n        method: 'POST',\n        payload: data,\n        token: gUserToken,\n      });\n\n      // Assert\n      expect(result).toMatchObject({\n        // expected properties\n      });\n\n      //  Track for cleanup (CRITICAL for parallel-safe tests)\n      createdEntityIds.push(result.id);\n    });\n  });\n\n  describe('Error Cases', () => {\n    it('should reject invalid input', async () => {\n      await testHelper.rest('/api/endpoint', {\n        method: 'POST',\n        payload: { /* invalid data */ },\n        statusCode: 400,\n        token: gUserToken,\n      });\n    });\n\n    it('should require authentication', async () => {\n      await testHelper.rest('/api/endpoint', {\n        method: 'POST',\n        payload: { /* data */ },\n        statusCode: 401,\n      });\n    });\n  });\n});\n```\n\n## Database Indexes with @UnifiedField\n\n### When to Add Indexes\n\n** ALWAYS define indexes in @UnifiedField decorator via mongoose option!**\n\n```typescript\n//  CORRECT: Index in decorator mongoose option\n@UnifiedField({\n  description: 'User email',\n  mongoose: { index: true, unique: true, type: String }\n})\nemail: string;\n\n//  WRONG: Separate schema index (hard to find)\nUserSchema.index({ email: 1 }, { unique: true });\n```\n\n### Common Index Patterns\n\n**Single Field Index:**\n```typescript\n@UnifiedField({\n  description: 'Product category',\n  mongoose: { index: true, type: String }  // For queries like: find({ category: 'electronics' })\n})\ncategory: string;\n```\n\n**Unique Index:**\n```typescript\n@UnifiedField({\n  description: 'Username',\n  mongoose: { index: true, unique: true, type: String }  // Prevents duplicates\n})\nusername: string;\n```\n\n**Foreign Key Index:**\n```typescript\n@UnifiedField({\n  description: 'User who created this',\n  mongoose: { index: true, type: String }  // For JOIN/population operations\n})\ncreatedBy: string;\n```\n\n**Multiple Indexed Fields:**\n```typescript\n@UnifiedField({\n  description: 'Customer reference',\n  mongoose: { index: true, type: String }  // Indexed individually\n})\ncustomerId: string;\n\n@UnifiedField({\n  description: 'Order status',\n  mongoose: { index: true, type: String }  // Indexed individually\n})\nstatus: string;\n\n// Both indexed for flexible querying\n```\n\n**Text Search Index:**\n```typescript\n@UnifiedField({\n  description: 'Product name',\n  mongoose: { type: String, text: true }  // For full-text search\n})\nname: string;\n```\n\n### Index Checklist\n\nBefore marking complete, verify:\n\n- [ ] Fields used in `find()` queries have indexes\n- [ ] Foreign keys (userId, productId, etc.) have indexes\n- [ ] Unique fields (email, username) marked with `unique: true`\n- [ ] Fields used in sorting have indexes\n- [ ] Compound queries use compound indexes\n- [ ] All indexes in @UnifiedField decorator (NOT separate schema)\n\n## REST API Testing Patterns (using TestHelper)\n\n** IMPORTANT: Before writing tests, read the TestHelper source file to understand all available features:**\n\n```\nnode_modules/@lenne.tech/nest-server/src/test/test.helper.ts\n```\n\nThis file documents all TestHelper capabilities including:\n- File uploads via `attachments` option\n- Debugging with `log` and `logError` options in `TestRestOptions`\n- Custom headers, status code validation, and more\n\n```typescript\n// GET request\nconst result = await testHelper.rest('/api/resource/123', {\n  token: userToken,\n});\n\n// GET request (public endpoint, no auth)\nconst result = await testHelper.rest('/api/public');\n\n// POST request\nconst result = await testHelper.rest('/api/resource', {\n  method: 'POST',\n  payload: data,\n  token: userToken,\n});\n\n// PUT request\nconst result = await testHelper.rest('/api/resource/123', {\n  method: 'PUT',\n  payload: updates,\n  token: userToken,\n});\n\n// DELETE request\nconst result = await testHelper.rest('/api/resource/123', {\n  method: 'DELETE',\n  token: userToken,\n});\n\n// Expect specific status code\nawait testHelper.rest('/api/resource', {\n  method: 'POST',\n  payload: invalidData,\n  statusCode: 400,\n  token: userToken,\n});\n\n// With custom headers\nconst result = await testHelper.rest('/api/resource', {\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Custom-Header': 'value',\n  },\n  token: userToken,\n});\n\n// File upload via attachments\nconst result = await testHelper.rest('/api/upload', {\n  method: 'POST',\n  attachments: [\n    { name: 'file', path: '/path/to/file.pdf' },\n    { name: 'image', path: '/path/to/image.png' },\n  ],\n  token: userToken,\n});\n```\n\n## GraphQL Testing Patterns (using TestHelper)\n\n```typescript\nimport { TestGraphQLType, TestHelper } from '@lenne.tech/nest-server';\n\n// GraphQL Query\nconst user = await testHelper.graphQl({\n  arguments: {\n    id: userId,\n  },\n  fields: ['id', 'email', 'firstName', { profile: ['bio', 'avatar'] }],\n  name: 'getUser',\n  type: TestGraphQLType.QUERY,\n}, { token: userToken });\n\nexpect(user).toMatchObject({\n  id: userId,\n  email: 'test@example.com',\n});\n\n// GraphQL Mutation\nconst result = await testHelper.graphQl({\n  arguments: {\n    input: {\n      firstName: 'Updated',\n      lastName: 'Name',\n    },\n  },\n  fields: ['id', 'firstName', 'lastName'],\n  name: 'updateUser',\n  type: TestGraphQLType.MUTATION,\n}, { token: userToken });\n\n// GraphQL Mutation with nested objects\nconst created = await testHelper.graphQl({\n  arguments: {\n    input: {\n      title: 'New Post',\n      content: 'Post content',\n      tags: ['tag1', 'tag2'],\n    },\n  },\n  fields: ['id', 'title', { author: ['id', 'email'] }, 'tags'],\n  name: 'createPost',\n  type: TestGraphQLType.MUTATION,\n}, { token: userToken });\n\n// GraphQL Query without auth (public)\nconst publicData = await testHelper.graphQl({\n  arguments: {},\n  fields: ['version', 'status'],\n  name: 'getPublicInfo',\n  type: TestGraphQLType.QUERY,\n});\n\n// Expecting errors (e.g., unauthorized)\nconst result = await testHelper.graphQl({\n  arguments: { id: otherUserId },\n  fields: ['id', 'email'],\n  name: 'getUser',\n  type: TestGraphQLType.QUERY,\n}, { token: userToken, statusCode: 200 });\n\nexpect(result.errors).toBeDefined();\nexpect(result.errors[0].message).toContain('Forbidden');\n```\n\n## Common Test Assertions\n\n```typescript\n// Object matching\nexpect(result).toMatchObject({ key: value });\n\n// Exact equality\nexpect(result).toEqual(expected);\n\n// Array checks\nexpect(array).toHaveLength(3);\nexpect(array).toContain(item);\nexpect(array).toBeInstanceOf(Array);\n\n// Existence checks\nexpect(value).toBeDefined();\nexpect(value).toBeUndefined();\nexpect(value).toBeNull();\nexpect(value).toBeTruthy();\nexpect(value).toBeFalsy();\n\n// Number comparisons\nexpect(number).toBeGreaterThan(5);\nexpect(number).toBeLessThan(10);\nexpect(number).toBeCloseTo(3.14, 2);\n\n// String matching\nexpect(string).toContain('substring');\nexpect(string).toMatch(/regex/);\n\n// Error checking\nexpect(() => fn()).toThrow();\nexpect(() => fn()).toThrow('error message');\n```\n\n## ObjectId Conversion Utilities\n\n**Use the utility functions from @lenne.tech/nest-server for ObjectId conversions:**\n\n```typescript\nimport { getStringIds, getObjectIds } from '@lenne.tech/nest-server';\n\n// Convert ObjectIds to strings (works with arrays OR single values)\nconst stringIds = getStringIds(objectIds);     // ObjectId[] -> string[]\nconst stringId = getStringIds(singleObjectId); // ObjectId -> string\n\n// Convert strings to ObjectIds (works with arrays OR single values)\nconst objectIds = getObjectIds(stringIds);     // string[] -> ObjectId[]\nconst objectId = getObjectIds(singleStringId); // string -> ObjectId\n\n// Pass objects directly - the functions extract IDs automatically!\nconst stringIds = getStringIds(documents);     // Extracts _id from each document\nconst objectIds = getObjectIds(documents);     // Extracts _id/id and converts\n```\n\n** ALWAYS use these utilities instead of manual conversion:**\n\n```typescript\n//  CORRECT: Use utility functions\nimport { getStringIds, getObjectIds } from '@lenne.tech/nest-server';\n\n// For arrays of objects (no mapping needed - IDs are extracted automatically!)\nconst stringIds = getStringIds(documents);\nconst objectIds = getObjectIds(users);\n\n// For single values (no array needed!)\nconst objectId = getObjectIds(userId);\nconst stringId = getStringIds(document);\n\n//  WRONG: Manual conversion\nconst stringIds = documents.map(d => d._id.toString());\nconst objectIds = inputIds.map(id => new ObjectId(id));\nconst objectId = new ObjectId(userId);\n```\n\n**Why use these utilities:**\n- Consistent behavior across the codebase\n- Works with both arrays and single values\n- Extracts IDs from objects automatically (no `.map()` needed)\n- Handles edge cases (null, undefined, invalid IDs)\n- Type-safe conversions\n- Easier to maintain and test\n\n## Security Testing Checklist\n\n```typescript\n//  Create users with correct roles using TestHelper\nconst userSignUp = await testHelper.graphQl({\n  arguments: {\n    input: {\n      email: 'user@test.com',\n      password: 'password123',\n      firstName: 'Test',\n    },\n  },\n  fields: ['token', { user: ['id'] }],\n  name: 'signUp',\n  type: TestGraphQLType.MUTATION,\n});\nconst userToken = userSignUp.token;\n\n//  Test with correct role\nawait testHelper.rest('/api/resource', {\n  token: userToken,\n});\n\n//  Test without authentication\nawait testHelper.rest('/api/resource', {\n  statusCode: 401,\n});\n\n//  Test with insufficient permissions\nawait testHelper.rest('/api/admin/resource', {\n  statusCode: 403,\n  token: userToken, // Normal user trying admin endpoint\n});\n\n//  Test access to own resources only\nawait testHelper.rest(`/api/users/${userSignUp.user.id}/profile`, {\n  method: 'PUT',\n  payload: { firstName: 'Updated' },\n  token: userToken,\n});\n\nawait testHelper.rest(`/api/users/${otherUserId}/profile`, {\n  method: 'PUT',\n  payload: { firstName: 'Hacker' },\n  statusCode: 403,\n  token: userToken,\n});\n\n//  NEVER do this\n// Don't remove @Restricted decorators\n// Don't change @Roles to more permissive\n// Don't disable security checks\n```\n\n## When to Ask Developer\n\n```\n‚ùì ASK when:\n- Story has contradictions or ambiguities\n- Need to change security decorators\n- Need to add new npm package\n- Multiple valid architectural approaches\n- Tests keep failing for unclear reasons\n\n DON'T ASK when:\n- Creating test files\n- Running tests\n- Analyzing failures\n- Implementing obvious features\n- Using nest-server-generator\n```\n\n## Debugging Failed Tests\n\nWhen tests fail, use these debugging tools to analyze the issue:\n\n### 1. TestHelper Logging Options\n\n```typescript\n// Enable detailed request/response logging\nconst result = await testHelper.graphQl({\n  arguments: { id: userId },\n  fields: ['id', 'email'],\n  name: 'getUser',\n  type: TestGraphQLType.QUERY,\n}, {\n  token: userToken,\n  log: true,        // Logs request details\n  logError: true,   // Logs errors when status >= 400\n});\n\n// For REST requests\nconst result = await testHelper.rest('/api/endpoint', {\n  method: 'POST',\n  payload: data,\n  token: userToken,\n  log: true,\n  logError: true,\n});\n```\n\n### 2. Server Exception Logging\n\nEnable in `src/config.env.ts`:\n\n```typescript\nexport default {\n  // ... other config\n  logExceptions: true,  // Log all exceptions with stack traces\n  // ...\n};\n```\n\n### 3. Validation Debug Logging\n\nEnable validation debugging via environment variable:\n\n```bash\n# In your terminal or test script\nDEBUG_VALIDATION=true npm test\n\n# Or in your test file\nprocess.env.DEBUG_VALIDATION = 'true';\n```\n\nThis activates console.debug statements in MapAndValidatePipe (automatically activated via CoreModule - see `node_modules/@lenne.tech/nest-server/src/core/common/pipes/map-and-validate.pipe.ts`) to show detailed validation errors.\n\n### 4. Combined Debugging Setup\n\nFor comprehensive debugging, combine all three:\n\n```typescript\n// In your test file beforeAll\nprocess.env.DEBUG_VALIDATION = 'true';\n\n// In src/config.env.ts\nexport default {\n  logExceptions: true,\n  // ...\n};\n\n// In your tests\nconst result = await testHelper.graphQl({\n  // ... your test\n}, {\n  log: true,\n  logError: true,\n});\n```\n\n## Decision Tree: Test Failure Analysis\n\n```\nTest fails\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Missing implementation?\n    ‚îÇ       ‚îî‚îÄ‚ñ∫ Go to Step 4 (Implement)\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Test has bugs/errors?\n    ‚îÇ       ‚îî‚îÄ‚ñ∫ Go to Step 3a (Fix test)\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Security blocking correctly?\n    ‚îÇ       ‚îî‚îÄ‚ñ∫ Fix test to use proper auth\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Unclear error message?\n    ‚îÇ       ‚îî‚îÄ‚ñ∫ Enable debugging (log, logError, logExceptions, DEBUG_VALIDATION)\n    ‚îÇ\n    ‚îî‚îÄ‚ñ∫ Still unclear why failing?\n            ‚îî‚îÄ‚ñ∫ Ask developer\n```\n\n## Code Quality, Security & Refactoring Check\n\n### Quick Review Guide\n\n**Before marking complete, check for:**\n\n1. **Code Duplication:**\n   - Repeated validation logic -> Extract to private method\n   - Similar calculations in multiple places -> Create helper function\n   - Duplicated query patterns -> Consolidate into flexible method\n\n2. **Common Functionality:**\n   - Extract repeated data transformations\n   - Create shared validation helpers\n   - Consolidate similar query builders\n\n2a. ** Guards in Controllers:**\n   - DO NOT add `@UseGuards(AuthGuard(AuthGuardStrategy.JWT))` manually\n   - `@Roles()` decorator automatically activates JWT authentication\n   - `@Restricted()` decorator also activates guards automatically\n   - Manual guards are redundant and create duplicates\n   ```typescript\n   //  CORRECT\n   @Roles(RoleEnum.ADMIN)\n   @Get()\n   async findAll() { ... }\n\n   //  WRONG: Redundant guard\n   @UseGuards(AuthGuard(AuthGuardStrategy.JWT))\n   @Roles(RoleEnum.ADMIN)\n   @Get()\n   async findAll() { ... }\n   ```\n\n3. **Database Indexes:**\n   - Fields used in queries -> Add `mongoose: { index: true, type: String }` to @UnifiedField\n   - Foreign keys -> Add index via mongoose option\n   - Unique fields -> Add `mongoose: { index: true, unique: true, type: String }`\n   - Multiple query fields -> Index each individually\n\n4. ** Security Review (CRITICAL):**\n   - @Restricted/@Roles decorators NOT removed or weakened\n   - Ownership checks in place for user data\n   - All inputs validated with DTOs\n   - Sensitive fields marked with `hideField: true`\n   - No injection vulnerabilities\n   - Error messages don't leak sensitive data\n   - Authorization tests pass\n\n5. **Refactoring Decision:**\n   ```\n   Used in 2+ places? -> Extract to private method\n   Used across services? -> Consider utility class\n   Only 1 usage? -> Leave as-is (don't over-engineer)\n   ```\n\n6. **After Refactoring & Security Review:**\n   ```bash\n   npm test  # MUST still pass!\n   ```\n\n### Code Quality Checklist\n\nBefore marking complete:\n\n- [ ] All tests passing\n- [ ] **No obvious code duplication**\n- [ ] **Common functionality extracted to helpers**\n- [ ] **Consistent patterns throughout**\n- [ ] **Database indexes added to @UnifiedField decorators**\n- [ ] **Indexes match query patterns in services**\n- [ ] Test coverage adequate (80%+)\n- [ ] Code follows existing patterns\n- [ ] No unnecessary dependencies added\n- [ ] Proper error handling\n- [ ] Input validation implemented\n- [ ] Documentation/comments where needed\n- [ ] **Tests still pass after refactoring**\n\n** Security Checklist:**\n\n- [ ] **@Restricted/@Roles decorators NOT removed or weakened**\n- [ ] **Ownership checks in place (users can only access own data)**\n- [ ] **All inputs validated with proper DTOs**\n- [ ] **Sensitive fields marked with hideField: true**\n- [ ] **No SQL/NoSQL injection vulnerabilities**\n- [ ] **Error messages don't expose sensitive data**\n- [ ] **checkSecurity methods implemented in models**\n- [ ] **Authorization tests pass**\n- [ ] **No hardcoded secrets or credentials**\n\n## Final Report Template\n\n```markdown\n# Story Implementation Complete \n\n## Story: [Name]\n\n### Tests Created\n- Location: tests/stories/[filename].story.test.ts\n- Test cases: X scenarios\n- Coverage: X%\n\n### Implementation Summary\n- Modules: [list]\n- Objects: [list]\n- Properties: [list]\n- Other: [list]\n\n### Test Results\n All X tests passing\n\n### Code Quality\n- Patterns followed: \n- Security preserved: \n- Dependencies: None added \n- Code duplication checked: \n- Database indexes added: \n- Refactoring performed: [Yes/No]\n\n### Security Review\n- Authentication/Authorization: \n- Input validation: \n- Data exposure prevented: \n- Ownership checks: \n- Injection prevention: \n- Authorization tests pass: \n\n### Refactoring (if performed)\n- Extracted helper functions: [list]\n- Consolidated code paths: [describe]\n- Removed duplication: [describe]\n- Tests still passing: \n\n### Files Modified\n1. path/to/file.ts - description\n2. path/to/file.ts - description\n```\n\n##  Handling Existing Tests\n\n**When your changes break existing tests:**\n\n### Decision Tree\n\n```\nExisting test fails\n    ‚îú‚îÄ‚ñ∫ Intentional breaking change? (e.g., added required field)\n    ‚îÇ   ‚îî‚îÄ‚ñ∫  Update test to match new behavior\n    ‚îÇ\n    ‚îî‚îÄ‚ñ∫ Unclear/unintended side effect?\n        ‚îú‚îÄ‚ñ∫  Use git to investigate:\n        ‚îÇ   - git show HEAD:path/to/file.ts\n        ‚îÇ   - git diff HEAD path/to/file.ts\n        ‚îÇ\n        ‚îî‚îÄ‚ñ∫  Fix code to satisfy BOTH old AND new tests\n```\n\n### Git Analysis (ALLOWED)\n\n```bash\n# View old version of file\ngit show HEAD:src/server/modules/user/user.service.ts\n\n# See what changed\ngit diff HEAD src/server/modules/user/user.service.ts\n\n# View commit history\ngit log -p --follow path/to/file.ts\n```\n\n### Guidelines\n\n** Update tests when:**\n- Intentional API contract change\n- Removed deprecated functionality\n- Renamed fields/methods\n- Documented in story requirements\n\n** Don't update tests when:**\n- Unclear why they're failing\n- Unrelated to your story\n- Multiple unrelated tests breaking\n- Testing important existing functionality\n\n**üö© Red flags (investigate, don't update):**\n- Tests in different modules failing\n- Security/auth tests failing\n- 3+ unrelated tests failing\n\n**Remember:**\n- Existing tests = documentation of expected behavior\n- Use git freely for investigation (NOT commits!)\n- When in doubt, preserve backward compatibility\n\n##  CRITICAL: Git Commits\n\n** NEVER create git commits unless explicitly requested by the developer.**\n\n-  DO NOT use `git add`, `git commit`, or `git push` automatically\n-  DO NOT commit changes when tests pass\n-  DO NOT assume developer wants changes committed\n-  ONLY commit when developer explicitly asks: \"commit these changes\"\n\n**Why:** Developers may want to review changes, commit in specific chunks, or have custom workflows.\n\n**Your job:**\n-  Create/modify files\n-  Run tests\n-  Use git for analysis (git show, git diff, git log)\n-  Provide comprehensive report\n-  Never commit to git (unless explicitly requested)\n\n##  CRITICAL: Database Cleanup & Test Isolation\n\n**ALWAYS implement comprehensive cleanup in your story tests!**\n\nTests run in parallel, so improper test data management causes:\n- Conflicts between parallel tests (duplicate keys, race conditions)\n- False positives/negatives in tests\n- Flaky tests that pass/fail randomly\n- Contaminated test database\n- Hard-to-debug test failures\n\n** GOLDEN RULES for Parallel-Safe Test Data:**\n\n1. **Email Addresses Must End with @test.com**\n   - Configuration in `src/config.env.ts` uses `e2e.brevo.exclude` to filter @test.com\n   - External services (email, etc.) will exclude these addresses\n   - Use timestamp + random suffix for guaranteed uniqueness\n   ```typescript\n   //  CORRECT: Timestamp + 6-char random suffix\n   const email = `user-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`;\n\n   //  LESS SAFE: Only timestamp (collision risk in same millisecond)\n   const email = `user-${Date.now()}@test.com`;\n\n   //  WRONG: No @test.com suffix\n   const email = 'testuser@example.com';\n   ```\n\n2. **NEVER Reuse Same Data Across Test Files**\n   - Tests run in parallel = same data causes conflicts\n   - Make ALL data unique (emails, usernames, product names, etc.)\n   - Always use timestamp + random suffix\n   ```typescript\n   //  CORRECT: Unique per test file with timestamp + random suffix\n   const email = `admin-product-test-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`;\n\n   //  LESS SAFE: Only timestamp\n   const email = `admin-product-test-${Date.now()}@test.com`;\n\n   //  WRONG: Reused across multiple test files\n   const email = 'admin@test.com';\n   ```\n\n3. **ONLY Delete Entities Created in This Test File**\n   - Track created IDs explicitly\n   - Delete ONLY tracked entities, not by pattern\n   ```typescript\n   //  CORRECT: Only delete what we created\n   await db.collection('users').deleteMany({\n     _id: { $in: createdUserIds.map(id => new ObjectId(id)) }\n   });\n\n   //  WRONG: Deletes ALL test users (breaks parallel tests)\n   await db.collection('users').deleteMany({ email: /@test\\.com$/ });\n   ```\n\n4. **ALL Created Entities Must Be Cleaned Up**\n   - Track every created entity ID immediately\n   - Clean up in correct order (children before parents)\n   - Prevents side effects on future test runs\n\n5. **NEVER Use Fixed Port Numbers**\n   - NestJS assigns random ports automatically for parallel execution\n   - Always use TestHelper - it abstracts port handling\n   ```typescript\n   //  CORRECT: No port specified, TestHelper handles it\n   await app.init();\n   const result = await testHelper.rest('/api/users', { ... });\n\n   //  WRONG: Fixed port causes conflicts\n   await app.listen(3000);\n   const response = await fetch('http://localhost:3000/api/users');\n   ```\n\n### Between Test Suites - RECOMMENDED APPROACH\n\n**Track all created entities and delete them explicitly:**\n\n```typescript\ndescribe('Feature Story', () => {\n  // Track created entities\n  let createdUserIds: string[] = [];\n  let createdProductIds: string[] = [];\n  let createdOrderIds: string[] = [];\n\n  // In your tests, track IDs immediately after creation\n  it('should create product', async () => {\n    //  IMPORTANT: Use unique data per test file + @test.com for emails\n    const productData = {\n      name: `Product-FeatureStory-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`,  //  Unique per test file\n      ownerEmail: `owner-feature-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`,  //  @test.com + unique\n    };\n\n    const product = await testHelper.rest('/api/products', {\n      method: 'POST',\n      payload: productData,\n      token: adminToken,\n    });\n\n    //  Track for cleanup (ONLY delete what we created)\n    createdProductIds.push(product.id);\n  });\n\n  afterAll(async () => {\n    // üßπ CLEANUP: Delete ALL test data created during tests\n    try {\n      // Delete in correct order (child entities first)\n      if (createdOrderIds.length > 0) {\n        await db.collection('orders').deleteMany({\n          _id: { $in: createdOrderIds.map(id => new ObjectId(id)) }\n        });\n      }\n\n      if (createdProductIds.length > 0) {\n        await db.collection('products').deleteMany({\n          _id: { $in: createdProductIds.map(id => new ObjectId(id)) }\n        });\n      }\n\n      if (createdUserIds.length > 0) {\n        await db.collection('users').deleteMany({\n          _id: { $in: createdUserIds.map(id => new ObjectId(id)) }\n        });\n      }\n    } catch (error) {\n      console.error('Cleanup failed:', error);\n      // Don't throw - cleanup failures shouldn't fail the test suite\n    }\n\n    await connection.close();\n    await app.close();\n  });\n});\n```\n\n### Alternative: Pattern-Based Cleanup (AVOID - Not Parallel-Safe!)\n\n** DO NOT USE pattern-based cleanup - it breaks parallel test execution!**\n\n```typescript\n//  WRONG: Deletes ALL test users, even from parallel tests!\nafterAll(async () => {\n  await db.collection('users').deleteMany({ email: /@test\\.com$/ });\n  await db.collection('products').deleteMany({ name: /^Test/ });\n\n  await connection.close();\n  await app.close();\n});\n```\n\n** Why This is Dangerous:**\n- **Breaks parallel tests:** Deletes entities from other tests that are still running\n- **Race conditions:** Unpredictable failures when tests run simultaneously\n- **Flaky tests:** Tests pass/fail randomly depending on execution order\n- **Hard to debug:** Unclear why tests fail intermittently\n\n** ALWAYS use ID-based cleanup instead:**\n```typescript\n//  CORRECT: Only deletes entities created in THIS test file\nif (createdUserIds.length > 0) {\n  await db.collection('users').deleteMany({\n    _id: { $in: createdUserIds.map(id => new ObjectId(id)) }\n  });\n}\n```\n\n### Between Individual Tests\n\nUse `beforeEach`/`afterEach` only when necessary:\n\n```typescript\ndescribe('Feature Tests', () => {\n  let sharedResource;\n\n  beforeEach(async () => {\n    // Reset state before each test if needed\n    sharedResource = await createFreshResource();\n  });\n\n  afterEach(async () => {\n    // Clean up after each test if needed\n    await deleteResource(sharedResource.id);\n  });\n});\n```\n\n## User Authentication: signUp vs signIn\n\n### When to use signUp\n\n- Creating new users in tests\n- Full control over user data needed\n- Testing user registration flows\n- Most common in story tests\n\n```typescript\nconst signUp = await testHelper.graphQl({\n  arguments: {\n    input: {\n      //  CRITICAL: MUST end with @test.com for e2e.brevo.exclude\n      // Use timestamp + random suffix for guaranteed uniqueness\n      email: `test-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`,  //  Unique + @test.com\n      password: 'testpass123',\n      firstName: 'Test',\n    },\n  },\n  fields: ['token', { user: ['id', 'email'] }],\n  name: 'signUp',\n  type: TestGraphQLType.MUTATION,\n});\nconst token = signUp.token;\n\n//  Track for cleanup\ncreatedUserIds.push(signUp.user.id);\n```\n\n### When to use signIn\n\n- Authenticating existing users\n- User already exists in database\n- Testing login flows\n\n```typescript\nconst signIn = await testHelper.rest('/auth/signin', {\n  method: 'POST',\n  payload: {\n    email: existingUserEmail,\n    password: existingUserPassword,\n  },\n});\nconst token = signIn.token;\n```\n\n## Avoiding Test Interdependencies\n\n###  DON'T: Shared state between tests\n\n```typescript\n//  BAD: Test 2 depends on Test 1\nlet createdUserId;\n\nit('should create user', async () => {\n  const user = await createUser(...);\n  createdUserId = user.id;  //  Shared state!\n});\n\nit('should update user', async () => {\n  await updateUser(createdUserId, ...);  //  Depends on Test 1!\n});\n```\n\n###  DO: Independent tests\n\n```typescript\n//  GOOD: Each test is independent\ndescribe('User CRUD', () => {\n  let testUserId;\n\n  beforeEach(async () => {\n    // Create fresh user for EACH test\n    const user = await createUser(...);\n    testUserId = user.id;\n  });\n\n  afterEach(async () => {\n    // Clean up after each test\n    await deleteUser(testUserId);\n  });\n\n  it('should update user', async () => {\n    await updateUser(testUserId, ...);  //  Independent!\n  });\n\n  it('should delete user', async () => {\n    await deleteUser(testUserId, ...);  //  Independent!\n  });\n});\n```\n\n## Async/Await Best Practices\n\n### Always await async operations\n\n```typescript\n//  WRONG: Forgotten await\nconst user = testHelper.graphQl({...});  // Returns Promise, not user!\nexpect(user.email).toBe('test@example.com');  // FAILS!\n\n//  CORRECT: With await\nconst user = await testHelper.graphQl({...});\nexpect(user.email).toBe('test@example.com');  // Works!\n```\n\n### Parallel vs Sequential execution\n\n```typescript\n//  Parallel execution (independent operations)\nconst [user1, user2, product] = await Promise.all([\n  testHelper.graphQl({...}),  // Create user 1\n  testHelper.graphQl({...}),  // Create user 2\n  testHelper.rest('/api/products', {...}),  // Create product\n]);\n\n//  Sequential execution (dependent operations)\nconst user = await testHelper.graphQl({...});\nconst product = await testHelper.rest('/api/products', {\n  token: user.token,  // Depends on user being created first\n  payload: {...},\n  method: 'POST',\n});\n\n//  WRONG: Sequential when parallel is possible (slower)\nconst user1 = await testHelper.graphQl({...});\nconst user2 = await testHelper.graphQl({...});  // Could run in parallel!\nconst product = await testHelper.rest('/api/products', {...});\n```\n\n### Handling errors with async/await\n\n```typescript\n// Test that async operation throws error\nawait expect(async () => {\n  await testHelper.rest('/api/resource', {\n    payload: invalidData,\n    token: userToken,\n  });\n}).rejects.toThrow();\n\n// Or use statusCode option\nawait testHelper.rest('/api/resource', {\n  payload: invalidData,\n  statusCode: 400,\n  token: userToken,\n});\n```\n\n## Common Pitfalls to Avoid\n\n **Don't:**\n- Write code before tests\n- Skip test analysis step\n- **Weaken security for passing tests**\n- **Remove or weaken @Restricted/@Roles decorators**\n- **Add @UseGuards(AuthGuard(...)) manually (redundant with @Roles)**\n- **Skip security review before marking complete**\n- Add dependencies without checking existing\n- Ignore existing code patterns\n- Batch test completions (mark complete immediately)\n- Work on multiple tasks simultaneously\n- **Create git commits without explicit request**\n- Forget `await` on async calls\n- Create test interdependencies\n- **Forget to implement cleanup in afterAll**\n- **Forget to track created entity IDs for cleanup**\n- **Use pattern-based cleanup (deletes entities from parallel tests!)**\n- **Reuse same test data across test files (causes parallel conflicts)**\n- **Use emails without @test.com suffix (won't be excluded from external services)**\n- **Use fixed port numbers (breaks parallel test execution)**\n- Clean up too aggressively (breaking other tests)\n- **Skip code quality check before marking complete**\n- **Leave obvious code duplication in place**\n- Over-engineer by extracting single-use code\n- **Define indexes separately in schema files**\n- **Forget to add indexes for queried fields**\n- Add indexes to fields that are never queried\n- **Expose sensitive fields without hideField**\n- **Allow users to access others' data without checks**\n- **Use 'any' type instead of proper DTOs**\n\n **Do:**\n- Follow the 7-step process strictly (including Step 5a security & refactoring check)\n- Ask for clarification early\n- **Preserve all security mechanisms (CRITICAL)**\n- **Perform security review before marking complete**\n- Study existing code first\n- Match existing patterns\n- Mark todos complete as you finish them\n- Focus on one step at a time\n- **Wait for developer to commit changes**\n- Always use `await` with async operations\n- Make tests independent\n- Use `beforeEach`/`afterEach` for test isolation\n- Use Promise.all() for parallel operations\n- **ALWAYS implement comprehensive cleanup in afterAll**\n- **Track all created entity IDs immediately after creation**\n- **ONLY delete entities created in THIS test file (parallel-safe)**\n- **Use @test.com suffix for ALL test emails (e2e.brevo.exclude)**\n- **Make ALL test data unique per test file (avoid parallel conflicts)**\n- **NEVER use fixed ports - let NestJS assign random ports automatically**\n- **Always use TestHelper for API calls (handles ports automatically)**\n- Delete entities in correct order (children before parents)\n- **Check for code duplication before marking complete**\n- **Extract common functionality to helpers when used 2+ times**\n- **Run tests again after refactoring**\n- **Verify ownership checks for user data access**\n- **Mark sensitive fields with hideField: true**\n- **Use proper DTOs with validation decorators**\n- **Ensure authorization tests pass**\n\n## Integration Points\n\n### With nest-server-generator\n- Use for creating modules, objects, properties\n- Use for understanding NestJS patterns\n- Use for reading CrudService implementations\n\n### With Existing Tests\n- Study patterns in test/ directory\n- Copy authentication setup approach\n- Use same helper functions\n- Match assertion style\n\n### With API Documentation\n- Check Controllers for REST endpoints\n- Review Swagger annotations\n- Understand existing data models\n- Verify GraphQL schema if applicable\n\n---\n\n**Remember:** Tests first, code second. Iterate until green. **Security review mandatory.** Refactor before done. Quality over speed.",
        "plugins/lt-dev/skills/building-stories-with-tdd/security-review.md": "---\nname: story-tdd-security-review\ndescription: Security review checklist for Test-Driven Development - ensures no vulnerabilities are introduced\n---\n\n#  Security Review Checklist\n\n## Table of Contents\n- [Security Checklist](#security-checklist)\n- [Security Decision Tree](#security-decision-tree)\n- [Red Flags - STOP and Review](#red-flags---stop-and-review)\n- [If ANY Red Flag Found](#if-any-red-flag-found)\n- [Remember](#remember)\n- [Quick Security Checklist](#quick-security-checklist)\n\n**CRITICAL: Perform security review before final testing!**\n\n**ALWAYS review all code changes for security vulnerabilities before marking complete.**\n\nSecurity issues can be introduced during implementation without realizing it. A systematic review prevents:\n- Unauthorized access to data\n- Privilege escalation\n- Data leaks\n- Injection attacks\n- Authentication bypasses\n\n---\n\n## Security Checklist\n\n### 1. Authentication & Authorization\n\n **Check decorators are NOT weakened:**\n\n```typescript\n//  WRONG: Removing security to make tests pass\n// OLD:\n@Restricted(RoleEnum.ADMIN)\nasync deleteUser(id: string) { ... }\n\n// NEW (DANGEROUS):\nasync deleteUser(id: string) { ... }  //  No restriction!\n\n//  CORRECT: Keep or strengthen security\n@Restricted(RoleEnum.ADMIN)\nasync deleteUser(id: string) { ... }\n```\n\n **Verify @Roles decorators:**\n\n```typescript\n//  WRONG: Making endpoint too permissive\n@Roles(RoleEnum.S_USER)  // Everyone can delete!\nasync deleteOrder(id: string) { ... }\n\n//  CORRECT: Proper role restriction\n@Roles(RoleEnum.ADMIN)  // Only admins can delete\nasync deleteOrder(id: string) { ... }\n```\n\n **Check ownership verification:**\n\n```typescript\n//  WRONG: No ownership check\nasync updateProfile(userId: string, data: UpdateProfileInput, currentUser: User) {\n  return this.userService.update(userId, data);  // Any user can update any profile!\n}\n\n//  CORRECT: Verify ownership or admin role\nasync updateProfile(userId: string, data: UpdateProfileInput, currentUser: User) {\n  // Check if user is updating their own profile or is admin\n  if (userId !== currentUser.id && !currentUser.roles.includes(RoleEnum.ADMIN)) {\n    throw new ForbiddenException('Cannot update other users');\n  }\n  return this.userService.update(userId, data);\n}\n```\n\n### 2. Input Validation\n\n **Verify all inputs are validated:**\n\n```typescript\n//  WRONG: No validation\nasync createProduct(input: any) {\n  return this.productService.create(input);  // Dangerous!\n}\n\n//  CORRECT: Proper DTO with validation\nexport class CreateProductInput {\n  @UnifiedField({\n    description: 'Product name',\n    isOptional: false,\n    mongoose: { type: String, required: true, minlength: 1, maxlength: 100 }\n  })\n  name: string;\n\n  @UnifiedField({\n    description: 'Price',\n    isOptional: false,\n    mongoose: { type: Number, required: true, min: 0 }\n  })\n  price: number;\n}\n```\n\n **Check for injection vulnerabilities:**\n\n```typescript\n//  WRONG: Direct string interpolation in queries\nasync findByName(name: string) {\n  return this.productModel.find({ $where: `this.name === '${name}'` });  // SQL Injection!\n}\n\n//  CORRECT: Parameterized queries\nasync findByName(name: string) {\n  return this.productModel.find({ name });  // Safe\n}\n```\n\n### 3. Data Exposure\n\n **Verify sensitive data is protected:**\n\n```typescript\n//  WRONG: Exposing passwords\nexport class User {\n  @UnifiedField({ description: 'Email' })\n  email: string;\n\n  @UnifiedField({ description: 'Password' })\n  password: string;  //  Will be exposed in API!\n}\n\n//  CORRECT: Hide sensitive fields\nexport class User {\n  @UnifiedField({ description: 'Email' })\n  email: string;\n\n  @UnifiedField({\n    description: 'Password hash',\n    hideField: true,  //  Never expose in API\n    mongoose: { type: String, required: true }\n  })\n  password: string;\n}\n```\n\n **Check error messages don't leak data:**\n\n```typescript\n//  WRONG: Exposing sensitive info in errors\ncatch (error) {\n  throw new BadRequestException(`Query failed: ${error.message}, SQL: ${query}`);\n}\n\n//  CORRECT: Generic error messages\ncatch (error) {\n  this.logger.error(`Query failed: ${error.message}`, error.stack);\n  throw new BadRequestException('Invalid request');\n}\n```\n\n### 4. Authorization in Services\n\n **Verify service methods check permissions:**\n\n```typescript\n//  WRONG: Service doesn't check who can access\nasync getOrder(orderId: string) {\n  return this.orderModel.findById(orderId);  // Anyone can see any order!\n}\n\n//  CORRECT: Service checks ownership or role\nasync getOrder(orderId: string, currentUser: User) {\n  const order = await this.orderModel.findById(orderId);\n\n  // Check if user owns the order or is admin\n  if (order.customerId !== currentUser.id && !currentUser.roles.includes(RoleEnum.ADMIN)) {\n    throw new ForbiddenException('Access denied');\n  }\n\n  return order;\n}\n```\n\n### 5. Security Model Checks\n\n **Verify checkSecurity methods:**\n\n```typescript\n// In model file\nasync checkSecurity(user: User, mode: SecurityMode): Promise<void> {\n  //  WRONG: No security check\n  return;\n\n  //  CORRECT: Proper security implementation\n  if (mode === SecurityMode.CREATE && !user.roles.includes(RoleEnum.ADMIN)) {\n    throw new ForbiddenException('Only admins can create');\n  }\n\n  if (mode === SecurityMode.UPDATE && this.createdBy !== user.id && !user.roles.includes(RoleEnum.ADMIN)) {\n    throw new ForbiddenException('Can only update own items');\n  }\n}\n```\n\n### 6. Cross-Cutting Concerns\n\n **Rate limiting for sensitive endpoints:**\n- Password reset endpoints\n- Authentication endpoints\n- Payment processing\n- Email sending\n\n **HTTPS/TLS enforcement (production)**\n\n **Proper CORS configuration**\n\n **No hardcoded secrets or API keys**\n\n---\n\n## Security Decision Tree\n\n```\nCode changes made?\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Modified @Restricted or @Roles?\n    ‚îÇ   ‚îî‚îÄ‚ñ∫  CRITICAL: Verify this was intentional and justified\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ New endpoint added?\n    ‚îÇ   ‚îî‚îÄ‚ñ∫  Ensure proper authentication + authorization decorators\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Service method modified?\n    ‚îÇ   ‚îî‚îÄ‚ñ∫  Verify ownership checks still in place\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ New input/query parameters?\n    ‚îÇ   ‚îî‚îÄ‚ñ∫  Ensure validation and sanitization\n    ‚îÇ\n    ‚îî‚îÄ‚ñ∫ Sensitive data accessed?\n        ‚îî‚îÄ‚ñ∫  Verify access control and data hiding\n```\n\n---\n\n## Red Flags - STOP and Review\n\nüö© **Authentication/Authorization:**\n- @Restricted decorator removed or changed\n- @Roles changed to more permissive role\n- Endpoints without authentication\n- Missing ownership checks\n\nüö© **Data Security:**\n- Sensitive fields not marked with hideField\n- Password or token fields exposed\n- User data accessible without permission check\n- Error messages revealing internal details\n\nüö© **Input Validation:**\n- Missing validation decorators\n- Any type used instead of DTO\n- Direct use of user input in queries\n- No sanitization of string inputs\n\nüö© **Business Logic:**\n- Bypassing security checks \"for convenience\"\n- Commented out authorization code\n- Admin-only actions available to regular users\n- Price/amount manipulation possible\n\n---\n\n## If ANY Red Flag Found\n\n1. **STOP implementation**\n2. **Fix the security issue immediately**\n3. **Review surrounding code for similar issues**\n4. **Re-run security checklist**\n5. **Update tests to verify security works**\n\n---\n\n## Remember\n\n- **Security > Convenience**\n- **Better to over-restrict than under-restrict**\n- **Always preserve existing security mechanisms**\n- **When in doubt, ask the developer**\n\n---\n\n### 7. Error Handling & Logging\n\n **Secure Error Responses:**\n\n```typescript\n//  WRONG: Exposing stack traces and internal details\ncatch (error) {\n  throw new InternalServerErrorException({\n    message: error.message,\n    stack: error.stack,\n    query: queryString,\n    dbConnection: this.connectionString\n  });\n}\n\n//  CORRECT: Generic errors with internal logging\ncatch (error) {\n  this.logger.error('Database query failed', {\n    error: error.message,\n    stack: error.stack,\n    userId: currentUser?.id,\n    operation: 'findUser'\n  });\n  throw new InternalServerErrorException('An error occurred processing your request');\n}\n```\n\n **Logging Best Practices:**\n\n```typescript\n// DO: Log security-relevant events\nthis.logger.warn('Failed login attempt', { email, ip, userAgent });\nthis.logger.info('User role changed', { userId, oldRole, newRole, changedBy });\nthis.logger.error('Unauthorized access attempt', { userId, resource, ip });\n\n// DON'T: Log sensitive data\nthis.logger.info('User login', { email, password }); //  NEVER log passwords!\nthis.logger.debug('Request data', { creditCard, ssn }); //  NEVER log PII!\n```\n\n **Checklist:**\n- [ ] No stack traces in production responses\n- [ ] Security events logged (login, logout, role changes, access denied)\n- [ ] No passwords, tokens, or PII in logs\n- [ ] Log levels appropriate (error for failures, warn for suspicious activity)\n\n---\n\n### 8. Cryptographic Practices\n\n **Password Hashing (bcrypt):**\n\n```typescript\n//  WRONG: Plain text or weak hashing\nuser.password = password;  // Plain text!\nuser.password = crypto.createHash('md5').update(password).digest('hex');  // MD5 is broken!\n\n//  CORRECT: bcrypt with proper cost factor\nimport * as bcrypt from 'bcrypt';\n\nconst SALT_ROUNDS = 12;  // Minimum 10, recommended 12+\n\nasync hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, SALT_ROUNDS);\n}\n\nasync verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}\n```\n\n **Secure Random Generation:**\n\n```typescript\n//  WRONG: Math.random() for security purposes\nconst resetToken = Math.random().toString(36);  // Predictable!\n\n//  CORRECT: Cryptographically secure random\nimport { randomBytes, randomUUID } from 'crypto';\n\nconst resetToken = randomBytes(32).toString('hex');  // 256-bit token\nconst apiKey = randomUUID();  // UUID v4\n```\n\n **Key Management:**\n\n```typescript\n//  WRONG: Hardcoded secrets\nconst JWT_SECRET = 'my-super-secret-key';\n\n//  CORRECT: Environment variables\nconst JWT_SECRET = process.env.JWT_SECRET;\nif (!JWT_SECRET || JWT_SECRET.length < 32) {\n  throw new Error('JWT_SECRET must be at least 32 characters');\n}\n```\n\n **Checklist:**\n- [ ] Passwords hashed with bcrypt (cost factor ‚â• 10)\n- [ ] Cryptographic randomness used for tokens/keys\n- [ ] No secrets hardcoded (use environment variables)\n- [ ] JWT secrets sufficiently long (‚â• 256 bits)\n\n---\n\n### 9. Session & Token Management\n\n **JWT Best Practices:**\n\n```typescript\n//  WRONG: Long-lived access tokens, no refresh\nconst token = this.jwtService.sign(payload, { expiresIn: '30d' });  // Too long!\n\n//  CORRECT: Short access tokens + refresh tokens\nconst accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });\nconst refreshToken = this.jwtService.sign(\n  { userId: user.id, tokenType: 'refresh' },\n  { expiresIn: '7d' }\n);\n\n// Store refresh token hash in DB for revocation\nawait this.refreshTokenService.create({\n  userId: user.id,\n  tokenHash: await bcrypt.hash(refreshToken, 10),\n  expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)\n});\n```\n\n **Token Revocation:**\n\n```typescript\n// Implement token blacklist or family rotation\nasync logout(userId: string): Promise<void> {\n  // Invalidate all refresh tokens for user\n  await this.refreshTokenService.revokeAllForUser(userId);\n}\n\nasync refreshAccessToken(refreshToken: string): Promise<TokenPair> {\n  const payload = this.jwtService.verify(refreshToken);\n\n  // Check if token is revoked\n  const isValid = await this.refreshTokenService.validate(refreshToken);\n  if (!isValid) {\n    throw new UnauthorizedException('Token has been revoked');\n  }\n\n  // Rotate refresh token (issue new one, revoke old)\n  return this.issueTokenPair(payload.userId);\n}\n```\n\n **Cookie Security (if using cookies):**\n\n```typescript\n//  CORRECT: Secure cookie settings\nresponse.cookie('refreshToken', token, {\n  httpOnly: true,      // Prevents XSS access\n  secure: true,        // HTTPS only\n  sameSite: 'strict',  // CSRF protection\n  maxAge: 7 * 24 * 60 * 60 * 1000,  // 7 days\n  path: '/auth/refresh'  // Limit scope\n});\n```\n\n **Checklist:**\n- [ ] Access tokens short-lived (‚â§ 15 minutes)\n- [ ] Refresh token rotation implemented\n- [ ] Token revocation mechanism exists (logout, password change)\n- [ ] Cookies use httpOnly, secure, sameSite flags\n- [ ] No tokens in URL parameters\n\n---\n\n## Quick Security Checklist\n\nBefore marking complete:\n\n**Authentication & Authorization:**\n- [ ] **@Restricted/@Roles decorators NOT removed or weakened**\n- [ ] **Ownership checks in place (users can only access own data)**\n- [ ] **checkSecurity methods implemented in models**\n- [ ] **Authorization tests pass**\n\n**Input & Data:**\n- [ ] **All inputs validated with proper DTOs**\n- [ ] **Sensitive fields marked with hideField: true**\n- [ ] **No SQL/NoSQL injection vulnerabilities**\n- [ ] **No hardcoded secrets or credentials**\n\n**Error Handling & Logging:**\n- [ ] **Error messages don't expose sensitive data**\n- [ ] **No stack traces in production responses**\n- [ ] **Security events logged appropriately**\n- [ ] **No passwords/tokens/PII in logs**\n\n**Cryptography & Tokens:**\n- [ ] **Passwords hashed with bcrypt (cost ‚â• 10)**\n- [ ] **Cryptographically secure random for tokens**\n- [ ] **JWT access tokens short-lived (‚â§ 15 min)**\n- [ ] **Token revocation mechanism implemented**\n",
        "plugins/lt-dev/skills/building-stories-with-tdd/workflow.md": "---\nname: story-tdd-workflow\ndescription: Complete 7-step TDD workflow with detailed implementation steps, testing guidelines, and validation process\n---\n\n# Story-Based TDD Workflow - The Seven Steps\n\n## Table of Contents\n- [Step 1: Story Analysis & Validation](#step-1-story-analysis--validation)\n- [Step 2: Create Story Test](#step-2-create-story-test)\n- [Step 3: Run Tests & Analyze Failures](#step-3-run-tests--analyze-failures)\n- [Step 3a: Fix Test Errors (if needed)](#step-3a-fix-test-errors-if-needed)\n- [Step 4: Implement/Extend API Code](#step-4-implementextend-api-code)\n- [Step 5: Validate & Iterate](#step-5-validate--iterate)\n- [Step 5a: Code Quality & Refactoring Check](#step-5a-code-quality--refactoring-check)\n- [Step 5b: Final Validation](#step-5b-final-validation)\n\nThis skill follows a rigorous 7-step iterative process (with Steps 5, 5a, 5b for final validation and refactoring):\n\n## Step 1: Story Analysis & Validation\n\n**Before writing ANY code or tests:**\n\n1. **Read and analyze the complete user story/requirement**\n   - Identify all functional requirements\n   - List all acceptance criteria\n   - Note any technical constraints\n\n2. ** VERIFY existing API structure - NEVER assume!**\n   - **Read actual Controller files** to verify endpoints exist:\n     - Check HTTP methods (GET, POST, PUT, DELETE)\n     - Verify exact endpoint paths (e.g., `/api/users` vs `/users`)\n     - Confirm request/response structures\n   - **Read actual Resolver files** for GraphQL:\n     - Verify mutation/query names exist\n     - Check input types and field names\n     - Confirm return types\n   - **Read existing test files** to understand patterns:\n     - How are endpoints called in practice?\n     - What authentication is used?\n     - What response structure is expected?\n   - **Document what EXISTS vs what NEEDS to be created:**\n     - Existing: `/api/products` GET, POST (verified in product.controller.ts:45)\n     - Missing: `/api/products/:id/reviews` POST (needs implementation)\n\n3. **Identify contradictions or ambiguities**\n   - Look for conflicting requirements\n   - Check for unclear specifications\n   - Verify if requirements match existing architecture\n   - **Verify assumed endpoints actually exist!**\n\n4. **Ask developer for clarification IMMEDIATELY if needed**\n   - Don't assume or guess requirements\n   - Don't assume endpoints exist without verification\n   - Clarify contradictions BEFORE writing tests\n   - Get confirmation on architectural decisions\n   - Verify security/permission requirements\n\n** CRITICAL:** If you find ANY contradictions or ambiguities, STOP and use AskUserQuestion to clarify BEFORE proceeding to Step 2.\n\n** CRITICAL:** If you assume an endpoint exists but didn't verify it in the code, you are doing it WRONG! Always read the actual controller/resolver files first.\n\n**Step 1 Checklist:**\n- [ ] Story completely read and understood\n- [ ] All functional requirements identified\n- [ ] All acceptance criteria listed\n- [ ] Existing API structure verified (Controllers/Resolvers read)\n- [ ] Documented what EXISTS vs what NEEDS creation\n- [ ] No contradictions or ambiguities (or clarified with developer)\n- [ ] Ready for Step 2\n\n## Step 2: Create Story Test\n\n** BEFORE Creating New Tests - Check Existing Tests First!**\n\n**CRITICAL:** Before writing ANY new test, verify that the functionality isn't already tested!\n\n1. **Search existing tests** in `tests/` directory:\n   - Look for tests covering the same endpoints/mutations\n   - Check if existing tests already validate the behavior\n   - Identify tests that might need updates due to story changes\n\n2. **If functionality is already tested:**\n   -  **DO NOT** create duplicate tests\n   -  **Extend** existing tests if new edge cases are needed\n   -  **Update** existing tests if the story changes expected behavior\n\n3. **If story changes require modifying existing tests:**\n   -  **ALWAYS inform the user** about which tests will be modified and why\n   -  **Only modify tests** when story requirements explicitly change the expected behavior\n   -  **NEVER modify tests just because they fail** - failing tests indicate bugs in implementation!\n\n** CRITICAL RULE: Tests Protect Against Unintended Side Effects!**\n\n```\nTest fails after your changes?\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Does the story EXPLICITLY require this behavior change?\n    ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îú‚îÄ‚ñ∫ YES (documented in story requirements):\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚ñ∫  Update the test AND inform the user:\n    ‚îÇ   ‚îÇ       \"Updating test X because story requires behavior Y\"\n    ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îî‚îÄ‚ñ∫ NO (not mentioned in story):\n    ‚îÇ       ‚îî‚îÄ‚ñ∫  DO NOT modify the test!\n    ‚îÇ           ‚îî‚îÄ‚ñ∫ Fix your implementation instead\n    ‚îÇ               (you introduced an unintended side effect)\n```\n\n**Example - WRONG approach:**\n```typescript\n// Test fails: \"expected status 200, got 401\"\n//  WRONG: Just change the expected status\nexpect(response.status).toBe(401); // Changed from 200 to make test pass\n```\n\n**Example - CORRECT approach:**\n```typescript\n// Test fails: \"expected status 200, got 401\"\n//  CORRECT: Investigate WHY it fails\n// -> Found: Missing authentication token in new implementation\n// -> Fix: Add proper authentication, keep test expecting 200\n```\n\n**When to inform user about test changes:**\n- \"Modifying `user-registration.story.test.ts` - story now requires email verification before login\"\n- \"Updating expected response in `product-search.test.ts` - story adds new `category` field to response\"\n- \"Adjusting test data in `order-processing.test.ts` - story changes minimum order amount from 10 to 20\"\n\n** For detailed guidance on handling failing tests, see: `handling-existing-tests.md`**\n\n---\n\n** CRITICAL: ALWAYS TEST THROUGH API - NEVER DIRECT SERVICE/DB ACCESS! **\n\n**FUNDAMENTAL RULE - Read This First:**\n\nTests MUST go through REST/GraphQL interfaces (Controller/Resolver) using TestHelper. Direct Service or Database access in test logic makes tests WORTHLESS because they bypass the actual API layer that users interact with.\n\n** ALWAYS DO:**\n-  Test via REST endpoints: `testHelper.rest('/api/users', { method: 'POST', ... })`\n-  Test via GraphQL: `testHelper.graphQl('mutation { createUser(...) }', { ... })`\n-  Use TestHelper for ALL functional testing\n-  Test the complete chain: Controller/Resolver -> Guards -> Service -> Database\n\n** NEVER DO:**\n-  Direct Service calls: `userService.create()` - bypasses authentication!\n-  Direct DB queries in tests: `db.collection('users').findOne()` - bypasses business logic!\n-  Service instantiation: `new UserService()` - bypasses dependency injection!\n-  Mocking Controllers or Resolvers - defeats the purpose!\n\n**Why This Rule Is Absolute:**\n- **Security:** Direct Service access bypasses authentication, authorization, guards, decorators\n- **Reality:** Tests must verify what actual users experience through the API\n- **Business Logic:** Services might have additional validation that gets bypassed\n- **Worthless Tests:** Tests that bypass the API cannot catch real bugs\n\n** RARE Exceptions - Only for Test Setup/Cleanup (NOT for testing functionality):**\n\nDirect database access is ONLY allowed in these specific cases:\n\n** Allowed in beforeAll/beforeEach/afterAll/afterEach:**\n- Setting user roles: `await db.collection('users').updateOne({ _id: userId }, { $set: { roles: ['admin'] } })`\n- Setting verified status: `await db.collection('users').updateOne({ _id: userId }, { $set: { verified: true } })`\n- Cleanup: `await db.collection('products').deleteMany({ createdBy: testUserId })`\n- Read-only verification when NO API endpoint exists: `const count = await db.collection('logs').countDocuments()`\n\n** Ask Yourself First:**\nBefore using direct DB/Service access, ask:\n1. Can I do this via an API endpoint? -> If YES, use the API!\n2. Am I testing functionality? -> If YES, MUST use API!\n3. Is this just setup/cleanup? -> Only then consider direct access\n4. Am I setting roles/verified status? -> Allowed exception\n5. Am I reading data that has NO API endpoint? -> Allowed, but prefer API\n\n** Still NEVER Allowed - Even in Setup:**\n-  Testing functionality via Services\n-  Creating test data via Services when API exists\n-  Verifying results via DB when API query exists\n-  Writing to DB for anything other than roles/verified/cleanup\n\n**Example of correct usage:**\n\n```typescript\ndescribe('User Registration Story', () => {\n  let testHelper: TestHelper;\n  let db: Db;\n  let createdUserId: string;\n\n  beforeAll(async () => {\n    testHelper = new TestHelper(app);\n    db = app.get<Connection>(getConnectionToken()).db;\n  });\n\n  afterAll(async () => {\n    //  ALLOWED: Direct DB access for cleanup\n    if (createdUserId) {\n      await db.collection('users').deleteOne({ _id: new ObjectId(createdUserId) });\n    }\n  });\n\n  it('should allow new user to register with valid data', async () => {\n    //  CORRECT: Test via API\n    const result = await testHelper.rest('/auth/signup', {\n      method: 'POST',\n      payload: {\n        email: 'newuser@test.com',\n        password: 'SecurePass123!',\n        firstName: 'John',\n        lastName: 'Doe'\n      },\n      statusCode: 201\n    });\n\n    expect(result.id).toBeDefined();\n    expect(result.email).toBe('newuser@test.com');\n    createdUserId = result.id;\n\n    //  ALLOWED: Set verified flag for subsequent tests\n    await db.collection('users').updateOne(\n      { _id: new ObjectId(createdUserId) },\n      { $set: { verified: true } }\n    );\n  });\n\n  it('should allow verified user to sign in', async () => {\n    //  CORRECT: Test via API\n    const result = await testHelper.rest('/auth/signin', {\n      method: 'POST',\n      payload: {\n        email: 'newuser@test.com',\n        password: 'SecurePass123!'\n      },\n      statusCode: 201\n    });\n\n    expect(result.token).toBeDefined();\n    expect(result.user.email).toBe('newuser@test.com');\n\n    //  WRONG: Don't verify via direct DB access\n    // const dbUser = await db.collection('users').findOne({ email: 'newuser@test.com' });\n\n    //  CORRECT: Verify via API\n    const profile = await testHelper.rest('/api/users/me', {\n      method: 'GET',\n      token: result.token,\n      statusCode: 200\n    });\n    expect(profile.email).toBe('newuser@test.com');\n  });\n});\n```\n\n---\n\n** BEFORE Writing Any Tests - Study the TestHelper:**\n\n**CRITICAL: Read the TestHelper source file to understand all available features!**\n\n```\nnode_modules/@lenne.tech/nest-server/src/test/test.helper.ts\n```\n\nThis file documents ALL TestHelper capabilities:\n- `rest()` and `graphQl()` methods with all options\n- File uploads via `attachments` option\n- Debugging with `log` and `logError` options in `TestRestOptions`\n- Custom headers, status code validation\n- Authentication token handling\n\n**Study this file BEFORE writing tests** to avoid reinventing functionality that already exists!\n\n---\n\n**Location:** `tests/stories/` directory (create if it doesn't exist)\n\n**Directory Creation:**\nIf the `tests/stories/` directory doesn't exist yet, create it first:\n```bash\nmkdir -p tests/stories\n```\n\n**Naming Convention:** `{feature-name}.story.test.ts`\n- Example: `user-registration.story.test.ts`\n- Example: `product-search.story.test.ts`\n- Example: `order-processing.story.test.ts`\n\n**üìÅ File Organization - Avoid Too Many Files:**\n\n**IMPORTANT:** Before creating a NEW test file, check if existing test files can be extended!\n\nStory tests typically require significant setup (TestHelper, database connections, test users, etc.), so files naturally grow larger. A typical story test file ranges from 400-800 lines, with complex features reaching 1000+ lines.\n\n** PREFER extending existing files when:**\n- The new tests relate to the same feature/module\n- The existing file is not excessively large (< 1000 lines)\n- The tests share similar setup/teardown logic\n- It makes logical sense to group them together\n\n** CREATE new files when:**\n- Testing a completely different feature/module\n- The existing file would exceed ~1000-1200 lines\n- The tests require significantly different setup\n- It improves clarity and maintainability\n\n**Example:**\n```\ntests/stories/\n  user-authentication.story.test.ts    # Login, logout, password reset, session handling\n  user-profile.story.test.ts           # Profile CRUD, settings, preferences\n  product-management.story.test.ts     # Product CRUD, variants, pricing\n  order-processing.story.test.ts       # Cart, checkout, payment, fulfillment\n```\n\n**Why this matters:**\n- Too many small files -> Hard to navigate, duplicate setup code, redundant boilerplate\n- Too few large files -> Hard to read, slow to run, merge conflicts\n- Balance: Group related tests, split when files grow beyond ~1000 lines\n\n** BEFORE Writing Tests - Verify Your Assumptions:**\n\n**CRITICAL: Only write tests for endpoints that you have VERIFIED exist in the code!**\n\n1. **For REST endpoints:**\n   ```typescript\n   //  CORRECT: Verified endpoint exists in user.controller.ts\n   await testHelper.rest('/api/users', { method: 'POST', ... });\n\n   //  WRONG: Assumed endpoint without verification\n   await testHelper.rest('/api/users/profile', { method: 'PUT', ... });  // Does this exist?\n   ```\n\n2. **For GraphQL mutations/queries:**\n   ```typescript\n   //  CORRECT: Verified 'createUser' mutation exists in user.resolver.ts\n   await testHelper.graphQl({ name: 'createUser', type: TestGraphQLType.MUTATION, ... });\n\n   //  WRONG: Assumed mutation without verification\n   await testHelper.graphQl({ name: 'updateUserProfile', ... });  // Does this exist?\n   ```\n\n3. **Document your verification:**\n   ```typescript\n   // Test for user creation\n   // Verified: POST /api/users exists in src/server/modules/user/user.controller.ts:34\n   // Verified: Requires authentication (S_USER role)\n   // Verified: Returns User object with id, email, firstName, lastName\n   it('should create new user', async () => {\n     const result = await testHelper.rest('/api/users', {\n       method: 'POST',\n       payload: { email: 'test@example.com', ... },\n       token: adminToken,\n       statusCode: 201\n     });\n     // ...\n   });\n   ```\n\n**Test Structure:**\n\n1. **Study existing story tests** (if any exist in `tests/stories/`)\n   - Follow established patterns and conventions\n   - Use similar setup/teardown approaches\n   - Match coding style and organization\n\n2. **Study other test files** for patterns:\n   - Check `test/**/*.test.ts` files\n   - Understand authentication setup\n   - Learn data creation patterns\n   - See how API calls are made\n\n3. **Write comprehensive story test** that includes:\n   - Clear test description matching the story\n   - Setup of test data and users\n   - All acceptance criteria as test cases\n   - Proper authentication/authorization\n   - Validation of responses and side effects\n   - Cleanup/teardown\n\n4. **Ensure tests cover:**\n   - Happy path scenarios\n   - Edge cases\n   - Error conditions\n   - Security/permission checks\n   - Data validation\n\n**Example test structure:**\n```typescript\ndescribe('User Registration Story', () => {\n  let createdUserIds: string[] = [];\n  let createdProductIds: string[] = [];\n\n  // Setup\n  beforeAll(async () => {\n    // Initialize test environment\n  });\n\n  afterAll(async () => {\n    // üßπ CLEANUP: Delete ALL test data created during tests\n    // This prevents side effects on subsequent test runs\n    if (createdUserIds.length > 0) {\n      await db.collection('users').deleteMany({\n        _id: { $in: createdUserIds.map(id => new ObjectId(id)) }\n      });\n    }\n    if (createdProductIds.length > 0) {\n      await db.collection('products').deleteMany({\n        _id: { $in: createdProductIds.map(id => new ObjectId(id)) }\n      });\n    }\n  });\n\n  it('should allow new user to register with valid data', async () => {\n    // Test implementation\n    const user = await createUser(...);\n    createdUserIds.push(user.id); // Track for cleanup\n  });\n\n  it('should reject registration with invalid email', async () => {\n    // Test implementation\n  });\n\n  it('should prevent duplicate email registration', async () => {\n    // Test implementation\n  });\n});\n```\n\n** CRITICAL: Test Data Management for Parallel Execution**\n\n**ALWAYS follow these rules to ensure tests can run in parallel safely!**\n\nTests run in parallel, so improper test data management causes:\n- Conflicts between parallel tests (duplicate keys, race conditions)\n- False positives/negatives in tests\n- Flaky tests that pass/fail randomly\n- Contaminated test database\n- Hard-to-debug test failures\n\n** GOLDEN RULES for Test Data:**\n\n1. **Email Addresses Must End with @test.com**\n   ```typescript\n   //  CORRECT: Will be excluded from external services (e2e.brevo.exclude)\n   // Includes timestamp + random suffix for uniqueness even within same millisecond\n   const testEmail = `user-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`;\n\n   //  LESS SAFE: Only timestamp (collision risk if tests run in same millisecond)\n   const testEmail = `user-${Date.now()}@test.com`;\n\n   //  WRONG: Won't be excluded, may trigger external emails\n   const testEmail = 'testuser@example.com';\n   ```\n\n   **Why:** Configuration in `src/config.env.ts` uses `e2e.brevo.exclude` to filter out @test.com emails from external services. The random suffix ensures uniqueness even when multiple tests run simultaneously.\n\n2. **NEVER Reuse Same Data Across Test Files**\n   ```typescript\n   //  WRONG: user-story-1.test.ts and user-story-2.test.ts both use:\n   const email = 'admin@test.com';  //  Conflict when running in parallel!\n\n   //  CORRECT: Make data unique per test file with timestamp + random suffix\n   const email = `admin-user-story-1-${Date.now()}-${Math.random().toString(36).substring(2, 8)}@test.com`;\n\n   //  LESS SAFE: Only timestamp\n   const email = `admin-user-story-1-${Date.now()}@test.com`;\n   ```\n\n   **Why:** Tests run in parallel. Same email = duplicate key errors and race conditions. Random suffix prevents collisions within same millisecond.\n\n3. **ONLY Delete What You Created in This Test File**\n   ```typescript\n   //  WRONG: Deletes ALL test users (affects parallel tests)\n   await db.collection('users').deleteMany({ email: /@test\\.com$/ });\n\n   //  CORRECT: Only delete tracked entities from THIS test\n   if (createdUserIds.length > 0) {\n     await db.collection('users').deleteMany({\n       _id: { $in: createdUserIds.map(id => new ObjectId(id)) }\n     });\n   }\n   ```\n\n   **Why:** Deleting too much breaks parallel tests that are still running.\n\n4. **ALL Created Entities Must Be Cleaned Up**\n   ```typescript\n   //  Track EVERY entity created\n   let createdUserIds: string[] = [];\n   let createdProductIds: string[] = [];\n   let createdOrderIds: string[] = [];\n\n   //  Clean up ALL in afterAll\n   afterAll(async () => {\n     if (createdOrderIds.length > 0) {\n       await db.collection('orders').deleteMany({\n         _id: { $in: createdOrderIds.map(id => new ObjectId(id)) }\n       });\n     }\n     // ... clean up products, users, etc.\n   });\n   ```\n\n   **Why:** Leftover data causes side effects in future test runs.\n\n5. **NEVER Use Fixed Port Numbers**\n   ```typescript\n   //  WRONG: Fixed port causes conflicts in parallel tests\n   await app.listen(3000);\n   const response = await fetch('http://localhost:3000/api/users');\n\n   //  CORRECT: NestJS assigns random ports automatically\n   await app.init();  // No port specified\n   // Use TestHelper - it handles ports automatically\n   const result = await testHelper.rest('/api/users', { ... });\n   ```\n\n   **Why:** Parallel tests need different ports. NestJS assigns random available ports automatically. TestHelper abstracts this away.\n\n**Cleanup Strategy:**\n\n1. **Track all created entities:**\n   ```typescript\n   let createdUserIds: string[] = [];\n   let createdProductIds: string[] = [];\n   let createdOrderIds: string[] = [];\n   ```\n\n2. **Add IDs immediately after creation:**\n   ```typescript\n   const user = await testHelper.rest('/api/users', {\n     method: 'POST',\n     payload: userData,\n     token: adminToken,\n   });\n   createdUserIds.push(user.id); //  Track for cleanup\n   ```\n\n3. **Delete ALL created entities in afterAll:**\n   ```typescript\n   afterAll(async () => {\n     // Clean up all test data\n     if (createdOrderIds.length > 0) {\n       await db.collection('orders').deleteMany({\n         _id: { $in: createdOrderIds.map(id => new ObjectId(id)) }\n       });\n     }\n     if (createdProductIds.length > 0) {\n       await db.collection('products').deleteMany({\n         _id: { $in: createdProductIds.map(id => new ObjectId(id)) }\n       });\n     }\n     if (createdUserIds.length > 0) {\n       await db.collection('users').deleteMany({\n         _id: { $in: createdUserIds.map(id => new ObjectId(id)) }\n       });\n     }\n\n     await connection.close();\n     await app.close();\n   });\n   ```\n\n4. **Clean up in correct order:**\n   - Delete child entities first (e.g., Orders before Products)\n   - Delete parent entities last (e.g., Users last)\n   - Consider foreign key relationships\n\n5. **Handle cleanup errors gracefully:**\n   ```typescript\n   afterAll(async () => {\n     try {\n       // Cleanup operations\n       if (createdUserIds.length > 0) {\n         await db.collection('users').deleteMany({\n           _id: { $in: createdUserIds.map(id => new ObjectId(id)) }\n         });\n       }\n     } catch (error) {\n       console.error('Cleanup failed:', error);\n       // Don't throw - cleanup failures shouldn't fail the test suite\n     }\n\n     await connection.close();\n     await app.close();\n   });\n   ```\n\n**What to clean up:**\n-  Users created during tests\n-  Products/Resources created during tests\n-  Orders/Transactions created during tests\n-  Any relationships (comments, reviews, etc.)\n-  Files uploaded during tests\n-  Any other test data that persists\n\n**What NOT to clean up:**\n-  Global test users created in `beforeAll` that are reused (clean these once at the end)\n-  Database connections (close these separately)\n-  The app instance (close this separately)\n\n**Step 2 Checklist:**\n- [ ] Test file created in tests/stories/\n- [ ] Endpoints verified before writing tests\n- [ ] ALL tests use TestHelper (rest() or graphQl())\n- [ ] NO direct Service or DB access in test logic\n- [ ] Existing test patterns studied and followed\n- [ ] All acceptance criteria covered\n- [ ] Cleanup implemented in afterAll\n- [ ] All test entities tracked for cleanup\n- [ ] Ready for Step 3\n\n## Step 3: Run Tests & Analyze Failures\n\n**Execute all tests:**\n```bash\nnpm test\n```\n\n**Or run specific story test:**\n```bash\nnpm test -- tests/stories/your-story.story.test.ts\n```\n\n**Analyze results:**\n1. Record which tests fail and why\n2. Identify if failures are due to:\n   - Missing implementation (expected)\n   - Test errors/bugs (needs fixing)\n   - Misunderstood requirements (needs clarification)\n\n**Decision point:**\n- If test has bugs/errors -> Go to Step 3a\n- If API implementation is missing/incomplete -> Go to Step 4\n\n**Debugging Test Failures:**\n\nIf test failures are unclear, enable debugging tools:\n- **TestHelper:** Add `log: true, logError: true` to test options for detailed output\n- **Server logging:** Set `logExceptions: true` in `src/config.env.ts`\n- **Validation debugging:** Set `DEBUG_VALIDATION=true` environment variable\n\nSee **reference.md** for detailed debugging instructions and examples.\n\n## Step 3a: Fix Test Errors (if needed)\n\n**Only fix tests if:**\n- Test logic is incorrect\n- Test has programming errors\n- Test makes nonsensical demands\n- Test doesn't match actual requirements\n\n**Do NOT \"fix\" tests by:**\n- Removing security checks to make them pass\n- Lowering expectations to match incomplete implementation\n- Skipping test cases that should work\n\n**After fixing tests:**\n- Return to Step 3 (run tests again)\n\n## Step 4: Implement/Extend API Code\n\n**Use the `nest-server-generator` skill for implementation:**\n\n1. **Analyze what's needed:**\n   - New modules? -> Use `nest-server-generator`\n   - New objects? -> Use `nest-server-generator`\n   - New properties? -> Use `nest-server-generator`\n   - Code modifications? -> Use `nest-server-generator`\n\n2. ** Understand existing codebase first - VERIFY before using:**\n   - **Read actual Service files** before calling methods:\n     - Verify method names and signatures\n     - Check required parameters and types\n     - Confirm return types\n     - Example: Read `user.service.ts` to verify `findById(id: string): Promise<User>` exists\n   - **Read actual Model files** to understand data structures:\n     - Verify field names and types\n     - Check validation rules\n     - Confirm relationships\n   - **Study @lenne.tech/nest-server patterns** (in `node_modules/@lenne.tech/nest-server/src`):\n     - Check CrudService base class for available methods (in `node_modules/@lenne.tech/nest-server/src/core/common/services/crud.service.ts`)\n     - Check RoleEnum (in the project or `node_modules/@lenne.tech/nest-server/src/core/common/enums/role.enum.ts`)\n     - Understand decorators: @Roles, @Restricted, @UnifiedField\n     - Study MapAndValidatePipe for validation logic (automatically activated via CoreModule - see `node_modules/@lenne.tech/nest-server/src/core/common/pipes/map-and-validate.pipe.ts`)\n   - **Review existing similar implementations** - don't assume, verify!\n\n   ** CRITICAL:** Don't assume methods or properties exist - READ THE CODE to verify!\n\n2a. ** CRITICAL: Property Descriptions with German Comments**\n\n   **When user provides German comments/descriptions for properties, you MUST preserve them correctly!**\n\n   **Rule: `ENGLISH (GERMAN)` format**\n   - German: `// Produktname` -> Description: `'Product name (Produktname)'`\n   - German: `// Stra√üe` -> Description: `'Street (Stra√üe)'`\n   - English: `// Product name` -> Description: `'Product name'` (no translation)\n\n   **Process:**\n   1.  Extract ALL comments from user requirements (after `//`)\n   2.  Translate German to English, keep German in parentheses\n   3.  Fix spelling errors but preserve exact wording\n   4.  Apply SAME description to: Model, CreateInput, UpdateInput, @ObjectType, @InputType\n   5.  NEVER change wording (e.g., `Stra√üe` -> `Stra√üenname` is WRONG!)\n   6.  NEVER skip German original in parentheses\n\n   **Example from user requirements:**\n   ```\n   Module: Product\n   - name: string // Produktname\n   - price: number // Price\n   ```\n\n   **Correct implementation in ALL locations:**\n   ```typescript\n   // In product.model.ts:\n   @UnifiedField({ description: 'Product name (Produktname)' })\n   name: string;\n\n   @UnifiedField({ description: 'Price' })\n   price: number;\n\n   // In product.input.ts (CreateInput, UpdateInput):\n   @UnifiedField({ description: 'Product name (Produktname)' })\n   name: string;\n\n   @UnifiedField({ description: 'Price' })\n   price: number;\n   ```\n\n   **See `nest-server-generator` skill -> `description-management.md` for complete details.**\n\n3. ** CRITICAL: ServiceOptions when calling other Services:**\n\n   **NEVER blindly pass all ServiceOptions when one Service calls another!**\n\n   When implementing Service methods that call other Services, analyze which options to pass:\n\n   ** WRONG:**\n   ```typescript\n   //  BAD: Blindly passing all serviceOptions\n   const product = await this.productService.findOne({ id: input.productId }, serviceOptions);\n   ```\n\n   ** CORRECT:**\n   ```typescript\n   //  GOOD: Only pass what's needed (usually just currentUser)\n   const product = await this.productService.findOne(\n     { id: input.productId },\n     { currentUser: serviceOptions.currentUser }\n   );\n\n   //  GOOD: Only set inputType if different Input class is needed\n   const user = await this.userService.findOne(\n     { id: input.userId },\n     {\n       currentUser: serviceOptions.currentUser,\n       inputType: UserInput // Only if specific Input class needed (e.g., UserInput, UserInputCreate)\n     }\n   );\n   ```\n\n   **Why this matters:**\n   - **inputType** specifies which Input class (DTO) to use for validation (e.g., `UserInput`, `UserInputCreate`)\n   - The inputType from outer service might be wrong for inner service\n   - **roles** might need to be different\n   - Other options (limit, skip, etc.) might not apply\n   - Can cause incorrect permission checks or wrong validation\n\n   **Before passing options:**\n   - Analyze what's in serviceOptions (currentUser, inputType, roles, etc.)\n   - Determine what the target Service actually needs\n   - Only pass required options (usually just currentUser)\n   - Only set inputType if a specific Input class (DTO) is needed (e.g., UserInput, UserInputCreate)\n\n4. **Implement equivalently to existing code:**\n   - Use TestHelper for REST oder GraphQL requests (in `node_modules/@lenne.tech/nest-server/src/test/test.helper.ts`)\n   - Use `getStringIds()` and `getObjectIds()` from `@lenne.tech/nest-server` for ObjectId conversions\n   - Match coding style and patterns\n   - Use same architectural approaches\n   - Follow established conventions\n   - Reuse existing utilities\n\n4a. ** IMPORTANT: Guards in Controllers**\n\n   **DO NOT manually add `@UseGuards(AuthGuard(AuthGuardStrategy.JWT))` - it's automatically activated by `@Roles()`!**\n\n   ```typescript\n   //  CORRECT: @Roles automatically activates JWT guard\n   @Roles(RoleEnum.ADMIN)\n   @Get()\n   async findAll() {\n     return this.service.find();\n   }\n\n   //  CORRECT: @Restricted also activates guards automatically\n   @Restricted()\n   @Post()\n   async create(@Body() input: CreateDto) {\n     return this.service.create(input);\n   }\n\n   //  WRONG: Redundant manual guard (already included by @Roles)\n   @UseGuards(AuthGuard(AuthGuardStrategy.JWT))\n   @Roles(RoleEnum.ADMIN)\n   @Get()\n   async findAll() {\n     return this.service.find();\n   }\n   ```\n\n   **Why this matters:**\n   - `@Roles()` decorator automatically applies `@UseGuards(RolesGuard)`\n   - `RolesGuard` internally uses JWT authentication\n   - Adding `@UseGuards(AuthGuard(...))` manually is redundant and creates duplicate guards\n   - Existing controllers don't use manual guards - follow this pattern\n\n5. ** IMPORTANT: Database Indexes**\n\n   **Always define indexes directly in the @UnifiedField decorator via mongoose option!**\n\n   **Quick Guidelines:**\n   - Fields used in queries -> Add `mongoose: { index: true, type: String }`\n   - Foreign keys -> Add index\n   - Unique fields -> Add `mongoose: { index: true, unique: true, type: String }`\n   -  NEVER define indexes separately in schema files\n\n   ** For detailed index patterns and examples, see: `database-indexes.md`**\n\n6. **Prefer existing packages:**\n   - Check if @lenne.tech/nest-server provides needed functionality\n   - Only add new npm packages as last resort\n   - If new package needed, verify:\n     - High quality and well-maintained\n     - Frequently used (npm downloads)\n     - Active maintenance\n     - Free license (preferably MIT)\n     - Long-term viability\n\n## Step 5: Validate & Iterate\n\n**Run ALL tests:**\n```bash\nnpm test\n```\n\n**Check results:**\n\n **All tests pass?**\n- Continue to Step 5a (Code Quality Check)\n\n **Some tests still fail?**\n- Return to Step 3 (analyze failures)\n- Continue iteration\n\n## Step 5a: Code Quality & Refactoring Check\n\n**BEFORE marking the task as complete, perform a code quality review!**\n\nOnce all tests are passing, analyze your implementation for code quality issues:\n\n### 1-3. Code Quality Review\n\n**Check for:**\n- Code duplication (extract to private methods if used 2+ times)\n- Common functionality (create helper functions)\n- Similar code paths (consolidate with flexible parameters)\n- Consistency with existing patterns\n\n** For detailed refactoring patterns and examples, see: `code-quality.md`**\n\n### 4. Review for Consistency\n\n**Ensure consistent patterns throughout your implementation:**\n- Naming conventions match existing codebase\n- Error handling follows project patterns\n- Return types are consistent\n- Similar operations use similar approaches\n\n### 4a. Check Database Indexes\n\n**Verify that indexes are defined where needed:**\n\n**Quick check:**\n- Fields used in find/filter -> Has index?\n- Foreign keys (userId, productId, etc.) -> Has index?\n- Unique fields (email, username) -> Has unique: true?\n- Fields used in sorting -> Has index?\n\n**If indexes are missing:**\n- Add to @UnifiedField decorator (mongoose option)\n- Re-run tests\n- Document query pattern\n\n** For detailed verification checklist, see: `database-indexes.md`**\n\n### 4b. Security Review\n\n** CRITICAL: Perform security review before final testing!**\n\n**ALWAYS review all code changes for security vulnerabilities.**\n\n**Quick Security Check:**\n- [ ] @Restricted/@Roles decorators NOT removed or weakened\n- [ ] Ownership checks in place (users can only access own data)\n- [ ] All inputs validated with proper DTOs\n- [ ] Sensitive fields marked with hideField: true\n- [ ] No injection vulnerabilities\n- [ ] Error messages don't expose sensitive data\n- [ ] Authorization tests pass\n\n**Red Flags (STOP if found):**\n- üö© @Restricted decorator removed\n- üö© @Roles changed to more permissive\n- üö© Missing ownership checks\n- üö© Sensitive fields exposed\n- üö© 'any' type instead of DTO\n\n**If ANY red flag found:**\n1. STOP implementation\n2. Fix security issue immediately\n3. Re-run security checklist\n4. Update tests to verify security\n\n** For complete security checklist with examples, see: `security-review.md`**\n\n### 5. Refactoring Decision Tree\n\n```\nCode duplication detected?\n    ‚îÇ\n    ‚îú‚îÄ‚ñ∫ Used in 2+ places?\n    ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îú‚îÄ‚ñ∫ YES: Extract to private method\n    ‚îÇ   ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚ñ∫ Used across multiple services?\n    ‚îÇ   ‚îÇ       ‚îÇ\n    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚ñ∫ YES: Consider utility class/function\n    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚ñ∫ NO: Keep as private method\n    ‚îÇ   ‚îÇ\n    ‚îÇ   ‚îî‚îÄ‚ñ∫ NO: Leave as-is (don't over-engineer)\n    ‚îÇ\n    ‚îî‚îÄ‚ñ∫ Complex logic block?\n        ‚îÇ\n        ‚îú‚îÄ‚ñ∫ Hard to understand?\n        ‚îÇ   ‚îî‚îÄ‚ñ∫ Extract to well-named method\n        ‚îÇ\n        ‚îî‚îÄ‚ñ∫ Simple and clear?\n            ‚îî‚îÄ‚ñ∫ Leave as-is\n```\n\n### 6. Run Tests After Refactoring & Security Review\n\n**CRITICAL: After any refactoring, adding indexes, or security fixes:**\n\n```bash\nnpm test\n```\n\n**Ensure:**\n-  All tests still pass\n-  No new failures introduced\n-  Code is more maintainable\n-  No functionality changed\n-  Indexes properly applied\n-  **Security checks still working (authorization tests pass)**\n\n### 7. When to Skip Refactoring\n\n**Don't refactor if:**\n- Code is used in only ONE place\n- Extraction would make code harder to understand\n- The duplication is coincidental, not conceptual\n- Time constraints don't allow for safe refactoring\n\n**Remember:**\n- **Working code > Perfect code**\n- **Refactor only if it improves maintainability**\n- **Always run tests after refactoring**\n- **Always add indexes where queries are performed**\n\n## Step 5b: Final Validation\n\n**After refactoring (or deciding not to refactor):**\n\n1. **Run ALL tests one final time:**\n   ```bash\n   npm test\n   ```\n\n2. **Verify:**\n   -  All tests pass\n   -  Test coverage is adequate\n   -  Code follows project patterns\n   -  No obvious duplication\n   -  Clean and maintainable\n   -  **Security review completed**\n   -  **No security vulnerabilities introduced**\n   -  **Authorization tests pass**\n\n3. **Generate final report for developer**\n\n4. **YOU'RE DONE!** \n",
        "plugins/lt-dev/skills/developing-claude-plugins/SKILL.md": "---\nname: developing-claude-plugins\ndescription: Expert for Claude Code plugin and marketplace development. Use when creating, editing, or optimizing skills (SKILL.md), commands (*.md), agents, hooks (hooks.json), scripts, or plugin.json files. Ensures consistency with official best practices from code.claude.com documentation. Activates for any file in plugins/ directory.\n---\n\n# Claude Code Plugin & Marketplace Expert\n\nYou are an expert in developing Claude Code marketplaces and plugins. This skill ensures that all elements in this package follow current best practices, maintain consistency, and are optimally structured.\n\n## When This Skill Activates\n\n**File patterns that trigger this skill:**\n- `plugins/**/*` - Any file in the plugins directory\n- `**/SKILL.md` - Skill definition files\n- `**/commands/**/*.md` - Command files\n- `**/agents/**/*.md` - Agent files\n- `**/hooks/**/*` - Hook configurations and scripts\n- `marketplace.json` - Marketplace definition\n- `plugin.json` - Plugin manifests\n\n**Actions that trigger this skill:**\n- Creating new plugins, agents, commands, hooks, skills, or scripts\n- Modifying existing plugin elements\n- Reviewing or optimizing plugin structure\n- Discussing Claude Code extension development\n\n## Mandatory Pre-Work: Documentation Review\n\n**CRITICAL:** Before ANY implementation or optimization, fetch the latest official documentation.\n\n### Primary Sources (GitHub - always available)\n\nFetch these GitHub sources first:\n```\nWebFetch: https://github.com/anthropics/claude-code/blob/main/plugins/README.md\nWebFetch: https://github.com/anthropics/skills/blob/main/README.md\n```\n\n### Secondary Sources (WebSearch)\n\nFor specific topics, use targeted searches:\n```\nWebSearch: \"Claude Code [topic] documentation site:claude.com\"\n```\n\nTopics to search when relevant:\n- Plugins & plugin.json structure\n- Skills & SKILL.md frontmatter\n- Slash commands & command frontmatter\n- Subagents & agent configuration\n- Hooks & hooks.json structure\n\nApply the patterns and requirements from these sources.\n\n---\n\n## Element Types Reference\n\n### Skills\n**Purpose:** Provide contextual expertise that enhances Claude's capabilities in specific domains.\n\n**Structure:**\n```\nskills/\n‚îî‚îÄ‚îÄ skill-name/\n    ‚îú‚îÄ‚îÄ SKILL.md           # Main skill definition (REQUIRED)\n    ‚îú‚îÄ‚îÄ reference.md       # Detailed reference documentation\n    ‚îú‚îÄ‚îÄ examples.md        # Usage examples\n    ‚îî‚îÄ‚îÄ [topic].md         # Additional topic-specific files\n```\n\n**SKILL.md Template:**\n```yaml\n---\nname: skill-name-kebab-case\ndescription: Concise description (max 280 chars) focusing on WHEN to use this skill. Must trigger auto-detection correctly.\n---\n\n# Skill Title\n\n[Introductory paragraph explaining the skill's purpose]\n\n## When to Use This Skill\n\n- [Trigger condition 1]\n- [Trigger condition 2]\n\n## Core Capabilities\n\n[Main content organized by capability]\n\n## Related Skills\n\n- `related-skill-1` - [relationship]\n- `related-skill-2` - [relationship]\n```\n\n**Key Principles:**\n- Description must answer \"WHEN should Claude use this skill?\"\n- Avoid overlap with other skills\n- Include clear boundary definitions\n- Reference related skills explicitly\n\n---\n\n### Commands\n**Purpose:** User-triggered actions invoked via `/command-name`.\n\n**Structure:**\n```\ncommands/\n‚îú‚îÄ‚îÄ simple-command.md\n‚îî‚îÄ‚îÄ category/\n    ‚îú‚îÄ‚îÄ sub-command-1.md\n    ‚îî‚îÄ‚îÄ sub-command-2.md\n```\n\n**Template:**\n```yaml\n---\ndescription: What this command does (shown in /help and command list)\nargument-hint: [optional-args]    # Optional: shown in autocomplete\nallowed-tools: Read, Grep, Bash   # Optional: restrict tool access\nmodel: claude-3-5-sonnet-20241022 # Optional: force specific model\n---\n\n# Command Title\n\n[Brief description of what this command accomplishes]\n\n## When to Use This Command\n\n- [Use case 1]\n- [Use case 2]\n\n## Workflow\n\n### Step 1: [Action]\n[Instructions]\n\n### Step 2: [Action]\n[Instructions]\n\n## Examples\n\n[Practical examples of command usage]\n```\n\n**Naming:** Use kebab-case, e.g., `create-story.md`, `git/commit-message.md`\n\n---\n\n### Agents\n**Purpose:** Autonomous agents that handle complex, multi-step tasks with specific tool access.\n\n**File:** `agents/agent-name.md`\n\n**Template:**\n```yaml\n---\nname: agent-name\ndescription: When to use this agent and what tasks it handles autonomously\nmodel: sonnet | opus | haiku\ntools: Bash, Read, Grep, Glob, Write, Edit\npermissionMode: default | bypassPermissions\nskills: optional-comma-separated-skills\n---\n\n[Agent persona and mission]\n\n## Use Cases\n\n- [When to spawn this agent]\n- [Specific task types it handles]\n\n## Execution Protocol\n\n[Detailed workflow and phases]\n\n## Output Format\n\n[Expected output structure]\n```\n\n**Key Principles:**\n- Define clear tool restrictions\n- Specify appropriate model (haiku for simple, sonnet for complex, opus for critical)\n- Include self-verification checklists\n\n---\n\n### Hooks\n**Purpose:** Automated responses to Claude Code events.\n\n**Structure:**\n```\nhooks/\n‚îú‚îÄ‚îÄ hooks.json    # Hook definitions\n‚îî‚îÄ‚îÄ scripts/      # Hook handler scripts\n    ‚îî‚îÄ‚îÄ handler.ts\n```\n\n**hooks.json Template:**\n```json\n{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"/path/to/script.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**Fields:**\n| Field | Type | Description |\n|-------|------|-------------|\n| `matcher` | string | Tool filter: `\"Write\"`, `\"Write\\|Edit\"`, `\"Bash(npm test*)\"`, or omit for all |\n| `type` | string | `\"command\"` (shell) or `\"prompt\"` (Claude evaluation) |\n| `command` | string | Shell command (for type=\"command\") |\n| `timeout` | number | Seconds before timeout (default: 60, optional) |\n\n**Events:**\n- `PreToolUse` - Before a tool executes\n- `PostToolUse` - After a tool executes\n- `PermissionRequest` - When permission is requested\n- `UserPromptSubmit` - When user submits a prompt\n- `SessionStart` - Session initialization\n- `Stop` - When main agent finishes\n- `SubagentStop` - When subagent finishes\n- `PreCompact` - Before context compaction\n\n---\n\n## Quality Checklist\n\n### Before Creating Any Element\n\n- [ ] Fetched latest documentation from official sources\n- [ ] Identified correct element type for the use case\n- [ ] Checked for existing similar elements (avoid duplication)\n- [ ] Determined relationships with existing elements\n\n### Element Quality Standards\n\n- [ ] YAML frontmatter is correct and complete\n- [ ] Description is concise and actionable\n- [ ] Structure follows established patterns in this package\n- [ ] Markdown is clean and well-organized\n- [ ] Examples are included where helpful\n- [ ] Related elements are cross-referenced\n\n### Consistency Checks\n\n- [ ] Naming follows kebab-case convention\n- [ ] Heading hierarchy is consistent (# for title, ## for sections)\n- [ ] Language is English (except user-facing German content)\n- [ ] No orphaned references to non-existent elements\n\n---\n\n## Optimization Workflow\n\nWhen optimizing existing elements:\n\n### 1. Analysis Phase\n```\n1. Read the element completely\n2. Identify the element type and purpose\n3. Fetch current best practices from documentation\n4. Compare against other elements in the same category\n5. List specific issues and improvements\n```\n\n### 2. Proposal Phase\n```\n1. Present findings to the user\n2. Propose specific changes with rationale\n3. Highlight any breaking changes or dependencies\n4. Get approval before implementation\n```\n\n### 3. Implementation Phase\n```\n1. Make changes incrementally\n2. Maintain backwards compatibility where possible\n3. Update cross-references in related elements\n4. Verify no broken references\n```\n\n### 4. Verification Phase\n```\n1. Validate YAML frontmatter syntax\n2. Check markdown rendering\n3. Verify all cross-references work\n4. Test any commands or workflows\n```\n\n---\n\n## Common Patterns in This Package\n\n### Skill Organization\n- Main SKILL.md with overview and triggers\n- Separate files for detailed topics (reference.md, examples.md)\n- Clear \"When to Use\" sections with bullet points\n\n### Command Organization\n- Grouped by category in subdirectories\n- Step-by-step workflows with clear phases\n- German output for user-facing commands where appropriate\n\n### Agent Organization\n- Detailed execution protocols with phases\n- Self-verification checklists\n- Comprehensive output format specifications\n\n---\n\n## Content Standards\n\n### No History References\n- **Never use** \"new\", \"updated\", \"changed from\", or version-specific markers\n- **Never include** \"since v2.1\", \"added in version X\", \"previously\"\n- **Write timelessly** as if features always existed\n- **Remove** any existing history references when optimizing\n\n### Token Efficiency\n- Keep content concise but complete\n- Avoid redundant explanations\n- Use tables and lists over prose where appropriate\n- Don't sacrifice clarity for brevity\n- **Never remove important information for token savings**\n\n---\n\n## Anti-Patterns to Avoid\n\n1. **Overlapping Skills**: Two skills that trigger on the same conditions\n2. **Monolithic Commands**: Commands that try to do too much\n3. **Vague Descriptions**: Descriptions that don't help auto-detection\n4. **Missing Cross-References**: Elements that should reference each other but don't\n5. **Inconsistent Structure**: Elements that don't follow established patterns\n6. **Outdated Best Practices**: Not checking current documentation before changes\n7. **History References**: Adding \"new\", \"updated\", version markers to content\n\n---\n\n## Related Skills\n\n**Works closely with:**\n- `using-lt-cli` skill - For Git operations in this package\n- `generating-nest-servers` skill - When adding NestJS-related commands or skills\n- `developing-lt-frontend` skill - When adding Nuxt-related commands or skills\n- `maintaining-npm-packages` skill - When adding maintenance-related commands\n\n**When to use which:**\n- Plugin development (this package)? Use this skill\n- NestJS server development? Use `generating-nest-servers` skill\n- Frontend development? Use `developing-lt-frontend` skill\n- Package maintenance? Use `maintaining-npm-packages` skill\n\nWhen modifying any skill, command, or agent in this package, this expertise should inform the changes.\n",
        "plugins/lt-dev/skills/developing-claude-plugins/examples.md": "# Claude Code Plugin Examples\n\nComplete, copy-paste-ready examples for each element type.\n\n## Table of Contents\n\n- [Skill Example: Code Review Standards](#skill-example-code-review-standards)\n- [Command Example: API Route Scaffolding](#command-example-api-route-scaffolding)\n- [Agent Example: Documentation Generator](#agent-example-documentation-generator)\n- [Hook Example: Format on Save](#hook-example-format-on-save)\n- [Hook Script Example: Frontmatter Validation](#hook-script-example-frontmatter-validation)\n- [Minimal Examples](#minimal-examples)\n\n---\n\n## Skill Example: Code Review Standards\n\nA read-only skill that provides code review expertise with restricted tool access.\n\n**File:** `skills/code-review-standards/SKILL.md`\n\n```yaml\n---\nname: code-review-standards\ndescription: Use when reviewing code or discussing code quality. Applies company coding standards and best practices for TypeScript, NestJS, and Angular projects.\nallowed-tools: Read, Grep, Glob\n---\n\n# Code Review Standards Expert\n\nYou ensure all code follows our established standards.\n\n## When This Skill Activates\n\n- Reviewing pull requests or code changes\n- Discussing code quality improvements\n- Checking compliance with coding standards\n\n## Standards\n\n### TypeScript\n- Use strict mode\n- Prefer interfaces over types for object shapes\n- Use explicit return types on public methods\n\n### Naming\n- camelCase for variables and functions\n- PascalCase for classes and interfaces\n- SCREAMING_SNAKE_CASE for constants\n\n### File Organization\n- One component/class per file\n- Group imports: external ‚Üí internal ‚Üí relative\n- Export public API from index.ts\n```\n\n---\n\n## Command Example: API Route Scaffolding\n\nA command that generates multiple files following project conventions.\n\n**File:** `commands/scaffold-api-route.md`\n\n```yaml\n---\ndescription: Generate a new API route with controller, service, DTO, and tests\nargument-hint: <route-name>\nallowed-tools: Read, Write, Glob\n---\n\n# Scaffold API Route\n\nCreates a complete API route structure following project conventions.\n\n## When to Use This Command\n\n- Adding a new REST endpoint\n- Need consistent structure for controllers and services\n\n## Workflow\n\n### Step 1: Gather Route Details\n\nAsk the user using AskUserQuestion:\n- Route path (e.g., `/users`, `/products/:id`)\n- HTTP methods needed (GET, POST, PUT, DELETE)\n- Authentication required?\n\n### Step 2: Analyze Existing Patterns\n\nRead existing controllers to match the project's coding style:\n- Decorator patterns\n- Error handling approach\n- Response formatting\n\n### Step 3: Generate Files\n\nCreate the following files:\n1. `src/controllers/[name].controller.ts`\n2. `src/services/[name].service.ts`\n3. `src/dto/[name].dto.ts`\n4. `tests/[name].spec.ts`\n\n### Step 4: Register Route\n\nAdd route to the router configuration or module imports.\n\n## Example Output\n\nFor `$ARGUMENTS = \"products\"`:\n\n**src/controllers/products.controller.ts**\n```typescript\nimport { Controller, Get, Post, Body, Param } from '@nestjs/common';\nimport { ProductsService } from '../services/products.service';\nimport { CreateProductDto } from '../dto/products.dto';\n\n@Controller('products')\nexport class ProductsController {\n  constructor(private readonly productsService: ProductsService) {}\n\n  @Get()\n  findAll() {\n    return this.productsService.findAll();\n  }\n\n  @Get(':id')\n  findOne(@Param('id') id: string) {\n    return this.productsService.findOne(id);\n  }\n\n  @Post()\n  create(@Body() createProductDto: CreateProductDto) {\n    return this.productsService.create(createProductDto);\n  }\n}\n```\n```\n\n---\n\n## Agent Example: Documentation Generator\n\nAn autonomous agent that generates documentation from code analysis.\n\n**File:** `agents/documentation-generator.md`\n\n```yaml\n---\nname: documentation-generator\ndescription: Generates comprehensive documentation from code. Use when creating or updating API docs, README files, or code documentation.\nmodel: sonnet\ntools: Read, Grep, Glob, Write\npermissionMode: default\n---\n\nYou are a documentation specialist. Generate clear, accurate documentation.\n\n## Use Cases\n\n- Generating API documentation from controllers\n- Creating README files for new modules\n- Updating existing documentation after code changes\n\n## Execution Protocol\n\n### Phase 1: Code Analysis\n1. Scan relevant source files using Glob\n2. Extract public APIs, types, and exports using Grep\n3. Read file contents to understand implementation\n4. Identify dependencies and relationships\n\n### Phase 2: Documentation Generation\n1. Generate markdown documentation\n2. Include code examples where helpful\n3. Add usage instructions\n4. Create table of contents for large docs\n\n### Phase 3: Validation\n1. Verify all internal links work\n2. Check code examples are syntactically correct\n3. Ensure consistency with existing documentation style\n\n## Output Format\n\nDocumentation in markdown format with:\n- Overview section\n- Installation/setup if applicable\n- API reference with parameters and return types\n- Usage examples\n- Troubleshooting section\n\n## Quality Checklist\n\nBefore completing, verify:\n- [ ] All public APIs documented\n- [ ] Code examples are runnable\n- [ ] No broken internal links\n- [ ] Consistent formatting throughout\n```\n\n---\n\n## Hook Example: Format on Save\n\nAutomatic formatting hook that runs after file writes.\n\n**File:** `hooks/hooks.json`\n\n```json\n{\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": {\n          \"tool\": \"Write\",\n          \"file_path\": \"**/*.ts\"\n        },\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx prettier --write $CLAUDE_FILE_PATH\",\n            \"timeout\": 10\n          }\n        ]\n      },\n      {\n        \"matcher\": {\n          \"tool\": \"Write\",\n          \"file_path\": \"src/**/*.ts\"\n        },\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx eslint $CLAUDE_FILE_PATH --fix\",\n            \"timeout\": 15\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"echo '{\\\"hookSpecificOutput\\\":{\\\"additionalContext\\\":\\\"Remember: All code must follow TypeScript strict mode\\\"}}'\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n---\n\n## Hook Script Example: Frontmatter Validation\n\nTypeScript validation script for PreToolUse hooks.\n\n**File:** `hooks/scripts/validate-frontmatter.ts`\n\n```typescript\n#!/usr/bin/env npx ts-node\n\nimport * as fs from 'fs';\n\ninterface HookInput {\n  tool: string;\n  tool_input: {\n    file_path?: string;\n    content?: string;\n  };\n}\n\ninterface ValidationResult {\n  decision: 'allow' | 'block';\n  reason?: string;\n}\n\nfunction parseYamlFrontmatter(content: string): Record<string, unknown> | null {\n  const match = content.match(/^---\\r?\\n([\\s\\S]*?)\\r?\\n---/);\n  if (!match) return null;\n\n  // Simple YAML parsing for frontmatter\n  const yaml = match[1];\n  const result: Record<string, unknown> = {};\n\n  for (const line of yaml.split('\\n')) {\n    const colonIndex = line.indexOf(':');\n    if (colonIndex > 0) {\n      const key = line.slice(0, colonIndex).trim();\n      const value = line.slice(colonIndex + 1).trim();\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\nfunction validate(input: HookInput): ValidationResult {\n  const filePath = input.tool_input.file_path || '';\n  const content = input.tool_input.content || '';\n\n  // Only validate markdown files in plugin directories\n  if (!filePath.endsWith('.md')) {\n    return { decision: 'allow' };\n  }\n\n  if (!filePath.match(/\\/(skills|commands|agents)\\//)) {\n    return { decision: 'allow' };\n  }\n\n  // Check for YAML frontmatter\n  const frontmatter = parseYamlFrontmatter(content);\n  if (!frontmatter) {\n    return {\n      decision: 'block',\n      reason: 'Plugin markdown files require YAML frontmatter (starting with ---)'\n    };\n  }\n\n  // Validate based on file type\n  if (filePath.includes('/skills/') && filePath.endsWith('SKILL.md')) {\n    if (!frontmatter.name || !frontmatter.description) {\n      return {\n        decision: 'block',\n        reason: 'SKILL.md requires \"name\" and \"description\" in frontmatter'\n      };\n    }\n  }\n\n  if (filePath.includes('/agents/') && !filePath.includes('/skills/')) {\n    const required = ['name', 'description', 'model', 'tools'];\n    const missing = required.filter(f => !frontmatter[f]);\n    if (missing.length > 0) {\n      return {\n        decision: 'block',\n        reason: `Agent file missing required fields: ${missing.join(', ')}`\n      };\n    }\n  }\n\n  if (filePath.includes('/commands/')) {\n    if (!frontmatter.description) {\n      return {\n        decision: 'block',\n        reason: 'Command file requires \"description\" in frontmatter'\n      };\n    }\n  }\n\n  return { decision: 'allow' };\n}\n\n// Main execution\nconst inputData = fs.readFileSync(0, 'utf-8');\nconst input: HookInput = JSON.parse(inputData);\nconst result = validate(input);\n\nif (result.decision === 'block') {\n  console.log(JSON.stringify(result));\n}\n\nprocess.exit(0);\n```\n\n---\n\n## Minimal Examples\n\n### Minimal Skill\n\n```yaml\n---\nname: my-skill\ndescription: Use when [trigger condition]. Provides [capability].\n---\n\n# My Skill\n\n[What this skill does]\n\n## When This Skill Activates\n\n- [Condition 1]\n- [Condition 2]\n```\n\n### Minimal Command\n\n```yaml\n---\ndescription: What this command does\n---\n\n[Command instructions]\n```\n\n### Minimal Agent\n\n```yaml\n---\nname: my-agent\ndescription: What this agent does autonomously\nmodel: sonnet\ntools: Read, Write, Grep, Glob\n---\n\n[Agent instructions and protocol]\n```\n",
        "plugins/lt-dev/skills/developing-claude-plugins/reference.md": "# Claude Code Plugin Development Reference\n\n## Table of Contents\n\n- [Official Documentation URLs](#official-documentation-urls)\n- [Element Comparison Matrix](#element-comparison-matrix)\n- [Frontmatter Field Reference](#frontmatter-field-reference)\n- [Tool Names for Agents](#tool-names-for-agents)\n- [Event Types for Hooks](#event-types-for-hooks)\n- [Model Selection Guide for Agents](#model-selection-guide-for-agents)\n- [Directory Structure Conventions](#directory-structure-conventions)\n- [Naming Conventions](#naming-conventions)\n- [Description Writing Guidelines](#description-writing-guidelines)\n- [Complete Examples](#complete-examples)\n\n---\n\n## Official Documentation URLs\n\nThese are the authoritative sources for Claude Code plugin development. **Always fetch before implementation.**\n\n### Primary URLs\n\n| Topic | URL |\n|-------|-----|\n| Plugins & Marketplaces | https://code.claude.com/docs/en/plugins |\n| Skills | https://code.claude.com/docs/en/skills |\n| Slash Commands | https://code.claude.com/docs/en/slash-commands |\n| Subagents | https://code.claude.com/docs/en/sub-agents |\n| Hooks | https://code.claude.com/docs/en/hooks |\n\n### Additional Resources\n\n| Topic | URL |\n|-------|-----|\n| Claude Code Overview | https://code.claude.com/docs/en/overview |\n| Configuration | https://code.claude.com/docs/en/settings |\n| MCP Servers | https://code.claude.com/docs/en/mcp |\n| CLI Reference | https://code.claude.com/docs/en/cli-reference |\n\n### Fallback Strategy\n\nIf URLs return 404 or fail to load:\n\n1. **WebSearch:** Use query `\"Claude Code [topic] documentation site:claude.com\"`\n2. **Alternative domains:** Try `docs.claude.com` or `docs.anthropic.com`\n3. **Report:** Note broken URLs for update in `/CLAUDE.md`\n\n---\n\n## Element Comparison Matrix\n\n| Feature | Skill | Command | Agent | Hook |\n|---------|-------|---------|-------|------|\n| **Activation** | Auto/Manual | User `/command` | Task tool | Event |\n| **Persistence** | Session | One-time | Isolated | Event-scoped |\n| **Tool Access** | All | All | Specified | Script-based |\n| **User Interaction** | Yes | Yes | Limited | No |\n| **Autonomous** | No | No | Yes | Yes |\n| **Best For** | Expertise | Workflows | Complex tasks | Automation |\n\n---\n\n## Frontmatter Field Reference\n\n### Skills (SKILL.md)\n\n```yaml\n---\nname: string          # Required. Kebab-case identifier\ndescription: string   # Required. Max 280 chars. WHEN to use\nallowed-tools: string # Optional. Restrict tools: Read, Grep, Glob, etc.\n---\n```\n\n**Note on `allowed-tools`:** Use this to restrict which tools Claude can use when the skill is active. Useful for read-only skills or skills that should not modify files.\n\n### Commands\n\n```yaml\n---\ndescription: string              # Required. WHAT it does (for /help)\nargument-hint: string            # Optional. Shows expected args, e.g., \"[message]\" or \"[pr-number] [priority]\"\nallowed-tools: string            # Optional. Restrict tools, e.g., \"Bash(git:*), Read, Grep\"\nmodel: string                    # Optional. Force specific model, e.g., \"claude-3-5-haiku-20241022\"\ndisable-model-invocation: bool   # Optional. Prevent SlashCommand tool from calling this command\n---\n```\n\n**Argument variables:**\n- `$ARGUMENTS` - All arguments as single string\n- `$1`, `$2`, `$3` - Positional arguments\n\n### Agents\n\n```yaml\n---\nname: string              # Required. Kebab-case identifier\ndescription: string       # Required. When/what for agent spawning\nmodel: string             # Required. sonnet | opus | haiku\ntools: string             # Required. Comma-separated tool names\npermissionMode: string    # Optional. default | bypassPermissions\nskills: string            # Optional. Comma-separated skill names\n---\n```\n\n### Hooks (hooks.json)\n\n```json\n{\n  \"hooks\": [\n    {\n      \"name\": \"string\",        // Required. Hook identifier\n      \"event\": \"string\",       // Required. Event type\n      \"command\": \"string\",     // Required. Script path + args\n      \"description\": \"string\"  // Optional. Human-readable description\n    }\n  ]\n}\n```\n\n---\n\n## Tool Names for Agents\n\nAvailable tools that can be specified in agent `tools` field:\n\n| Tool | Purpose |\n|------|---------|\n| `Bash` | Execute shell commands |\n| `Read` | Read file contents |\n| `Write` | Create/overwrite files |\n| `Edit` | Modify existing files |\n| `Glob` | Find files by pattern |\n| `Grep` | Search file contents |\n| `WebFetch` | Fetch and analyze URLs |\n| `WebSearch` | Search the web |\n| `Task` | Spawn sub-agents |\n| `TodoWrite` | Manage task lists |\n| `AskUserQuestion` | Get user input |\n\n---\n\n## Event Types for Hooks\n\n| Event | Trigger | Use Case |\n|-------|---------|----------|\n| `PreToolUse` | Before tool execution | Validation, input modification |\n| `PostToolUse` | After tool execution | Cleanup, notifications |\n| `UserPromptSubmit` | User sends message | Context injection |\n| `Notification` | System notification | Alerting |\n| `Stop` | Main agent finishes | Cleanup, summary |\n| `SubagentStop` | Subagent finishes | Result processing |\n| `SessionStart` | Session begins | Environment setup |\n| `SessionEnd` | Session ends | Cleanup |\n| `PreCompact` | Before compacting | Context preservation |\n| `PermissionRequest` | Permission dialog | Auto-approve/deny |\n\n---\n\n## Model Selection Guide for Agents\n\n| Model | When to Use |\n|-------|-------------|\n| `haiku` | Fast, simple tasks. Low cost. Good for repetitive operations. |\n| `sonnet` | Default choice. Balanced speed/quality. Most tasks. |\n| `opus` | Complex reasoning. Critical decisions. High-stakes operations. |\n\n---\n\n## Directory Structure Conventions\n\n```\nplugins/\n‚îî‚îÄ‚îÄ plugin-name/\n    ‚îú‚îÄ‚îÄ plugin.json              # Plugin manifest\n    ‚îú‚îÄ‚îÄ agents/\n    ‚îÇ   ‚îî‚îÄ‚îÄ agent-name.md        # One file per agent\n    ‚îú‚îÄ‚îÄ commands/\n    ‚îÇ   ‚îú‚îÄ‚îÄ simple-command.md    # Top-level commands\n    ‚îÇ   ‚îî‚îÄ‚îÄ category/            # Grouped commands\n    ‚îÇ       ‚îî‚îÄ‚îÄ sub-command.md\n    ‚îú‚îÄ‚îÄ hooks/\n    ‚îÇ   ‚îú‚îÄ‚îÄ hooks.json           # Hook definitions\n    ‚îÇ   ‚îî‚îÄ‚îÄ scripts/             # Hook handler scripts\n    ‚îÇ       ‚îî‚îÄ‚îÄ handler.ts\n    ‚îî‚îÄ‚îÄ skills/\n        ‚îî‚îÄ‚îÄ skill-name/          # One directory per skill\n            ‚îú‚îÄ‚îÄ SKILL.md         # Main skill file (required)\n            ‚îú‚îÄ‚îÄ reference.md     # Reference documentation\n            ‚îî‚îÄ‚îÄ examples.md      # Usage examples\n```\n\n---\n\n## Naming Conventions\n\n| Element | Convention | Example |\n|---------|------------|---------|\n| Plugin | kebab-case | `lt-dev` |\n| Skill directory | kebab-case | `generating-nest-servers` |\n| Skill name | kebab-case | `generating-nest-servers` |\n| Command file | kebab-case | `create-story.md` |\n| Agent file | kebab-case | `npm-package-maintainer.md` |\n| Hook name | kebab-case | `pre-tool-validation` |\n\n---\n\n## Description Writing Guidelines\n\n### Skills\nFocus on **WHEN** - triggers auto-detection:\n- \"Use when working with NestJS and @lenne.tech/nest-server...\"\n- \"Expert for creating user stories with TDD...\"\n- \"Use when performing package maintenance...\"\n\n### Commands\nFocus on **WHAT** - describes the action:\n- \"Create a user story for TDD implementation\"\n- \"Generate commit message with alternatives\"\n- \"Perform security review of code changes\"\n\n### Agents\nFocus on **WHAT + WHEN** - for Task tool matching:\n- \"Specialized agent for maintaining npm packages. Use when...\"\n- \"Expert agent for code review. Spawned after significant changes...\"\n\n---\n\n## Complete Examples\n\nFor detailed, copy-paste-ready examples of each element type, see **[examples.md](examples.md)**.\n\nQuick reference for minimal implementations:\n\n### Minimal Skill\n```yaml\n---\nname: my-skill\ndescription: Use when [trigger]. Provides [capability].\n---\n# Title\n[Content]\n```\n\n### Minimal Command\n```yaml\n---\ndescription: What this command does\n---\n[Instructions]\n```\n\n### Minimal Agent\n```yaml\n---\nname: my-agent\ndescription: What this agent does\nmodel: sonnet\ntools: Read, Write, Grep, Glob\n---\n[Protocol]\n```\n",
        "plugins/lt-dev/skills/developing-lt-frontend/SKILL.md": "---\nname: developing-lt-frontend\ndescription: PRIMARY expert for ALL Nuxt and Vue frontend tasks. ALWAYS use this skill when working with Nuxt 4, Vue components, Nuxt UI, frontend pages, or files in app/components/, app/composables/, app/pages/, app/interfaces/ (supports monorepos with projects/app/, packages/app/). Handles modals (useOverlay), forms (Valibot), API integration (types.gen.ts, sdk.gen.ts), authentication (Better Auth), TailwindCSS styling, useFetch, useState, SSR. ALWAYS activate for .vue files, nuxt.config.ts, or frontend development. NOT for NestJS backend (use generating-nest-servers).\n---\n\n# lenne.tech Frontend Development\n\n## When to Use This Skill\n\n- Working with Nuxt 4 projects (nuxt.config.ts present)\n- Editing files in `app/components/`, `app/composables/`, `app/pages/`, `app/interfaces/`\n- Creating or modifying Vue components with Nuxt UI\n- Integrating backend APIs via generated types (`types.gen.ts`, `sdk.gen.ts`)\n- Building forms with Valibot validation\n- Implementing authentication (login, register, 2FA, passkeys)\n- Working in monorepos with `projects/app/` or `packages/app/` structure\n\n**NOT for:** NestJS backend development (use `generating-nest-servers` skill instead)\n\n## Development Approach: Real Backend Integration FIRST\n\n**CRITICAL: Always implement with real backend integration immediately!**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  ‚ùå FORBIDDEN:                                                 ‚îÇ\n‚îÇ  - Placeholder data: const items = ['Item 1', 'Item 2']        ‚îÇ\n‚îÇ  - TODO comments: // TODO: Connect to API later                ‚îÇ\n‚îÇ  - Mock functions: async function fetchData() { return [] }    ‚îÇ\n‚îÇ  - Dummy interfaces: interface Item { name: string }           ‚îÇ\n‚îÇ  - \"We'll add the API call later\"                              ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  ‚úÖ REQUIRED:                                                  ‚îÇ\n‚îÇ  - Real API calls from the start                               ‚îÇ\n‚îÇ  - Generated types (types.gen.ts)                              ‚îÇ\n‚îÇ  - Generated SDK functions (sdk.gen.ts)                        ‚îÇ\n‚îÇ  - Feature-by-feature with full backend integration            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Workflow for each feature:**\n\n1. **Ensure services are running** (API on 3000, App on 3001)\n2. **Generate types first** (`npm run generate-types`)\n3. **Create composable** with real SDK functions\n4. **Build component** using the composable\n5. **Test in browser** with real data\n6. **Move to next feature** only when current one works\n\n**Example - The RIGHT way:**\n\n```typescript\n// ‚úÖ CORRECT: Real integration from the start\nimport type { ProductDto } from '~/api-client/types.gen'\nimport { productControllerFindAll } from '~/api-client/sdk.gen'\n\nexport function useProducts() {\n  const products = ref<ProductDto[]>([])\n\n  async function fetchAll() {\n    const response = await productControllerFindAll()\n    if (response.data) products.value = response.data\n  }\n\n  return { products: readonly(products), fetchAll }\n}\n```\n\n```typescript\n// ‚ùå WRONG: Placeholder approach\ninterface Product { name: string }  // Manual interface!\nconst products = ref<Product[]>([\n  { name: 'Placeholder 1' },  // Fake data!\n  { name: 'Placeholder 2' }\n])\n// TODO: Connect to API  // Deferred work!\n```\n\n**Why this matters:**\n- Placeholders hide integration issues until later\n- Manual interfaces drift from backend DTOs\n- \"Later\" often means bugs discovered too late\n- Real data reveals edge cases immediately\n\n## Test-Driven Development (TDD)\n\n**For frontend features, follow the TDD approach:**\n\n```\n1. Backend API must be complete (API tests pass)\n2. Write E2E tests BEFORE implementing frontend\n3. Implement components/pages until E2E tests pass\n4. Debug with Chrome DevTools MCP\n```\n\n**Complete E2E testing guide: [reference/e2e-testing.md](./reference/e2e-testing.md)**\n\n### Quick E2E Test Example\n\n```typescript\n// tests/e2e/products.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest('should create product', async ({ page }) => {\n  await page.goto('/products');\n  await page.click('[data-testid=\"create\"]');\n  await page.fill('[data-testid=\"name\"]', `Test-${Date.now()}`);\n  await page.click('[data-testid=\"submit\"]');\n  await expect(page.locator('text=erfolgreich')).toBeVisible();\n});\n```\n\n### Test Cleanup (CRITICAL)\n\n**Every E2E test must clean up after itself:**\n\n```typescript\ntest.afterAll(async ({ request }) => {\n  for (const id of createdIds) {\n    await request.delete(`/api/products/${id}`);\n  }\n});\n```\n\n**Use separate test database:** `app-test` instead of `app-dev`\n\n## Related Skills\n\n**Works closely with:**\n- `generating-nest-servers` - For NestJS backend development (projects/api/)\n- `using-lt-cli` - For Git operations and Fullstack initialization\n- `building-stories-with-tdd` - For complete TDD workflow (Backend + Frontend)\n\n**When to use which:**\n- .vue files, Nuxt, Vue components? Use **this skill** (developing-lt-frontend)\n- NestJS, services, controllers? Use `generating-nest-servers` skill\n- Git operations, `lt` commands? Use `using-lt-cli` skill\n- Complete TDD workflow (tests first)? Use `building-stories-with-tdd` skill\n\n**In monorepo projects:**\n- `projects/app/` or `packages/app/` ‚Üí **This skill**\n- `projects/api/` or `packages/api/` ‚Üí `generating-nest-servers` skill\n\n## TypeScript Language Server (Recommended)\n\n**Use the LSP tool when available** for better code intelligence in TypeScript/Vue/Nuxt projects:\n\n| Operation | Use Case |\n|-----------|----------|\n| `goToDefinition` | Find where a type, composable, or component is defined |\n| `findReferences` | Find all usages of a symbol across the codebase |\n| `hover` | Get type information for props, refs, and computed values |\n| `documentSymbol` | List all exports, functions, and types in a file |\n| `workspaceSymbol` | Search for composables, interfaces, or components |\n| `goToImplementation` | Find implementations of interfaces |\n\n**When to use LSP:**\n- Finding where a type from `types.gen.ts` is used ‚Üí `findReferences`\n- Understanding composable structure ‚Üí `documentSymbol`\n- Navigating to type definitions ‚Üí `goToDefinition`\n- Searching for components or composables ‚Üí `workspaceSymbol`\n\n**Installation (if LSP not available):**\n```bash\nclaude plugins install typescript-lsp --marketplace claude-plugins-official\n```\n\n## Service Health Check (MANDATORY)\n\n**Before starting ANY frontend work, check if required services are running:**\n\n```bash\n# Check if API is running (Port 3000)\ncurl -s -o /dev/null -w \"%{http_code}\" http://localhost:3000/api\n\n# Check if App is running (Port 3001)\ncurl -s -o /dev/null -w \"%{http_code}\" http://localhost:3001\n```\n\n**Workflow:**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  BEFORE starting frontend work:                                ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  1. CHECK API (Port 3000):                                     ‚îÇ\n‚îÇ     curl -s -o /dev/null -w \"%{http_code}\" localhost:3000/api  ‚îÇ\n‚îÇ     - If NOT 200: Start API in background                      ‚îÇ\n‚îÇ       cd projects/api && npm run start:dev &                   ‚îÇ\n‚îÇ     - Wait until API responds (max 30s)                        ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  2. CHECK APP (Port 3001):                                     ‚îÇ\n‚îÇ     curl -s -o /dev/null -w \"%{http_code}\" localhost:3001      ‚îÇ\n‚îÇ     - If NOT 200: Start App in background                      ‚îÇ\n‚îÇ       cd projects/app && npm run dev &                         ‚îÇ\n‚îÇ     - Wait until App responds (max 30s)                        ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  3. ONLY THEN proceed with frontend development                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Starting Services (if not running):**\n\n```bash\n# Start API in background (from monorepo root)\ncd projects/api && npm run start:dev &\n\n# Start App in background (from monorepo root)\ncd projects/app && npm run dev &\n```\n\n**Important:**\n- Always check BEFORE starting to avoid duplicate processes\n- Use `lsof -i :3000` or `lsof -i :3001` to check if port is already in use\n- If port is in use but service not responding, investigate before starting another instance\n\n## Browser Testing (Chrome DevTools MCP)\n\n**After implementing each feature, verify it works in the browser!**\n\n**Available Tools:**\n| Tool | Use Case |\n|------|----------|\n| `mcp__chrome-devtools__navigate_page` | Navigate to URL |\n| `mcp__chrome-devtools__take_snapshot` | Get page structure with UIDs (preferred) |\n| `mcp__chrome-devtools__take_screenshot` | Visual verification |\n| `mcp__chrome-devtools__click` / `fill` | Interact with elements |\n| `mcp__chrome-devtools__list_console_messages` | Check for JS errors |\n| `mcp__chrome-devtools__list_network_requests` | Debug API calls |\n\n**Workflow after each feature:**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  AFTER implementing a feature:                                 ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  1. NAVIGATE to the page:                                      ‚îÇ\n‚îÇ     mcp__chrome-devtools__navigate_page(url: \"localhost:3001\") ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  2. TAKE SNAPSHOT (preferred over screenshot):                 ‚îÇ\n‚îÇ     mcp__chrome-devtools__take_snapshot()                      ‚îÇ\n‚îÇ     - Check if on correct page (middleware may redirect)       ‚îÇ\n‚îÇ     - If redirected to /login: Handle authentication first     ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  3. CHECK CONSOLE for errors:                                  ‚îÇ\n‚îÇ     mcp__chrome-devtools__list_console_messages(types: error)  ‚îÇ\n‚îÇ     - Fix any JavaScript errors before proceeding              ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  4. VERIFY API calls work:                                     ‚îÇ\n‚îÇ     mcp__chrome-devtools__list_network_requests()              ‚îÇ\n‚îÇ     - Check for failed requests (4xx, 5xx)                     ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  5. ONLY proceed to next feature when current one works        ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Authentication Handling:**\n- Most pages require login\n- If redirected to `/login` or `/auth/login`: Ask user for credentials\n- Use `fill` and `click` tools to authenticate\n- Then navigate back to intended page\n\n## Nuxt UI MCP (Component Documentation)\n\n**Use the Nuxt UI MCP tools for component documentation:**\n\n| Tool | Use Case |\n|------|----------|\n| `mcp__nuxt-ui-remote__list-components` | List all available components |\n| `mcp__nuxt-ui-remote__get-component` | Get component documentation |\n| `mcp__nuxt-ui-remote__get-component-metadata` | Get props, slots, events |\n| `mcp__nuxt-ui-remote__search-components-by-category` | Find components by category |\n| `mcp__nuxt-ui-remote__list-composables` | List available composables |\n\n**When to use:**\n- Before using a Nuxt UI component you haven't used before\n- When unsure about available props or slots\n- When looking for the right component for a use case\n\n## Error Recovery\n\n**For detailed troubleshooting workflows, see [reference/troubleshooting.md](./reference/troubleshooting.md)**\n\n**Quick fixes:**\n- Type generation fails ‚Üí Check if API is running on port 3000\n- API won't start ‚Üí Check `lsof -i :3000`, kill stale processes\n- Build fails ‚Üí Run `npm run generate-types`, check imports\n- Console errors ‚Üí Use `mcp__chrome-devtools__list_console_messages`\n\n## Nuxt 4 Directory Structure\n\n```\napp/                  # Application code (srcDir)\n‚îú‚îÄ‚îÄ components/       # Auto-imported components\n‚îú‚îÄ‚îÄ composables/      # Auto-imported composables\n‚îú‚îÄ‚îÄ interfaces/       # TypeScript interfaces\n‚îú‚îÄ‚îÄ lib/              # Utility libraries (auth-client, etc.)\n‚îú‚îÄ‚îÄ pages/            # File-based routing\n‚îú‚îÄ‚îÄ layouts/          # Layout components\n‚îú‚îÄ‚îÄ utils/            # Auto-imported utilities\n‚îî‚îÄ‚îÄ api-client/       # Generated types & SDK\nserver/               # Nitro server routes\npublic/               # Static assets\nnuxt.config.ts\n```\n\n## Type Rules\n\n**CRITICAL: Never create custom interfaces for backend DTOs!**\n\n| Priority | Source | Use For |\n|----------|--------|---------|\n| 1. | `~/api-client/types.gen.ts` | All backend DTOs (REQUIRED) |\n| 2. | `~/api-client/sdk.gen.ts` | All API calls (REQUIRED) |\n| 3. | Nuxt UI types | Component props (auto-imported) |\n| 4. | `app/interfaces/*.interface.ts` | Frontend-only types (UI state, forms) |\n\n### Missing Generated Types\n\n**If `types.gen.ts` or `sdk.gen.ts` are missing/outdated:** See [reference/troubleshooting.md](./reference/troubleshooting.md#missing-generated-types)\n\n**Key rules:**\n- ‚ùå NEVER create manual interfaces as workaround\n- ‚úÖ Always run `npm run generate-types` with API running\n\n### Generating Types\n\n**Prerequisites:** Backend API must be running!\n\n```bash\n# Start API first (in monorepo)\ncd projects/api && npm run start:dev\n\n# Wait for API to be ready (check http://localhost:3000/api)\n\n# Then generate types (from frontend directory)\nnpm run generate-types\n```\n\n## Core Patterns\n\n### API Calls (via generated SDK)\n\n```typescript\nimport type { SeasonDto } from '~/api-client/types.gen'\nimport { seasonControllerGet } from '~/api-client/sdk.gen'\n\nconst response = await seasonControllerGet()\nconst seasons: SeasonDto[] = response.data ?? []\n```\n\n### Composables (one per controller)\n\n```typescript\nexport function useSeasons() {\n  const seasons = ref<SeasonDto[]>([])\n  const loading = ref<boolean>(false)\n\n  async function fetchSeasons(): Promise<void> {\n    loading.value = true\n    try {\n      const response = await seasonControllerGet()\n      if (response.data) seasons.value = response.data\n    } finally {\n      loading.value = false\n    }\n  }\n\n  return { seasons: readonly(seasons), loading: readonly(loading), fetchSeasons }\n}\n```\n\n### Shared State (useState)\n\n```typescript\n// For state shared across components (SSR-safe)\nexport function useSettings() {\n  const theme = useState<'light' | 'dark'>('app-theme', () => 'light')\n  return { theme }\n}\n```\n\n### Authentication (Better Auth)\n\n```typescript\n// app/composables/use-better-auth.ts (pre-configured in nuxt-base-starter)\nimport { authClient } from '~/lib/auth-client'\n\nexport function useBetterAuth() {\n  const session = authClient.useSession(useFetch)\n\n  const user = computed(() => session.data.value?.user ?? null)\n  const isAuthenticated = computed<boolean>(() => !!session.data.value?.session)\n  const isAdmin = computed<boolean>(() => user.value?.role === 'admin')\n\n  return {\n    user, isAuthenticated, isAdmin,\n    signIn: authClient.signIn,   // Password auto-hashed (SHA256)\n    signUp: authClient.signUp,   // Password auto-hashed (SHA256)\n    signOut: authClient.signOut,\n    twoFactor: authClient.twoFactor,\n    passkey: authClient.passkey,\n  }\n}\n```\n\n**Preferred auth methods:** Passkey (WebAuthn) or Email/Password + 2FA (TOTP)\n**Base path:** `/iam` (must match nest-server config)\n\n### Programmatic Modals\n\n```typescript\nconst overlay = useOverlay()\n\noverlay.open(ModalCreate, {\n  props: { title: 'Neu' },\n  onClose: (result) => { if (result) refreshData() }\n})\n```\n\n### Valibot Forms (not Zod)\n\n```typescript\nimport { object, pipe, string, minLength } from 'valibot'\nimport type { InferOutput } from 'valibot'\n\nconst schema = object({\n  title: pipe(string(), minLength(3, 'Mindestens 3 Zeichen'))\n})\ntype Schema = InferOutput<typeof schema>\nconst state = reactive<Schema>({ title: '' })\n```\n\n## Standards\n\n| Rule | Value |\n|------|-------|\n| UI Labels | German (`Speichern`, `Abbrechen`) |\n| Code/Comments | English |\n| Styling | TailwindCSS only, no `<style>` |\n| Colors | Semantic only (`primary`, `error`, `success`), no hardcoded |\n| Types | Explicit, no implicit `any` |\n| Backend Types | **Generated only** (`types.gen.ts`) |\n| Custom Interfaces | Frontend-only (`app/interfaces/*.interface.ts`) |\n| Composables | `app/composables/use*.ts` |\n| Shared State | `useState()` for SSR-safe state |\n| Local State | `ref()` / `reactive()` |\n\n## Reference Files\n\n| Topic | File |\n|-------|------|\n| TypeScript | [reference/typescript.md](./reference/typescript.md) |\n| Components | [reference/components.md](./reference/components.md) |\n| Composables | [reference/composables.md](./reference/composables.md) |\n| Forms | [reference/forms.md](./reference/forms.md) |\n| Modals | [reference/modals.md](./reference/modals.md) |\n| API | [reference/api.md](./reference/api.md) |\n| Colors | [reference/colors.md](./reference/colors.md) |\n| Nuxt Patterns | [reference/nuxt.md](./reference/nuxt.md) |\n| Authentication | [reference/authentication.md](./reference/authentication.md) |\n| **E2E Testing** | [reference/e2e-testing.md](./reference/e2e-testing.md) |\n| Troubleshooting | [reference/troubleshooting.md](./reference/troubleshooting.md) |\n| **Security** | [reference/security.md](./reference/security.md) |\n\n## Pre-Commit\n\n**Backend Integration (CRITICAL):**\n- [ ] **No placeholder data** (no fake arrays, no dummy objects)\n- [ ] **No TODO comments for API integration** (integrate immediately)\n- [ ] **No manual interfaces for backend DTOs** (use `types.gen.ts`)\n- [ ] All API calls via `sdk.gen.ts`\n- [ ] Types regenerated after backend changes (`npm run generate-types`)\n- [ ] Each feature fully integrated before starting next\n\n**Code Quality:**\n- [ ] Logic in composables\n- [ ] Modals use `useOverlay`\n- [ ] Forms use Valibot\n- [ ] TailwindCSS only\n- [ ] **Semantic colors only** (`primary`, `error`, `success`), no hardcoded colors\n- [ ] German UI, English code\n- [ ] No implicit `any`\n- [ ] ESLint passes\n\n**Authentication:**\n- [ ] Auth uses `useBetterAuth()` composable (pre-configured)\n- [ ] Protected routes use `middleware: 'auth'`\n- [ ] Auth base path is `/iam` (nest-server default)\n\n**Security (OWASP):**\n- [ ] **No v-html with user content** (see [security.md](./reference/security.md))\n- [ ] **Tokens stored securely** (not in localStorage)\n- [ ] Input validation with Valibot schemas\n\n**Browser Verification:**\n- [ ] Feature tested in browser (Chrome DevTools MCP)\n- [ ] No console errors (`list_console_messages`)\n- [ ] API calls successful (`list_network_requests`)\n- [ ] Page renders correctly (snapshot or screenshot)\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/api.md": "# API Integration\n\n## Table of Contents\n\n- [Generated Files (REQUIRED)](#generated-files-required)\n- [MANDATORY: Missing Types Workflow](#-mandatory-missing-types-workflow)\n- [Basic Usage](#basic-usage)\n- [Composable Pattern](#composable-pattern)\n- [Error Handling](#error-handling)\n- [With Toast Notifications](#with-toast-notifications)\n\n---\n\n## Generated Files (REQUIRED)\n\n**NEVER create custom interfaces for backend DTOs!**\n\n| File | Purpose |\n|------|---------|\n| `~/api-client/types.gen.ts` | All backend DTOs (REQUIRED) |\n| `~/api-client/sdk.gen.ts` | All API functions (REQUIRED) |\n\n## ‚ö†Ô∏è MANDATORY: Missing Types Workflow\n\n**If generated files are missing, you MUST ask the user - NEVER create manual interfaces!**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  STOP! types.gen.ts or sdk.gen.ts missing?                     ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  Step 1: ASK USER                                              ‚îÇ\n‚îÇ  \"Die generierten API-Types fehlen. L√§uft die Backend-API      ‚îÇ\n‚îÇ   unter http://localhost:3000?\"                                ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  Step 2: GENERATE TYPES                                        ‚îÇ\n‚îÇ  - If API running ‚Üí npm run generate-types                     ‚îÇ\n‚îÇ  - If API not running ‚Üí Ask user to start it first             ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  Step 3: WAIT FOR COMPLETION                                   ‚îÇ\n‚îÇ  - Verify types.gen.ts exists after generation                 ‚îÇ\n‚îÇ  - Then continue with implementation                           ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  ‚ùå FORBIDDEN: Creating manual interfaces                      ‚îÇ\n‚îÇ  ‚ùå FORBIDDEN: Skipping this workflow                          ‚îÇ\n‚îÇ  ‚ùå FORBIDDEN: \"I'll create the types manually\"                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### Generating Types\n\n**Prerequisites:** Backend API must be running!\n\n```bash\n# 1. Start API first (in monorepo)\ncd projects/api && npm run start:dev\n\n# 2. Wait for API to be ready (check http://localhost:3000/api)\n\n# 3. Generate types (from frontend directory)\nnpm run generate-types\n```\n\n### When to Regenerate\n\n- After adding/modifying backend DTOs\n- After adding/modifying controllers\n- After changing API endpoints\n- When `types.gen.ts` is missing or outdated\n\n## Basic Usage\n\n```typescript\nimport type { SeasonDto, CreateSeasonDto } from '~/api-client/types.gen'\nimport { seasonControllerGet, seasonControllerCreate } from '~/api-client/sdk.gen'\n\n// GET all\nconst response = await seasonControllerGet()\nconst seasons: SeasonDto[] = response.data ?? []\n\n// GET by ID\nconst response = await seasonControllerGetById({ path: { id: '123' } })\nconst season: SeasonDto | null = response.data ?? null\n\n// POST\nconst response = await seasonControllerCreate({ body: createDto })\nconst created: SeasonDto | null = response.data ?? null\n\n// PUT\nconst response = await seasonControllerUpdate({\n  path: { id: '123' },\n  body: updateDto\n})\n\n// DELETE\nawait seasonControllerDelete({ path: { id: '123' } })\n```\n\n## Composable Pattern\n\nOne composable per backend controller:\n\n```typescript\n// app/composables/useSeasons.ts\nimport { ref, readonly } from 'vue'\nimport type { SeasonDto, CreateSeasonDto } from '~/api-client/types.gen'\nimport { seasonControllerGet, seasonControllerCreate } from '~/api-client/sdk.gen'\n\nexport function useSeasons() {\n  const seasons = ref<SeasonDto[]>([])\n  const loading = ref<boolean>(false)\n\n  async function fetchAll(): Promise<void> {\n    loading.value = true\n    try {\n      const response = await seasonControllerGet()\n      if (response.data) seasons.value = response.data\n    } finally {\n      loading.value = false\n    }\n  }\n\n  async function create(data: CreateSeasonDto): Promise<SeasonDto | null> {\n    loading.value = true\n    try {\n      const response = await seasonControllerCreate({ body: data })\n      if (response.data) {\n        seasons.value.push(response.data)\n        return response.data\n      }\n      return null\n    } finally {\n      loading.value = false\n    }\n  }\n\n  return {\n    seasons: readonly(seasons),\n    loading: readonly(loading),\n    create,\n    fetchAll\n  }\n}\n```\n\n## Error Handling\n\n```typescript\nasync function fetchSeasons(): Promise<void> {\n  loading.value = true\n  error.value = null\n\n  try {\n    const response = await seasonControllerGet()\n    if (response.data) seasons.value = response.data\n  } catch (e) {\n    error.value = 'Fehler beim Laden'\n    console.error('Fetch failed:', e)\n  } finally {\n    loading.value = false\n  }\n}\n```\n\n## With Toast Notifications\n\n```typescript\nconst toast = useToast()\n\nasync function create(data: CreateSeasonDto): Promise<SeasonDto | null> {\n  try {\n    const response = await seasonControllerCreate({ body: data })\n    if (response.data) {\n      toast.add({ title: 'Erfolgreich erstellt', color: 'success' })\n      return response.data\n    }\n    return null\n  } catch (e) {\n    toast.add({ title: 'Fehler beim Erstellen', color: 'error' })\n    return null\n  }\n}\n```\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/authentication.md": "# Authentication (Better Auth)\n\nlenne.tech projects use [Better Auth](https://www.better-auth.com/) for authentication, integrated with the @lenne.tech/nest-server backend.\n\n## Table of Contents\n\n- [Preferred Authentication Methods](#preferred-authentication-methods)\n- [Client Setup (nuxt-base-starter)](#client-setup-nuxt-base-starter)\n- [Crypto Utility](#crypto-utility)\n- [useBetterAuth Composable](#usebetterauth-composable)\n- [Auth Middleware](#auth-middleware)\n- [Basic Usage Examples](#basic-usage-examples)\n- [Environment Configuration](#environment-configuration)\n- [Pre-built Auth Pages (nuxt-base-starter)](#pre-built-auth-pages-nuxt-base-starter)\n- [Key Patterns](#key-patterns)\n- [Anti-Patterns](#anti-patterns)\n\n---\n\n## Preferred Authentication Methods\n\n| Priority | Method | Description |\n|----------|--------|-------------|\n| 1. | **Passkey** | WebAuthn-based, passwordless (recommended) |\n| 2. | **Email + Password + 2FA** | Traditional with TOTP second factor |\n\n## Client Setup (nuxt-base-starter)\n\nThe auth client is pre-configured in `app/lib/auth-client.ts`:\n\n```typescript\n// app/lib/auth-client.ts\nimport { passkeyClient } from '@better-auth/passkey/client'\nimport { adminClient, twoFactorClient } from 'better-auth/client/plugins'\nimport { createAuthClient } from 'better-auth/vue'\n\nimport { sha256 } from '~/utils/crypto'\n\n// =============================================================================\n// Type Definitions\n// =============================================================================\n\nexport interface AuthResponse {\n  data?: null | {\n    redirect?: boolean\n    token?: null | string\n    url?: string\n    user?: {\n      createdAt?: Date\n      email?: string\n      emailVerified?: boolean\n      id?: string\n      image?: string\n      name?: string\n      updatedAt?: Date\n    }\n  }\n  error?: null | {\n    code?: string\n    message?: string\n    status?: number\n  }\n}\n\n// =============================================================================\n// Base Client Configuration\n// =============================================================================\n\nconst baseClient = createAuthClient({\n  basePath: '/iam', // IMPORTANT: Must match nest-server betterAuth.basePath\n  baseURL: import.meta.env?.VITE_API_URL || process.env.API_URL || 'http://localhost:3000',\n  plugins: [\n    adminClient(),\n    twoFactorClient({\n      onTwoFactorRedirect() {\n        navigateTo('/auth/2fa')\n      },\n    }),\n    passkeyClient(),\n  ],\n})\n\n// =============================================================================\n// Auth Client with Password Hashing\n// =============================================================================\n\n/**\n * Extended auth client that hashes passwords before transmission.\n *\n * SECURITY: Passwords are hashed with SHA256 client-side to prevent\n * plain text password transmission over the network.\n */\nexport const authClient = {\n  ...baseClient,\n\n  changePassword: async (params: { currentPassword: string; newPassword: string }, options?: any) => {\n    const [hashedCurrent, hashedNew] = await Promise.all([\n      sha256(params.currentPassword),\n      sha256(params.newPassword)\n    ])\n    return baseClient.changePassword?.({ currentPassword: hashedCurrent, newPassword: hashedNew }, options)\n  },\n\n  resetPassword: async (params: { newPassword: string; token: string }, options?: any) => {\n    const hashedPassword = await sha256(params.newPassword)\n    return baseClient.resetPassword?.({ newPassword: hashedPassword, token: params.token }, options)\n  },\n\n  signIn: {\n    ...baseClient.signIn,\n    email: async (params: { email: string; password: string; rememberMe?: boolean }, options?: any) => {\n      const hashedPassword = await sha256(params.password)\n      return baseClient.signIn.email({ ...params, password: hashedPassword }, options)\n    },\n  },\n\n  signOut: baseClient.signOut,\n\n  signUp: {\n    ...baseClient.signUp,\n    email: async (params: { email: string; name: string; password: string }, options?: any) => {\n      const hashedPassword = await sha256(params.password)\n      return baseClient.signUp.email({ ...params, password: hashedPassword }, options)\n    },\n  },\n\n  twoFactor: {\n    ...baseClient.twoFactor,\n    disable: async (params: { password: string }, options?: any) => {\n      const hashedPassword = await sha256(params.password)\n      return baseClient.twoFactor.disable({ password: hashedPassword }, options)\n    },\n    enable: async (params: { password: string }, options?: any) => {\n      const hashedPassword = await sha256(params.password)\n      return baseClient.twoFactor.enable({ password: hashedPassword }, options)\n    },\n  },\n}\n\nexport type AuthClient = typeof authClient\n```\n\n## Crypto Utility\n\n```typescript\n// app/utils/crypto.ts\nexport async function sha256(message: string): Promise<string> {\n  const msgBuffer = new TextEncoder().encode(message)\n  const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer)\n  const hashArray = Array.from(new Uint8Array(hashBuffer))\n  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('')\n}\n```\n\n## useBetterAuth Composable\n\n```typescript\n// app/composables/use-better-auth.ts\nimport { authClient } from '~/lib/auth-client'\n\nexport function useBetterAuth() {\n  const session = authClient.useSession(useFetch)\n\n  const user = computed(() => session.data.value?.user ?? null)\n  const isAuthenticated = computed<boolean>(() => !!session.data.value?.session)\n  const isAdmin = computed<boolean>(() => user.value?.role === 'admin')\n  const is2FAEnabled = computed<boolean>(() => !!user.value?.twoFactorEnabled)\n  const isLoading = computed<boolean>(() => session.isPending.value)\n\n  return {\n    // State\n    session,\n    user,\n    isAuthenticated,\n    isAdmin,\n    is2FAEnabled,\n    isLoading,\n\n    // Methods (delegated from authClient)\n    passkey: authClient.passkey,\n    signIn: authClient.signIn,\n    signOut: authClient.signOut,\n    signUp: authClient.signUp,\n    twoFactor: authClient.twoFactor,\n  }\n}\n```\n\n## Auth Middleware\n\n```typescript\n// middleware/auth.ts\nexport default defineNuxtRouteMiddleware(async (to) => {\n  const { isAuthenticated } = useBetterAuth()\n\n  if (!isAuthenticated.value) {\n    return navigateTo('/auth/login')\n  }\n})\n\n// middleware/guest.ts\nexport default defineNuxtRouteMiddleware(() => {\n  const { isAuthenticated } = useBetterAuth()\n\n  if (isAuthenticated.value) {\n    return navigateTo('/dashboard')\n  }\n})\n\n// middleware/admin.ts\nexport default defineNuxtRouteMiddleware(() => {\n  const { isAuthenticated, isAdmin } = useBetterAuth()\n\n  if (!isAuthenticated.value) {\n    return navigateTo('/auth/login')\n  }\n\n  if (!isAdmin.value) {\n    return navigateTo('/dashboard')\n  }\n})\n```\n\n## Basic Usage Examples\n\n### Sign In\n\n```typescript\nconst { signIn } = useBetterAuth()\nconst toast = useToast()\n\nasync function handleLogin(email: string, password: string) {\n  const { error } = await signIn.email({\n    email,\n    password, // Auto-hashed via authClient\n    rememberMe: true\n  })\n\n  if (error) {\n    toast.add({ title: error.message, color: 'error' })\n  }\n  // 2FA redirect handled automatically by twoFactorClient\n}\n```\n\n### Sign Up\n\n```typescript\nconst { signUp } = useBetterAuth()\n\nasync function handleRegister(name: string, email: string, password: string) {\n  const { error } = await signUp.email({\n    name,\n    email,\n    password // Auto-hashed via authClient\n  })\n\n  if (!error) {\n    // Optionally prompt for passkey setup\n    await authClient.passkey.addPasskey()\n  }\n}\n```\n\n### Passkey Login\n\n```typescript\nconst { signIn } = useBetterAuth()\n\nasync function handlePasskeyLogin() {\n  const { error } = await signIn.passkey()\n  if (!error) navigateTo('/app')\n}\n```\n\n### 2FA Verification\n\n```typescript\nconst { twoFactor } = useBetterAuth()\n\n// TOTP code\nawait twoFactor.verifyTotp({\n  code: '123456',\n  trustDevice: true // Remember for 30 days\n})\n\n// Backup code (alternative)\nawait twoFactor.verifyBackupCode({ code: 'ABCD-1234' })\n```\n\n### Password Reset\n\n```typescript\n// Request reset email\nawait authClient.requestPasswordReset({\n  email: 'user@example.com',\n  redirectTo: '/auth/reset-password'\n})\n\n// Complete reset (with token from URL)\nawait authClient.resetPassword({\n  newPassword: 'newSecurePassword', // Auto-hashed\n  token: route.query.token as string\n})\n```\n\n## Environment Configuration\n\n```env\n# .env\nVITE_API_URL=http://localhost:3000\nAPI_URL=http://localhost:3000\n```\n\n## Pre-built Auth Pages (nuxt-base-starter)\n\n**These pages are already included in `npx create-nuxt-base` projects!**\n\n| Page | Path | Features |\n|------|------|----------|\n| Login | `/auth/login` | Email/Password, Passkey, \"Passwort vergessen\" link |\n| Register | `/auth/register` | Name/Email/Password + optional Passkey setup prompt |\n| 2FA | `/auth/2fa` | TOTP code OR Backup code, \"Ger√§t vertrauen\" option |\n| Forgot Password | `/auth/forgot-password` | Email input ‚Üí Success message |\n| Reset Password | `/auth/reset-password` | Token from URL, password confirmation |\n\n### Page Structure\n\nAll auth pages use:\n- **Layout:** `slim` (centered, minimal)\n- **Components:** `UPageCard`, `UAuthForm` (Nuxt UI)\n- **Validation:** Valibot with German error messages\n- **Language:** German UI labels\n\n### Login Page Features\n\n```vue\n<!-- Key features in pages/auth/login.vue -->\n<script setup lang=\"ts\">\ndefinePageMeta({ layout: 'slim' })\n\n// Two loading states\nconst loading = ref(false)        // Email/Password form\nconst passkeyLoading = ref(false) // Passkey button\n\n// Passkey login\nasync function onPasskeyLogin() {\n  passkeyLoading.value = true\n  const { error } = await authClient.signIn.passkey()\n  if (error) toast.add({ title: error.message, color: 'error' })\n  else navigateTo('/app')\n  passkeyLoading.value = false\n}\n</script>\n\n<template>\n  <UPageCard title=\"Anmelden\" description=\"...\">\n    <UAuthForm :fields=\"fields\" :schema=\"schema\" @submit=\"onSubmit\">\n      <template #password-hint>\n        <NuxtLink to=\"/auth/forgot-password\">Passwort vergessen?</NuxtLink>\n      </template>\n    </UAuthForm>\n\n    <template #footer>\n      <UDivider label=\"oder\" />\n      <UButton @click=\"onPasskeyLogin\" :loading=\"passkeyLoading\">\n        Mit Passkey anmelden\n      </UButton>\n      <p>Noch kein Konto? <NuxtLink to=\"/auth/register\">Registrieren</NuxtLink></p>\n    </template>\n  </UPageCard>\n</template>\n```\n\n### Register Page Features\n\n```vue\n<!-- Key features in pages/auth/register.vue -->\n<script setup lang=\"ts\">\n// Two-stage UI: Registration ‚Üí Passkey Setup\nconst showPasskeyPrompt = ref(false)\n\n// After successful registration, offer passkey setup\nasync function onSubmit(event) {\n  const { error } = await authClient.signUp.email({ ... })\n  if (!error) {\n    showPasskeyPrompt.value = true // Show passkey prompt\n  }\n}\n\n// Optional passkey enrollment\nasync function addPasskey() {\n  await authClient.passkey.addPasskey()\n  navigateTo('/app')\n}\n\nfunction skipPasskey() {\n  navigateTo('/app')\n}\n</script>\n\n<template>\n  <!-- Stage 1: Registration form -->\n  <UPageCard v-if=\"!showPasskeyPrompt\" title=\"Registrieren\">\n    <UAuthForm :fields=\"fields\" :schema=\"schema\" @submit=\"onSubmit\" />\n  </UPageCard>\n\n  <!-- Stage 2: Passkey setup prompt -->\n  <UPageCard v-else title=\"Passkey einrichten\">\n    <p>M√∂chtest du einen Passkey f√ºr schnellere Anmeldungen einrichten?</p>\n    <UButton @click=\"addPasskey\">Passkey hinzuf√ºgen</UButton>\n    <UButton variant=\"ghost\" @click=\"skipPasskey\">√úberspringen</UButton>\n  </UPageCard>\n</template>\n```\n\n### 2FA Page Features\n\n```vue\n<!-- Key features in pages/auth/2fa.vue -->\n<script setup lang=\"ts\">\nconst useBackupCode = ref(false) // Toggle TOTP vs Backup code\nconst trustDevice = ref(false)   // Remember device\n\nasync function onSubmit(event) {\n  if (useBackupCode.value) {\n    // Verify with backup code\n    await authClient.twoFactor.verifyBackupCode({ code: event.data.code })\n  } else {\n    // Verify with TOTP\n    await authClient.twoFactor.verifyTotp({\n      code: event.data.code,\n      trustDevice: trustDevice.value\n    })\n  }\n}\n</script>\n\n<template>\n  <UPageCard>\n    <UIcon name=\"i-lucide-shield\" class=\"size-12\" />\n    <h1>Zwei-Faktor-Authentifizierung</h1>\n\n    <UAuthForm :schema=\"schema\" @submit=\"onSubmit\">\n      <UInput class=\"font-mono tracking-widest\" inputmode=\"numeric\" />\n    </UAuthForm>\n\n    <UCheckbox v-if=\"!useBackupCode\" v-model=\"trustDevice\"\n      label=\"Diesem Ger√§t 30 Tage vertrauen\" />\n\n    <UButton variant=\"link\" @click=\"useBackupCode = !useBackupCode\">\n      {{ useBackupCode ? 'Code aus App verwenden' : 'Backup-Code verwenden' }}\n    </UButton>\n  </UPageCard>\n</template>\n```\n\n### Password Reset Flow\n\n```typescript\n// forgot-password.vue: Request reset\nawait authClient.requestPasswordReset({\n  email: state.email,\n  redirectTo: '/auth/reset-password'\n})\n\n// reset-password.vue: Complete reset (token from URL)\nconst token = useRoute().query.token as string\nawait authClient.resetPassword({\n  newPassword: state.password, // Auto-hashed\n  token\n})\n```\n\n## Key Patterns\n\n| Pattern | Implementation |\n|---------|----------------|\n| Session access | `authClient.useSession(useFetch)` for SSR |\n| Composable | `useBetterAuth()` (auto-imported) |\n| Password security | Client-side SHA256 hashing before transmission |\n| 2FA redirect | Automatic via `twoFactorClient({ onTwoFactorRedirect })` |\n| Passkey autofill | `autocomplete=\"username webauthn\"` |\n| Protected routes | `definePageMeta({ middleware: 'auth' })` |\n| Guest routes | `definePageMeta({ middleware: 'guest' })` |\n| Admin routes | `definePageMeta({ middleware: 'admin' })` |\n| Base path | `/iam` (must match nest-server config) |\n| Auth layout | `definePageMeta({ layout: 'slim' })` |\n| Auth forms | `UPageCard` + `UAuthForm` components |\n| Post-register | Passkey setup prompt (optional) |\n| 2FA fallback | Backup code support |\n\n## Security Considerations\n\nFor comprehensive frontend security guidelines, see [security.md](./security.md).\n\n**Key security aspects already implemented:**\n\n| Aspect | Implementation |\n|--------|----------------|\n| Password transmission | SHA256 hashed client-side before sending |\n| Session management | httpOnly cookies via Better Auth |\n| 2FA | TOTP support with device trust option |\n| Passwordless | Passkey/WebAuthn support (recommended) |\n\n**Additional recommendations:**\n- Never store tokens in `localStorage` (XSS vulnerable)\n- Use `httpOnly` cookies for refresh tokens\n- Implement session timeout for sensitive applications\n- Clear all client state on logout\n\n---\n\n## Anti-Patterns\n\n```typescript\n//  Don't send plain passwords (handled automatically by authClient)\nawait baseClient.signIn.email({ password: 'plaintext' })\n\n//  Use authClient which hashes automatically\nawait authClient.signIn.email({ password: 'plaintext' }) // Hashed to SHA256\n\n//  Don't use authClient.useSession() without useFetch in SSR\nconst session = authClient.useSession() // Hydration mismatch!\n\n//  Pass useFetch for SSR support\nconst session = authClient.useSession(useFetch)\n\n//  Don't hardcode API URL\nbaseURL: 'http://localhost:3000'\n\n//  Use environment variables\nbaseURL: import.meta.env?.VITE_API_URL || process.env.API_URL\n\n//  Don't change basePath without updating nest-server\nbasePath: '/api/auth' // Won't work with nest-server default\n\n//  Use /iam (nest-server default)\nbasePath: '/iam'\n```\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/colors.md": "# Nuxt UI Color System\n\nNuxt UI uses **semantic color naming** instead of hardcoded values. This enables consistent theming and easy dark/light mode switching.\n\n## Table of Contents\n\n- [Semantic Colors](#semantic-colors)\n- [Configuration](#configuration)\n- [CSS Utility Classes](#css-utility-classes)\n- [Component Color Props](#component-color-props)\n- [Dark/Light Mode](#darklight-mode)\n- [Customizing CSS Variables](#customizing-css-variables)\n- [Anti-Patterns](#anti-patterns)\n- [Quick Reference](#quick-reference)\n\n---\n\n## Semantic Colors\n\n| Color | Default | Use For |\n|-------|---------|---------|\n| `primary` | green | Main CTAs, active navigation, brand elements |\n| `secondary` | blue | Secondary buttons, alternative actions |\n| `success` | green | Success messages, completed states |\n| `info` | blue | Info alerts, tooltips, help text |\n| `warning` | yellow | Warning messages, pending states |\n| `error` | red | Error messages, validation errors, destructive actions |\n| `neutral` | slate | Text, borders, backgrounds, disabled states |\n\n## Configuration\n\n### app.config.ts (Runtime)\n\n```typescript\n// app.config.ts\nexport default defineAppConfig({\n  ui: {\n    colors: {\n      primary: 'green',     // Brand color\n      secondary: 'blue',    // Alternative actions\n      neutral: 'slate'      // Text, borders, backgrounds\n    }\n  }\n})\n```\n\n**Available colors:** Any Tailwind default color (`blue`, `green`, `red`, `zinc`, etc.) or custom colors defined via `@theme`.\n\n### Custom Brand Colors\n\nDefine custom colors in your CSS:\n\n```css\n/* app/assets/css/main.css */\n@import \"tailwindcss\";\n@import \"@nuxt/ui\";\n\n@theme static {\n  --color-brand-50: #fef2f2;\n  --color-brand-100: #fee2e2;\n  --color-brand-200: #fecaca;\n  --color-brand-300: #fca5a5;\n  --color-brand-400: #f87171;\n  --color-brand-500: #ef4444;\n  --color-brand-600: #dc2626;\n  --color-brand-700: #b91c1c;\n  --color-brand-800: #991b1b;\n  --color-brand-900: #7f1d1d;\n  --color-brand-950: #450a0a;\n}\n```\n\nThen use in `app.config.ts`:\n\n```typescript\nexport default defineAppConfig({\n  ui: {\n    colors: {\n      primary: 'brand'\n    }\n  }\n})\n```\n\n## CSS Utility Classes\n\n### Semantic Color Classes\n\n```vue\n<template>\n  <!-- Text colors -->\n  <span class=\"text-primary\">Primary text</span>\n  <span class=\"text-secondary\">Secondary text</span>\n  <span class=\"text-success\">Success text</span>\n  <span class=\"text-error\">Error text</span>\n  <span class=\"text-warning\">Warning text</span>\n  <span class=\"text-info\">Info text</span>\n</template>\n```\n\n### Text Hierarchy\n\n| Class | Use For |\n|-------|---------|\n| `text-highlighted` | Most prominent text |\n| `text-default` | Normal body text |\n| `text-toned` | Slightly dimmed text |\n| `text-muted` | Secondary information |\n| `text-dimmed` | Least prominent (hints, placeholders) |\n| `text-inverted` | Text on inverted backgrounds |\n\n```vue\n<template>\n  <h1 class=\"text-highlighted\">Title</h1>\n  <p class=\"text-default\">Body text</p>\n  <span class=\"text-muted\">Secondary info</span>\n  <span class=\"text-dimmed\">Hint text</span>\n</template>\n```\n\n### Backgrounds\n\n| Class | Use For |\n|-------|---------|\n| `bg-default` | Main page background |\n| `bg-muted` | Subtle background sections |\n| `bg-elevated` | Cards, elevated surfaces |\n| `bg-accented` | Highlighted sections |\n| `bg-inverted` | Inverted backgrounds (dark on light, light on dark) |\n\n```vue\n<template>\n  <div class=\"bg-default\">Page background</div>\n  <div class=\"bg-elevated\">Card surface</div>\n  <div class=\"bg-inverted text-inverted\">Inverted section</div>\n</template>\n```\n\n### Borders\n\n| Class | Use For |\n|-------|---------|\n| `border-default` | Standard borders |\n| `border-muted` | Subtle borders |\n| `border-accented` | Emphasized borders |\n| `border-inverted` | Inverted borders |\n\n```vue\n<template>\n  <div class=\"border border-default\">Standard border</div>\n  <div class=\"border border-muted\">Subtle border</div>\n</template>\n```\n\n## Component Color Props\n\n### Buttons\n\n```vue\n<template>\n  <UButton color=\"primary\">Speichern</UButton>\n  <UButton color=\"secondary\">Bearbeiten</UButton>\n  <UButton color=\"error\">Loschen</UButton>\n  <UButton color=\"neutral\" variant=\"outline\">Abbrechen</UButton>\n</template>\n```\n\n### Badges\n\n```vue\n<template>\n  <UBadge color=\"success\">Aktiv</UBadge>\n  <UBadge color=\"warning\">Ausstehend</UBadge>\n  <UBadge color=\"error\">Fehler</UBadge>\n  <UBadge color=\"info\">Info</UBadge>\n</template>\n```\n\n### Alerts\n\n```vue\n<template>\n  <UAlert color=\"success\" title=\"Erfolgreich gespeichert\" />\n  <UAlert color=\"error\" title=\"Fehler aufgetreten\" />\n  <UAlert color=\"warning\" title=\"Achtung\" />\n  <UAlert color=\"info\" title=\"Hinweis\" />\n</template>\n```\n\n### Toasts\n\n```typescript\nconst toast = useToast()\n\n// Success feedback\ntoast.add({\n  title: 'Erfolgreich gespeichert',\n  color: 'success',\n  icon: 'i-lucide-check'\n})\n\n// Error feedback\ntoast.add({\n  title: 'Fehler beim Speichern',\n  color: 'error',\n  icon: 'i-lucide-x'\n})\n\n// Warning\ntoast.add({\n  title: 'Nicht gespeicherte Anderungen',\n  color: 'warning',\n  icon: 'i-lucide-alert-triangle'\n})\n\n// Info\ntoast.add({\n  title: 'Neue Version verfugbar',\n  color: 'info',\n  icon: 'i-lucide-info'\n})\n```\n\n## Dark/Light Mode\n\n### Automatic Support\n\nNuxt UI integrates `@nuxtjs/color-mode` automatically. Colors adapt to the current mode.\n\n### useColorMode Composable\n\n```typescript\nconst colorMode = useColorMode()\n\n// Get current mode\nconsole.log(colorMode.value) // 'light' | 'dark' | 'system'\n\n// Set mode\ncolorMode.preference = 'dark'\n```\n\n### Toggle Component\n\n```vue\n<script setup lang=\"ts\">\nconst colorMode = useColorMode()\n\nconst isDark = computed({\n  get: () => colorMode.value === 'dark',\n  set: (value) => colorMode.preference = value ? 'dark' : 'light'\n})\n</script>\n\n<template>\n  <UButton\n    :icon=\"isDark ? 'i-lucide-moon' : 'i-lucide-sun'\"\n    color=\"neutral\"\n    variant=\"ghost\"\n    @click=\"isDark = !isDark\"\n  />\n</template>\n```\n\n### Built-in Components\n\n```vue\n<template>\n  <!-- Simple button toggle -->\n  <UColorModeButton />\n\n  <!-- Switch toggle -->\n  <UColorModeSwitch />\n\n  <!-- Select dropdown -->\n  <UColorModeSelect />\n</template>\n```\n\n## Customizing CSS Variables\n\nOverride default shades in your CSS:\n\n```css\n/* app/assets/css/main.css */\n@import \"tailwindcss\";\n@import \"@nuxt/ui\";\n\n/* Custom primary shade for light mode */\n:root {\n  --ui-primary: var(--ui-color-primary-600);\n}\n\n/* Custom primary shade for dark mode */\n.dark {\n  --ui-primary: var(--ui-color-primary-300);\n}\n\n/* Custom border radius */\n:root {\n  --ui-radius: 0.5rem;\n}\n```\n\n## Anti-Patterns\n\n```vue\n<!--  DON'T: Hardcoded Tailwind colors -->\n<span class=\"text-red-500\">Error</span>\n<span class=\"text-green-500\">Success</span>\n<UButton class=\"bg-blue-600\">Action</UButton>\n\n<!--  DO: Semantic colors -->\n<span class=\"text-error\">Error</span>\n<span class=\"text-success\">Success</span>\n<UButton color=\"primary\">Action</UButton>\n```\n\n```typescript\n//  DON'T: Hardcoded toast colors\ntoast.add({ title: 'Error', color: 'red' })\ntoast.add({ title: 'Success', color: 'green' })\n\n//  DO: Semantic toast colors\ntoast.add({ title: 'Error', color: 'error' })\ntoast.add({ title: 'Success', color: 'success' })\n```\n\n## Quick Reference\n\n| Purpose | Class/Prop |\n|---------|------------|\n| Primary action | `color=\"primary\"` |\n| Secondary action | `color=\"secondary\"` |\n| Success state | `color=\"success\"` |\n| Error state | `color=\"error\"` |\n| Warning state | `color=\"warning\"` |\n| Info message | `color=\"info\"` |\n| Neutral/Cancel | `color=\"neutral\"` |\n| Main text | `text-default` |\n| Muted text | `text-muted` |\n| Card background | `bg-elevated` |\n| Page background | `bg-default` |\n| Standard border | `border-default` |\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/components.md": "# Component Patterns\n\n## Table of Contents\n\n- [Script Structure](#script-structure)\n- [Template Rules](#template-rules)\n- [Props Pattern](#props-pattern)\n- [Emit Pattern](#emit-pattern)\n- [Naming](#naming)\n- [Performance](#performance)\n\n---\n\n## Script Structure\n\n```vue\n<script setup lang=\"ts\">\n// ============================================================================\n// Imports\n// ============================================================================\nimport { ref, computed } from 'vue'\nimport type { SeasonDto } from '~/api-client/types.gen'\n\n// ============================================================================\n// Composables\n// ============================================================================\nconst { seasons, fetchSeasons } = useSeasons()\nconst overlay = useOverlay()\n\n// ============================================================================\n// Variables\n// ============================================================================\nconst selected = ref<SeasonDto | null>(null)\nconst loading = ref<boolean>(false)\n\n// ============================================================================\n// Computed Properties\n// ============================================================================\nconst hasSelection = computed<boolean>(() => !!selected.value)\n\n// ============================================================================\n// Lifecycle Hooks\n// ============================================================================\nonMounted(() => fetchSeasons())\n\n// ============================================================================\n// Functions\n// ============================================================================\nfunction handleSelect(season: SeasonDto): void {\n  selected.value = season\n}\n</script>\n```\n\n## Template Rules\n\n```vue\n<template>\n  <!-- TailwindCSS only - no <style> blocks -->\n  <div class=\"flex flex-col gap-4\">\n\n    <!-- Single root for conditionals -->\n    <div v-if=\"loading\">Loading...</div>\n    <div v-else-if=\"error\">Error</div>\n    <div v-else>Content</div>\n\n    <!-- v-for with unique :key -->\n    <div v-for=\"season in seasons\" :key=\"season.id\">\n      {{ season.title }}\n    </div>\n\n    <!-- Event handlers call methods -->\n    <UButton @click=\"handleSubmit\">Speichern</UButton>\n  </div>\n</template>\n```\n\n## Props Pattern\n\n```typescript\ninterface Props {\n  season: SeasonDto\n  editable?: boolean\n  title?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  editable: false,\n  title: 'Details'\n})\n```\n\n## Emit Pattern\n\n```typescript\nconst emit = defineEmits<{\n  update: [season: SeasonDto]\n  delete: [id: string]\n  cancel: []\n}>()\n\nfunction handleSave(): void {\n  emit('update', season)\n}\n```\n\n## Naming\n\n| Type | Pattern | Example |\n|------|---------|---------|\n| Components | PascalCase | `SeasonCard.vue` |\n| Pages | kebab-case | `season-details.vue` |\n| Modals | `Modal` prefix | `ModalCreateSeason.vue` |\n\n## Performance\n\n```typescript\n//  Use computed for derived data (cached)\nconst activeSeasons = computed<SeasonDto[]>(() =>\n  seasons.value.filter(s => s.status === 'active')\n)\n\n//  Use methods for actions (not cached)\nfunction handleClick(): void { }\n\n//  Don't compute in template\n// {{ seasons.filter(s => s.active).length }}\n```\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/composables.md": "# Composables\n\n## Table of Contents\n\n- [Naming & Location](#naming--location)\n- [Structure](#structure)\n- [Key Rules](#key-rules)\n- [Stateless Composable](#stateless-composable)\n- [Composable with Parameters](#composable-with-parameters)\n- [Authentication Composable (Better Auth)](#authentication-composable-better-auth)\n- [Anti-Patterns](#anti-patterns)\n\n---\n\n## Naming & Location\n\n- File: `app/composables/use{Feature}.ts`\n- Function: `export function use{Feature}()`\n\n## Structure\n\n```typescript\n// app/composables/useSeasons.ts\nimport { ref, computed, readonly } from 'vue'\nimport type { SeasonDto, CreateSeasonDto } from '~/api-client/types.gen'\nimport { seasonControllerGet, seasonControllerCreate } from '~/api-client/sdk.gen'\n\nexport function useSeasons() {\n  // ============================================================================\n  // State\n  // ============================================================================\n  const seasons = ref<SeasonDto[]>([])\n  const loading = ref<boolean>(false)\n  const error = ref<string | null>(null)\n\n  // ============================================================================\n  // Computed\n  // ============================================================================\n  const activeSeasons = computed<SeasonDto[]>(() =>\n    seasons.value.filter(s => s.status === 'active')\n  )\n\n  // ============================================================================\n  // Methods\n  // ============================================================================\n  async function fetchAll(): Promise<void> {\n    loading.value = true\n    error.value = null\n    try {\n      const response = await seasonControllerGet()\n      if (response.data) seasons.value = response.data\n    } catch (e) {\n      error.value = 'Fehler beim Laden'\n    } finally {\n      loading.value = false\n    }\n  }\n\n  async function create(data: CreateSeasonDto): Promise<SeasonDto | null> {\n    loading.value = true\n    try {\n      const response = await seasonControllerCreate({ body: data })\n      if (response.data) {\n        seasons.value.push(response.data)\n        return response.data\n      }\n      return null\n    } finally {\n      loading.value = false\n    }\n  }\n\n  // ============================================================================\n  // Return\n  // ============================================================================\n  return {\n    // State (readonly)\n    seasons: readonly(seasons),\n    loading: readonly(loading),\n    error: readonly(error),\n\n    // Computed\n    activeSeasons,\n\n    // Methods\n    create,\n    fetchAll\n  }\n}\n```\n\n## Key Rules\n\n| Rule | Example |\n|------|---------|\n| Return readonly state | `readonly(seasons)` |\n| One composable per controller | `useSeasons`, `useTeams` |\n| Use `ref` for primitives/arrays | `ref<SeasonDto[]>([])` |\n| Use `reactive` for form state | `reactive<FormState>({})` |\n| Explicit types | `ref<boolean>(false)` |\n\n## Stateless Composable\n\nFor simple API wrappers without caching:\n\n```typescript\nexport function useRequest() {\n  const toast = useToast()\n\n  async function getAll(): Promise<RequestDto[] | null> {\n    try {\n      const response = await requestControllerGet()\n      return response.data ?? null\n    } catch (e) {\n      toast.add({ title: 'Fehler', color: 'error' })\n      return null\n    }\n  }\n\n  return { getAll }\n}\n```\n\n## Composable with Parameters\n\n```typescript\nexport function useSeasonTeams(seasonId: string) {\n  const teams = ref<TeamDto[]>([])\n\n  async function fetchTeams(): Promise<void> {\n    const response = await seasonControllerGetTeams({ path: { id: seasonId } })\n    if (response.data) teams.value = response.data\n  }\n\n  return { teams: readonly(teams), fetchTeams }\n}\n\n// Usage\nconst { teams, fetchTeams } = useSeasonTeams(route.params.id as string)\n```\n\n## Authentication Composable (Better Auth)\n\n```typescript\n// app/composables/use-better-auth.ts (pre-configured in nuxt-base-starter)\nimport { authClient } from '~/lib/auth-client'\n\nexport function useBetterAuth() {\n  const session = authClient.useSession(useFetch)\n\n  const user = computed(() => session.data.value?.user ?? null)\n  const isAuthenticated = computed<boolean>(() => !!session.data.value?.session)\n  const isAdmin = computed<boolean>(() => user.value?.role === 'admin')\n  const is2FAEnabled = computed<boolean>(() => !!user.value?.twoFactorEnabled)\n  const isLoading = computed<boolean>(() => session.isPending.value)\n\n  return {\n    // State\n    session, user, isAuthenticated, isAdmin, is2FAEnabled, isLoading,\n    // Methods (passwords auto-hashed via authClient wrapper)\n    passkey: authClient.passkey,\n    signIn: authClient.signIn,\n    signOut: authClient.signOut,\n    signUp: authClient.signUp,\n    twoFactor: authClient.twoFactor,\n  }\n}\n```\n\n> **Full authentication details:** See [reference/authentication.md](./authentication.md)\n\n## Anti-Patterns\n\n```typescript\n//  Don't expose mutable state\nreturn { seasons } // Can be mutated externally\n\n//  Return readonly\nreturn { seasons: readonly(seasons) }\n\n//  Don't forget types\nconst loading = ref(false)\n\n//  Explicit types\nconst loading = ref<boolean>(false)\n\n//  Don't mix concerns\nexport function useSeasons() {\n  const modalOpen = ref(false) // UI logic doesn't belong here\n}\n\n//  Don't use authClient.useSession() without useFetch (SSR issues)\nconst session = authClient.useSession()\n\n//  Pass useFetch for SSR support\nconst session = authClient.useSession(useFetch)\n```\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/e2e-testing.md": "# E2E Testing with Playwright\n\nThis document describes End-to-End (E2E) testing for Nuxt/Vue frontend applications using Playwright.\n\n## TDD Approach for Frontend\n\n**CRITICAL: Write E2E tests BEFORE implementing frontend features!**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  FRONTEND TDD WORKFLOW                                                     ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  1. Backend is complete (API tests pass)                                   ‚îÇ\n‚îÇ  2. Write E2E tests for user workflows                                     ‚îÇ\n‚îÇ  3. Run tests (expect failures - Red phase)                                ‚îÇ\n‚îÇ  4. Implement components/pages until tests pass (Green phase)              ‚îÇ\n‚îÇ  5. Refactor with tests passing (Refactor phase)                           ‚îÇ\n‚îÇ  6. Debug with Chrome DevTools MCP                                         ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Playwright Configuration\n\n### Basic Setup\n\n```typescript\n// playwright.config.ts\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './tests/e2e',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: 'html',\n\n  use: {\n    baseURL: process.env.TEST_BASE_URL || 'http://localhost:3001',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n  },\n\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n  ],\n\n  // Start dev server before tests\n  webServer: {\n    command: 'npm run dev',\n    url: 'http://localhost:3001',\n    reuseExistingServer: !process.env.CI,\n    timeout: 120 * 1000,\n  },\n});\n```\n\n### Test Environment Separation\n\n```typescript\n// playwright.config.ts for test environment\nexport default defineConfig({\n  use: {\n    baseURL: 'http://localhost:3101', // Different port for tests\n  },\n  webServer: {\n    command: 'npm run dev:test', // Uses test environment\n    url: 'http://localhost:3101',\n  },\n});\n```\n\n### package.json Scripts\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"nuxi dev --port 3001\",\n    \"dev:test\": \"NODE_ENV=test nuxi dev --port 3101\",\n    \"test:e2e\": \"playwright test\",\n    \"test:e2e:ui\": \"playwright test --ui\",\n    \"test:e2e:headed\": \"playwright test --headed\"\n  }\n}\n```\n\n## Writing E2E Tests\n\n### Test Structure\n\n```typescript\n// tests/e2e/products.spec.ts\nimport { test, expect } from '@playwright/test';\n\ntest.describe('Product Management', () => {\n  // Track created entities for cleanup\n  const createdProductIds: string[] = [];\n\n  test.beforeAll(async ({ request }) => {\n    // Optional: Setup test data via API\n  });\n\n  test.afterAll(async ({ request }) => {\n    // CRITICAL: Cleanup all created entities\n    for (const id of createdProductIds) {\n      await request.delete(`/api/products/${id}`);\n    }\n  });\n\n  test.beforeEach(async ({ page }) => {\n    // Login before each test (if required)\n    await loginAsUser(page, 'test@test.com', 'password');\n  });\n\n  test('should display product list', async ({ page }) => {\n    await page.goto('/products');\n\n    // Wait for data to load\n    await expect(page.locator('[data-testid=\"product-list\"]')).toBeVisible();\n\n    // Verify content\n    const items = page.locator('[data-testid=\"product-item\"]');\n    await expect(items).toHaveCount(await items.count());\n  });\n\n  test('should create new product', async ({ page }) => {\n    await page.goto('/products');\n\n    // Click create button\n    await page.click('[data-testid=\"create-product\"]');\n\n    // Fill form\n    await page.fill('[data-testid=\"product-name\"]', `Test-${Date.now()}`);\n    await page.fill('[data-testid=\"product-price\"]', '99.99');\n\n    // Submit\n    await page.click('[data-testid=\"submit\"]');\n\n    // Verify success (capture ID for cleanup)\n    await expect(page.locator('text=erfolgreich')).toBeVisible();\n\n    // Track for cleanup\n    const url = page.url();\n    const match = url.match(/\\/products\\/([a-f0-9]+)/);\n    if (match) createdProductIds.push(match[1]);\n  });\n});\n```\n\n### Helper Functions\n\n```typescript\n// tests/e2e/helpers/auth.ts\nimport { Page } from '@playwright/test';\n\nexport async function loginAsUser(\n  page: Page,\n  email: string,\n  password: string\n): Promise<void> {\n  await page.goto('/login');\n  await page.fill('[data-testid=\"email\"]', email);\n  await page.fill('[data-testid=\"password\"]', password);\n  await page.click('[data-testid=\"login-submit\"]');\n\n  // Wait for redirect\n  await page.waitForURL(/(?!.*login)/);\n}\n\nexport async function logout(page: Page): Promise<void> {\n  await page.click('[data-testid=\"user-menu\"]');\n  await page.click('[data-testid=\"logout\"]');\n  await page.waitForURL('/login');\n}\n```\n\n### API Fixtures\n\n```typescript\n// tests/e2e/fixtures/api.ts\nimport { test as base, APIRequestContext } from '@playwright/test';\n\ninterface ApiFixtures {\n  apiClient: APIRequestContext;\n  authToken: string;\n}\n\nexport const test = base.extend<ApiFixtures>({\n  apiClient: async ({ playwright }, use) => {\n    const context = await playwright.request.newContext({\n      baseURL: 'http://localhost:3000',\n    });\n    await use(context);\n    await context.dispose();\n  },\n\n  authToken: async ({ apiClient }, use) => {\n    const response = await apiClient.post('/api/auth/signin', {\n      data: {\n        email: 'test@test.com',\n        password: 'password',\n      },\n    });\n    const data = await response.json();\n    await use(data.accessToken);\n  },\n});\n```\n\n## Test Data Management\n\n### Unique Test Data\n\n```typescript\n// ALWAYS use unique identifiers\nconst uniqueEmail = `user-${Date.now()}-${crypto.randomUUID().slice(0, 8)}@test.com`;\nconst uniqueName = `Product-${Date.now()}`;\n\n// NEVER use hardcoded values that could collide\n// BAD:  const email = 'test@test.com';\n// GOOD: const email = `test-${Date.now()}@test.com`;\n```\n\n### Cleanup Patterns\n\n```typescript\ntest.describe('Feature Tests', () => {\n  const cleanup: Array<() => Promise<void>> = [];\n\n  test.afterAll(async () => {\n    // Execute all cleanup functions\n    for (const cleanupFn of cleanup) {\n      await cleanupFn();\n    }\n  });\n\n  test('creates data', async ({ page, request }) => {\n    // ... create data ...\n\n    // Register cleanup\n    cleanup.push(async () => {\n      await request.delete(`/api/resource/${createdId}`);\n    });\n  });\n});\n```\n\n### Database Isolation\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  DATABASE SEPARATION                                                       ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  Development: mongodb://localhost:27017/app-dev                            ‚îÇ\n‚îÇ  Testing:     mongodb://localhost:27017/app-test  ‚Üê E2E tests use this    ‚îÇ\n‚îÇ  Production:  mongodb://atlas/app-prod                                     ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îÇ  Configure via environment variables:                                      ‚îÇ\n‚îÇ  - .env.development: MONGODB_URI=...app-dev                                ‚îÇ\n‚îÇ  - .env.test:        MONGODB_URI=...app-test                               ‚îÇ\n‚îÇ                                                                            ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Testing Authentication Flows\n\n### Login Test\n\n```typescript\ntest('should login successfully', async ({ page }) => {\n  await page.goto('/login');\n\n  await page.fill('[data-testid=\"email\"]', 'admin@test.com');\n  await page.fill('[data-testid=\"password\"]', 'password');\n  await page.click('[data-testid=\"login-submit\"]');\n\n  // Should redirect to dashboard\n  await expect(page).toHaveURL('/dashboard');\n\n  // User info should be visible\n  await expect(page.locator('[data-testid=\"user-name\"]')).toBeVisible();\n});\n```\n\n### Protected Route Test\n\n```typescript\ntest('should redirect unauthenticated users to login', async ({ page }) => {\n  // Try to access protected route without login\n  await page.goto('/dashboard');\n\n  // Should redirect to login\n  await expect(page).toHaveURL(/\\/login/);\n});\n```\n\n### 2FA Test\n\n```typescript\ntest('should complete 2FA verification', async ({ page }) => {\n  await loginAsUser(page, '2fa-user@test.com', 'password');\n\n  // Should show 2FA input\n  await expect(page.locator('[data-testid=\"2fa-input\"]')).toBeVisible();\n\n  // Enter TOTP code (use test secret in test environment)\n  const totpCode = generateTOTP(TEST_2FA_SECRET);\n  await page.fill('[data-testid=\"2fa-input\"]', totpCode);\n  await page.click('[data-testid=\"2fa-verify\"]');\n\n  // Should complete login\n  await expect(page).toHaveURL('/dashboard');\n});\n```\n\n## Debugging with Chrome DevTools MCP\n\n### During Test Development\n\nUse Chrome DevTools MCP to debug failing tests:\n\n```typescript\n// 1. Navigate to the page\nmcp__chrome-devtools__navigate_page({ url: 'http://localhost:3001/products' });\n\n// 2. Take snapshot to understand structure\nmcp__chrome-devtools__take_snapshot();\n\n// 3. Check for console errors\nmcp__chrome-devtools__list_console_messages({ types: ['error'] });\n\n// 4. Verify API calls\nmcp__chrome-devtools__list_network_requests();\n\n// 5. Interact with elements\nmcp__chrome-devtools__click({ uid: 'button-create' });\nmcp__chrome-devtools__fill({ uid: 'input-name', value: 'Test' });\n```\n\n### Common Debugging Scenarios\n\n| Issue | MCP Tool | What to Check |\n|-------|----------|---------------|\n| Page blank | `take_snapshot` | Element structure, loading states |\n| API errors | `list_network_requests` | Failed requests (4xx, 5xx) |\n| JS errors | `list_console_messages` | Error messages, stack traces |\n| Auth issues | `list_network_requests` | Token in headers, 401 responses |\n| Missing elements | `take_snapshot` | Correct selectors, element visibility |\n\n## Best Practices\n\n### 1. Use data-testid Attributes\n\n```vue\n<!-- Component with test identifiers -->\n<template>\n  <div>\n    <UButton data-testid=\"create-product\" @click=\"onCreate\">\n      Erstellen\n    </UButton>\n\n    <UInput\n      v-model=\"name\"\n      data-testid=\"product-name\"\n      label=\"Name\"\n    />\n  </div>\n</template>\n```\n\n### 2. Wait for Conditions, Not Time\n\n```typescript\n// BAD: Fixed wait times\nawait page.waitForTimeout(3000);\n\n// GOOD: Wait for specific conditions\nawait page.waitForSelector('[data-testid=\"product-list\"]');\nawait expect(page.locator('text=Geladen')).toBeHidden();\nawait page.waitForResponse(resp => resp.url().includes('/api/products'));\n```\n\n### 3. Isolate Tests\n\n```typescript\n// Each test should be independent\ntest('test A', async ({ page }) => {\n  // Creates its own data\n  // Cleans up after itself\n});\n\ntest('test B', async ({ page }) => {\n  // Does NOT depend on test A\n  // Creates its own data\n});\n```\n\n### 4. Test User Journeys\n\n```typescript\n// Test complete workflows, not individual actions\ntest('complete order workflow', async ({ page }) => {\n  // 1. Browse products\n  await page.goto('/products');\n  await page.click('[data-testid=\"product-1\"]');\n\n  // 2. Add to cart\n  await page.click('[data-testid=\"add-to-cart\"]');\n\n  // 3. Checkout\n  await page.goto('/checkout');\n  await page.fill('[data-testid=\"address\"]', 'Test Street 1');\n\n  // 4. Complete order\n  await page.click('[data-testid=\"place-order\"]');\n  await expect(page.locator('text=Bestellung erfolgreich')).toBeVisible();\n});\n```\n\n## Running Tests\n\n### Commands\n\n```bash\n# Run all E2E tests\nnpm run test:e2e\n\n# Run specific test file\nnpx playwright test tests/e2e/products.spec.ts\n\n# Run with UI mode (debugging)\nnpm run test:e2e:ui\n\n# Run with visible browser\nnpm run test:e2e:headed\n\n# Run specific test by name\nnpx playwright test -g \"should create product\"\n\n# Generate test report\nnpx playwright show-report\n```\n\n### CI/CD Integration\n\n```yaml\n# .github/workflows/e2e.yml\nname: E2E Tests\n\non: [push, pull_request]\n\njobs:\n  e2e:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n\n      - name: Install dependencies\n        run: npm ci\n\n      - name: Install Playwright browsers\n        run: npx playwright install --with-deps\n\n      - name: Start API (test environment)\n        run: |\n          cd ../api\n          npm run start:test &\n          npx wait-on http://localhost:3100/api\n\n      - name: Run E2E tests\n        run: npm run test:e2e\n\n      - name: Upload report\n        if: always()\n        uses: actions/upload-artifact@v4\n        with:\n          name: playwright-report\n          path: playwright-report/\n```\n\n## Checklist\n\n### Before Writing Tests\n- [ ] Backend API is complete and tested\n- [ ] Playwright is configured\n- [ ] Test database is set up\n- [ ] data-testid attributes planned\n\n### Test Quality\n- [ ] Tests written BEFORE implementation\n- [ ] Complete user journeys covered\n- [ ] Unique test data with timestamps\n- [ ] Cleanup in afterAll hooks\n- [ ] No hardcoded waits (use conditions)\n- [ ] Authentication flows tested\n\n### After Tests Pass\n- [ ] Tests run twice without failures\n- [ ] No orphaned test data in database\n- [ ] CI/CD pipeline configured\n- [ ] Test report reviewed\n\n## Related Documentation\n\n- **Fullstack TDD Workflow:** `building-stories-with-tdd` skill -> `fullstack-tdd-workflow.md`\n- **Browser Debugging:** Chrome DevTools MCP section in SKILL.md\n- **Authentication:** `reference/authentication.md`\n- **Troubleshooting:** `reference/troubleshooting.md`\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/forms.md": "# Forms with Valibot\n\n**Valibot is the ONLY validation library. Do NOT use Zod.**\n\n## Table of Contents\n\n- [Basic Pattern](#basic-pattern)\n- [UAuthForm (Authentication)](#uauthform-authentication)\n- [Validation Rules](#validation-rules)\n- [Cross-Field Validation](#cross-field-validation)\n- [Form with Initial Data](#form-with-initial-data)\n- [Loading State](#loading-state)\n- [Toast Feedback](#toast-feedback)\n- [Zod to Valibot Migration](#zod-to-valibot-migration)\n\n---\n\n## Basic Pattern\n\n```vue\n<script setup lang=\"ts\">\nimport { object, pipe, string, number, minLength, minValue } from 'valibot'\nimport type { InferOutput } from 'valibot'\n\nconst schema = object({\n  title: pipe(string(), minLength(3, 'Mindestens 3 Zeichen')),\n  count: pipe(number(), minValue(1, 'Mindestens 1'))\n})\n\ntype Schema = InferOutput<typeof schema>\n\nconst state = reactive<Schema>({\n  title: '',\n  count: 1\n})\n\nasync function handleSubmit(): Promise<void> {\n  // state is validated\n}\n</script>\n\n<template>\n  <UForm :state=\"state\" :schema=\"schema\" @submit=\"handleSubmit\">\n    <UFormField name=\"title\" label=\"Titel\" required>\n      <UInput v-model=\"state.title\" />\n    </UFormField>\n\n    <UFormField name=\"count\" label=\"Anzahl\" required>\n      <UInput v-model=\"state.count\" type=\"number\" />\n    </UFormField>\n\n    <UButton type=\"submit\">Speichern</UButton>\n  </UForm>\n</template>\n```\n\n## UAuthForm (Authentication)\n\nFor authentication forms, use `UAuthForm` which provides pre-styled fields and layout:\n\n```vue\n<script setup lang=\"ts\">\nimport { object, pipe, string, email, minLength } from 'valibot'\nimport type { InferOutput } from 'valibot'\nimport type { FormSubmitEvent } from '@nuxt/ui'\n\nconst schema = object({\n  email: pipe(string(), email('Ung√ºltige E-Mail')),\n  password: pipe(string(), minLength(8, 'Mindestens 8 Zeichen'))\n})\n\ntype Schema = InferOutput<typeof schema>\n\nconst fields = [\n  { name: 'email', label: 'E-Mail', type: 'email', placeholder: 'name@beispiel.de' },\n  { name: 'password', label: 'Passwort', type: 'password' }\n]\n\nconst loading = ref(false)\n\nasync function onSubmit(event: FormSubmitEvent<Schema>) {\n  loading.value = true\n  try {\n    // Handle authentication\n  } finally {\n    loading.value = false\n  }\n}\n</script>\n\n<template>\n  <UPageCard title=\"Anmelden\">\n    <UAuthForm\n      :fields=\"fields\"\n      :schema=\"schema\"\n      :loading=\"loading\"\n      submit-label=\"Anmelden\"\n      @submit=\"onSubmit\"\n    >\n      <!-- Optional: Slot for password hint -->\n      <template #password-hint>\n        <NuxtLink to=\"/auth/forgot-password\" class=\"text-sm\">\n          Passwort vergessen?\n        </NuxtLink>\n      </template>\n    </UAuthForm>\n  </UPageCard>\n</template>\n```\n\n**UAuthForm Props:**\n| Prop | Type | Description |\n|------|------|-------------|\n| `fields` | `AuthFormField[]` | Field definitions (name, label, type, placeholder) |\n| `schema` | `ObjectSchema` | Valibot validation schema |\n| `loading` | `boolean` | Show loading spinner on submit button |\n| `submit-label` | `string` | Text for submit button |\n\n## Validation Rules\n\n```typescript\nimport {\n  string, number, boolean, array, object, pipe,\n  minLength, maxLength, email, url, regex,\n  minValue, maxValue, integer,\n  optional, nullable\n} from 'valibot'\n\n// Strings\npipe(string(), minLength(3), maxLength(100))\npipe(string(), email('Ung√ºltige E-Mail'))\npipe(string(), regex(/^\\d{5}$/, 'Ung√ºltige PLZ'))\n\n// Numbers\npipe(number(), minValue(0), maxValue(100))\npipe(number(), integer('Muss ganze Zahl sein'))\n\n// Optional\noptional(string())\nnullable(string())\n\n// Arrays\npipe(array(string()), minLength(1, 'Mindestens 1 Eintrag'))\n```\n\n## Cross-Field Validation\n\n```typescript\nimport { object, pipe, string, forward, partialCheck, minLength } from 'valibot'\n\nconst schema = pipe(\n  object({\n    password: pipe(string(), minLength(8)),\n    confirm: string()\n  }),\n  forward(\n    partialCheck(\n      [['password'], ['confirm']],\n      (input) => input.password === input.confirm,\n      'Passw√∂rter stimmen nicht √ºberein'\n    ),\n    ['confirm']\n  )\n)\n```\n\n## Form with Initial Data\n\n```typescript\ninterface Props {\n  initialData?: Partial<SeasonDto>\n}\n\nconst props = defineProps<Props>()\n\nconst state = reactive<Schema>({\n  title: props.initialData?.title ?? '',\n  description: props.initialData?.description ?? ''\n})\n```\n\n## Loading State\n\n```vue\n<script setup lang=\"ts\">\nconst submitting = ref<boolean>(false)\n\nasync function handleSubmit(): Promise<void> {\n  submitting.value = true\n  try {\n    await createSeason(state)\n  } finally {\n    submitting.value = false\n  }\n}\n</script>\n\n<template>\n  <UButton type=\"submit\" :loading=\"submitting\">Speichern</UButton>\n</template>\n```\n\n## Toast Feedback\n\n```typescript\nconst toast = useToast()\n\nasync function handleSubmit(): Promise<void> {\n  try {\n    await createSeason(state)\n    toast.add({ title: 'Erfolgreich gespeichert', color: 'success' })\n  } catch (error) {\n    toast.add({ title: 'Fehler beim Speichern', color: 'error' })\n  }\n}\n```\n\n## Zod to Valibot Migration\n\n| Zod | Valibot (v1) |\n|-----|--------------|\n| `z.object()` | `object()` |\n| `z.string().min(3)` | `pipe(string(), minLength(3))` |\n| `z.number().min(0)` | `pipe(number(), minValue(0))` |\n| `z.string().email()` | `pipe(string(), email())` |\n| `z.optional()` | `optional()` |\n| `z.infer<typeof schema>` | `InferOutput<typeof schema>` |\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/modals.md": "# Modals with useOverlay\n\n**Always use programmatic modals. Never use inline modals.**\n\n## Table of Contents\n\n- [Opening a Modal](#opening-a-modal)\n- [Modal Component](#modal-component)\n- [Confirmation Dialog](#confirmation-dialog)\n- [Rules](#rules)\n- [Anti-Patterns](#anti-patterns)\n\n---\n\n## Opening a Modal\n\n```typescript\nimport ModalCreateSeason from '~/components/ModalCreateSeason.vue'\n\nconst overlay = useOverlay()\n\nfunction openModal(): void {\n  overlay.open(ModalCreateSeason, {\n    props: {\n      title: 'Neue Season',\n      initialData: existingData\n    },\n    onClose: (result?: SeasonDto) => {\n      if (result) {\n        refreshData()\n      }\n    }\n  })\n}\n```\n\n## Modal Component\n\n```vue\n<!-- app/components/ModalCreateSeason.vue -->\n<script setup lang=\"ts\">\nimport { object, pipe, string, minLength } from 'valibot'\nimport type { InferOutput } from 'valibot'\n\ninterface Props {\n  title?: string\n  initialData?: Partial<SeasonDto>\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  title: 'Neue Season'\n})\n\nconst overlay = useOverlay()\nconst isOpen = ref<boolean>(true)\nconst loading = ref<boolean>(false)\n\nconst schema = object({\n  title: pipe(string(), minLength(3, 'Mindestens 3 Zeichen'))\n})\n\ntype Schema = InferOutput<typeof schema>\n\nconst state = reactive<Schema>({\n  title: props.initialData?.title ?? ''\n})\n\nasync function handleSubmit(): Promise<void> {\n  loading.value = true\n  try {\n    const result = await createSeason(state)\n    if (result) overlay.close(result)\n  } finally {\n    loading.value = false\n  }\n}\n\nfunction handleCancel(): void {\n  overlay.close()\n}\n</script>\n\n<template>\n  <UModal v-model:open=\"isOpen\" prevent-close @close=\"handleCancel\">\n    <UCard>\n      <template #header>\n        <div class=\"flex items-center justify-between\">\n          <h3 class=\"text-lg font-semibold\">{{ props.title }}</h3>\n          <UButton\n            color=\"gray\"\n            variant=\"ghost\"\n            icon=\"i-heroicons-x-mark\"\n            @click=\"handleCancel\"\n          />\n        </div>\n      </template>\n\n      <UForm :state=\"state\" :schema=\"schema\" class=\"space-y-4\" @submit=\"handleSubmit\">\n        <UFormField name=\"title\" label=\"Titel\" required>\n          <UInput v-model=\"state.title\" />\n        </UFormField>\n\n        <div class=\"flex justify-end gap-2\">\n          <UButton color=\"gray\" :disabled=\"loading\" @click=\"handleCancel\">\n            Abbrechen\n          </UButton>\n          <UButton type=\"submit\" :loading=\"loading\">\n            Speichern\n          </UButton>\n        </div>\n      </UForm>\n    </UCard>\n  </UModal>\n</template>\n```\n\n## Confirmation Dialog\n\n```typescript\nimport ModalConfirm from '~/components/ModalConfirm.vue'\n\nasync function handleDelete(season: SeasonDto): Promise<void> {\n  const confirmed = await new Promise<boolean>((resolve) => {\n    overlay.open(ModalConfirm, {\n      props: {\n        title: 'L√∂schen?',\n        message: `\"${season.title}\" wirklich l√∂schen?`,\n        danger: true\n      },\n      onClose: (result) => resolve(!!result)\n    })\n  })\n\n  if (confirmed) {\n    await deleteSeason(season.id)\n  }\n}\n```\n\n## Rules\n\n| Rule | Value |\n|------|-------|\n| `isOpen` | Always `ref<boolean>(true)` |\n| Close | Always via `overlay.close(result)` |\n| Return data | `overlay.close(data)` |\n| Cancel | `overlay.close()` (no argument) |\n| Prevent close | Use `prevent-close` on UModal |\n\n## Anti-Patterns\n\n```vue\n<!--  DON'T: Inline modal -->\n<template>\n  <UButton @click=\"isOpen = true\">Open</UButton>\n  <UModal v-model:open=\"isOpen\">...</UModal>\n</template>\n\n<!--  DO: Programmatic modal -->\n<template>\n  <UButton @click=\"openModal\">Open</UButton>\n</template>\n```\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/nuxt.md": "# Nuxt 4 Patterns\n\n## Table of Contents\n\n- [State Management](#state-management)\n- [Data Fetching](#data-fetching)\n- [Performance](#performance)\n- [Route Middleware](#route-middleware)\n- [Runtime Config](#runtime-config)\n- [SEO](#seo)\n- [Anti-Patterns](#anti-patterns)\n\n---\n\n## State Management\n\n### useState vs ref\n\n```typescript\n//  useState - SSR-safe, shared across components\nconst user = useState<UserDto | null>('user', () => null)\n\n//  ref - local component state only\nconst loading = ref<boolean>(false)\n\n//  ref for shared state - not SSR-safe, creates new instance\nconst user = ref<UserDto | null>(null)\n```\n\n| Use Case | Solution |\n|----------|----------|\n| Shared across components | `useState('key', () => initial)` |\n| Local component state | `ref<Type>(initial)` |\n| Form state | `reactive<Schema>({})` |\n\n## Data Fetching\n\n### useFetch (for API calls)\n\n```typescript\n// Basic\nconst { data, error, pending } = await useFetch<UserDto[]>('/api/users')\n\n// With reactive params (auto-refetch)\nconst page = ref<number>(1)\nconst { data } = await useFetch('/api/users', {\n  query: { page }\n})\n\n// Client-only\nconst { data } = await useFetch('/api/preferences', {\n  server: false\n})\n\n// Lazy loading\nconst { data } = await useLazyFetch('/api/heavy-data')\n```\n\n### useAsyncData (for custom logic)\n\n```typescript\n// Multiple sources\nconst { data } = await useAsyncData('dashboard', async () => {\n  const [users, stats] = await Promise.all([\n    $fetch('/api/users'),\n    $fetch('/api/stats')\n  ])\n  return { users, stats }\n})\n```\n\n## Performance\n\n### Lazy Components\n\n```vue\n<template>\n  <!-- Lazy load with Lazy prefix -->\n  <LazyHeavyChart v-if=\"showChart\" />\n\n  <!-- Client-only rendering -->\n  <ClientOnly>\n    <HeavyEditor />\n    <template #fallback>\n      <USkeleton class=\"h-64\" />\n    </template>\n  </ClientOnly>\n</template>\n```\n\n### Image Optimization\n\n```vue\n<template>\n  <NuxtImg\n    src=\"/hero.jpg\"\n    width=\"800\"\n    height=\"600\"\n    format=\"webp\"\n    loading=\"lazy\"\n  />\n</template>\n```\n\n## Route Middleware\n\n```typescript\n// middleware/auth.ts (uses useBetterAuth - see reference/authentication.md)\nexport default defineNuxtRouteMiddleware(async () => {\n  const { isAuthenticated } = useBetterAuth()\n\n  if (!isAuthenticated.value) {\n    return navigateTo('/auth/login')\n  }\n})\n\n// middleware/guest.ts (redirect authenticated users)\nexport default defineNuxtRouteMiddleware(() => {\n  const { isAuthenticated } = useBetterAuth()\n  if (isAuthenticated.value) return navigateTo('/dashboard')\n})\n\n// middleware/admin.ts (admin-only routes)\nexport default defineNuxtRouteMiddleware(() => {\n  const { isAuthenticated, isAdmin } = useBetterAuth()\n  if (!isAuthenticated.value) return navigateTo('/auth/login')\n  if (!isAdmin.value) return navigateTo('/dashboard')\n})\n\n// Usage in page\ndefinePageMeta({\n  middleware: 'auth' // or 'guest' or 'admin'\n})\n```\n\n> **Full authentication details:** See [reference/authentication.md](./authentication.md)\n> **Note:** 2FA redirect is handled automatically via `twoFactorClient` plugin\n\n## Runtime Config\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  runtimeConfig: {\n    apiSecret: '', // Server-only (from NUXT_API_SECRET)\n    public: {\n      apiBase: '' // Client + Server (from NUXT_PUBLIC_API_BASE)\n    }\n  }\n})\n\n// Usage\nconst config = useRuntimeConfig()\nconfig.apiSecret      // Server only\nconfig.public.apiBase // Everywhere\n```\n\n## SEO\n\n```typescript\n// In page or composable\nuseSeoMeta({\n  title: 'Dashboard',\n  description: 'User dashboard',\n  ogImage: '/og-dashboard.png'\n})\n\n// Or with useHead\nuseHead({\n  title: 'Dashboard',\n  meta: [\n    { name: 'description', content: 'User dashboard' }\n  ]\n})\n```\n\n## Anti-Patterns\n\n```typescript\n//  Using ref for shared state\nconst user = ref(null)\n\n//  Use useState\nconst user = useState('user', () => null)\n\n//  Direct process.env access\nconst key = process.env.API_KEY\n\n//  Use runtimeConfig\nconst config = useRuntimeConfig()\nconst key = config.apiSecret\n\n//  fetch() in components\nconst data = await fetch('/api/users')\n\n//  Use useFetch or $fetch\nconst { data } = await useFetch('/api/users')\n```\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/security.md": "---\nname: nuxt-vue-frontend-security\ndescription: Comprehensive frontend security guide for Nuxt/Vue applications based on OWASP practices\n---\n\n# Frontend Security (Nuxt/Vue)\n\nComprehensive security guide based on OWASP practices, tailored for Nuxt 4 and Vue 3 applications.\n\n---\n\n## 1. XSS Prevention (Cross-Site Scripting)\n\n### v-html Risks and Sanitization\n\n```vue\n<!-- ‚ùå DANGEROUS: Never use v-html with user input -->\n<div v-html=\"userComment\"></div>\n\n<!-- ‚úÖ SAFE: Use text interpolation (auto-escaped) -->\n<div>{{ userComment }}</div>\n\n<!-- ‚úÖ SAFE: Sanitize before rendering -->\n<script setup lang=\"ts\">\nimport DOMPurify from 'dompurify'\n\nconst props = defineProps<{ rawHtml: string }>()\nconst safeHtml = computed(() => DOMPurify.sanitize(props.rawHtml, {\n  ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],\n  ALLOWED_ATTR: ['href'],\n  ALLOWED_URI_REGEXP: /^https?:/\n}))\n</script>\n\n<template>\n  <div v-html=\"safeHtml\"></div>\n</template>\n```\n\n### Safe Attribute Binding\n\n```vue\n<script setup lang=\"ts\">\nconst userProvidedUrl = ref('')\n\n// Validate URLs before using\nconst safeUrl = computed(() => {\n  try {\n    const url = new URL(userProvidedUrl.value)\n    if (!['https:', 'http:'].includes(url.protocol)) {\n      return '#'  // Block javascript:, data:, etc.\n    }\n    return url.href\n  } catch {\n    return '#'\n  }\n})\n</script>\n\n<template>\n  <!-- ‚ùå DANGEROUS: User-controlled href -->\n  <a :href=\"userProvidedUrl\">Link</a>\n\n  <!-- ‚úÖ SAFE: Validated URL -->\n  <a :href=\"safeUrl\">Link</a>\n</template>\n```\n\n### Dynamic Component Security\n\n```vue\n<script setup lang=\"ts\">\n// ‚ùå DANGEROUS: User-controlled component name\nconst componentName = ref(userInput)\n\n// ‚úÖ SAFE: Allowlist of components\nconst ALLOWED_COMPONENTS = ['CardView', 'ListView', 'GridView'] as const\ntype AllowedComponent = typeof ALLOWED_COMPONENTS[number]\n\nconst selectedView = ref<AllowedComponent>('CardView')\n\nfunction setView(name: string): void {\n  if (ALLOWED_COMPONENTS.includes(name as AllowedComponent)) {\n    selectedView.value = name as AllowedComponent\n  }\n}\n</script>\n\n<template>\n  <component :is=\"selectedView\" />\n</template>\n```\n\n---\n\n## 2. CSRF Protection (Cross-Site Request Forgery)\n\n### SameSite Cookie Configuration\n\n```typescript\n// composables/useAuth.ts\nexport function useAuth() {\n  async function login(credentials: LoginDto): Promise<void> {\n    const response = await $fetch('/api/auth/login', {\n      method: 'POST',\n      body: credentials,\n      credentials: 'include'  // Include cookies\n    })\n\n    // Server sets cookies with SameSite=Strict\n    // Never store tokens in localStorage for sensitive apps\n  }\n}\n```\n\n### CSRF Token for State-Changing Operations\n\n```typescript\n// composables/useCsrf.ts\nexport function useCsrf() {\n  const csrfToken = useCookie('XSRF-TOKEN')\n\n  async function securePost<T>(url: string, body: unknown): Promise<T> {\n    return await $fetch<T>(url, {\n      method: 'POST',\n      body,\n      headers: {\n        'X-XSRF-TOKEN': csrfToken.value || ''\n      }\n    })\n  }\n\n  return { securePost }\n}\n```\n\n### Safe Form Submissions\n\n```vue\n<script setup lang=\"ts\">\nconst { securePost } = useCsrf()\n\nasync function handleSubmit(data: FormData): Promise<void> {\n  await securePost('/api/orders', data)\n}\n</script>\n```\n\n---\n\n## 3. Authentication & Token Management\n\n### Secure Token Storage\n\n```typescript\n// ‚ùå WRONG: localStorage is vulnerable to XSS\nlocalStorage.setItem('accessToken', token)\n\n// ‚úÖ CORRECT: Use httpOnly cookies (set by server)\n// Frontend never sees the token - server handles via cookies\n\n// For SPAs requiring client-side tokens:\n// composables/useAuth.ts\nexport function useAuth() {\n  // Store in memory only (cleared on page refresh)\n  const accessToken = useState<string | null>('auth-token', () => null)\n\n  // Refresh token in httpOnly cookie (set by server)\n  async function refreshAccessToken(): Promise<void> {\n    const response = await $fetch<{ accessToken: string }>('/api/auth/refresh', {\n      method: 'POST',\n      credentials: 'include'  // Send httpOnly refresh cookie\n    })\n    accessToken.value = response.accessToken\n  }\n\n  return { accessToken: readonly(accessToken), refreshAccessToken }\n}\n```\n\n### Token Lifecycle Management\n\n```typescript\n// composables/useAuth.ts\nexport function useAuth() {\n  const accessToken = useState<string | null>('auth-token', () => null)\n  const tokenExpiresAt = useState<number | null>('auth-expires', () => null)\n\n  // Check if token needs refresh (with buffer)\n  const needsRefresh = computed(() => {\n    if (!tokenExpiresAt.value) return true\n    return Date.now() > tokenExpiresAt.value - 60_000  // 1 min buffer\n  })\n\n  // Setup automatic refresh\n  function setupTokenRefresh(): void {\n    const intervalId = setInterval(async () => {\n      if (needsRefresh.value && accessToken.value) {\n        await refreshAccessToken()\n      }\n    }, 30_000)  // Check every 30s\n\n    onUnmounted(() => clearInterval(intervalId))\n  }\n\n  async function logout(): Promise<void> {\n    await $fetch('/api/auth/logout', {\n      method: 'POST',\n      credentials: 'include'\n    })\n    accessToken.value = null\n    tokenExpiresAt.value = null\n    navigateTo('/login')\n  }\n\n  return { accessToken, logout, setupTokenRefresh }\n}\n```\n\n---\n\n## 4. Input Validation (Frontend)\n\n### Valibot Schema Validation\n\n```typescript\n// schemas/user.schema.ts\nimport { object, string, minLength, maxLength, email, pipe, regex } from 'valibot'\n\nexport const userFormSchema = object({\n  name: pipe(\n    string(),\n    minLength(2, 'Name muss mindestens 2 Zeichen haben'),\n    maxLength(100, 'Name darf maximal 100 Zeichen haben')\n  ),\n  email: pipe(\n    string(),\n    email('Ung√ºltige E-Mail-Adresse')\n  ),\n  // Prevent script injection in text fields\n  bio: pipe(\n    string(),\n    maxLength(500),\n    regex(/^[^<>]*$/, 'Unerlaubte Zeichen')  // No HTML tags\n  )\n})\n```\n\n### File Upload Validation\n\n```vue\n<script setup lang=\"ts\">\nconst ALLOWED_TYPES = ['image/jpeg', 'image/png', 'application/pdf']\nconst MAX_SIZE = 5 * 1024 * 1024  // 5MB\n\nfunction validateFile(file: File): string | null {\n  if (!ALLOWED_TYPES.includes(file.type)) {\n    return 'Ung√ºltiger Dateityp. Erlaubt: JPEG, PNG, PDF'\n  }\n  if (file.size > MAX_SIZE) {\n    return 'Datei zu gro√ü. Maximum: 5MB'\n  }\n  return null\n}\n\nasync function handleFileUpload(event: Event): Promise<void> {\n  const input = event.target as HTMLInputElement\n  const file = input.files?.[0]\n  if (!file) return\n\n  const error = validateFile(file)\n  if (error) {\n    toast.error(error)\n    input.value = ''  // Clear input\n    return\n  }\n\n  // Upload validated file\n  const formData = new FormData()\n  formData.append('file', file)\n  await $fetch('/api/upload', { method: 'POST', body: formData })\n}\n</script>\n\n<template>\n  <input\n    type=\"file\"\n    accept=\".jpg,.jpeg,.png,.pdf\"\n    @change=\"handleFileUpload\"\n  />\n</template>\n```\n\n### URL/Redirect Validation\n\n```typescript\n// utils/security.ts\nconst ALLOWED_HOSTS = ['example.com', 'app.example.com']\n\nexport function isValidRedirect(url: string): boolean {\n  // Allow relative URLs\n  if (url.startsWith('/') && !url.startsWith('//')) {\n    return true\n  }\n\n  try {\n    const parsed = new URL(url)\n    return ALLOWED_HOSTS.includes(parsed.hostname) &&\n           ['http:', 'https:'].includes(parsed.protocol)\n  } catch {\n    return false\n  }\n}\n\n// Usage in route guard\nexport default defineNuxtRouteMiddleware((to) => {\n  const redirect = to.query.redirect as string | undefined\n  if (redirect && !isValidRedirect(redirect)) {\n    return navigateTo('/')  // Ignore invalid redirect\n  }\n})\n```\n\n---\n\n## 5. Sensitive Data Handling\n\n### Environment Variables (Client vs Server)\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  runtimeConfig: {\n    // Server-only secrets (never exposed to client)\n    apiSecret: process.env.API_SECRET,\n    dbUrl: process.env.DATABASE_URL,\n\n    // Public config (exposed to client)\n    public: {\n      apiBaseUrl: process.env.NUXT_PUBLIC_API_URL,\n      appName: 'My App'\n      // Never put secrets here!\n    }\n  }\n})\n```\n\n```vue\n<script setup lang=\"ts\">\nconst config = useRuntimeConfig()\n\n// ‚úÖ OK: Public config\nconst apiUrl = config.public.apiBaseUrl\n\n// ‚ùå WRONG: Server config not available on client\n// const secret = config.apiSecret  // undefined on client\n</script>\n```\n\n### Password Field Security\n\n```vue\n<template>\n  <UInput\n    v-model=\"password\"\n    type=\"password\"\n    autocomplete=\"new-password\"\n    :ui=\"{ input: 'font-mono' }\"\n  />\n\n  <!-- Toggle visibility -->\n  <UInput\n    v-model=\"password\"\n    :type=\"showPassword ? 'text' : 'password'\"\n    autocomplete=\"current-password\"\n  >\n    <template #trailing>\n      <UButton\n        variant=\"ghost\"\n        :icon=\"showPassword ? 'i-heroicons-eye-slash' : 'i-heroicons-eye'\"\n        @click=\"showPassword = !showPassword\"\n      />\n    </template>\n  </UInput>\n</template>\n```\n\n### No Sensitive Data in Client State\n\n```typescript\n// ‚ùå WRONG: Storing sensitive data in client state\nconst user = useState('user', () => ({\n  id: '123',\n  email: 'user@example.com',\n  ssn: '123-45-6789',  // Never store SSN in client!\n  creditCard: '4111...'  // Never store card numbers!\n}))\n\n// ‚úÖ CORRECT: Only necessary data\nconst user = useState('user', () => ({\n  id: '123',\n  email: 'user@example.com',\n  displayName: 'John Doe'\n}))\n// Fetch sensitive data on-demand, display, don't store\n```\n\n---\n\n## 6. Secure API Communication\n\n### HTTPS Enforcement\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  runtimeConfig: {\n    public: {\n      // Always use HTTPS in production\n      apiBaseUrl: process.env.NODE_ENV === 'production'\n        ? 'https://api.example.com'\n        : 'http://localhost:3000'\n    }\n  }\n})\n\n// middleware/https.global.ts\nexport default defineNuxtRouteMiddleware(() => {\n  if (import.meta.client && process.env.NODE_ENV === 'production') {\n    if (window.location.protocol !== 'https:') {\n      window.location.href = window.location.href.replace('http:', 'https:')\n    }\n  }\n})\n```\n\n### Authorization Header Handling\n\n```typescript\n// plugins/api.ts\nexport default defineNuxtPlugin(() => {\n  const { accessToken } = useAuth()\n\n  const api = $fetch.create({\n    baseURL: useRuntimeConfig().public.apiBaseUrl,\n    onRequest({ options }) {\n      if (accessToken.value) {\n        options.headers = {\n          ...options.headers,\n          Authorization: `Bearer ${accessToken.value}`\n        }\n      }\n    },\n    onResponseError({ response }) {\n      if (response.status === 401) {\n        // Token expired, redirect to login\n        navigateTo('/login')\n      }\n    }\n  })\n\n  return { provide: { api } }\n})\n```\n\n### Error Response Handling\n\n```typescript\n// composables/useApi.ts\nexport function useApi() {\n  async function safeRequest<T>(request: () => Promise<T>): Promise<T | null> {\n    try {\n      return await request()\n    } catch (error: unknown) {\n      if (error instanceof FetchError) {\n        // Never expose raw server errors to users\n        const message = getHumanReadableError(error.statusCode)\n        toast.error(message)\n\n        // Log for debugging (but not in production console)\n        if (process.env.NODE_ENV !== 'production') {\n          console.error('API Error:', error)\n        }\n      }\n      return null\n    }\n  }\n\n  return { safeRequest }\n}\n\nfunction getHumanReadableError(status?: number): string {\n  switch (status) {\n    case 400: return 'Ung√ºltige Anfrage'\n    case 401: return 'Bitte melden Sie sich an'\n    case 403: return 'Zugriff verweigert'\n    case 404: return 'Nicht gefunden'\n    case 429: return 'Zu viele Anfragen. Bitte warten.'\n    default: return 'Ein Fehler ist aufgetreten'\n  }\n}\n```\n\n---\n\n## 7. Content Security Policy (CSP)\n\n### Nuxt Security Module\n\n```bash\nnpm install nuxt-security\n```\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  modules: ['nuxt-security'],\n\n  security: {\n    headers: {\n      contentSecurityPolicy: {\n        'default-src': [\"'self'\"],\n        'script-src': [\"'self'\", \"'strict-dynamic'\"],\n        'style-src': [\"'self'\", \"'unsafe-inline'\"],  // Required for Tailwind\n        'img-src': [\"'self'\", 'data:', 'https:'],\n        'font-src': [\"'self'\"],\n        'connect-src': [\"'self'\", 'https://api.example.com'],\n        'frame-ancestors': [\"'none'\"],\n        'base-uri': [\"'self'\"],\n        'form-action': [\"'self'\"]\n      },\n      xContentTypeOptions: 'nosniff',\n      xFrameOptions: 'DENY',\n      referrerPolicy: 'strict-origin-when-cross-origin'\n    },\n    // Rate limiting for API routes\n    rateLimiter: {\n      tokensPerInterval: 100,\n      interval: 60000  // 100 requests per minute\n    }\n  }\n})\n```\n\n### Nonce-based Inline Scripts\n\n```typescript\n// nuxt.config.ts\nexport default defineNuxtConfig({\n  security: {\n    nonce: true,  // Auto-generate nonce for inline scripts\n    headers: {\n      contentSecurityPolicy: {\n        'script-src': [\"'self'\", \"'nonce-{{nonce}}'\"]\n      }\n    }\n  }\n})\n```\n\n```vue\n<script setup lang=\"ts\">\n// useNonce() available when nonce is enabled\nconst nonce = useNonce()\n</script>\n\n<template>\n  <!-- Nonce automatically added to Nuxt-managed scripts -->\n  <script :nonce=\"nonce\">\n    // Inline script with nonce\n  </script>\n</template>\n```\n\n---\n\n## 8. SSR Security (Nuxt-specific)\n\n### Prevent Server-Side Data Leakage\n\n```typescript\n// ‚ùå WRONG: Exposing server data in SSR\n// server/api/user.ts\nexport default defineEventHandler(async (event) => {\n  const user = await getUserFromDb(event)\n  return user  // May include password hash, internal IDs!\n})\n\n// ‚úÖ CORRECT: Transform before sending\nexport default defineEventHandler(async (event) => {\n  const user = await getUserFromDb(event)\n  return {\n    id: user.id,\n    name: user.name,\n    email: user.email\n    // Explicitly list safe fields\n  }\n})\n```\n\n### Cookie Handling in SSR\n\n```typescript\n// composables/useAuth.ts\nexport function useAuth() {\n  // Works on both server and client\n  const token = useCookie('auth-token', {\n    httpOnly: true,  // Only server can read\n    secure: true,\n    sameSite: 'strict',\n    maxAge: 60 * 60 * 24 * 7  // 7 days\n  })\n\n  // Server-side auth check\n  async function getUser(): Promise<UserDto | null> {\n    if (!token.value) return null\n\n    // On server: validate token directly\n    // On client: call API endpoint\n    if (import.meta.server) {\n      return await validateTokenServer(token.value)\n    } else {\n      return await $fetch('/api/auth/me')\n    }\n  }\n}\n```\n\n### Environment Isolation\n\n```typescript\n// composables/useSecrets.ts\nexport function useServerSecret(key: string): string {\n  if (import.meta.client) {\n    throw new Error('Server secrets cannot be accessed on client')\n  }\n  const config = useRuntimeConfig()\n  return config[key] as string\n}\n\n// Usage in server routes only\n// server/api/external.ts\nexport default defineEventHandler(async () => {\n  const apiKey = useRuntimeConfig().externalApiKey\n  // Safe: server-only execution\n})\n```\n\n---\n\n## 9. Component Security\n\n### Props Validation\n\n```vue\n<script setup lang=\"ts\">\n// Always define prop types explicitly\ninterface Props {\n  userId: string\n  title: string\n  maxLength?: number\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  maxLength: 100\n})\n\n// Validate at runtime for external data\nconst sanitizedTitle = computed(() => {\n  if (typeof props.title !== 'string') return ''\n  return props.title.slice(0, props.maxLength)\n})\n</script>\n```\n\n### Event Handler Security\n\n```vue\n<script setup lang=\"ts\">\nconst emit = defineEmits<{\n  update: [value: string]\n  delete: [id: string]\n}>()\n\n// Validate before emitting\nfunction handleUpdate(value: unknown): void {\n  if (typeof value !== 'string') return\n  if (value.length > 1000) return  // Prevent massive payloads\n  emit('update', value)\n}\n</script>\n```\n\n### Slot Content Safety\n\n```vue\n<script setup lang=\"ts\">\n// Parent component with slots\n</script>\n\n<template>\n  <div class=\"card\">\n    <!-- Slot content is rendered as-is -->\n    <!-- Ensure parent sanitizes any user content before passing -->\n    <slot name=\"content\">\n      <p>Default safe content</p>\n    </slot>\n  </div>\n</template>\n\n<!-- Usage - Parent must sanitize -->\n<MyCard>\n  <template #content>\n    <!-- ‚ùå DANGEROUS -->\n    <div v-html=\"userContent\"></div>\n\n    <!-- ‚úÖ SAFE -->\n    <div>{{ userContent }}</div>\n  </template>\n</MyCard>\n```\n\n---\n\n## 10. Third-Party Dependencies\n\n### NPM Audit\n\n```bash\n# Check for vulnerabilities\nnpm audit\n\n# Fix automatically where possible\nnpm audit fix\n\n# Check specific package\nnpm audit --package-lock-only\n\n# In CI/CD pipeline\nnpm audit --audit-level=high || exit 1\n```\n\n### Subresource Integrity (SRI)\n\n```html\n<!-- For external CDN resources, always use SRI -->\n<script\n  src=\"https://cdn.example.com/lib.js\"\n  integrity=\"sha384-abc123...\"\n  crossorigin=\"anonymous\"\n></script>\n```\n\n### Dependency Lock\n\n```typescript\n// package.json - Use exact versions for security\n{\n  \"dependencies\": {\n    \"vue\": \"3.4.15\",  // Exact version\n    \"nuxt\": \"~3.10.0\"  // Patch updates only\n  }\n}\n\n// Always commit package-lock.json\n// Review dependency updates before merging\n```\n\n---\n\n## Security Checklist\n\n### Before Deployment\n\n**XSS Prevention:**\n- [ ] No v-html with user content (or DOMPurify sanitized)\n- [ ] User input escaped in templates\n- [ ] URLs validated before use in hrefs\n- [ ] Dynamic components use allowlist\n\n**Authentication:**\n- [ ] Tokens in httpOnly cookies or memory (not localStorage)\n- [ ] Automatic token refresh implemented\n- [ ] Logout clears all client state\n- [ ] Session timeout configured\n\n**Input Validation:**\n- [ ] All forms use Valibot schemas\n- [ ] File uploads validated (type, size)\n- [ ] Redirect URLs validated against allowlist\n\n**API Security:**\n- [ ] HTTPS enforced in production\n- [ ] Authorization headers properly set\n- [ ] Error messages don't leak internals\n- [ ] Rate limiting awareness in UI\n\n**CSP & Headers:**\n- [ ] nuxt-security module configured\n- [ ] CSP headers appropriate for app\n- [ ] X-Frame-Options: DENY\n- [ ] X-Content-Type-Options: nosniff\n\n**SSR Security:**\n- [ ] No server secrets exposed to client\n- [ ] Sensitive data transformed before SSR\n- [ ] Cookies configured with security flags\n\n**Dependencies:**\n- [ ] npm audit clean (or known issues accepted)\n- [ ] package-lock.json committed\n- [ ] No deprecated packages with known vulnerabilities\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/troubleshooting.md": "# Troubleshooting & Error Recovery\n\n## Table of Contents\n\n- [Type Generation Fails](#type-generation-fails)\n- [API Won't Start](#api-wont-start)\n- [Frontend Build Fails](#frontend-build-fails)\n- [Console Errors in Browser](#console-errors-in-browser)\n- [Missing Generated Types](#missing-generated-types)\n\n---\n\n## Type Generation Fails\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  npm run generate-types fails?                                 ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  1. CHECK if API is actually running:                          ‚îÇ\n‚îÇ     curl -s http://localhost:3000/api                          ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  2. CHECK API logs for errors:                                 ‚îÇ\n‚îÇ     docker compose logs api --tail=50                          ‚îÇ\n‚îÇ     OR: Check terminal where API is running                    ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  3. COMMON FIXES:                                              ‚îÇ\n‚îÇ     - API not started ‚Üí Start it first                         ‚îÇ\n‚îÇ     - API crashed ‚Üí Check logs, fix error, restart             ‚îÇ\n‚îÇ     - Wrong URL ‚Üí Check openapi-ts.config.ts for correct URL   ‚îÇ\n‚îÇ     - Network issue ‚Üí Ensure localhost:3000 is accessible      ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  4. RETRY after fixing the issue                               ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## API Won't Start\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  API won't start on Port 3000?                                 ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  1. CHECK if port is already in use:                           ‚îÇ\n‚îÇ     lsof -i :3000                                              ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  2. IF port in use by old process:                             ‚îÇ\n‚îÇ     kill $(lsof -t -i :3000)                                   ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  3. CHECK for TypeScript/Build errors:                         ‚îÇ\n‚îÇ     cd projects/api && npm run build                           ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  4. CHECK environment:                                         ‚îÇ\n‚îÇ     - MongoDB running? (check docker compose ps)               ‚îÇ\n‚îÇ     - .env file exists with correct values?                    ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  5. RESTART cleanly:                                           ‚îÇ\n‚îÇ     cd projects/api && npm run start:dev                       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## Frontend Build Fails\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Frontend build/dev fails?                                     ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  1. CHECK for TypeScript errors:                               ‚îÇ\n‚îÇ     npm run typecheck (or check terminal output)               ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  2. COMMON ISSUES:                                             ‚îÇ\n‚îÇ     - Missing types ‚Üí Run npm run generate-types               ‚îÇ\n‚îÇ     - Import errors ‚Üí Check file paths and exports             ‚îÇ\n‚îÇ     - Nuxt module errors ‚Üí Check nuxt.config.ts                ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  3. CLEAR CACHE if weird errors:                               ‚îÇ\n‚îÇ     rm -rf .nuxt .output node_modules/.cache                   ‚îÇ\n‚îÇ     npm run dev                                                ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  4. CHECK dependencies:                                        ‚îÇ\n‚îÇ     npm install (in case packages missing)                     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## Console Errors in Browser\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  JavaScript errors in browser console?                         ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  1. GET error details:                                         ‚îÇ\n‚îÇ     mcp__chrome-devtools__list_console_messages(types: error)  ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  2. COMMON CAUSES:                                             ‚îÇ\n‚îÇ     - API call failed ‚Üí Check network requests                 ‚îÇ\n‚îÇ     - Undefined property ‚Üí Check null/undefined handling       ‚îÇ\n‚îÇ     - Missing composable ‚Üí Check imports and auto-imports      ‚îÇ\n‚îÇ     - Hydration mismatch ‚Üí Check SSR compatibility             ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  3. FIX before proceeding to next feature!                     ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## Missing Generated Types\n\n**If `types.gen.ts` or `sdk.gen.ts` are missing or outdated:**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  types.gen.ts missing or outdated?                          ‚îÇ\n‚îÇ                                                             ‚îÇ\n‚îÇ  1. ASK USER: \"Die generierten Types fehlen oder sind       ‚îÇ\n‚îÇ     veraltet. L√§uft die Backend-API unter                   ‚îÇ\n‚îÇ     http://localhost:3000?\"                                 ‚îÇ\n‚îÇ                                                             ‚îÇ\n‚îÇ  2. IF API RUNNING:                                         ‚îÇ\n‚îÇ     ‚Üí Run: npm run generate-types                           ‚îÇ\n‚îÇ     ‚Üí Wait for completion                                   ‚îÇ\n‚îÇ     ‚Üí Continue with generated types                         ‚îÇ\n‚îÇ                                                             ‚îÇ\n‚îÇ  3. IF API NOT RUNNING:                                     ‚îÇ\n‚îÇ     ‚Üí Ask user to start API first:                          ‚îÇ\n‚îÇ       \"Bitte starte die API mit: cd projects/api &&         ‚îÇ\n‚îÇ        npm run start:dev\"                                   ‚îÇ\n‚îÇ     ‚Üí Wait for user confirmation                            ‚îÇ\n‚îÇ     ‚Üí Then run: npm run generate-types                      ‚îÇ\n‚îÇ                                                             ‚îÇ\n‚îÇ  ‚ùå NEVER create manual interfaces as workaround!           ‚îÇ\n‚îÇ  ‚ùå NEVER skip this workflow!                               ‚îÇ\n‚îÇ  ‚ùå NEVER say \"I'll create interfaces manually\"             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Why this matters:**\n- Manual interfaces get out of sync with backend\n- Generated types include all validation rules\n- SDK functions have correct parameter types\n- Prevents runtime type mismatches\n\n---\n\n## Quick Commands Reference\n\n```bash\n# Check if API is running\ncurl -s -o /dev/null -w \"%{http_code}\" http://localhost:3000/api\n\n# Check if port is in use\nlsof -i :3000\nlsof -i :3001\n\n# Kill process on port\nkill $(lsof -t -i :3000)\n\n# Clear Nuxt cache\nrm -rf .nuxt .output node_modules/.cache\n\n# Regenerate types\nnpm run generate-types\n\n# Check Docker containers\ndocker compose ps\ndocker compose logs api --tail=50\n```\n",
        "plugins/lt-dev/skills/developing-lt-frontend/reference/typescript.md": "# TypeScript Standards\n\n## Table of Contents\n\n- [Rule: No Implicit any](#rule-no-implicit-any)\n- [Variables](#variables)\n- [Functions](#functions)\n- [Vue Composition API](#vue-composition-api)\n- [Props & Emits](#props--emits)\n- [Generated Types (REQUIRED)](#generated-types-required)\n- [Anti-Patterns](#anti-patterns)\n\n---\n\n## Rule: No Implicit `any`\n\nEvery variable, parameter, and return value MUST have an explicit type.\n\n## Variables\n\n```typescript\n// Primitives\nconst name: string = 'value'\nconst count: number = 0\nconst active: boolean = true\n\n// Arrays\nconst items: SeasonDto[] = []\n\n// Nullable\nconst season: SeasonDto | null = null\n\n// Unions\nconst status: 'active' | 'inactive' = 'active'\n```\n\n## Functions\n\n```typescript\n// Sync\nfunction process(input: string): void { }\n\n// Async\nasync function fetch(id: string): Promise<SeasonDto | null> { }\n\n// Arrow\nconst handle = (event: MouseEvent): void => { }\n```\n\n## Vue Composition API\n\n```typescript\n// ref - always with type parameter\nconst count = ref<number>(0)\nconst user = ref<UserDto | null>(null)\nconst items = ref<SeasonDto[]>([])\n\n// reactive - with interface\ninterface FormState {\n  title: string\n  description: string\n}\nconst state = reactive<FormState>({ title: '', description: '' })\n\n// computed - with return type\nconst active = computed<SeasonDto[]>(() => items.value.filter(i => i.active))\n```\n\n## Props & Emits\n\n```typescript\n// Props\ninterface Props {\n  season: SeasonDto\n  editable?: boolean\n}\nconst props = withDefaults(defineProps<Props>(), { editable: false })\n\n// Emits\nconst emit = defineEmits<{\n  update: [value: string]\n  submit: [data: FormData]\n}>()\n```\n\n## Generated Types (REQUIRED)\n\n**NEVER create custom interfaces for backend DTOs!**\n\n```typescript\n//  ALWAYS use generated types for backend data\nimport type { SeasonDto, CreateSeasonDto } from '~/api-client/types.gen'\nimport { seasonControllerGet } from '~/api-client/sdk.gen'\n\n//  Extend generated types for UI-specific properties\ninterface SeasonWithUI extends SeasonDto {\n  isSelected: boolean\n}\n\n//  Custom interfaces ONLY for frontend-only state\n// app/interfaces/filter.interface.ts\ninterface FilterState {\n  searchQuery: string\n  sortBy: 'name' | 'date'\n}\n```\n\n### If Generated Types Are Missing\n\n**Prerequisites:** Backend API must be running!\n\n```bash\n# 1. Start API\ncd projects/api && npm run start:dev\n\n# 2. Generate types\nnpm run generate-types\n```\n\n**NEVER create manual DTOs as a workaround!**\n\n## Anti-Patterns\n\n```typescript\n//  FORBIDDEN: Custom interfaces for backend DTOs\n// app/interfaces/season.interface.ts\ninterface Season {\n  id: string\n  name: string\n}\n\n//  Use generated types\nimport type { SeasonDto } from '~/api-client/types.gen'\n\n//  Implicit any\nconst data = null\nfunction process(input) { }\nconst items = []\n\n//  Explicit types\nconst data: SeasonDto | null = null\nfunction process(input: string): void { }\nconst items: SeasonDto[] = []\n```\n",
        "plugins/lt-dev/skills/general-frontend-security/SKILL.md": "---\nname: general-frontend-security\ndescription: Framework-agnostic frontend security guide based on OWASP. Use when implementing security in web applications, reviewing frontend code for vulnerabilities, or working with client-side authentication, XSS prevention, CSRF protection, or secure storage. Covers browser security features, client-side validation, and security headers.\n---\n\n# General Frontend Security\n\nFramework-agnostic security practices for web applications based on OWASP guidelines.\n\n## When to Use This Skill\n\n- Reviewing frontend code for security vulnerabilities\n- Implementing client-side authentication flows\n- Setting up secure cookie handling\n- Configuring Content Security Policy\n- Auditing third-party dependencies\n- General frontend security questions\n\n## Framework-Specific References\n\n| Framework | Reference File |\n|-----------|---------------|\n| Nuxt/Vue | [../developing-lt-frontend/reference/security.md](../developing-lt-frontend/reference/security.md) |\n| Angular | [angular-security.md](angular-security.md) |\n\n---\n\n## OWASP Top 10 for Frontend\n\n### 1. Cross-Site Scripting (XSS)\n\n**Prevention:**\n\n```javascript\n// ‚ùå DANGEROUS: innerHTML with user input\nelement.innerHTML = userInput\n\n// ‚úÖ SAFE: textContent for plain text\nelement.textContent = userInput\n\n// ‚úÖ SAFE: Sanitize if HTML needed\nimport DOMPurify from 'dompurify'\nelement.innerHTML = DOMPurify.sanitize(userInput)\n```\n\n**Types of XSS:**\n- **Stored XSS:** Malicious script stored in database, served to users\n- **Reflected XSS:** Script in URL parameters reflected in response\n- **DOM-based XSS:** Script manipulates DOM directly\n\n### 2. Broken Authentication\n\n**Prevention:**\n- Use httpOnly cookies for session tokens\n- Implement token refresh with short-lived access tokens\n- Never store sensitive tokens in localStorage\n- Implement proper logout (server-side token invalidation)\n\n### 3. Sensitive Data Exposure\n\n**Prevention:**\n- Never log passwords, tokens, or PII to console\n- Don't store sensitive data in client-side state\n- Use HTTPS for all API communication\n- Mask sensitive input fields\n\n### 4. Broken Access Control\n\n**Prevention:**\n- Client-side access control is UI-only (server must verify)\n- Validate redirects against allowlist\n- Don't expose admin features based on client-side flags\n\n### 5. Security Misconfiguration\n\n**Prevention:**\n- Configure CSP headers properly\n- Disable debug mode in production\n- Remove development tools and console logs\n- Use secure cookie flags\n\n---\n\n## Client-Side Storage Security\n\n### localStorage/sessionStorage\n\n```javascript\n// ‚ùå NEVER store in localStorage:\n// - Access tokens\n// - Refresh tokens\n// - Session IDs\n// - Credit card numbers\n// - Passwords\n\n// localStorage is accessible to any script (XSS vulnerable)\nlocalStorage.setItem('token', sensitiveToken)  // DANGEROUS\n\n// ‚ö†Ô∏è Use only for non-sensitive data\nlocalStorage.setItem('theme', 'dark')  // OK\nlocalStorage.setItem('language', 'de')  // OK\n```\n\n### Secure Token Storage Options\n\n| Method | XSS Risk | CSRF Risk | Recommendation |\n|--------|----------|-----------|----------------|\n| localStorage | HIGH | None | Never for tokens |\n| sessionStorage | HIGH | None | Never for tokens |\n| httpOnly Cookie | None | Medium | Best for refresh tokens |\n| Memory (JS variable) | Low | None | Good for access tokens |\n| Secure Cookie (non-httpOnly) | Medium | Medium | Avoid |\n\n### Best Practice: Memory + httpOnly Cookie\n\n```javascript\n// Access token: Store in memory (cleared on page refresh)\nlet accessToken = null\n\nfunction setAccessToken(token) {\n  accessToken = token\n}\n\nfunction getAccessToken() {\n  return accessToken\n}\n\n// Refresh token: httpOnly cookie (set by server)\n// Frontend never sees it, automatically sent with requests\nasync function refreshAccessToken() {\n  const response = await fetch('/api/auth/refresh', {\n    method: 'POST',\n    credentials: 'include'  // Send httpOnly cookie\n  })\n  const { accessToken } = await response.json()\n  setAccessToken(accessToken)\n}\n```\n\n---\n\n## Browser Security Features\n\n### Content Security Policy (CSP)\n\n```html\n<!-- HTTP Header (recommended) or meta tag -->\n<meta http-equiv=\"Content-Security-Policy\" content=\"\n  default-src 'self';\n  script-src 'self' 'nonce-abc123';\n  style-src 'self' 'unsafe-inline';\n  img-src 'self' data: https:;\n  connect-src 'self' https://api.example.com;\n  font-src 'self';\n  object-src 'none';\n  frame-ancestors 'none';\n  base-uri 'self';\n  form-action 'self';\n\">\n```\n\n**Key Directives:**\n\n| Directive | Purpose | Recommendation |\n|-----------|---------|----------------|\n| `default-src` | Fallback for all | `'self'` |\n| `script-src` | JavaScript sources | `'self'` + nonces |\n| `style-src` | CSS sources | `'self'` (avoid `'unsafe-inline'`) |\n| `img-src` | Image sources | `'self' data: https:` |\n| `connect-src` | XHR/Fetch/WebSocket | Explicit API origins |\n| `frame-ancestors` | Who can embed | `'none'` (prevent clickjacking) |\n\n### Subresource Integrity (SRI)\n\n```html\n<!-- Always use SRI for external scripts/styles -->\n<script\n  src=\"https://cdn.example.com/lib.js\"\n  integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\"\n  crossorigin=\"anonymous\"\n></script>\n```\n\n### Security Headers\n\n```\n# Prevent clickjacking\nX-Frame-Options: DENY\n\n# Prevent MIME sniffing\nX-Content-Type-Options: nosniff\n\n# Enforce HTTPS\nStrict-Transport-Security: max-age=31536000; includeSubDomains; preload\n\n# Control referrer information\nReferrer-Policy: strict-origin-when-cross-origin\n\n# Restrict feature access\nPermissions-Policy: geolocation=(), camera=(), microphone=()\n```\n\n---\n\n## Secure Cookie Configuration\n\n### Cookie Flags\n\n```javascript\n// Server sets cookies with these flags\nSet-Cookie: sessionId=abc123;\n  HttpOnly;       // Not accessible via JavaScript (XSS protection)\n  Secure;         // Only sent over HTTPS\n  SameSite=Strict;  // Not sent with cross-site requests (CSRF protection)\n  Path=/;         // Cookie scope\n  Max-Age=86400   // Expiry (in seconds)\n```\n\n| Flag | Purpose | When to Use |\n|------|---------|-------------|\n| `HttpOnly` | Prevent JS access | Always for session/auth cookies |\n| `Secure` | HTTPS only | Always in production |\n| `SameSite=Strict` | No cross-site | Auth cookies, most secure |\n| `SameSite=Lax` | Some cross-site | Default, allows GET navigation |\n| `SameSite=None` | All cross-site | Third-party cookies (requires Secure) |\n\n---\n\n## Input Validation\n\n### Client-Side Validation (UI Only)\n\n```javascript\n// Client validation improves UX but NEVER trust it for security\nfunction validateEmail(email) {\n  const regex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  return regex.test(email)\n}\n\nfunction validatePassword(password) {\n  return password.length >= 8 &&\n         /[A-Z]/.test(password) &&\n         /[a-z]/.test(password) &&\n         /[0-9]/.test(password)\n}\n\n// Always validate on server too!\n```\n\n### URL Validation\n\n```javascript\nfunction isValidUrl(url) {\n  try {\n    const parsed = new URL(url)\n    return ['http:', 'https:'].includes(parsed.protocol)\n  } catch {\n    return false\n  }\n}\n\nfunction isSameOrigin(url) {\n  try {\n    const parsed = new URL(url, window.location.origin)\n    return parsed.origin === window.location.origin\n  } catch {\n    return false\n  }\n}\n\n// Redirect validation\nfunction safeRedirect(url) {\n  if (isSameOrigin(url) || ALLOWED_EXTERNAL_ORIGINS.includes(new URL(url).origin)) {\n    window.location.href = url\n  } else {\n    window.location.href = '/dashboard'  // Fallback\n  }\n}\n```\n\n### File Upload Validation\n\n```javascript\nconst ALLOWED_TYPES = ['image/jpeg', 'image/png', 'application/pdf']\nconst MAX_SIZE = 5 * 1024 * 1024  // 5MB\n\nfunction validateFile(file) {\n  const errors = []\n\n  if (!ALLOWED_TYPES.includes(file.type)) {\n    errors.push('Invalid file type')\n  }\n\n  if (file.size > MAX_SIZE) {\n    errors.push('File too large (max 5MB)')\n  }\n\n  // Check file extension matches type\n  const ext = file.name.split('.').pop()?.toLowerCase()\n  const expectedExts = {\n    'image/jpeg': ['jpg', 'jpeg'],\n    'image/png': ['png'],\n    'application/pdf': ['pdf']\n  }\n\n  if (expectedExts[file.type] && !expectedExts[file.type].includes(ext)) {\n    errors.push('File extension mismatch')\n  }\n\n  return errors\n}\n```\n\n---\n\n## API Security\n\n### Secure Fetch Wrapper\n\n```javascript\nasync function secureFetch(url, options = {}) {\n  const config = {\n    ...options,\n    credentials: 'include',  // Include cookies\n    headers: {\n      'Content-Type': 'application/json',\n      ...options.headers\n    }\n  }\n\n  // Add CSRF token for state-changing requests\n  if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(options.method)) {\n    const csrfToken = getCsrfToken()  // From cookie or meta tag\n    if (csrfToken) {\n      config.headers['X-CSRF-Token'] = csrfToken\n    }\n  }\n\n  try {\n    const response = await fetch(url, config)\n\n    if (response.status === 401) {\n      // Token expired - try refresh or redirect to login\n      await handleUnauthorized()\n      return null\n    }\n\n    if (!response.ok) {\n      // Don't expose error details to users\n      console.error('API Error:', response.status)\n      throw new Error('Request failed')\n    }\n\n    return response.json()\n  } catch (error) {\n    // Log for debugging, show generic message to user\n    console.error('Fetch error:', error)\n    throw new Error('Network error')\n  }\n}\n```\n\n### Rate Limiting Awareness\n\n```javascript\nclass RateLimitedClient {\n  private retryAfter = 0\n\n  async request(url, options) {\n    if (Date.now() < this.retryAfter) {\n      throw new Error('Rate limited. Please wait.')\n    }\n\n    const response = await fetch(url, options)\n\n    if (response.status === 429) {\n      const retryAfter = response.headers.get('Retry-After')\n      this.retryAfter = Date.now() + (parseInt(retryAfter || '60') * 1000)\n      throw new Error('Too many requests. Please try again later.')\n    }\n\n    return response\n  }\n}\n```\n\n---\n\n## Third-Party Dependencies\n\n### Audit Process\n\n```bash\n# Check for vulnerabilities\nnpm audit\n\n# Auto-fix where safe\nnpm audit fix\n\n# Check outdated packages\nnpm outdated\n\n# Update to latest (careful with major versions)\nnpm update\n```\n\n### Dependency Best Practices\n\n1. **Lock versions**: Always commit `package-lock.json`\n2. **Regular audits**: Run `npm audit` in CI/CD\n3. **Minimal dependencies**: Fewer deps = smaller attack surface\n4. **Review before adding**: Check package popularity, maintenance, and security\n5. **CDN integrity**: Always use SRI for CDN resources\n\n---\n\n## DevTools Security\n\n### Production Safeguards\n\n```javascript\n// Remove console statements in production build\n// Most bundlers support this via configuration\n\n// Disable right-click (not a security measure, just UX)\n// Don't rely on this for security!\n\n// Detect DevTools (not reliable, just awareness)\n// Not a security measure - determined attackers bypass this\n\n// REAL security: Proper server-side validation and authentication\n```\n\n---\n\n## Security Checklist\n\n### Development\n\n- [ ] No sensitive data in client-side code\n- [ ] Environment variables separated (public vs private)\n- [ ] Input validation on all user inputs\n- [ ] XSS prevention (no innerHTML with user data)\n- [ ] CSRF tokens for state-changing requests\n\n### Authentication\n\n- [ ] Tokens stored securely (memory + httpOnly cookies)\n- [ ] Token refresh mechanism implemented\n- [ ] Proper logout (clear all client state)\n- [ ] Session timeout configured\n\n### Configuration\n\n- [ ] HTTPS enforced\n- [ ] CSP headers configured\n- [ ] Security headers set (X-Frame-Options, etc.)\n- [ ] Cookies configured with secure flags\n- [ ] CORS properly restricted\n\n### Dependencies\n\n- [ ] npm audit clean (or accepted risks)\n- [ ] package-lock.json committed\n- [ ] SRI for external resources\n- [ ] Regular dependency updates\n\n### Build & Deploy\n\n- [ ] Debug mode disabled\n- [ ] Console logs removed\n- [ ] Source maps disabled or restricted\n- [ ] Error messages generic (no stack traces)\n",
        "plugins/lt-dev/skills/general-frontend-security/angular-security.md": "---\nname: angular-security-reference\ndescription: Angular-specific security best practices based on OWASP guidelines\n---\n\n# Angular Security Reference\n\nAngular-specific security implementations based on OWASP Secure Coding Practices.\n\n---\n\n## 1. Built-in XSS Protection\n\n### Angular's Automatic Sanitization\n\nAngular automatically sanitizes values in templates:\n\n```typescript\n// Component\n@Component({\n  template: `\n    <!-- ‚úÖ SAFE: Automatically escaped -->\n    <div>{{ userInput }}</div>\n\n    <!-- ‚úÖ SAFE: Attribute binding escaped -->\n    <div [title]=\"userInput\"></div>\n\n    <!-- ‚ö†Ô∏è Angular sanitizes but logs warning -->\n    <div [innerHTML]=\"userInput\"></div>\n  `\n})\nexport class SafeComponent {\n  userInput = '<script>alert(\"xss\")</script>'\n}\n```\n\n### DomSanitizer and Security Contexts\n\n```typescript\nimport { DomSanitizer, SafeHtml, SafeUrl } from '@angular/platform-browser'\n\n@Component({\n  template: `\n    <div [innerHTML]=\"trustedHtml\"></div>\n    <a [href]=\"trustedUrl\">Link</a>\n  `\n})\nexport class SanitizerComponent {\n  trustedHtml: SafeHtml\n  trustedUrl: SafeUrl\n\n  constructor(private sanitizer: DomSanitizer) {\n    // ‚ö†Ô∏è ONLY use bypass when you KNOW the content is safe\n    // For example: content from your own CMS, not user input!\n    const htmlFromCms = '<strong>Trusted</strong>'\n    this.trustedHtml = this.sanitizer.bypassSecurityTrustHtml(htmlFromCms)\n\n    // Validate URLs before trusting\n    const validatedUrl = this.validateUrl(userProvidedUrl)\n    this.trustedUrl = this.sanitizer.bypassSecurityTrustUrl(validatedUrl)\n  }\n\n  private validateUrl(url: string): string {\n    try {\n      const parsed = new URL(url)\n      if (!['http:', 'https:'].includes(parsed.protocol)) {\n        return 'about:blank'  // Block javascript:, data:, etc.\n      }\n      return url\n    } catch {\n      return 'about:blank'\n    }\n  }\n}\n```\n\n### bypassSecurityTrust* Risks\n\n```typescript\n// ‚ùå DANGEROUS: Never use with user input\n@Component({\n  template: `<div [innerHTML]=\"dangerousHtml\"></div>`\n})\nexport class DangerousComponent {\n  constructor(private sanitizer: DomSanitizer) {\n    // NEVER DO THIS with user input!\n    const userInput = '<img src=x onerror=alert(\"xss\")>'\n    this.dangerousHtml = this.sanitizer.bypassSecurityTrustHtml(userInput)\n  }\n}\n\n// ‚úÖ SAFE: Only bypass for truly trusted content\n@Component({\n  template: `<div [innerHTML]=\"safeHtml\"></div>`\n})\nexport class SafeComponent {\n  safeHtml: SafeHtml\n\n  constructor(private sanitizer: DomSanitizer, private cmsService: CmsService) {\n    // Content from internal CMS with admin-only editing\n    this.cmsService.getTrustedContent().subscribe(content => {\n      this.safeHtml = this.sanitizer.bypassSecurityTrustHtml(content)\n    })\n  }\n}\n```\n\n---\n\n## 2. HTTP Security\n\n### HttpClient Interceptors\n\n```typescript\n// auth.interceptor.ts\n@Injectable()\nexport class AuthInterceptor implements HttpInterceptor {\n  constructor(private authService: AuthService) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const token = this.authService.getAccessToken()\n\n    if (token) {\n      req = req.clone({\n        setHeaders: {\n          Authorization: `Bearer ${token}`\n        }\n      })\n    }\n\n    return next.handle(req).pipe(\n      catchError((error: HttpErrorResponse) => {\n        if (error.status === 401) {\n          this.authService.logout()\n          this.router.navigate(['/login'])\n        }\n        return throwError(() => error)\n      })\n    )\n  }\n}\n\n// app.config.ts\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(\n      withInterceptors([authInterceptor])\n    )\n  ]\n}\n```\n\n### XSRF/CSRF Protection (Built-in)\n\n```typescript\n// Angular's HttpClient automatically handles XSRF\n// Configure cookie and header names if needed\n\n// app.config.ts\nimport { provideHttpClient, withXsrfConfiguration } from '@angular/common/http'\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideHttpClient(\n      withXsrfConfiguration({\n        cookieName: 'XSRF-TOKEN',  // Default\n        headerName: 'X-XSRF-TOKEN'  // Default\n      })\n    )\n  ]\n}\n\n// Server must set XSRF-TOKEN cookie\n// Angular automatically sends X-XSRF-TOKEN header\n```\n\n### Secure HTTP Requests\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class ApiService {\n  private apiUrl = environment.apiUrl  // Always HTTPS in production\n\n  constructor(private http: HttpClient) {}\n\n  // Always use POST for sensitive data\n  login(credentials: LoginDto): Observable<AuthResponse> {\n    return this.http.post<AuthResponse>(`${this.apiUrl}/auth/login`, credentials, {\n      withCredentials: true  // Include cookies\n    })\n  }\n\n  // Never put sensitive data in URL\n  // ‚ùå WRONG\n  getUser(token: string): Observable<User> {\n    return this.http.get(`${this.apiUrl}/user?token=${token}`)\n  }\n\n  // ‚úÖ CORRECT\n  getUser(): Observable<User> {\n    // Token sent via Authorization header by interceptor\n    return this.http.get<User>(`${this.apiUrl}/user`)\n  }\n}\n```\n\n---\n\n## 3. Route Guards\n\n### CanActivate for Authentication\n\n```typescript\n// auth.guard.ts\nexport const authGuard: CanActivateFn = (route, state) => {\n  const authService = inject(AuthService)\n  const router = inject(Router)\n\n  if (authService.isAuthenticated()) {\n    return true\n  }\n\n  // Store intended URL for redirect after login\n  router.navigate(['/login'], {\n    queryParams: { returnUrl: state.url }\n  })\n  return false\n}\n\n// routes.ts\nexport const routes: Routes = [\n  { path: 'dashboard', component: DashboardComponent, canActivate: [authGuard] },\n  { path: 'admin', component: AdminComponent, canActivate: [authGuard, adminGuard] }\n]\n```\n\n### Role-based Access\n\n```typescript\n// role.guard.ts\nexport const roleGuard: CanActivateFn = (route) => {\n  const authService = inject(AuthService)\n  const router = inject(Router)\n\n  const requiredRoles = route.data['roles'] as string[]\n  const userRoles = authService.getCurrentUser()?.roles ?? []\n\n  const hasRole = requiredRoles.some(role => userRoles.includes(role))\n\n  if (!hasRole) {\n    router.navigate(['/unauthorized'])\n    return false\n  }\n\n  return true\n}\n\n// routes.ts\nexport const routes: Routes = [\n  {\n    path: 'admin',\n    component: AdminComponent,\n    canActivate: [authGuard, roleGuard],\n    data: { roles: ['ADMIN'] }\n  }\n]\n```\n\n### CanLoad for Lazy Modules\n\n```typescript\n// Prevents unauthorized users from even downloading module code\nexport const canLoadAdmin: CanMatchFn = () => {\n  const authService = inject(AuthService)\n  return authService.hasRole('ADMIN')\n}\n\n// routes.ts\nexport const routes: Routes = [\n  {\n    path: 'admin',\n    loadChildren: () => import('./admin/admin.routes'),\n    canMatch: [canLoadAdmin]\n  }\n]\n```\n\n### Redirect Security\n\n```typescript\n// login.component.ts\n@Component({ /* ... */ })\nexport class LoginComponent {\n  private router = inject(Router)\n  private route = inject(ActivatedRoute)\n\n  onLoginSuccess(): void {\n    const returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/dashboard'\n\n    // ‚úÖ VALIDATE redirect URL\n    if (this.isValidRedirect(returnUrl)) {\n      this.router.navigateByUrl(returnUrl)\n    } else {\n      this.router.navigate(['/dashboard'])\n    }\n  }\n\n  private isValidRedirect(url: string): boolean {\n    // Only allow internal URLs\n    if (url.startsWith('/') && !url.startsWith('//')) {\n      return true\n    }\n\n    try {\n      const parsed = new URL(url, window.location.origin)\n      return parsed.origin === window.location.origin\n    } catch {\n      return false\n    }\n  }\n}\n```\n\n---\n\n## 4. Content Security\n\n### CSP Compatibility\n\n```typescript\n// For inline styles (Angular often uses them)\n// Configure CSP to allow Angular's style handling\n\n// In index.html or server configuration:\n// Content-Security-Policy: style-src 'self' 'unsafe-inline';\n\n// Better: Use nonces with Angular Universal/SSR\n// Configure CSP header with nonce\n```\n\n### Strict Template Security\n\n```typescript\n// Enable strict template type checking in tsconfig.json\n{\n  \"angularCompilerOptions\": {\n    \"strictTemplates\": true,\n    \"strictInjectionParameters\": true,\n    \"strictInputAccessModifiers\": true\n  }\n}\n```\n\n### AOT vs JIT Security\n\n```typescript\n// ALWAYS use AOT (Ahead-of-Time) compilation in production\n// angular.json\n{\n  \"projects\": {\n    \"my-app\": {\n      \"architect\": {\n        \"build\": {\n          \"configurations\": {\n            \"production\": {\n              \"aot\": true,  // Default and required\n              \"buildOptimizer\": true\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n// JIT allows dynamic template compilation - security risk!\n// Never enable JIT in production\n```\n\n---\n\n## 5. Form Security\n\n### Reactive Forms Validation\n\n```typescript\n@Component({\n  template: `\n    <form [formGroup]=\"loginForm\" (ngSubmit)=\"onSubmit()\">\n      <input formControlName=\"email\" type=\"email\" autocomplete=\"email\">\n      <input formControlName=\"password\" type=\"password\" autocomplete=\"current-password\">\n      <button type=\"submit\" [disabled]=\"loginForm.invalid\">Login</button>\n    </form>\n  `\n})\nexport class LoginComponent {\n  loginForm = new FormGroup({\n    email: new FormControl('', [\n      Validators.required,\n      Validators.email,\n      Validators.maxLength(254)\n    ]),\n    password: new FormControl('', [\n      Validators.required,\n      Validators.minLength(8),\n      Validators.maxLength(128)\n    ])\n  })\n\n  onSubmit(): void {\n    if (this.loginForm.invalid) return\n\n    // Form values are typed and validated\n    const { email, password } = this.loginForm.value\n    this.authService.login(email!, password!).subscribe()\n  }\n}\n```\n\n### File Upload Validation\n\n```typescript\n@Component({\n  template: `\n    <input type=\"file\" (change)=\"onFileSelected($event)\" accept=\".pdf,.jpg,.png\">\n  `\n})\nexport class FileUploadComponent {\n  private readonly ALLOWED_TYPES = ['application/pdf', 'image/jpeg', 'image/png']\n  private readonly MAX_SIZE = 5 * 1024 * 1024  // 5MB\n\n  onFileSelected(event: Event): void {\n    const input = event.target as HTMLInputElement\n    const file = input.files?.[0]\n    if (!file) return\n\n    // Validate type\n    if (!this.ALLOWED_TYPES.includes(file.type)) {\n      this.showError('Invalid file type')\n      input.value = ''\n      return\n    }\n\n    // Validate size\n    if (file.size > this.MAX_SIZE) {\n      this.showError('File too large (max 5MB)')\n      input.value = ''\n      return\n    }\n\n    this.uploadFile(file)\n  }\n}\n```\n\n---\n\n## 6. Storage Security\n\n### Token Storage Best Practices\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class AuthService {\n  // ‚ùå WRONG: localStorage vulnerable to XSS\n  private saveTokenWrong(token: string): void {\n    localStorage.setItem('token', token)\n  }\n\n  // ‚úÖ BETTER: Memory storage (cleared on refresh)\n  private accessToken: string | null = null\n\n  setAccessToken(token: string): void {\n    this.accessToken = token\n  }\n\n  getAccessToken(): string | null {\n    return this.accessToken\n  }\n\n  // ‚úÖ BEST: httpOnly cookies (handled by server)\n  // Frontend never sees the token\n  login(credentials: LoginDto): Observable<void> {\n    return this.http.post<void>('/api/auth/login', credentials, {\n      withCredentials: true  // Server sets httpOnly cookie\n    })\n  }\n}\n```\n\n### Secure Session Management\n\n```typescript\n@Injectable({ providedIn: 'root' })\nexport class SessionService {\n  private sessionTimeout: number | null = null\n  private readonly SESSION_DURATION = 15 * 60 * 1000  // 15 minutes\n\n  startSession(): void {\n    this.resetTimeout()\n    this.setupActivityListeners()\n  }\n\n  private resetTimeout(): void {\n    if (this.sessionTimeout) {\n      clearTimeout(this.sessionTimeout)\n    }\n\n    this.sessionTimeout = window.setTimeout(() => {\n      this.logout()\n    }, this.SESSION_DURATION)\n  }\n\n  private setupActivityListeners(): void {\n    const events = ['mousedown', 'keydown', 'touchstart', 'scroll']\n    events.forEach(event => {\n      document.addEventListener(event, () => this.resetTimeout(), { passive: true })\n    })\n  }\n\n  logout(): void {\n    // Clear all sensitive data\n    this.accessToken = null\n    sessionStorage.clear()\n    // Navigate to login\n  }\n}\n```\n\n---\n\n## 7. Dependency Security\n\n### NPM Audit\n\n```bash\n# Check for vulnerabilities\nnpm audit\n\n# Auto-fix where possible\nnpm audit fix\n\n# In CI/CD\nnpm audit --audit-level=high || exit 1\n```\n\n### Angular Update\n\n```bash\n# Check for updates\nng update\n\n# Update Angular packages\nng update @angular/core @angular/cli\n\n# Always test after updates\nnpm test\nnpm run build\n```\n\n---\n\n## Security Checklist\n\n### Before Deployment\n\n**XSS Prevention:**\n- [ ] No `bypassSecurityTrust*` with user input\n- [ ] All user content displayed via interpolation `{{ }}`\n- [ ] URLs validated before use\n- [ ] Template strict mode enabled\n\n**Authentication:**\n- [ ] Tokens stored securely (memory or httpOnly cookies)\n- [ ] Auto logout on token expiry\n- [ ] Session timeout implemented\n- [ ] Interceptors handle 401 responses\n\n**Authorization:**\n- [ ] Route guards protect sensitive routes\n- [ ] CanMatch prevents unauthorized module loading\n- [ ] Role-based access enforced\n- [ ] Return URLs validated\n\n**HTTP Security:**\n- [ ] HTTPS enforced in production\n- [ ] XSRF configuration correct\n- [ ] Sensitive data never in URLs\n- [ ] Credentials included for cookies\n\n**Forms:**\n- [ ] All inputs validated (client + server)\n- [ ] File uploads validated (type, size)\n- [ ] Autocomplete attributes set correctly\n\n**Build:**\n- [ ] AOT compilation enabled\n- [ ] Production mode enabled\n- [ ] Source maps disabled in production\n- [ ] npm audit clean\n\n**CSP:**\n- [ ] Content Security Policy configured\n- [ ] X-Frame-Options: DENY\n- [ ] Strict-Transport-Security header\n",
        "plugins/lt-dev/skills/generating-nest-servers/SKILL.md": "---\nname: generating-nest-servers\ndescription: PRIMARY expert for ALL NestJS and @lenne.tech/nest-server tasks. ALWAYS use this skill when working in projects with @lenne.tech/nest-server in package.json dependencies (supports monorepos with projects/*, packages/*, apps/* structure), or when asked about NestJS modules, services, controllers, resolvers, models, objects, tests, server creation, debugging, or any NestJS/nest-server development task. Handles lt server commands, security analysis, test creation, and all backend development. ALWAYS reads CrudService base class before working with Services.\n---\n\n# NestJS Server Development Expert\n\nYou are the **PRIMARY expert** for NestJS backend development and the @lenne.tech/nest-server framework. This skill handles **ALL NestJS-related tasks**, from analysis to creation to debugging:\n\n## When to Use This Skill\n\n**ALWAYS use this skill for:**\n\n### Analysis & Understanding\n- Analyzing existing NestJS code structure\n- Understanding how modules, services, controllers work\n- Reviewing project architecture\n- Mapping relationships between modules\n- Reading and explaining NestJS code\n- Finding specific implementations (controllers, services, etc.)\n\n### Running & Debugging\n- Starting the NestJS server (`npm start`, `npm run dev`)\n- Debugging server issues and errors\n- Running tests (`npm test`)\n- Checking server logs and output\n- Configuring environment variables\n- Troubleshooting build/compile errors\n\n### Creation & Modification\n- Creating new modules with `lt server module`\n- Creating new objects with `lt server object`\n- Adding properties with `lt server addProp`\n- Creating a new server with `lt server create`\n- Modifying existing code (services, controllers, resolvers)\n- Adding relationships between modules\n- Managing dependencies and imports\n\n### Testing & Validation\n- Creating API tests for controllers/resolvers\n- Running and fixing failing tests\n- Testing endpoints manually\n- Validating data models and schemas\n- Testing authentication and permissions\n\n### General NestJS Tasks\n- Answering NestJS/nest-server questions\n- Explaining framework concepts\n- Discussing architecture decisions\n- Recommending best practices\n- Refactoring existing code\n\n**Rule: If it involves NestJS or @lenne.tech/nest-server in ANY way, use this skill!**\n\n## Recommended: Test-Driven Development (TDD)\n\n**Use TDD for robust, maintainable code:**\n\n```\n1. Write API tests FIRST (REST/GraphQL endpoint tests)\n2. Implement backend code until tests pass\n3. Iterate until all tests green\n4. Then proceed to frontend (E2E tests first)\n```\n\n**Why TDD?**\n- Catches bugs early\n- Documents expected behavior\n- Enables safe refactoring\n- Ensures security requirements are tested\n\n**For TDD workflow, use `building-stories-with-tdd` skill** - it coordinates backend and frontend test-first development.\n\n### Test Cleanup (CRITICAL)\n\n```typescript\nafterAll(async () => {\n  // Clean up test-created entities\n  await db.collection('entities').deleteMany({ createdBy: testUserId });\n  await db.collection('users').deleteMany({ email: /@test\\.com$/ });\n});\n```\n\n**Use separate test database:** `app-test` instead of `app-dev`\n\n## Related Skills\n\n**Works closely with:**\n- `developing-lt-frontend` skill - For ALL Nuxt/Vue frontend development (projects/app/)\n- `building-stories-with-tdd` skill - For building user stories with Test-Driven Development\n- `using-lt-cli` skill - For Git operations and Fullstack initialization\n- `nest-server-updating` skill - For updating @lenne.tech/nest-server to latest version\n\n**When to use which:**\n- Nuxt/Vue frontend work? Use `developing-lt-frontend` skill\n- Building features with TDD workflow? Use `building-stories-with-tdd` skill (it will use this skill for implementation)\n- Need Git operations? Use `using-lt-cli` skill\n- Updating @lenne.tech/nest-server? Use `nest-server-updating` skill\n\n**In monorepo projects:**\n- `projects/api/` or `packages/api/` ‚Üí This skill (generating-nest-servers)\n- `projects/app/` or `packages/app/` ‚Üí `developing-lt-frontend` skill\n- Direct NestJS work? Use this skill\n\n## TypeScript Language Server (Recommended)\n\n**Use the LSP tool when available** for better code intelligence in TypeScript/NestJS projects:\n\n| Operation | Use Case |\n|-----------|----------|\n| `goToDefinition` | Find where a class, function, or type is defined |\n| `findReferences` | Find all usages of a symbol across the codebase |\n| `hover` | Get type information and documentation for a symbol |\n| `documentSymbol` | List all classes, functions, and variables in a file |\n| `workspaceSymbol` | Search for symbols across the entire project |\n| `goToImplementation` | Find implementations of interfaces or abstract methods |\n| `incomingCalls` | Find all callers of a function/method |\n| `outgoingCalls` | Find all functions called by a function/method |\n\n**When to use LSP:**\n- Navigating unfamiliar code ‚Üí `goToDefinition`, `findReferences`\n- Understanding inheritance ‚Üí `goToImplementation`\n- Analyzing dependencies ‚Üí `incomingCalls`, `outgoingCalls`\n- Exploring file structure ‚Üí `documentSymbol`\n- Finding symbols by name ‚Üí `workspaceSymbol`\n\n**Installation (if LSP not available):**\n```bash\nclaude plugins install typescript-lsp --marketplace claude-plugins-official\n```\n\n---\n\n## CRITICAL SECURITY RULES - READ FIRST\n\n**Before you start ANY work, understand these NON-NEGOTIABLE rules:**\n\n### NEVER Do This:\n1. **NEVER remove or weaken `@Restricted()` decorators**\n2. **NEVER change `@Roles()` decorators** to more permissive roles\n3. **NEVER modify `securityCheck()` logic** to bypass security\n4. **NEVER remove class-level `@Restricted(RoleEnum.ADMIN)`**\n\n### ALWAYS Do This:\n1. **ALWAYS analyze permissions BEFORE writing tests**\n2. **ALWAYS test with the LEAST privileged user** who is authorized\n3. **ALWAYS adapt tests to security requirements**, never vice versa\n4. **ALWAYS ask developer for approval** before changing ANY security decorator\n\n**Complete security rules with all details, examples, and testing strategies: `security-rules.md`**\n**Comprehensive OWASP Secure Coding Practices checklist: `owasp-checklist.md`**\n\n## CRITICAL: NEVER USE `declare` KEYWORD FOR PROPERTIES\n\n**DO NOT use the `declare` keyword when defining properties in classes!**\n\n```typescript\n// WRONG\ndeclare name: string;  // Decorator won't work!\n\n// CORRECT\n@UnifiedField({ description: 'Product name' })\nname: string;  // Decorator works properly\n```\n\n**Why**: `declare` prevents decorators from being applied, breaking the decorator system.\n\n**Complete explanation and correct patterns: `declare-keyword-warning.md`**\n\n## CRITICAL: DESCRIPTION MANAGEMENT\n\n**Descriptions must be applied consistently to EVERY component.**\n\n**Quick 3-Step Process:**\n1. Extract descriptions from user's `// comments`\n2. Format: `'English text'` or `'English (Deutsch)'` for German input\n3. Apply EVERYWHERE: Model, CreateInput, UpdateInput, Objects, Class-level decorators\n\n**Complete formatting rules, examples, and verification checklist: `description-management.md`**\n\n---\n\n## Core Responsibilities\n\nThis skill handles **ALL** NestJS server development tasks, including:\n\n### Simple Tasks (Single Commands)\n- Creating a single module with `lt server module`\n- Creating a single object with `lt server object`\n- Adding properties with `lt server addProp`\n- Creating a new server with `lt server create`\n- Starting the server with `npm start` or `npm run dev`\n- Running tests with `npm test`\n\n### Complex Tasks (Multiple Components)\nWhen you receive a complete structure specification, you will:\n\n1. **Parse and analyze** the complete structure (modules, models, objects, properties, relationships)\n2. **Create a comprehensive todo list** breaking down all tasks\n3. **Generate all components** in the correct order (objects first, then modules)\n4. **Handle inheritance** properly (Core and custom parent classes)\n5. **Manage descriptions** (translate German to English, add originals in parentheses)\n6. **Create API tests** for all controllers and resolvers\n7. **Verify functionality** and provide a summary with observations\n\n### Analysis Tasks\nWhen analyzing existing code:\n\n1. **Explore the project structure** to understand the architecture\n2. **Read relevant files** (modules, services, controllers, models)\n3. **Identify patterns** and conventions used in the project\n4. **Explain findings** clearly and concisely\n5. **Suggest improvements** when appropriate\n\n### Debugging Tasks\nWhen debugging issues:\n\n1. **Read error messages and logs** carefully\n2. **Identify the root cause** by analyzing relevant code\n3. **Check configuration** (environment variables, config files)\n4. **Test hypotheses** by examining related files\n5. **Provide solutions** with code examples\n\n**Remember:** For ANY task involving NestJS or @lenne.tech/nest-server, use this skill!\n\n## Understanding the Framework\n\n**Complete framework guide: `framework-guide.md`**\n\n**Critical Rules:**\n- [ ] Read CrudService before modifying any Service (`node_modules/@lenne.tech/nest-server/src/core/common/services/crud.service.ts`)\n- [ ] NEVER blindly pass all serviceOptions to other Services (only pass `currentUser`)\n- [ ] Check if CrudService already provides needed functionality (create, find, findOne, update, delete, pagination)\n\n## Configuration File & Commands\n\n**Complete guide: `configuration.md`**\n\n**Quick Command Reference:**\n```bash\n# Create complete module (REST is default!)\nlt server module --name Product --controller Rest\n\n# Create SubObject\nlt server object --name Address\n\n# Add properties\nlt server addProp --type Module --element User\n\n# New project\nlt server create <server-name>\n```\n\n**API Style: REST is the default!**\n- **REST** (default): Use `--controller Rest` - Standard for all modules unless explicitly requested otherwise\n- **GraphQL**: Use `--controller GraphQL` - ONLY when user explicitly requests GraphQL\n- **Both**: Use `--controller Both` - ONLY when user explicitly wants both REST and GraphQL\n\n**Essential Property Flags:**\n- `--prop-name-X / --prop-type-X` - Name and type (string|number|boolean|ObjectId|Json|Date|bigint)\n- `--prop-nullable-X` / `--prop-array-X` - Modifiers\n- `--prop-enum-X / --prop-schema-X / --prop-reference-X` - Complex types\n\n## Service Health Check (MANDATORY)\n\n**Before starting ANY backend work, check if services are running:**\n\n```bash\n# Check if API is running (Port 3000)\ncurl -s -o /dev/null -w \"%{http_code}\" http://localhost:3000/api\n\n# Check if port is in use (alternative)\nlsof -i :3000\n```\n\n**Workflow:**\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  BEFORE starting backend work:                                 ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  1. CHECK if Port 3000 is in use:                              ‚îÇ\n‚îÇ     lsof -i :3000                                              ‚îÇ\n‚îÇ     - If port in use: API already running, proceed             ‚îÇ\n‚îÇ     - If port free: Start API                                  ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  2. START API (if not running):                                ‚îÇ\n‚îÇ     cd projects/api && npm run start:dev &                     ‚îÇ\n‚îÇ     - Wait until API responds (max 30s)                        ‚îÇ\n‚îÇ     - Verify: curl -s http://localhost:3000/api                ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  3. FOR FULLSTACK WORK (API + Frontend):                       ‚îÇ\n‚îÇ     Also check Port 3001 for frontend                          ‚îÇ\n‚îÇ     cd projects/app && npm run dev &                           ‚îÇ\n‚îÇ                                                                ‚îÇ\n‚îÇ  4. ONLY THEN proceed with development                         ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Starting Services (if not running):**\n\n```bash\n# Start API in background (from monorepo root)\ncd projects/api && npm run start:dev &\n\n# Optional: Start Frontend too (Port 3001)\ncd projects/app && npm run dev &\n```\n\n**Important:**\n- Always check with `lsof -i :3000` BEFORE starting to avoid duplicate processes\n- If port is in use but service not responding, kill the process first: `kill $(lsof -t -i :3000)`\n- For tests that require running server, ensure API is started first\n\n## Prerequisites Check\n\n**Setup:**\n```bash\nlt --version  # Check CLI installation\nnpm install -g @lenne.tech/cli  # If needed\nls src/server/modules  # Verify project structure\n```\n\n**Creating New Server:**\n```bash\nlt server create <server-name>\n```\n\n**Post-creation verification:** Check `src/config.env.ts` for replaced secrets and correct database URIs.\n\n## Understanding the Specification Format\n\n**Complete reference and examples: `reference.md` and `examples.md`**\n\n**Quick Type Reference:**\n- Basic: `string`, `number`, `boolean`, `Date`, `bigint`, `Json`\n- Arrays: `type[]` -> add `--prop-array-X true`\n- Optional: `property?: type` -> add `--prop-nullable-X true`\n- References: `User` -> use `--prop-type-X ObjectId --prop-reference-X User`\n- Embedded: `Address` -> use `--prop-schema-X Address`\n- Enums: `ENUM (VAL1, VAL2)` -> use `--prop-enum-X PropertyNameEnum`\n\n## Workflow Process\n\n**Complete details: `workflow-process.md`**\n\n**7-Phase Workflow:**\n1. Analysis & Planning - Parse spec, create todo list\n2. SubObject Creation - Create in dependency order\n3. Module Creation - Create with all properties\n4. Inheritance Handling - Update extends, CreateInput must include parent fields\n5. **Description Management** (CRITICAL) - Extract from comments, format as \"ENGLISH (DEUTSCH)\", apply everywhere\n6. Enum File Creation - Manual creation in `src/server/common/enums/`\n7. API Test Creation - **MANDATORY:** Analyze permissions first, use least privileged user, test failures\n\n**Critical Testing Rules:**\n- Test via REST/GraphQL using TestHelper (NEVER direct Service tests)\n- Analyze @Roles decorators BEFORE writing tests\n- Use appropriate user role (not admin when S_USER works)\n- Test unauthorized access failures (401/403)\n\n## Property Ordering\n\n**ALL properties must be in alphabetical order** in Model, Input, and Output files. Verify and reorder after generating.\n\n## Verification Checklist\n\n**Complete checklist: `verification-checklist.md`**\n\n**Essential Checks:**\n- [ ] All components created with descriptions (Model + CreateInput + UpdateInput)\n- [ ] Properties in alphabetical order\n- [ ] Permission analysis BEFORE writing tests\n- [ ] Least privileged user used in tests\n- [ ] Security validation tests (401/403 failures)\n- [ ] All tests pass\n\n## Error Handling\n\n**Common Issues:**\n- **TypeScript errors** -> Add missing imports manually\n- **CreateInput validation fails** -> Check parent's CreateInput for required fields\n- **Tests fail with 403** -> Check @Roles decorator, use appropriate user role (not admin when S_USER works)\n- **Security tests not failing** -> Verify @Roles and securityCheck() logic, fix model/controller if needed\n\n## Phase 8: Pre-Report Quality Review\n\n**Complete process: `quality-review.md`**\n\n**7 Steps:**\n1. Identify all changes (git)\n2. Test management (analyze existing tests, create new, follow patterns)\n3. Compare with existing code (consistency)\n4. Critical analysis (style, structure, quality)\n5. Automated optimizations (imports, properties, formatting)\n6. Pre-report testing (build, lint, all tests must pass)\n7. Final verification (complete checklist)\n\n**Critical:** Understand TestHelper, analyze existing tests first, use appropriate user roles, all tests must pass.\n\n## Final Report\n\nAfter completing all tasks, provide:\n1. Summary of created components (SubObjects, Objects, Modules, enums, tests)\n2. Observations about data structure\n3. Test results (all passing)\n4. Next steps\n\n## Best Practices\n\n1. Create dependencies first (SubObjects before Modules)\n2. Check for circular dependencies\n3. Test incrementally, commit after major components\n4. **Use REST controller by default** - Only use GraphQL when explicitly requested\n5. Validate required fields in tests\n6. Document complex relationships\n\n## Working with This Skill\n\nWhen receiving a specification:\n1. Parse completely, ask clarifying questions\n2. Create detailed todo list\n3. Execute systematically following workflow\n4. Verify each step, report progress\n5. Provide comprehensive summary\n",
        "plugins/lt-dev/skills/generating-nest-servers/configuration.md": "---\nname: nest-server-generator-configuration\ndescription: Complete guide to lt.config.json configuration file\n---\n\n# Configuration Guide\n\n## Table of Contents\n- [Configuration File (lt.config.json)](#configuration-file-ltconfigjson)\n- [Command Syntax Reference](#command-syntax-reference)\n\n## Configuration File (lt.config.json)\n\nThe lenne.tech CLI supports project-level configuration via `lt.config.json` files. This allows you to set default values for commands, eliminating the need for repeated CLI parameters or interactive prompts.\n\n### File Location and Hierarchy\n\n- **Location**: Place `lt.config.json` in your project root or any parent directory\n- **Hierarchy**: The CLI searches from the current directory up to the root, merging configurations\n- **Priority** (lowest to highest):\n  1. Default values (hardcoded in CLI)\n  2. Config from parent directories (higher up = lower priority)\n  3. Config from current directory\n  4. CLI parameters (`--flag value`)\n  5. Interactive user input\n\n### Configuration Structure\n\n```json\n{\n  \"meta\": {\n    \"version\": \"1.0.0\",\n    \"name\": \"My Project\",\n    \"description\": \"Optional project description\"\n  },\n  \"commands\": {\n    \"server\": {\n      \"module\": {\n        \"controller\": \"Both\",\n        \"skipLint\": false\n      },\n      \"object\": {\n        \"skipLint\": false\n      },\n      \"addProp\": {\n        \"skipLint\": false\n      }\n    }\n  }\n}\n```\n\n### Available Configuration Options\n\n**Server Module Configuration (`commands.server.module`)**:\n- `controller`: Default controller type (`\"Rest\"` | `\"GraphQL\"` | `\"Both\"` | `\"auto\"`)\n- `skipLint`: Skip lint prompt after module creation (boolean)\n\n**Server Object Configuration (`commands.server.object`)**:\n- `skipLint`: Skip lint prompt after object creation (boolean)\n\n**Server AddProp Configuration (`commands.server.addProp`)**:\n- `skipLint`: Skip lint prompt after adding property (boolean)\n\n### Using Configuration in Commands\n\n**Example 1: Configure controller type globally**\n```json\n{\n  \"commands\": {\n    \"server\": {\n      \"module\": {\n        \"controller\": \"Rest\"\n      }\n    }\n  }\n}\n```\n\nNow all `lt server module` commands will default to REST controllers:\n```bash\n# Uses \"Rest\" from config (no prompt)\nlt server module --name Product --prop-name-0 name --prop-type-0 string\n```\n\n**Example 2: Override config with CLI parameter**\n```bash\n# Ignores config, uses GraphQL\nlt server module --name Product --controller GraphQL\n```\n\n**Example 3: Auto-detect from config**\n```json\n{\n  \"commands\": {\n    \"server\": {\n      \"module\": {\n        \"controller\": \"auto\"\n      }\n    }\n  }\n}\n```\n\nNow the CLI will auto-detect controller type from existing modules without prompting.\n\n### Managing Configuration\n\n**Initialize configuration**:\n```bash\nlt config init\n```\n\n**Show current configuration** (merged from all hierarchy levels):\n```bash\nlt config show\n```\n\n**Get help**:\n```bash\nlt config help\n```\n\n### When to Use Configuration\n\n** Use configuration when:**\n- Creating multiple modules with the same controller type\n- Working in a team with agreed-upon conventions\n- Automating module generation in CI/CD\n- You want to skip repetitive prompts\n\n** Don't use configuration when:**\n- Creating a single module with specific requirements\n- Each module needs a different controller type\n- You're just testing or experimenting\n\n### Best Practices\n\n1. **Project Root**: Place `lt.config.json` in your project root\n2. **Version Control**: Commit the config file to share with your team\n3. **Documentation**: Add a README note explaining the config choices\n4. **Override When Needed**: Use CLI parameters to override for special cases\n\n###  IMPORTANT: Configuration After Server Creation\n\n**CRITICAL WORKFLOW**: After creating a new server with `lt server create`, you **MUST** initialize the configuration file to set project conventions.\n\n#### Automatic Post-Creation Setup\n\nWhen you create a new NestJS server, immediately follow these steps:\n\n1. **Navigate to the API directory**:\n   ```bash\n   cd projects/api\n   ```\n\n2. **Create the configuration file manually**:\n   ```bash\n   # Create lt.config.json with controller preference\n   ```\n\n3. **Ask the developer for their preference** (if not already specified):\n   ```\n   What controller type do you prefer for new modules in this project?\n   1. Rest - REST controllers only\n   2. GraphQL - GraphQL resolvers only\n   3. Both - Both REST and GraphQL\n   4. auto - Auto-detect from existing modules\n   ```\n\n4. **Write the configuration** based on the answer:\n   ```json\n   {\n     \"meta\": {\n       \"version\": \"1.0.0\"\n     },\n     \"commands\": {\n       \"server\": {\n         \"module\": {\n           \"controller\": \"Rest\"\n         }\n       }\n     }\n   }\n   ```\n\n#### Why This Is Important\n\n-  **Consistency**: All modules will follow the same pattern\n-  **No Prompts**: Developers won't be asked for controller type repeatedly\n-  **Team Alignment**: Everyone uses the same conventions\n-  **Automation**: Scripts and CI/CD can create modules without interaction\n\n#### Example Workflow\n\n```bash\n# User creates new server\nlt server create --name MyAPI\n\n# You (Claude) navigate to API directory\ncd projects/api\n\n# You ask the user\n\"I've created the server. What controller type would you like to use for modules?\"\n\"1. Rest (REST only)\"\n\"2. GraphQL (GraphQL only)\"\n\"3. Both (REST + GraphQL)\"\n\"4. auto (Auto-detect)\"\n\n# User answers: \"Rest\"\n\n# You create lt.config.json\n{\n  \"meta\": {\n    \"version\": \"1.0.0\"\n  },\n  \"commands\": {\n    \"server\": {\n      \"module\": {\n        \"controller\": \"Rest\"\n      }\n    }\n  }\n}\n\n# Confirm to user\n\" Configuration saved! All new modules will default to REST controllers.\"\n\"You can change this anytime by editing lt.config.json or running 'lt config init'.\"\n```\n\n#### Configuration Options Explained\n\n**\"Rest\"**:\n-  Creates REST controllers (`@Controller()`)\n-  No GraphQL resolvers\n-  No PubSub integration\n- **Best for**: Traditional REST APIs, microservices\n\n**\"GraphQL\"**:\n-  No REST controllers\n-  Creates GraphQL resolvers (`@Resolver()`)\n-  Includes PubSub for subscriptions\n- **Best for**: GraphQL-first APIs, real-time apps\n\n**\"Both\"**:\n-  Creates REST controllers\n-  Creates GraphQL resolvers\n-  Includes PubSub\n- **Best for**: Hybrid APIs, gradual migration\n\n**\"auto\"**:\n- ü§ñ Analyzes existing modules\n- ü§ñ Detects pattern automatically\n- ü§ñ No user prompt\n- **Best for**: Following existing conventions\n\n#### When NOT to Create Config\n\nSkip config creation if:\n-  User is just testing/experimenting\n-  User explicitly says \"no configuration\"\n-  Project already has lt.config.json\n\n### Integration with Commands\n\nWhen generating code, **ALWAYS check for configuration**:\n1. Load config via `lt config show` or check for `lt.config.json`\n2. Use configured values in command construction\n3. Only pass CLI parameters when overriding config\n\n**Example: Generating module with config**\n```bash\n# Check if config exists and what controller type is configured\n# If config has \"controller\": \"Rest\", use it\nlt server module --name Product --prop-name-0 name --prop-type-0 string\n\n# If config has \"controller\": \"auto\", let CLI detect\nlt server module --name Order --prop-name-0 total --prop-type-0 number\n\n# Override config when needed\nlt server module --name User --controller Both\n```\n\n## Command Syntax Reference\n",
        "plugins/lt-dev/skills/generating-nest-servers/declare-keyword-warning.md": "---\nname: nest-server-generator-declare-keyword\ndescription: Critical warning about using the declare keyword in TypeScript classes\n---\n\n#  CRITICAL: NEVER USE `declare` KEYWORD FOR PROPERTIES\n\n## Table of Contents\n- [WRONG - Using `declare`](#-wrong---using-declare)\n- [CORRECT - Without `declare`](#-correct---without-declare)\n- [Why This Matters](#why-this-matters)\n- [When You Might Be Tempted to Use `declare`](#when-you-might-be-tempted-to-use-declare)\n- [Correct Approach Instead](#correct-approach-instead)\n- [Examples](#examples)\n- [Remember](#remember)\n\n** IMPORTANT RULE: DO NOT use the `declare` keyword when defining properties in classes!**\n\nThe `declare` keyword in TypeScript signals that a property is only a type declaration without a runtime value. This prevents decorators from being properly applied and overridden.\n\n---\n\n##  WRONG - Using `declare`\n\n```typescript\nexport class ProductCreateInput extends ProductInput {\n  declare name: string;  //  WRONG - Decorator won't be applied!\n  declare price: number; //  WRONG - Decorator won't be applied!\n}\n```\n\n---\n\n##  CORRECT - Without `declare`\n\n```typescript\nexport class ProductCreateInput extends ProductInput {\n  @UnifiedField({ description: 'Product name' })\n  name: string;  //  CORRECT - Decorator works properly\n\n  @UnifiedField({ description: 'Product price' })\n  price: number; //  CORRECT - Decorator works properly\n}\n```\n\n---\n\n## Why This Matters\n\n1. **Decorators require actual properties**: `@UnifiedField()`, `@Restricted()`, and other decorators need actual property declarations to attach metadata\n2. **Override behavior**: When extending classes, using `declare` prevents decorators from being properly overridden\n3. **Runtime behavior**: `declare` properties don't exist at runtime, breaking the decorator system\n\n---\n\n## When You Might Be Tempted to Use `declare`\n\n-  When extending a class and wanting to change a decorator\n-  When TypeScript shows \"property is declared but never used\"\n-  When dealing with inheritance and property redefinition\n\n---\n\n## Correct Approach Instead\n\nUse the `override` keyword (when appropriate) but NEVER `declare`:\n\n```typescript\nexport class ProductCreateInput extends ProductInput {\n  //  Use override when useDefineForClassFields is enabled\n  override name: string;\n\n  //  Apply decorators directly - they will override parent decorators\n  @UnifiedField({ description: 'Product name', isOptional: false })\n  override price: number;\n}\n```\n\n---\n\n## Examples\n\n###  WRONG - Using declare\n\n```typescript\n// This will BREAK decorator functionality\nexport class AddressInput extends Address {\n  declare street: string;\n  declare city: string;\n  declare zipCode: string;\n}\n```\n\n###  CORRECT - Without declare\n\n```typescript\n// This works properly\nexport class AddressInput extends Address {\n  @UnifiedField({ description: 'Street' })\n  street: string;\n\n  @UnifiedField({ description: 'City' })\n  city: string;\n\n  @UnifiedField({ description: 'Zip code' })\n  zipCode: string;\n}\n```\n\n###  CORRECT - With override\n\n```typescript\n// This also works when extending decorated properties\nexport class AddressInput extends Address {\n  @UnifiedField({ description: 'Street', isOptional: false })\n  override street: string;\n\n  @UnifiedField({ description: 'City', isOptional: false })\n  override city: string;\n\n  @UnifiedField({ description: 'Zip code', isOptional: true })\n  override zipCode?: string;\n}\n```\n\n---\n\n## Remember\n\n**`declare` = no decorators = broken functionality!**\n\nAlways use actual property declarations with decorators, optionally with the `override` keyword when extending classes.\n",
        "plugins/lt-dev/skills/generating-nest-servers/description-management.md": "---\nname: nest-server-generator-description-management\ndescription: Guidelines for consistent description management across all generated components\n---\n\n#  CRITICAL: Description Management\n\n## Table of Contents\n- [Step 1: ALWAYS Extract Descriptions from User Input](#-step-1-always-extract-descriptions-from-user-input)\n- [Step 2: Format Descriptions Correctly](#-step-2-format-descriptions-correctly)\n- [Step 3: Apply Descriptions EVERYWHERE (Most Critical!)](#-step-3-apply-descriptions-everywhere-most-critical)\n- [Common Mistakes to AVOID](#-common-mistakes-to-avoid)\n- [Verification Checklist](#-verification-checklist)\n- [If You Forget](#-if-you-forget)\n- [Quick Reference](#quick-reference)\n\n** COMMON MISTAKE:** Descriptions are often applied inconsistently or only partially. You MUST follow this process for EVERY component.\n\n---\n\n##  Step 1: ALWAYS Extract Descriptions from User Input\n\n**BEFORE generating ANY code, scan the user's specification for description hints:**\n\n1. **Look for comments after `//`**:\n   ```\n   Module: Product\n   - name: string // Product name\n   - price: number // Produktpreis\n   - stock?: number // Current stock level\n   ```\n\n2. **Extract ALL comments** and store them for each property\n3. **Identify language** (English or German)\n\n---\n\n##  Step 2: Format Descriptions Correctly\n\n**Rule**: `\"ENGLISH_DESCRIPTION (DEUTSCHE_BESCHREIBUNG)\"`\n\n### Processing Logic\n\n| User Input | Language | Formatted Description |\n|------------|----------|----------------------|\n| `// Product name` | English | `'Product name'` |\n| `// Produktname` | German | `'Product name (Produktname)'` |\n| `// Stra√üe` | German | `'Street (Stra√üe)'` |\n| `// Postleizahl` (typo) | German | `'Postal code (Postleitzahl)'` |\n| (no comment) | - | Create meaningful English description |\n\n###  CRITICAL - Preserving Original Text\n\n**1. Fix spelling errors ONLY:**\n-  Correct typos: `Postleizahl` -> `Postleitzahl` (missing 't')\n-  Fix character errors: `Star√üe` -> `Stra√üe` (wrong character)\n-  Correct English typos: `Prodcut name` -> `Product name`\n\n**2. DO NOT change the wording:**\n-  NEVER rephrase: `Stra√üe` -> `Stra√üenname` (NO!)\n-  NEVER expand: `Produkt` -> `Produktbezeichnung` (NO!)\n-  NEVER improve: `Name` -> `Full name` (NO!)\n-  NEVER translate differently: `Name` -> `Title` (NO!)\n\n**3. Why this is critical:**\n- User comments may be **predefined terms** from requirements\n- External systems may **reference these exact terms**\n- Changing wording breaks **external integrations**\n\n### Examples\n\n```\n CORRECT:\n// Stra√üe -> 'Street (Stra√üe)'  (only translated)\n// Star√üe -> 'Street (Stra√üe)'  (typo fixed, then translated)\n// Produkt -> 'Product (Produkt)'  (keep original word)\n// Strasse -> 'Street (Stra√üe)'  (ss ->√ü corrected, then translated)\n\n WRONG:\n// Stra√üe -> 'Street name (Stra√üenname)'  (changed wording!)\n// Produkt -> 'Product name (Produktname)'  (added word!)\n// Name -> 'Full name (Vollst√§ndiger Name)'  (rephrased!)\n```\n\n**Rule Summary**: Fix typos, preserve wording, translate accurately.\n\n---\n\n##  Step 3: Apply Descriptions EVERYWHERE (Most Critical!)\n\n** YOU MUST apply the SAME description to ALL of these locations:**\n\n### For Module Properties\n\n**1. Model file** (`<module>.model.ts`):\n```typescript\n@UnifiedField({ description: 'Product name (Produktname)' })\nname: string;\n```\n\n**2. Create Input** (`<module>-create.input.ts`):\n```typescript\n@UnifiedField({ description: 'Product name (Produktname)' })\nname: string;\n```\n\n**3. Update Input** (`<module>.input.ts`):\n```typescript\n@UnifiedField({ description: 'Product name (Produktname)' })\nname?: string;\n```\n\n### For SubObject Properties\n\n**1. Object file** (`<object>.object.ts`):\n```typescript\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet: string;\n```\n\n**2. Object Create Input** (`<object>-create.input.ts`):\n```typescript\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet: string;\n```\n\n**3. Object Update Input** (`<object>.input.ts`):\n```typescript\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet?: string;\n```\n\n### For Object/Module Type Decorators\n\nApply descriptions to the class decorators as well:\n\n```typescript\n@ObjectType({ description: 'Address information (Adressinformationen)' })\nexport class Address { ... }\n\n@InputType({ description: 'Address information (Adressinformationen)' })\nexport class AddressInput { ... }\n\n@ObjectType({ description: 'Product entity (Produkt-Entit√§t)' })\nexport class Product extends CoreModel { ... }\n```\n\n---\n\n##  Common Mistakes to AVOID\n\n1.  **Partial application**: Descriptions only in Models, not in Inputs\n2.  **Inconsistent format**: German-only in some places, English-only in others\n3.  **Missing descriptions**: No descriptions when user provided comments\n4.  **Ignoring Object inputs**: Forgetting to add descriptions to SubObject Input files\n5.  **Wrong format**: Using `(ENGLISH)` instead of `ENGLISH (DEUTSCH)`\n6.  **Changing wording**: Rephrasing user's original terms\n7.  **Adding words**: Expanding user's terminology\n\n---\n\n##  Verification Checklist\n\nAfter generating code, ALWAYS verify:\n\n- [ ] All user comments/descriptions extracted from specification\n- [ ] All descriptions follow format: `\"ENGLISH (DEUTSCH)\"` or `\"ENGLISH\"`\n- [ ] Model properties have descriptions\n- [ ] Create Input properties have SAME descriptions\n- [ ] Update Input properties have SAME descriptions\n- [ ] Object properties have descriptions\n- [ ] Object Input properties have SAME descriptions\n- [ ] Class-level `@ObjectType()` and `@InputType()` have descriptions\n- [ ] NO German-only descriptions (must be translated)\n- [ ] NO inconsistencies between files\n- [ ] Original wording preserved (only typos fixed)\n\n---\n\n##  If You Forget\n\n**If you generate code and realize descriptions are missing or inconsistent:**\n\n1. **STOP** - Don't continue with other phases\n2. **Go back** and add/fix ALL descriptions\n3. **Verify** using the checklist above\n4. **Then continue** with remaining phases\n\n**Remember**: Descriptions are NOT optional \"nice-to-have\" - they are MANDATORY for:\n- API documentation (Swagger/GraphQL)\n- Code maintainability\n- Developer experience\n- Bilingual projects (German/English teams)\n\n---\n\n## Quick Reference\n\n### Format Rules\n\n```\nEnglish input    -> 'Product name'\nGerman input     -> 'Product name (Produktname)'\nNo input         -> Create meaningful description\nTypo input       -> Fix typo, then translate\nMixed input      -> Standardize to 'ENGLISH (DEUTSCH)'\n```\n\n### Application Checklist\n\nFor **each property**:\n- [ ] Model file\n- [ ] Create Input file\n- [ ] Update Input file\n\nFor **each class**:\n- [ ] @ObjectType() decorator\n- [ ] @InputType() decorator (if applicable)\n\n### Remember\n\n- **Consistency is critical** - Same description everywhere\n- **Preserve wording** - Only fix typos, never rephrase\n- **Bilingual format** - Always use \"ENGLISH (DEUTSCH)\" for German terms\n- **Verification** - Check all files before proceeding\n",
        "plugins/lt-dev/skills/generating-nest-servers/examples.md": "---\nname: nest-server-generator-examples\ndescription: Complete examples for generating NestJS server structures from specifications\n---\n\n# NestJS Server Generator Examples\n\n## Table of Contents\n- [Example 1: Library Management System](#example-1-library-management-system)\n- [Example 2: Hotel Booking System (Minimal)](#example-2-hotel-booking-system-minimal)\n- [Key Patterns Demonstrated](#key-patterns-demonstrated)\n- [Best Practices from Examples](#best-practices-from-examples)\n- [Quality Review Workflow Example](#quality-review-workflow-example)\n\n## Example 1: Library Management System\n\nThis example demonstrates all features:\n- SubObjects (embedded data)\n- Objects (base models)\n- Modules with inheritance\n- ENUMs\n- Arrays\n- Optional properties\n- References between modules\n- German/English descriptions\n\n### Complete Specification\n\n```\n===========\n\nSubObject: Author // Author information\n- firstName: string // First name\n- lastName: string // Last name\n- birthDate?: Date // Date of birth\n- nationality?: string // Nationality\n\n===\n\nSubObject: Publisher // Publisher details\n- name: string // Publisher name\n- city: string // City\n- country: string // Country\n- foundedYear?: number // Year founded\n\n===\n\nSubObject: Review // Book review\n- rating: number // Rating (1-5)\n- comment?: string // Review comment\n- reviewerName: string // Name of reviewer\n- reviewDate: Date // Review date\n\n===\n\nObject: BaseItem // Base library item\nProperties:\n- title: string // Titel\n- description?: string // Beschreibung\n- available: boolean // Verf√ºgbar\n- location: string // Standort\n\n===\n\nModule: Book // Book module\n\nModel: Book // Buch\nExtends: BaseItem\n- isbn: string // ISBN-Nummer\n- authors: Author[] // Autoren\n- publisher: Publisher // Verlag\n- publishYear: number // Erscheinungsjahr\n- pageCount: number // Seitenzahl\n- language: ENUM (ENGLISH, GERMAN, FRENCH, SPANISH, OTHER) // Sprache\n- genre: ENUM (FICTION, NON_FICTION, SCIENCE, HISTORY, BIOGRAPHY, CHILDREN, FANTASY, MYSTERY, ROMANCE) // Genre\n- coverImage?: string // Cover image URL\n- reviews?: Review[] // Bewertungen\n- borrowedBy?: Member // Current borrower\n\n===\n\nModule: Member // Library member module\n\nModel: Member // Bibliotheksmitglied\n- memberNumber: string // Mitgliedsnummer\n- firstName: string // Vorname\n- lastName: string // Nachname\n- email: string // E-Mail-Adresse\n- phone?: string // Telefonnummer\n- joinDate: Date // Beitrittsdatum\n- status: ENUM (ACTIVE, SUSPENDED, EXPIRED) // Status\n- currentLoans: Book[] // Currently borrowed books\n\n===\n\nModule: Loan // Loan tracking module\n\nModel: Loan // Ausleihe\n- member: Member // Mitglied\n- book: Book // Buch\n- loanDate: Date // Ausleihdatum\n- dueDate: Date // F√§lligkeitsdatum\n- returnDate?: Date // R√ºckgabedatum\n- status: ENUM (ACTIVE, OVERDUE, RETURNED, LOST) // Status\n- renewalCount: number // Anzahl der Verl√§ngerungen\n- fine?: number // Geb√ºhr bei Versp√§tung\n\n===========\n```\n\n### Generated Commands Sequence\n\n#### Step 1: Create SubObjects\n\n```bash\n# Author SubObject\nlt server object --name Author \\\n  --prop-name-0 birthDate --prop-type-0 Date --prop-nullable-0 true \\\n  --prop-name-1 firstName --prop-type-1 string \\\n  --prop-name-2 lastName --prop-type-2 string \\\n  --prop-name-3 nationality --prop-type-3 string --prop-nullable-3 true\n\n# Publisher SubObject\nlt server object --name Publisher \\\n  --prop-name-0 city --prop-type-0 string \\\n  --prop-name-1 country --prop-type-1 string \\\n  --prop-name-2 foundedYear --prop-type-2 number --prop-nullable-2 true \\\n  --prop-name-3 name --prop-type-3 string\n\n# Review SubObject\nlt server object --name Review \\\n  --prop-name-0 comment --prop-type-0 string --prop-nullable-0 true \\\n  --prop-name-1 rating --prop-type-1 number \\\n  --prop-name-2 reviewDate --prop-type-2 Date \\\n  --prop-name-3 reviewerName --prop-type-3 string\n```\n\n#### Step 2: Create Base Object\n\n```bash\n# BaseItem Object\nlt server object --name BaseItem \\\n  --prop-name-0 available --prop-type-0 boolean \\\n  --prop-name-1 description --prop-type-1 string --prop-nullable-1 true \\\n  --prop-name-2 location --prop-type-2 string \\\n  --prop-name-3 title --prop-type-3 string\n```\n\n#### Step 3: Create Modules\n\n```bash\n# Member Module (create first as it's referenced by Book)\n# REST is the default - only use GraphQL when explicitly requested\nlt server module --name Member --controller Rest \\\n  --prop-name-0 email --prop-type-0 string \\\n  --prop-name-1 firstName --prop-type-1 string \\\n  --prop-name-2 joinDate --prop-type-2 Date \\\n  --prop-name-3 lastName --prop-type-3 string \\\n  --prop-name-4 memberNumber --prop-type-4 string \\\n  --prop-name-5 phone --prop-type-5 string --prop-nullable-5 true \\\n  --prop-name-6 status --prop-enum-6 MemberStatusEnum\n\n# Book Module (references Member)\nlt server module --name Book --controller Rest \\\n  --prop-name-0 authors --prop-schema-0 Author --prop-array-0 true \\\n  --prop-name-1 borrowedBy --prop-type-1 ObjectId --prop-reference-1 Member --prop-nullable-1 true \\\n  --prop-name-2 coverImage --prop-type-2 string --prop-nullable-2 true \\\n  --prop-name-3 genre --prop-enum-3 BookGenreEnum \\\n  --prop-name-4 isbn --prop-type-4 string \\\n  --prop-name-5 language --prop-enum-5 BookLanguageEnum \\\n  --prop-name-6 pageCount --prop-type-6 number \\\n  --prop-name-7 publishYear --prop-type-7 number \\\n  --prop-name-8 publisher --prop-schema-8 Publisher \\\n  --prop-name-9 reviews --prop-schema-9 Review --prop-array-9 true --prop-nullable-9 true\n\n# Add currentLoans to Member (after Book is created)\nlt server addProp --type Module --element Member \\\n  --prop-name-0 currentLoans --prop-type-0 ObjectId --prop-reference-0 Book --prop-array-0 true\n\n# Loan Module (references both Member and Book)\nlt server module --name Loan --controller Rest \\\n  --prop-name-0 book --prop-type-0 ObjectId --prop-reference-0 Book \\\n  --prop-name-1 dueDate --prop-type-1 Date \\\n  --prop-name-2 fine --prop-type-2 number --prop-nullable-2 true \\\n  --prop-name-3 loanDate --prop-type-3 Date \\\n  --prop-name-4 member --prop-type-4 ObjectId --prop-reference-4 Member \\\n  --prop-name-5 renewalCount --prop-type-5 number \\\n  --prop-name-6 returnDate --prop-type-6 Date --prop-nullable-6 true \\\n  --prop-name-7 status --prop-enum-7 LoanStatusEnum\n```\n\n#### Step 4: Handle Inheritance\n\nManually modify `book.model.ts`:\n\n```typescript\n// Change from:\nimport { CoreModel } from '@lenne.tech/nest-server';\nexport class Book extends CoreModel { ... }\n\n// To:\nimport { BaseItem } from '../../common/objects/base-item/base-item.object';\nexport class Book extends BaseItem { ... }\n```\n\nManually update `book.input.ts` and `book-create.input.ts`:\n\n```typescript\n// book-create.input.ts\n// Add required fields from BaseItem:\n// - title (required in BaseItem)\n// - available (required in BaseItem)\n// - location (required in BaseItem)\n// - description (optional in BaseItem)\n```\n\n#### Step 5: Update Descriptions\n\n** CRITICAL STEP - Extract descriptions from original specification and apply EVERYWHERE!**\n\n**Step 5.1: Extract from specification**\n\nGo back to the original specification and identify ALL comments:\n\n```\nSubObject: Address\n- street: string // Stra√üe\n- city: string // City name\n- zipCode: string // Postleitzahl\n\nModule: Book\nModel: Book\nExtends: BaseItem\n- isbn: string // ISBN-Nummer\n- author: string // Author name\n- publisher?: string // Verlag\n```\n\n**Extracted mapping:**\n- Address.street -> \"Stra√üe\" (German)\n- Address.city -> \"City name\" (English)\n- Address.zipCode -> \"Postleitzahl\" (German)\n- Book.isbn -> \"ISBN-Nummer\" (German)\n- Book.author -> \"Author name\" (English)\n- Book.publisher -> \"Verlag\" (German)\n\n**Step 5.2: Format descriptions**\n\nApply format rules:\n- German -> Translate and add: `ENGLISH (DEUTSCH)`\n- English -> Keep as-is\n- **Fix typos only, preserve original wording!**\n\n```\nAddress.street -> 'Street (Stra√üe)'  (preserve word \"Stra√üe\", don't change to \"Stra√üenname\")\nAddress.city -> 'City name'\nAddress.zipCode -> 'Postal code (Postleitzahl)'\nBook.isbn -> 'ISBN number (ISBN-Nummer)'\nBook.author -> 'Author name'\nBook.publisher -> 'Publisher (Verlag)'  (preserve word \"Verlag\", don't expand)\n```\n\n** CRITICAL - Preserve Original Wording:**\n\nUser comments may be predefined terms or referenced by external systems.\n\n**Examples of correct handling**:\n```\n CORRECT:\n// Stra√üe -> 'Street (Stra√üe)'  (just translate)\n// Postleizahl -> 'Postal code (Postleitzahl)'  (fix typo, preserve word)\n// Produkt -> 'Product (Produkt)'  (don't add \"name\")\n// Status -> 'Status (Status)'  (same word)\n\n WRONG:\n// Stra√üe -> 'Street name (Stra√üenname)'  (changed word!)\n// Produkt -> 'Product name (Produktname)'  (added word!)\n// Titel -> 'Product title (Produkttitel)'  (changed \"Titel\"!)\n```\n\n**Step 5.3: Apply to ALL files**\n\nFor Address SubObject (3 files):\n\n```typescript\n// File: src/server/common/objects/address/address.object.ts\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet: string;\n\n@UnifiedField({ description: 'City name' })\ncity: string;\n\n@UnifiedField({ description: 'Postal code (Postleitzahl)' })\nzipCode: string;\n\n// File: src/server/common/objects/address/address-create.input.ts\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet: string;\n\n@UnifiedField({ description: 'City name' })\ncity: string;\n\n@UnifiedField({ description: 'Postal code (Postleitzahl)' })\nzipCode: string;\n\n// File: src/server/common/objects/address/address.input.ts\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet?: string;\n\n@UnifiedField({ description: 'City name' })\ncity?: string;\n\n@UnifiedField({ description: 'Postal code (Postleitzahl)' })\nzipCode?: string;\n```\n\nFor Book Module (3 files):\n\n```typescript\n// File: src/server/modules/book/book.model.ts\n@UnifiedField({ description: 'ISBN number (ISBN-Nummer)' })\nisbn: string;\n\n@UnifiedField({ description: 'Author name' })\nauthor: string;\n\n@UnifiedField({ description: 'Publisher (Verlag)' })\npublisher?: string;\n\n// File: src/server/modules/book/inputs/book-create.input.ts\n@UnifiedField({ description: 'ISBN number (ISBN-Nummer)' })\nisbn: string;\n\n@UnifiedField({ description: 'Author name' })\nauthor: string;\n\n@UnifiedField({ description: 'Publisher (Verlag)' })\npublisher?: string;\n\n// File: src/server/modules/book/inputs/book.input.ts\n@UnifiedField({ description: 'ISBN number (ISBN-Nummer)' })\nisbn?: string;\n\n@UnifiedField({ description: 'Author name' })\nauthor?: string;\n\n@UnifiedField({ description: 'Publisher (Verlag)' })\npublisher?: string;\n```\n\n**Verification:**\n-  Same description in ALL 3 files for each property\n-  All German descriptions translated\n-  All user comments extracted and applied\n-  No inconsistencies\n\n#### Step 6: Create Enum Files\n\n```typescript\n// src/server/common/enums/book-language.enum.ts\nexport enum BookLanguageEnum {\n  ENGLISH = 'ENGLISH',\n  GERMAN = 'GERMAN',\n  FRENCH = 'FRENCH',\n  SPANISH = 'SPANISH',\n  OTHER = 'OTHER',\n}\n\n// src/server/common/enums/book-genre.enum.ts\nexport enum BookGenreEnum {\n  FICTION = 'FICTION',\n  NON_FICTION = 'NON_FICTION',\n  SCIENCE = 'SCIENCE',\n  HISTORY = 'HISTORY',\n  BIOGRAPHY = 'BIOGRAPHY',\n  CHILDREN = 'CHILDREN',\n  FANTASY = 'FANTASY',\n  MYSTERY = 'MYSTERY',\n  ROMANCE = 'ROMANCE',\n}\n\n// src/server/common/enums/member-status.enum.ts\nexport enum MemberStatusEnum {\n  ACTIVE = 'ACTIVE',\n  SUSPENDED = 'SUSPENDED',\n  EXPIRED = 'EXPIRED',\n}\n\n// src/server/common/enums/loan-status.enum.ts\nexport enum LoanStatusEnum {\n  ACTIVE = 'ACTIVE',\n  OVERDUE = 'OVERDUE',\n  RETURNED = 'RETURNED',\n  LOST = 'LOST',\n}\n```\n\n#### Step 7: Create API Tests\n\n```typescript\n// test/book/book.controller.test.ts\nimport { TestHelper, TestGraphQLType } from '@lenne.tech/nest-server';\n\ndescribe('Book Controller', () => {\n  let testHelper: TestHelper;\n  let adminToken: string;\n  let createdBookId: string;\n\n  beforeAll(async () => {\n    testHelper = new TestHelper(app);\n\n    // Sign in as admin\n    const authResult = await testHelper.graphQl({\n      name: 'signIn',\n      type: TestGraphQLType.MUTATION,\n      arguments: { email: 'admin@test.com', password: 'password' },\n      fields: ['token']\n    });\n    adminToken = authResult.token;\n  });\n\n  afterAll(async () => {\n    // Clean up created book\n    if (createdBookId) {\n      await testHelper.graphQl({\n        name: 'deleteBook',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: createdBookId },\n        fields: ['id']\n      }, { token: adminToken });\n    }\n  });\n\n  it('should create book with all required fields', async () => {\n    const result = await testHelper.graphQl({\n      name: 'createBook',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        input: {\n          isbn: '978-3-16-148410-0',\n          title: 'Test Book',\n          description: 'A test book',\n          available: true,\n          location: 'Shelf A1',\n          authors: [{\n            firstName: 'John',\n            lastName: 'Doe'\n          }],\n          publisher: {\n            name: 'Test Publisher',\n            city: 'Berlin',\n            country: 'Germany'\n          },\n          publishYear: 2023,\n          pageCount: 300,\n          language: 'ENGLISH',\n          genre: 'FICTION'\n        }\n      },\n      fields: ['id', 'isbn', 'title', 'pageCount']\n    }, { token: adminToken });\n\n    expect(result.isbn).toBe('978-3-16-148410-0');\n    createdBookId = result.id;\n  });\n\n  it('should fail without required fields', async () => {\n    const result = await testHelper.graphQl({\n      name: 'createBook',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        input: {\n          isbn: '978-3-16-148410-1'\n          // Missing required fields\n        }\n      },\n      fields: ['id']\n    }, { token: adminToken, statusCode: 400 });\n\n    expect(result.errors).toBeDefined();\n  });\n\n  it('should get all books', async () => {\n    const result = await testHelper.graphQl({\n      name: 'books',\n      type: TestGraphQLType.QUERY,\n      fields: ['id', 'isbn', 'title']\n    }, { token: adminToken });\n\n    expect(Array.isArray(result)).toBe(true);\n  });\n\n  it('should update book', async () => {\n    const result = await testHelper.graphQl({\n      name: 'updateBook',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        id: createdBookId,\n        input: { pageCount: 350 }\n      },\n      fields: ['id', 'pageCount']\n    }, { token: adminToken });\n\n    expect(result.pageCount).toBe(350);\n  });\n\n  it('should delete book', async () => {\n    const result = await testHelper.graphQl({\n      name: 'deleteBook',\n      type: TestGraphQLType.MUTATION,\n      arguments: { id: createdBookId },\n      fields: ['id']\n    }, { token: adminToken });\n\n    expect(result.id).toBe(createdBookId);\n    createdBookId = null;\n  });\n});\n\n// For REST API tests\n// test/book/book.controller.rest.test.ts\ndescribe('Book Controller (REST)', () => {\n  let testHelper: TestHelper;\n  let adminToken: string;\n  let createdBookId: string;\n\n  beforeAll(async () => {\n    testHelper = new TestHelper(app);\n    const authResult = await testHelper.rest('/auth/sign-in', {\n      method: 'POST',\n      payload: { email: 'admin@test.com', password: 'password' }\n    });\n    adminToken = authResult.token;\n  });\n\n  it('should create book via REST', async () => {\n    const result = await testHelper.rest('/books', {\n      method: 'POST',\n      payload: {\n        isbn: '978-3-16-148410-0',\n        title: 'Test Book',\n        available: true,\n        location: 'Shelf A1',\n        // ... other required fields\n      },\n      token: adminToken\n    });\n\n    expect(result.isbn).toBe('978-3-16-148410-0');\n    createdBookId = result.id;\n  });\n\n  it('should get all books via REST', async () => {\n    const result = await testHelper.rest('/books', { token: adminToken });\n    expect(Array.isArray(result)).toBe(true);\n  });\n\n  afterAll(async () => {\n    if (createdBookId) {\n      await testHelper.rest(`/books/${createdBookId}`, {\n        method: 'DELETE',\n        token: adminToken\n      });\n    }\n  });\n});\n```\n\n### Execution Todo List Example\n\nWhen processing this specification, create this todo list:\n\n```\n1. Create Author SubObject\n2. Create Publisher SubObject\n3. Create Review SubObject\n4. Create BaseItem Object\n5. Create Member Module\n6. Create Book Module\n7. Add currentLoans property to Member\n8. Create Loan Module\n9. Modify Book model to extend BaseItem\n10. Update Book CreateInput with BaseItem required fields\n11. Update all descriptions to \"ENGLISH (DEUTSCH)\" format\n12. Create BookLanguageEnum file\n13. Create BookGenreEnum file\n14. Create MemberStatusEnum file\n15. Create LoanStatusEnum file\n16. Create Book controller tests\n17. Create Book resolver tests\n18. Create Member controller tests\n19. Create Member resolver tests\n20. Create Loan controller tests\n21. Create Loan resolver tests\n22. Run all tests\n23. Verify all tests pass\n24. Verify no TypeScript errors\n25. Run lint and fix\n26. Provide summary\n```\n\n## Example 2: Hotel Booking System (Minimal)\n\nA simpler example focusing on basic features:\n\n```\n===========\n\nSubObject: ContactDetails // Contact information\n- email: string // Email address\n- phone: string // Phone number\n\n===\n\nModule: Guest // Guest module\n\nModel: Guest // Hotel guest\n- name: string // Full name\n- contact: ContactDetails // Contact information\n- checkInDate: Date // Check-in date\n- checkOutDate: Date // Check-out date\n- roomNumber: string // Room number\n- status: ENUM (CHECKED_IN, CHECKED_OUT, RESERVED, CANCELLED) // Booking status\n\n===========\n```\n\n### Commands\n\n```bash\n# SubObject\nlt server object --name ContactDetails \\\n  --prop-name-0 email --prop-type-0 string \\\n  --prop-name-1 phone --prop-type-1 string\n\n# Module (REST is default)\nlt server module --name Guest --controller Rest \\\n  --prop-name-0 checkInDate --prop-type-0 Date \\\n  --prop-name-1 checkOutDate --prop-type-1 Date \\\n  --prop-name-2 contact --prop-schema-2 ContactDetails \\\n  --prop-name-3 name --prop-type-3 string \\\n  --prop-name-4 roomNumber --prop-type-4 string \\\n  --prop-name-5 status --prop-enum-5 GuestStatusEnum\n\n# Enum file\n# src/server/common/enums/guest-status.enum.ts\nexport enum GuestStatusEnum {\n  CHECKED_IN = 'CHECKED_IN',\n  CHECKED_OUT = 'CHECKED_OUT',\n  RESERVED = 'RESERVED',\n  CANCELLED = 'CANCELLED',\n}\n```\n\n## Key Patterns Demonstrated\n\n### 1. SubObject with Arrays\n```\n- authors: Author[] // Multiple authors\n```\n -> `--prop-schema-X Author --prop-array-X true`\n\n### 2. Optional Fields\n```\n- description?: string // Optional description\n```\n -> `--prop-nullable-X true`\n\n### 3. Enum Properties\n```\n- status: ENUM (ACTIVE, INACTIVE) // Status\n```\n -> `--prop-enum-X StatusEnum` + create enum file\n\n### 4. Module References\n```\n- borrowedBy?: Member // Reference to member\n```\n -> `--prop-type-X ObjectId --prop-reference-X Member --prop-nullable-X true`\n\n### 5. Inheritance\n```\nExtends: BaseItem\n```\n -> Manually change model to extend BaseItem and update inputs\n\n### 6. Circular References\n```\nMember has currentLoans: Book[]\nBook has borrowedBy?: Member\n```\n -> Create both modules first, then use `addProp` for the second reference\n\n## Best Practices from Examples\n\n1. **Create SubObjects first**: Author, Publisher, Review before Book\n2. **Create referenced modules early**: Member before Book (for borrowedBy)\n3. **Handle circular refs with addProp**: Add currentLoans to Member after Book exists\n4. **Use REST by default**: Only use `--controller GraphQL` when explicitly requested\n5. **Alphabetical ordering**: All properties sorted in final files\n6. **Proper descriptions**: \"ENGLISH (DEUTSCH)\" format throughout\n7. **Complete enum files**: Create all enums immediately after modules\n8. **Comprehensive tests**: Cover all CRUD operations and edge cases\n9. **Quality review before reporting**: ALWAYS perform comprehensive quality review\n\n## Quality Review Workflow Example\n\n**CRITICAL**: Before creating the final report, ALWAYS perform this quality review:\n\n```bash\n# Step 1: Identify all changes\ngit status --short\ngit diff --name-only\n\n# Step 2: Test Management\n\n# Step 2.1: FIRST - Analyze existing tests thoroughly\nls -la tests/\nls -la tests/modules/\nfind tests -name \"*.e2e-spec.ts\" -type f\n\n# Understand the test folder structure:\n# - tests/modules/<module-name>.e2e-spec.ts - for modules\n# - tests/common.e2e-spec.ts - for common functionality\n# - tests/project.e2e-spec.ts - for project-level tests\n\n# Read multiple test files to understand patterns\ncat tests/modules/user.e2e-spec.ts\ncat tests/modules/<another-module>.e2e-spec.ts\ncat tests/common.e2e-spec.ts\ncat tests/project.e2e-spec.ts\n\n# CRITICAL: Read and understand TestHelper source code\ncat node_modules/@lenne.tech/nest-server/src/test/test.helper.ts\n\n# Document TestHelper understanding:\n# - Available methods: graphQl(), rest(), constructor, initialization\n# - graphQl() signature: (options: GraphQLOptions, config?: RequestConfig)\n#   - GraphQLOptions: { name, type (QUERY/MUTATION), arguments, fields }\n#   - RequestConfig: { token, statusCode, headers }\n# - rest() signature: (method: HttpMethod, path: string, options?: RestOptions)\n#   - HttpMethod: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'\n#   - RestOptions: { body, token, statusCode, headers }\n# - Authentication: Pass token via config.token (both methods)\n# - Error handling: Specify expected statusCode for error cases\n# - Response: Returns parsed data directly\n# - When to use: graphQl() for GraphQL endpoints, rest() for REST endpoints\n\n# Document observed patterns:\n# - Test framework: Vitest (or Jest in older projects)\n# - Test helper: TestHelper from @lenne.tech/nest-server\n# - Auth: Token-based via signIn mutation\n# - Setup: beforeAll initializes app and gets admin token\n# - Cleanup: afterAll deletes test data\n# - Assertions: expect() with Vitest/Jest matchers\n# - Prerequisites: How are test users/related data created?\n\n# Verify existing tests pass BEFORE making changes\nnpm run test:e2e\n\n# Step 2.2: For new modules - create test files in correct location\n# Example: Created Book module, need to create tests\n\n# IMPORTANT: Determine correct test location first!\n# - Module in src/server/modules/book? -> tests/modules/book.e2e-spec.ts\n# - Common object/enum? -> Add to tests/common.e2e-spec.ts\n# - Project-level? -> Add to tests/project.e2e-spec.ts\n\n# Create new test file EXACTLY matching the pattern observed\n# tests/modules/book.e2e-spec.ts with:\n# - Same imports as existing tests\n# - Same beforeAll/afterAll structure\n# - Same authentication pattern\n# - Same prerequisite handling (e.g., create User first if Book needs User)\n# - Same assertion style\n# - All CRUD operations\n# - Authorization tests\n# - Required field validation\n\n# Step 2.3: For modified modules - update existing tests\nfind tests -name \"*user*.e2e-spec.ts\"\ncat tests/modules/user.e2e-spec.ts  # Read first!\n\n# Run tests before modifying\nnpm run test:e2e\n\n# If you added a property to User, update tests to verify it\n# Run tests after modifying to ensure nothing broke\nnpm run test:e2e\n\n# Step 3: Compare with existing code\n# Read existing modules to understand project patterns\ncat src/server/modules/user/user.model.ts\ncat src/server/modules/user/inputs/user-create.input.ts\n\n# Step 3: Critical analysis\n# For each generated file, check:\n# - Import ordering matches existing code\n# - Property ordering is alphabetical\n# - Decorator patterns match existing code\n# - Description format matches project style\n# - Indentation and formatting is consistent\n\n# Step 4: Apply optimizations\n# Fix any inconsistencies found:\n# - Reorder imports\n# - Reorder properties\n# - Fix formatting\n# - Improve descriptions\n\n# Step 5: Run all tests\nnpm run build\nnpm run lint\nnpm run test:e2e\n\n# Step 6: Fix any failures and repeat\n# If tests fail:\n# - Analyze error\n# - Fix issue\n# - Re-run tests\n# - Repeat until all pass\n\n# Only after ALL checks pass -> Create Final Report\n```\n\n**Example findings during quality review**:\n\n```\nStep 2.1: Analyzed existing tests\n Listed test structure: tests/modules/, tests/common.e2e-spec.ts, tests/project.e2e-spec.ts\n Read 3 existing test files (user, role, profile)\n Read and analyzed TestHelper source code (node_modules/@lenne.tech/nest-server/src/test/test.helper.ts)\n Documented TestHelper:\n  - graphQl() method: signature, GraphQLOptions, RequestConfig\n  - rest() method: signature, HttpMethod, RestOptions\n  - When to use graphQl() vs rest()\n  - Authentication handling (token in config for both methods)\n  - Error handling (statusCode parameter)\n  - Response format and parsing\n Documented patterns: Vitest + TestHelper, token auth, beforeAll/afterAll cleanup\n Documented prerequisites: Test users created first, then module-specific data\n Verified all existing tests pass (23/23 passing)\n\n Found: New Book module created but no test file exists\n Fixed: Created tests/modules/book.e2e-spec.ts following exact pattern\n  - Placed in correct location: tests/modules/book.e2e-spec.ts (not tests/book/ or tests/modules/book/)\n  - Matched imports structure\n  - Matched beforeAll/afterAll pattern\n  - Identified prerequisites: Book references User for borrowedBy\n  - Created test User first in beforeAll\n  - Matched authentication approach\n  - Matched assertion style\n\n Found: Modified User module (added 'phone' property) but tests not updated\n Fixed:\n  - Read existing tests/modules/user.e2e-spec.ts first\n  - Ran tests before changes (all passing)\n  - Updated test to verify 'phone' property in create/update operations\n  - Ran tests after changes (all passing)\n\n Found: Import ordering differs from existing modules\n Fixed: Reordered imports to match project pattern\n\n Found: Properties not alphabetically ordered in Book model\n Fixed: Reordered all properties alphabetically\n\n Found: Description format inconsistent (\"German only\" vs \"ENGLISH (DEUTSCH)\")\n Fixed: Updated all descriptions to \"ENGLISH (DEUTSCH)\" format\n\n Found: Test missing required field validation\n Fixed: Added test case for missing required fields\n\n Found: Test cleanup not following project pattern\n Fixed: Updated afterAll hook to match existing test cleanup patterns\n\n All tests passing\n Linter passing\n TypeScript compiling without errors\n\n -> Ready for Final Report\n```\n\n**This quality review ensures**:\n- Generated code matches project patterns perfectly\n- No style inconsistencies\n- **TestHelper thoroughly understood before creating tests**\n- **TestHelper used correctly (graphQl() and rest() methods, authentication, error handling)**\n- **Tests in correct folder structure (tests/modules/<name>.e2e-spec.ts, tests/common.e2e-spec.ts, tests/project.e2e-spec.ts)**\n- **All new modules have corresponding test files**\n- **All modified modules have updated tests**\n- **All test prerequisites identified and handled correctly**\n- **Tests follow existing project test patterns exactly**\n- All tests pass before reporting\n- Professional, production-ready code\n",
        "plugins/lt-dev/skills/generating-nest-servers/framework-guide.md": "---\nname: nest-server-generator-framework\ndescription: Complete guide to @lenne.tech/nest-server framework - CrudService base class, ServiceOptions handling, patterns for Service inheritance, and best practices for working with the framework\n---\n\n#  Understanding the @lenne.tech/nest-server Framework\n\n## Table of Contents\n- [Core Service Base Class: CrudService](#core-service-base-class-crudservice)\n- [CRITICAL: ServiceOptions When Calling Other Services](#-critical-serviceoptions-when-calling-other-services)\n- [Framework Patterns](#framework-patterns)\n- [Key Takeaways](#key-takeaways)\n\n## Core Service Base Class: CrudService\n\n**IMPORTANT**: Before working with Services, ALWAYS read this file to understand the base functionality:\n\n```\nnode_modules/@lenne.tech/nest-server/src/core/common/services/crud.service.ts\n```\n\n**Why this is critical:**\n- Almost ALL Services extend `CrudService<Model>`\n- CrudService provides base CRUD operations (create, find, update, delete)\n- Understanding CrudService prevents reinventing the wheel\n- Shows patterns for handling permissions, filtering, and pagination\n\n**When to read CrudService:**\n1.  Before creating a new Service\n2.  When implementing custom Service methods\n3.  When debugging Service behavior\n4.  When writing tests for Services\n5.  When questions arise about Service functionality\n\n**What CrudService provides:**\n- `create(input, options)` - Create new document\n- `find(filterArgs)` - Find multiple documents\n- `findOne(filterArgs)` - Find single document\n- `findAndCount(filterArgs)` - Find with total count (pagination)\n- `update(id, input, options)` - Update document\n- `delete(id, options)` - Delete document\n- Permission handling via `options.roles`\n- Query filtering and population\n- Pagination support\n\n**Example Service that extends CrudService:**\n```typescript\n@Injectable()\nexport class ProductService extends CrudService<Product> {\n  constructor(\n    @InjectModel(Product.name) protected readonly productModel: Model<ProductDocument>,\n    protected readonly configService: ConfigService,\n  ) {\n    super({ configService, mainDbModel: productModel, mainModelConstructor: Product });\n  }\n\n  // Custom methods can be added here\n  // Base CRUD methods are inherited from CrudService\n}\n```\n\n**Action Items:**\n- [ ] Read CrudService before modifying any Service\n- [ ] Check if CrudService already provides the needed functionality\n- [ ] Only add custom methods if CrudService doesn't cover the use case\n- [ ] Follow CrudService patterns for consistency\n\n---\n\n##  CRITICAL: ServiceOptions When Calling Other Services\n\n**NEVER blindly pass all ServiceOptions when calling another Service!**\n\nWhen a Service method calls another Service, you must carefully analyze which options to pass:\n\n###  WRONG - Blindly passing all options\n\n```typescript\nasync createOrder(input: CreateOrderInput, serviceOptions: ServiceOptions) {\n  //  BAD: Passes ALL serviceOptions without checking\n  const product = await this.productService.findOne({ id: input.productId }, serviceOptions);\n\n  //  BAD: inputType might be wrong for userService\n  const user = await this.userService.findOne({ id: input.userId }, serviceOptions);\n}\n```\n\n###  CORRECT - Selectively passing required options\n\n```typescript\nasync createOrder(input: CreateOrderInput, serviceOptions: ServiceOptions) {\n  //  GOOD: Only pass currentUser (needed for permissions)\n  const product = await this.productService.findOne(\n    { id: input.productId },\n    { currentUser: serviceOptions.currentUser }\n  );\n\n  //  GOOD: Only set inputType if different Input class is needed\n  const user = await this.userService.findOne(\n    { id: input.userId },\n    {\n      currentUser: serviceOptions.currentUser,\n      inputType: UserInput // Only if specific Input class needed (e.g., UserInput, UserInputCreate)\n    }\n  );\n\n  //  ALSO GOOD: Don't pass inputType if not needed\n  const category = await this.categoryService.findOne(\n    { id: input.categoryId },\n    { currentUser: serviceOptions.currentUser } // No inputType - use default\n  );\n}\n```\n\n### Why this is critical\n\n- **inputType** specifies which Input class (DTO) to use for validation (e.g., `UserInput`, `UserInputCreate`)\n- The inputType from outer service might be wrong for inner service call\n- **roles** might need to be different for the called service\n- **Other options** (limit, skip, etc.) might not apply to the inner call\n- Blindly passing options can cause **incorrect permission checks** or **wrong validation**\n- Can lead to **unexpected behavior** in nested service calls\n\n### Analysis Checklist Before Passing ServiceOptions\n\n1. **Analyze current serviceOptions:**\n   ```typescript\n   // What's in serviceOptions right now?\n   // - currentUser? (usually needed)\n   // - inputType? (which Input class: UserInput, UserInputCreate, etc.?)\n   // - roles? (are these the right roles?)\n   // - other options? (limit, skip, populate, etc.)\n   ```\n\n2. **Check target Service requirements:**\n   - What does the target Service method need?\n   - Read the target Service method signature\n   - Check what permissions/validations it performs\n   - Understand which Input class (inputType) is appropriate\n\n3. **Pass only required options:**\n   ```typescript\n   // Build options object with only what's needed\n   const targetOptions: ServiceOptions = {\n     currentUser: serviceOptions.currentUser, // Usually needed\n     // inputType: Only set if specific Input class is needed (e.g., UserInput, UserInputCreate)!\n     // roles: Only if different roles are needed\n     // Don't include: limit, skip, etc. unless specifically needed\n   };\n   ```\n\n### Common Patterns\n\n- **Reading data for validation**: Usually only need `currentUser` (no inputType needed)\n- **Creating related entities**: May need different Input class as inputType (e.g., `UserInputCreate` instead of `UserInput`)\n- **Admin operations**: May need to override `roles` or set specific Input class (only if necessary)\n- **Nested CRUD operations**: Carefully consider each option - often only currentUser needed\n\n### Action Items\n\n- [ ] Before calling another Service, analyze current serviceOptions\n- [ ] Determine which options the target Service actually needs\n- [ ] Only pass required options (usually just currentUser)\n- [ ] Only set inputType if a specific Input class (DTO) is needed (e.g., UserInput, UserInputCreate)\n- [ ] NEVER blindly pass all serviceOptions\n\n---\n\n## Framework Patterns\n\n### Service Inheritance Pattern\n\nAll Services follow this pattern:\n\n```typescript\n@Injectable()\nexport class YourService extends CrudService<YourModel> {\n  constructor(\n    @InjectModel(YourModel.name) protected readonly yourModel: Model<YourModelDocument>,\n    protected readonly configService: ConfigService,\n    // Inject other services if needed\n    private readonly otherService: OtherService,\n  ) {\n    super({\n      configService,\n      mainDbModel: yourModel,\n      mainModelConstructor: YourModel\n    });\n  }\n\n  // Add custom methods here\n  async customMethod(input: SomeInput, serviceOptions?: ServiceOptions) {\n    // Your custom logic\n    // Can call base methods: this.create(), this.find(), etc.\n    // Can call other services with proper ServiceOptions handling\n  }\n}\n```\n\n### Controller/Resolver Pattern\n\nControllers and Resolvers use Services:\n\n```typescript\n@Controller('api/products')\nexport class ProductController {\n  constructor(private readonly productService: ProductService) {}\n\n  @Get()\n  @Roles(RoleEnum.S_USER)\n  async getProducts(@CurrentUser() user: User) {\n    return this.productService.find({ currentUser: user });\n  }\n\n  @Post()\n  @Roles(RoleEnum.S_USER)\n  async createProduct(\n    @Body() input: ProductCreateInput,\n    @CurrentUser() user: User\n  ) {\n    return this.productService.create(input, { currentUser: user });\n  }\n}\n```\n\n### Permission Handling Pattern\n\n```typescript\n// In Model\nexport class Product extends CoreModel {\n  securityCheck(user: User, force?: boolean) {\n    if (force || user?.hasRole(RoleEnum.ADMIN)) {\n      return this; // Admin sees all\n    }\n    if (!equalIds(user, this.createdBy)) {\n      return undefined; // Non-creator gets nothing\n    }\n    return this; // Creator sees own products\n  }\n}\n\n// In Service\nasync customMethod(input: Input, serviceOptions?: ServiceOptions) {\n  // CrudService automatically applies securityCheck\n  const results = await this.find({ currentUser: serviceOptions.currentUser });\n  // Only products passing securityCheck are returned\n}\n```\n\n---\n\n## Key Takeaways\n\n1. **Always read CrudService first** - Understand what's already provided\n2. **Never blindly pass ServiceOptions** - Analyze and pass only what's needed\n3. **Follow framework patterns** - Inherit from CrudService, use proper decorators\n4. **Understand permission flow** - securityCheck + serviceOptions.currentUser + @Roles\n5. **inputType is the Input CLASS** - Not an enum, but the actual DTO class (e.g., UserInput, UserInputCreate)\n",
        "plugins/lt-dev/skills/generating-nest-servers/owasp-checklist.md": "---\nname: owasp-secure-coding-checklist\ndescription: Comprehensive OWASP Secure Coding Practices checklist for NestJS/Node.js applications\n---\n\n# OWASP Secure Coding Practices Checklist\n\nBased on [OWASP Secure Coding Practices Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/).\n\n**Source:** [GitHub - OWASP Checklist (stable-en)](https://raw.githubusercontent.com/OWASP/www-project-secure-coding-practices-quick-reference-guide/refs/heads/main/stable-en/02-checklist/05-checklist.md)\n\n**Use this checklist during security reviews and before deployments.**\n\n---\n\n## 1. Input Validation\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 1.1 | Conduct all input validation on a trusted system (server) | Use DTOs with class-validator, never trust client-side validation |\n| 1.2 | Identify all data sources and classify as trusted/untrusted | Request body, query params, headers, cookies = untrusted |\n| 1.3 | Centralized input validation routine | Use ValidationPipe globally in main.ts |\n| 1.4 | Specify proper character sets (UTF-8) | Set `charset: 'utf-8'` in responses |\n| 1.5 | Encode data to common character set before validation | Use `normalizeEmail()` in class-validator |\n| 1.6 | All validation failures result in input rejection | ValidationPipe throws BadRequestException |\n| 1.7 | Validate data type, range, length | `@IsInt()`, `@Min()`, `@Max()`, `@Length()` |\n| 1.8 | Validate against allowlist where possible | `@IsIn(['option1', 'option2'])` |\n| 1.9 | Validate all client-provided data | Apply ValidationPipe to all endpoints |\n| 1.10 | Verify header values in requests | Custom guards for header validation |\n| 1.11 | Validate data from redirects | Don't blindly follow redirect URLs |\n| 1.12 | Validate file type by content (magic bytes) | Use `file-type` package, not extension |\n| 1.13 | Validate uploaded filenames | Sanitize or generate random names |\n| 1.14 | Reject input containing certain characters | `@Matches()` with blocklist regex |\n\n```typescript\n// Global validation setup (main.ts)\napp.useGlobalPipes(new ValidationPipe({\n  whitelist: true,           // Strip unknown properties\n  forbidNonWhitelisted: true, // Throw on unknown properties\n  transform: true,           // Transform to DTO types\n  transformOptions: {\n    enableImplicitConversion: true\n  }\n}));\n```\n\n---\n\n## 2. Output Encoding\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 2.1 | Conduct all encoding on trusted system | Server-side encoding only |\n| 2.2 | Utilize standard encoding routine | Use `escape-html`, `sanitize-html` packages |\n| 2.3 | Contextual output encoding | Different encoding for HTML, URL, JS, CSS |\n| 2.4 | Encode all characters unless safe for interpreter | Default to encoding everything |\n| 2.5 | Sanitize output of untrusted data to queries | Use parameterized queries (Mongoose/TypeORM) |\n| 2.6 | Sanitize output to OS commands | Never construct OS commands from user input |\n\n```typescript\n// HTML encoding for API responses containing user content\nimport { escape } from 'html-escaper';\n\n@Get('user/:id')\nasync getUser(@Param('id') id: string) {\n  const user = await this.userService.findById(id);\n  return {\n    ...user,\n    bio: escape(user.bio),  // Encode HTML entities\n  };\n}\n\n// For rich text, use sanitize-html with strict allowlist\nimport * as sanitizeHtml from 'sanitize-html';\n\nconst cleanHtml = sanitizeHtml(userInput, {\n  allowedTags: ['b', 'i', 'em', 'strong', 'a', 'p'],\n  allowedAttributes: { 'a': ['href'] },\n  allowedSchemes: ['https']\n});\n```\n\n---\n\n## 3. Authentication & Password Management\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 3.1 | Require authentication for all resources except public | `@Public()` decorator for exceptions, default to protected |\n| 3.2 | All authentication controls on trusted system | Server-side JWT/session validation |\n| 3.3 | Centralized authentication services | AuthModule with AuthGuard |\n| 3.4 | Separate authentication from resource logic | Guards handle auth, controllers handle business logic |\n| 3.5 | Authentication failure doesn't reveal which credential wrong | \"Invalid credentials\" - never \"Invalid password\" |\n| 3.6 | Authentication over HTTPS | TLS termination at load balancer minimum |\n| 3.7 | Password entry only via POST | Never via GET query params |\n| 3.8 | Temporary passwords expire quickly | Token expiry with `expiresIn` |\n| 3.9 | Enforce password complexity | `@IsStrongPassword()` validator |\n| 3.10 | Password input with disabled autocomplete | Frontend concern (autocomplete=\"off\") |\n| 3.11 | Disable \"remember me\" for sensitive apps | Don't persist sessions for admin apps |\n| 3.12 | Hash passwords with bcrypt | `bcrypt.hash(password, 12)` |\n| 3.13 | Enforce password change on temp passwords | `requirePasswordChange` flag |\n| 3.14 | Minimum 8 character passwords | `@MinLength(8)` |\n| 3.15 | Hide password entry | Frontend concern (type=\"password\") |\n| 3.16 | Disable account after failed attempts | AccountLock entity with attempt counter |\n| 3.17 | Password reset doesn't reveal account existence | \"If account exists, email sent\" |\n| 3.18 | Reset questions have sufficient entropy | Prefer email/SMS verification |\n| 3.19 | Password reset tokens single-use with expiry | Delete token after use, short TTL |\n| 3.20 | Require re-auth for sensitive operations | Fresh login for password change |\n| 3.21 | Multi-factor for high-value transactions | TOTP via `speakeasy` package |\n| 3.22 | Protect password fields from caching | `Cache-Control: no-store` |\n| 3.23 | Store credentials with crypto protection | bcrypt for passwords, encrypted secrets |\n\n```typescript\n// Password validation DTO\nexport class PasswordDto {\n  @IsString()\n  @MinLength(8)\n  @Matches(/((?=.*\\d)|(?=.*\\W+))(?![.\\n])(?=.*[A-Z])(?=.*[a-z]).*$/, {\n    message: 'Password must contain uppercase, lowercase, and number/special char'\n  })\n  password: string;\n}\n\n// Generic error messages\nif (!user || !(await bcrypt.compare(password, user.password))) {\n  throw new UnauthorizedException('Invalid credentials');  // Never specify which\n}\n```\n\n---\n\n## 4. Session Management\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 4.1 | Server-side session management | JWT stored server-side or stateless with signature |\n| 4.2 | Session ID generation with approved algorithm | `randomBytes(32).toString('hex')` |\n| 4.3 | Logout terminates session | Invalidate refresh token in DB |\n| 4.4 | Logout available from all authenticated pages | Frontend responsibility + API endpoint |\n| 4.5 | Session timeout after inactivity | `expiresIn: '15m'` for access tokens |\n| 4.6 | Don't allow persistent sessions | Short-lived tokens, require re-auth |\n| 4.7 | New session ID on re-authentication | Issue new tokens on login |\n| 4.8 | New session ID on privilege change | New tokens after role upgrade |\n| 4.9 | Concurrent sessions if needed | Track sessions in DB, allow/deny based on policy |\n| 4.10 | Session ID only via cookies (not URLs) | Never put tokens in query params |\n| 4.11 | Protect session cookies | `httpOnly: true, secure: true, sameSite: 'strict'` |\n| 4.12 | Set domain/path for cookies | `path: '/', domain: '.example.com'` |\n\n```typescript\n// Token configuration\nconst accessToken = this.jwtService.sign(payload, { expiresIn: '15m' });\nconst refreshToken = this.jwtService.sign(\n  { sub: user.id, type: 'refresh' },\n  { expiresIn: '7d' }\n);\n\n// Cookie settings for refresh token\nres.cookie('refreshToken', refreshToken, {\n  httpOnly: true,\n  secure: process.env.NODE_ENV === 'production',\n  sameSite: 'strict',\n  path: '/auth',\n  maxAge: 7 * 24 * 60 * 60 * 1000\n});\n```\n\n---\n\n## 5. Access Control\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 5.1 | Use only trusted objects for access decisions | Server-side user object from token, not client |\n| 5.2 | Single site-wide access control component | AuthGuard + RolesGuard combination |\n| 5.3 | Access controls fail securely | Default deny, explicit allow |\n| 5.4 | Deny access by default | `@Restricted(RoleEnum.ADMIN)` class default |\n| 5.5 | Enforce access control at every request | Global guards in main.ts |\n| 5.6 | Segregate privileged logic from other code | Separate admin modules |\n| 5.7 | Restrict access to files/resources | S3 pre-signed URLs, file guards |\n| 5.8 | Restrict access to protected URLs | Guards on all routes |\n| 5.9 | Restrict access to protected functions | Method-level decorators |\n| 5.10 | Restrict direct object references | Check ownership in service layer |\n| 5.11 | Restrict access to services | API Gateway, network policies |\n| 5.12 | Restrict access to data | Row-level security in queries |\n| 5.13 | Restrict access to security attributes | `hideField: true` in DTOs |\n| 5.14 | Restrict access to system configurations | Environment variables only |\n| 5.15 | Server-side authorization rules | Never trust client claims |\n| 5.16 | Centralized access control code | AuthModule exports guards |\n\n```typescript\n// Default-deny with class decorator\n@Restricted(RoleEnum.ADMIN)  // Fallback: admin only\n@Controller('products')\nexport class ProductController {\n  @Roles(RoleEnum.S_EVERYONE)  // Override: public\n  @Get()\n  findAll() {}\n\n  @Roles(RoleEnum.S_USER)  // Override: logged-in users\n  @Post()\n  create() {}\n\n  @Delete(':id')  // No override: admin only (from class)\n  delete() {}\n}\n```\n\n---\n\n## 6. Cryptographic Practices\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 6.1 | Cryptographic functions on trusted system | Server-side only |\n| 6.2 | Protect master secrets from unauthorized access | HSM, Vault, or env vars with restricted access |\n| 6.3 | Cryptographic modules fail securely | Catch and handle crypto errors |\n| 6.4 | Random numbers cryptographically secure | `crypto.randomBytes()`, never `Math.random()` |\n| 6.5 | Cryptographic modules FIPS-140 certified | Node.js crypto module |\n| 6.6 | Establish policy for cryptographic keys | Key rotation, storage, access policies |\n\n```typescript\nimport { randomBytes, createCipheriv, createDecipheriv, scrypt } from 'crypto';\n\n// Secure random token generation\nconst token = randomBytes(32).toString('hex');\n\n// Encryption for sensitive data at rest\nasync function encrypt(text: string, password: string): Promise<string> {\n  const iv = randomBytes(16);\n  const key = await new Promise<Buffer>((resolve, reject) => {\n    scrypt(password, 'salt', 32, (err, derivedKey) => {\n      if (err) reject(err);\n      resolve(derivedKey);\n    });\n  });\n  const cipher = createCipheriv('aes-256-gcm', key, iv);\n  // ... encryption logic\n}\n```\n\n---\n\n## 7. Error Handling & Logging\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 7.1 | Don't disclose sensitive info in errors | ExceptionFilter sanitizes responses |\n| 7.2 | Implement generic error messages | \"An error occurred\" in production |\n| 7.3 | Handle errors without stack traces | `NODE_ENV=production` hides stack |\n| 7.4 | Free allocated memory on error | Node.js garbage collection handles this |\n| 7.5 | Security-related errors logged | Logger service for security events |\n| 7.6 | Logging controls support audit success/failure | Structured logging with levels |\n| 7.7 | Log all input validation failures | Warn-level logs in ValidationPipe |\n| 7.8 | Log all authentication attempts | Login success/failure events |\n| 7.9 | Log all access control failures | 403 responses logged with context |\n| 7.10 | Log all exceptions | ExceptionFilter logs all |\n| 7.11 | Don't log sensitive data | Never log passwords, tokens, PII |\n| 7.12 | Timestamps in consistent format | ISO 8601 UTC |\n| 7.13 | Log entries support forensic analysis | Include userId, IP, userAgent, requestId |\n\n```typescript\n// Global exception filter with secure logging\n@Catch()\nexport class AllExceptionsFilter implements ExceptionFilter {\n  private logger = new Logger('ExceptionFilter');\n\n  catch(exception: unknown, host: ArgumentsHost) {\n    const ctx = host.switchToHttp();\n    const response = ctx.getResponse();\n    const request = ctx.getRequest();\n\n    const status = exception instanceof HttpException\n      ? exception.getStatus()\n      : HttpStatus.INTERNAL_SERVER_ERROR;\n\n    // Log full details internally\n    this.logger.error('Request failed', {\n      status,\n      path: request.url,\n      method: request.method,\n      userId: request.user?.id,\n      ip: request.ip,\n      userAgent: request.headers['user-agent'],\n      error: exception instanceof Error ? exception.message : 'Unknown error',\n      stack: exception instanceof Error ? exception.stack : undefined\n    });\n\n    // Return generic error to client\n    response.status(status).json({\n      statusCode: status,\n      message: status >= 500 ? 'Internal server error' : (exception as any).message,\n      timestamp: new Date().toISOString()\n    });\n  }\n}\n```\n\n---\n\n## 8. Data Protection\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 8.1 | Implement least privilege | Minimal data in JWT, minimal DB fields returned |\n| 8.2 | Protect cached sensitive data on server | Encrypted cache, Redis AUTH |\n| 8.3 | Encrypt sensitive stored data | Field-level encryption for PII |\n| 8.4 | Protect server-side code from download | Don't serve `/src` or `.env` |\n| 8.5 | Don't store passwords, connection strings in plain text | Environment variables, secrets manager |\n| 8.6 | Don't include sensitive info in GET params | POST for sensitive data |\n| 8.7 | Disable autocomplete on sensitive form fields | Frontend concern |\n| 8.8 | Disable caching for sensitive pages | `Cache-Control: no-store` header |\n| 8.9 | Remove unnecessary application data | Clear temp files, logs rotation |\n| 8.10 | Appropriate access controls on sensitive data | DB roles, row-level security |\n| 8.11 | Store sensitive data in non-web-accessible location | Outside public folder |\n| 8.12 | Use secure data collection channels | HTTPS only |\n\n```typescript\n// Hide sensitive fields in responses\n@UnifiedField({\n  description: 'Password hash',\n  hideField: true  // Never returned in API\n})\npassword: string;\n\n// Encrypt sensitive fields at rest\n@UnifiedField({\n  description: 'Social Security Number',\n  transform: (value) => encrypt(value, process.env.ENCRYPTION_KEY)\n})\nssn: string;\n\n// Disable caching for sensitive responses\n@Get('me')\n@Header('Cache-Control', 'no-store, no-cache, must-revalidate')\nasync getCurrentUser() {}\n```\n\n---\n\n## 9. Communication Security\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 9.1 | Use encryption for all sensitive data transmission | TLS 1.3 minimum |\n| 9.2 | TLS certificates from trusted CA | Let's Encrypt or commercial CA |\n| 9.3 | Implement HSTS | Helmet middleware |\n| 9.4 | Protect connection strings and credentials | Environment variables |\n| 9.5 | Remove comments from production code | Build process strips comments |\n\n```typescript\n// Helmet configuration with HSTS\nimport helmet from 'helmet';\n\napp.use(helmet({\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n```\n\n---\n\n## 10. System Configuration\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 10.1 | Servers/frameworks configured securely | Follow NestJS security guide |\n| 10.2 | Third-party components up to date | Regular `npm audit`, `npm update` |\n| 10.3 | Non-essential features disabled | Disable GraphQL playground in prod |\n| 10.4 | Appropriate access controls for server files | chmod 640 for configs |\n| 10.5 | Separate environments (dev/staging/prod) | NODE_ENV based configuration |\n| 10.6 | Remove default/demo code | No sample data in production |\n| 10.7 | Don't expose system info in errors | Production error filter |\n\n```typescript\n// Environment-specific configuration\nconst isDev = process.env.NODE_ENV !== 'production';\n\n// Disable introspection in production\nGraphQLModule.forRoot({\n  playground: isDev,\n  introspection: isDev,\n  debug: isDev\n});\n```\n\n---\n\n## 11. Database Security\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 11.1 | Use parameterized queries | Mongoose/TypeORM built-in |\n| 11.2 | Utilize input validation | class-validator before DB operations |\n| 11.3 | Strongly typed queries | TypeScript interfaces |\n| 11.4 | Validate response type and count | Check query results before use |\n| 11.5 | Use only approved database accounts | Connection string in env vars |\n| 11.6 | Close connections properly | Connection pooling, graceful shutdown |\n| 11.7 | Remove default accounts/passwords | No admin/admin credentials |\n| 11.8 | Application minimal privileges | Read-only replicas where possible |\n| 11.9 | Remove unnecessary stored procedures | Minimize database logic |\n| 11.10 | Remove test/sample data | Migration scripts clean data |\n| 11.11 | Database account cannot access config | Separate DB user from admin |\n\n```typescript\n// Parameterized query (Mongoose)\nconst user = await this.userModel.findOne({ email });  // Safe\n\n// NEVER do this\nconst user = await this.userModel.findOne({ $where: `this.email === '${email}'` });  // Injection!\n\n// Validate ObjectId before query\nif (!Types.ObjectId.isValid(id)) {\n  throw new BadRequestException('Invalid ID');\n}\n```\n\n---\n\n## 12. File Management\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 12.1 | Don't pass user input to dynamic include | Never `require(userInput)` |\n| 12.2 | Require authentication for file downloads | FileGuard on download endpoints |\n| 12.3 | Restrict file types to business need | Allowlist MIME types |\n| 12.4 | Validate file type by content | Magic byte validation |\n| 12.5 | Don't save files in web context | S3 or separate file server |\n| 12.6 | Block execution of user-uploaded files | No execute permissions, nosniff header |\n| 12.7 | Implement secure upload progress | Chunked uploads with validation |\n| 12.8 | Prevent path traversal in uploads | `path.basename()` and random filenames |\n| 12.9 | Scan uploaded files for malware | ClamAV integration |\n| 12.10 | Protect file permissions | `chmod 644` for uploads |\n\n```typescript\n// Secure file upload handling\n@Post('upload')\n@UseInterceptors(FileInterceptor('file', {\n  limits: { fileSize: 5 * 1024 * 1024 },  // 5MB\n  fileFilter: (req, file, cb) => {\n    const allowedMimes = ['image/jpeg', 'image/png', 'application/pdf'];\n    if (!allowedMimes.includes(file.mimetype)) {\n      return cb(new BadRequestException('Invalid file type'), false);\n    }\n    cb(null, true);\n  }\n}))\nasync uploadFile(@UploadedFile() file: Express.Multer.File) {\n  // Additional magic byte validation\n  const type = await fileType.fromBuffer(file.buffer);\n  if (!type || !['image/jpeg', 'image/png', 'application/pdf'].includes(type.mime)) {\n    throw new BadRequestException('Invalid file content');\n  }\n\n  // Generate secure filename\n  const filename = `${randomUUID()}${path.extname(file.originalname)}`;\n  // Upload to S3 or secure storage\n}\n```\n\n---\n\n## 13. Memory Management\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 13.1 | Use input/output control for untrusted data | Streams with limits |\n| 13.2 | Check buffer boundaries | Node.js handles automatically |\n| 13.3 | Truncate input to buffer length | String slicing before assignment |\n| 13.4 | Use safe functions (strncpy vs strcpy) | Not applicable to Node.js |\n| 13.5 | Free resources properly | `finally` blocks, try-with-resources pattern |\n| 13.6 | Bounds checking on stack variables | Not applicable to Node.js |\n| 13.7 | Avoid unsafe functions | No `eval()`, no `Function()` constructor |\n| 13.8 | Format strings from trusted sources | No template injection |\n| 13.9 | Clear sensitive data from memory | `buffer.fill(0)` for sensitive buffers |\n\n```typescript\n// Avoid eval and similar\nconst userInput = req.body.code;\n// NEVER: eval(userInput)\n// NEVER: new Function(userInput)\n// NEVER: vm.runInContext(userInput)\n\n// Clear sensitive data\nfunction processPassword(password: string): void {\n  const passwordBuffer = Buffer.from(password);\n  try {\n    // Process password...\n  } finally {\n    passwordBuffer.fill(0);  // Clear from memory\n  }\n}\n```\n\n---\n\n## 14. General Coding Practices\n\n| # | Practice | NestJS Implementation |\n|---|----------|----------------------|\n| 14.1 | Tested and approved managed code | `npm audit`, code review |\n| 14.2 | Use task-specific tested libraries | Well-maintained packages only |\n| 14.3 | Don't use client-side code for security | Server-side validation always |\n| 14.4 | Use checksums for integrity | Package lock files, SRI |\n| 14.5 | Don't allow non-essential URLs | Validate redirect URLs |\n| 14.6 | Prevent frame embedding | `X-Frame-Options: DENY` via Helmet |\n| 14.7 | Use safe redirect functions | Allowlist valid redirect targets |\n| 14.8 | Remove test code from production | Build process excludes tests |\n| 14.9 | Don't implement custom crypto | Use Node.js crypto module |\n| 14.10 | Use complete error checking | Validate all function returns |\n\n```typescript\n// Safe redirect validation\nconst ALLOWED_REDIRECTS = ['/', '/dashboard', '/profile'];\n\n@Get('redirect')\nredirect(@Query('to') to: string, @Res() res: Response) {\n  if (!ALLOWED_REDIRECTS.includes(to)) {\n    throw new BadRequestException('Invalid redirect target');\n  }\n  return res.redirect(to);\n}\n\n// Or validate against origin\nconst url = new URL(to, 'https://example.com');\nif (url.hostname !== 'example.com') {\n  throw new BadRequestException('Cannot redirect to external sites');\n}\n```\n\n---\n\n## Quick Reference Card\n\n### Pre-Deployment Checklist\n\n**Input/Output:**\n- [ ] ValidationPipe global mit whitelist\n- [ ] Alle DTOs mit class-validator Decorators\n- [ ] HTML-Sanitization f√ºr User-Content\n- [ ] Parameterized Queries (kein String-Building)\n\n**Authentication:**\n- [ ] bcrypt f√ºr Passwords (cost ‚â• 10)\n- [ ] JWT Access Tokens ‚â§ 15 min\n- [ ] Refresh Token Rotation\n- [ ] Generic Error Messages\n\n**Authorization:**\n- [ ] Default-Deny auf Class-Level\n- [ ] Ownership-Checks in Services\n- [ ] Rate Limiting auf Auth-Endpoints\n\n**Communication:**\n- [ ] HTTPS enforced\n- [ ] Helmet Security Headers\n- [ ] CORS auf allowed origins beschr√§nkt\n- [ ] Sensitive Cookies: httpOnly, secure, sameSite\n\n**Data Protection:**\n- [ ] Sensitive Fields hidden (hideField: true)\n- [ ] No secrets in code (env vars only)\n- [ ] PII encrypted at rest\n- [ ] Logs contain no passwords/tokens\n\n**Files:**\n- [ ] Magic Byte Validation\n- [ ] Size Limits\n- [ ] Random Filenames\n- [ ] External Storage (S3)\n\n**Dependencies:**\n- [ ] `npm audit` clean\n- [ ] No deprecated packages\n- [ ] Lock file committed\n",
        "plugins/lt-dev/skills/generating-nest-servers/quality-review.md": "---\nname: nest-server-generator-quality-review\ndescription: Comprehensive quality review guidelines before creating final report\n---\n\n# Phase 8: Pre-Report Quality Review\n\n## Table of Contents\n- [Step 1: Identify All Changes](#step-1-identify-all-changes)\n- [Step 2: Test Management](#step-2-test-management)\n- [Step 3: Compare with Existing Code](#step-3-compare-with-existing-code)\n- [Step 4: Critical Analysis](#step-4-critical-analysis)\n- [Step 5: Automated Optimizations](#step-5-automated-optimizations)\n- [Step 6: Pre-Report Testing](#step-6-pre-report-testing)\n- [Step 7: Final Verification](#step-7-final-verification)\n\n**CRITICAL**: Before creating the final report, you MUST perform a comprehensive quality review:\n\n## Step 1: Identify All Changes\n\nUse git to identify all created and modified files:\n\n```bash\ngit status --short\ngit diff --name-only\n```\n\nFor each file, review:\n- All newly created files\n- All modified files\n- File structure and organization\n\n## Step 2: Test Management\n\n**CRITICAL**: Ensure tests are created/updated for all changes:\n\n### Step 2.1: Analyze Existing Tests FIRST\n\n**BEFORE creating or modifying ANY tests, you MUST thoroughly analyze existing tests**:\n\n1. **Identify all existing test files**:\n   ```bash\n   # List all test directories and files\n   ls -la tests/\n   ls -la tests/modules/\n   find tests -name \"*.e2e-spec.ts\" -type f\n   ```\n\n2. **Read multiple existing test files completely**:\n   ```bash\n   # Read at least 2-3 different module tests to understand patterns\n   cat tests/modules/user.e2e-spec.ts\n   cat tests/modules/<another-module>.e2e-spec.ts\n\n   # Also check the common and project test files\n   cat tests/common.e2e-spec.ts\n   cat tests/project.e2e-spec.ts\n   ```\n\n3. **CRITICAL: Understand the TestHelper thoroughly**:\n\n   **Before creating any tests, you MUST understand the TestHelper from @lenne.tech/nest-server**:\n\n   ```bash\n   # Read the TestHelper source code to understand its capabilities\n   cat node_modules/@lenne.tech/nest-server/src/test/test.helper.ts\n   ```\n\n   **Analyze the TestHelper to understand**:\n   - **Available methods**: What methods does TestHelper provide?\n   - **Configuration options**: How can TestHelper be configured?\n   - **GraphQL support**: How to use `graphQl()` method? What parameters does it accept?\n   - **REST support**: How to use `rest()` method? What parameters does it accept?\n   - **Authentication**: How does TestHelper handle tokens and authentication?\n   - **Request building**: How are requests constructed? What options are available?\n   - **Response handling**: How are responses processed? What format is returned?\n   - **Error handling**: How does TestHelper handle errors and failures?\n   - **Helper utilities**: What additional utilities are available?\n\n   **Document your findings**:\n   ```typescript\n   // Example: Understanding TestHelper.graphQl()\n   // Method signature: graphQl(options: GraphQLOptions, config?: RequestConfig)\n   // GraphQLOptions: { name, type (QUERY/MUTATION), arguments, fields }\n   // RequestConfig: { token, statusCode, headers }\n   // Returns: Parsed response data or error\n\n   // Example: Understanding TestHelper.rest()\n   // Method signature: rest(method: HttpMethod, path: string, options?: RestOptions)\n   // HttpMethod: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE'\n   // RestOptions: { body, token, statusCode, headers }\n   // Returns: Response data or error\n   ```\n\n   **Common TestHelper patterns to understand**:\n   - How to execute GraphQL queries/mutations with `graphQl()`\n   - How to execute REST requests with `rest()`\n   - How to pass authentication tokens (same for both methods)\n   - How to handle expected errors (statusCode parameter)\n   - How to work with response data\n   - How to structure test data\n   - When to use GraphQL vs REST methods\n\n   **Only after fully understanding TestHelper, proceed to next step.**\n\n4. **Understand the testing approach used**:\n   - Which test framework? (Vitest, Jest, etc.)\n   - Which testing utilities? (@lenne.tech/nest-server testHelper, custom helpers)\n   - How is the test app initialized? (beforeAll setup)\n   - How are test users/auth handled?\n   - How is test data created and cleaned up?\n   - What assertion library? (expect, should, etc.)\n   - Are there custom matchers?\n\n5. **Document the patterns you observe**:\n   - **Import patterns**: Which modules are imported? In what order?\n   - **Setup patterns**: How is beforeAll/beforeEach structured?\n   - **Auth patterns**: How do tests authenticate? Token handling?\n   - **Test structure**: Describe blocks organization? Test naming conventions?\n   - **CRUD patterns**: How are create/read/update/delete tested?\n   - **Assertion patterns**: What assertions are used? How detailed?\n   - **Cleanup patterns**: How is afterAll/afterEach structured?\n   - **Error testing**: How are failures/validations tested?\n\n6. **Verify existing tests run successfully**:\n   ```bash\n   # Run existing tests to ensure they pass\n   npm run test:e2e\n\n   # If any fail, understand why before proceeding\n   # Your new/modified tests MUST NOT break existing tests\n   ```\n\n7. **Create a mental checklist**:\n   - [ ] I have read and understand the TestHelper source code\n   - [ ] I understand TestHelper methods and configuration\n   - [ ] I understand how to use graphQl() method (GraphQL queries/mutations)\n   - [ ] I understand how to use rest() method (REST endpoints)\n   - [ ] I understand when to use graphQl() vs rest()\n   - [ ] I understand TestHelper authentication and error handling\n   - [ ] I understand which test helpers/utilities are used\n   - [ ] I understand the authentication/authorization pattern\n   - [ ] I understand the test data lifecycle (create/cleanup)\n   - [ ] I understand the assertion patterns\n   - [ ] I understand the error testing approach\n   - [ ] All existing tests pass before I make changes\n\n**Only after completing this analysis, proceed to create or modify tests.**\n\n### Step 2.1.1: Understanding Permissions and User Rights in Tests\n\n**CRITICAL**: Before creating tests, you MUST understand the 3-layer permission system:\n\n**Important Definitions**:\n\n- **Admin User**: A user whose `roles` array contains `'admin'`\n  ```typescript\n  // Example admin user\n  {\n    id: '123',\n    email: 'admin@test.com',\n    roles: ['admin', 'user'] // ‚Üê Contains 'admin'\n  }\n  ```\n\n- **Creator**: The user who created an object, identified by matching IDs\n  ```typescript\n  // User who created the object\n  const user = { id: 'user-123', email: 'creator@test.com' };\n\n  // Object created by this user\n  const product = {\n    id: 'product-456',\n    name: 'Test Product',\n    createdBy: 'user-123' // ‚Üê Matches user.id -> This user is the CREATOR\n  };\n\n  // Different user (NOT the creator)\n  const otherUser = { id: 'user-789', email: 'other@test.com' };\n  // otherUser.id !== product.createdBy -> NOT the creator!\n  ```\n\n**The Three Permission Layers**:\n\n1. **Controller/Resolver Layer** (`@Roles()` decorator):\n   - Controls WHO can call the endpoint\n   - Example: `@Roles(RoleEnum.ADMIN)` -> Only admins can call this endpoint\n   - Example: `@Roles(RoleEnum.S_USER)` -> All signed-in users can call\n\n2. **Service Layer** (`serviceOptions.roles` parameter):\n   - Controls what permissions are checked during service processing\n   - Example: Update/Delete often require `[RoleEnum.ADMIN, RoleEnum.S_CREATOR]`\n   - The creator can update/delete their own items\n\n3. **Model Layer** (`securityCheck()` method):\n   - Controls WHAT data is returned to the user\n   - Standard implementation:\n     ```typescript\n     securityCheck(user: User, force?: boolean) {\n       // Admins see everything (user.roles contains 'admin')\n       if (force || user?.hasRole(RoleEnum.ADMIN)) {\n         return this;\n       }\n       // Only creator can see their own data (user.id === this.createdBy)\n       if (!equalIds(user, this.createdBy)) {\n         return undefined; // Non-creator gets nothing!\n       }\n       return this;\n     }\n     ```\n   - **Key checks**:\n     - `user?.hasRole(RoleEnum.ADMIN)` -> Returns `true` if `user.roles.includes('admin')`\n     - `equalIds(user, this.createdBy)` -> Returns `true` if `user.id === this.createdBy`\n\n**Default Permission Behavior**:\n- **Create**: Usually accessible to signed-in users (`RoleEnum.S_USER`)\n- **Read/List**: Usually accessible to signed-in users, but securityCheck filters results\n- **Update**: Only ADMIN or CREATOR (via `serviceOptions.roles` check)\n- **Delete**: Only ADMIN or CREATOR (via `serviceOptions.roles` check)\n\n**Analyzing Permissions Before Creating Tests**:\n\nBefore writing tests, check these 3 locations:\n\n1. **Check Controller/Resolver decorators**:\n   ```typescript\n   // In product.resolver.ts\n   @Roles(RoleEnum.ADMIN) // ‚Üê WHO can call this?\n   @Query(() => Product)\n   async getProduct(@Args('id') id: string) { ... }\n\n   @Roles(RoleEnum.S_USER) // ‚Üê All signed-in users\n   @Mutation(() => Product)\n   async createProduct(@Args('input') input: ProductCreateInput) { ... }\n   ```\n\n2. **Check Model/Object `@Restricted` decorators**:\n   ```typescript\n   // In product.model.ts\n   @Restricted(RoleEnum.ADMIN) // ‚Üê Model-level restriction\n   export class Product extends CoreModel {\n\n     @Restricted(RoleEnum.ADMIN) // ‚Üê Property-level restriction\n     @UnifiedField()\n     internalNotes?: string;\n   }\n   ```\n\n3. **Check Model `securityCheck()` logic**:\n   ```typescript\n   // In product.model.ts\n   securityCheck(user: User, force?: boolean) {\n     // Admin check: user.roles contains 'admin'\n     if (force || user?.hasRole(RoleEnum.ADMIN)) {\n       return this; // Admin sees all\n     }\n\n     // Custom logic: Allow public products for everyone\n     if (this.isPublic) {\n       return this;\n     }\n\n     // Creator check: user.id === this.createdBy\n     if (!equalIds(user, this.createdBy)) {\n       return undefined; // Non-creator gets nothing\n     }\n     return this; // Creator sees their own product\n   }\n   ```\n\n**Creating Appropriate Test Users**:\n\nBased on permission analysis, create appropriate test users:\n\n```typescript\ndescribe('Product Module', () => {\n  let testHelper: TestHelper;\n  let adminToken: string;\n  let userToken: string;\n  let otherUserToken: string;\n  let createdProductId: string;\n\n  beforeAll(async () => {\n    testHelper = new TestHelper(app);\n\n    // Admin user (user.roles contains 'admin')\n    const adminAuth = await testHelper.graphQl({\n      name: 'signIn',\n      type: TestGraphQLType.MUTATION,\n      arguments: { email: 'admin@test.com', password: 'admin' },\n      fields: ['token', 'user { id email roles }']\n    });\n    adminToken = adminAuth.token;\n    // adminAuth.user.roles = ['admin', 'user'] ‚Üê Contains 'admin'\n\n    // Regular user (will be the creator of test objects)\n    const userAuth = await testHelper.graphQl({\n      name: 'signIn',\n      type: TestGraphQLType.MUTATION,\n      arguments: { email: 'user@test.com', password: 'user' },\n      fields: ['token', 'user { id email roles }']\n    });\n    userToken = userAuth.token;\n    // When this user creates an object -> object.createdBy = userAuth.user.id\n\n    // Another regular user (will NOT be the creator)\n    const otherUserAuth = await testHelper.graphQl({\n      name: 'signIn',\n      type: TestGraphQLType.MUTATION,\n      arguments: { email: 'other@test.com', password: 'other' },\n      fields: ['token', 'user { id email roles }']\n    });\n    otherUserToken = otherUserAuth.token;\n    // otherUserAuth.user.id !== object.createdBy -> NOT the creator\n  });\n});\n```\n\n**Test Structure Based on Permissions**:\n\n```typescript\ndescribe('Product Module', () => {\n  // ... setup with adminToken, userToken, otherUserToken\n\n  describe('Create Product', () => {\n    it('should create product as regular user', async () => {\n      const result = await testHelper.graphQl({\n        name: 'createProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { input: { name: 'Test Product', price: 99.99 } },\n        fields: ['id', 'name', 'createdBy { id }']\n      }, { token: userToken }); // ‚Üê Created by userToken\n\n      expect(result.name).toBe('Test Product');\n      // result.createdBy.id now equals userAuth.user.id\n      // -> userToken is the CREATOR of this product\n      createdProductId = result.id;\n    });\n  });\n\n  describe('Update Product', () => {\n    it('should update product as creator', async () => {\n      const result = await testHelper.graphQl({\n        name: 'updateProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: {\n          id: createdProductId,\n          input: { price: 89.99 }\n        },\n        fields: ['id', 'price']\n      }, { token: userToken }); // ‚Üê Creator: userAuth.user.id === product.createdBy\n\n      expect(result.price).toBe(89.99);\n    });\n\n    it('should update product as admin', async () => {\n      const result = await testHelper.graphQl({\n        name: 'updateProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: {\n          id: createdProductId,\n          input: { price: 79.99 }\n        },\n        fields: ['id', 'price']\n      }, { token: adminToken }); // ‚Üê Admin: adminAuth.user.roles contains 'admin'\n\n      expect(result.price).toBe(79.99);\n    });\n\n    it('should fail to update product as non-creator', async () => {\n      const result = await testHelper.graphQl({\n        name: 'updateProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: {\n          id: createdProductId,\n          input: { price: 69.99 }\n        },\n        fields: ['id']\n      }, { token: otherUserToken, statusCode: 403 }); // ‚Üê Not creator: otherUserAuth.user.id !== product.createdBy\n\n      expect(result.errors).toBeDefined();\n    });\n  });\n\n  describe('Delete Product', () => {\n    it('should delete product as creator', async () => {\n      // First create a new product to delete\n      const created = await testHelper.graphQl({\n        name: 'createProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { input: { name: 'To Delete', price: 50 } },\n        fields: ['id']\n      }, { token: userToken });\n\n      // Delete as creator\n      const result = await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: created.id },\n        fields: ['id']\n      }, { token: userToken }); // ‚Üê Creator: userAuth.user.id === created.createdBy\n\n      expect(result.id).toBe(created.id);\n    });\n\n    it('should fail to delete product as non-creator', async () => {\n      const result = await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: createdProductId },\n        fields: ['id']\n      }, { token: otherUserToken, statusCode: 403 }); // ‚Üê Not creator: otherUserAuth.user.id !== product.createdBy\n\n      expect(result.errors).toBeDefined();\n    });\n\n    it('should delete any product as admin', async () => {\n      const result = await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: createdProductId },\n        fields: ['id']\n      }, { token: adminToken }); // ‚Üê Admin: adminAuth.user.roles contains 'admin'\n\n      expect(result.id).toBe(createdProductId);\n    });\n  });\n});\n```\n\n**Permission Testing Checklist**:\n\nBefore creating tests, verify:\n\n- [ ] I have checked the `@Roles()` decorators in controllers/resolvers\n- [ ] I have checked the `@Restricted()` decorators in models/objects\n- [ ] I have reviewed the `securityCheck()` logic in models\n- [ ] I understand who can CREATE items (usually S_USER)\n- [ ] I understand who can READ items (S_USER + securityCheck filtering)\n- [ ] I understand who can UPDATE items (usually ADMIN + S_CREATOR)\n- [ ] I understand who can DELETE items (usually ADMIN + S_CREATOR)\n- [ ] I have created appropriate test users (admin, creator, non-creator)\n- [ ] My tests use the CREATOR token (user.id === object.createdBy) for update/delete operations\n- [ ] My tests verify that non-creators (user.id !== object.createdBy) CANNOT update/delete\n- [ ] My tests verify that admins (user.roles contains 'admin') CAN update/delete everything\n\n**Common Permission Test Patterns**:\n\n1. **Test with creator** (user.id === object.createdBy) -> Should succeed\n2. **Test with admin** (user.roles contains 'admin') -> Should succeed\n3. **Test with other user** (user.id !== object.createdBy) -> Should fail (403)\n\n**Only after understanding permissions, proceed to create tests.**\n\n### Step 2.2: For Newly Created Modules\n\n**CRITICAL: Follow the correct test folder structure**:\n\nThe project uses a specific test organization:\n\n1. **Module tests** (for modules in `src/server/modules/`):\n   ```\n   tests/modules/<module-name>.e2e-spec.ts\n   ```\n   - Each module gets its own test file directly in `tests/modules/`\n   - Examples: `tests/modules/user.e2e-spec.ts`, `tests/modules/book.e2e-spec.ts`\n\n2. **Common tests** (for common functionality in `src/server/common/`):\n   ```\n   tests/common.e2e-spec.ts\n   ```\n   - All common functionality (enums, objects, helpers) tested here\n   - Single file for all common-related tests\n\n3. **Project tests** (for everything else - root level, config, etc.):\n   ```\n   tests/project.e2e-spec.ts\n   ```\n   - General project-level tests\n   - Configuration tests\n   - Integration tests\n\n**Determine correct test location**:\n\n```bash\n# BEFORE creating a test, ask yourself:\n# - Is this a module in src/server/modules/? -> tests/modules/<name>.e2e-spec.ts\n# - Is this common functionality? -> Add to tests/common.e2e-spec.ts\n# - Is this project-level? -> Add to tests/project.e2e-spec.ts\n\n# Check existing test structure to confirm:\nls -la tests/\nls tests/modules/\n```\n\n**Create new test files** for modules following the patterns you identified:\n\n```bash\n# For a new module (e.g., Book)\ntests/modules/book.e2e-spec.ts\n```\n\n**IMPORTANT**: Your new test file MUST:\n1. **Match the exact structure** of existing test files\n2. **Use the same imports** as existing tests\n3. **Follow the same setup/cleanup pattern** (beforeAll, afterAll)\n4. **Use the same test helpers/utilities** you observed\n5. **Follow the same authentication pattern**\n6. **Use the same assertion style**\n7. **Follow the same naming conventions** for describe/it blocks\n\n**Each new test file must include**:\n1. All CRUD operations (create, find all, find by ID, update, delete)\n2. Authorization tests (unauthorized should fail, authorized should succeed)\n3. Required field validation (missing required fields should fail)\n4. Proper test data setup and cleanup (beforeAll, afterAll)\n5. Tests for any custom methods or relationships\n\n**Ensure all prerequisites are met by analyzing existing tests**:\n\nBefore writing test code, identify ALL prerequisites from existing test files:\n\n```bash\n# Read an existing module test to understand prerequisites\ncat tests/modules/user.e2e-spec.ts\n```\n\n**Common prerequisites to check**:\n1. **Test data dependencies**:\n   - Does the module reference other modules? (e.g., Book -> User for borrowedBy)\n   - Do you need to create related test data first?\n   - Example: To test Book with borrowedBy: User, create test User first\n\n2. **Authentication requirements**:\n   - What roles/permissions are needed?\n   - Do test users need to be created with specific roles?\n   - Example: Admin user for create operations, regular user for read operations\n\n3. **Database setup**:\n   - Are there database constraints or required collections?\n   - Do embedded objects or enums need to exist?\n\n4. **Configuration**:\n   - Are environment variables or config values needed?\n   - Example: JWT secrets, database connections\n\n**Pattern from existing tests**:\n```typescript\n// Example structure you should follow:\nbeforeAll(async () => {\n  // 1. Initialize test app/module\n  // 2. Set up database connection\n  // 3. Create prerequisite test data (users, roles, etc.)\n  // 4. Authenticate and get tokens\n});\n\ndescribe('Module Tests', () => {\n  // Tests here\n});\n\nafterAll(async () => {\n  // 1. Delete created test data (in reverse order)\n  // 2. Clean up connections\n  // 3. Close app\n});\n```\n\n**CRITICAL**: Look at how existing tests handle prerequisites and replicate the exact same approach.\n\n### Step 2.3: For Modified Existing Modules\n\n**Update existing test files** when you modify modules:\n\n1. **FIRST: Read the existing test file completely**:\n   ```bash\n   # Find and read the test file for the module you modified\n   find tests -name \"*<module-name>*.e2e-spec.ts\"\n   cat tests/modules/<module-name>.e2e-spec.ts\n   ```\n\n2. **Understand what the existing tests cover**:\n   - Which operations are tested?\n   - Which properties are validated?\n   - What edge cases are covered?\n   - How is test data structured?\n\n3. **Run existing tests to ensure they pass BEFORE your changes**:\n   ```bash\n   npm run test:e2e\n   ```\n\n4. **Review and update tests**:\n   - **Added properties**: Add tests verifying new properties work correctly\n   - **Changed validation**: Update tests to reflect new validation rules\n   - **Added relationships**: Add tests for new references/embedded objects\n   - **Changed required fields**: Update CreateInput tests accordingly\n   - **Removed properties**: Remove related test assertions\n\n5. **Verify test coverage**:\n   - All new properties are tested\n   - Changed behavior is verified\n   - Edge cases are covered\n   - Authorization still works correctly\n\n6. **Run tests again to ensure your changes don't break anything**:\n   ```bash\n   npm run test:e2e\n   ```\n\n## Step 3: Compare with Existing Code\n\n**Compare generated code with existing project code**:\n\n1. **Read existing similar modules** to understand project patterns:\n   ```bash\n   # Example: If you created a User module, check existing modules\n   ls src/server/modules/\n   ```\n\n2. **Check for consistency**:\n   - Code style (indentation, spacing, formatting)\n   - Import ordering and organization\n   - Naming conventions (camelCase, PascalCase, kebab-case)\n   - File structure and directory organization\n   - Comment style and documentation\n   - Decorator usage (@Field, @Prop, etc.)\n   - Error handling patterns\n   - Validation patterns\n\n3. **Review property ordering**:\n   - Verify alphabetical order in models\n   - Verify alphabetical order in inputs\n   - Verify alphabetical order in outputs\n   - Check decorator consistency\n\n## Step 4: Critical Analysis\n\n**Analyze each file critically**:\n\n1. **Style consistency**:\n   - Does the code match the project's existing style?\n   - Are imports grouped and ordered correctly?\n   - Is indentation consistent with the project?\n   - Are naming conventions followed?\n\n2. **Structural consistency**:\n   - Are decorators in the same order as existing code?\n   - Is the file structure identical to existing modules?\n   - Are descriptions formatted the same way?\n   - Are relationships implemented consistently?\n\n3. **Code quality**:\n   - Are there any redundant imports?\n   - Are there any missing imports?\n   - Are descriptions meaningful and complete?\n   - Are TypeScript types correctly used?\n\n4. **Best practices**:\n   - Are required fields properly marked?\n   - Are nullable fields correctly configured?\n   - Are references properly typed?\n   - Are arrays correctly configured?\n\n## Step 5: Automated Optimizations\n\n**Apply automatic improvements**:\n\n1. **Fix import ordering**:\n   - External imports first (alphabetically)\n   - @lenne.tech/nest-server imports next\n   - Local imports last (alphabetically by path depth)\n\n2. **Fix property ordering**:\n   - Reorder all properties alphabetically in models\n   - Reorder all properties alphabetically in inputs\n   - Reorder all properties alphabetically in outputs\n\n3. **Fix formatting**:\n   - Ensure consistent indentation\n   - Remove extra blank lines\n   - Add missing blank lines between sections\n\n4. **Fix descriptions**:\n   - Ensure all follow \"ENGLISH (DEUTSCH)\" format\n   - Add missing descriptions\n   - Improve unclear descriptions\n\n5. **Fix common patterns**:\n   - Standardize decorator usage\n   - Standardize validation patterns\n   - Standardize error handling\n\n## Step 6: Pre-Report Testing\n\n**MANDATORY**: Run all tests before reporting:\n\n```bash\n# Run TypeScript compilation\nnpm run build\n\n# Run linting\nnpm run lint\n\n# Run all tests\nnpm run test:e2e\n\n# If any fail, fix issues and repeat\n```\n\n**If tests fail**:\n1. Analyze the error\n2. Fix the issue\n3. Re-run tests\n4. Repeat until all tests pass\n\n### Debugging Failed Tests - Important Guidelines\n\n**When tests fail, use systematic debugging with console.log statements:**\n\n1. **Add debug messages in Controllers/Resolvers**:\n   ```typescript\n   // In controller/resolver - BEFORE service call\n   console.log('üîµ [Controller] createProduct - Input:', input);\n   console.log('üîµ [Controller] createProduct - User:', serviceOptions?.user);\n\n   const result = await this.productService.create(input, serviceOptions);\n\n   // AFTER service call\n   console.log('üîµ [Controller] createProduct - Result:', result);\n   ```\n\n2. **Add debug messages in Services**:\n   ```typescript\n   // In service method\n   console.log(' [Service] create - Input:', input);\n   console.log(' [Service] create - ServiceOptions:', serviceOptions);\n\n   const created = await super.create(input, serviceOptions);\n\n   console.log(' [Service] create - Created:', created);\n   ```\n\n3. **Understand the permissions system**:\n   - **Controllers/Resolvers**: `@Roles()` decorator controls WHO can call the endpoint\n   - **Services**: `serviceOptions.roles` controls what the service checks during processing\n   - **Models**: `securityCheck()` method determines what data is returned to the user\n\n4. **Default permission behavior**:\n   - Only **Admin users** (user.roles contains 'admin') OR the **creator** (user.id === object.createdBy) of an element can access it\n   - This is enforced in the `securityCheck()` method in models:\n   ```typescript\n   securityCheck(user: User, force?: boolean) {\n     // Admin: user.roles contains 'admin'\n     if (force || user?.hasRole(RoleEnum.ADMIN)) {\n       return this; // Admin sees everything\n     }\n     // Creator: user.id === this.createdBy\n     if (!equalIds(user, this.createdBy)) {\n       return undefined; // Non-creator (user.id !== this.createdBy) gets nothing\n     }\n     return this; // Creator sees their own data\n   }\n   ```\n\n5. **Debugging strategy for permission issues**:\n\n   **Step 1**: Run failing test with Admin user first\n   ```typescript\n   // In test setup\n   const adminToken = await testHelper.signIn('admin@test.com', 'admin-password');\n\n   // Use admin token in test\n   const result = await testHelper.graphQl({...}, { token: adminToken });\n   ```\n\n   **Step 2**: Analyze results\n   -  **Works with Admin, fails with normal user** -> Permission issue (check Roles, securityCheck)\n   -  **Fails with Admin too** -> Different issue (check logic, data, validation)\n\n6. **Common permission issues and solutions**:\n\n   | Problem | Cause | Solution |\n   |---------|-------|----------|\n   | 401/403 on endpoint | `@Roles()` too restrictive | Adjust decorator in controller/resolver |\n   | Empty result despite data existing | `securityCheck()` returns undefined | Modify securityCheck logic or use Admin |\n   | Service throws permission error | `serviceOptions.roles` check fails | Pass correct roles in serviceOptions |\n\n7. **Remove debug messages after fixing**:\n   ```bash\n   # After tests pass, remove all console.log statements\n   # Search for debug patterns\n   grep -r \"console.log\" src/server/modules/your-module/\n\n   # Remove them manually or with sed\n   # Then verify tests still pass\n   npm run test:e2e\n   ```\n\n**Debugging workflow example**:\n```typescript\n// 1. Test fails - add debugging\n@Mutation(() => Product)\nasync createProduct(@Args('input') input: ProductCreateInput, @GraphQLServiceOptions() opts) {\n  console.log('üîµ START createProduct', { input, user: opts?.user?.email });\n\n  const result = await this.productService.create(input, opts);\n\n  console.log('üîµ END createProduct', { result: result?.id });\n  return result;\n}\n\n// In service\nasync create(input: ProductCreateInput, serviceOptions?: ServiceOptions) {\n  console.log(' Service create', { input, user: serviceOptions?.user?.email });\n\n  const created = await super.create(input, serviceOptions);\n\n  console.log(' Service created', { id: created?.id, createdBy: created?.createdBy });\n  return created;\n}\n\n// 2. Run test - observe output:\n// üîµ START createProduct { input: {...}, user: 'test@test.com' }\n//  Service create { input: {...}, user: 'test@test.com' }\n//  Service created { id: '123', createdBy: '456' }\n// üîµ END createProduct { result: undefined }  ‚Üê AHA! Result is undefined!\n\n// 3. Check model securityCheck() - likely returns undefined for non-creator (user.id !== object.createdBy)\n// 4. Fix: Either use Admin user (user.roles contains 'admin') or adjust securityCheck logic\n// 5. Test passes -> Remove console.log statements\n// 6. Verify tests still pass\n```\n\n**Do not proceed to final report if**:\n- TypeScript compilation fails\n- Linting fails\n- Any tests fail\n- Console shows errors or warnings\n\n## Step 7: Final Verification\n\nBefore reporting, verify:\n\n- [ ] All files compared with existing code\n- [ ] Code style matches project patterns\n- [ ] All imports properly ordered\n- [ ] All properties in alphabetical order\n- [ ] All descriptions follow format\n- [ ] **TestHelper source code read and understood**\n- [ ] **TestHelper methods and configuration understood**\n- [ ] **Existing tests analyzed BEFORE creating/modifying tests**\n- [ ] **Existing tests passed BEFORE making changes**\n- [ ] **Tests in correct location (tests/modules/<name>.e2e-spec.ts, tests/common.e2e-spec.ts, or tests/project.e2e-spec.ts)**\n- [ ] **New test files created for all new modules**\n- [ ] **Existing test files updated for all modified modules**\n- [ ] **All prerequisites identified and handled (test data dependencies, auth, etc.)**\n- [ ] **All new/modified tests follow exact patterns from existing tests**\n- [ ] TypeScript compiles without errors\n- [ ] Linter passes without warnings\n- [ ] **All tests pass AFTER changes**\n- [ ] No console errors or warnings\n\n**Only after ALL checks pass, proceed to Final Report.**\n",
        "plugins/lt-dev/skills/generating-nest-servers/reference.md": "---\nname: nest-server-generator-reference\ndescription: Quick reference for ALL NestJS server development - from simple single commands to complex structure generation\n---\n\n# NestJS Server Development Quick Reference\n\n## Table of Contents\n- [Scope](#scope)\n- [Specification Syntax](#specification-syntax)\n- [Execution Workflow](#execution-workflow)\n- [Command Quick Reference](#command-quick-reference)\n- [Description Format](#description-format)\n- [Inheritance Handling](#inheritance-handling)\n- [Enum File Template](#enum-file-template)\n- [API Test Template](#api-test-template)\n- [Common Patterns](#common-patterns)\n- [Troubleshooting](#troubleshooting)\n- [Verification Checklist](#verification-checklist)\n- [File Structure](#file-structure)\n- [Best Practices Summary](#best-practices-summary)\n- [Quick Start](#quick-start)\n\n## Scope\n\n**This skill handles ALL NestJS server development tasks:**\n-  Simple: Create single module, object, or add property\n-  Complex: Generate complete server structures from specifications\n-  Any `lt server` command\n\nUse this skill for **ANY** NestJS/nest-server work, no matter how simple or complex.\n\n## Specification Syntax\n\n### Component Types\n\n| Type | Syntax | Purpose |\n|------|--------|---------|\n| **SubObject** | `SubObject: Name // Desc` | Embedded data structure (no _id, no timestamps) |\n| **Object** | `Object: Name\\nProperties:\\n- prop: type` | Base model for inheritance |\n| **Module** | `Module: Name\\nModel: Name\\n- prop: type` | Full CRUD module with API |\n\n### Property Syntax\n\n| Pattern | Meaning | LT CLI Flag |\n|---------|---------|-------------|\n| `name: string` | Required string | `--prop-name-X name --prop-type-X string` |\n| `age?: number` | Optional number | `--prop-name-X age --prop-type-X number --prop-nullable-X true` |\n| `tags: string[]` | Array of strings | `--prop-name-X tags --prop-type-X string --prop-array-X true` |\n| `status: ENUM (A, B)` | Enum property | `--prop-name-X status --prop-enum-X StatusEnum` |\n| `owner: User` | Reference to module | `--prop-name-X owner --prop-type-X ObjectId --prop-reference-X User` |\n| `address: Address` | Embedded object | `--prop-name-X address --prop-schema-X Address` |\n| `items: Item[]` | Array of objects | `--prop-name-X items --prop-schema-X Item --prop-array-X true` |\n| `doc: File` | File reference | `--prop-name-X doc --prop-type-X string` |\n\n### Type Mapping\n\n| Spec Type | TypeScript | MongoDB | CLI Type |\n|-----------|-----------|---------|----------|\n| `string` | string | String | string |\n| `number` | number | Number | number |\n| `boolean` | boolean | Boolean | boolean |\n| `Date` | Date | Date | Date |\n| `bigint` | bigint | Long | bigint |\n| `File` | string | String | string |\n| `ENUM(...)` | XxxEnum | String/Number | (use --prop-enum-X) |\n| `OtherModule` | ObjectId ref | ObjectId | ObjectId + reference |\n| `SubObject` | Embedded | Object | (use --prop-schema-X) |\n\n## Execution Workflow\n\n### Phase Checklist\n\n```\n‚òê 1. Parse specification completely\n‚òê 2. Create comprehensive todo list\n‚òê 3. Create all SubObjects (dependency order)\n‚òê 4. Create all Objects\n‚òê 5. Create all Modules (dependency order)\n‚òê 6. Handle inheritance (manual edits)\n‚òê 7. Update ALL descriptions EVERYWHERE (CRITICAL!)\n    ‚òê 7.1. Extract ALL user comments (after //) from specification\n    ‚òê 7.2. Format descriptions: ENGLISH (DEUTSCH)\n    ‚òê 7.3. Apply to ALL Module files (Model, CreateInput, UpdateInput)\n    ‚òê 7.4. Apply to ALL SubObject files (Object, CreateInput, UpdateInput)\n    ‚òê 7.5. Add to ALL class decorators (@ObjectType, @InputType)\n    ‚òê 7.6. Verify consistency (same property = same description)\n‚òê 8. Alphabetize all properties\n‚òê 9. Create enum files\n‚òê 10. Create API tests\n‚òê 11. Run tests\n‚òê 12. Verify & provide summary\n```\n\n### Dependency Order\n\n```\n1. SubObjects (if A uses B, create B first)\n2. Objects (base models)\n3. Modules (if A references B, create B first)\n4. Circular refs (use addProp for second reference)\n5. Inheritance updates\n6. Enums\n7. Tests\n```\n\n## Command Quick Reference\n\n### Create New Server\n```bash\nlt server create <server-name>\n# Alias: lt server c <server-name>\n\n# Example\nlt server create my-api\n\n# With specific branch (for testing starter branches)\nlt server create my-api --branch feature/new-auth\nlt server create my-api -b feature/new-auth\n```\n\n**Options**:\n- `--branch <branch>` / `-b` - Branch of nest-server-starter to use as template\n\n**What it does**:\n- Clones nest-server-starter template (optionally from specific branch)\n- Configures package.json\n- Sets up Swagger docs\n- **Replaces ALL secrets** (`'SECRET_OR_PRIVATE_KEY...'` -> unique random values)\n- **Updates database names** (`nest-server-*` -> `<project-name>-*`)\n- Installs dependencies\n- Optionally initializes git\n\n**Post-creation verification**:\n- Verify `src/config.env.ts` has no `SECRET_OR_PRIVATE_KEY` placeholders\n- Verify mongoose.uri uses project name (e.g., `my-api-local` not `nest-server-local`)\n- If using older CLI (<v0.0.126), run `lt server setConfigSecrets` manually\n\n### Create SubObject\n```bash\nlt server object --name <Name> \\\n  --prop-name-0 <name> --prop-type-0 <type> [modifiers] \\\n  --prop-name-1 <name> --prop-type-1 <type> [modifiers]\n```\n\n### Create Module\n```bash\n# REST is the default! Only use GraphQL when explicitly requested.\nlt server module --name <Name> --controller Rest \\\n  --prop-name-0 <name> --prop-type-0 <type> [modifiers] \\\n  --prop-name-1 <name> --prop-type-1 <type> [modifiers]\n```\n\n**Controller Options:**\n- `Rest` (DEFAULT) - REST API with Controllers\n- `GraphQL` - GraphQL API with Resolvers (only when explicitly requested)\n- `Both` - REST + GraphQL (only when explicitly requested)\n\n### Add Properties\n```bash\nlt server addProp --type Module --element <Name> \\\n  --prop-name-0 <name> --prop-type-0 <type> [modifiers]\n```\n\n### Modifiers\n\n| Modifier | Flag | Example |\n|----------|------|---------|\n| Optional | `--prop-nullable-X true` | `--prop-nullable-2 true` |\n| Array | `--prop-array-X true` | `--prop-array-1 true` |\n| Enum | `--prop-enum-X <EnumName>` | `--prop-enum-3 StatusEnum` |\n| Schema | `--prop-schema-X <SchemaName>` | `--prop-schema-0 Address` |\n| Reference | `--prop-reference-X <ModelName>` | `--prop-reference-1 User` |\n\n## Description Format\n\n** CRITICAL:** Always extract descriptions from user comments (after `//`) and apply EVERYWHERE!\n\n**Rule**: `\"ENGLISH_DESCRIPTION (DEUTSCHE_BESCHREIBUNG)\"`\n\n### Processing\n\n| Input Comment | Language | Output Description |\n|---------------|----------|-------------------|\n| `// Product name` | English | `'Product name'` |\n| `// Produktname` | German | `'Product name (Produktname)'` |\n| `// Street name` | English | `'Street name'` |\n| `// Stra√üe` | German | `'Street (Stra√üe)'` |\n| `// Postleizahl` (typo) | German | `'Postal code (Postleitzahl)'` (corrected) |\n| (no comment) | - | Create meaningful English description |\n\n** Preserve Original Wording:**\n-  Fix typos: `Postleizahl` -> `Postleitzahl`, `Star√üe` -> `Stra√üe`\n-  DON'T rephrase: `Stra√üe` -> `Stra√üenname` (NO!)\n-  DON'T expand: `Produkt` -> `Produktbezeichnung` (NO!)\n- **Reason:** User comments may be predefined terms referenced by external systems\n\n### Apply To ALL Files\n\n**For EVERY Module property** (3 files):\n1. `<module>.model.ts` -> Property `@UnifiedField({ description: '...' })`\n2. `inputs/<module>-create.input.ts` -> Property `@UnifiedField({ description: '...' })`\n3. `inputs/<module>.input.ts` -> Property `@UnifiedField({ description: '...' })`\n\n**For EVERY SubObject property** (3 files):\n1. `objects/<object>/<object>.object.ts` -> Property `@UnifiedField({ description: '...' })`\n2. `objects/<object>/<object>-create.input.ts` -> Property `@UnifiedField({ description: '...' })`\n3. `objects/<object>/<object>.input.ts` -> Property `@UnifiedField({ description: '...' })`\n\n**For class decorators**:\n- `@ObjectType({ description: '...' })` on Models and Objects\n- `@InputType({ description: '...' })` on all Input classes\n\n### Common Mistakes\n\n **WRONG:** Descriptions only in Model, missing in Inputs\n **WRONG:** German-only descriptions without English translation\n **WRONG:** Inconsistent descriptions (different in Model vs Input)\n **WRONG:** Ignoring user-provided comments from specification\n **WRONG:** Changing wording: `Stra√üe` -> `Stra√üenname` (rephrased!)\n **WRONG:** Expanding terms: `Produkt` -> `Produktbezeichnung` (added word!)\n\n **CORRECT:** Same description in ALL 3 files (Model, CreateInput, UpdateInput)\n **CORRECT:** Format `ENGLISH (DEUTSCH)` for German comments\n **CORRECT:** All user comments extracted and applied\n **CORRECT:** Fix typos only, preserve original wording: `Postleizahl` -> `Postleitzahl`\n **CORRECT:** Keep exact terms: `Stra√üe` -> `Street (Stra√üe)` (not \"Street name\"!)\n\n## Inheritance Handling\n\n### Model Extension\n\n```typescript\n// FROM (generated):\nimport { CoreModel } from '@lenne.tech/nest-server';\nexport class ChildModel extends CoreModel { ... }\n\n// TO (manual edit):\nimport { ParentModel } from '../../common/objects/parent/parent.model';\nexport class ChildModel extends ParentModel { ... }\n```\n\n### Input Extension\n\n```typescript\n// child-create.input.ts\n// MUST include:\n// 1. ALL required fields from parent's CreateInput\n// 2. ALL required fields from child model\n// 3. Optional fields from both (optional in UpdateInput)\n```\n\n### Core Models (no changes needed)\n- `CoreModel`\n- `CorePersisted`\n- Any @lenne.tech/nest-server base class\n\n## Enum File Template\n\n```typescript\n// src/server/common/enums/<name>.enum.ts\nexport enum <Name>Enum {\n  VALUE_ONE = 'VALUE_ONE',\n  VALUE_TWO = 'VALUE_TWO',\n  VALUE_THREE = 'VALUE_THREE',\n}\n```\n\n### Naming\n- **File**: `kebab-case.enum.ts` -> `user-status.enum.ts`\n- **Enum**: `PascalCaseEnum` -> `UserStatusEnum`\n- **Values**: `UPPER_SNAKE_CASE` -> `ACTIVE`, `PENDING`\n\n## API Test Template\n\n```typescript\n// test/<module>/<module>.controller.test.ts\nimport { testHelper } from '@lenne.tech/nest-server';\n\ndescribe('<Module> Controller', () => {\n  let testUser;\n  let created<Model>;\n\n  beforeAll(async () => {\n    testUser = await testHelper.createTestUser({ roles: ['admin'] });\n  });\n\n  afterAll(async () => {\n    if (created<Model>) await testHelper.delete('<modules>', created<Model>.id);\n    await testHelper.deleteTestUser(testUser.id);\n  });\n\n  it('should create with required fields', async () => { /* ... */ });\n  it('should fail without required fields', async () => { /* ... */ });\n  it('should get all', async () => { /* ... */ });\n  it('should get by id', async () => { /* ... */ });\n  it('should update', async () => { /* ... */ });\n  it('should delete', async () => { /* ... */ });\n  it('should fail without auth', async () => { /* ... */ });\n});\n```\n\n### Test Coverage\n-  Create (valid data)\n-  Create (missing required - fail)\n-  Find all\n-  Find by ID\n-  Update\n-  Delete\n-  Authorization (fail without auth)\n-  Required fields validation\n\n## Common Patterns\n\n### Pattern 1: Simple Module\n```\nModule: Product\nModel: Product\n- name: string\n- price: number\n```\n -> `lt server module --name Product --controller Rest --prop-name-0 name --prop-type-0 string --prop-name-1 price --prop-type-1 number`\n\n### Pattern 2: Module with Reference\n```\nModule: Order\nModel: Order\n- customer: User\n- total: number\n```\n -> `lt server module --name Order --controller Rest --prop-name-0 customer --prop-type-0 ObjectId --prop-reference-0 User --prop-name-1 total --prop-type-1 number`\n\n### Pattern 3: Module with Embedded Object\n```\nSubObject: Address\n- street: string\n- city: string\n\nModule: Company\nModel: Company\n- name: string\n- address: Address\n```\n -> Create Address first, then Company with `--prop-schema-X Address`\n\n### Pattern 4: Module with Enum Array\n```\nModule: User\nModel: User\n- name: string\n- roles: ENUM (ADMIN, USER, GUEST)[]\n```\n -> `--prop-name-1 roles --prop-enum-1 RoleEnum --prop-array-1 true`\n\n### Pattern 5: Inheritance\n```\nObject: BaseProfile\nProperties:\n- name: string\n- email: string\n\nModule: UserProfile\nModel: UserProfile\nExtends: BaseProfile\n- username: string\n```\n -> Create BaseProfile object, create UserProfile module, manually update to extend BaseProfile\n\n### Pattern 6: Circular References\n```\nModule: Author\n- books: Book[]\n\nModule: Book\n- author: Author\n```\n -> Create Author, create Book with author ref, use addProp to add books to Author\n\n## Troubleshooting\n\n| Issue | Solution |\n|-------|----------|\n| Missing imports | Add manually: `import { Ref } from '@lenne.tech/nest-server'` |\n| CreateInput validation fails | Add parent's required fields to child's CreateInput |\n| Enum errors | Create enum file in `src/server/common/enums/` |\n| Test fails (required fields) | Check CreateInput for all required fields |\n| Circular dependency | Use `addProp` for second reference |\n| Properties not alphabetical | Reorder manually in all files |\n| TypeScript errors after inheritance | Check imports and extend statement |\n\n## Verification Checklist\n\nFinal checks before completing:\n\n```\n‚òê All SubObjects created\n‚òê All Objects created\n‚òê All Modules created\n‚òê Properties in alphabetical order\n‚òê DESCRIPTIONS - CRITICAL (check ALL):\n  ‚òê User comments extracted from specification\n  ‚òê German descriptions -> ENGLISH (DEUTSCH) format\n  ‚òê English descriptions -> kept as-is\n  ‚òê Module Models have descriptions\n  ‚òê Module CreateInputs have SAME descriptions\n  ‚òê Module UpdateInputs have SAME descriptions\n  ‚òê SubObjects have descriptions\n  ‚òê SubObject CreateInputs have SAME descriptions\n  ‚òê SubObject UpdateInputs have SAME descriptions\n  ‚òê @ObjectType/@InputType decorators have descriptions\n  ‚òê NO inconsistencies between files\n‚òê Inheritance correctly implemented\n‚òê CreateInputs have all required fields (parent + model)\n‚òê Enum files created in src/server/common/enums/\n‚òê API tests created for all modules\n‚òê Tests cover CRUD operations\n‚òê Tests verify authorization\n‚òê Tests verify required fields\n‚òê All tests pass\n‚òê No TypeScript errors\n‚òê Lint passes\n```\n\n## File Structure\n\n```\nsrc/server/\n‚îú‚îÄ‚îÄ modules/\n‚îÇ   ‚îú‚îÄ‚îÄ <module-name>/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <module-name>.model.ts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <module-name>.service.ts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <module-name>.controller.ts (if Rest/Both)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <module-name>.resolver.ts (if GraphQL/Both)\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <module-name>.module.ts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ inputs/\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <module-name>.input.ts\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ <module-name>-create.input.ts\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ outputs/\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ find-and-count-<module-name>s-result.output.ts\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îî‚îÄ‚îÄ common/\n    ‚îú‚îÄ‚îÄ objects/\n    ‚îÇ   ‚îú‚îÄ‚îÄ <object-name>/\n    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <object-name>.object.ts\n    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ <object-name>.input.ts\n    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ <object-name>-create.input.ts\n    ‚îÇ   ‚îî‚îÄ‚îÄ ...\n    ‚îî‚îÄ‚îÄ enums/\n        ‚îú‚îÄ‚îÄ <enum-name>.enum.ts\n        ‚îî‚îÄ‚îÄ ...\n\ntest/\n‚îú‚îÄ‚îÄ <module-name>/\n‚îÇ   ‚îú‚îÄ‚îÄ <module-name>.controller.test.ts\n‚îÇ   ‚îî‚îÄ‚îÄ <module-name>.resolver.test.ts\n‚îî‚îÄ‚îÄ ...\n```\n\n## Best Practices Summary\n\n1.  **Plan before executing** - Analyze full specification first\n2.  **Create dependencies first** - SubObjects -> Objects -> Modules\n3.  **Follow naming conventions** - PascalCase for types, camelCase for properties\n4.  **Order matters** - Alphabetical properties, dependency-ordered creation\n5.  **Describe thoroughly** - \"ENGLISH (DEUTSCH)\" everywhere\n6.  **Use REST by default** - Only use GraphQL when explicitly requested\n7.  **Test comprehensively** - All CRUD + auth + validation\n8.  **Clean up tests** - Delete test data in afterAll\n9.  **Commit incrementally** - After SubObjects, Modules, Tests\n10.  **Verify before finishing** - Run checklist, ensure tests pass\n11.  **Report observations** - Note data structure issues/improvements\n\n## Quick Start\n\n```bash\n# 1. Receive specification\n# 2. Parse and create todo list\n# 3. Execute commands in order:\n\n# SubObjects\nlt server object --name Address --prop-name-0 street --prop-type-0 string ...\n\n# Modules (REST is default!)\nlt server module --name User --controller Rest --prop-name-0 email --prop-type-0 string ...\n\n# Enums\n# Create files in src/server/common/enums/\n\n# Tests\n# Create test files for each module\n\n# 4. Verify and report\nnpm test\nnpm run lint\n# Provide summary\n```\n\n---\n\n**Remember**: This skill handles COMPLETE structure generation, not individual commands. Always process the full specification systematically and provide comprehensive summaries.\n",
        "plugins/lt-dev/skills/generating-nest-servers/security-rules.md": "---\nname: nest-server-generator-security-rules\ndescription: Critical security and test coverage rules for NestJS development\n---\n\n#  CRITICAL SECURITY RULES\n\n## Table of Contents\n- [NEVER Do This](#-never-do-this)\n- [ALWAYS Do This](#-always-do-this)\n- [Permission Hierarchy (Specific Overrides General)](#-permission-hierarchy-specific-overrides-general)\n- [Rule 1: NEVER Weaken Security for Test Convenience](#rule-1-never-weaken-security-for-test-convenience)\n- [Rule 2: Understanding Permission Hierarchy](#rule-2-understanding-permission-hierarchy)\n- [Rule 3: Adapt Tests to Security, Not Vice Versa](#rule-3-adapt-tests-to-security-not-vice-versa)\n- [Rule 4: Test with Least Privileged User](#rule-4-test-with-least-privileged-user)\n- [Rule 5: Create Appropriate Test Users](#rule-5-create-appropriate-test-users)\n- [Rule 6: Comprehensive Test Coverage](#rule-6-comprehensive-test-coverage)\n- [Quick Security Checklist](#quick-security-checklist)\n- [Security Decision Protocol](#security-decision-protocol)\n\n**Before you start ANY work, understand these NON-NEGOTIABLE rules.**\n\n---\n\n##  NEVER Do This\n\n1. **NEVER remove or weaken `@Restricted()` decorators** to make tests pass\n2. **NEVER change `@Roles()` decorators** to more permissive roles for test convenience\n3. **NEVER modify `securityCheck()` logic** to bypass security in tests\n4. **NEVER remove class-level `@Restricted(RoleEnum.ADMIN)`** - it's a security fallback\n\n---\n\n##  ALWAYS Do This\n\n1. **ALWAYS analyze permissions BEFORE writing tests** (Controller, Model, Service layers)\n2. **ALWAYS test with the LEAST privileged user** who is authorized\n3. **ALWAYS create appropriate test users** for each permission level\n4. **ALWAYS adapt tests to security requirements**, never the other way around\n5. **ALWAYS ask developer for approval** before changing ANY security decorator\n6. **ALWAYS aim for maximum test coverage** (80-100% depending on criticality)\n\n---\n\n## üîë Permission Hierarchy (Specific Overrides General)\n\n```typescript\n@Restricted(RoleEnum.ADMIN)  // ‚Üê FALLBACK: DO NOT REMOVE\nexport class ProductController {\n  @Roles(RoleEnum.S_USER)    // ‚Üê SPECIFIC: This method is more open\n  async createProduct() { }   // ‚Üê S_USER can access (specific wins)\n\n  async secretMethod() { }    // ‚Üê ADMIN only (fallback applies)\n}\n```\n\n**Why class-level `@Restricted(ADMIN)` MUST stay:**\n- If someone forgets `@Roles()` on a new method -> it's secure by default\n- Shows the class is security-sensitive\n- Fail-safe protection\n\n---\n\n## Rule 1: NEVER Weaken Security for Test Convenience\n\n###  ABSOLUTELY FORBIDDEN\n\n```typescript\n// BEFORE (secure):\n@Restricted(RoleEnum.ADMIN)\nexport class ProductController {\n  @Roles(RoleEnum.S_USER)\n  async createProduct() { ... }\n}\n\n// AFTER (FORBIDDEN - security weakened!):\n// @Restricted(RoleEnum.ADMIN)  ‚Üê NEVER remove this!\nexport class ProductController {\n  @Roles(RoleEnum.S_USER)\n  async createProduct() { ... }\n}\n```\n\n###  CRITICAL RULE\n\n- **NEVER remove or weaken `@Restricted()` decorators** on Controllers, Resolvers, Models, or Objects\n- **NEVER change `@Roles()` decorators** to more permissive roles just to make tests pass\n- **NEVER modify `securityCheck()` logic** to bypass security for testing\n\n### If tests fail due to permissions\n\n1.  **CORRECT**: Adjust the test to use the appropriate user/token\n2.  **CORRECT**: Create test users with the required roles\n3.  **WRONG**: Weaken security to make tests pass\n\n### Any security changes MUST\n\n- Be discussed with the developer FIRST\n- Have a solid business justification\n- Be explicitly approved by the developer\n- Be documented with the reason\n\n---\n\n## Rule 2: Understanding Permission Hierarchy\n\n### ‚≠ê Key Concept: Specific Overrides General\n\nThe `@Restricted()` decorator on a class acts as a **security fallback** - if a method/property doesn't specify permissions, it inherits the class-level restriction. This is a **security-by-default** pattern.\n\n### Example - Controller/Resolver\n\n```typescript\n@Restricted(RoleEnum.ADMIN)  // ‚Üê FALLBACK: Protects everything by default\nexport class ProductController {\n\n  @Roles(RoleEnum.S_EVERYONE)  // ‚Üê SPECIFIC: This method is MORE open\n  async getPublicProducts() {\n    // Anyone can access this (specific @Roles wins)\n  }\n\n  @Roles(RoleEnum.S_USER)  // ‚Üê SPECIFIC: Logged-in users\n  async createProduct() {\n    // S_USER can access (specific wins over fallback)\n  }\n\n  async deleteProduct() {\n    // ADMIN ONLY (no specific decorator, fallback applies)\n  }\n}\n```\n\n### Example - Model\n\n```typescript\n@Restricted(RoleEnum.ADMIN)  // ‚Üê FALLBACK\nexport class Product {\n\n  @Roles(RoleEnum.S_EVERYONE)  // ‚Üê SPECIFIC\n  @UnifiedField({ description: 'Product name' })\n  name: string;  // Everyone can read this\n\n  @UnifiedField({ description: 'Internal cost' })\n  cost: number;  // ADMIN ONLY (fallback applies)\n}\n```\n\n---\n\n## Rule 3: Adapt Tests to Security, Not Vice Versa\n\n###  WRONG Approach\n\n```typescript\n// Test fails because user isn't admin\nit('should create product', async () => {\n  const result = await request(app)\n    .post('/products')\n    .set('Authorization', regularUserToken)  // Not an admin!\n    .send(productData);\n\n  expect(result.status).toBe(201);  // Fails with 403\n});\n\n//  WRONG FIX: Removing @Restricted from controller\n// @Restricted(RoleEnum.ADMIN)  ‚Üê NEVER DO THIS!\n```\n\n###  CORRECT Approach\n\n```typescript\n// Analyze first: Who is allowed to create products?\n// Answer: ADMIN only (based on @Restricted on controller)\n\n// Create admin test user\nlet adminToken: string;\n\nbeforeAll(async () => {\n  const admin = await createTestUser({ roles: [RoleEnum.ADMIN] });\n  adminToken = admin.token;\n});\n\nit('should create product as admin', async () => {\n  const result = await request(app)\n    .post('/products')\n    .set('Authorization', adminToken)  //  Use admin token\n    .send(productData);\n\n  expect(result.status).toBe(201);  //  Passes\n});\n\nit('should reject product creation for regular user', async () => {\n  const result = await request(app)\n    .post('/products')\n    .set('Authorization', regularUserToken)\n    .send(productData);\n\n  expect(result.status).toBe(403);  //  Test security works!\n});\n```\n\n---\n\n## Rule 4: Test with Least Privileged User\n\n**Always test with the LEAST privileged user who is authorized to perform the action.**\n\n###  WRONG\n\n```typescript\n// Method allows S_USER, but testing with ADMIN\n@Roles(RoleEnum.S_USER)\nasync getProducts() { }\n\nit('should get products', async () => {\n  const result = await request(app)\n    .get('/products')\n    .set('Authorization', adminToken);  //  Over-privileged!\n});\n```\n\n###  CORRECT\n\n```typescript\n@Roles(RoleEnum.S_USER)\nasync getProducts() { }\n\nit('should get products as regular user', async () => {\n  const result = await request(app)\n    .get('/products')\n    .set('Authorization', regularUserToken);  //  Least privilege\n});\n```\n\n**Why this matters:**\n- Tests might pass with ADMIN but fail with S_USER\n- You won't catch permission bugs\n- False confidence in security\n\n---\n\n## Rule 5: Create Appropriate Test Users\n\n**Create test users for EACH permission level you need to test.**\n\n### Example Test Setup\n\n```typescript\ndescribe('ProductController', () => {\n  let adminToken: string;\n  let userToken: string;\n  let everyoneToken: string;\n\n  beforeAll(async () => {\n    // Create admin user\n    const admin = await createTestUser({\n      roles: [RoleEnum.ADMIN]\n    });\n    adminToken = admin.token;\n\n    // Create regular user\n    const user = await createTestUser({\n      roles: [RoleEnum.S_USER]\n    });\n    userToken = user.token;\n\n    // Create unauthenticated scenario\n    const guest = await createTestUser({\n      roles: [RoleEnum.S_EVERYONE]\n    });\n    everyoneToken = guest.token;\n  });\n\n  it('admin can delete products', async () => {\n    // Use adminToken\n  });\n\n  it('regular user can create products', async () => {\n    // Use userToken\n  });\n\n  it('everyone can view products', async () => {\n    // Use everyoneToken or no token\n  });\n\n  it('regular user cannot delete products', async () => {\n    // Use userToken, expect 403\n  });\n});\n```\n\n---\n\n## Rule 6: Comprehensive Test Coverage\n\n**Aim for 80-100% test coverage depending on criticality:**\n\n- **High criticality** (payments, user data, admin functions): 95-100%\n- **Medium criticality** (business logic, CRUD): 80-90%\n- **Low criticality** (utilities, formatters): 70-80%\n\n### What to Test\n\n**For each endpoint/method:**\n\n1.  Happy path (authorized user, valid data)\n2.  Permission denied (unauthorized user)\n3.  Validation errors (invalid input)\n4.  Edge cases (empty data, boundaries)\n5.  Error handling (server errors, missing resources)\n\n### Example Comprehensive Tests\n\n```typescript\ndescribe('createProduct', () => {\n  it('should create product with admin user', async () => {\n    // Happy path\n  });\n\n  it('should reject creation by regular user', async () => {\n    // Permission test\n  });\n\n  it('should reject invalid product data', async () => {\n    // Validation test\n  });\n\n  it('should reject duplicate product name', async () => {\n    // Business rule test\n  });\n\n  it('should handle missing required fields', async () => {\n    // Edge case\n  });\n});\n```\n\n---\n\n## Rule 7: Input Sanitization & XSS Prevention\n\n###  Always Sanitize User Input\n\n```typescript\n//  WRONG: Direct HTML rendering without sanitization\n@UnifiedField({ description: 'User bio (supports HTML)' })\nbio: string;  // Could contain <script> tags!\n\n//  CORRECT: Sanitize HTML input\nimport * as sanitizeHtml from 'sanitize-html';\n\n@UnifiedField({\n  description: 'User bio',\n  transform: (value: string) => sanitizeHtml(value, {\n    allowedTags: ['b', 'i', 'em', 'strong', 'p', 'br'],\n    allowedAttributes: {}\n  })\n})\nbio: string;\n```\n\n### URL Parameter Validation\n\n```typescript\n//  WRONG: Using URL parameters directly\n@Get(':id')\nasync findOne(@Param('id') id: string) {\n  return this.service.findById(id);  // No validation!\n}\n\n//  CORRECT: Validate with ParseUUIDPipe or custom validation\n@Get(':id')\nasync findOne(@Param('id', ParseUUIDPipe) id: string) {\n  return this.service.findById(id);\n}\n\n// Or custom validation\n@Get(':id')\nasync findOne(@Param('id') id: string) {\n  if (!Types.ObjectId.isValid(id)) {\n    throw new BadRequestException('Invalid ID format');\n  }\n  return this.service.findById(id);\n}\n```\n\n### Query Parameter Limits\n\n```typescript\n//  WRONG: No limits on pagination\n@Get()\nasync findAll(@Query('limit') limit: number) {\n  return this.service.find({}, { limit });  // User could request limit=1000000\n}\n\n//  CORRECT: Enforce limits\n@Get()\nasync findAll(@Query('limit', new DefaultValuePipe(20), ParseIntPipe) limit: number) {\n  const safeLimit = Math.min(Math.max(1, limit), 100);  // Clamp to 1-100\n  return this.service.find({}, { limit: safeLimit });\n}\n```\n\n---\n\n## Rule 8: File Upload Security\n\n###  Validate File Types (Magic Bytes, not just extension)\n\n```typescript\nimport * as fileType from 'file-type';\n\n//  WRONG: Trust file extension\nasync uploadFile(file: Express.Multer.File) {\n  if (!file.originalname.endsWith('.pdf')) {\n    throw new BadRequestException('Only PDF allowed');\n  }\n  // Attacker can rename malware.exe to malware.pdf!\n}\n\n//  CORRECT: Validate magic bytes\nasync uploadFile(file: Express.Multer.File) {\n  const type = await fileType.fromBuffer(file.buffer);\n\n  const ALLOWED_TYPES = ['application/pdf', 'image/jpeg', 'image/png'];\n  if (!type || !ALLOWED_TYPES.includes(type.mime)) {\n    throw new BadRequestException('Invalid file type');\n  }\n\n  // Also check file size\n  const MAX_SIZE = 5 * 1024 * 1024;  // 5MB\n  if (file.size > MAX_SIZE) {\n    throw new BadRequestException('File too large (max 5MB)');\n  }\n}\n```\n\n### Prevent Path Traversal\n\n```typescript\nimport * as path from 'path';\n\n//  WRONG: Use user-provided filename directly\nasync saveFile(file: Express.Multer.File) {\n  const filePath = path.join('/uploads', file.originalname);\n  // Attacker could use: ../../../etc/passwd\n}\n\n//  CORRECT: Sanitize filename and use random names\nasync saveFile(file: Express.Multer.File) {\n  // Option 1: Use only base name\n  const safeName = path.basename(file.originalname);\n\n  // Option 2: Generate random filename (recommended)\n  const ext = path.extname(file.originalname);\n  const randomName = `${randomUUID()}${ext}`;\n\n  const uploadDir = '/uploads';\n  const filePath = path.join(uploadDir, randomName);\n\n  // Verify path is within upload directory\n  if (!filePath.startsWith(uploadDir)) {\n    throw new BadRequestException('Invalid file path');\n  }\n}\n```\n\n### Serve Files Securely\n\n```typescript\n//  WRONG: Execute files or expose directory\napp.use('/uploads', express.static('uploads'));  // Could serve malicious HTML\n\n//  CORRECT: Set proper headers\napp.use('/uploads', express.static('uploads', {\n  setHeaders: (res, filePath) => {\n    res.setHeader('Content-Disposition', 'attachment');  // Force download\n    res.setHeader('X-Content-Type-Options', 'nosniff');\n    res.setHeader('Content-Type', 'application/octet-stream');\n  }\n}));\n```\n\n---\n\n## Rule 9: Communication Security\n\n### HTTPS & TLS Enforcement\n\n```typescript\n// main.ts - Production configuration\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n\n  // Redirect HTTP to HTTPS (via reverse proxy or middleware)\n  app.use((req, res, next) => {\n    if (req.headers['x-forwarded-proto'] !== 'https' && process.env.NODE_ENV === 'production') {\n      return res.redirect(301, `https://${req.headers.host}${req.url}`);\n    }\n    next();\n  });\n}\n```\n\n### Helmet Security Headers\n\n```typescript\nimport helmet from 'helmet';\n\n// main.ts\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      scriptSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      frameAncestors: [\"'none'\"],\n    },\n  },\n  hsts: {\n    maxAge: 31536000,  // 1 year\n    includeSubDomains: true,\n    preload: true\n  },\n  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }\n}));\n```\n\n### CORS Configuration\n\n```typescript\n//  WRONG: Allow all origins\napp.enableCors();  // Allows any origin!\n\n//  CORRECT: Restrict origins\napp.enableCors({\n  origin: [\n    'https://app.example.com',\n    'https://admin.example.com',\n  ],\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  credentials: true,\n  maxAge: 86400,  // Cache preflight for 24 hours\n});\n\n// Or dynamic origin validation\napp.enableCors({\n  origin: (origin, callback) => {\n    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];\n    if (!origin || allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  }\n});\n```\n\n### Rate Limiting\n\n```typescript\nimport { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';\n\n@Module({\n  imports: [\n    ThrottlerModule.forRoot({\n      ttl: 60,      // Time window in seconds\n      limit: 100,   // Max requests per window\n    }),\n  ],\n})\nexport class AppModule {}\n\n// Apply globally\n@UseGuards(ThrottlerGuard)\n@Controller('api')\nexport class ApiController {}\n\n// Or per-endpoint with different limits\n@Throttle(5, 60)  // 5 requests per 60 seconds\n@Post('auth/login')\nasync login() {}\n\n@Throttle(3, 3600)  // 3 requests per hour\n@Post('auth/forgot-password')\nasync forgotPassword() {}\n```\n\n---\n\n## Quick Security Checklist\n\nBefore completing ANY task:\n\n**Authorization & Access Control:**\n- [ ] **All @Restricted decorators preserved**\n- [ ] **@Roles decorators NOT made more permissive**\n- [ ] **Tests use appropriate user roles**\n- [ ] **Test users created for each permission level**\n- [ ] **Least privileged user tested**\n- [ ] **Permission denial tested (403 responses)**\n- [ ] **No securityCheck() logic bypassed**\n\n**Input & Validation:**\n- [ ] **All inputs validated and sanitized**\n- [ ] **URL parameters validated (UUIDs, ObjectIds)**\n- [ ] **Query limits enforced (pagination)**\n- [ ] **HTML content sanitized**\n\n**File Uploads:**\n- [ ] **File types validated via magic bytes**\n- [ ] **File size limits enforced**\n- [ ] **Filenames sanitized (no path traversal)**\n- [ ] **Files served with safe headers**\n\n**Communication:**\n- [ ] **HTTPS enforced in production**\n- [ ] **Helmet security headers configured**\n- [ ] **CORS restricted to allowed origins**\n- [ ] **Rate limiting on sensitive endpoints**\n\n**Testing:**\n- [ ] **Test coverage ‚â• 80%**\n- [ ] **All edge cases covered**\n\n---\n\n## Security Decision Protocol\n\n**When you encounter a security-related decision:**\n\n1. **STOP** - Don't make the change immediately\n2. **ANALYZE** - Why does the current security exist?\n3. **ASK** - Consult the developer before changing\n4. **DOCUMENT** - If approved, document the reason\n5. **TEST** - Ensure security still works after change\n\n**Remember:**\n- **Security > Convenience**\n- **Better to over-restrict than under-restrict**\n- **Always preserve existing security mechanisms**\n- **When in doubt, ask the developer**\n",
        "plugins/lt-dev/skills/generating-nest-servers/verification-checklist.md": "---\nname: nest-server-generator-verification\ndescription: Comprehensive verification checklist for generated NestJS modules and objects - covers code generation, descriptions, API tests with security-first approach, test coverage requirements, and security rules compliance\n---\n\n# Verification Checklist\n\n## Table of Contents\n- [Code Generation](#code-generation)\n- [API Tests - Security First](#api-tests---security-first)\n- [Test Coverage - Comprehensive Testing](#test-coverage---comprehensive-testing)\n- [Security Rules Compliance](#security-rules-compliance)\n- [Test Organization Structure](#test-organization-structure)\n- [Quick Verification Workflow](#quick-verification-workflow)\n- [Common Verification Failures](#common-verification-failures)\n- [Success Criteria](#success-criteria)\n\nAfter generation, verify all items in this comprehensive checklist:\n\n## Code Generation\n\n- [ ] All SubObjects created\n- [ ] All Objects created\n- [ ] All Modules created\n- [ ] All properties in alphabetical order\n- [ ] **DESCRIPTIONS (Critical - check thoroughly):**\n  - [ ] All user-provided comments (after `//`) extracted from specification\n  - [ ] All German descriptions translated to format: `ENGLISH (DEUTSCH)`\n  - [ ] All English descriptions kept as-is (spelling corrected)\n  - [ ] ALL Module Models have descriptions on all properties\n  - [ ] ALL Module CreateInputs have SAME descriptions\n  - [ ] ALL Module UpdateInputs have SAME descriptions\n  - [ ] ALL SubObjects have descriptions on all properties\n  - [ ] ALL SubObject CreateInputs have SAME descriptions\n  - [ ] ALL SubObject UpdateInputs have SAME descriptions\n  - [ ] ALL `@ObjectType()` decorators have descriptions\n  - [ ] ALL `@InputType()` decorators have descriptions\n  - [ ] NO inconsistencies (same property, different descriptions in different files)\n  - [ ] NO German-only descriptions (must be translated)\n- [ ] Inheritance properly implemented\n- [ ] Required fields correctly set in CreateInputs\n- [ ] Enum files created in `src/server/common/enums/`\n\n---\n\n## API Tests - Security First\n\n** CRITICAL: Security analysis MUST be completed BEFORE writing ANY test!**\n\n### Permission Analysis (BEFORE Writing Tests)\n- [ ] **Permission analysis completed BEFORE writing tests**\n- [ ] **Analyzed ALL `@Roles()` decorators in controllers/resolvers**\n- [ ] **Read complete `securityCheck()` method in models**\n- [ ] **Understood permission hierarchy (specific overrides general)**\n\n### Test User Matrix (Principle of Least Privilege)\n- [ ] **Tests use LEAST privileged user (never admin when less works)**\n- [ ] **S_EVERYONE endpoints tested WITHOUT token**\n- [ ] **S_USER endpoints tested with REGULAR user (not admin)**\n- [ ] **UPDATE/DELETE tested with CREATOR token (not admin)**\n\n### Security Validation Tests (MANDATORY)\n- [ ] **Tests verify unauthorized access FAILS (401/403)**\n- [ ] **Tests verify non-creators CANNOT update/delete**\n- [ ] **Tests verify required fields**\n- [ ] **Security validation tests exist (permission failures)**\n\n### General Test Requirements\n- [ ] API tests created for all modules\n- [ ] Tests cover all CRUD operations\n- [ ] All tests pass\n- [ ] No TypeScript errors\n- [ ] Lint passes\n\n---\n\n## Test Coverage - Comprehensive Testing\n\n** GOAL: Achieve the HIGHEST possible test coverage**\n\n### Functional Coverage\n- [ ] **Every endpoint has at least one successful test**\n- [ ] **Every endpoint has at least one failure test (unauthorized/validation)**\n- [ ] **All query parameters tested (filters, sorting, pagination)**\n- [ ] **All validation rules tested (required fields, min/max, patterns)**\n- [ ] **All relationships tested (creating/updating/deleting with references)**\n- [ ] **Edge cases tested (empty results, non-existent IDs, duplicate values)**\n- [ ] **Error handling tested (400, 401, 403, 404, 409 status codes)**\n- [ ] **Data integrity tested (cascading deletes, orphan prevention)**\n- [ ] **Business logic tested (custom methods, computed properties)**\n- [ ] **Performance tested (large datasets, pagination limits)**\n\n### Coverage Requirements\n- Minimum 80% line coverage for services\n- Minimum 90% line coverage for resolvers/controllers\n- 100% coverage for critical security logic (securityCheck, permission guards)\n- 100% coverage for all endpoints (success AND failure cases)\n- 100% coverage for all permission combinations\n- All public methods tested\n- All error paths tested\n\n---\n\n## Security Rules Compliance\n\n** CRITICAL: These MUST be checked before completing**\n\n### Security Decorator Rules\n- [ ] **NO `@Restricted()` decorators removed from Controllers/Resolvers/Models/Objects**\n- [ ] **NO `@Roles()` decorators weakened to make tests pass**\n- [ ] **NO `securityCheck()` logic modified to bypass security**\n- [ ] **Class-level `@Restricted(ADMIN)` kept as security fallback**\n\n### Security Change Management\n- [ ] **All security changes discussed and approved by developer**\n- [ ] **All security changes documented with approval and reason**\n- [ ] **Tests adapted to security requirements (not vice versa)**\n\n### Test User Management\n- [ ] **Appropriate test users created for each permission level**\n- [ ] **Permission hierarchy understood and respected (specific overrides general)**\n\n---\n\n## Test Organization Structure\n\nUse this structure for comprehensive, organized tests:\n\n```typescript\ndescribe('ProductResolver', () => {\n  // Setup\n  describe('Setup', () => {\n    beforeAll(async () => {\n      // Initialize test environment\n      // Create test users with different roles\n    });\n\n    afterAll(async () => {\n      // Cleanup all test data\n    });\n  });\n\n  // Happy path tests\n  describe('CREATE operations', () => {\n    it('should create product as regular user', ...);\n    it('should create product with all optional fields', ...);\n    it('should create product with relationships', ...);\n  });\n\n  describe('READ operations', () => {\n    it('should get product by ID', ...);\n    it('should list all products with pagination', ...);\n    it('should filter products by criteria', ...);\n    it('should sort products by field', ...);\n  });\n\n  describe('UPDATE operations', () => {\n    it('should update product as creator', ...);\n    it('should update product as admin', ...);\n    it('should update with partial data', ...);\n  });\n\n  describe('DELETE operations', () => {\n    it('should delete product as creator', ...);\n    it('should delete product as admin', ...);\n    it('should handle cascading deletes', ...);\n  });\n\n  // Security tests (MANDATORY)\n  describe('Security Validation', () => {\n    it('should FAIL to create without auth', ...);\n    it('should FAIL to update as non-creator', ...);\n    it('should FAIL to delete as non-creator', ...);\n    it('should FAIL to access with invalid token', ...);\n    it('should FAIL to read private data as different user', ...);\n  });\n\n  // Validation tests\n  describe('Input Validation', () => {\n    it('should FAIL with missing required fields', ...);\n    it('should FAIL with invalid field values', ...);\n    it('should FAIL with duplicate values', ...);\n    it('should FAIL with invalid references', ...);\n  });\n\n  // Edge cases\n  describe('Edge Cases', () => {\n    it('should handle non-existent ID (404)', ...);\n    it('should handle empty list results', ...);\n    it('should handle concurrent updates', ...);\n    it('should handle circular references', ...);\n  });\n});\n```\n\n---\n\n## Quick Verification Workflow\n\n1. **Code Generation:**\n   - Run through all Code Generation checkboxes\n   - Pay special attention to DESCRIPTIONS - most common error!\n\n2. **API Tests - Security First:**\n   - Complete Permission Analysis BEFORE writing tests\n   - Create appropriate test users\n   - Write security validation tests FIRST\n   - Then write functional tests\n\n3. **Test Coverage:**\n   - Review coverage report\n   - Add tests for any uncovered code\n   - Aim for 90%+ overall coverage\n\n4. **Security Rules:**\n   - Double-check no decorators were removed\n   - Verify all security changes documented\n   - Confirm tests adapted to security (not vice versa)\n\n5. **Final Validation:**\n   - Run all tests: `npm test`\n   - Check TypeScript: `npm run build`\n   - Run linter: `npm run lint`\n\n---\n\n## Common Verification Failures\n\n###  Missing Descriptions\n**Problem:** Forgot to add descriptions to CreateInput or UpdateInput\n**Fix:** Add SAME description from Model to ALL Input files\n\n###  Wrong Test Privileges\n**Problem:** Using admin token when S_USER would work\n**Fix:** Review @Roles decorator, use least privileged user\n\n###  Missing Security Tests\n**Problem:** No tests for unauthorized access\n**Fix:** Add describe('Security Validation') block with 401/403 tests\n\n###  Inconsistent Descriptions\n**Problem:** Different descriptions for same property in different files\n**Fix:** Standardize to one description across Model + CreateInput + UpdateInput\n\n###  Security Decorator Removed\n**Problem:** Removed @Restricted to make test pass\n**Fix:** Keep decorator, fix test to use proper authentication\n\n---\n\n## Success Criteria\n\n **All checkboxes checked**\n **All tests pass**\n **No TypeScript errors**\n **Lint passes**\n **Coverage > 90%**\n **Security rules maintained**\n **Descriptions consistent**\n\n**When all criteria met -> Generation complete! **\n",
        "plugins/lt-dev/skills/generating-nest-servers/workflow-process.md": "---\nname: nest-server-generator-workflow\ndescription: Complete 7-phase workflow for NestJS module/object generation - from analysis to testing, including SubObject creation, inheritance handling, description management, enum files, and comprehensive API testing with security validation\n---\n\n# Workflow Process\n\n## Table of Contents\n- [Phase 1: Analysis & Planning](#phase-1-analysis--planning)\n- [Phase 2: SubObject Creation](#phase-2-subobject-creation)\n- [Phase 3: Module Creation](#phase-3-module-creation)\n- [Phase 4: Inheritance Handling](#phase-4-inheritance-handling)\n- [Phase 5: Description Management](#phase-5-description-management)\n- [Phase 6: Enum File Creation](#phase-6-enum-file-creation)\n- [Phase 7: API Test Creation](#phase-7-api-test-creation)\n\n### Phase 1: Analysis & Planning\n\n1. **Parse the specification** completely\n2. **Identify all components**:\n   - List all SubObjects\n   - List all Objects\n   - List all Modules\n   - Identify inheritance relationships\n   - Identify enum types needed\n3. **Create comprehensive todo list** with:\n   - Create each SubObject\n   - Create each Object\n   - Create each Module\n   - Handle inheritance modifications\n   - Create enum files\n   - Create API tests for each module\n   - Run tests and verify\n\n**Phase 1 Checklist:**\n- [ ] Specification completely parsed\n- [ ] All components identified (SubObjects, Objects, Modules)\n- [ ] Inheritance relationships documented\n- [ ] Enum types listed\n- [ ] Comprehensive todo list created\n- [ ] Ready for Phase 2\n\n### Phase 2: SubObject Creation\n\n**Create SubObjects in dependency order** (if SubObject A contains SubObject B, create B first):\n\n```bash\nlt server object --name <ObjectName> \\\n  --prop-name-0 <name> --prop-type-0 <type> \\\n  --prop-name-1 <name> --prop-type-1 <type> \\\n  ...\n```\n\n**Apply modifiers**:\n- Optional: `--prop-nullable-X true`\n- Array: `--prop-array-X true`\n- Enum: `--prop-enum-X <EnumName>`\n- Schema: `--prop-schema-X <SchemaName>`\n\n**Phase 2 Checklist:**\n- [ ] All SubObjects created in correct dependency order\n- [ ] All modifiers applied (nullable, array, enum, schema)\n- [ ] Properties in alphabetical order\n- [ ] No circular dependencies\n- [ ] Ready for Phase 3\n\n### Phase 3: Module Creation\n\n**Create modules with all properties**:\n\n```bash\nlt server module --name <ModuleName> --controller <Rest|GraphQL|Both> \\\n  --prop-name-0 <name> --prop-type-0 <type> \\\n  --prop-name-1 <name> --prop-type-1 <type> \\\n  ...\n```\n\n**For references to other modules**:\n```bash\n--prop-name-X author --prop-type-X ObjectId --prop-reference-X User\n```\n\n**For embedded objects**:\n```bash\n--prop-name-X address --prop-schema-X Address\n```\n\n**Phase 3 Checklist:**\n- [ ] All modules created with correct properties\n- [ ] References correctly set (ObjectId with --prop-reference-X)\n- [ ] Embedded objects correctly referenced (--prop-schema-X)\n- [ ] Properties in alphabetical order\n- [ ] All required imports present\n- [ ] Ready for Phase 4\n\n### Phase 4: Inheritance Handling\n\nWhen a model extends another model (e.g., `Extends: Profile`):\n\n1. **Identify parent model location**:\n   - Core models (from @lenne.tech/nest-server): CoreModel, CorePersisted, etc.\n   - Custom parent models: Need to find in project\n\n2. **For Core parent models**:\n   - Replace in model file: `extends CoreModel` -> `extends ParentModel`\n   - Import: `import { ParentModel } from './path'`\n\n3. **For custom parent models (objects/other modules)**:\n   - Model extends parent object: Import and extend\n   - Input files must include parent properties\n\n4. **Input/Output inheritance**:\n   - **CreateInput**: Must include ALL required properties from parent AND model\n   - **UpdateInput**: Include all properties as optional\n   - Check parent's CreateInput for required fields\n   - Copy required fields to child's CreateInput\n\n**Example**: If `BuyerProfile` extends `Profile`:\n```typescript\n// buyer-profile.model.ts\nimport { Profile } from '../../common/objects/profile/profile.object';\nexport class BuyerProfile extends Profile { ... }\n\n// buyer-profile-create.input.ts\n// Must include ALL required fields from Profile's create input + BuyerProfile fields\n```\n\n**Phase 4 Checklist:**\n- [ ] All parent models identified (Core or custom)\n- [ ] Model extends correct parent class\n- [ ] Imports updated correctly\n- [ ] CreateInput includes ALL parent required fields\n- [ ] UpdateInput includes all properties as optional\n- [ ] No missing required fields\n- [ ] Ready for Phase 5\n\n### Phase 5: Description Management\n\n** CRITICAL PHASE - Refer to \"CRITICAL: DESCRIPTION MANAGEMENT\" section at the top of this document!**\n\nThis phase is often done incorrectly. Follow these steps EXACTLY:\n\n#### Step 5.1: Extract Descriptions from User Input\n\n**BEFORE applying any descriptions, review the original specification:**\n\nGo back to the user's original specification and extract ALL comments that appear after `//`:\n\n```\nModule: Product\n- name: string // Product name\n- price: number // Produktpreis\n- description?: string // Produktbeschreibung\n- stock: number // Current inventory\n\nSubObject: Address\n- street: string // Stra√üe\n- city: string // City name\n- zipCode: string // Postleitzahl\n```\n\n**Create a mapping**:\n```\nProduct.name -> \"Product name\" (English)\nProduct.price -> \"Produktpreis\" (German)\nProduct.description -> \"Produktbeschreibung\" (German)\nProduct.stock -> \"Current inventory\" (English)\nAddress.street -> \"Stra√üe\" (German)\nAddress.city -> \"City name\" (English)\nAddress.zipCode -> \"Postleitzahl\" (German)\n```\n\n#### Step 5.2: Format Descriptions\n\n**Rule**: `\"ENGLISH_DESCRIPTION (DEUTSCHE_BESCHREIBUNG)\"`\n\nApply formatting rules:\n\n1. **If comment is in English**:\n   ```\n   // Product name\n   ```\n   -> Use as: `description: 'Product name'`\n\n   Fix typos if needed:\n   ```\n   // Prodcut name  (typo)\n   ```\n   -> Use as: `description: 'Product name'` (typo corrected)\n\n2. **If comment is in German**:\n   ```\n   // Produktpreis\n   ```\n   -> Translate and add original: `description: 'Product price (Produktpreis)'`\n\n   ```\n   // Stra√üe\n   ```\n   -> Translate and add original: `description: 'Street (Stra√üe)'`\n\n   Fix typos in original:\n   ```\n   // Postleizahl  (typo: missing 't')\n   ```\n   -> Translate and add corrected: `description: 'Postal code (Postleitzahl)'`\n\n3. **If no comment provided**:\n   -> Create meaningful English description: `description: 'User email address'`\n\n** CRITICAL - Preserve Original Wording**:\n\n-  **DO:** Fix spelling/typos only\n-  **DON'T:** Rephrase, expand, or improve wording\n-  **DON'T:** Change terms (they may be predefined/referenced by external systems)\n\n**Examples**:\n```\n CORRECT:\n// Stra√üe -> 'Street (Stra√üe)'  (preserve word)\n// Produkt -> 'Product (Produkt)'  (don't add \"name\")\n// Status -> 'Status (Status)'  (same in both languages)\n\n WRONG:\n// Stra√üe -> 'Street name (Stra√üenname)'  (changed word!)\n// Produkt -> 'Product name (Produktname)'  (added word!)\n// Status -> 'Current status (Aktueller Status)'  (added word!)\n```\n\n#### Step 5.3: Apply Descriptions EVERYWHERE\n\n** MOST IMPORTANT: Apply SAME description to ALL files!**\n\nFor **EVERY property in EVERY Module**:\n\n1. Open `<module>.model.ts` -> Add description to property\n2. Open `inputs/<module>-create.input.ts` -> Add SAME description to property\n3. Open `inputs/<module>.input.ts` -> Add SAME description to property\n\nFor **EVERY property in EVERY SubObject**:\n\n1. Open `objects/<object>/<object>.object.ts` -> Add description to property\n2. Open `objects/<object>/<object>-create.input.ts` -> Add SAME description to property\n3. Open `objects/<object>/<object>.input.ts` -> Add SAME description to property\n\n**Example for Module \"Product\" with property \"price\"**:\n\n```typescript\n// File: src/server/modules/product/product.model.ts\n@UnifiedField({ description: 'Product price (Produktpreis)' })\nprice: number;\n\n// File: src/server/modules/product/inputs/product-create.input.ts\n@UnifiedField({ description: 'Product price (Produktpreis)' })\nprice: number;\n\n// File: src/server/modules/product/inputs/product.input.ts\n@UnifiedField({ description: 'Product price (Produktpreis)' })\nprice?: number;\n```\n\n**Example for SubObject \"Address\" with property \"street\"**:\n\n```typescript\n// File: src/server/common/objects/address/address.object.ts\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet: string;\n\n// File: src/server/common/objects/address/address-create.input.ts\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet: string;\n\n// File: src/server/common/objects/address/address.input.ts\n@UnifiedField({ description: 'Street (Stra√üe)' })\nstreet?: string;\n```\n\n#### Step 5.4: Add Class-Level Descriptions\n\nAlso add descriptions to the `@ObjectType()` and `@InputType()` decorators:\n\n```typescript\n@ObjectType({ description: 'Product entity (Produkt-Entit√§t)' })\nexport class Product extends CoreModel { ... }\n\n@InputType({ description: 'Product creation data (Produkt-Erstellungsdaten)' })\nexport class ProductCreateInput { ... }\n\n@InputType({ description: 'Product update data (Produkt-Aktualisierungsdaten)' })\nexport class ProductInput { ... }\n```\n\n#### Step 5.5: Verify Consistency\n\nAfter applying all descriptions, verify:\n\n- [ ] All user-provided comments extracted and processed\n- [ ] All German descriptions translated to format: `ENGLISH (DEUTSCH)`\n- [ ] All English descriptions kept as-is\n- [ ] Module Model has descriptions on all properties\n- [ ] Module CreateInput has SAME descriptions on all properties\n- [ ] Module UpdateInput has SAME descriptions on all properties\n- [ ] SubObject has descriptions on all properties\n- [ ] SubObject CreateInput has SAME descriptions on all properties\n- [ ] SubObject UpdateInput has SAME descriptions on all properties\n- [ ] Class-level decorators have descriptions\n- [ ] NO inconsistencies (same property, different descriptions)\n\n**If ANY checkbox is unchecked, STOP and fix before continuing to Phase 6!**\n\n**Phase 5 Checklist:**\n- [ ] All user-provided comments extracted and processed\n- [ ] All German descriptions translated to format: ENGLISH (DEUTSCH)\n- [ ] All English descriptions kept as-is (typos fixed only)\n- [ ] Descriptions applied to ALL Model properties\n- [ ] Descriptions applied to ALL CreateInput properties\n- [ ] Descriptions applied to ALL UpdateInput properties\n- [ ] Descriptions applied to ALL SubObject properties\n- [ ] Class-level decorators have descriptions\n- [ ] NO inconsistencies (same property different descriptions)\n- [ ] Ready for Phase 6\n\n### Phase 6: Enum File Creation\n\nFor each enum used, create enum file manually:\n\n```typescript\n// src/server/common/enums/status.enum.ts\nexport enum StatusEnum {\n  PENDING = 'PENDING',\n  ACTIVE = 'ACTIVE',\n  COMPLETED = 'COMPLETED',\n}\n```\n\n**Naming convention**:\n- File: `kebab-case.enum.ts`\n- Enum: `PascalCaseEnum`\n- Values: `UPPER_SNAKE_CASE`\n\n**Phase 6 Checklist:**\n- [ ] All enum files created in src/server/common/enums/\n- [ ] File naming follows kebab-case.enum.ts\n- [ ] Enum naming follows PascalCaseEnum\n- [ ] Values follow UPPER_SNAKE_CASE\n- [ ] All enums properly imported where used\n- [ ] Ready for Phase 7\n\n### Phase 7: API Test Creation\n\n** CRITICAL: Test Type Requirement**\n\n**ONLY create API tests using TestHelper - NEVER create direct Service tests!**\n\n-  **DO:** Create tests that call REST endpoints or GraphQL queries/mutations using `TestHelper`\n-  **DO:** Test through the API layer (Controller/Resolver -> Service -> Database)\n-  **DON'T:** Create tests that directly instantiate or call Service methods\n-  **DON'T:** Create unit tests for Services (e.g., `user.service.spec.ts`)\n-  **DON'T:** Mock dependencies or bypass the API layer\n\n**Why API tests only?**\n- API tests validate the complete security model (decorators, guards, permissions)\n- Direct Service tests bypass authentication and authorization checks\n- TestHelper provides all necessary tools for comprehensive API testing\n\n**Exception: Direct database/service access for test setup/cleanup ONLY**\n\nDirect database or service access is ONLY allowed for:\n\n-  **Test Setup (beforeAll/beforeEach)**:\n  - Setting user roles in database: `await db.collection('users').updateOne({ _id: userId }, { $set: { roles: ['admin'] } })`\n  - Setting verified flag: `await db.collection('users').updateOne({ _id: userId }, { $set: { verified: true } })`\n  - Creating prerequisite test data that can't be created via API\n\n-  **Test Cleanup (afterAll/afterEach)**:\n  - Deleting test objects: `await db.collection('products').deleteMany({ createdBy: testUserId })`\n  - Cleaning up test data: `await db.collection('users').deleteOne({ email: 'test@example.com' })`\n\n-  **NEVER for testing functionality**:\n  - Don't call `userService.create()` to test user creation - use API endpoint!\n  - Don't call `productService.update()` to test updates - use API endpoint!\n  - Don't access database to verify results - query via API instead!\n\n**Example of correct usage:**\n\n```typescript\ndescribe('Product Tests', () => {\n  let adminToken: string;\n  let userId: string;\n\n  beforeAll(async () => {\n    //  ALLOWED: Direct DB access for setup\n    const user = await testHelper.rest('/auth/signup', {\n      method: 'POST',\n      payload: { email: 'admin@test.com', password: 'password' }\n    });\n    userId = user.id;\n\n    //  ALLOWED: Direct DB manipulation for test setup\n    await db.collection('users').updateOne(\n      { _id: new ObjectId(userId) },\n      { $set: { roles: ['admin'], verified: true } }\n    );\n\n    // Get token via API\n    const auth = await testHelper.rest('/auth/signin', {\n      method: 'POST',\n      payload: { email: 'admin@test.com', password: 'password' }\n    });\n    adminToken = auth.token;\n  });\n\n  it('should create product', async () => {\n    //  CORRECT: Test via API\n    const result = await testHelper.rest('/api/products', {\n      method: 'POST',\n      payload: { name: 'Test Product' },\n      token: adminToken\n    });\n\n    expect(result.name).toBe('Test Product');\n\n    //  WRONG: Don't verify via DB\n    // const dbProduct = await db.collection('products').findOne({ _id: result.id });\n\n    //  CORRECT: Verify via API\n    const fetched = await testHelper.rest(`/api/products/${result.id}`, {\n      method: 'GET',\n      token: adminToken\n    });\n    expect(fetched.name).toBe('Test Product');\n  });\n\n  afterAll(async () => {\n    //  ALLOWED: Direct DB access for cleanup\n    await db.collection('products').deleteMany({ createdBy: userId });\n    await db.collection('users').deleteOne({ _id: new ObjectId(userId) });\n  });\n});\n```\n\n---\n\n** CRITICAL: Test Creation Process**\n\nCreating API tests is NOT just about testing functionality - it's about **validating the security model**. You MUST follow this exact process:\n\n---\n\n#### Step 1:  MANDATORY Permission Analysis (BEFORE writing ANY test)\n\n**YOU MUST analyze these THREE layers BEFORE writing a single test:**\n\n1. **Controller/Resolver Layer** - Check `@Roles()` decorator:\n   ```typescript\n   // In product.resolver.ts\n   @Roles(RoleEnum.S_EVERYONE)  // ‚Üê WHO can call this?\n   @Query(() => [Product])\n   async getProducts() { ... }\n\n   @Roles(RoleEnum.S_USER)      // ‚Üê All signed-in users\n   @Mutation(() => Product)\n   async createProduct(@Args('input') input: ProductCreateInput) { ... }\n\n   @Roles(RoleEnum.ADMIN, RoleEnum.S_CREATOR)  // ‚Üê Only admin or creator\n   @Mutation(() => Product)\n   async updateProduct(@Args('id') id: string, @Args('input') input: ProductInput) { ... }\n   ```\n\n2. **Model Layer** - Check `@Restricted()` and `securityCheck()`:\n   ```typescript\n   // In product.model.ts\n   export class Product extends CoreModel {\n     securityCheck(user: User, force?: boolean) {\n       if (force || user?.hasRole(RoleEnum.ADMIN)) {\n         return this; // Admin sees all\n       }\n       if (this.isPublic) {\n         return this; // Everyone sees public products\n       }\n       if (!equalIds(user, this.createdBy)) {\n         return undefined; // Non-creator gets nothing\n       }\n       return this; // Creator sees own products\n     }\n   }\n   ```\n\n3. **Service Layer** - Check `serviceOptions.roles` usage:\n   ```typescript\n   // In product.service.ts\n   async update(id: string, input: ProductInput, serviceOptions?: ServiceOptions) {\n     // Check if user has ADMIN or S_CREATOR role\n     // ...\n   }\n   ```\n\n**Permission Analysis Checklist:**\n- [ ] I have checked ALL `@Roles()` decorators in controller/resolver\n- [ ] I have read the complete `securityCheck()` method in the model\n- [ ] I have checked ALL `@Restricted()` decorators\n- [ ] I understand WHO can CREATE (usually S_USER or ADMIN)\n- [ ] I understand WHO can READ (S_USER + securityCheck filtering)\n- [ ] I understand WHO can UPDATE (usually ADMIN + S_CREATOR)\n- [ ] I understand WHO can DELETE (usually ADMIN + S_CREATOR)\n\n**Common Permission Patterns:**\n- `S_EVERYONE` -> No authentication required\n- `S_USER` -> Any signed-in user\n- `ADMIN` -> User with 'admin' role\n- `S_CREATOR` -> User who created the resource (user.id === object.createdBy)\n\n---\n\n#### Step 2:  Apply Principle of Least Privilege\n\n**GOLDEN RULE**: Always test with the **LEAST privileged user** who is still authorized.\n\n**Decision Tree:**\n\n```\nIs endpoint marked with @Roles(RoleEnum.S_EVERYONE)?\n‚îú‚îÄ YES -> Test WITHOUT token (unauthenticated)\n‚îî‚îÄ NO  -> Is endpoint marked with @Roles(RoleEnum.S_USER)?\n         ‚îú‚îÄ YES -> Test WITH regular user token (NOT admin, NOT creator)\n         ‚îî‚îÄ NO  -> Is endpoint marked with @Roles(RoleEnum.ADMIN, RoleEnum.S_CREATOR)?\n                  ‚îú‚îÄ For UPDATE/DELETE -> Test WITH creator token (user who created it)\n                  ‚îî‚îÄ For ADMIN-only -> Test WITH admin token\n```\n\n** WRONG Approach:**\n```typescript\n// BAD: Using admin for everything\nit('should create product', async () => {\n  const result = await testHelper.graphQl({\n    name: 'createProduct',\n    type: TestGraphQLType.MUTATION,\n    arguments: { input: { name: 'Test' } },\n    fields: ['id']\n  }, { token: adminToken }); //  WRONG - Over-privileged!\n});\n```\n\n** CORRECT Approach:**\n```typescript\n// GOOD: Using least privileged user\nit('should create product as regular user', async () => {\n  const result = await testHelper.graphQl({\n    name: 'createProduct',\n    type: TestGraphQLType.MUTATION,\n    arguments: { input: { name: 'Test' } },\n    fields: ['id']\n  }, { token: userToken }); //  CORRECT - S_USER is enough!\n});\n```\n\n---\n\n#### Step 3:  Create Test User Matrix\n\nBased on your permission analysis, create test users:\n\n```typescript\ndescribe('Product API', () => {\n  let testHelper: TestHelper;\n\n  // Create users based on ACTUAL needs (not all of them!)\n  let noToken: undefined;           // For S_EVERYONE endpoints\n  let userToken: string;            // For S_USER endpoints\n  let creatorToken: string;         // For S_CREATOR (will create test data)\n  let otherUserToken: string;       // For testing \"not creator\" scenarios\n  let adminToken: string;           // Only if ADMIN-specific endpoints exist\n\n  let createdProductId: string;\n\n  beforeAll(async () => {\n    testHelper = new TestHelper(app);\n\n    // Only create users you ACTUALLY need based on @Roles() analysis!\n\n    // Regular user (for S_USER endpoints)\n    const userAuth = await testHelper.graphQl({\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        input: {\n          email: 'user@test.com',\n          password: 'password',\n          roles: ['user']  // Regular user, no special privileges\n        }\n      },\n      fields: ['token', 'user { id }']\n    });\n    userToken = userAuth.token;\n\n    // Creator user (will create test objects)\n    const creatorAuth = await testHelper.graphQl({\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        input: {\n          email: 'creator@test.com',\n          password: 'password',\n          roles: ['user']\n        }\n      },\n      fields: ['token', 'user { id }']\n    });\n    creatorToken = creatorAuth.token;\n\n    // Other user (to test \"not creator\" scenarios)\n    const otherUserAuth = await testHelper.graphQl({\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        input: {\n          email: 'other@test.com',\n          password: 'password',\n          roles: ['user']\n        }\n      },\n      fields: ['token', 'user { id }']\n    });\n    otherUserToken = otherUserAuth.token;\n\n    // Admin user (ONLY if truly needed!)\n    const adminAuth = await testHelper.graphQl({\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        input: {\n          email: 'admin@test.com',\n          password: 'password',\n          roles: ['admin', 'user']  // ‚Üê 'admin' role!\n        }\n      },\n      fields: ['token']\n    });\n    adminToken = adminAuth.token;\n  });\n\n  afterAll(async () => {\n    // Clean up with appropriate privileged user\n    if (createdProductId) {\n      // Use creator or admin token for cleanup\n      await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: createdProductId },\n        fields: ['id']\n      }, { token: creatorToken });\n    }\n  });\n});\n```\n\n---\n\n#### Step 4:  Write Tests with Correct Privileges\n\n**Example 1: S_EVERYONE endpoint (public access)**\n\n```typescript\n// Endpoint: @Roles(RoleEnum.S_EVERYONE)\ndescribe('Public Endpoints', () => {\n  it('should get public products WITHOUT token', async () => {\n    const result = await testHelper.graphQl({\n      name: 'getPublicProducts',\n      type: TestGraphQLType.QUERY,\n      fields: ['id', 'name', 'price']\n    }); // ‚Üê NO TOKEN! S_EVERYONE means unauthenticated is OK\n\n    expect(result).toBeDefined();\n    expect(Array.isArray(result)).toBe(true);\n  });\n});\n```\n\n**Example 2: S_USER endpoint (any authenticated user)**\n\n```typescript\n// Endpoint: @Roles(RoleEnum.S_USER)\ndescribe('Create Product', () => {\n  it('should create product as regular user', async () => {\n    const result = await testHelper.graphQl({\n      name: 'createProduct',\n      type: TestGraphQLType.MUTATION,\n      arguments: { input: { name: 'Test Product', price: 10 } },\n      fields: ['id', 'name', 'price', 'createdBy']\n    }, { token: userToken }); // ‚Üê Regular user, NOT admin!\n\n    expect(result).toBeDefined();\n    expect(result.name).toBe('Test Product');\n    createdProductId = result.id;\n\n    // Verify creator is set\n    expect(result.createdBy).toBe(userAuth.user.id);\n  });\n});\n```\n\n**Example 3: UPDATE - S_CREATOR or ADMIN**\n\n```typescript\n// Endpoint: @Roles(RoleEnum.ADMIN, RoleEnum.S_CREATOR)\ndescribe('Update Product', () => {\n  it('should update product as creator', async () => {\n    // First, creator creates a product\n    const created = await testHelper.graphQl({\n      name: 'createProduct',\n      type: TestGraphQLType.MUTATION,\n      arguments: { input: { name: 'Original', price: 10 } },\n      fields: ['id', 'name']\n    }, { token: creatorToken });\n\n    // Then, same creator updates it\n    const result = await testHelper.graphQl({\n      name: 'updateProduct',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        id: created.id,\n        input: { name: 'Updated' }\n      },\n      fields: ['id', 'name']\n    }, { token: creatorToken }); // ‚Üê Use CREATOR token (least privilege!)\n\n    expect(result.name).toBe('Updated');\n  });\n\n  it('should update any product as admin', async () => {\n    // Admin can update products they did NOT create\n    const result = await testHelper.graphQl({\n      name: 'updateProduct',\n      type: TestGraphQLType.MUTATION,\n      arguments: {\n        id: createdProductId, // Created by different user\n        input: { name: 'Admin Updated' }\n      },\n      fields: ['id', 'name']\n    }, { token: adminToken }); // ‚Üê Admin needed for other's products\n\n    expect(result.name).toBe('Admin Updated');\n  });\n});\n```\n\n---\n\n#### Step 5: MANDATORY: Test Permission Failures\n\n**CRITICAL**: You MUST test that unauthorized users are BLOCKED. This validates the security model.\n\n```typescript\ndescribe('Security Validation', () => {\n  describe('Unauthorized Access', () => {\n    it('should FAIL to create product without authentication', async () => {\n      // @Roles(RoleEnum.S_USER) requires authentication\n      const result = await testHelper.graphQl({\n        name: 'createProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { input: { name: 'Hack', price: 1 } },\n        fields: ['id']\n      }, { statusCode: 401 }); // ‚Üê NO TOKEN = should fail with 401\n\n      expect(result.errors).toBeDefined();\n      expect(result.errors[0].message).toContain('Unauthorized');\n    });\n\n    it('should FAIL to update product as non-creator', async () => {\n      // @Roles(RoleEnum.ADMIN, RoleEnum.S_CREATOR)\n      const result = await testHelper.graphQl({\n        name: 'updateProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: {\n          id: createdProductId, // Created by creatorUser\n          input: { name: 'Hacked' }\n        },\n        fields: ['id']\n      }, { token: otherUserToken, statusCode: 403 }); // ‚Üê Different user = should fail with 403\n\n      expect(result.errors).toBeDefined();\n      expect(result.errors[0].message).toContain('Forbidden');\n    });\n\n    it('should FAIL to delete product as non-creator', async () => {\n      const result = await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: createdProductId },\n        fields: ['id']\n      }, { token: otherUserToken, statusCode: 403 });\n\n      expect(result.errors).toBeDefined();\n    });\n\n    it('should FAIL to read private product as different user', async () => {\n      // If securityCheck() blocks non-creators\n      const result = await testHelper.graphQl({\n        name: 'getProduct',\n        type: TestGraphQLType.QUERY,\n        arguments: { id: privateProductId },\n        fields: ['id', 'name']\n      }, { token: otherUserToken });\n\n      // securityCheck returns undefined for non-creator\n      expect(result).toBeUndefined();\n    });\n  });\n});\n```\n\n---\n\n#### Step 6:  Complete Test Structure\n\n**Test file location**:\n```\ntests/modules/<module-name>.e2e-spec.ts\n```\n\n**Complete test template with proper privileges**:\n\n```typescript\nimport { TestGraphQLType, TestHelper } from '@lenne.tech/nest-server';\n\ndescribe('Product Module E2E', () => {\n  let testHelper: TestHelper;\n  let userToken: string;\n  let creatorToken: string;\n  let otherUserToken: string;\n  let adminToken: string;\n  let createdProductId: string;\n  let userAuth: any;\n  let creatorAuth: any;\n\n  beforeAll(async () => {\n    testHelper = new TestHelper(app);\n\n    // Create test users (based on permission analysis)\n    userAuth = await testHelper.graphQl({\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n      arguments: { input: { email: 'user@test.com', password: 'password', roles: ['user'] } },\n      fields: ['token', 'user { id }']\n    });\n    userToken = userAuth.token;\n\n    creatorAuth = await testHelper.graphQl({\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n      arguments: { input: { email: 'creator@test.com', password: 'password', roles: ['user'] } },\n      fields: ['token', 'user { id }']\n    });\n    creatorToken = creatorAuth.token;\n\n    const otherUserAuth = await testHelper.graphQl({\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n      arguments: { input: { email: 'other@test.com', password: 'password', roles: ['user'] } },\n      fields: ['token']\n    });\n    otherUserToken = otherUserAuth.token;\n\n    const adminAuth = await testHelper.graphQl({\n      name: 'signUp',\n      type: TestGraphQLType.MUTATION,\n      arguments: { input: { email: 'admin@test.com', password: 'password', roles: ['admin', 'user'] } },\n      fields: ['token']\n    });\n    adminToken = adminAuth.token;\n  });\n\n  afterAll(async () => {\n    // Cleanup with appropriate privileges\n    if (createdProductId) {\n      await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: createdProductId },\n        fields: ['id']\n      }, { token: creatorToken });\n    }\n  });\n\n  // 1. CREATE Tests (with least privileged user)\n  describe('Create Product', () => {\n    it('should create product as regular user', async () => {\n      const result = await testHelper.graphQl({\n        name: 'createProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { input: { name: 'Test', price: 10 } },\n        fields: ['id', 'name', 'price', 'createdBy']\n      }, { token: userToken }); // ‚Üê S_USER = regular user\n\n      expect(result.name).toBe('Test');\n      createdProductId = result.id;\n    });\n\n    it('should FAIL to create without authentication', async () => {\n      const result = await testHelper.graphQl({\n        name: 'createProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { input: { name: 'Fail', price: 10 } },\n        fields: ['id']\n      }, { statusCode: 401 }); // ‚Üê No token = should fail\n\n      expect(result.errors).toBeDefined();\n    });\n\n    it('should FAIL to create without required fields', async () => {\n      const result = await testHelper.graphQl({\n        name: 'createProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { input: {} },\n        fields: ['id']\n      }, { token: userToken, statusCode: 400 });\n\n      expect(result.errors).toBeDefined();\n    });\n  });\n\n  // 2. READ Tests\n  describe('Get Products', () => {\n    it('should get all products as regular user', async () => {\n      const result = await testHelper.graphQl({\n        name: 'getProducts',\n        type: TestGraphQLType.QUERY,\n        fields: ['id', 'name', 'price']\n      }, { token: userToken });\n\n      expect(Array.isArray(result)).toBe(true);\n    });\n\n    it('should get product by ID as regular user', async () => {\n      const result = await testHelper.graphQl({\n        name: 'getProduct',\n        type: TestGraphQLType.QUERY,\n        arguments: { id: createdProductId },\n        fields: ['id', 'name', 'price']\n      }, { token: userToken });\n\n      expect(result.id).toBe(createdProductId);\n    });\n  });\n\n  // 3. UPDATE Tests (with creator, not admin!)\n  describe('Update Product', () => {\n    let creatorProductId: string;\n\n    beforeAll(async () => {\n      // Creator creates a product to test updates\n      const created = await testHelper.graphQl({\n        name: 'createProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { input: { name: 'Creator Product', price: 20 } },\n        fields: ['id']\n      }, { token: creatorToken });\n      creatorProductId = created.id;\n    });\n\n    it('should update product as creator', async () => {\n      const result = await testHelper.graphQl({\n        name: 'updateProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: creatorProductId, input: { name: 'Updated' } },\n        fields: ['id', 'name']\n      }, { token: creatorToken }); // ‚Üê CREATOR token (least privilege!)\n\n      expect(result.name).toBe('Updated');\n    });\n\n    it('should FAIL to update product as non-creator', async () => {\n      const result = await testHelper.graphQl({\n        name: 'updateProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: creatorProductId, input: { name: 'Hacked' } },\n        fields: ['id']\n      }, { token: otherUserToken, statusCode: 403 });\n\n      expect(result.errors).toBeDefined();\n    });\n\n    it('should update any product as admin', async () => {\n      const result = await testHelper.graphQl({\n        name: 'updateProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: creatorProductId, input: { name: 'Admin Update' } },\n        fields: ['id', 'name']\n      }, { token: adminToken });\n\n      expect(result.name).toBe('Admin Update');\n    });\n  });\n\n  // 4. DELETE Tests (with creator, not admin!)\n  describe('Delete Product', () => {\n    it('should delete product as creator', async () => {\n      // Creator creates and deletes\n      const created = await testHelper.graphQl({\n        name: 'createProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { input: { name: 'To Delete', price: 5 } },\n        fields: ['id']\n      }, { token: creatorToken });\n\n      const result = await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: created.id },\n        fields: ['id']\n      }, { token: creatorToken }); // ‚Üê CREATOR token!\n\n      expect(result.id).toBe(created.id);\n    });\n\n    it('should FAIL to delete product as non-creator', async () => {\n      const result = await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: createdProductId },\n        fields: ['id']\n      }, { token: otherUserToken, statusCode: 403 });\n\n      expect(result.errors).toBeDefined();\n    });\n\n    it('should delete any product as admin', async () => {\n      const result = await testHelper.graphQl({\n        name: 'deleteProduct',\n        type: TestGraphQLType.MUTATION,\n        arguments: { id: createdProductId },\n        fields: ['id']\n      }, { token: adminToken });\n\n      expect(result.id).toBe(createdProductId);\n    });\n  });\n});\n```\n\n---\n\n#### Test Creation Checklist\n\nBefore finalizing tests, verify:\n\n- [ ]  I have analyzed ALL `@Roles()` decorators\n- [ ]  I have read the complete `securityCheck()` method\n- [ ]  I use the LEAST privileged user for each test\n- [ ]  S_EVERYONE endpoints tested WITHOUT token\n- [ ]  S_USER endpoints tested with REGULAR user (not admin)\n- [ ]  UPDATE/DELETE tested with CREATOR token (not admin)\n- [ ]  I have tests that verify unauthorized access FAILS (401/403)\n- [ ]  I have tests that verify non-creators CANNOT update/delete\n- [ ]  I have tests for missing required fields\n- [ ]  All tests follow the security model\n- [ ]  Tests validate protection mechanisms work\n\n** NEVER use admin token when a less privileged user would work!**\n\n",
        "plugins/lt-dev/skills/maintaining-npm-packages/SKILL.md": "---\nname: maintaining-npm-packages\ndescription: Guides npm package maintenance tasks. Use when user mentions outdated packages, npm audit, security vulnerabilities, dependency updates, package optimization, unused dependencies, or devDependencies categorization. Recommends the lt-dev:npm-package-maintainer agent via /maintain commands.\n---\n\n# NPM Package Maintenance\n\n## When to Use This Skill\n\n- User mentions outdated packages or wants to update dependencies\n- Security vulnerabilities found via `npm audit`\n- Need to optimize `dependencies` vs `devDependencies`\n- Removing unused packages from `package.json`\n- Pre-release or post-feature dependency cleanup\n- General package maintenance or housekeeping tasks\n\nFor comprehensive npm package maintenance, use the **lt-dev:npm-package-maintainer agent** via the maintenance commands.\n\n## Related Skills\n\n- `generating-nest-servers` - For NestJS development when dependencies affect the server\n- `using-lt-cli` - For Git operations after maintenance\n- `nest-server-updating` - For updating @lenne.tech/nest-server (uses this agent internally)\n\n## Available Commands\n\n| Command | Mode | Use Case |\n|---------|------|----------|\n| `/lt-dev:maintain` | FULL | Complete optimization (remove unused, recategorize, update all) |\n| `/lt-dev:maintain-check` | DRY-RUN | Analysis only - see what would be done without changes |\n| `/lt-dev:maintain-security` | SECURITY | Fast security-only updates (npm audit vulnerabilities) |\n| `/lt-dev:maintain-pre-release` | PRE-RELEASE | Conservative patch-only updates before a release |\n| `/lt-dev:maintain-post-feature` | FULL | Clean up after feature development |\n\n## When to Recommend Each Command\n\n### `/lt-dev:maintain` (FULL MODE)\nRecommend when user wants:\n- Complete dependency optimization\n- General maintenance / housekeeping\n- \"Clean up my dependencies\"\n- \"Update all packages\"\n\n### `/lt-dev:maintain-check` (DRY-RUN)\nRecommend when user wants:\n- To see what would change without making changes\n- Analysis or audit of current state\n- \"What packages are outdated?\"\n- \"Check my dependencies\"\n- Pre-approval before making changes\n\n### `/lt-dev:maintain-security` (SECURITY-ONLY)\nRecommend when user mentions:\n- `npm audit` vulnerabilities\n- Security issues\n- CVEs or security advisories\n- \"Fix security vulnerabilities\"\n- Quick/urgent security fixes\n\n### `/lt-dev:maintain-pre-release` (PRE-RELEASE)\nRecommend when user mentions:\n- Preparing for a release\n- \"Before release\"\n- Wanting minimal/safe changes only\n- Risk-averse updates\n\n### `/lt-dev:maintain-post-feature` (POST-FEATURE)\nRecommend when user:\n- Just finished implementing a feature\n- Added new dependencies\n- Wants to clean up after development work\n\n## What the Agent Does\n\nThe lt-dev:npm-package-maintainer agent performs 3 priorities:\n\n1. **Remove unused packages** - Finds and removes packages not used in the codebase\n2. **Optimize categorization** - Moves dev-only packages to devDependencies\n3. **Update packages** - Updates to latest versions with risk-based approach\n\nAll operations ensure `npm run build` and `npm test` pass before completion.\n\n## Quick Guidance\n\n- **User unsure?** ‚Üí Recommend `/lt-dev:maintain-check` first (safe, no changes)\n- **Security urgent?** ‚Üí Recommend `/lt-dev:maintain-security` (fast, focused)\n- **Before release?** ‚Üí Recommend `/lt-dev:maintain-pre-release` (conservative)\n- **General cleanup?** ‚Üí Recommend `/lt-dev:maintain` (comprehensive)\n",
        "plugins/lt-dev/skills/nest-server-updating/SKILL.md": "---\nname: nest-server-updating\ndescription: Knowledge base for updating @lenne.tech/nest-server. Use when discussing nest-server updates, upgrades, migrations, breaking changes, or version compatibility. Provides resources, migration guide patterns, and error solutions. For execution, use the lt-dev:nest-server-updater agent.\n---\n\n# @lenne.tech/nest-server Update Knowledge Base\n\nThis skill provides **knowledge and resources** for updating @lenne.tech/nest-server. For automated execution, use the `lt-dev:nest-server-updater` agent via `/lt-dev:backend:update-nest-server`.\n\n## When This Skill Activates\n\n- Discussing nest-server updates or upgrades\n- Asking about breaking changes between versions\n- Troubleshooting update-related errors\n- Planning migration strategies\n- Comparing versions or checking compatibility\n\n## Related Elements\n\n| Element | Purpose |\n|---------|---------|\n| **Agent**: `lt-dev:nest-server-updater` | Automated execution of updates |\n| **Command**: `/lt-dev:backend:update-nest-server` | User invocation |\n| **Skill**: `generating-nest-servers` | Code modifications after update |\n| **Skill**: `maintaining-npm-packages` | Package optimization |\n\n---\n\n## Core Resources\n\n### GitHub Repositories\n\n| Resource | URL | Purpose |\n|----------|-----|---------|\n| **nest-server** | https://github.com/lenneTech/nest-server | Main package repository |\n| **Releases** | https://github.com/lenneTech/nest-server/releases | Release notes, changelogs |\n| **Migration Guides** | https://github.com/lenneTech/nest-server/tree/main/migration-guides | Version-specific migration instructions |\n| **Reference Project** | https://github.com/lenneTech/nest-server-starter | Current compatible code & package versions |\n\n### npm Package\n\n```bash\n# Package info\nnpm view @lenne.tech/nest-server\n\n# Current installed version\nnpm list @lenne.tech/nest-server --depth=0\n\n# All available versions\nnpm view @lenne.tech/nest-server versions --json\n```\n\n---\n\n## Migration Guide System\n\n### File Naming Convention\n\nMigration guides in `migration-guides/` follow these patterns:\n\n| Pattern | Example | Scope |\n|---------|---------|-------|\n| `X.Y.x-to-A.B.x.md` | `11.6.x-to-11.7.x.md` | Minor version step |\n| `X.x-to-Y.x.md` | `11.x-to-12.x.md` | Major version jump |\n| `X.Y.x-to-A.B.x.md` | `11.6.x-to-12.0.x.md` | Spanning multiple versions |\n\n### Guide Selection Logic\n\nFor an update from version `CURRENT` to `TARGET`:\n\n1. **List available guides:**\n   ```bash\n   gh api repos/lenneTech/nest-server/contents/migration-guides --jq '.[].name'\n   ```\n\n2. **Select applicable guides:**\n\n   | Condition | Guides to load |\n   |-----------|----------------|\n   | Same major, sequential minor | Each `X.Y.x-to-X.Z.x.md` in sequence |\n   | Major version jump | All minor guides + `X.x-to-Y.x.md` |\n   | Spanning guide exists | Include it (may consolidate steps) |\n\n3. **Load order (example 11.6.0 ‚Üí 12.1.0):**\n   ```\n   1. 11.6.x-to-11.7.x.md\n   2. 11.7.x-to-11.8.x.md\n   3. ... (all minor steps to 11.x latest)\n   4. 11.x-to-12.x.md (major jump)\n   5. 12.0.x-to-12.1.x.md\n   6. 11.6.x-to-12.x.md (if exists - consolidated)\n   ```\n\n4. **Fetch guide content:**\n   ```bash\n   gh api repos/lenneTech/nest-server/contents/migration-guides/11.6.x-to-11.7.x.md \\\n     --jq '.content' | base64 -d\n   ```\n   Or via URL:\n   ```\n   https://raw.githubusercontent.com/lenneTech/nest-server/main/migration-guides/11.6.x-to-11.7.x.md\n   ```\n\n### Fallback When No Guides Available\n\nIf `migration-guides/` is empty or no matching guides exist for the version range:\n\n**Fallback Priority Order:**\n\n| Priority | Source | How to Use |\n|----------|--------|------------|\n| 1 | **Release Notes** | Extract breaking changes from GitHub Releases |\n| 2 | **Reference Project** | Compare nest-server-starter between version tags |\n| 3 | **CHANGELOG.md** | Check nest-server repo for changelog entries |\n\n**Fallback Commands:**\n\n```bash\n# Get all releases between versions\ngh release list --repo lenneTech/nest-server --limit 50\n\n# View specific release details\ngh release view v11.7.0 --repo lenneTech/nest-server\n\n# Compare reference project between versions\ncd /tmp/nest-server-starter-ref\ngit log --oneline v11.6.0..v11.8.0\ngit diff v11.6.0..v11.8.0 -- package.json src/\n```\n\n**When using fallback:**\n- Proceed with extra caution\n- Validate more frequently (after each minor change)\n- Document assumptions in the update report\n- Recommend manual review before merging\n\n---\n\n## Version Update Strategies\n\n**IMPORTANT:** In @lenne.tech/nest-server, **Major versions are reserved for NestJS Major versions**.\nTherefore, **Minor versions are treated like Major versions** and may contain breaking changes.\n\n### Patch Updates (X.Y.Z ‚Üí X.Y.W)\n\n- Usually safe, no breaking changes\n- Use the standard update workflow (see Quick Reference ‚Üí Update Workflow)\n- Run tests to verify\n- **Example:** `11.6.0 ‚Üí 11.6.5` - direct update OK\n\n### Minor Updates (X.Y.Z ‚Üí X.W.0) ‚ö†Ô∏è Treat as Major!\n\n- **May contain breaking changes** (Minor = Major in this package)\n- **Always stepwise**: Update through each minor version\n- Each minor step requires full validation cycle\n- Migration guides are essential\n- **Example:** `11.6.0 ‚Üí 11.8.0` becomes `11.6 ‚Üí 11.7 ‚Üí 11.8`\n\n### Major Updates (X.Y.Z ‚Üí W.0.0)\n\n- Reserved for NestJS major version changes\n- **Always stepwise**: Update through each major AND minor version\n- Example: `11.6.0 ‚Üí 12.2.0` becomes:\n  1. `11.6 ‚Üí 11.7 ‚Üí ... ‚Üí 11.latest` (all minors)\n  2. `11.latest ‚Üí 12.0` (major jump)\n  3. `12.0 ‚Üí 12.1 ‚Üí 12.2` (all minors)\n- Migration guides are critical\n\n---\n\n## Common Error Patterns & Solutions\n\n### TypeScript Errors\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| `Cannot find module '@lenne.tech/nest-server/...'` | Import path changed | Check migration guide for new paths |\n| `Type 'X' is not assignable to type 'Y'` | API type changed | Update to new type signature per guide |\n| `Property 'X' does not exist` | API removed/renamed | Check migration guide for replacement |\n\n### Runtime Errors\n\n| Error | Cause | Solution |\n|-------|-------|----------|\n| `Decorator not found` | Decorator moved | Import from new location |\n| `Cannot read property of undefined` | Initialization changed | Check startup sequence in reference project |\n| `Module not found` | Peer dependency missing | Compare package.json with reference project |\n\n### Test Failures\n\n| Symptom | Cause | Solution |\n|---------|-------|----------|\n| Timeout errors | Async behavior changed | Check test patterns in reference project |\n| Auth failures | Auth mechanism updated | Review auth changes in migration guide |\n| Validation errors | DTO changes | Update DTOs per migration guide |\n\n---\n\n## Reference Project Usage\n\nThe [nest-server-starter](https://github.com/lenneTech/nest-server-starter) serves as the source of truth:\n\n### What to Check\n\n1. **package.json**\n   - Compatible dependency versions\n   - New/removed dependencies\n   - Script changes\n\n2. **src/config.env.ts**\n   - New configuration options\n   - Changed defaults\n\n3. **src/server/modules/**\n   - Updated patterns for modules/services\n   - New decorators or utilities\n\n4. **Git history**\n   ```bash\n   git log --oneline --all --grep=\"nest-server\" | head -20\n   ```\n   - Find commits related to version updates\n   - See exactly what changed\n\n---\n\n## Update Modes\n\nThe `lt-dev:nest-server-updater` agent supports these modes:\n\n| Mode | Flag | Behavior |\n|------|------|----------|\n| **Full** | (default) | Complete update with all migrations |\n| **Dry-Run** | `--dry-run` | Analysis only, no changes |\n| **Target Version** | `--target-version X.Y.Z` | Update to specific version |\n| **Skip Packages** | `--skip-packages` | Skip npm-package-maintainer optimization |\n\n---\n\n## Quick Reference\n\n### Commands\n\n```bash\n# Check current version\nnpm list @lenne.tech/nest-server --depth=0\n\n# Check latest version\nnpm view @lenne.tech/nest-server version\n\n# List migration guides\ngh api repos/lenneTech/nest-server/contents/migration-guides --jq '.[].name'\n```\n\n### Update Workflow\n\n**IMPORTANT:** The `npm run update` script requires a specific workflow:\n\n1. **First:** Update the version in `package.json` to the desired target version\n   ```\n   \"@lenne.tech/nest-server\": \"^X.Y.Z\"\n   ```\n\n2. **Then:** Run the update script\n   ```bash\n   npm run update\n   ```\n\n**What `npm run update` does:**\n- Verifies the specified version is available on npm\n- Installs `@lenne.tech/nest-server` at the version from package.json\n- Analyzes which packages inside `@lenne.tech/nest-server` were updated\n- Installs those updated dependencies if they don't exist or have a lower version\n- Ensures version consistency between nest-server and its peer dependencies\n\n**Manual update (only if `npm run update` script is not available):**\n```bash\nnpm install @lenne.tech/nest-server@X.Y.Z --save-exact\nnpm install\n```\nNote: This skips the automatic dependency synchronization that `npm run update` provides.\n\n### Package Optimization (after npm run update)\n\nAfter `npm run update` completes, run comprehensive package maintenance:\n\n```bash\n# Via command (recommended)\n/lt-dev:maintenance:maintain\n\n# Or via agent (Task tool with lt-dev:npm-package-maintainer in FULL MODE)\n```\n\nThis ensures:\n- Unused dependencies are removed\n- Packages are correctly categorized (dependencies vs devDependencies)\n- All packages are updated to their latest compatible versions\n- Security vulnerabilities are addressed\n\n### Validation Sequence\n\n```bash\nnpm run build    # Must pass\nnpm run lint     # Must pass\nnpm test         # Must pass (no skips)\nnpm audit        # Should show no new vulnerabilities\n```\n\n---\n\n## When to Use the Agent vs. Manual Update\n\n| Scenario | Recommendation |\n|----------|----------------|\n| Routine update to latest | Use agent: `/lt-dev:backend:update-nest-server` |\n| Check what would change | Use agent with `--dry-run` |\n| Update to specific version | Use agent with `--target-version X.Y.Z` |\n| Complex issues during update | Use this skill's knowledge + manual fixes |\n| Understanding breaking changes | Read this skill + migration guides |\n",
        "plugins/lt-dev/skills/using-lt-cli/SKILL.md": "---\nname: using-lt-cli\ndescription: Expert for lenne.tech CLI (lt command). ALWAYS activate when user mentions \"lt\", \"lt CLI\", \"lenne.tech CLI\", fullstack workspace, local templates, or any lt command. Provides comprehensive reference for all lt CLI features including fullstack init, git workflows, server creation, and advanced options. Works alongside generating-nest-servers for NestJS development tasks.\n---\n\n# LT CLI Expert\n\nYou are an expert in the lenne.tech CLI tool (`lt` command). This skill provides comprehensive reference for all lt CLI features.\n\n**CRITICAL:** For NestJS server development (modules, objects, properties), ALWAYS use the `generating-nest-servers` skill instead.\n\n## Skill Activation\n\nThis skill activates whenever:\n- User mentions \"lt\", \"lt CLI\", or \"lenne.tech CLI\"\n- User wants to create a fullstack workspace\n- User mentions local templates, symlinks, or branch options\n- Any lt command is being used\n\n## Complementary Skills\n\nFor fullstack development, this skill works **alongside** other skills:\n\n| Task | Skills Used |\n|------|-------------|\n| `lt fullstack init` | **using-lt-cli** |\n| `lt git get`, `lt git reset` | **using-lt-cli** |\n| `lt server create` | **using-lt-cli** + generating-nest-servers |\n| `lt server module`, `lt server object` | **using-lt-cli** + generating-nest-servers |\n| NestJS code modifications | generating-nest-servers |\n| Nuxt/Vue frontend development | developing-lt-frontend |\n\nMultiple skills can be active simultaneously - this skill provides CLI syntax reference, while other skills provide development expertise.\n\n## Related Skills\n\n**Works closely with:**\n- `generating-nest-servers` skill - For ALL NestJS backend development\n- `developing-lt-frontend` skill - For ALL Nuxt/Vue frontend development\n- `building-stories-with-tdd` skill - For Test-Driven Development with NestJS\n\n**When to use which:**\n- Git operations (`lt git`)? Use this skill (using-lt-cli)\n- Fullstack init? Use this skill (using-lt-cli)\n- NestJS backend? Use `generating-nest-servers` skill\n- Nuxt/Vue frontend? Use `developing-lt-frontend` skill\n- TDD approach? Use `building-stories-with-tdd` skill\n\n**After `lt fullstack init`:**\n- Backend work (projects/api/) ‚Üí `generating-nest-servers`\n- Frontend work (projects/app/) ‚Üí `developing-lt-frontend`\n\n---\n\n## Available Commands\n\n### 1. Git Operations\n\n#### Get Branch\n**Command**: `lt git get <branch-name>` (alias: `lt git g`)\n\nChecks out a branch, creating it if it doesn't exist.\n\n**Non-interactive syntax**:\n```bash\nlt git get <branch-name>\n```\n\n**Examples**:\n```bash\n# Checkout existing or create new branch\nlt git get DEV-123\n\n# Using alias\nlt git g feature/new-feature\n```\n\n**What it does**:\n1. Checks if branch exists locally\n2. If not, checks if it exists on remote\n3. If remote exists, checks out and tracks remote branch\n4. If neither exists, creates new branch from current branch\n5. Switches to the branch\n\n#### Reset to Remote\n**Command**: `lt git reset`\n\nResets current branch to match remote (discards local changes).\n\n**Interactive**: Prompts for confirmation before resetting.\n\n**What it does**:\n1. Fetches latest from remote\n2. Resets current branch to origin/<branch>\n3. Discards all local changes and commits\n\n**WARNING**: This is destructive! All local changes will be lost.\n\n### 2. Fullstack Initialization\n\n#### Initialize Fullstack Workspace\n**Command**: `lt fullstack init` (alias: `lt full init`)\n\nCreates complete fullstack workspace with frontend and backend.\n\n**Interactive mode**:\n- Prompts for workspace name\n- Prompts for frontend framework (Angular or Nuxt)\n- Prompts for git initialization\n- Prompts for git repository URL (if git enabled)\n\n**Non-interactive syntax**:\n```bash\nlt fullstack init --name <WorkspaceName> --frontend <angular|nuxt> --git <true|false> [--git-link <GitURL>] [--api-branch <branch>] [--frontend-branch <branch>] [--api-copy <path>] [--api-link <path>] [--frontend-copy <path>] [--frontend-link <path>]\n```\n\n**Parameters**:\n- `--name` - Workspace/project name (PascalCase recommended)\n- `--frontend` - Frontend framework: `angular` or `nuxt`\n- `--git` - Initialize git repository: `true` or `false`\n- `--git-link` - Git repository URL (optional, only if `--git true`)\n- `--api-branch` - Branch of nest-server-starter to use for API (optional, for testing specific branches)\n- `--frontend-branch` - Branch of frontend starter to use (optional, for testing specific branches)\n- `--api-copy` - Path to local API template directory (copies the template)\n- `--api-link` - Path to local API template directory (creates symlink for fastest testing)\n- `--frontend-copy` - Path to local frontend template directory (copies the template)\n- `--frontend-link` - Path to local frontend template directory (creates symlink for fastest testing)\n\n**Examples**:\n```bash\n# With git and repository\nlt fullstack init --name MyApp --frontend angular --git true --git-link https://github.com/user/myapp.git\n\n# Without git\nlt fullstack init --name MyApp --frontend nuxt --git false\n\n# Using alias\nlt full init --name MyProject --frontend angular --git true\n\n# With local templates (symlink for fastest testing)\nlt fullstack init --name MyApp --frontend nuxt --git false \\\n  --api-link ~/code/nest-server-starter \\\n  --frontend-link ~/code/nuxt-base-starter\n\n# With local templates (copy for independent development)\nlt fullstack init --name MyApp --frontend angular --git true \\\n  --api-copy ~/code/nest-server-starter \\\n  --frontend-copy ~/code/ng-base-starter\n```\n\n**What gets created**:\n```\n<workspace-name>/\n  frontend/          # Angular or Nuxt application\n  projects/\n    api/            # NestJS backend (@lenne.tech/nest-server)\n  package.json      # Root workspace configuration\n  .gitignore        # (if git enabled)\n  .git/             # (if git enabled)\n```\n\n**Post-creation steps**:\n1. `cd <workspace-name>`\n2. Install dependencies: `npm install`\n3. Start backend: `cd projects/api && npm start`\n4. Start frontend: `cd frontend && npm start`\n\n---\n\n## How to Redirect to generating-nest-servers\n\nWhen you detect ANY NestJS server task, immediately inform the user:\n\n**Template response**:\n```\nFor NestJS server development tasks, please use the **generating-nest-servers skill** instead.\n\nThis skill is specifically designed for all NestJS/nest-server work, including:\n- Creating modules, objects, or properties\n- Modifying existing server code\n- Generating complete server structures\n\nI can help you with your NestJS server task using the generating-nest-servers skill.\n```\n\n---\n\n## Best Practices\n\n### Git Operations\n1. **Always commit changes before `lt git reset`** - It's destructive!\n2. **Use meaningful branch names** - Follow your team's conventions (e.g., `DEV-123`, `feature/xyz`)\n3. **Check status first** - Run `git status` before reset operations\n\n### Fullstack Init\n1. **Plan your architecture** - Know which frontend framework you need\n2. **Set up git early** - Use `--git true` from the start\n3. **Follow naming conventions** - Use PascalCase for workspace names\n4. **Read the generated README** - Each project has specific setup instructions\n\n---\n\n## Troubleshooting\n\n### Git Reset Not Working\n**Symptom**: Reset command fails or doesn't reset properly\n**Cause**: Remote branch doesn't exist or network issues\n**Solution**:\n- Check if remote branch exists: `git branch -r`\n- Ensure you're connected to remote: `git remote -v`\n- Fetch first: `git fetch origin`\n\n### Fullstack Init Fails\n**Symptom**: Installation errors during `lt fullstack init`\n**Cause**: Network issues, missing dependencies, or permissions\n**Solution**:\n- Check internet connection\n- Ensure Node.js is installed: `node --version`\n- Check npm permissions\n- Try with sudo if permission errors persist\n\n### Branch Already Exists\n**Symptom**: `lt git get` says branch exists but can't switch\n**Cause**: Uncommitted changes in working directory\n**Solution**: Commit, stash, or discard changes first:\n```bash\ngit stash        # Save changes temporarily\nlt git get <branch>\ngit stash pop    # Restore changes\n```\n\n---\n\n## Working with This Skill\n\nWhen helping users:\n\n1. **Clarify intent**: Is this a git operation or fullstack setup?\n2. **Redirect server tasks**: Immediately suggest nest-server-generator for any NestJS work\n3. **Provide complete commands**: Include all necessary flags\n4. **Warn about destructive operations**: Always warn before `lt git reset`\n5. **Explain side effects**: Describe what will happen\n\n### Example Response Pattern\n\n**User**: \"Switch to branch DEV-456\"\n\n**Your response**:\n```bash\n# Switch to branch DEV-456 (creates if it doesn't exist)\nlt git get DEV-456\n\n# This will:\n# ‚úì Check if DEV-456 exists locally\n# ‚úì If not, check remote\n# ‚úì If remote exists, checkout and track\n# ‚úì If neither exists, create new branch\n# ‚úì Switch to the branch\n```\n\n**User**: \"Create a User module\"\n\n**Your response**:\n```\nFor creating NestJS modules, please use the **generating-nest-servers skill** instead.\n\nThat skill is specifically designed for all NestJS/nest-server development tasks.\n\nThen I can help you create the User module with all necessary files and configurations.\n```\n\n---\n\n## Important Notes\n\n- **CLI works from anywhere** in your project directory\n- **Automatically finds** the nearest git repository for git commands\n- **Creates missing directories** for fullstack init\n- **Validates inputs** before executing destructive operations\n- **Always use generating-nest-servers skill** for NestJS server development\n\n---\n\n## Command Reference\n\nFor detailed command syntax and all available options, see [reference.md](reference.md).\n\nFor NestJS server commands (`lt server module`, `lt server object`, etc.), use the **generating-nest-servers skill**.\n",
        "plugins/lt-dev/skills/using-lt-cli/examples.md": "---\nname: lt-cli-examples\ndescription: Real-world examples for Git operations and Fullstack initialization with lenne.tech CLI\n---\n\n# LT CLI Examples\n\n **Note**: For NestJS server examples (modules, objects, properties), see the **nest-server-generator skill** instead.\n\n## Table of Contents\n- [Git Operations](#git-operations)\n- [Fullstack Project Initialization](#fullstack-project-initialization)\n- [Troubleshooting Examples](#troubleshooting-examples)\n- [Using Alias Commands](#using-alias-commands)\n- [Best Practices](#best-practices)\n- [Reference](#reference)\n\n---\n\n## Git Operations\n\n### 1. Branch Management\n\n#### Switching to Existing Branch\n```bash\n# Switch to existing branch DEV-123\nlt git get DEV-123\n```\n\n**What happens:**\n1. Checks if `DEV-123` exists locally\n2. Switches to branch `DEV-123`\n\n#### Creating New Branch\n```bash\n# Create and switch to new branch feature/new-authentication\nlt git get feature/new-authentication\n```\n\n**What happens:**\n1. Checks if `feature/new-authentication` exists locally (not found)\n2. Checks if it exists on remote (not found)\n3. Creates new branch `feature/new-authentication` from current branch\n4. Switches to the new branch\n\n#### Checking Out Remote Branch\n```bash\n# Checkout branch that exists on remote but not locally\nlt git get DEV-456\n```\n\n**What happens:**\n1. Checks if `DEV-456` exists locally (not found)\n2. Checks if it exists on remote (found!)\n3. Checks out `DEV-456` and sets up tracking to `origin/DEV-456`\n4. Switches to the branch\n\n#### Using Alias\n```bash\n# Same as \"lt git get\" but shorter\nlt git g DEV-789\n```\n\n---\n\n### 2. Workflow Scenarios\n\n#### Start New Feature Development\n```bash\n# You're on main branch, start working on new ticket\ngit status  # Verify clean working tree\nlt git get DEV-234  # Create and switch to new feature branch\n\n# Do your work...\ngit add .\ngit commit -m \"Implement feature\"\ngit push -u origin DEV-234\n```\n\n#### Switch Between Tickets\n```bash\n# Working on DEV-123, need to switch to urgent DEV-456\ngit status  # Check for uncommitted changes\ngit stash   # Save work in progress\nlt git get DEV-456  # Switch to urgent ticket\n\n# Fix urgent issue...\ngit add .\ngit commit -m \"Fix urgent bug\"\ngit push\n\n# Return to original work\nlt git get DEV-123\ngit stash pop  # Restore work in progress\n```\n\n#### Sync with Remote Branch\n```bash\n# Someone else created branch DEV-789 on remote\nlt git get DEV-789  # Automatically checks out and tracks remote branch\n\n# Verify tracking\ngit status\n# Output: \"Your branch is up to date with 'origin/DEV-789'\"\n```\n\n---\n\n### 3. Reset Operations\n\n#### Discard All Local Changes\n```bash\n# Your local changes are broken, start fresh from remote\ngit status  # See what will be discarded\n\nlt git reset\n# Prompts: \"Reset current branch to origin/<branch>? This will discard all local changes. (y/N)\"\n# Type: y\n\n# Your branch now matches remote exactly\n```\n\n** WARNING**: This is destructive! All local commits and changes are permanently lost.\n\n#### When to Use Reset\n\n**Use Case 1**: Experimental work failed\n```bash\n# You tried something, it didn't work, want clean slate\ngit status  # Shows many broken changes\nlt git reset  # Start over from remote\n```\n\n**Use Case 2**: Merge conflict too complex\n```bash\n# Merge created complex conflicts, easier to start over\ngit merge main  # Conflict!\n# ... attempt to resolve, too complicated\ngit merge --abort\nlt git reset  # Get clean state\n# Now merge again or use different approach\n```\n\n**Use Case 3**: Accidental commits on wrong branch\n```bash\n# Made commits on main instead of feature branch\ngit log  # See unwanted commits\nlt git reset  # Discard commits, return to clean main\nlt git get DEV-123  # Switch to correct branch\n# Re-do work properly\n```\n\n---\n\n### 4. Common Patterns\n\n#### Daily Development Workflow\n```bash\n# Morning: Start work on ticket\nlt git get main          # Switch to main\ngit pull                 # Get latest changes\nlt git get DEV-567       # Create/switch to ticket branch\n\n# During day: Regular commits\ngit add .\ngit commit -m \"Progress on feature\"\ngit push -u origin DEV-567  # First push sets upstream\n\n# End of day: Push progress\ngit add .\ngit commit -m \"WIP: End of day checkpoint\"\ngit push\n```\n\n#### Handling Mistakes\n```bash\n# Scenario: Committed to wrong branch\ngit log -1               # See the wrong commit\ngit stash                # Stash any uncommitted work\nlt git reset             # Reset to clean state\nlt git get DEV-999       # Switch to correct branch\ngit stash pop            # Restore work\n# Now commit on correct branch\n```\n\n#### Code Review Feedback\n```bash\n# Reviewer asked for changes on PR branch\nlt git get DEV-333       # Switch to PR branch\ngit pull                 # Get latest\n# Make requested changes\ngit add .\ngit commit -m \"Address PR feedback\"\ngit push\n```\n\n---\n\n## Fullstack Project Initialization\n\n### 1. Angular Projects\n\n#### Production Angular App with Git\n```bash\nlt fullstack init \\\n  --name MyAngularApp \\\n  --frontend angular \\\n  --git true \\\n  --git-link https://github.com/myorg/my-angular-app.git\n```\n\n**Creates:**\n```\nMyAngularApp/\n‚îú‚îÄ‚îÄ frontend/              # Angular 18+ application\n‚îÇ   ‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ angular.json\n‚îÇ   ‚îî‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ projects/\n‚îÇ   ‚îî‚îÄ‚îÄ api/              # NestJS backend (@lenne.tech/nest-server)\n‚îÇ       ‚îú‚îÄ‚îÄ src/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ server/\n‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ modules/\n‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ common/\n‚îÇ       ‚îî‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ package.json          # Root workspace config\n‚îú‚îÄ‚îÄ .gitignore\n‚îî‚îÄ‚îÄ .git/                 # Initialized with remote\n```\n\n**Next steps:**\n```bash\ncd MyAngularApp\nnpm install              # Install all dependencies\ncd projects/api && npm start  # Start backend (port 3000)\n# In another terminal:\ncd frontend && npm start      # Start frontend (port 4200)\n```\n\n#### Local Development Angular App\n```bash\nlt fullstack init \\\n  --name LocalDevApp \\\n  --frontend angular \\\n  --git false\n```\n\n**Use case:** Quick prototyping, learning, no version control needed\n\n---\n\n### 2. Nuxt Projects\n\n#### Production Nuxt App with Git\n```bash\nlt fullstack init \\\n  --name MyNuxtApp \\\n  --frontend nuxt \\\n  --git true \\\n  --git-link https://github.com/myorg/my-nuxt-app.git\n```\n\n**Creates:**\n```\nMyNuxtApp/\n‚îú‚îÄ‚îÄ frontend/              # Nuxt 3 application\n‚îÇ   ‚îú‚îÄ‚îÄ pages/\n‚îÇ   ‚îú‚îÄ‚îÄ components/\n‚îÇ   ‚îú‚îÄ‚îÄ nuxt.config.ts\n‚îÇ   ‚îî‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ projects/\n‚îÇ   ‚îî‚îÄ‚îÄ api/              # NestJS backend\n‚îÇ       ‚îî‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ .gitignore\n‚îî‚îÄ‚îÄ .git/\n```\n\n#### Nuxt App without Remote\n```bash\nlt fullstack init \\\n  --name MyNuxtProject \\\n  --frontend nuxt \\\n  --git true\n  # No --git-link, git initialized but no remote\n```\n\n**Use case:** Start project locally, add remote later\n\n**Add remote later:**\n```bash\ncd MyNuxtProject\ngit remote add origin https://github.com/myorg/my-nuxt-project.git\ngit push -u origin main\n```\n\n---\n\n### 3. Local Template Development\n\nUse local templates when developing or testing changes to the starter templates themselves.\n\n#### Symlink Mode (Fastest for Testing)\n```bash\n# Test changes to nest-server-starter immediately\nlt fullstack init --name TestApp --frontend nuxt --git false \\\n  --api-link ~/code/nest-server-starter\n\n# Test both API and frontend template changes\nlt fullstack init --name TestApp --frontend nuxt --git false \\\n  --api-link ~/code/nest-server-starter \\\n  --frontend-link ~/code/nuxt-base-starter\n```\n\n**What happens:**\n1. Creates workspace directory structure\n2. Symlinks `projects/api` -> your local nest-server-starter\n3. Symlinks `projects/app` -> your local nuxt-base-starter (if specified)\n4. Changes to your local templates are instantly reflected\n\n**Use case:** Template development, quick testing, debugging\n\n#### Copy Mode (Independent Development)\n```bash\n# Create independent copy from local template\nlt fullstack init --name MyApp --frontend angular --git true \\\n  --api-copy ~/code/nest-server-starter \\\n  --frontend-copy ~/code/ng-base-starter\n```\n\n**What happens:**\n1. Copies entire template directory (excluding `.git`)\n2. Creates independent project you can modify freely\n3. Safe for production projects starting from local template\n\n**Use case:** Starting project from customized template, offline development\n\n#### Auto-Detection of Nuxt Subdirectory\n```bash\n# If your local repo has nuxt-base-template/ subdirectory:\nlt fullstack init --name TestApp --frontend nuxt --git false \\\n  --frontend-link ~/code/nuxt-base-starter\n# CLI auto-detects and uses ~/code/nuxt-base-starter/nuxt-base-template/\n```\n\n---\n\n### 4. Project Types (Examples)\n\n#### Client Project (Angular + NestJS)\n```bash\nlt fullstack init \\\n  --name ClientPortal \\\n  --frontend angular \\\n  --git true \\\n  --git-link https://github.com/client/portal.git\n\n# After creation:\ncd ClientPortal/projects/api\n\n# Add authentication module\nlt server module --name User --controller Both \\\n  --prop-name-0 email --prop-type-0 string \\\n  --prop-name-1 password --prop-type-1 string\n\n# Add business logic modules\n# ... (use nest-server-generator skill for this)\n```\n\n#### Internal Tool (Nuxt + NestJS)\n```bash\nlt fullstack init \\\n  --name InternalDashboard \\\n  --frontend nuxt \\\n  --git true \\\n  --git-link https://github.com/company/internal-dashboard.git\n\n# Quick setup for internal tools with Nuxt's flexibility\n```\n\n#### Learning/Tutorial Project\n```bash\nlt fullstack init \\\n  --name LearningFullstack \\\n  --frontend angular \\\n  --git false\n\n# No git overhead, just focus on learning\n```\n\n---\n\n### 5. Post-Creation Workflows\n\n#### After Angular Fullstack Init\n```bash\ncd MyAngularApp\nnpm install\n\n# Terminal 1: Start backend\ncd projects/api\nnpm start\n# API runs on http://localhost:3000\n\n# Terminal 2: Start frontend\ncd frontend\nnpm start\n# Frontend runs on http://localhost:4200\n# Auto-proxies API calls to backend\n\n# Terminal 3: Development\ncd projects/api\n# Generate server modules using nest-server-generator skill\n```\n\n#### After Nuxt Fullstack Init\n```bash\ncd MyNuxtApp\nnpm install\n\n# Terminal 1: Start backend\ncd projects/api\nnpm start\n# API runs on http://localhost:3000\n\n# Terminal 2: Start frontend\ncd frontend\nnpm run dev\n# Frontend runs on http://localhost:3000 (or 3001 if 3000 taken)\n\n# Configure proxy in nuxt.config.ts if needed\n```\n\n---\n\n### 6. Common Initialization Patterns\n\n#### Team Project Setup\n```bash\n# Lead developer initializes project\nlt fullstack init \\\n  --name TeamProject \\\n  --frontend angular \\\n  --git true \\\n  --git-link https://github.com/team/team-project.git\n\ncd TeamProject\nnpm install\n# ... initial setup, create base modules\ngit add .\ngit commit -m \"Initial project setup\"\ngit push -u origin main\n\n# Team members clone\n# git clone https://github.com/team/team-project.git\n# cd team-project\n# npm install\n```\n\n#### Monorepo with Multiple Projects\n```bash\n# Create first project\nlt fullstack init --name ProjectA --frontend angular --git true\n\n# Create second project\nlt fullstack init --name ProjectB --frontend nuxt --git true\n\n# Each has its own git repository, npm workspace, and backend\n```\n\n#### Migration from Existing Backend\n```bash\n# Create fullstack project\nlt fullstack init \\\n  --name MigratedApp \\\n  --frontend angular \\\n  --git true\n\ncd MigratedApp/projects\n\n# Remove generated api\nrm -rf api\n\n# Clone existing backend\ngit clone https://github.com/company/existing-api.git api\n\n# Update root package.json workspace paths if needed\n```\n\n---\n\n## Troubleshooting Examples\n\n### Git Branch Issues\n\n#### Branch Exists But Can't Switch\n```bash\n# Problem: Uncommitted changes\ngit status\n# Output: \"Changes not staged for commit...\"\n\n# Solution 1: Stash changes\ngit stash\nlt git get DEV-123\ngit stash pop\n\n# Solution 2: Commit changes\ngit add .\ngit commit -m \"WIP: Save progress\"\nlt git get DEV-123\n```\n\n#### Reset Fails\n```bash\n# Problem: No remote branch\nlt git reset\n# Error: \"Remote branch not found\"\n\n# Solution: Check remote\ngit branch -r  # List remote branches\ngit remote -v  # Verify remote URL\n\n# If remote missing, add it\ngit remote add origin https://github.com/user/repo.git\ngit fetch origin\nlt git reset  # Try again\n```\n\n### Fullstack Init Issues\n\n#### Permission Denied\n```bash\n# Problem: Can't create directory\nlt fullstack init --name MyApp --frontend angular --git false\n# Error: \"Permission denied\"\n\n# Solution: Check permissions\nls -la .\n# Create in home directory or with sudo\ncd ~\nlt fullstack init --name MyApp --frontend angular --git false\n```\n\n#### Git Remote Already Exists\n```bash\n# Problem: Directory already has .git\nlt fullstack init --name ExistingDir --frontend nuxt --git true\n# Error: \"Directory already initialized with git\"\n\n# Solution: Use different directory or remove .git\nrm -rf ExistingDir/.git\nlt fullstack init --name ExistingDir --frontend nuxt --git true\n```\n\n---\n\n## Using Alias Commands\n\nAll commands have shorter aliases:\n\n```bash\n# Full commands\nlt git get DEV-123\nlt fullstack init --name MyApp --frontend angular --git true\n\n# With aliases\nlt git g DEV-123\nlt full init --name MyApp --frontend angular --git true\n```\n\n---\n\n## Best Practices\n\n### Git Operations\n1. **Always check status first**: `git status` before switching branches\n2. **Save work before switching**: Commit or stash uncommitted changes\n3. **Be cautious with reset**: It's destructive and irreversible\n4. **Use meaningful branch names**: Follow team conventions (DEV-123, feature/xyz)\n\n### Fullstack Initialization\n1. **Choose frontend wisely**: Angular for enterprise, Nuxt for flexibility\n2. **Enable git from start**: Use `--git true` for all real projects\n3. **Follow naming conventions**: PascalCase for project names\n4. **Read generated READMEs**: Each project has setup instructions\n5. **Install dependencies immediately**: Run `npm install` after creation\n\n---\n\n## Reference\n\nFor detailed command syntax and all available options, see [reference.md](reference.md).\n\nFor NestJS server development examples, use the **nest-server-generator skill**.\n",
        "plugins/lt-dev/skills/using-lt-cli/reference.md": "---\nname: lt-cli-reference\ndescription: Quick reference for Git operations and Fullstack initialization commands\n---\n\n# LT CLI Quick Reference\n\n **Note**: For NestJS server command reference (modules, objects, properties), see the **nest-server-generator skill** instead.\n\n## Table of Contents\n- [Command Cheat Sheet](#command-cheat-sheet)\n- [Git Commands Reference](#git-commands-reference)\n- [Fullstack Commands Reference](#fullstack-commands-reference)\n- [Common Patterns](#common-patterns)\n- [Troubleshooting](#troubleshooting)\n- [Best Practices](#best-practices)\n- [Quick Tips](#quick-tips)\n- [Related Commands](#related-commands)\n- [References](#references)\n\n---\n\n## Command Cheat Sheet\n\n### Git Commands\n\n#### Get Branch (Checkout/Create)\n```bash\n# Interactive (prompts for branch name)\nlt git get\nlt git g\n\n# Non-interactive\nlt git get <branch-name>\nlt git g <branch-name>\n```\n\n**Parameters:**\n- `<branch-name>`: Branch name to checkout/create\n\n**What it does:**\n1. Checks if branch exists locally -> switches to it\n2. If not local, checks remote -> checks out and tracks\n3. If neither exists -> creates new branch from current\n\n**Examples:**\n```bash\nlt git get DEV-123\nlt git get feature/new-auth\nlt git g main\n```\n\n#### Reset to Remote\n```bash\n# Interactive (prompts for confirmation)\nlt git reset\n\n# Prompts: \"Reset current branch to origin/<branch>? (y/N)\"\n```\n\n**What it does:**\n1. Fetches latest from remote\n2. Resets current branch to `origin/<current-branch>`\n3. Discards ALL local changes and commits\n\n** WARNING**: Destructive operation - cannot be undone!\n\n---\n\n### Fullstack Commands\n\n#### Initialize Fullstack Workspace\n```bash\n# Interactive (prompts for all options)\nlt fullstack init\nlt full init\n\n# Non-interactive\nlt fullstack init \\\n  --name <WorkspaceName> \\\n  --frontend <angular|nuxt> \\\n  --git <true|false> \\\n  [--git-link <GitURL>]\n```\n\n**Required Parameters:**\n- `--name`: Workspace/project name (PascalCase recommended)\n- `--frontend`: Frontend framework (`angular` or `nuxt`)\n- `--git`: Initialize git repository (`true` or `false`)\n\n**Optional Parameters:**\n- `--git-link`: Git repository URL (only when `--git true`)\n\n**Examples:**\n```bash\n# With git and remote\nlt fullstack init \\\n  --name MyApp \\\n  --frontend angular \\\n  --git true \\\n  --git-link https://github.com/user/myapp.git\n\n# Without git\nlt fullstack init \\\n  --name TestProject \\\n  --frontend nuxt \\\n  --git false\n\n# With git but no remote (add later)\nlt fullstack init \\\n  --name LocalProject \\\n  --frontend angular \\\n  --git true\n```\n\n---\n\n## Git Commands Reference\n\n### lt git get\n\n**Syntax:**\n```bash\nlt git get [branch-name]\n```\n\n**Aliases:**\n- `lt git g`\n\n**Behavior:**\n\n| Scenario | Action |\n|----------|--------|\n| Branch exists locally | Switches to branch |\n| Branch exists on remote only | Checks out and tracks remote branch |\n| Branch doesn't exist anywhere | Creates new branch from current |\n\n**Common Usage:**\n```bash\n# Start new feature\nlt git get DEV-456           # Creates if doesn't exist\n\n# Switch to existing branch\nlt git get main              # Switches to main\n\n# Checkout teammate's branch\nlt git get feature/auth      # Checks out from remote if exists\n\n# Short alias\nlt git g DEV-789             # Same as \"lt git get DEV-789\"\n```\n\n**Equivalent Standard Git:**\n```bash\n# lt git get DEV-123 does:\ngit checkout DEV-123 2>/dev/null || \\\n  git checkout -b DEV-123 --track origin/DEV-123 2>/dev/null || \\\n  git checkout -b DEV-123\n```\n\n---\n\n### lt git reset\n\n**Syntax:**\n```bash\nlt git reset\n```\n\n**No parameters accepted** - always operates on current branch.\n\n**Interactive Prompt:**\n```\nReset current branch to origin/<branch>?\nThis will discard all local changes. (y/N)\n```\n\n**What Gets Discarded:**\n- All uncommitted changes (staged and unstaged)\n- All local commits not pushed to remote\n- All untracked files (if any were added)\n\n**When to Use:**\n- Experimental work failed, want clean slate\n- Merge conflicts too complex\n- Accidentally committed to wrong branch\n- Local branch corrupted\n\n**When NOT to Use:**\n- You want to keep any local changes\n- You haven't pushed but commits are valuable\n- Branch has no remote tracking\n\n**Equivalent Standard Git:**\n```bash\n# lt git reset does:\ngit fetch origin\ngit reset --hard origin/<current-branch>\n```\n\n**Recovery (if you made a mistake):**\n```bash\n# IMMEDIATELY after reset, if you change your mind:\ngit reflog                   # Find commit before reset\ngit reset --hard HEAD@{1}    # Restore to that commit\n```\n\n---\n\n## Fullstack Commands Reference\n\n### lt fullstack init\n\n**Syntax:**\n```bash\nlt fullstack init \\\n  --name <WorkspaceName> \\\n  --frontend <angular|nuxt> \\\n  --git <true|false> \\\n  [--git-link <GitURL>] \\\n  [--api-branch <branch>] \\\n  [--frontend-branch <branch>] \\\n  [--api-copy <path>] \\\n  [--api-link <path>] \\\n  [--frontend-copy <path>] \\\n  [--frontend-link <path>]\n```\n\n**Aliases:**\n- `lt full init`\n\n**Parameters:**\n\n| Parameter | Type | Required | Options | Description |\n|-----------|------|----------|---------|-------------|\n| `--name` | string | Yes | - | Project name (PascalCase) |\n| `--frontend` | string | Yes | `angular`, `nuxt` | Frontend framework |\n| `--git` | boolean | Yes | `true`, `false` | Initialize git |\n| `--git-link` | string | No | URL | Git repository URL |\n| `--api-branch` | string | No | branch name | Branch of nest-server-starter to use for API |\n| `--frontend-branch` | string | No | branch name | Branch of frontend starter (ng-base-starter/nuxt-base-starter) |\n| `--api-copy` | string | No | local path | Copy API template from local directory |\n| `--api-link` | string | No | local path | Symlink API to local template (fastest for testing) |\n| `--frontend-copy` | string | No | local path | Copy frontend template from local directory |\n| `--frontend-link` | string | No | local path | Symlink frontend to local template (fastest for testing) |\n\n**Local Template Options:**\n\nUse `--*-link` for **development/testing** (instant setup, changes affect source):\n```bash\nlt fullstack init --name TestApp --frontend nuxt --git false \\\n  --api-link ~/code/nest-server-starter \\\n  --frontend-link ~/code/nuxt-base-starter\n```\n\nUse `--*-copy` for **independent development** (isolated copy, safe to modify):\n```bash\nlt fullstack init --name MyApp --frontend angular --git true \\\n  --api-copy ~/code/nest-server-starter \\\n  --frontend-copy ~/code/ng-base-starter\n```\n\n**Priority:** `--*-link` > `--*-copy` > `--*-branch` > default (clone from GitHub)\n\n**Created Structure:**\n```\n<workspace-name>/\n‚îú‚îÄ‚îÄ frontend/              # Angular or Nuxt app\n‚îÇ   ‚îú‚îÄ‚îÄ src/              # (Angular) or pages/ (Nuxt)\n‚îÇ   ‚îú‚îÄ‚îÄ package.json\n‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ projects/\n‚îÇ   ‚îî‚îÄ‚îÄ api/              # NestJS backend (@lenne.tech/nest-server)\n‚îÇ       ‚îú‚îÄ‚îÄ src/\n‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ server/\n‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ modules/\n‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ common/\n‚îÇ       ‚îú‚îÄ‚îÄ package.json\n‚îÇ       ‚îî‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ package.json          # Root workspace config\n‚îú‚îÄ‚îÄ .gitignore           # (if --git true)\n‚îî‚îÄ‚îÄ .git/                # (if --git true)\n```\n\n**Post-Creation Setup:**\n```bash\ncd <workspace-name>\nnpm install                        # Install dependencies\n\n# Terminal 1: Start backend\ncd projects/api && npm start       # Runs on port 3000\n\n# Terminal 2: Start frontend\ncd frontend && npm start           # Angular: 4200, Nuxt: 3000/3001\n```\n\n**Git Remote Configuration:**\n\nWith `--git-link`:\n```bash\n# Remote automatically configured\ngit remote -v\n# origin  https://github.com/user/repo.git (fetch)\n# origin  https://github.com/user/repo.git (push)\n```\n\nWithout `--git-link` (add later):\n```bash\ncd <workspace-name>\ngit remote add origin https://github.com/user/repo.git\ngit push -u origin main\n```\n\n---\n\n## Common Patterns\n\n### Git Workflows\n\n#### Feature Development\n```bash\n# Start new feature\ngit checkout main\ngit pull\nlt git get DEV-123\n\n# Work...\ngit add .\ngit commit -m \"Implement feature\"\ngit push -u origin DEV-123\n```\n\n#### Switch Between Branches\n```bash\n# Save current work\ngit stash\n\n# Switch branch\nlt git get DEV-456\n\n# Do urgent work...\n\n# Return to original work\nlt git get DEV-123\ngit stash pop\n```\n\n#### Discard Failed Work\n```bash\n# Work didn't go well\ngit status                  # See mess\n\n# Start over from remote\nlt git reset               # Clean slate\n```\n\n### Fullstack Initialization\n\n#### Production Project\n```bash\nlt fullstack init \\\n  --name ProductionApp \\\n  --frontend angular \\\n  --git true \\\n  --git-link https://github.com/company/production-app.git\n\ncd ProductionApp\nnpm install\n# ... setup, create modules, commit, push\n```\n\n#### Local Development\n```bash\nlt fullstack init \\\n  --name LocalTest \\\n  --frontend nuxt \\\n  --git false\n\ncd LocalTest\nnpm install\n# ... quick testing without git overhead\n```\n\n---\n\n## Troubleshooting\n\n### Git Commands\n\n#### \"Branch not found\" Error\n```bash\n# Problem: Typo in branch name\nlt git get DEV-12345\n# Error: Branch not found\n\n# Solution: Check available branches\ngit branch -a               # List all branches\nlt git get DEV-123          # Correct name\n```\n\n#### \"Cannot reset\" Error\n```bash\n# Problem: No remote tracking\nlt git reset\n# Error: No remote tracking branch\n\n# Solution: Set up tracking\ngit branch -u origin/main   # Or appropriate branch\ngit fetch origin\nlt git reset\n```\n\n#### Uncommitted Changes Block Switch\n```bash\n# Problem: Changes prevent switching\nlt git get DEV-456\n# Error: Your local changes... would be overwritten\n\n# Solution 1: Stash\ngit stash\nlt git get DEV-456\ngit stash pop\n\n# Solution 2: Commit\ngit add .\ngit commit -m \"WIP\"\nlt git get DEV-456\n```\n\n### Fullstack Init\n\n#### Permission Denied\n```bash\n# Problem: No write permissions\nlt fullstack init --name MyApp --frontend angular --git false\n# Error: Permission denied\n\n# Solution: Use writable directory\ncd ~/projects\nlt fullstack init --name MyApp --frontend angular --git false\n```\n\n#### Directory Already Exists\n```bash\n# Problem: Project name already used\nlt fullstack init --name MyApp --frontend angular --git false\n# Error: Directory already exists\n\n# Solution: Use different name or remove directory\nrm -rf MyApp\nlt fullstack init --name MyApp --frontend angular --git false\n```\n\n#### Git Link Invalid\n```bash\n# Problem: Invalid git URL\nlt fullstack init \\\n  --name MyApp \\\n  --frontend angular \\\n  --git true \\\n  --git-link invalid-url\n\n# Solution: Use valid HTTPS or SSH URL\nlt fullstack init \\\n  --name MyApp \\\n  --frontend angular \\\n  --git true \\\n  --git-link https://github.com/user/repo.git\n```\n\n---\n\n## Best Practices\n\n### Git Operations\n\n**Branch Management:**\n-  Always run `git status` before switching branches\n-  Commit or stash changes before switching\n-  Use meaningful branch names (DEV-123, feature/xyz)\n-  Pull latest before creating feature branches\n-  Don't leave uncommitted changes when switching\n\n**Reset Operations:**\n-  Verify what will be discarded with `git status` first\n-  Only reset when you're certain you want to discard everything\n-  Know that reset is irreversible (unless using reflog immediately)\n-  Don't reset if you have valuable local commits\n-  Don't reset without checking remote exists\n\n### Fullstack Initialization\n\n**Project Setup:**\n-  Use PascalCase for project names (MyProject, not my-project)\n-  Enable git for all real projects (`--git true`)\n-  Add git remote URL immediately with `--git-link`\n-  Run `npm install` right after creation\n-  Choose Angular for enterprise, Nuxt for flexibility\n-  Don't use git for quick throwaway tests\n-  Don't use spaces in project names\n\n**Post-Creation:**\n-  Read generated README.md files\n-  Commit initial setup before making changes\n-  Set up CI/CD early\n-  Configure environment variables\n-  Don't commit .env files\n-  Don't modify generated structure without understanding it\n\n---\n\n## Quick Tips\n\n1. **Use aliases**: `lt git g` instead of `lt git get`\n2. **Stash is your friend**: `git stash` before branch switches\n3. **Check status often**: `git status` before any git operation\n4. **Reset is destructive**: Only use when certain\n5. **PascalCase names**: `MyProject`, not `my_project` or `myproject`\n6. **Git from start**: Use `--git true` for all real projects\n7. **Track branches**: Let `lt git get` handle remote tracking\n8. **Install immediately**: Run `npm install` after init\n9. **Commit often**: Save work after each logical step\n10. **Read READMEs**: Each generated project has setup instructions\n\n---\n\n## Related Commands\n\nFor NestJS server development commands, use the **nest-server-generator skill**:\n- `lt server module` - Create modules\n- `lt server object` - Create objects\n- `lt server addProp` - Add properties\n\n---\n\n## References\n\n- [lenne.tech CLI Documentation](https://github.com/lenneTech/cli)\n- [Git Documentation](https://git-scm.com/doc)\n- [NestJS Documentation](https://docs.nestjs.com)\n- [Angular Documentation](https://angular.io/docs)\n- [Nuxt Documentation](https://nuxt.com/docs)\n"
      },
      "plugins": [
        {
          "name": "lt-dev",
          "source": "./plugins/lt-dev",
          "description": "Skills, Commands & Hooks for Nuxt 4, NestJS, TDD and CLI tools",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add lenneTech/claude-code",
            "/plugin install lt-dev@lenne-tech"
          ]
        }
      ]
    }
  ]
}