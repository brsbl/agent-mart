{
  "author": {
    "id": "forztf",
    "display_name": "forztf",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/10570841?v=4",
    "url": "https://github.com/forztf",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 16,
      "total_skills": 16,
      "total_stars": 4,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "open-skilled-sdd-marketplace",
      "version": null,
      "description": "Official marketplace for Open Spec-Driven Development Claude Code plugin",
      "owner_info": {
        "name": "forztf"
      },
      "keywords": [],
      "repo_full_name": "forztf/open-skilled-sdd",
      "repo_url": "https://github.com/forztf/open-skilled-sdd",
      "repo_description": "Enhancing AI coding assistants through open Spec-driven development (Spec-driven development for AI coding assistants), adopting the Claude Code Skills approach, compatible with various CLI and IDE AI coding assistants that support AGENTS.md.",
      "homepage": null,
      "signals": {
        "stars": 4,
        "forks": 1,
        "pushed_at": "2025-11-28T07:09:48Z",
        "created_at": "2025-11-21T06:14:22Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 396
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 1098
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-archiving-cn",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-archiving-cn/SKILL.md",
          "type": "blob",
          "size": 10164
        },
        {
          "path": "skills/openspec-archiving",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-archiving/SKILL.md",
          "type": "blob",
          "size": 10798
        },
        {
          "path": "skills/openspec-context-loading-cn",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-context-loading-cn/SKILL.md",
          "type": "blob",
          "size": 10102
        },
        {
          "path": "skills/openspec-context-loading-cn/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-context-loading-cn/reference/SEARCH_PATTERNS.md",
          "type": "blob",
          "size": 2197
        },
        {
          "path": "skills/openspec-context-loading",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-context-loading/SKILL.md",
          "type": "blob",
          "size": 10399
        },
        {
          "path": "skills/openspec-implementation-cn",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-implementation-cn/SKILL.md",
          "type": "blob",
          "size": 9440
        },
        {
          "path": "skills/openspec-implementation-cn/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-implementation-cn/reference/TASK_PATTERNS.md",
          "type": "blob",
          "size": 27692
        },
        {
          "path": "skills/openspec-implementation-cn/reference/TESTING_STRATEGIES.md",
          "type": "blob",
          "size": 1340
        },
        {
          "path": "skills/openspec-implementation",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-implementation/SKILL.md",
          "type": "blob",
          "size": 8447
        },
        {
          "path": "skills/openspec-proposal-creation-cn",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation-cn/SKILL.md",
          "type": "blob",
          "size": 7849
        },
        {
          "path": "skills/openspec-proposal-creation-cn/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation-cn/reference/EARS_FORMAT.md",
          "type": "blob",
          "size": 7163
        },
        {
          "path": "skills/openspec-proposal-creation-cn/reference/VALIDATION_PATTERNS.md",
          "type": "blob",
          "size": 8063
        },
        {
          "path": "skills/openspec-proposal-creation-cn/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation-cn/templates/proposal.md",
          "type": "blob",
          "size": 774
        },
        {
          "path": "skills/openspec-proposal-creation-cn/templates/spec-delta.md",
          "type": "blob",
          "size": 1128
        },
        {
          "path": "skills/openspec-proposal-creation",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation/SKILL.md",
          "type": "blob",
          "size": 7677
        },
        {
          "path": "skills/openspec-proposal-creation/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation/reference/EARS_FORMAT.md",
          "type": "blob",
          "size": 8198
        },
        {
          "path": "skills/openspec-proposal-creation/reference/VALIDATION_PATTERNS.md",
          "type": "blob",
          "size": 8297
        },
        {
          "path": "skills/openspec-proposal-creation/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/openspec-proposal-creation/templates/proposal.md",
          "type": "blob",
          "size": 842
        },
        {
          "path": "skills/openspec-proposal-creation/templates/spec-delta.md",
          "type": "blob",
          "size": 1268
        },
        {
          "path": "skills/openspec-proposal-creation/templates/tasks.md",
          "type": "blob",
          "size": 774
        },
        {
          "path": "skills/speckit-analyze-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-analyze-zh/SKILL.md",
          "type": "blob",
          "size": 6897
        },
        {
          "path": "skills/speckit-analyze-zh/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-analyze-zh/references/analysis-patterns.md",
          "type": "blob",
          "size": 1399
        },
        {
          "path": "skills/speckit-checklist-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-checklist-zh/SKILL.md",
          "type": "blob",
          "size": 15852
        },
        {
          "path": "skills/speckit-checklist-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-checklist-zh/assets/checklist-template.md",
          "type": "blob",
          "size": 1255
        },
        {
          "path": "skills/speckit-checklist-zh/assets/correct-examples.md",
          "type": "blob",
          "size": 654
        },
        {
          "path": "skills/speckit-checklist-zh/assets/example-snippets.md",
          "type": "blob",
          "size": 1653
        },
        {
          "path": "skills/speckit-checklist-zh/assets/user-input-template.md",
          "type": "blob",
          "size": 22
        },
        {
          "path": "skills/speckit-checklist-zh/assets/wrong-examples.md",
          "type": "blob",
          "size": 322
        },
        {
          "path": "skills/speckit-checklist-zh/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-checklist-zh/references/anti-examples.md",
          "type": "blob",
          "size": 2367
        },
        {
          "path": "skills/speckit-checklist-zh/references/checklist-types.md",
          "type": "blob",
          "size": 2278
        },
        {
          "path": "skills/speckit-checklist-zh/references/execution-guide.md",
          "type": "blob",
          "size": 2373
        },
        {
          "path": "skills/speckit-checklist-zh/references/quality-dimensions.md",
          "type": "blob",
          "size": 3570
        },
        {
          "path": "skills/speckit-clarify-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-clarify-zh/SKILL.md",
          "type": "blob",
          "size": 10539
        },
        {
          "path": "skills/speckit-constitution-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/SKILL.md",
          "type": "blob",
          "size": 6010
        },
        {
          "path": "skills/speckit-constitution-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/memory/constitution.md",
          "type": "blob",
          "size": 2047
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/agent-file-template.md",
          "type": "blob",
          "size": 433
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/checklist-template.md",
          "type": "blob",
          "size": 1255
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/analyze.md",
          "type": "blob",
          "size": 6582
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/checklist.md",
          "type": "blob",
          "size": 15507
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/clarify.md",
          "type": "blob",
          "size": 10219
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/constitution.md",
          "type": "blob",
          "size": 4629
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/implement.md",
          "type": "blob",
          "size": 7211
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/plan.md",
          "type": "blob",
          "size": 2973
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/specify.md",
          "type": "blob",
          "size": 11279
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/commands/tasks.md",
          "type": "blob",
          "size": 6005
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/constitution-template.md",
          "type": "blob",
          "size": 2047
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/plan-template.md",
          "type": "blob",
          "size": 3579
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/spec-template.md",
          "type": "blob",
          "size": 3521
        },
        {
          "path": "skills/speckit-constitution-zh/assets/specify/templates/tasks-template.md",
          "type": "blob",
          "size": 8682
        },
        {
          "path": "skills/speckit-implement-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-implement-zh/SKILL.md",
          "type": "blob",
          "size": 7504
        },
        {
          "path": "skills/speckit-implement-zh/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-implement-zh/references/context-loading-order.md",
          "type": "blob",
          "size": 1721
        },
        {
          "path": "skills/speckit-implement-zh/references/ignore-patterns.md",
          "type": "blob",
          "size": 1453
        },
        {
          "path": "skills/speckit-implement-zh/references/implementation-workflow.md",
          "type": "blob",
          "size": 1511
        },
        {
          "path": "skills/speckit-plan-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/SKILL.md",
          "type": "blob",
          "size": 2941
        },
        {
          "path": "skills/speckit-plan-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/assets/key-rules.md",
          "type": "blob",
          "size": 206
        },
        {
          "path": "skills/speckit-plan-zh/assets/phase0-research.md",
          "type": "blob",
          "size": 712
        },
        {
          "path": "skills/speckit-plan-zh/assets/phase1-design.md",
          "type": "blob",
          "size": 816
        },
        {
          "path": "skills/speckit-plan-zh/assets/plan-template.md",
          "type": "blob",
          "size": 3579
        },
        {
          "path": "skills/speckit-plan-zh/assets/setup-workflow.md",
          "type": "blob",
          "size": 544
        },
        {
          "path": "skills/speckit-plan-zh/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-plan-zh/references/technical-context.md",
          "type": "blob",
          "size": 1613
        },
        {
          "path": "skills/speckit-specify-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/SKILL.md",
          "type": "blob",
          "size": 11026
        },
        {
          "path": "skills/speckit-specify-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/clarification-template.md",
          "type": "blob",
          "size": 536
        },
        {
          "path": "skills/speckit-specify-zh/assets/quality-checklist-template.md",
          "type": "blob",
          "size": 1005
        },
        {
          "path": "skills/speckit-specify-zh/assets/spec-template.md",
          "type": "blob",
          "size": 3521
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/memory/constitution.md",
          "type": "blob",
          "size": 2047
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/agent-file-template.md",
          "type": "blob",
          "size": 433
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/checklist-template.md",
          "type": "blob",
          "size": 1255
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/analyze.md",
          "type": "blob",
          "size": 6582
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/checklist.md",
          "type": "blob",
          "size": 15507
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/clarify.md",
          "type": "blob",
          "size": 10219
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/constitution.md",
          "type": "blob",
          "size": 4629
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/implement.md",
          "type": "blob",
          "size": 7211
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/plan.md",
          "type": "blob",
          "size": 2973
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/specify.md",
          "type": "blob",
          "size": 11279
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/commands/tasks.md",
          "type": "blob",
          "size": 6005
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/constitution-template.md",
          "type": "blob",
          "size": 2047
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/plan-template.md",
          "type": "blob",
          "size": 3579
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/spec-template.md",
          "type": "blob",
          "size": 3521
        },
        {
          "path": "skills/speckit-specify-zh/assets/specify/templates/tasks-template.md",
          "type": "blob",
          "size": 8682
        },
        {
          "path": "skills/speckit-tasks-zh",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-tasks-zh/SKILL.md",
          "type": "blob",
          "size": 6330
        },
        {
          "path": "skills/speckit-tasks-zh/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/speckit-tasks-zh/assets/TASK_EXAMPLES.md",
          "type": "blob",
          "size": 3046
        },
        {
          "path": "skills/speckit-tasks-zh/assets/WORKFLOW.md",
          "type": "blob",
          "size": 2898
        },
        {
          "path": "skills/speckit-tasks-zh/assets/tasks-template.md",
          "type": "blob",
          "size": 2164
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"open-skilled-sdd-marketplace\",\n  \"owner\": {\n    \"name\": \"forztf\"\n  },\n  \"description\": \"Official marketplace for Open Spec-Driven Development Claude Code plugin\",\n  \"plugins\": [\n    {\n      \"name\": \"open-skilled-sdd\",\n      \"source\": \"./\",\n      \"description\": \"open spec-driven development workflow: OpenSpec, PRPs, Spec Kit, spec-workflow-mcp, BMad-Method, 6A workflow\"\n    }\n  ]\n}",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"open-skilled-sdd\",\n  \"description\": \"Open Spec-driven development workflow for Claude Code: OpenSpec, PRPs, Spec Kit, spec-workflow-mcp, BMad-Method, 6A workflow.\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"forztf\"\n  },\n  \"homepage\": \"https://github.com/forztf/open-skilled-sdd\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"specifications\",\n    \"spec-driven\",\n    \"requirements\",\n    \"EARS\",\n    \"workflow\",\n    \"testing\",\n    \"documentation\"\n  ],\n  \"skills\": [\n    \"./skills/openspec-proposal-creation-cn\",\n    \"./skills/openspec-implementation-cn\",\n    \"./skills/openspec-archiving-cn\",\n    \"./skills/openspec-context-loading-cn\",\n    \"./skills/openspec-proposal-creation\",\n    \"./skills/openspec-implementation\",\n    \"./skills/openspec-archiving\",\n    \"./skills/openspec-context-loading\",\n    \"./skills/speckit-constitution-zh\",\n    \"./skills/speckit-specify-zh\",\n    \"./skills/speckit-clarify-zh\",\n    \"./skills/speckit-plan-zh\",\n    \"./skills/speckit-tasks-zh\",\n    \"./skills/speckit-analyze-zh\",\n    \"./skills/speckit-checklist-zh\",\n    \"./skills/speckit-implement-zh\"\n  ]\n}\n",
        "skills/openspec-archiving-cn/SKILL.md": "---\nname: openspec-archiving-cn\ndescription: 归档已完成的变更并将规范差异合并到常驻文档。用于变更已部署、准备归档或实施后需要更新规范时。触发词包括 \"openspec归档\", \"归档\", \"归档提案\", \"合并规范\", \"完成提案\", \"更新文档\", \"定稿规范\", \"标记完成\"。\n---\n\n# 规范归档\n\n归档已完成的变更提案，并将其规范差异合并到常驻规范文档中。\n\n## 快速开始\n\n归档包含两项主要操作：\n1. **移动变更目录**至带时间戳的归档位置\n2. **合并规范差异**到常驻规范（ADDED/MODIFIED/REMOVED）\n\n**关键规则**：在归档前验证所有任务已完成。归档意味着已部署且完成。\n\n## 工作流\n\n复制此清单并跟踪进度：\n\n```\n归档进度:\n- [ ] 第 1 步：验证实施完成\n- [ ] 第 2 步：审阅待合并的规范差异\n- [ ] 第 3 步：创建带时间戳的归档目录\n- [ ] 第 4 步：合并 ADDED 需求到常驻规范\n- [ ] 第 5 步：合并 MODIFIED 需求到常驻规范\n- [ ] 第 6 步：合并 REMOVED 需求到常驻规范\n- [ ] 第 7 步：移动变更目录到归档\n- [ ] 第 8 步：验证常驻规范结构\n```\n\n### 第 1 步：验证实施完成\n\n在归档前确认所有工作已完成：\n\n```bash\n# 检查 IMPLEMENTED 标记\ntest -f spec/changes/{change-id}/IMPLEMENTED && echo \"✓ 已实施\" || echo \"✗ 未实施\"\n\n# 查看任务\ncat spec/changes/{change-id}/tasks.json\n\n# 使用 git 检查未提交工作\ngit status\n```\n\n**询问用户**：\n```markdown\n所有任务是否已完成并通过测试？\n该变更是否已部署到生产？\n是否继续归档？\n```\n\n### 第 2 步：审阅待合并的规范差异\n\n了解需要合并的内容：\n\n```bash\n# 列出所有规范差异文件\nfind spec/changes/{change-id}/specs -name \"*.md\" -type f\n\n# 读取每个差异文件\nfor file in spec/changes/{change-id}/specs/**/*.md; do\n    echo \"=== $file ===\"\n    cat \"$file\"\ndone\n```\n\n**识别**：\n- 哪些能力受到影响\n- ADDED/MODIFIED/REMOVED 各有多少需求\n- 这些变更在常驻规范中的归属位置\n\n### 第 3 步：创建带时间戳的归档目录\n\n```bash\n# 以当天日期创建归档目录\nTIMESTAMP=$(date +%Y-%m-%d)\nmkdir -p spec/archive/${TIMESTAMP}-{change-id}\n```\n\n**示例**：\n```bash\n# 对 2025-10-26 归档的 \"add-user-auth\" 变更\nmkdir -p spec/archive/2025-10-26-add-user-auth\n```\n\n### 第 4 步：合并 ADDED 需求到常驻规范\n\n对每个 `## ADDED Requirements` 部分：\n\n**流程**：\n1. 定位目标常驻规范文件\n2. 将新增需求追加到文件末尾\n3. 保持正确的 Markdown 格式\n\n**示例**：\n\n**来源**（`spec/changes/add-user-auth/specs/authentication/spec-delta.md`）：\n```markdown\n## ADDED Requirements\n\n### Requirement: 用户登录\nWHEN 用户提交有效凭据,\n系统 SHALL 认证用户并创建会话。\n\n#### Scenario: 登录成功\nGIVEN 有效的凭据\nWHEN 用户提交登录表单\nTHEN 系统创建会话\n```\n\n**目标**（`spec/specs/authentication/spec.md`）：\n```bash\n# 追加到常驻规范\ncat >> spec/specs/authentication/spec.md << 'EOF'\n\n### Requirement: 用户登录\nWHEN 用户提交有效凭据,\n系统 SHALL 认证用户并创建会话。\n\n#### Scenario: 登录成功\nGIVEN 有效的凭据\nWHEN 用户提交登录表单\nTHEN 系统创建会话\nEOF\n```\n\n### 第 5 步：合并 MODIFIED 需求到常驻规范\n\n对每个 `## MODIFIED Requirements` 部分：\n\n**流程**：\n1. 在常驻规范中定位现有需求\n2. 替换**整个**需求块（包括全部场景）\n3. 使用差异文件中的完整更新文本\n\n**示例（使用 sed）**：\n\n```bash\n# 查找并替换需求块\n# 这是概念示例——实际实现取决于结构\n\n# 首先，确定旧需求的起始行\nSTART_LINE=$(grep -n \"### Requirement: 用户登录\" spec/specs/authentication/spec.md | cut -d: -f1)\n\n# 查找结束位置（下一个需求或文件末尾）\nEND_LINE=$(tail -n +$((START_LINE + 1)) spec/specs/authentication/spec.md | \\\n           grep -n \"^### Requirement:\" | head -1 | cut -d: -f1)\n\n# 删除旧需求\nsed -i \"${START_LINE},${END_LINE}d\" spec/specs/authentication/spec.md\n\n# 在相同位置插入新需求\n#（从差异文件提取并插入）\n```\n\n**手动方式**（出于安全建议）：\n```markdown\n1. 在编辑器中打开常驻规范\n2. 通过名称查找目标需求\n3. 删除整个块（需求 + 所有场景）\n4. 将差异文件中的更新需求粘贴到该处\n5. 保存\n```\n\n### 第 6 步：合并 REMOVED 需求到常驻规范\n\n对每个 `## REMOVED Requirements` 部分：\n\n**流程**：\n1. 在常驻规范中定位该需求\n2. 删除整个需求块\n3. 添加一条注释记录移除\n\n**示例**：\n\n```bash\n# 方案 1：带注释删除\n# 手动编辑 spec/specs/authentication/spec.md\n\n# 添加弃用注释\necho \"<!-- Requirement 'Legacy Password Reset' removed $(date +%Y-%m-%d) -->\" >> spec/specs/authentication/spec.md\n\n# 通过手动或 sed 删除该需求块\n```\n\n**模式**：\n```markdown\n<!-- Removed 2025-10-26: 用户需使用基于邮件的密码重置 -->\n~~### Requirement: SMS Password Reset~~\n```\n\n### 第 7 步：将变更目录移动到归档\n\n在所有差异合并后：\n\n```bash\n# 将完整的变更目录移动到归档\nmv spec/changes/{change-id} spec/archive/${TIMESTAMP}-{change-id}\n```\n\n**验证移动成功**：\n```bash\n# 检查归档是否存在\nls -la spec/archive/${TIMESTAMP}-{change-id}\n\n# 检查 changes 目录是否干净\nls spec/changes/ | grep \"{change-id}\"  # 应无结果\n```\n\n### 第 8 步：验证常驻规范结构\n\n在合并后，验证常驻规范的完整性：\n\n```bash\n# 检查需求格式\ngrep -n \"### Requirement:\" spec/specs/**/*.md\n\n# 检查场景格式\ngrep -n \"#### Scenario:\" spec/specs/**/*.md\n\n# 统计每个规范中的需求数量\nfor spec in spec/specs/**/spec.md; do\n    count=$(grep -c \"### Requirement:\" \"$spec\")\n    echo \"$spec: $count 条需求\"\ndone\n```\n\n**手动审阅**：\n- 打开每个被修改的规范文件\n- 验证 Markdown 格式正确\n- 检查需求逻辑是否连贯\n- 确保不存在重复需求\n\n## 合并逻辑参考\n\n### ADDED 操作\n\n```\n动作：追加到常驻规范\n位置：文件末尾（任何页脚/附录之前）\n格式：按原文复制需求与全部场景\n```\n\n### MODIFIED 操作\n\n```\n动作：替换现有需求\n位置：通过需求名称定位，替换整个块\n格式：使用差异文件的完整更新文本（不拼接，直接替换）\n说明：旧版本保留在归档中\n```\n\n### REMOVED 操作\n\n```\n动作：删除需求，并添加弃用注释\n位置：通过需求名称定位\n格式：删除整个块，可选添加 <!-- Removed YYYY-MM-DD: reason -->\n```\n\n### RENAMED 操作（不常见）\n\n```\n动作：更新需求名称，保留内容\n位置：通过旧名称定位，更新为新名称\n格式：仅修改标题：### Requirement: 新名称\n说明：通常使用 MODIFIED 更为常见\n```\n\n## 最佳实践\n\n### 模式 1：移动前先验证\n\n**务必**在移动到归档前验证差异合并：\n\n```bash\n# 合并后查看差异\ngit diff spec/specs/\n\n# 审阅变更\ngit diff spec/specs/authentication/spec.md\n\n# 若正确则提交\ngit add spec/specs/\ngit commit -m \"Merge spec deltas from add-user-auth\"\n\n# 然后再归档\nmv spec/changes/add-user-auth spec/archive/2025-10-26-add-user-auth\n```\n\n### 模式 2：原子化归档\n\n归档整个变更，而非单个文件：\n\n**好**：\n```bash\n# 移动完整变更目录\nmv spec/changes/add-user-auth spec/archive/2025-10-26-add-user-auth\n```\n\n**坏**：\n```bash\n# 不要挑拣文件\nmv spec/changes/add-user-auth/proposal.md spec/archive/\n#（会留下孤儿文件）\n```\n\n### 模式 3：归档保全\n\n归档是历史记录。切勿修改归档文件：\n\n```markdown\n❌ 不要：编辑 spec/archive/\n✓ 要：将归档视为只读历史\n```\n\n### 模式 4：Git 提交策略\n\n推荐提交流程：\n\n```bash\n# 提交 1：合并差异\ngit add spec/specs/\ngit commit -m \"Merge spec deltas from add-user-auth\n\n- Added User Login requirement\n- Modified Password Policy requirement\n- Removed Legacy Auth requirement\"\n\n# 提交 2：归档变更\ngit add spec/archive/ spec/changes/\ngit commit -m \"Archive add-user-auth change\"\n```\n\n## 进阶主题\n\n**复杂差异**：见 [reference/MERGE_LOGIC.md](reference/MERGE_LOGIC.md)\n\n**冲突解决**：若多个变更修改同一需求，需手动合并。\n\n**回滚策略**：若需回滚归档，反向执行流程（从归档移回 changes，并从常驻规范移除已合并内容）。\n\n## 常见模式\n\n### 模式 1：简单新增\n\n```markdown\n变更新增 1 条需求 → 追加到规范 → 归档\n```\n\n### 模式 2：行为变更\n\n```markdown\n变更修改 1 条需求 → 在规范中替换 → 归档\n```\n\n### 模式 3：弃用\n\n```markdown\n变更移除 1 条需求 → 删除并添加注释 → 归档\n```\n\n### 模式 4：多需求的功能\n\n```markdown\n变更在 2 个规范中新增 5 条需求\n→ 分别追加到相应规范\n→ 验证全部已合并\n→ 归档\n```\n\n## 反模式避免\n\n**不要**：\n- 归档未完成的实施\n- 在部署前合并差异\n- 修改归档文件\n- 跳过合并后的验证\n- 忘记在合并规范后进行 git 提交\n\n**要**：\n- 在归档前验证所有任务完成\n- 小心且完整地合并差异\n- 将归档视为不可变历史\n- 验证合并后规范结构\n- 在归档移动前提交合并后的规范\n\n## 故障排查\n\n### 问题：合并冲突（常驻规范已有该需求）\n\n**解决方案**：\n```markdown\n1. 若名称相同但内容不同 → 使用 MODIFIED 模式\n2. 若确实是不同需求 → 重命名其中之一\n3. 若属重复错误 → 选择正确版本\n```\n\n### 问题：找不到需要修改/移除的需求\n\n**解决方案**：\n```markdown\n1. 按部分名称搜索：grep -i \"login\" spec/specs/**/*.md\n2. 检查是否已被移除\n3. 检查是否位于其他能力文件\n```\n\n### 问题：合并后常驻规范格式错误\n\n**解决方案**：\n```markdown\n1. 手动修复格式\n2. 重新运行验证：grep -n \"###\" spec/specs/**/*.md\n3. 确保标题层级一致\n```\n\n## 参考资料\n\n- [MERGE_LOGIC.md](reference/MERGE_LOGIC.md) - 详细的合并操作规则\n\n---\n\n**Token 预算**：此 SKILL.md 约 430 行，低于建议的 500 行上限。",
        "skills/openspec-archiving/SKILL.md": "---\nname: openspec-archiving\ndescription: Archives completed changes and merges specification deltas into living documentation. Use when changes are deployed, ready to archive, or specs need updating after implementation. Triggers include \"openspec archive\", \"archive change\", \"merge specs\", \"complete proposal\", \"update documentation\", \"finalize spec\", \"mark as done\".\n---\n\n# Specification Archiving\n\nArchives completed change proposals and merges their spec deltas into the living specification documentation.\n\n## Quick Start\n\nArchiving involves two main operations:\n1. **Move change folder** to archive with timestamp\n2. **Merge spec deltas** into living specs (ADDED/MODIFIED/REMOVED operations)\n\n**Critical rule**: Verify all tasks are complete before archiving. Archiving signifies deployment and completion.\n\n## Workflow\n\nCopy this checklist and track progress:\n\n```\nArchive Progress:\n- [ ] Step 1: Verify implementation is complete\n- [ ] Step 2: Review spec deltas to merge\n- [ ] Step 3: Create timestamped archive directory\n- [ ] Step 4: Merge ADDED requirements into living specs\n- [ ] Step 5: Merge MODIFIED requirements into living specs\n- [ ] Step 6: Merge REMOVED requirements into living specs\n- [ ] Step 7: Move change folder to archive\n- [ ] Step 8: Validate living spec structure\n```\n\n### Step 1: Verify implementation is complete\n\nBefore archiving, confirm all work is done:\n\n```bash\n# Check for IMPLEMENTED marker\ntest -f spec/changes/{change-id}/IMPLEMENTED && echo \"✓ Implemented\" || echo \"✗ Not implemented\"\n\n# Review tasks\ncat spec/changes/{change-id}/tasks.md\n\n# Check git status for uncommitted work\ngit status\n```\n\n**Ask the user**:\n```markdown\nAre all tasks complete and tested?\nHas this change been deployed to production?\nShould I proceed with archiving?\n```\n\n### Step 2: Review spec deltas to merge\n\nUnderstand what will be merged:\n\n```bash\n# List all spec delta files\nfind spec/changes/{change-id}/specs -name \"*.md\" -type f\n\n# Read each delta\nfor file in spec/changes/{change-id}/specs/**/*.md; do\n    echo \"=== $file ===\"\n    cat \"$file\"\ndone\n```\n\n**Identify**:\n- Which capabilities are affected\n- How many requirements are ADDED/MODIFIED/REMOVED\n- Where in living specs these changes belong\n\n### Step 3: Create timestamped archive directory\n\n```bash\n# Create archive with today's date\nTIMESTAMP=$(date +%Y-%m-%d)\nmkdir -p spec/archive/${TIMESTAMP}-{change-id}\n```\n\n**Example**:\n```bash\n# For change \"add-user-auth\" archived on Oct 26, 2025\nmkdir -p spec/archive/2025-10-26-add-user-auth\n```\n\n### Step 4: Merge ADDED requirements into living specs\n\nFor each `## ADDED Requirements` section:\n\n**Process**:\n1. Locate the target living spec file\n2. Append the new requirements to the end of the file\n3. Maintain proper markdown formatting\n\n**Example**:\n\n**Source** (`spec/changes/add-user-auth/specs/authentication/spec-delta.md`):\n```markdown\n## ADDED Requirements\n\n### Requirement: User Login\nWHEN a user submits valid credentials,\nthe system SHALL authenticate the user and create a session.\n\n#### Scenario: Successful Login\nGIVEN valid credentials\nWHEN user submits login form\nTHEN system creates session\n```\n\n**Target** (`spec/specs/authentication/spec.md`):\n```bash\n# Append to living spec\ncat >> spec/specs/authentication/spec.md << 'EOF'\n\n### Requirement: User Login\nWHEN a user submits valid credentials,\nthe system SHALL authenticate the user and create a session.\n\n#### Scenario: Successful Login\nGIVEN valid credentials\nWHEN user submits login form\nTHEN system creates session\nEOF\n```\n\n### Step 5: Merge MODIFIED requirements into living specs\n\nFor each `## MODIFIED Requirements` section:\n\n**Process**:\n1. Locate the existing requirement in the living spec\n2. Replace the ENTIRE requirement block (including all scenarios)\n3. Use the complete updated text from the delta\n\n**Example using sed**:\n\n```bash\n# Find and replace requirement block\n# This is conceptual - actual implementation depends on structure\n\n# First, identify the line range of the old requirement\nSTART_LINE=$(grep -n \"### Requirement: User Login\" spec/specs/authentication/spec.md | cut -d: -f1)\n\n# Find the end (next requirement or end of file)\nEND_LINE=$(tail -n +$((START_LINE + 1)) spec/specs/authentication/spec.md | \\\n           grep -n \"^### Requirement:\" | head -1 | cut -d: -f1)\n\n# Delete old requirement\nsed -i \"${START_LINE},${END_LINE}d\" spec/specs/authentication/spec.md\n\n# Insert new requirement at same position\n# (Extract from delta and insert)\n```\n\n**Manual approach** (recommended for safety):\n```markdown\n1. Open living spec in editor\n2. Find the requirement by name\n3. Delete entire block (requirement + all scenarios)\n4. Paste updated requirement from delta\n5. Save\n```\n\n### Step 6: Merge REMOVED requirements into living specs\n\nFor each `## REMOVED Requirements` section:\n\n**Process**:\n1. Locate the requirement in the living spec\n2. Delete the entire requirement block\n3. Add a comment documenting the removal\n\n**Example**:\n\n```bash\n# Option 1: Delete with comment\n# Manually edit spec/specs/authentication/spec.md\n\n# Add deprecation comment\necho \"<!-- Requirement 'Legacy Password Reset' removed $(date +%Y-%m-%d) -->\" >> spec/specs/authentication/spec.md\n\n# Delete the requirement block manually or with sed\n```\n\n**Pattern**:\n```markdown\n<!-- Removed 2025-10-26: User must use email-based password reset -->\n~~### Requirement: SMS Password Reset~~\n```\n\n### Step 7: Move change folder to archive\n\nAfter all deltas are merged:\n\n```bash\n# Move entire change folder to archive\nmv spec/changes/{change-id} spec/archive/${TIMESTAMP}-{change-id}\n```\n\n**Verify move succeeded**:\n```bash\n# Check archive exists\nls -la spec/archive/${TIMESTAMP}-{change-id}\n\n# Check changes directory is clean\nls spec/changes/ | grep \"{change-id}\"  # Should return nothing\n```\n\n### Step 8: Validate living spec structure\n\nAfter merging, validate the living specs are well-formed:\n\n```bash\n# Check requirement format\ngrep -n \"### Requirement:\" spec/specs/**/*.md\n\n# Check scenario format\ngrep -n \"#### Scenario:\" spec/specs/**/*.md\n\n# Count requirements per spec\nfor spec in spec/specs/**/spec.md; do\n    count=$(grep -c \"### Requirement:\" \"$spec\")\n    echo \"$spec: $count requirements\"\ndone\n```\n\n**Manual review**:\n- Open each modified spec file\n- Verify markdown formatting is correct\n- Check requirements flow logically\n- Ensure no duplicate requirements exist\n\n## Merge Logic Reference\n\n### ADDED Operation\n\n```\nAction: Append to living spec\nLocation: End of file (before any footer/appendix)\nFormat: Copy requirement + all scenarios exactly as written\n```\n\n### MODIFIED Operation\n\n```\nAction: Replace existing requirement\nLocation: Find by requirement name, replace entire block\nFormat: Use complete updated text from delta (don't merge, replace)\nNote: Old version is preserved in archive\n```\n\n### REMOVED Operation\n\n```\nAction: Delete requirement, add deprecation comment\nLocation: Find by requirement name\nFormat: Delete entire block, optionally add <!-- Removed YYYY-MM-DD: reason -->\n```\n\n### RENAMED Operation (uncommon)\n\n```\nAction: Update requirement name, keep content\nLocation: Find by old name, update to new name\nFormat: Just change the header: ### Requirement: NewName\nNote: Typically use MODIFIED instead\n```\n\n## Best Practices\n\n### Pattern 1: Verify Before Moving\n\n**Always** verify delta merges before moving to archive:\n\n```bash\n# After merging, check diff\ngit diff spec/specs/\n\n# Review changes\ngit diff spec/specs/authentication/spec.md\n\n# If correct, commit\ngit add spec/specs/\ngit commit -m \"Merge spec deltas from add-user-auth\"\n\n# Then archive\nmv spec/changes/add-user-auth spec/archive/2025-10-26-add-user-auth\n```\n\n### Pattern 2: Atomic Archiving\n\nArchive entire changes, not individual files:\n\n**Good**:\n```bash\n# Move complete change folder\nmv spec/changes/add-user-auth spec/archive/2025-10-26-add-user-auth\n```\n\n**Bad**:\n```bash\n# Don't cherry-pick files\nmv spec/changes/add-user-auth/proposal.md spec/archive/\n# (leaves orphaned files)\n```\n\n### Pattern 3: Archive Preservation\n\nThe archive is a historical record. Never modify archived files:\n\n```markdown\n❌ Don't: Edit files in spec/archive/\n✓ Do: Treat archive as read-only history\n```\n\n### Pattern 4: Git Commit Strategy\n\nRecommended commit workflow:\n\n```bash\n# Commit 1: Merge deltas\ngit add spec/specs/\ngit commit -m \"Merge spec deltas from add-user-auth\n\n- Added User Login requirement\n- Modified Password Policy requirement\n- Removed Legacy Auth requirement\"\n\n# Commit 2: Archive change\ngit add spec/archive/ spec/changes/\ngit commit -m \"Archive add-user-auth change\"\n```\n\n## Advanced Topics\n\n**For complex deltas**: See [reference/MERGE_LOGIC.md](reference/MERGE_LOGIC.md)\n\n**Conflict resolution**: If multiple changes modified the same requirement, manual merge is required.\n\n**Rollback strategy**: To rollback an archive, reverse the process (move from archive back to changes, remove merged content from living specs).\n\n## Common Patterns\n\n### Pattern 1: Simple Addition\n\n```markdown\nChange adds 1 new requirement → Append to spec → Archive\n```\n\n### Pattern 2: Behavioral Change\n\n```markdown\nChange modifies 1 requirement → Replace in spec → Archive\n```\n\n### Pattern 3: Deprecation\n\n```markdown\nChange removes 1 requirement → Delete from spec with comment → Archive\n```\n\n### Pattern 4: Feature with Multiple Requirements\n\n```markdown\nChange adds 5 requirements across 2 specs\n→ Append each to respective spec\n→ Verify all are merged\n→ Archive\n```\n\n## Anti-Patterns to Avoid\n\n**Don't**:\n- Archive incomplete implementations\n- Merge deltas before deployment\n- Modify archived files\n- Skip validation after merging\n- Forget to git commit merged specs\n\n**Do**:\n- Verify all tasks complete before archiving\n- Merge deltas carefully and completely\n- Treat archive as immutable history\n- Validate merged specs structure\n- Commit merged specs before archiving move\n\n## Troubleshooting\n\n### Issue: Merge conflict (requirement exists in living spec)\n\n**Solution**:\n```markdown\n1. If names match but content differs → Use MODIFIED pattern\n2. If truly different requirements → Rename one\n3. If duplicate by mistake → Use whichever is correct\n```\n\n### Issue: Can't find requirement to modify/remove\n\n**Solution**:\n```markdown\n1. Search by partial name: grep -i \"login\" spec/specs/**/*.md\n2. Check if already removed\n3. Check if in different capability file\n```\n\n### Issue: Living spec has formatting errors after merge\n\n**Solution**:\n```markdown\n1. Fix formatting manually\n2. Re-run validation: grep -n \"###\" spec/specs/**/*.md\n3. Ensure consistent heading levels\n```\n\n## Reference Materials\n\n- [MERGE_LOGIC.md](reference/MERGE_LOGIC.md) - Detailed merge operation rules\n\n---\n\n**Token budget**: This SKILL.md is approximately 480 lines, under the 500-line recommended limit.\n",
        "skills/openspec-context-loading-cn/SKILL.md": "---\nname: openspec-context-loading-cn\ndescription: 加载项目上下文，列出现有规范与变更，搜索能力与需求。用于用户询问项目状态、现有规范、进行中的变更、可用能力或需要发现上下文时。触发词包括\"openspec上下文\", \"有哪些规范\", \"显示变更\", \"列出能力\", \"项目上下文\", \"查找规范\", \"规范包含什么\", \"展示规范\"。\n---\n\n# 规范上下文加载\n\n发现并加载项目规范、进行中的变更和需求，以提供上下文。\n\n## 快速开始\n\n上下文加载可帮助回答：\n- 项目有哪些规范？\n- 目前有哪些进行中的变更？\n- 已定义了哪些需求？\n- 系统具备哪些能力？\n- 某项功能在何处有所规范？\n\n**基本模式**：搜索 → 阅读 → 总结\n\n## 发现命令\n\n注意将控制台与管道输出编码统一为 UTF-8，确保中文字符正确显示。\n\n### 列出所有规范\n\n```bash\n# 查找所有规范文件\nfind spec/specs -name \"spec.md\" -type f\n\n# 查找所有能力目录\nfind spec/specs -mindepth 1 -maxdepth 1 -type d\n\n# 显示规范树\ntree spec/specs/  # 若已安装 tree\n# 或\nls -R spec/specs/\n```\n\n**输出格式**：\n```\nspec/specs/\n├── authentication/\n│   └── spec.md\n├── billing/\n│   └── spec.md\n└── notifications/\n    └── spec.md\n```\n\n### 列出进行中的变更\n\n```bash\n# 显示所有进行中的变更\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | sort\n\n# 显示修改时间\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" -exec ls -ld {} \\;\n\n# 统计进行中的变更数量\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | wc -l\n```\n\n### 列出已归档的变更\n\n```bash\n# 显示所有已归档变更\nls -1 spec/archive/\n\n# 显示日期\nls -la spec/archive/\n\n# 查找最近 7 天归档的变更\nfind spec/archive/ -maxdepth 1 -type d -mtime -7\n```\n\n### 搜索需求\n\n```bash\n# 查找所有需求\ngrep -r \"### Requirement:\" spec/specs/\n\n# 在特定能力中查找需求\ngrep \"### Requirement:\" spec/specs/authentication/spec.md\n\n# 列出唯一需求名称\ngrep -h \"### Requirement:\" spec/specs/**/*.md | sed 's/### Requirement: //' | sort\n```\n\n### 搜索场景\n\n```bash\n# 查找所有场景\ngrep -r \"#### Scenario:\" spec/specs/\n\n# 统计每个规范中的场景数量\nfor spec in spec/specs/**/spec.md; do\n    count=$(grep -c \"#### Scenario:\" \"$spec\")\n    echo \"$spec: $count scenarios\"\ndone\n```\n\n### 关键词搜索\n\n```bash\n# 查找提到 \"authentication\" 的规范\ngrep -r -i \"authentication\" spec/specs/\n\n# 查找与 \"password\" 相关的需求\ngrep -B 1 -A 5 -i \"password\" spec/specs/**/*.md | grep -A 5 \"### Requirement:\"\n\n# 查找提到 \"error\" 的场景\ngrep -B 1 -A 10 -i \"error\" spec/specs/**/*.md | grep -A 10 \"#### Scenario:\"\n```\n\n## 常见查询\n\n### 查询 1：\"项目有哪些规范？\"\n\n```bash\n# 列出所有能力\nfind spec/specs -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;\n\n# 统计每个能力的需求数量\nfor cap in spec/specs/*/; do\n    name=$(basename \"$cap\")\n    count=$(grep -c \"### Requirement:\" \"$cap/spec.md\" 2>/dev/null || echo \"0\")\n    echo \"$name: $count requirements\"\ndone\n```\n\n**响应格式**：\n```markdown\n## 现有规范\n\n项目具备以下能力的规范：\n\n- **authentication**：8 条需求\n- **billing**：12 条需求\n- **notifications**：5 条需求\n\n合计：3 个能力，25 条需求\n```\n\n### 查询 2：\"当前有哪些变更在进行？\"\n\n```bash\n# 附带提案摘要的列表\nfor change in spec/changes/*/; do\n    if [ \"$change\" != \"spec/changes/archive/\" ]; then\n        id=$(basename \"$change\")\n        echo \"=== $id ===\"\n        head -n 20 \"$change/proposal.md\" | grep -A 3 \"## Why\"\n    fi\ndone\n```\n\n**响应格式**：\n```markdown\n## 进行中的变更\n\n当前进行中的变更：\n\n### add-user-auth\n**Why**：用户需要安全的认证...\n\n### update-billing-api\n**Why**：支付处理需要 v2 API...\n\n合计：2 个进行中变更\n```\n\n### 查询 3：\"查找 authentication 规范\"\n\n```bash\n# 阅读完整规范\ncat spec/specs/authentication/spec.md\n\n# 或展示摘要\necho \"需求：\"\ngrep \"### Requirement:\" spec/specs/authentication/spec.md\n\necho \"场景：\"\ngrep \"#### Scenario:\" spec/specs/authentication/spec.md\n```\n\n**响应格式**：\n```markdown\n## Authentication 规范\n\n（包含 spec.md 的完整内容）\n\n摘要：\n- 8 条需求\n- 16 个场景\n- 最近修改时间：[来自 git log 的日期]\n```\n\n### 查询 4：\"查找与 password 相关的规范\"\n\n```bash\n# 关键词搜索\ngrep -r -i \"password\" spec/specs/ -A 5\n\n# 显示提到该关键词的规范\ngrep -r -i \"password\" spec/specs/ -l\n```\n\n**响应格式**：\n```markdown\n## Specs Mentioning \"Password\"\n\n发现于：\n- spec/specs/authentication/spec.md（3 条需求）\n- spec/specs/security/spec.md（1 条需求）\n\n相关需求：\n### Requirement: Password Validation\n### Requirement: Password Reset\n### Requirement: Password Strength\n```\n\n### 查询 5：\"变更 X 的具体内容是什么？\"\n\n```bash\n# 展示完整的变更上下文\nCHANGE_ID=\"add-user-auth\"\n\necho \"=== 提案 ===\"\ncat spec/changes/$CHANGE_ID/proposal.md\n\necho \"\\n=== 任务 ===\"\ncat spec/changes/$CHANGE_ID/tasks.json\n\necho \"\\n=== 规范变更 ===\"\nfind spec/changes/$CHANGE_ID/specs -name \"*.md\" -exec echo \"File: {}\" \\; -exec cat {} \\;\n```\n\n## 仪表盘视图\n\n创建全面的项目概览：\n\n```bash\n#!/bin/bash\n# 项目规范仪表盘\n\necho \"===  规范仪表盘 ===\"\necho \"\"\n\n# 能力\necho \"## 能力\"\nCAPS=$(find spec/specs -mindepth 1 -maxdepth 1 -type d | wc -l)\necho \"能力总数: $CAPS\"\nfor cap in spec/specs/*/; do\n    name=$(basename \"$cap\")\n    reqs=$(grep -c \"### Requirement:\" \"$cap/spec.md\" 2>/dev/null || echo \"0\")\n    echo \"  - $name: $reqs 条需求\"\ndone\necho \"\"\n\n# 需求\necho \"## 需求\"\nTOTAL_REQS=$(grep -r \"### Requirement:\" spec/specs/ | wc -l)\nTOTAL_SCENARIOS=$(grep -r \"#### Scenario:\" spec/specs/ | wc -l)\necho \"需求总数: $TOTAL_REQS\"\necho \"场景总数: $TOTAL_SCENARIOS\"\necho \"每个需求平均场景数: $(echo \"scale=1; $TOTAL_SCENARIOS/$TOTAL_REQS\" | bc)\"\necho \"\"\n\n# 变更\necho \"## 变更\"\nACTIVE=$(find spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | wc -l)\nARCHIVED=$(ls -1 spec/archive/ | wc -l)\necho \"进行中的变更: $ACTIVE\"\necho \"已归档的变更: $ARCHIVED\"\necho \"\"\n\n# 最近活动\necho \"## 最近活动\"\necho \"最近修改的规范:\"\nfind spec/specs -name \"spec.md\" -type f -exec ls -lt {} \\; | head -5\n```\n\n**响应格式**：\n```markdown\n# Specification Dashboard\n\n## Capabilities\nTotal capabilities: 3\n  - authentication: 8 requirements\n  - billing: 12 requirements\n  - notifications: 5 requirements\n\n## Requirements\nTotal requirements: 25\nTotal scenarios: 52\nAvg scenarios per requirement: 2.1\n\n## Changes\nActive changes: 2\nArchived changes: 15\n\n## Recent Activity\nRecently modified specs:\n- spec/specs/billing/spec.md（2 天前）\n- spec/specs/authentication/spec.md（1 周前）\n```\n\n## 高级查询\n\n### 查找相关需求\n\n```bash\n# 查找提到其他需求的内容\ngrep -r \"User Login\" spec/specs/ -A 10 | grep \"### Requirement:\"\n\n# 查找交叉引用\ngrep -r \"See Requirement:\" spec/specs/\n```\n\n### 分析覆盖度\n\n```bash\n# 查找无场景的需求\nfor spec in spec/specs/**/spec.md; do\n    awk '/### Requirement:/ {req=$0; getline; if ($0 !~ /#### Scenario:/) print req}' \"$spec\"\ndone\n\n# 查找不包含完整 Given/When/Then 的场景\ngrep -A 5 \"#### Scenario:\" spec/specs/**/*.md | grep -v \"GIVEN\\|WHEN\\|THEN\"\n```\n\n### 对比进行中与已归档\n\n```bash\n# 展示时间演化\necho \"归档历史:\"\nls -1 spec/archive/ | head -10\n\necho \"最近归档 (30天):\"\nfind spec/archive/ -maxdepth 1 -type d -mtime -30 -exec basename {} \\;\n```\n\n## 搜索模式\n\n### 模式 1：能力发现\n\n用户提问：\"系统能做什么？\"\n\n```bash\n# 列出能力\nfind spec/specs -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;\n\n# 展示高层需求\nfor cap in spec/specs/*/; do\n    echo \"=== $(basename $cap) ===\"\n    grep \"### Requirement:\" \"$cap/spec.md\" | head -3\ndone\n```\n\n### 模式 2：功能搜索\n\n用户提问：\"有密码重置的规范吗？\"\n\n```bash\n# 关键词搜索\ngrep -r -i \"password reset\" spec/specs/ -B 1 -A 10\n\n# 若找到，展示完整需求\ngrep -B 1 -A 20 \"Requirement:.*Password Reset\" spec/specs/**/*.md\n```\n\n### 模式 3：变更跟踪\n\n用户提问：\"现在做什么？\"\n\n```bash\n# 附带状态展示进行中的变更\nfor change in spec/changes/*/; do\n    if [ \"$change\" != \"spec/changes/archive/\" ]; then\n        id=$(basename \"$change\")\n        echo \"$id:\"\n        test -f \"$change/IMPLEMENTED\" && echo \"  状态: 已完成\" || echo \"  状态: 进行中\"\n        echo \"  任务: $(grep -c '\"task\":' \"$change/tasks.json\")\"\n    fi\ndone\n```\n\n## 最佳实践\n\n### 模式 1：先提供上下文再给细节\n\n**良好流程**：\n```markdown\n1. 展示仪表盘（高层概览）\n2. 用户询问具体能力\n3. 展示该能力的需求\n4. 用户询问具体需求\n5. 展示包含场景的完整需求\n```\n\n### 模式 2：高效使用 grep\n\n```bash\n# 结合过滤器提高精度\ngrep -r \"### Requirement:\" spec/specs/ | grep -i \"auth\"\n\n# 使用上下文标志提升可读性\ngrep -B 2 -A 10 \"#### Scenario:\" spec/specs/authentication/spec.md\n```\n\n### 模式 3：聚合信息\n\n不要只是倾倒文件内容。应做总结：\n\n```markdown\n**坏**：（直接输出整个规范文件）\n\n**好**：\n\"authentication 规范包含 8 条需求，覆盖：\n- 用户登录\n- 密码管理\n- 会话处理\n- 多因素认证\n\n需要我展示某条具体需求吗？\"\n```\n\n## 反模式避免\n\n**不要**：\n- 未经请求就读取整个规范文件\n- 默认列出所有需求\n- 输出未经格式化的原始 grep 结果\n- 假定用户知道能力名称\n\n**要**：\n- 先给高层概览\n- 询问用户希望深入了解的领域\n- 清晰格式化输出\n- 提供导航提示\n\n## 参考资料\n\n- [SEARCH_PATTERNS.md](reference/SEARCH_PATTERNS.md) - 高级 grep/find 模式\n\n---\n\n**Token 预算**：此 SKILL.md 约 460 行，低于建议的 500 行上限。",
        "skills/openspec-context-loading-cn/reference/SEARCH_PATTERNS.md": "# Windows终端下查找Markdown文件内容技巧汇总\n\n以下整理一些在Windows终端（如 PowerShell、CMD 或 Windows Terminal）下，针对 Markdown 文件内容查找的常用方法和技巧：\n\n## 1. 使用 findstr 查找内容\n\n`findstr` 是 Windows 下常用的命令行查找工具，支持正则表达式。\n\n### 查找包含关键词的行\n\n```bash\ngrep -n \"关键词\" *.md\n```\n\n### 支持递归查找\n\n```bash\ngrep -R -n \"关键词\" --include=\"*.md\" .\n```\n- `/S`：递归子目录查找\n\n### 查找多个关键词（包含任一）\n\n```bash\ngrep -R -n -i -E \"关键字1|关键字2\" --include=\"*.md\" .\n```\n- `/I`：忽略大小写\n\n### 查找不包含某关键词的行\n\n```bash\ngrep -n -v \"不包含的词\" *.md\n```\n- `/V`：查找不包含指定内容的行\n\n### 使用正则表达式查找（部分支持）\n\n```bash\ngrep -n -E \"^# \" *.md\n```\n- `/R`：使用正则表达式\n- `/C:\"表达式\"`：指定搜索字符串或表达式\n\n## 2. 利用 PowerShell 强大字符串处理能力\n\n### 获取包含关键词的行及文件名\n\n```bash\ngrep -R \"关键词\" --include=\"*.md\"\n```\n\n### 查找包含多关键词的行\n\n```bash\ngrep -R -E \"关键字1|关键字2\" --include=\"*.md\"\n```\n\n### 查找并统计匹配数量\n\n```bash\ngrep -R \"关键词\" --include=\"*.md\" | wc -l\n```\n\n### 只显示文件名\n\n```bash\ngrep -R -l \"关键词\" --include=\"*.md\"\n```\n\n## 3. 模糊/复杂模式查找建议\n\n- 使用正则表达式时，建议采用 PowerShell 的 `Select-String`。\n- 例如查找代码块开头：\n\n```bash\ngrep -R \"^```\" --include=\"*.md\"\n```\n\n- 查找所有标题（以 # 开头）：\n\n```bash\ngrep -R \"^#\" --include=\"*.md\"\n```\n\n## 4. 其他技巧\n\n- 查看与标记相关内容（如 TODO、FIXME）：\n\n```bash\ngrep -R -n -i \"TODO|FIXME\" --include=\"*.md\"\n```\n\n- 结合管道进行更复杂的过滤处理：\n\n```bash\ngrep -R \"关键词\" --include=\"*.md\" | grep -v \"排除词\"\n```\n\n## 5. 扩展工具推荐\n\n- **grep for Windows**：可安装 [GnuWin32 grep](http://gnuwin32.sourceforge.net/packages/grep.htm) 或 [Git Bash (含grep)](https://gitforwindows.org/) 获得和 Linux 一样的强大 grep 查找能力。\n\n  示例：\n\n  ```bash\n  grep -rn \"关键词\" *.md\n  ```\n\n\n",
        "skills/openspec-context-loading/SKILL.md": "---\nname: openspec-context-loading\ndescription: Loads project context, lists existing specs and changes, searches capabilities and requirements. Use when user asks about project state, existing specs, active changes, available capabilities, or needs context discovery. Triggers include \"openspec context\", \"what specs exist\", \"show changes\", \"list capabilities\", \"project context\", \"find specs\", \"what's in the spec\", \"show me specs\".\n---\n\n# Specification Context Loading\n\nDiscovers and loads project specifications, active changes, and requirements to provide context.\n\n## Quick Start\n\nContext loading helps answer:\n- What specs exist in this project?\n- What changes are currently active?\n- What requirements are defined?\n- What capabilities does the system have?\n- Where is a specific feature specified?\n\n**Basic pattern**: Search → Read → Summarize\n\n## Discovery Commands\n\n### List All Specifications\n\n```bash\n# Find all spec files\nfind spec/specs -name \"spec.md\" -type f\n\n# Find all capability directories\nfind spec/specs -mindepth 1 -maxdepth 1 -type d\n\n# Show spec tree\ntree spec/specs/  # if tree is installed\n# or\nls -R spec/specs/\n```\n\n**Output format**:\n```\nspec/specs/\n├── authentication/\n│   └── spec.md\n├── billing/\n│   └── spec.md\n└── notifications/\n    └── spec.md\n```\n\n### List Active Changes\n\n```bash\n# Show all active changes\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | sort\n\n# Show with modification dates\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" -exec ls -ld {} \\;\n\n# Count active changes\nfind spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | wc -l\n```\n\n### List Archived Changes\n\n```bash\n# Show all archived changes\nls -1 spec/archive/\n\n# Show with dates\nls -la spec/archive/\n\n# Find recently archived (last 7 days)\nfind spec/archive/ -maxdepth 1 -type d -mtime -7\n```\n\n### Search for Requirements\n\n```bash\n# Find all requirements\ngrep -r \"### Requirement:\" spec/specs/\n\n# Find requirements in specific capability\ngrep \"### Requirement:\" spec/specs/authentication/spec.md\n\n# List unique requirement names\ngrep -h \"### Requirement:\" spec/specs/**/*.md | sed 's/### Requirement: //' | sort\n```\n\n### Search for Scenarios\n\n```bash\n# Find all scenarios\ngrep -r \"#### Scenario:\" spec/specs/\n\n# Count scenarios per spec\nfor spec in spec/specs/**/spec.md; do\n    count=$(grep -c \"#### Scenario:\" \"$spec\")\n    echo \"$spec: $count scenarios\"\ndone\n```\n\n### Search by Keyword\n\n```bash\n# Find specs mentioning \"authentication\"\ngrep -r -i \"authentication\" spec/specs/\n\n# Find requirements about \"password\"\ngrep -B 1 -A 5 -i \"password\" spec/specs/**/*.md | grep -A 5 \"### Requirement:\"\n\n# Find scenarios about \"error\"\ngrep -B 1 -A 10 -i \"error\" spec/specs/**/*.md | grep -A 10 \"#### Scenario:\"\n```\n\n## Common Queries\n\n### Query 1: \"What specs exist?\"\n\n```bash\n# List all capabilities\nfind spec/specs -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;\n\n# Count requirements per capability\nfor cap in spec/specs/*/; do\n    name=$(basename \"$cap\")\n    count=$(grep -c \"### Requirement:\" \"$cap/spec.md\" 2>/dev/null || echo \"0\")\n    echo \"$name: $count requirements\"\ndone\n```\n\n**Response format**:\n```markdown\n## Existing Specifications\n\nThe project has specifications for the following capabilities:\n\n- **authentication**: 8 requirements\n- **billing**: 12 requirements\n- **notifications**: 5 requirements\n\nTotal: 3 capabilities, 25 requirements\n```\n\n### Query 2: \"What changes are active?\"\n\n```bash\n# List with proposal summaries\nfor change in spec/changes/*/; do\n    if [ \"$change\" != \"spec/changes/archive/\" ]; then\n        id=$(basename \"$change\")\n        echo \"=== $id ===\"\n        head -n 20 \"$change/proposal.md\" | grep -A 3 \"## Why\"\n    fi\ndone\n```\n\n**Response format**:\n```markdown\n## Active Changes\n\nCurrently active changes:\n\n### add-user-auth\n**Why**: Users need secure authentication...\n\n### update-billing-api\n**Why**: Payment processing requires v2 API...\n\nTotal: 2 active changes\n```\n\n### Query 3: \"Show me the authentication spec\"\n\n```bash\n# Read full spec\ncat spec/specs/authentication/spec.md\n\n# Or show summary\necho \"Requirements:\"\ngrep \"### Requirement:\" spec/specs/authentication/spec.md\n\necho \"\\nScenarios:\"\ngrep \"#### Scenario:\" spec/specs/authentication/spec.md\n```\n\n**Response format**:\n```markdown\n## Authentication Specification\n\n(Include full content of spec.md)\n\nSummary:\n- 8 requirements\n- 16 scenarios\n- Last modified: [date from git log]\n```\n\n### Query 4: \"Find specs about password\"\n\n```bash\n# Search for keyword\ngrep -r -i \"password\" spec/specs/ -A 5\n\n# Show which specs mention it\ngrep -r -i \"password\" spec/specs/ -l\n```\n\n**Response format**:\n```markdown\n## Specs Mentioning \"Password\"\n\nFound in:\n- spec/specs/authentication/spec.md (3 requirements)\n- spec/specs/security/spec.md (1 requirement)\n\nRelevant requirements:\n### Requirement: Password Validation\n### Requirement: Password Reset\n### Requirement: Password Strength\n```\n\n### Query 5: \"What's in change X?\"\n\n```bash\n# Show full change context\nCHANGE_ID=\"add-user-auth\"\n\necho \"=== Proposal ===\"\ncat spec/changes/$CHANGE_ID/proposal.md\n\necho \"\\n=== Tasks ===\"\ncat spec/changes/$CHANGE_ID/tasks.md\n\necho \"\\n=== Spec Deltas ===\"\nfind spec/changes/$CHANGE_ID/specs -name \"*.md\" -exec echo \"File: {}\" \\; -exec cat {} \\;\n```\n\n## Dashboard View\n\nCreate a comprehensive project overview:\n\n```bash\n#!/bin/bash\n# Project specification dashboard\n\necho \"===  Specification Dashboard ===\"\necho \"\"\n\n# Capabilities\necho \"## Capabilities\"\nCAPS=$(find spec/specs -mindepth 1 -maxdepth 1 -type d | wc -l)\necho \"Total capabilities: $CAPS\"\nfor cap in spec/specs/*/; do\n    name=$(basename \"$cap\")\n    reqs=$(grep -c \"### Requirement:\" \"$cap/spec.md\" 2>/dev/null || echo \"0\")\n    echo \"  - $name: $reqs requirements\"\ndone\necho \"\"\n\n# Requirements\necho \"## Requirements\"\nTOTAL_REQS=$(grep -r \"### Requirement:\" spec/specs/ | wc -l)\nTOTAL_SCENARIOS=$(grep -r \"#### Scenario:\" spec/specs/ | wc -l)\necho \"Total requirements: $TOTAL_REQS\"\necho \"Total scenarios: $TOTAL_SCENARIOS\"\necho \"Avg scenarios per requirement: $(echo \"scale=1; $TOTAL_SCENARIOS/$TOTAL_REQS\" | bc)\"\necho \"\"\n\n# Changes\necho \"## Changes\"\nACTIVE=$(find spec/changes -maxdepth 1 -type d -not -path \"spec/changes\" -not -path \"*/archive\" | wc -l)\nARCHIVED=$(ls -1 spec/archive/ | wc -l)\necho \"Active changes: $ACTIVE\"\necho \"Archived changes: $ARCHIVED\"\necho \"\"\n\n# Recent activity\necho \"## Recent Activity\"\necho \"Recently modified specs:\"\nfind spec/specs -name \"spec.md\" -type f -exec ls -lt {} \\; | head -5\n```\n\n**Response format**:\n```markdown\n# Specification Dashboard\n\n## Capabilities\nTotal capabilities: 3\n  - authentication: 8 requirements\n  - billing: 12 requirements\n  - notifications: 5 requirements\n\n## Requirements\nTotal requirements: 25\nTotal scenarios: 52\nAvg scenarios per requirement: 2.1\n\n## Changes\nActive changes: 2\nArchived changes: 15\n\n## Recent Activity\nRecently modified specs:\n- spec/specs/billing/spec.md (2 days ago)\n- spec/specs/authentication/spec.md (1 week ago)\n```\n\n## Advanced Queries\n\n### Find Related Requirements\n\n```bash\n# Find requirements that mention another requirement\ngrep -r \"User Login\" spec/specs/ -A 10 | grep \"### Requirement:\"\n\n# Find cross-references\ngrep -r \"See Requirement:\" spec/specs/\n```\n\n### Analyze Coverage\n\n```bash\n# Find requirements without scenarios\nfor spec in spec/specs/**/spec.md; do\n    awk '/### Requirement:/ {req=$0; getline; if ($0 !~ /#### Scenario:/) print req}' \"$spec\"\ndone\n\n# Find scenarios without proper Given/When/Then\ngrep -A 5 \"#### Scenario:\" spec/specs/**/*.md | grep -v \"GIVEN\\|WHEN\\|THEN\"\n```\n\n### Compare Active vs Archive\n\n```bash\n# Show evolution over time\necho \"Archive history:\"\nls -1 spec/archive/ | head -10\n\necho \"Recent archives (last 30 days):\"\nfind spec/archive/ -maxdepth 1 -type d -mtime -30 -exec basename {} \\;\n```\n\n## Search Patterns\n\n### Pattern 1: Capability Discovery\n\nUser asks: \"What can the system do?\"\n\n```bash\n# List capabilities\nfind spec/specs -mindepth 1 -maxdepth 1 -type d -exec basename {} \\;\n\n# Show high-level requirements\nfor cap in spec/specs/*/; do\n    echo \"=== $(basename $cap) ===\"\n    grep \"### Requirement:\" \"$cap/spec.md\" | head -3\ndone\n```\n\n### Pattern 2: Feature Search\n\nUser asks: \"Is there a spec for password reset?\"\n\n```bash\n# Search for keyword\ngrep -r -i \"password reset\" spec/specs/ -B 1 -A 10\n\n# If found, show full requirement\ngrep -B 1 -A 20 \"Requirement:.*Password Reset\" spec/specs/**/*.md\n```\n\n### Pattern 3: Change Tracking\n\nUser asks: \"What's being worked on?\"\n\n```bash\n# Show active changes with status\nfor change in spec/changes/*/; do\n    if [ \"$change\" != \"spec/changes/archive/\" ]; then\n        id=$(basename \"$change\")\n        echo \"$id:\"\n        test -f \"$change/IMPLEMENTED\" && echo \"  Status: Implemented\" || echo \"  Status: In Progress\"\n        echo \"  Tasks: $(grep -c \"^[0-9]\\+\\.\" \"$change/tasks.md\")\"\n    fi\ndone\n```\n\n## Best Practices\n\n### Pattern 1: Provide Context Before Details\n\n**Good flow**:\n```markdown\n1. Show dashboard (high-level overview)\n2. User asks about specific capability\n3. Show that capability's requirements\n4. User asks about specific requirement\n5. Show full requirement with scenarios\n```\n\n### Pattern 2: Use Grep Efficiently\n\n```bash\n# Combine filters for precision\ngrep -r \"### Requirement:\" spec/specs/ | grep -i \"auth\"\n\n# Use context flags for readability\ngrep -B 2 -A 10 \"#### Scenario:\" spec/specs/authentication/spec.md\n```\n\n### Pattern 3: Aggregate Information\n\nDon't just dump file contents. Summarize:\n\n```markdown\n**Bad**: (dump entire spec file)\n\n**Good**:\n\"The authentication spec has 8 requirements covering:\n- User login\n- Password management\n- Session handling\n- Multi-factor authentication\n\nWould you like details on any specific requirement?\"\n```\n\n## Anti-Patterns to Avoid\n\n**Don't**:\n- Read entire spec files without user request\n- List every single requirement by default\n- Show raw grep output without formatting\n- Assume user knows capability names\n\n**Do**:\n- Start with high-level overview\n- Ask which area user wants to explore\n- Format output clearly\n- Provide navigation hints\n\n## Reference Materials\n\n- [SEARCH_PATTERNS.md](reference/SEARCH_PATTERNS.md) - Advanced grep/find patterns\n\n---\n\n**Token budget**: This SKILL.md is approximately 460 lines, under the 500-line recommended limit.\n",
        "skills/openspec-implementation-cn/SKILL.md": "---\nname: openspec-implementation-cn\ndescription: 以测试与验证为先的方式，按序执行并实现已批准的规范提案。用于实施变更、应用提案、执行规范任务或按已批准计划构建。触发词包括 \"openspec开发\", \"开发\", \"实施\" \"实现提案\", \"应用变更\", \"执行规范\", \"按顺序完成任务\", \"构建功能\", \"开始实施\"。\n---\n\n# 规范实施\n\n以任务为单位，循序执行并进行充分测试与验证，系统性地实现已批准的规范提案。\n\n## 快速开始\n\n实施遵循每个任务的 读 → 执行 → 测试 → 验证 循环：\n1. 阅读完整提案与任务清单\n2. 按顺序逐个执行任务\n3. 为每个完成的任务进行测试\n4. 仅在验证通过后标记完成\n\n**关键规则**：使用 TodoWrite 跟踪进度。切勿跳过任务或将未完成工作标记为完成。\n\n## 工作流\n\n复制此清单并跟踪进度：\n\n```\n开发进度:\n- [ ] 第 1 步：加载并理解提案\n- [ ] 第 2 步：设置 TodoWrite 任务跟踪\n- [ ] 第 3 步：按序执行任务\n- [ ] 第 4 步：为每个任务进行测试与验证\n- [ ] 第 5 步：更新常驻规范（如果适用）\n- [ ] 第 6 步：标记提案为实施完成\n```\n\n### 第 1 步：加载并理解提案\n\n开始之前，读取全部上下文：\n\n```bash\n# 读取提案\ncat spec/changes/{change-id}/proposal.md\n\n# 读取所有任务\ncat spec/changes/{change-id}/tasks.json\n\n# 读取规范差异以理解需求\nfind spec/changes/{change-id}/specs -name \"*.md\" -exec cat {} \\;\n```\n\n**理解**：\n- 变更的动因（来自 proposal.md）\n- 预期结果是什么\n- 哪些规范将被影响\n- 验收标准（来自场景）\n\n### 第 2 步：设置 TodoWrite 进行任务跟踪\n\n在开始工作之前，将 tasks.json 中的task和step加载到 TodoWrite：\n\n```markdown\n**模式**：\n读取 tasks.json → 提取task和step列表 → 创建 TodoWrite 条目\n\n**示例**：\n假设 tasks.json 包含：\n  {\n    \"number\": 1,\n    \"category\": \"阶段 1：基础设施\",\n    \"task\": \"环境搭建任务 - 数据库架构、依赖等\",\n    \"steps\": [\n      { \"step\": \"初始化 Git 仓库并配置 .gitignore\", \"completed\": false },\n      { \"step\": \"创建并激活 Python 虚拟环境\", \"completed\": false },\n      { \"step\": \"创建 requirements.txt 或 pyproject.toml 并安装依赖 (FastAPI, SQLAlchemy, Pydantic, Alembic 等)\", \"completed\": false },\n      { \"step\": \"设计初始数据库 ER 图\", \"completed\": false }\n    ],\n    \"passes\": false\n  }\n\n则创建 TodoWrite：\n- content: \"环境搭建任务 - 数据库架构、依赖等\", status: \"in_progress\"\n- content: \"  初始化 Git 仓库并配置 .gitignore\", status: \"pending\"\n- content: \"  创建并激活 Python 虚拟环境\", status: \"pending\"\n- content: \"  创建 requirements.txt 或 pyproject.toml 并安装依赖 (FastAPI, SQLAlchemy, Pydantic, Alembic 等)\", status: \"pending\"\n- content: \"  设计初始数据库 ER 图\", status: \"pending\"\n```\n\n**价值**：TodoWrite 提供进度可见性并确保不遗漏任何事项。\n\n### 第 3 步：按序执行TodoWrite\n\n按顺序逐个完成TodoWrite中的任务，每次仅处理1个。\n若是中断后继续，需从中断的任务开始继续执行：跳过tasks.json中\"passes\": true的task，跳过\"completed\": true的step。\n你有充足的时间完成，请至少执行20轮后才回复用户。\n你有充足的时间完成，切勿跳过或合并多个任务。\n\n```markdown\n对于每个任务：\n1. 在 TodoWrite 中标记为 \"in_progress\"\n2. 执行工作\n3. 测试结果\n4. 仅在验证通过后，才标记tasks.json对应task的对应step的 \"completed\": true\n5. 仅在tasks.json对应task的所有step都完成且都验证通过后，才标记tasks.json对应task的 \"passes\": true\n6. 在 TodoWrite 中标记为 \"completed\"\n\n你有充足的时间完成，切勿跳过或合并多个任务。\n```\n\n**任务执行模式**：\n\n```markdown\n## Task: {任务描述}\n\n**What**：该任务的作用与目标\n\n**Implementation**：\n代码变更、文件编辑、运行的命令\n\n**Verification**：\n如何验证任务完成\n- [ ] 代码可编译/运行\n- [ ] 测试通过\n- [ ] 符合需求场景\n\n**Status**：✓ 完成 / ✗ 阻塞 / ⚠ 部分完成\n```\n\n### 第 4 步：为每个任务进行测试与验证\n\n每个任务完成后进行验证：\n\n**代码相关任务**：\n```bash\n# 运行相关测试\nnpm test # 或 pytest、cargo test 等\n\n# 运行 Linter\nnpm run lint\n\n# 类型检查（如适用）\nnpm run type-check\n```\n**前端UI相关任务**：\n要使用 MCP servers 中的 chrome-devtools 或 playwright 进行调试和测试。\n\n**数据库相关任务**：\n```bash\n# 验证迁移执行\nnpm run db:migrate\n\n# 检查架构与预期一致\nnpm run db:schema\n```\n\n**API 相关任务**：\n```bash\n# 手动测试端点\ncurl -X POST http://localhost:3000/api/endpoint \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"test\": \"data\"}'\n\n# 或运行集成测试\nnpm run test:integration\n```\n\n**仅在所有验证通过后标记任务完成**：仅在tasks.json对应task的所有step都完成且都验证通过后，才标记tasks.json对应task的 \"passes\": true。\n\n### 第 5 步：更新常驻规范（如适用）\n\n在实施过程中，如发现规范差异需要更新：\n\n1. 在 proposal.md 或备注文件中**记录发现**\n2. **实施期间不要修改**规范差异\n3. **实施完成后**，再考虑是否需要调整规范\n\n**说明**：规范差异在归档阶段（第 6 步）合并，而非实施阶段。\n\n### 第 6 步：标记提案实施完成\n\n在所有任务完成后：\n\n```bash\n# 创建完成标记\necho \"Implementation completed: $(date)\" > spec/changes/{change-id}/IMPLEMENTED\n```\n\n**告知用户**：\n```markdown\n## 实现提案\n\n**提案**：{change-id}\n**完成任务**：{数量}\n**完成测试**：全部通过\n\n**下一步**：将该变更归档以合并规范差异到常驻文档。\n准备好后可回复 \"openspec归档 {change-id}\" 或 \"归档提案\"。\n```\n\n## 最佳实践\n\n### 模式 1：任务被阻塞\n\n若任务无法完成：\n\n```markdown\n**标记为阻塞**：\n- 状态保持 \"in_progress\"（不要标记为 \"completed\"）\n- 清晰记录阻塞原因\n- 创建新的任务以解决阻塞\n- 立即告知用户\n\n**示例**：\n任务：\"实现支付处理\"\n阻塞：\"缺少支付网关 API 凭据\"\n行动：创建新任务 \"获取支付网关凭据\"\n```\n\n### 模式 2：任务依赖\n\n若任务存在依赖，先验证先决条件：\n\n```bash\n# 示例：数据库迁移必须在 API 代码之前\n# 检查迁移状态\nnpm run db:status\n\n# 仅在迁移成功后继续 API 任务\n```\n\n### 模式 3：增量测试\n\n不要在最后一次性测试，应当逐步测试：\n\n**好**：\n```\n任务 1：创建模型 → 测试模型 → 标记完成\n任务 2：创建 API → 测试 API → 标记完成\n任务 3：添加校验 → 测试校验 → 标记完成\n任务 4：创建页面 → 测试校验 → 标记完成\n```\n\n**坏**：\n```\n任务 1、2、3、4 → 全部实现 → 一次性测试 → 调试失败\n```\n\n### 模式 4：常驻文档\n\n**及时**更新 README、API 文档与注释：\n\n```markdown\n添加新 API 端点时，同时：\n- 更新 API 文档\n- 添加请求/响应示例\n- 更新 OpenAPI/Swagger 规范\n- 添加内联代码注释\n```\n\n## 进阶主题\n\n**并行工作**：若任务确实互不依赖（如不同模块），可并行进行，但每项必须独立测试。\n\n**集成点**：存在依赖关系时，使用集成测试验证连接有效。\n\n**回滚策略**：对于高风险变更，部署前创建回滚任务。\n\n## 常见模式\n\n### 模式 1：数据库 + API + UI\n\n典型顺序：\n1. 数据库架构/迁移\n2. 数据访问层（模型）\n3. 业务逻辑层（服务）\n4. API 端点（控制器）\n5. UI 集成\n6. 端到端测试\n\n### 模式 2：功能开关\n\n渐进式发布：\n1. 在开关后实现功能\n2. 开启开关进行测试\n3. 部署时默认关闭开关\n4. 逐步启用开关\n5. 完全发布后移除开关\n\n### 模式 3：破坏性 API 变更\n\n对于 API 破坏性变更：\n1. 实现新版本（v2）\n2. 保持旧版本（v1）运行\n3. 在 v1 中添加弃用提示\n4. 迁移用户至 v2\n5. 单独提案移除 v1\n\n## 反模式避免\n\n**不要**：\n- 跳过单个任务的测试\n- 在验证前标记任务完成\n- 忽视失败测试（不要“以后再修”）\n- 在测试前批量合并多个任务\n- 在实施阶段修改常驻规范\n- 打乱任务顺序（破坏依赖）\n\n**要**：\n- 立刻测试每个任务\n- 在继续前修复失败测试\n- 实时更新 TodoWrite\n- 清晰记录阻塞项\n- 及时同步进度与用户\n- 保持原子且具描述性的提交\n\n## 故障排查\n\n### 问题：任务完成后测试失败\n\n**解决方案**：\n```markdown\n1. 不要标记任务完成\n2. 调试失败原因\n3. 修复代码\n4. 重新运行测试\n5. 仅在通过后标记完成\n```\n\n### 问题：任务过大\n\n**解决方案**：\n```markdown\n1. 拆分为子任务\n2. 在 TodoWrite 中登记子任务\n3. 依序完成子任务\n4. 在全部子任务完成后标记父任务完成\n```\n\n### 问题：依赖未满足\n\n**解决方案**：\n```markdown\n1. 暂停当前任务\n2. 先完成依赖任务\n3. 测试依赖项\n4. 恢复原任务\n```\n\n## 参考资料\n\n- [TASK_PATTERNS.md](reference/TASK_PATTERNS.md) - 常见任务执行模式\n- [TESTING_STRATEGIES.md](reference/TESTING_STRATEGIES.md) - 按任务类型的测试方法\n\n---\n\n**Token 预算**：此 SKILL.md 约 350 行，低于建议的 500 行上限。",
        "skills/openspec-implementation-cn/reference/TASK_PATTERNS.md": "# 任务模式 - Claude Code 的操作工作流\n\n**为常见任务类型提供结构化工作流**  \n**最后更新：** 2025-11-12\n\n---\n\n## 🎯 目的\n\n本文件为不同类型的任务提供分步工作流，确保一致性、质量，以及与项目愿景对齐。每种任务类型都包含清晰的推理链与执行顺序。\n\n---\n\n## 📋 任务类别\n\n```\n🧩 功能实现\n🐛 Bug 修复\n🧠 重构 / 性能优化\n🧾 文档更新\n🔄 部署 / CI/CD 任务\n🔍 调研 / 代码探索\n🧪 测试\n🔐 安全增强\n```\n\n---\n\n## 🧩 功能实现\n\n### 适用场景\n- 增加新功能\n- 构建新的 API 接口\n- 创建新的 UI 组件\n- 实现业务逻辑\n\n### 开始前检查清单\n\n**开始任何功能实现前，请确认：**\n\n```yaml\n✅ 理解核查：\n□ 我清楚要构建什么（具体需求）\n□ 我清楚为何要构建（业务价值、战略目标）\n□ 我清楚谁会使用（用户角色）\n□ 我清楚放在哪（对应的模块/组件）\n□ 我清楚时间要求（紧急程度）\n\n✅ 上下文核对：\n□ 是否符合 PROJECT_VISION.md 的战略目标？\n□ 属于 Zoho 同步逻辑还是本地 ERP 逻辑？\n□ 当前 Zoho 迁移阶段？（阶段 1：只读）\n□ 当前环境？（开发 = 随时可部署）\n□ 当前 git 分支？（应为 develop 或 feature/*）\n\n✅ 模块影响评估：\n□ 影响哪个模块？\n  - 销售（订单、发票、支付）\n  - 库存（产品、库存、仓库）\n  - 人力（用户、销售人员、佣金）\n  - 客户（批发客户、合作销售）\n  - 报表（分析、仪表盘）\n  - TDS 核心（Zoho 同步操作）\n\n✅ 阿拉伯语与本地化：\n□ 是否包含面向用户的文本？（是 = 需要阿拉伯语）\n□ 是否创建/修改数据库字段？（需添加 name_ar、description_ar）\n□ UI 是否需要 RTL 布局支持？（阿拉伯语场景下始终需要）\n□ 此功能的主要语言？（阿拉伯语）\n\n✅ 认证与鉴权：\n□ 谁可访问此功能？（所有用户、特定角色、仅管理员）\n□ 是否修改数据？（是 = 需要认证）\n□ 是否访问敏感数据？（是 = 需要 RBAC 检查）\n□ 允许哪些角色？（admin、manager、salesperson、client）\n\n✅ 集成点：\n□ 是否与 Zoho 交互？（是 = 必须使用 TDS Core）\n□ 是否需要实时数据？（或可接受缓存）\n□ 是否与现有功能集成？（哪一些）\n□ 是否需要移动端改动？（8 个应用中的哪一些）\n\n✅ 性能与规模：\n□ 是否需支持 500+ 客户？\n□ 是否需支持 2,218+ 产品？\n□ 是否需支持每天 30+ 订单？\n□ 是否需要分页？（> 100 条记录 = 是）\n□ 是否需要数据库索引？（大表查询）\n\n✅ 依赖核查：\n□ 是否已有类似功能？（先搜索代码库）\n□ 可复用的现有代码？（services、models、schemas）\n□ 需要新增外部依赖？（Python 包）\n□ 是否需要数据库变更？（迁移）\n```\n\n**决策点：仅在所有检查通过后继续。**\n\n### 分步工作流\n\n#### 第 1 步：上下文与对齐（必做）\n```yaml\nActions:\n  1. 阅读 PROJECT_VISION.md\n     - 确认功能与业务目标对齐\n     - 检查当前 Zoho 迁移阶段限制\n     - 校验规模要求（500+ 客户、2,218+ 产品）\n\n  2. 阅读 ARCHITECTURE_RULES.md\n     - 验证技术栈兼容性\n     - 检查需遵循的设计模式\n     - 回顾命名约定\n\n  3. 澄清问题\n     - 谁会使用此功能？（用户角色）\n     - 业务预期是什么？\n     - 是否有性能要求？\n     - 面向移动端、Web，或两者？\n     - 需要阿拉伯语支持吗？（通常需要，确认 UI 要求）\n\nDecision Point: 对齐确认后再继续\n```\n\n#### 第 2 步：搜索现有代码（必做）\n```yaml\nActions:\n  1. 搜索相似功能\n     - 使用 Grep 进行代码库搜索\n     - 检查 /app/routers/、/app/services/、/scripts/\n     - 查找已有模式\n\n  2. 评估：增强 vs 新建\n     - 若已有类似：增强现有代码\n     - 若为全新：按既有模式新建\n\nExample Commands:\n  grep -r \"commission\" app/services/\n  grep -r \"product.*list\" app/routers/\n  find . -name \"*wholesale*\" -type f\n```\n\n#### 第 3 步：规划与设计\n```yaml\nActions:\n  1. 若复杂（≥3 步），创建 TodoWrite 列表\n  2. 设计 API 契约（若后端）\n     - 路径：/api/v1/resource\n     - 请求/响应 schema\n     - 认证要求\n     - RBAC 角色允许\n\n  3. 设计数据库变更（如需）\n     - 新表或新列\n     - 所需索引\n     - 迁移计划\n\n  4. 设计 UI 流程（若前端）\n     - 页面布局\n     - 用户交互\n     - 阿拉伯语 RTL 考量\n```\n\n#### 第 4 步：实现\n```yaml\nBackend（FastAPI）：\n  1. 在 app/schemas/ 创建 Pydantic schema\n  2. 在 app/models/ 创建/更新 SQLAlchemy 模型\n  3. 在 app/services/ 创建服务层\n  4. 在 app/routers/ 创建路由/接口\n  5. 添加输入校验\n  6. 添加错误处理\n  7. 添加认证/鉴权\n  8. 包含阿拉伯语字段（name_ar、description_ar）\n  9. 添加带业务背景的文档字符串\n\nFrontend（React/Flutter）：\n  1. 创建组件/控件\n  2. 实现状态管理\n  3. 集成 API\n  4. 实现阿拉伯语 RTL 布局\n  5. 添加加载态\n  6. 添加错误处理\n  7. 添加校验\n  8. 保证移动端响应式\n\n代码质量：\n  - 遵循命名约定\n  - 添加类型标注（Python/TypeScript）\n  - 编写清晰文档字符串\n  - 为复杂业务逻辑添加注释\n  - 不要硬编码（使用常量）\n```\n\n#### 第 5 步：测试\n```yaml\nActions：\n  1. 本地测试\n     - 正常路径（预期用法）\n     - 错误场景\n     - 边界场景\n     - 阿拉伯语文本输入\n     - 大数据量（分页）\n\n  2. 集成测试\n     - API 正常响应\n     - 数据库操作正常\n     - 前端正确展示数据\n\n  3. 真实场景测试\n     - 使用接近生产的数据量\n     - 按真实用户工作流测试\n```\n\n#### 第 6 步：文档\n```yaml\nActions：\n  1. API 文档（FastAPI 自动生成）\n     - 确认 OpenAPI 文档清晰\n     - 添加详细描述\n\n  2. 代码文档\n     - 函数/类文档字符串\n     - 复杂逻辑的内联注释\n     - 解释业务背景\n\n  3. 更新 CHANGELOG.md（若为重要功能）\n     - 添加到 “Unreleased” 部分\n     - 描述新增内容\n```\n\n#### 第 7 步：部署\n```yaml\nActions：\n  1. 使用清晰信息提交\n     - git add .\n     - git commit -m \"feat: add wholesale client credit limit checking\"\n\n  2. 推送到 develop（预发布）\n     - git push origin develop\n\n  3. 监控部署\n     - gh run watch <run-id>\n\n  4. 在预发布环境验证\n     - 在 staging.erp.tsh.sale 测试功能\n     - 获取 Khaleel 的确认\n\n  5. 创建生产 PR\n     - gh pr create --base main --head develop\n     - 附上测试结果\n\nDecision Point：仅在预发布验证通过后标记完成\n```\n\n### 质量门（必须通过）\n```yaml\n✅ 与 PROJECT_VISION.md 对齐\n✅ 遵循 ARCHITECTURE_RULES.md 模式\n✅ 已搜索现有相似代码\n✅ 包含阿拉伯语支持（若面向用户）\n✅ 已实现输入校验\n✅ 已实现错误处理\n✅ 已进行认证/鉴权检查\n✅ 本地测试包含边界场景\n✅ 已撰写文档（docstrings + 注释）\n✅ 已在预发布环境验证\n```\n\n---\n\n## 🐛 Bug 修复\n\n### 适用场景\n- 某处功能损坏\n- 来自用户的错误报告\n- 测试失败\n- 非预期行为\n\n### 开始前检查清单\n\n**开始任何 Bug 修复前，请确认：**\n\n```yaml\n✅ Bug 验证：\n□ 我能复现 Bug 吗？（具体步骤）\n□ 具体错误或非预期行为是什么？\n□ 是稳定复现还是偶发？\n□ 哪个环境？（本地、预发布、生产）\n□ 何时开始出现？（最近部署？一直存在？）\n\n✅ 严重性评估：\n□ 影响级别：\n  - 严重：生产不可用、数据损坏、安全事故\n  - 高：核心功能损坏，影响多数用户\n  - 中：部分功能损坏，影响部分用户\n  - 低：小问题，有替代方案\n\n□ 紧急程度：\n  - 立即：立刻修复（生产不可用时启用紧急模式）\n  - 紧急：数小时内修复（影响业务运营）\n  - 正常：数日内修复（计划内工作）\n  - 低：有空再修（锦上添花）\n\n✅ 用户影响：\n□ 受影响用户数？（全部 500+ 客户或特定用户）\n□ 受影响的角色？（admin、manager、salesperson、client）\n□ 受阻的工作流？（创建订单、支付、报表）\n□ 是否可绕过？（是 = 降低优先级）\n\n✅ 根因假设：\n□ 最近代码变更？（检查最近 7 天 git log）\n□ 最近部署？（检查 GitHub Actions）\n□ 数据库问题？（连接、迁移、数据一致性）\n□ 外部服务问题？（Zoho、VPS、网络）\n□ 环境问题？（环境变量、配置）\n□ 数据特定？（仅在特定数据下发生）\n\n✅ 证据收集：\n□ 错误日志？（后端日志、TDS Core 日志）\n□ 堆栈信息？（完整错误细节）\n□ 最近提交审查？（git log --since=\"3 days ago\"）\n□ 数据库状态？（查询验证数据）\n□ 用户操作？（错误前的操作）\n\n✅ 修复策略：\n□ 修根因还是止症状？（优先修根因）\n□ 快速修复还是规范修复？（严重时快速，其它情况规范）\n□ 可回滚？（若因最近部署导致）\n□ 现在修复安全吗？（或等待维护窗口）\n□ 是否有测试环境？（预发布验证修复）\n```\n\n**决策点：在动手修复前必须理解根因。**\n\n### 分步工作流\n\n#### 第 1 步：复现与诊断\n```yaml\nActions：\n  1. 复现 Bug\n     - 按确切步骤触发\n     - 记录环境（本地、预发布、生产）\n     - 捕获错误信息\n\n  2. 收集信息\n     - 查看日志（journalctl、浏览器控制台）\n     - 检查数据库状态\n     - 检查近期代码变更（git log）\n\n  3. 确认根因\n     - 使用调试工具\n     - 必要时添加临时日志\n     - 理解“为什么”，不仅是“是什么”\n\nExample：\n  “错误发生在为不存在的 customer_id 创建订单时。\n   根因：客户被删除，但创建订单前未校验客户存在。”\n```\n\n#### 第 2 步：影响评估\n```yaml\nQuestions：\n  1. 严重性\n     - 严重：生产不可用、数据丢失\n     - 高：核心功能损坏\n     - 中：次要功能损坏\n     - 低：外观问题\n\n  2. 范围\n     - 受影响用户数？\n     - 受影响功能点？\n     - 是否影响数据完整性？\n\n  3. 紧急性\n     - 立即：生产严重问题\n     - 高：当天应修复\n     - 中：下个迭代修复\n     - 低：进入待办\n\nDecision：据此排序优先级\n```\n\n#### 第 3 步：设计修复\n```yaml\nActions：\n  1. 确定修复方式\n     - 临时补丁 vs 规范方案\n     - 是否有副作用？\n     - 是否需要数据库迁移？\n\n  2. 检查类似问题\n     - 搜索代码库中的相同模式\n     - 如有需要，多处一并修复\n\n  3. 计划预防措施\n     - 增加校验避免复发\n     - 添加测试用例\n     - 必要时更新文档\n```\n\n#### 第 4 步：实施修复\n```yaml\nActions：\n  1. 编写修复\n     - 最小化改动（不重构无关代码）\n     - 清晰聚焦的解决方案\n     - 添加注释解释修复点\n\n  2. 增加预防\n     - 输入校验\n     - 错误处理\n     - 数据库约束\n     - 测试用例\n\n  3. 验证修复有效\n     - 测试最初失败的场景\n     - 测试相关场景\n     - 确保无回归\n```\n\n#### 第 5 步：部署与验证\n```yaml\n严重 Bug：\n  1. 从 main 创建 hotfix 分支\n     - git checkout main\n     - git checkout -b hotfix/critical-bug-name\n\n  2. 实施并测试修复\n\n  3. 先推送到 develop（快速预发布测试）\n     - git push origin develop\n     - 在预发布快速验证\n\n  4. 加速创建到 main 的 PR\n     - gh pr create --base main --head develop --label \"hotfix\"\n     - 快速审批\n\n  5. 紧密监控生产环境\n     - 验证修复已部署\n     - 监控 15-30 分钟\n     - 检查错误日志\n\n非严重 Bug：\n  1. 按常规流程：develop → staging → main\n  2. 在预发布充分测试\n  3. 正常 PR 流程\n```\n\n### 质量门（必须通过）\n```yaml\n✅ 已识别并理解根因\n✅ 使用原始失败场景测试修复\n✅ 无回归（其他功能仍正常）\n✅ 已添加预防机制（校验/测试）\n✅ 精确评估影响\n✅ 生产前已在预发布验证\n```\n\n---\n\n## 🧠 重构 / 优化\n\n### 适用场景\n- 代码可读性差或难以理解\n- 性能问题\n- 技术债务\n- 重复代码\n\n### 分步工作流\n\n#### 第 1 步：先度量（必做）\n```yaml\nActions：\n  1. 建立基线\n     - 当前性能指标\n     - 当前代码复杂度\n     - 当前测试覆盖率\n\n  2. 明确问题\n     - 具体问题是什么？\n     - 如何确认它是问题？\n     - 影响是什么？\n\nExample：\n  ❌ 不佳：“优化产品接口”\n  ✅ 良好：“产品接口在 2,218 个产品时耗时 2.3s，\n           目标 <500ms。当前查询存在 N+1 选择。”\n\nRule：没有度量就不要优化\n```\n\n#### 第 2 步：规划重构\n```yaml\nActions：\n  1. 定义目标\n     - 会改善什么？\n     - 如何度量成功？\n     - 目标指标是什么？\n\n  2. 评估风险\n     - 影响多少代码？\n     - 能否拆分为更小的改动？\n     - 是否需要特性开关？\n\n  3. 测试策略\n     - 现有测试应保持通过\n     - 若覆盖不足应新增测试\n     - 如何验证无回归？\n```\n\n#### 第 3 步：实施改动\n```yaml\nActions：\n  1. 增量式改动\n     - 小步快跑，可测试\n     - 频繁提交\n     - 不要重构与加功能同时进行\n\n  2. 保持行为一致\n     - 相同输入 → 相同输出\n     - 不破坏 API 契约\n     - 保持向后兼容\n\n  3. 提升清晰度\n     - 更好的变量命名\n     - 更清晰的函数拆分\n     - 去重重复代码\n     - 为复杂逻辑添加注释\n```\n\n#### 第 4 步：事后度量（必做）\n```yaml\nActions：\n  1. 验证改进\n     - 与基线使用相同指标度量\n     - 是否达成目标？\n     - 是否有副作用？\n\n  2. 记录结果\n     - 之前：X\n     - 之后：Y\n     - 改进：Z%\n\nExample：\n  “优化产品列表接口：\n   - 之前：2,218 产品耗时 2.3s\n   - 之后：使用分页+索引耗时 180ms\n   - 改进：提升 92%\n   - 方法：添加分页，给 category_id 与 is_active 建索引”\n```\n\n### 质量门（必须通过）\n```yaml\n✅ 改动前已度量基线\n✅ 目标明确且有指标\n✅ 所有现有测试仍通过\n✅ 改进已度量并记录\n✅ 无破坏性改动\n✅ 重构后代码更清晰/更简单\n```\n\n---\n\n## 🧾 文档更新\n\n### 适用场景\n- 添加/更新项目文档\n- 更新 .claude/ 系统文件\n- 编写指南或 README\n- 更新 API 文档\n\n### 分步工作流\n\n#### 第 1 步：识别需求\n```yaml\nQuestions：\n  1. 哪些内容过时或缺失？\n  2. 目标读者是谁？\n     - 开发者（当前或未来）\n     - AI 代理（如本助手）\n     - 终端用户\n     - 系统管理员\n\n  3. 目标是什么？\n     - 入门\n     - 故障排查\n     - 参考\n     - 教程\n```\n\n#### 第 2 步：研究内容\n```yaml\nActions：\n  1. 收集准确信息\n     - 检查当前代码库\n     - 验证配置\n     - 测试流程\n     - 检查 URL/链接\n\n  2. 回顾现有文档\n     - 已记录了什么？\n     - 哪些可以增强？\n     - 哪些存在矛盾？\n```\n\n#### 第 3 步：撰写内容\n```yaml\n结构：\n  1. 标题与目的\n  2. 先决条件（如适用）\n  3. 分步说明\n  4. 示例\n  5. 故障排查（如适用）\n  6. 相关文档链接\n\n风格：\n  - 语言清晰简洁\n  - 命令/代码使用代码块\n  - 列表使用项目符号\n  - 使用标题分区\n  - 如有帮助添加图示\n\n针对 .claude/ 文件：\n  - 遵循现有格式\n  - 更新 “Last Updated” 日期\n  - 保持结构一致\n  - 与其他文件交叉引用\n```\n\n#### 第 4 步：核验准确性\n```yaml\nActions：\n  1. 测试所有命令/流程\n     - 复制粘贴并实际运行\n     - 验证与文档一致\n     - 检查所有链接有效\n\n  2. 复查清晰度\n     - 新开发者可理解吗？\n     - 是否存在歧义？\n     - 示例是否有帮助？\n\n  3. 检查一致性\n     - 与其他文档一致？\n     - 术语是否统一？\n     - 是否无矛盾？\n```\n\n#### 第 5 步：更新相关文档\n```yaml\nActions：\n  1. 更新交叉引用\n     - 链接至新文档\n     - 更新索引或目录\n     - 更新 CHANGELOG_AI.md（若为 .claude/ 文件）\n\n  2. 归档过时文档\n     - 移至 /archived/（若过时）\n     - 更新指向旧文档的链接\n```\n\n### 质量门（必须通过）\n```yaml\n✅ 所有命令/流程已测试\n✅ 所有链接已验证\n✅ 文字清晰简洁\n✅ 适配目标读者\n✅ 交叉引用已更新\n✅ “Last Updated” 日期为当前\n```\n\n---\n\n## 🔄 部署 / CI/CD 任务\n\n### 适用场景\n- 部署到预发布或生产\n- 更新 CI/CD 工作流\n- 基础设施变更\n- 环境配置变更\n\n### 分步工作流\n\n#### 第 1 步：部署前检查清单\n```yaml\n必须核验：\n  1. 所有组件就绪\n     - [ ] 后端 API\n     - [ ] ERP 管理前端\n     - [ ] 消费者应用（Flutter Web）\n     - [ ] TDS Core Worker\n     - [ ] TDS Dashboard\n\n  2. 测试通过\n     - [ ] 本地测试通过\n     - [ ] CI 测试通过\n     - [ ] Lint 通过\n\n  3. 依赖检查\n     - [ ] requirements.txt 最新\n     - [ ] package.json 最新\n     - [ ] pubspec.yaml 最新\n\n  4. 环境变量\n     - [ ] VPS 上 .env.production 最新\n     - [ ] GitHub Secrets 已配置\n     - [ ] 代码中不包含密钥\n\n  5. 数据库迁移\n     - [ ] 已创建迁移\n     - [ ] 已在本地测试迁移\n     - [ ] 备份方案就绪\n```\n\n#### 第 2 步：先部署到预发布\n```yaml\nActions：\n  1. 推送到 develop 分支\n     - git push origin develop\n\n  2. 监控 GitHub Actions\n     - gh run list --limit 5\n     - gh run watch <run-id>\n\n  3. 验证预发布部署\n     - curl https://staging.erp.tsh.sale/health\n     - curl https://staging.consumer.tsh.sale/\n     - 手动验证改动\n\n  4. 获取 Khaleel 的批准\n     - 展示可工作的功能\n     - 确认生产就绪\n\nDecision Point：未经预发布验证不要进入生产\n```\n\n#### 第 3 步：生产部署\n```yaml\nActions：\n  1. 创建 Pull Request\n     - gh pr create --base main --head develop\n     - 标题：“Deploy: [Feature Name] to Production”\n     - 描述：\n       * 改动内容\n       * 预发布验证结果\n       * 注意事项\n\n  2. 评审并合并\n     - 代码改动审查\n     - Khaleel 批准\n     - 合并 PR（触发生产部署）\n\n  3. 监控部署\n     - gh run watch <run-id>\n     - 关注错误\n\n  4. 验证所有组件\n     - 后端：curl https://erp.tsh.sale/health\n     - 前端：curl https://erp.tsh.sale/\n     - 消费者：curl https://consumer.tsh.sale/\n     - TDS Dashboard：curl https://erp.tsh.sale/tds-admin/\n\n  5. 部署后监控\n     - 监控 15-30 分钟\n     - 检查错误日志\n     - 留意用户报告\n```\n\n#### 第 4 步：回滚计划（如需）\n```yaml\n若部署失败：\n  1. 评估严重性\n     - 生产是否完全不可用？\n     - 数据是否有风险？\n     - 用户是否仍可工作？\n\n  2. 快速回滚选项\n     - VPS 上的蓝绿切换\n     - Git revert + 重新部署\n     - 从备份恢复（最后手段）\n\n  3. 执行回滚\n     - ssh root@167.71.39.50\n     - bash /opt/tsh_erp/bin/switch_deployment.sh\n\n  4. 调查并修复\n     - 诊断问题原因\n     - 在 develop 分支修复\n     - 充分测试\n     - 重新部署\n```\n\n### 质量门（必须通过）\n```yaml\n✅ 所有组件均已部署（不是只部署一个）\n✅ 生产前先验证预发布\n✅ 所有健康检查通过\n✅ 所有 URL 返回 200 OK\n✅ 数据库迁移已成功执行\n✅ 日志无错误\n✅ 部署已获 Khaleel 批准\n```\n\n---\n\n## 🔍 调研 / 研究\n\n### 适用场景\n- 理解现有代码\n- 研究最佳实践\n- 评估技术选型\n- 探索代码库结构\n\n### 分步工作流\n\n#### 第 1 步：明确问题\n```yaml\nActions：\n  1. 澄清要找的内容\n     - 具体：\"如何计算佣金？\"\n     - 不要模糊：\"钱是怎么回事？\"\n\n  2. 定义成功标准\n     - 哪些信息能回答问题？\n     - 深度需要到什么程度？\n```\n\n#### 第 2 步：搜索策略\n```yaml\n工具：\n  1. Grep（代码搜索）\n     - 搜索关键词\n     - 查找相似模式\n\n  2. Read（文件阅读）\n     - 阅读相关文件\n     - 理解上下文\n\n  3. Task（复杂搜索）\n     - 使用 Explore 代理深入调查\n     - 指定详尽程度\n\nExample：\n  “需要找到批发定价的计算方式”\n\n  1. grep -r \"wholesale.*price\" app/\n  2. grep -r \"commission\" app/services/\n  3. 阅读找到的文件\n  4. 追踪函数调用\n```\n\n#### 第 3 步：记录发现\n```yaml\nActions：\n  1. 总结发现\n     - 清晰解释\n     - 文件位置（含行号）\n     - 工作机制\n\n  2. 提供示例\n     - 实际代码片段\n     - 使用示例\n\n  3. 记录问题\n     - 发现的 Bug\n     - 不一致之处\n     - 改进机会\n\nExample Response：\n  “批发定价在 app/services/pricing.py:45 计算。\n\n   函数 calculate_wholesale_price() 包含：\n   1. 基础产品价格\n   2. 量级折扣（>100 单位 = 10%）\n   3. 客户表中的客户特定折扣\n\n   当前未考虑 PROJECT_VISION.md 中提到的季节性折扣。”\n```\n\n### 质量门（必须通过）\n```yaml\n✅ 问题定义清晰\n✅ 进行了彻底搜索（不仅仅第一个结果）\n✅ 发现包含文件路径与行号\n✅ 回答可执行\n✅ 相关问题已记录\n```\n\n---\n\n## 🧪 测试\n\n### 适用场景\n- 编写新测试\n- 修复失败测试\n- 提升测试覆盖率\n- 集成测试\n\n### 分步工作流\n\n#### 第 1 步：明确测试内容\n```yaml\n测试类型：\n  1. 单元测试\n     - 单个函数/方法\n     - 业务逻辑\n     - 数据变换\n\n  2. 集成测试\n     - API 接口\n     - 数据库操作\n     - 服务交互\n\n  3. 端到端测试\n     - 完整用户工作流\n     - 多组件交互\n```\n\n#### 第 2 步：编写测试\n```yaml\n结构（AAA 模式）：\n  1. Arrange：准备测试数据与环境\n  2. Act：执行被测代码\n  3. Assert：断言预期结果\n\n示例（Python/pytest）：\n  def test_wholesale_price_calculation():\n      # Arrange\n      product = Product(price=100.00)\n      client = Client(discount_percent=15)\n      quantity = 150\n\n      # Act\n      final_price = calculate_wholesale_price(product, client, quantity)\n\n      # Assert\n      assert final_price == 72.25  # 100 - 15% - 10%（量级）\n\n测试覆盖：\n  - 正常路径（预期输入）\n  - 边界值（边界场景）\n  - 错误场景（非法输入）\n  - 阿拉伯语文本（面向用户的功能）\n```\n\n#### 第 3 步：运行测试\n```yaml\nActions：\n  1. 先本地运行\n     - pytest tests/\n     - npm test\n     - flutter test\n\n  2. 修复任何失败\n     - 理解失败原因\n     - 修复代码或修复错误的测试\n\n  3. 验证覆盖率\n     - pytest --cov=app tests/\n     - 关键路径覆盖率目标 >80%\n```\n\n#### 第 4 步：集成 CI\n```yaml\nActions：\n  1. 确保测试在 CI 中运行\n     - GitHub Actions 应运行测试\n     - 测试必须在合并前通过\n\n  2. 保持测试快速\n     - 单元测试 < 1 秒/个\n     - 集成测试 < 5 秒/个\n     - Mock 外部服务（Zoho API）\n```\n\n### 质量门（必须通过）\n```yaml\n✅ 测试遵循 AAA 模式\n✅ 测试清晰聚焦\n✅ 覆盖正常路径 + 边界 + 错误\n✅ 测试运行快速\n✅ 本地全部通过\n✅ CI 全部通过\n```\n\n---\n\n## 🔐 安全增强\n\n### 适用场景\n- 添加安全特性\n- 修复安全漏洞\n- 实施认证/鉴权\n- 进行安全审计\n\n### 分步工作流\n\n#### 第 1 步：评估现状\n```yaml\nActions：\n  1. 检查安全姿态\n     - 是否启用认证？\n     - 是否启用鉴权？\n     - 输入校验？\n     - 防 SQL 注入？\n     - 防 XSS？\n     - CSRF 保护？\n\n  2. 识别漏洞\n     - 使用安全扫描工具\n     - 以常见问题审查代码\n     - 检查依赖的 CVE\n```\n\n#### 第 2 步：设计安全增强\n```yaml\nQuestions：\n  1. 我们在应对何种威胁？\n  2. 安全边界是什么？\n  3. 对用户的影响？\n  4. 性能影响？\n\n安全分层：\n  1. 认证（你是谁？）\n  2. 鉴权（你能做什么？）\n  3. 输入校验（是否安全？）\n  4. 输出编码（无法注入）\n  5. 审计日志（谁做了什么？）\n```\n\n#### 第 3 步：安全实施\n```yaml\n最佳实践：\n  1. 使用成熟库\n     - 不要自造加密\n     - 使用 FastAPI 安全工具\n     - 使用 SQLAlchemy（防 SQL 注入）\n\n  2. 纵深防御\n     - 多层安全措施\n     - 安全失败（默认拒绝）\n\n  3. 全面校验\n     - 永远不信任用户输入\n     - 后端校验（不只前端）\n     - 使用 Pydantic schema\n\n  4. 遵循 OWASP Top 10\n     - 注入\n     - 认证破坏\n     - 敏感数据暴露\n     - XML 外部实体（XXE）\n     - 访问控制破坏\n     - 安全错误配置\n     - 跨站脚本（XSS）\n     - 不安全反序列化\n     - 使用已知漏洞组件\n     - 日志与监控不足\n```\n\n#### 第 4 步：安全测试\n```yaml\nActions：\n  1. 攻击场景测试\n     - 试图绕过认证\n     - 尝试 SQL 注入\n     - 尝试 XSS 攻击\n     - 尝试未授权访问\n\n  2. 安全扫描\n     - 运行 bandit（Python 安全 linter）\n     - 运行 npm audit（Node.js）\n     - 检查依赖\n\n  3. 渗透测试\n     - 手工测试安全控制\n     - 自动化安全扫描\n```\n\n#### 第 5 步：文档与监控\n```yaml\nActions：\n  1. 记录安全措施\n     - 保护了什么\n     - 如何保护\n     - 假设条件\n\n  2. 建立监控\n     - 登录失败次数\n     - 异常访问模式\n     - 安全事件日志\n\n  3. 事件响应预案\n     - 发现入侵后如何处理\n     - 联系谁\n     - 如何隔离\n```\n\n### 质量门（必须通过）\n```yaml\n✅ 威胁清晰识别\n✅ 遵循安全最佳实践\n✅ 已实施输入校验\n✅ 认证/鉴权已执行\n✅ 防 SQL 注入（使用 ORM）\n✅ 防 XSS（输出编码）\n✅ 安全测试通过\n✅ 无硬编码密钥\n✅ 审计日志就位\n```\n\n---\n\n## 📊 任务模式选择决策树\n\n```\n开始\n  ↓\n是否在添加新功能？\n  是 → 🧩 功能实现\n  否 → 继续\n  ↓\n是否有损坏的功能？\n  是 → 🐛 Bug 修复\n  否 → 继续\n  ↓\n是否在提升代码质量或性能？\n  是 → 🧠 重构 / 优化\n  否 → 继续\n  ↓\n是否在更新文档？\n  是 → 🧾 文档更新\n  否 → 继续\n  ↓\n是否在部署改动？\n  是 → 🔄 部署 / CI/CD 任务\n  否 → 继续\n  ↓\n是否在搜索/理解代码？\n  是 → 🔍 调研 / 研究\n  否 → 继续\n  ↓\n是否在编写/修复测试？\n  是 → 🧪 测试\n  否 → 继续\n  ↓\n是否与安全相关？\n  是 → 🔐 安全增强\n  否 → 询问 Khaleel 以澄清\n```\n\n---\n\n## ✅ 通用质量原则\n\n适用于所有任务类型：\n\n```yaml\n开始前：\n  - [ ] 阅读 PROJECT_VISION.md（理解业务背景）\n  - [ ] 阅读 ARCHITECTURE_RULES.md（遵循模式）\n  - [ ] 搜索现有代码（优先增强而非新建）\n  - [ ] 若不确定则提出澄清问题\n\n进行中：\n  - [ ] 遵循命名约定\n  - [ ] 包含阿拉伯语支持（若面向用户）\n  - [ ] 添加校验与错误处理\n  - [ ] 编写清晰 docstrings 与注释\n  - [ ] 持续测试\n\n完成前：\n  - [ ] 本地已测试\n  - [ ] 代码整洁可读\n  - [ ] 文档已更新（如需）\n  - [ ] 使用清晰信息提交\n  - [ ] 部署到预发布（若为部署任务）\n  - [ ] 验证工作正常\n```\n\n---\n\n## 🎯 成功指标\n\n当你有效地使用任务模式时：\n\n- ✅ 各任务类型均遵循一致步骤\n- ✅ 不跳过关键步骤（特别是上下文加载）\n- ✅ 质量门在标记完成前均已通过\n- ✅ Khaleel 不需重复同样指令\n- ✅ 功能首次即可正确工作\n- ✅ 代码遵循既定模式\n- ✅ 文档保持更新\n\n---\n\n**任务模式（中文版）结束**",
        "skills/openspec-implementation-cn/reference/TESTING_STRATEGIES.md": "# 测试策略\n\n下述为各类测试的目的与粗略的覆盖率目标：\n\n## 单元测试 - 90-100%\n\n由程序员编写，面向程序员，用于在最低层次对系统进行规格化，并作为持续集成的一部分执行。\n\n## 组件测试 - 50%\n\n由 QA 与业务在开发者协助下编写，主要覆盖常规路径与明显的边界情况，验证给定输入的输出符合期望。\n\n### 端到端测试 - 70-100%\n\n由 QA 与业务在开发者协助下编写，“端到端”测试是指你做一个断言，这个断言涉及系统逻辑的一个完整“路径”。也就是说，你启动整个系统，在用户输入的入口点执行某些操作，然后检查系统产生的结果。你不在乎内部如何实现这个目标，你只关心输入和结果。这对于所有测试通常都是真实的，但在这里我们只是在系统输入的最外层进行测试，并检查它产生的最外层结果。\n\n## 集成测试 - 20%\n\n通常由系统架构师或首席设计师编写，确保组件正确连接并清晰通信。\n\n## 系统测试 - 10%\n\n通常由系统架构师与技术负责人编写，测试系统被正确地构建。\n\n## 手工探索性测试 - 5%\n\n由测试人员（或任何人）进行，探索系统在人工操作下的表现，并尽可能创造性地发现尽量多的“怪异”行为。",
        "skills/openspec-implementation/SKILL.md": "---\nname: openspec-implementation\ndescription: Implements approved specification proposals by working through tasks sequentially with testing and validation. Use when implementing changes, applying proposals, executing spec tasks, or building from approved plans. Triggers include \"openspec implement\", \"implement\", \"apply change\", \"execute spec\", \"work through tasks\", \"build feature\", \"start implementation\".\n---\n\n# Specification Implementation\n\nSystematically implements approved spec proposals by executing tasks sequentially with proper testing and validation.\n\n## Quick Start\n\nImplementation follows a read → execute → test → validate cycle for each task:\n1. Read the full proposal and task list\n2. Execute tasks one at a time, in order\n3. Test each completed task\n4. Mark complete only after verification\n\n**Critical rule**: Use TodoWrite to track progress. Never skip tasks or mark incomplete work as done.\n\n## Workflow\n\nCopy this checklist and track progress:\n\n```\nImplementation Progress:\n- [ ] Step 1: Load and understand the proposal\n- [ ] Step 2: Set up TodoWrite task tracking\n- [ ] Step 3: Execute tasks sequentially\n- [ ] Step 4: Test and validate each task\n- [ ] Step 5: Update living specifications (if applicable)\n- [ ] Step 6: Mark proposal as implementation-complete\n```\n\n### Step 1: Load and understand the proposal\n\nBefore starting, read all context:\n\n```bash\n# Read the proposal\ncat spec/changes/{change-id}/proposal.md\n\n# Read all tasks\ncat spec/changes/{change-id}/tasks.md\n\n# Read spec deltas to understand requirements\nfind spec/changes/{change-id}/specs -name \"*.md\" -exec cat {} \\;\n```\n\n**Understand**:\n- Why this change is needed (from proposal.md)\n- What the expected outcomes are\n- Which specs will be affected\n- What the acceptance criteria are (from scenarios)\n\n### Step 2: Set up TodoWrite task tracking\n\nLoad tasks from tasks.md into TodoWrite **before starting work**:\n\n```markdown\n**Pattern**:\nRead tasks.md → Extract numbered list → Create TodoWrite entries\n\n**Example**:\nIf tasks.md contains:\n1. Create database migration\n2. Implement API endpoint\n3. Add tests\n4. Update documentation\n\nThen create TodoWrite with:\n- content: \"Create database migration\", status: \"in_progress\"\n- content: \"Implement API endpoint\", status: \"pending\"\n- content: \"Add tests\", status: \"pending\"\n- content: \"Update documentation\", status: \"pending\"\n```\n\n**Why this matters**: TodoWrite gives the user visibility into progress and ensures nothing gets skipped.\n\n### Step 3: Execute tasks sequentially\n\nWork through tasks **one at a time, in order**:\n\n```markdown\nFor each task:\n1. Mark as \"in_progress\" in TodoWrite\n2. Execute the work\n3. Test the work\n4. Only mark \"completed\" after verification\n\nNEVER skip ahead or batch multiple tasks before testing.\n```\n\n**Task execution pattern**:\n\n```markdown\n## Task: {Task Description}\n\n**What**: [Brief explanation of what this task does]\n\n**Implementation**:\n[Code changes, file edits, commands run]\n\n**Verification**:\n[How to verify this task is complete]\n- [ ] Code compiles/runs\n- [ ] Tests pass\n- [ ] Meets requirement scenarios\n\n**Status**: ✓ Complete / ✗ Blocked / ⚠ Partial\n```\n\n### Step 4: Test and validate each task\n\nAfter each task, verify it works:\n\n**For code tasks**:\n```bash\n# Run relevant tests\nnpm test # or pytest, cargo test, etc.\n\n# Run linter\nnpm run lint\n\n# Check types (if applicable)\nnpm run type-check\n```\n\n**For database tasks**:\n```bash\n# Verify migration runs\nnpm run db:migrate\n\n# Check schema matches expected\nnpm run db:schema\n```\n\n**For API tasks**:\n```bash\n# Test endpoint manually\ncurl -X POST http://localhost:3000/api/endpoint \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"test\": \"data\"}'\n\n# Or run integration tests\nnpm run test:integration\n```\n\n**Only mark task complete after all verifications pass**.\n\n### Step 5: Update living specifications (if applicable)\n\n**During implementation**, if you discover the spec deltas need updates:\n\n1. **Document the discovery** in proposal.md or a notes file\n2. **Do NOT modify spec deltas** during implementation\n3. **After implementation completes**, consider whether spec needs adjustment\n\n**Note**: Spec deltas are merged during archiving (Step 6), not during implementation.\n\n### Step 6: Mark proposal as implementation-complete\n\nAfter all tasks are complete:\n\n```bash\n# Create a completion marker\necho \"Implementation completed: $(date)\" > spec/changes/{change-id}/IMPLEMENTED\n```\n\n**Tell the user**:\n```markdown\n## Implementation Complete\n\n**Change**: {change-id}\n**Tasks completed**: {count}\n**Tests**: All passing\n\n**Next step**: Archive this change to merge spec deltas into living documentation.\nSay \"openspec archive {change-id}\" or \"archive this change\" when ready.\n```\n\n## Best Practices\n\n### Pattern 1: Blocked Tasks\n\nIf a task cannot be completed:\n\n```markdown\n**Mark as blocked**:\n- Keep status as \"in_progress\" (NOT \"completed\")\n- Document the blocker clearly\n- Create a new task for resolving the blocker\n- Inform the user immediately\n\n**Example**:\nTask: \"Implement payment processing\"\nBlocker: \"Missing API credentials for payment gateway\"\nAction: Create new task \"Obtain payment gateway credentials\"\n```\n\n### Pattern 2: Task Dependencies\n\nIf tasks have dependencies, verify prerequisites before starting:\n\n```bash\n# Example: Database migration must run before API code\n# Check migration status\nnpm run db:status\n\n# Only proceed with API task if migration succeeded\n```\n\n### Pattern 3: Incremental Testing\n\nTest incrementally, not at the end:\n\n**Good**:\n```\nTask 1: Create model → Test model → Mark complete\nTask 2: Create API → Test API → Mark complete\nTask 3: Add validation → Test validation → Mark complete\n```\n\n**Bad**:\n```\nTask 1, 2, 3 → Implement all → Test everything → Debug failures\n```\n\n### Pattern 4: Living Documentation\n\nKeep README, API docs, and comments up to date **as you go**:\n\n```markdown\nWhen adding a new API endpoint, also:\n- Update API documentation\n- Add example request/response\n- Update OpenAPI/Swagger spec\n- Add inline code comments\n```\n\n## Advanced Topics\n\n**Parallel work**: If tasks are truly independent (e.g., separate modules), you can work on them in parallel, but each must be tested independently.\n\n**Integration points**: When task dependencies exist, use integration tests to verify the connection works.\n\n**Rollback strategy**: For risky changes, create rollback tasks before deploying.\n\n## Common Patterns\n\n### Pattern 1: Database + API + UI\n\nTypical order:\n1. Database schema/migration\n2. Data access layer (models)\n3. Business logic layer (services)\n4. API endpoints (controllers)\n5. UI integration\n6. End-to-end tests\n\n### Pattern 2: Feature Flags\n\nFor gradual rollouts:\n1. Implement feature behind flag\n2. Test with flag enabled\n3. Deploy with flag disabled\n4. Enable flag incrementally\n5. Remove flag after full rollout\n\n### Pattern 3: Breaking Changes\n\nFor API breaking changes:\n1. Implement new version (v2)\n2. Keep old version (v1) working\n3. Add deprecation warnings to v1\n4. Migrate users to v2\n5. Remove v1 (separate task/proposal)\n\n## Anti-Patterns to Avoid\n\n**Don't**:\n- Skip testing individual tasks\n- Mark tasks complete before verification\n- Ignore failing tests (\"I'll fix it later\")\n- Batch multiple tasks before testing\n- Modify living specs during implementation\n- Work out of order (dependencies break)\n\n**Do**:\n- Test each task immediately\n- Fix failing tests before proceeding\n- Update TodoWrite in real-time\n- Document blockers clearly\n- Communicate progress to user\n- Keep commits atomic and descriptive\n\n## Troubleshooting\n\n### Issue: Tests failing after task completion\n\n**Solution**:\n```markdown\n1. Do NOT mark task complete\n2. Debug the failure\n3. Fix the code\n4. Re-run tests\n5. Only mark complete after pass\n```\n\n### Issue: Task is too large\n\n**Solution**:\n```markdown\n1. Break into subtasks\n2. Update TodoWrite with subtasks\n3. Complete subtasks sequentially\n4. Mark parent task complete after all subtasks done\n```\n\n### Issue: Dependency not met\n\n**Solution**:\n```markdown\n1. Pause current task\n2. Complete dependency first\n3. Test dependency\n4. Resume original task\n```\n\n## Reference Materials\n\n- [TASK_PATTERNS.md](reference/TASK_PATTERNS.md) - Common task execution patterns\n- [TESTING_STRATEGIES.md](reference/TESTING_STRATEGIES.md) - Testing approaches by task type\n\n---\n\n**Token budget**: This SKILL.md is approximately 430 lines, under the 500-line recommended limit.\n",
        "skills/openspec-proposal-creation-cn/SKILL.md": "---\nname: openspec-proposal-creation-cn\ndescription: 通过openspec规范驱动的方法创建结构化的变更提案与规范差异。用于规划功能、创建提案、编写规范、引入新能力或启动开发流程。触发词包括 \"openspec提案\", \"规划\", \"创建提案\", \"规划变更\", \"规范功能\", \"新功能\", \"新特性\", \"新需求\", \"添加功能规划\", \"设计规范\"。\n---\n\n# 规范提案创建\n\n遵循规范驱动开发方法，生成完整的变更提案。\n\n## 快速开始\n\n创建规范提案包含三类输出：\n1. **proposal.md** - 为什么、做什么、影响摘要\n2. **tasks.json** - 编号的实施清单\n3. **spec-delta.md** - 正式的需求变更（ADDED/MODIFIED/REMOVED）\n\n**基本流程**：生成变更 ID → 脚手架目录 → 起草提案 → 编写规范差异 → 验证结构\n\n## 工作流\n\n复制此清单并跟踪进度：\n\n```\n规划进度:\n- [ ] 第 1 步：审阅现有规范\n- [ ] 第 2 步：生成唯一的变更 ID\n- [ ] 第 3 步：生成目录结构\n- [ ] 第 4 步：起草 proposal.md（为什么、做什么、影响摘要）\n- [ ] 第 5 步：创建 tasks.json 实施清单\n- [ ] 第 6 步：编写 spec-delta.md 规范差异（ADDED/MODIFIED/REMOVED）\n- [ ] 第 7 步：验证提案结构\n- [ ] 第 8 步：向用户展示并请求审批\n```\n\n### 第 1 步：审阅现有规范\n\n在创建提案前，了解当前状态：\n\n```bash\n# 列出所有现有规范\nfind spec/specs -name \"spec.md\" -type f\n\n# 列出进行中的变更以避免冲突\nfind spec/changes -maxdepth 1 -type d -not -path \"*/archive\"\n\n# 搜索相关需求\ngrep -r \"### Requirement:\" spec/specs/\n```\n\n### 第 2 步：生成唯一的变更 ID\n\n选择具描述性、URL 安全的标识符：\n\n**格式**：`add-<feature>`、`fix-<issue>`、`update-<component>`、`remove-<feature>`\n\n**示例**：\n- `add-user-authentication`\n- `fix-payment-validation`\n- `update-api-rate-limits`\n- `remove-legacy-endpoints`\n\n**校验**：检查是否冲突：\n```bash\nls spec/changes/ | grep -i \"<proposed-id>\"\n```\n\n### 第 3 步：生成目录结构\n\n按标准结构创建变更目录：\n\n```bash\n# 将 {change-id} 替换为实际 ID\nmkdir -p spec/changes/{change-id}/specs/{capability-name}\n```\n\n**示例**：\n```bash\nmkdir -p spec/changes/add-user-auth/specs/authentication\n```\n\n### 第 4 步：起草 proposal.md\n\n以 [templates/proposal.md](templates/proposal.md) 为起点。\n\n**必需章节**：\n- **Why**：驱动变更的问题或机会\n- **What Changes**：修改项清单\n- **Impact**：受影响的规范、代码、API、用户\n\n**语气**：清晰、简洁、面向决策。避免不必要背景。\n\n### 第 5 步：创建 tasks.json 实施清单\n\n将实现拆分为具体、可测试的任务。使用 [templates/tasks.json](templates/tasks.json)。\n\n**格式**：\n```markdown\n# 实施任务\n```json\n[\n  {\n    \"number\": 1,\n    \"category\": \"阶段 1：基础设施\",\n    \"task\": \"环境搭建任务 - 数据库架构、依赖等\",\n    \"steps\": [\n      { \"step\": \"初始化 Git 仓库并配置 .gitignore\", \"completed\": false },\n      { \"step\": \"创建并激活 Python 虚拟环境\", \"completed\": false },\n      { \"step\": \"创建 requirements.txt 或 pyproject.toml 并安装依赖 (FastAPI, SQLAlchemy, Pydantic, Alembic 等)\", \"completed\": false },\n      { \"step\": \"设计初始数据库 ER 图\", \"completed\": false },\n      { \"step\": \"配置数据库连接字符串和环境变量 (.env)\", \"completed\": false },\n      { \"step\": \"初始化 Alembic 迁移环境\", \"completed\": false }\n    ],\n    \"passes\": false\n  }\n]\n\n\n**最佳实践**：\n- 每个任务可独立完成\n- 为每个主要组件添加测试任务\n- 为每个主要组件添加测试任务\n- 包含测试与验证任务\n- 按依赖排序（数据库先于 API 等）\n- 通常 5-15 个任务；更多时应拆分\n- 每次仅处理1个step\n\n```\n\n### 第 6 步：以 EARS 格式编写规范差异\n\n这是最关键步骤。规范差异使用 **EARS 格式**（易于需求语法）。\n\n**完整 EARS 指南**见 [reference/EARS_FORMAT.md](reference/EARS_FORMAT.md)\n\n**差异操作**：\n- `## ADDED Requirements` - 新增能力\n- `## MODIFIED Requirements` - 行为变更（包含完整更新文本）\n- `## REMOVED Requirements` - 弃用功能\n\n**基本需求结构**：\n```markdown\n## ADDED Requirements\n\n### Requirement: 用户登录\nWHEN 用户提交有效凭据,\n系统 SHALL 认证用户并创建会话。\n\n#### Scenario: 登录成功\nGIVEN 用户邮箱为 \"user@example.com\" 且密码为 \"correct123\"\nWHEN 用户提交登录表单\nTHEN 系统创建已认证会话\nAND 重定向至仪表盘\n```\n\n**用于验证的模式**见 [reference/VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md)\n\n### 第 7 步：验证提案结构\n\n在展示给用户前运行以下检查：\n\n```markdown\n结构清单：\n- [ ] 目录存在：`spec/changes/{change-id}/`\n- [ ] proposal.md 包含 Why/What/Impact\n- [ ] tasks.json 含编号任务列表（5-15 项）\n- [ ] 规范差异包含操作标题（ADDED/MODIFIED/REMOVED）\n- [ ] 需求遵循 `### Requirement: <name>` 格式\n- [ ] 场景使用 `#### Scenario:` 格式（四个井号）\n```\n\n**自动化检查**：\n```bash\n# 统计差异操作（应 > 0）\ngrep -c \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/{change-id}/specs/**/*.md\n\n# 验证场景格式（显示行号）\ngrep -n \"#### Scenario:\" spec/changes/{change-id}/specs/**/*.md\n\n# 检查需求标题\ngrep -n \"### Requirement:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n### 第 8 步：提交用户评审\n\n清晰总结提案：\n\n```markdown\n## Proposal Summary\n\n**Change ID**：{change-id}\n**Scope**：{简要描述}\n\n**创建的文件**：\n- spec/changes/{change-id}/proposal.md\n- spec/changes/{change-id}/tasks.json\n- spec/changes/{change-id}/specs/{capability}/spec-delta.md\n\n**下一步**：\n请评审提案。如认可或修正后，请回复 \"openspec开发\" 或 \"按顺序完成任务\" 开始实施。\n```\n\n## 进阶主题\n\n**EARS 格式细节**：见 [reference/EARS_FORMAT.md](reference/EARS_FORMAT.md)\n**验证模式**：见 [reference/VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md)\n**完整示例**：见 [reference/EXAMPLES.md](reference/EXAMPLES.md)\n\n## 常见模式\n\n### 模式 1：新增功能提案\n\n新增能力时：\n- 使用 `ADDED Requirements` 差异\n- 同时包含正向场景与错误处理\n- 在场景中考虑边界情况\n\n### 模式 2：破坏性变更提案\n\n修改既有行为时：\n- 使用 `MODIFIED Requirements` 差异\n- 包含完整更新后的需求文本\n- 在 proposal.md 中说明变更内容与原因\n- 在 tasks.json 中考虑迁移任务\n\n### 模式 3：弃用提案\n\n移除功能时：\n- 使用 `REMOVED Requirements` 差异\n- 在 proposal.md 中记录移除理由\n- 在 tasks.json 中包含清理任务\n- 在影响部分考虑用户迁移\n\n## 反模式避免\n\n**不要**：\n- 跳过验证检查（务必运行 grep 模式）\n- 未先审阅现有规范就创建提案\n- 使用含糊的任务描述（如\"修一下\"）\n- 编写不含场景的需求\n- 忽略错误处理场景\n- 在一个提案中混合多个无关变更\n\n**要**：\n- 在创建变更 ID 前检查冲突\n- 编写具体、可测试的任务\n- 同时包含正向与负向场景\n- 一个提案只处理一个关注点\n- 在展示前验证结构\n\n## 文件模板\n\n所有模板位于 `templates/` 目录：\n- [proposal.md](templates/proposal.md) - 提案结构\n- [tasks.json](templates/tasks.json) - 任务清单格式\n- [spec-delta.md](templates/spec-delta.md) - 规范差异模板\n\n## 参考资料\n\n- [EARS_FORMAT.md](reference/EARS_FORMAT.md) - 完整 EARS 语法指南\n- [VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md) - Grep/bash 验证\n- [EXAMPLES.md](reference/EXAMPLES.md) - 真实提案示例\n\n---\n\n**Token 预算**：此 SKILL.md 约 250 行，低于建议的 500 行上限。引用文件按需加载以逐步呈现。",
        "skills/openspec-proposal-creation-cn/reference/EARS_FORMAT.md": "# EARS 格式指南\n\nEARS（Easy Approach to Requirements Syntax）提供了一种结构化格式，用于编写清晰、可测试的需求。\n\n## 目录\n- 需求结构与关键字\n- 场景格式（Given/When/Then）\n- 需求类型与模式\n- 示例与反模式\n\n## 需求结构\n\n### 基本格式\n\n```markdown\n### Requirement: {描述性名称}\n{TRIGGER 子句},\n系统 SHALL {动作与结果}。\n```\n\n### 触发类型\n\n**WHEN**（事件驱动）：\n```markdown\n### Requirement: 保存用户资料\nWHEN 用户点击“保存”按钮,\n系统 SHALL 将资料变更持久化到数据库。\n```\n\n**IF**（状态驱动）：\n```markdown\n### Requirement: 免运费\nIF 购物车总额超过 $50,\n系统 SHALL 免除运费。\n```\n\n**WHERE**（特定范围）：\n```markdown\n### Requirement: 管理员访问\nWHERE 用户具有管理员权限,\n系统 SHALL 显示管理面板。\n```\n\n**WHILE**（持续进行）：\n```markdown\n### Requirement: 实时同步\nWHILE 文档处于打开状态,\n系统 SHALL 每 5 秒同步一次更改。\n```\n\n## SHALL / SHOULD / MAY\n\n- **SHALL**：具约束性的需求（必须实现）\n- **SHOULD**：推荐但非强制\n- **MAY**：可选能力\n\n**生产环境需求优先使用 SHALL**。谨慎使用 SHOULD/MAY。\n\n## 场景格式\n\n每条需求必须包含展示预期行为的场景。\n\n### 结构\n\n```markdown\n#### Scenario: {描述性名称}\nGIVEN {前置条件}\nAND {附加前置条件}\nWHEN {动作或触发}\nTHEN {期望结果}\nAND {附加结果}\n```\n\n### 示例：完整的需求与场景\n\n```markdown\n### Requirement: 用户登录\nWHEN 用户提交有效凭据,\n系统 SHALL 认证用户并创建会话。\n\n#### Scenario: 登录成功\nGIVEN 一个已注册用户，邮箱为 \"user@example.com\"\nAND 用户拥有正确密码 \"SecurePass123\"\nWHEN 用户提交登录表单\nTHEN 系统创建已认证会话\nAND 重定向用户至仪表盘\nAND 设置 24 小时过期的会话 Cookie\n\n#### Scenario: 密码错误\nGIVEN 一个已注册用户，邮箱为 \"user@example.com\"\nAND 用户提供错误密码 \"WrongPass\"\nWHEN 用户提交登录表单\nTHEN 系统拒绝登录尝试\nAND 显示错误信息 \"Invalid email or password\"\nAND 不创建会话\n\n#### Scenario: 账户被锁定\nGIVEN 该账户因失败尝试而被锁定\nWHEN 用户提交任意凭据\nTHEN 系统拒绝登录尝试\nAND 显示错误信息 \"Account locked. Contact support.\"\n```\n\n## 需求模式\n\n### 模式 1：数据校验\n\n```markdown\n### Requirement: 邮箱格式校验\nWHEN 用户输入邮箱地址,\n系统 SHALL 验证其格式符合 RFC 5322 标准。\n\n#### Scenario: 合法邮箱\nGIVEN 用户输入邮箱 \"test@example.com\"\nWHEN 表单提交\nTHEN 系统接受该邮箱\n\n#### Scenario: 格式非法\nGIVEN 用户输入 \"not-an-email\"\nWHEN 表单提交\nTHEN 系统显示错误 \"Invalid email format\"\n```\n\n### 模式 2：授权\n\n```markdown\n### Requirement: 删除权限\nWHERE 用户尝试删除资源,\n系统 SHALL 验证用户拥有资源或具备管理员权限。\n\n#### Scenario: 所有者删除\nGIVEN 用户拥有文档 ID 123\nWHEN 用户请求删除文档 123\nTHEN 系统删除该文档\n\n#### Scenario: 非所有者被阻止\nGIVEN 用户不拥有文档 ID 456\nAND 用户不具备管理员权限\nWHEN 用户请求删除文档 456\nTHEN 系统返回 HTTP 403 Forbidden\n```\n\n### 模式 3：状态流转\n\n```markdown\n### Requirement: 订单处理\nWHEN 订单被创建,\n系统 SHALL 按状态流转：pending → processing → shipped → delivered。\n\n#### Scenario: 标准流程\nGIVEN 新订单处于 \"pending\" 状态\nWHEN 支付确认\nTHEN 系统流转至 \"processing\"\nWHEN 物品发货\nTHEN 系统流转至 \"shipped\"\nWHEN 确认送达\nTHEN 系统流转至 \"delivered\"\n```\n\n## 反模式避免\n\n### ❌ 需求含糊\n\n**坏示例**：\n```markdown\n### Requirement: 高性能\n系统应该很快。\n```\n\n**好示例**：\n```markdown\n### Requirement: API 响应时间\nWHEN 发起 API 请求,\n系统 SHALL 在 95% 的请求中于 200 毫秒内响应。\n\n#### Scenario: 正常负载\nGIVEN 系统处于正常负载（< 100 请求/秒）\nWHEN 发起 API 请求\nTHEN 响应时间小于 200ms\n```\n\n### ❌ 缺少场景\n\n**坏示例**：\n```markdown\n### Requirement: 文件上传\nWHEN 用户上传文件,\n系统 SHALL 存储它。\n```\n\n**好示例**：\n```markdown\n### Requirement: 文件上传\nWHEN 用户上传小于 10MB 的文件,\n系统 SHALL 将其存储到 S3 并返回 URL。\n\n#### Scenario: 上传成功\nGIVEN 用户选择一个 5MB 的 PDF 文件\nWHEN 上传完成\nTHEN 系统将文件存储到 S3\nAND 返回 1 小时有效的签名 URL\n\n#### Scenario: 文件过大\nGIVEN 用户选择一个 15MB 的视频文件\nWHEN 尝试上传\nTHEN 系统拒绝该文件\nAND 显示错误 \"File size exceeds 10MB limit\"\n```\n\n### ❌ 在需求中写实现细节\n\n**坏示例**：\n```markdown\n### Requirement: 密码存储\n系统 SHALL 使用 bcrypt，工作因子为 12，并将哈希存储在用户表。\n```\n\n**好示例**：\n```markdown\n### Requirement: 安全的密码存储\nWHEN 用户设置密码,\n系统 SHALL 在存储前使用业界标准的不可逆哈希进行处理。\n\n#### Scenario: 创建密码\nGIVEN 用户设置密码 \"SecurePass123\"\nWHEN 系统处理该密码\nTHEN 系统仅存储密码的加密哈希\nAND 丢弃明文密码\nAND 为每位用户使用唯一盐值\n```\n\n（关于 bcrypt/工作因子的实现选择应写在设计文档，而非需求中）\n\n## 完整示例：用户注册\n\n```markdown\n## ADDED Requirements\n\n### Requirement: 账户创建\nWHEN 用户提交包含有效数据的注册表单,\n系统 SHALL 创建新账户并发送验证邮件。\n\n#### Scenario: 注册成功\nGIVEN 用户提供邮箱 \"new@example.com\"\nAND 提供密码 \"SecurePass123\"\nAND 提供姓名 \"John Doe\"\nAND 该邮箱尚未被注册\nWHEN 用户提交注册表单\nTHEN 系统创建新用户账户\nAND 向 \"new@example.com\" 发送验证邮件\nAND 显示信息 \"Check your email to verify your account\"\nAND 重定向至登录页\n\n#### Scenario: 邮箱重复\nGIVEN 用户提供邮箱 \"existing@example.com\"\nAND 该邮箱已被注册\nWHEN 用户提交注册表单\nTHEN 系统拒绝注册\nAND 显示错误 \"This email is already registered\"\nAND 不发送邮件\n\n#### Scenario: 密码过弱\nGIVEN 用户提供密码 \"123\"\nWHEN 用户提交注册表单\nTHEN 系统拒绝注册\nAND 显示错误 \"Password must be at least 8 characters\"\n\n### Requirement: 邮件验证\nWHEN 用户点击验证链接,\n系统 SHALL 在令牌有效且未过期时激活账户。\n\n#### Scenario: 令牌有效\nGIVEN 用户收到验证邮件\nAND 验证令牌未超过 24 小时\nWHEN 用户点击验证链接\nTHEN 系统激活账户\nAND 显示信息 \"Account verified successfully\"\nAND 重定向至登录页\n\n#### Scenario: 令牌过期\nGIVEN 验证令牌已超过 24 小时\nWHEN 用户点击验证链接\nTHEN 系统拒绝验证\nAND 显示信息 \"Verification link expired. Request a new one.\"\n```\n\n## 摘要清单\n\n编写需求时：\n- [ ] 使用 SHALL 表示具约束性需求\n- [ ] 包含触发子句（WHEN/IF/WHERE/WHILE）\n- [ ] 写清动作与结果\n- [ ] 至少包含一个正向场景\n- [ ] 包含错误/边界场景\n- [ ] 场景使用 Given/When/Then 格式\n- [ ] 避免实现细节\n- [ ] 使需求可测试",
        "skills/openspec-proposal-creation-cn/reference/VALIDATION_PATTERNS.md": "# 验证模式\n\n使用 grep 与 bash 的模式，在不依赖外部 CLI 工具的情况下验证提案结构。\n\n## 目录\n- 目录结构验证\n- 提案文件验证\n- 规范差异验证\n- 需求格式验证\n- 常用验证工作流\n\n## 目录结构验证\n\n### 检查变更目录是否存在\n\n```bash\n# 验证变更目录是否已创建\ntest -d spec/changes/{change-id} && echo \"✓ 目录存在\" || echo \"✗ 目录缺失\"\n```\n\n### 列出所有变更\n\n```bash\n# 显示所有进行中的变更\nls -1 spec/changes/ | grep -v \"archive\"\n```\n\n### 检查是否有冲突\n\n```bash\n# 搜索相似的变更 ID\nls spec/changes/ | grep -i \"{search-term}\"\n```\n\n## 提案文件验证\n\n### 检查必需章节\n\n```bash\n# 验证 proposal.md 是否包含必需章节\ngrep -c \"## Why\" spec/changes/{change-id}/proposal.md\ngrep -c \"## What Changes\" spec/changes/{change-id}/proposal.md\ngrep -c \"## Impact\" spec/changes/{change-id}/proposal.md\n```\n\n**预期**：每个 grep 返回 1（如果有子章节则可能大于 1）\n\n### 验证任务文件\n\n```bash\n# 统计任务数量\ngrep -c '\"task\":' spec/changes/{change-id}/tasks.json\n\n# 显示任务列表\ngrep '\"task\":' spec/changes/{change-id}/tasks.json\n```\n\n**预期**：通常为 5-15 个任务\n\n## 规范差异验证\n\n### 检查差异操作是否存在\n\n```bash\n# 统计差异操作标题数量\ngrep -c \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**预期**：至少 1 个匹配\n\n### 列出差异操作\n\n```bash\n# 以行号显示所有差异操作\ngrep -n \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**示例输出**：\n```\nspec/changes/add-auth/specs/authentication/spec-delta.md:3:## ADDED Requirements\nspec/changes/add-auth/specs/authentication/spec-delta.md:45:## MODIFIED Requirements\n```\n\n### 验证各部分是否有内容\n\n```bash\n# 检查 ADDED 部分是否包含需求\nawk '/## ADDED/,/^## [A-Z]/ {if (/### Requirement:/) count++} END {print count}' \\\n    spec/changes/{change-id}/specs/**/*.md\n```\n\n## 需求格式验证\n\n### 检查需求标题\n\n```bash\n# 列出所有需求标题\ngrep -n \"### Requirement:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**期望格式**：`### Requirement: 描述性名称`\n\n### 验证场景格式\n\n```bash\n# 检查场景（必须使用四个井号）\ngrep -n \"#### Scenario:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**期望格式**：`#### Scenario: 描述性名称`\n\n### 统计需求与场景数量\n\n```bash\n# 统计需求数量\nREQS=$(grep -c \"### Requirement:\" spec/changes/{change-id}/specs/**/*.md)\n\n# 统计场景数量\nSCENARIOS=$(grep -c \"#### Scenario:\" spec/changes/{change-id}/specs/**/*.md)\n\necho \"需求数：$REQS\"\necho \"场景数：$SCENARIOS\"\necho \"比率：$(echo \"scale=1; $SCENARIOS/$REQS\" | bc)\"\n```\n\n**预期**：比率 >= 2.0（每个需求至少 2 个场景）\n\n### 检查 SHALL 关键字\n\n```bash\n# 验证需求中是否使用 SHALL（具约束性的要求指示）\ngrep -c \"SHALL\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**预期**：SHALL 的数量至少与需求数量相当\n\n## 完整验证工作流\n\n### 预提交验证脚本\n\n```bash\n#!/bin/bash\n# 验证变更提案结构\n\nCHANGE_ID=\"$1\"\nBASE_PATH=\"spec/changes/$CHANGE_ID\"\n\necho \"正在验证提案：$CHANGE_ID\"\necho \"================================\"\n\n# 1. 目录存在\nif [ ! -d \"$BASE_PATH\" ]; then\n    echo \"✗ 变更目录未找到\"\n    exit 1\nfi\necho \"✓ 变更目录存在\"\n\n# 2. 必需文件存在\nfor file in proposal.md tasks.json; do\n    if [ ! -f \"$BASE_PATH/$file\" ]; then\n        echo \"✗ 缺少 $file\"\n        exit 1\n    fi\n    echo \"✓ 找到 $file\"\ndone\n\n# 3. 提案包含必需章节\nfor section in \"## Why\" \"## What Changes\" \"## Impact\"; do\n    if ! grep -q \"$section\" \"$BASE_PATH/proposal.md\"; then\n        echo \"✗ proposal.md 缺少章节：$section\"\n        exit 1\n    fi\ndone\necho \"✓ proposal.md 包含所需章节\"\n\n# 4. 任务文件包含 'task' 键\nTASK_COUNT=$(grep -c '\"task\":' \"$BASE_PATH/tasks.json\" || echo \"0\")\nif [ \"$TASK_COUNT\" -lt 3 ]; then\n    echo \"✗ tasks.json 任务数量不足（$TASK_COUNT）\"\n    exit 1\nfi\necho \"✓ 找到 $TASK_COUNT 个任务\"\n\n# 5. 存在规范差异文件\nDELTA_COUNT=$(find \"$BASE_PATH/specs\" -name \"*.md\" 2>/dev/null | wc -l)\nif [ \"$DELTA_COUNT\" -eq 0 ]; then\n    echo \"✗ 未找到规范差异文件\"\n    exit 1\nfi\necho \"✓ 找到 $DELTA_COUNT 个规范差异文件\"\n\n# 6. 存在差异操作\nOPERATIONS=$(grep -h \"## ADDED\\|MODIFIED\\|REMOVED\" \"$BASE_PATH/specs\"/**/*.md 2>/dev/null | wc -l)\nif [ \"$OPERATIONS\" -eq 0 ]; then\n    echo \"✗ 未发现差异操作\"\n    exit 1\nfi\necho \"✓ 找到 $OPERATIONS 个差异操作\"\n\n# 7. 需求具备场景\nREQ_COUNT=$(grep -h \"### Requirement:\" \"$BASE_PATH/specs\"/**/*.md 2>/dev/null | wc -l)\nSCENARIO_COUNT=$(grep -h \"#### Scenario:\" \"$BASE_PATH/specs\"/**/*.md 2>/dev/null | wc -l)\n\nif [ \"$REQ_COUNT\" -eq 0 ]; then\n    echo \"✗ 未找到任何需求\"\n    exit 1\nfi\n\nif [ \"$SCENARIO_COUNT\" -lt \"$REQ_COUNT\" ]; then\n    echo \"⚠ 警告：场景数（$SCENARIO_COUNT）少于需求数（$REQ_COUNT）\"\n    echo \"  建议：每个需求至少包含 2 个场景\"\nelse\n    echo \"✓ 找到 $REQ_COUNT 个需求，包含 $SCENARIO_COUNT 个场景\"\nfi\n\necho \"================================\"\necho \"✓ 验证通过\"\n```\n\n**用法**：\n```bash\nbash validate-proposal.sh add-user-auth\n```\n\n## 常见问题与修复\n\n### 问题：缺少场景\n\n**检测**：\n```bash\n# 查找没有场景的需求\nawk '/### Requirement:/ {req=$0; getline; if ($0 !~ /#### Scenario:/) print req}' \\\n    spec/changes/{change-id}/specs/**/*.md\n```\n\n**修复**：为每个需求添加场景\n\n### 问题：场景标题层级错误\n\n**检测**：\n```bash\n# 查找场景标题井号数量错误（不完全等于 4）\ngrep -n \"^###\\? Scenario:\\|^#####+ Scenario:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**修复**：场景必须使用恰好 4 个井号：`#### Scenario:`\n\n### 问题：缺少差异操作\n\n**检测**：\n```bash\n# 检查文件存在需求但无差异操作头\nfor file in spec/changes/{change-id}/specs/**/*.md; do\n    if grep -q \"### Requirement:\" \"$file\" && \\\n       ! grep -q \"## ADDED\\|MODIFIED\\|REMOVED\" \"$file\"; then\n        echo \"缺少差异操作：$file\"\n    fi\ndone\n```\n\n**修复**：添加适当的差异操作标题（ADDED/MODIFIED/REMOVED）\n\n## 快速验证命令\n\n### 一行命令：完整结构检查\n\n```bash\n# 快速验证变更结构\nCHANGE_ID=\"add-user-auth\" && \\\ntest -f spec/changes/$CHANGE_ID/proposal.md && \\\ntest -f spec/changes/$CHANGE_ID/tasks.json && \\\ngrep -q \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/$CHANGE_ID/specs/**/*.md && \\\ngrep -q \"### Requirement:\" spec/changes/$CHANGE_ID/specs/**/*.md && \\\ngrep -q \"#### Scenario:\" spec/changes/$CHANGE_ID/specs/**/*.md && \\\necho \"✓ 所有验证通过\" || echo \"✗ 验证失败\"\n```\n\n### 显示提案摘要\n\n```bash\n# 展示提案概览\nCHANGE_ID=\"add-user-auth\"\necho \"提案：$CHANGE_ID\"\necho \"文件数：$(find spec/changes/$CHANGE_ID -type f | wc -l)\"\necho \"任务数：$(grep -c '\\\"task\\\":' spec/changes/$CHANGE_ID/tasks.json)\"\necho \"需求数：$(grep -h \\\"### Requirement:\\\" spec/changes/$CHANGE_ID/specs/**/*.md | wc -l)\"\necho \"场景数：$(grep -h \\\"#### Scenario:\\\" spec/changes/$CHANGE_ID/specs/**/*.md | wc -l)\"\n```\n\n## 验证清单\n\n在面向用户展示提案之前：\n\n```markdown\n手动检查：\n- [ ] 变更 ID 描述性且唯一\n- [ ] proposal.md 的 Why 部分解释问题\n- [ ] proposal.md 的 What 部分列出具体变更\n- [ ] proposal.md 的 Impact 部分标识受影响区域\n- [ ] tasks.json 含 5-15 个具体、可测试的任务\n- [ ] 任务按依赖顺序排列\n\n自动检查：\n- [ ] 目录结构存在\n- [ ] 必需文件存在（proposal.md、tasks.json、spec-delta.md）\n- [ ] 差异操作存在（ADDED/MODIFIED/REMOVED）\n- [ ] 需求遵循格式：`### Requirement: 名称`\n- [ ] 场景遵循格式：`#### Scenario: 名称`\n- [ ] 每个需求至少包含 2 个场景\n- [ ] 需求使用 SHALL 关键字\n```\n\n运行所有自动检查：\n```bash\n# 执行验证脚本\nbash validate-proposal.sh {change-id}\n```\n",
        "skills/openspec-proposal-creation-cn/templates/proposal.md": "# 提案：{变更标题}\n\n## Why\n\n[描述问题或机会]\n\n**背景**：\n- [背景点 1]\n- [背景点 2]\n\n**当前状态**：[当前如何工作]\n\n**期望状态**：[应该如何工作]\n\n## What Changes\n\n- [变更 1]\n- [变更 2]\n- [变更 3]\n\n## Impact\n\n### 受影响的规范\n- `spec/specs/{capability}/spec.md` - [发生哪些变更]\n\n### 受影响的代码\n- `src/{module}` - [需要实现的内容]\n\n### 用户影响\n- [如适用，说明对用户的影响]\n\n### API 变更\n- [是否存在破坏性变更]\n- [是否新增端点]\n\n### 需要迁移\n- [ ] 数据库迁移\n- [ ] API 版本提升\n- [ ] 用户沟通\n- [ ] 文档更新\n\n## 时间线评估\n\n[粗略估计：小/中/大，或具体天数]\n\n## 风险\n\n- [风险 1 与缓解方案]\n- [风险 2 与缓解方案]",
        "skills/openspec-proposal-creation-cn/templates/spec-delta.md": "# 规范差异：{能力名称}\n\n本文件包含对 `spec/specs/{capability}/spec.md` 的规范变更。\n\n## ADDED 需求\n\n### Requirement: {需求名称}\n{WHEN/IF 子句描述触发条件}\n系统 SHALL {动作与结果}。\n\n#### Scenario: {正向场景名称}\nGIVEN {前置条件}\nWHEN {动作}\nTHEN {期望结果}\nAND {附加结果}\n\n#### Scenario: {错误场景名称}\nGIVEN {错误前置条件}\nWHEN {动作}\nTHEN {期望的错误处理}\n\n---\n\n## MODIFIED 需求\n\n### Requirement: {现有需求名称}\n**Previous**：{旧行为的简要说明}\n\n{采用 EARS 格式的完整更新需求文本}\nWHEN {触发条件},\n系统 SHALL {新的动作与结果}。\n\n#### Scenario: {更新后的场景名称}\nGIVEN {新的前置条件}\nWHEN {动作}\nTHEN {新的期望结果}\n\n---\n\n## REMOVED 需求\n\n### Requirement: {弃用的需求名称}\n**移除原因**：{弃用原因}\n\n**迁移路径**：{用户应如何适配}\n\n---\n\n## 备注\n\n- 对全新能力使用 ADDED\n- 修改既有行为时使用 MODIFIED（包含完整更新文本）\n- 对弃用功能使用 REMOVED\n- 每条需求都应包含场景\n- 同时考虑正向与错误场景",
        "skills/openspec-proposal-creation/SKILL.md": "---\nname: openspec-proposal-creation\ndescription: Creates structured change proposals with specification deltas for new features, breaking changes, or architecture updates. Use when planning features, creating proposals, speccing changes, introducing new capabilities, or starting development workflows. Triggers include \"openspec proposal\", \"create proposal\", \"plan change\", \"spec feature\", \"new capability\", \"add feature planning\", \"design spec\".\n---\n\n# Specification Proposal Creation\n\nCreates comprehensive change proposals following spec-driven development methodology.\n\n## Quick Start\n\nCreating a spec proposal involves three main outputs:\n1. **proposal.md** - Why, what, and impact summary\n2. **tasks.md** - Numbered implementation checklist\n3. **spec-delta.md** - Formal requirement changes (ADDED/MODIFIED/REMOVED)\n\n**Basic workflow**: Generate change ID → scaffold directories → draft proposal → create spec deltas → validate structure\n\n## Workflow\n\nCopy this checklist and track progress:\n\n```\nProposal Progress:\n- [ ] Step 1: Review existing specifications\n- [ ] Step 2: Generate unique change ID\n- [ ] Step 3: Scaffold directory structure\n- [ ] Step 4: Draft proposal.md (Why/What/Impact)\n- [ ] Step 5: Create tasks.md implementation checklist\n- [ ] Step 6: Write spec deltas with EARS format\n- [ ] Step 7: Validate proposal structure\n- [ ] Step 8: Present for user approval\n```\n\n### Step 1: Review existing specifications\n\nBefore creating a proposal, understand the current state:\n\n```bash\n# List all existing specs\nfind spec/specs -name \"spec.md\" -type f\n\n# List active changes to avoid conflicts\nfind spec/changes -maxdepth 1 -type d -not -path \"*/archive\"\n\n# Search for related requirements\ngrep -r \"### Requirement:\" spec/specs/\n```\n\n### Step 2: Generate unique change ID\n\nChoose a descriptive, URL-safe identifier:\n\n**Format**: `add-<feature>`, `fix-<issue>`, `update-<component>`, `remove-<feature>`\n\n**Examples**:\n- `add-user-authentication`\n- `fix-payment-validation`\n- `update-api-rate-limits`\n- `remove-legacy-endpoints`\n\n**Validation**: Check for conflicts:\n```bash\nls spec/changes/ | grep -i \"<proposed-id>\"\n```\n\n### Step 3: Scaffold directory structure\n\nCreate the change folder with standard structure:\n\n```bash\n# Replace {change-id} with actual ID\nmkdir -p spec/changes/{change-id}/specs/{capability-name}\n```\n\n**Example**:\n```bash\nmkdir -p spec/changes/add-user-auth/specs/authentication\n```\n\n### Step 4: Draft proposal.md\n\nUse the template at [templates/proposal.md](templates/proposal.md) as starting point.\n\n**Required sections**:\n- **Why**: Problem or opportunity driving this change\n- **What Changes**: Bullet list of modifications\n- **Impact**: Affected specs, code, APIs, users\n\n**Tone**: Clear, concise, decision-focused. Avoid unnecessary background.\n\n### Step 5: Create tasks.md implementation checklist\n\nBreak implementation into concrete, testable tasks. Use the template at [templates/tasks.md](templates/tasks.md).\n\n**Format**:\n```markdown\n# Implementation Tasks\n\n1. [First concrete task]\n2. [Second concrete task]\n3. [Test task]\n4. [Documentation task]\n```\n\n**Best practices**:\n- Each task is independently completable\n- Include testing and validation tasks\n- Order by dependencies (database before API, etc.)\n- 5-15 tasks is typical; split if more needed\n\n### Step 6: Write spec deltas with EARS format\n\nThis is the most critical step. Spec deltas use **EARS format** (Easy Approach to Requirements Syntax).\n\n**For complete EARS guidelines**, see [reference/EARS_FORMAT.md](reference/EARS_FORMAT.md)\n\n**Delta operations**:\n- `## ADDED Requirements` - New capabilities\n- `## MODIFIED Requirements` - Changed behavior (include full updated text)\n- `## REMOVED Requirements` - Deprecated features\n\n**Basic requirement structure**:\n```markdown\n## ADDED Requirements\n\n### Requirement: User Login\nWHEN a user submits valid credentials,\nthe system SHALL authenticate the user and create a session.\n\n#### Scenario: Successful Login\nGIVEN a user with email \"user@example.com\" and password \"correct123\"\nWHEN the user submits the login form\nTHEN the system creates an authenticated session\nAND redirects to the dashboard\n```\n\n**For validation patterns**, see [reference/VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md)\n\n### Step 7: Validate proposal structure\n\nRun these checks before presenting to user:\n\n```markdown\nStructure Checklist:\n- [ ] Directory exists: `spec/changes/{change-id}/`\n- [ ] proposal.md has Why/What/Impact sections\n- [ ] tasks.md has numbered task list (5-15 items)\n- [ ] Spec deltas have operation headers (ADDED/MODIFIED/REMOVED)\n- [ ] Requirements follow `### Requirement: <name>` format\n- [ ] Scenarios use `#### Scenario:` format (4 hashtags)\n```\n\n**Automated checks**:\n```bash\n# Count delta operations (should be > 0)\ngrep -c \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/{change-id}/specs/**/*.md\n\n# Verify scenario format (should show line numbers)\ngrep -n \"#### Scenario:\" spec/changes/{change-id}/specs/**/*.md\n\n# Check requirement headers\ngrep -n \"### Requirement:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n### Step 8: Present for user approval\n\nSummarize the proposal clearly:\n\n```markdown\n## Proposal Summary\n\n**Change ID**: {change-id}\n**Scope**: {brief description}\n\n**Files created**:\n- spec/changes/{change-id}/proposal.md\n- spec/changes/{change-id}/tasks.md\n- spec/changes/{change-id}/specs/{capability}/spec-delta.md\n\n**Next steps**:\nReview the proposal. If approved, say \"openspec implement\" or \"apply the change\" to begin implementation.\n```\n\n## Advanced Topics\n\n**EARS format details**: See [reference/EARS_FORMAT.md](reference/EARS_FORMAT.md)\n**Validation patterns**: See [reference/VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md)\n**Complete examples**: See [reference/EXAMPLES.md](reference/EXAMPLES.md)\n\n## Common Patterns\n\n### Pattern 1: New feature proposal\n\nWhen adding net-new capability:\n- Use `ADDED Requirements` delta\n- Include positive scenarios AND error handling\n- Consider edge cases in scenarios\n\n### Pattern 2: Breaking change proposal\n\nWhen changing existing behavior:\n- Use `MODIFIED Requirements` delta\n- Include complete updated requirement text\n- Document what changes and why in proposal.md\n- Consider migration tasks in tasks.md\n\n### Pattern 3: Deprecation proposal\n\nWhen removing features:\n- Use `REMOVED Requirements` delta\n- Document removal rationale in proposal.md\n- Include cleanup tasks in tasks.md\n- Consider user migration in impact section\n\n## Anti-Patterns to Avoid\n\n**Don't**:\n- Skip validation checks (always run grep patterns)\n- Create proposals without reviewing existing specs first\n- Use vague task descriptions (\"Fix the thing\")\n- Write requirements without scenarios\n- Forget error handling scenarios\n- Mix multiple unrelated changes in one proposal\n\n**Do**:\n- Check for conflicts before creating change ID\n- Write concrete, testable tasks\n- Include positive AND negative scenarios\n- Keep one concern per proposal\n- Validate structure before presenting\n\n## File Templates\n\nAll templates are in the `templates/` directory:\n- [proposal.md](templates/proposal.md) - Proposal structure\n- [tasks.md](templates/tasks.md) - Task checklist format\n- [spec-delta.md](templates/spec-delta.md) - Spec delta template\n\n## Reference Materials\n\n- [EARS_FORMAT.md](reference/EARS_FORMAT.md) - Complete EARS syntax guide\n- [VALIDATION_PATTERNS.md](reference/VALIDATION_PATTERNS.md) - Grep/bash validation\n- [EXAMPLES.md](reference/EXAMPLES.md) - Real-world proposal examples\n\n---\n\n**Token budget**: This SKILL.md is approximately 450 lines, under the 500-line recommended limit. Reference files load only when needed for progressive disclosure.\n",
        "skills/openspec-proposal-creation/reference/EARS_FORMAT.md": "# EARS Format Guide\n\nEARS (Easy Approach to Requirements Syntax) provides a structured format for writing clear, testable requirements.\n\n## Contents\n- Requirement structure and keywords\n- Scenario format (Given/When/Then)\n- Requirement types and patterns\n- Examples and anti-patterns\n\n## Requirement Structure\n\n### Basic Format\n\n```markdown\n### Requirement: {Descriptive Name}\n{TRIGGER clause},\nthe system SHALL {action and outcome}.\n```\n\n### Trigger Types\n\n**WHEN** (Event-driven):\n```markdown\n### Requirement: Save User Profile\nWHEN a user clicks the \"Save\" button,\nthe system SHALL persist profile changes to the database.\n```\n\n**IF** (State-driven):\n```markdown\n### Requirement: Free Shipping\nIF the cart total exceeds $50,\nthe system SHALL waive shipping fees.\n```\n\n**WHERE** (Feature-specific):\n```markdown\n### Requirement: Admin Access\nWHERE the user has admin privileges,\nthe system SHALL display the administration panel.\n```\n\n**WHILE** (Continuous):\n```markdown\n### Requirement: Real-time Sync\nWHILE a document is open,\nthe system SHALL synchronize changes every 5 seconds.\n```\n\n## SHALL vs SHOULD vs MAY\n\n- **SHALL**: Binding requirement (must be implemented)\n- **SHOULD**: Recommended but not mandatory\n- **MAY**: Optional capability\n\n**Prefer SHALL** for all production requirements. Use SHOULD/MAY sparingly.\n\n## Scenario Format\n\nEvery requirement MUST have scenarios showing expected behavior.\n\n### Structure\n\n```markdown\n#### Scenario: {Descriptive Name}\nGIVEN {preconditions}\nAND {additional preconditions}\nWHEN {action or trigger}\nTHEN {expected outcome}\nAND {additional outcome}\n```\n\n### Example: Complete Requirement with Scenarios\n\n```markdown\n### Requirement: User Login\nWHEN a user submits valid credentials,\nthe system SHALL authenticate the user and create a session.\n\n#### Scenario: Successful Login\nGIVEN a registered user with email \"user@example.com\"\nAND the user has correct password \"SecurePass123\"\nWHEN the user submits the login form\nTHEN the system creates an authenticated session\nAND redirects the user to the dashboard\nAND sets a session cookie expiring in 24 hours\n\n#### Scenario: Invalid Password\nGIVEN a registered user with email \"user@example.com\"\nAND the user provides incorrect password \"WrongPass\"\nWHEN the user submits the login form\nTHEN the system rejects the login attempt\nAND displays error message \"Invalid email or password\"\nAND does not create a session\n\n#### Scenario: Account Locked\nGIVEN a user account that is locked due to failed attempts\nWHEN the user submits any credentials\nTHEN the system rejects the login attempt\nAND displays error message \"Account locked. Contact support.\"\n```\n\n## Requirement Patterns\n\n### Pattern 1: Data Validation\n\n```markdown\n### Requirement: Email Validation\nWHEN a user enters an email address,\nthe system SHALL validate the format matches RFC 5322 standard.\n\n#### Scenario: Valid Email\nGIVEN a user entering email \"test@example.com\"\nWHEN the form is submitted\nTHEN the system accepts the email\n\n#### Scenario: Invalid Format\nGIVEN a user entering email \"not-an-email\"\nWHEN the form is submitted\nTHEN the system displays error \"Invalid email format\"\n```\n\n### Pattern 2: Authorization\n\n```markdown\n### Requirement: Delete Permission\nWHERE a user attempts to delete a resource,\nthe system SHALL verify the user owns the resource OR has admin privileges.\n\n#### Scenario: Owner Deletes\nGIVEN a user owns document ID 123\nWHEN the user requests deletion of document 123\nTHEN the system deletes the document\n\n#### Scenario: Non-owner Blocked\nGIVEN a user does not own document ID 456\nAND the user lacks admin privileges\nWHEN the user requests deletion of document 456\nTHEN the system returns HTTP 403 Forbidden\n```\n\n### Pattern 3: State Transitions\n\n```markdown\n### Requirement: Order Processing\nWHEN an order is placed,\nthe system SHALL transition through states: pending → processing → shipped → delivered.\n\n#### Scenario: Standard Flow\nGIVEN a new order in \"pending\" state\nWHEN payment is confirmed\nTHEN the system transitions to \"processing\"\nWHEN items are shipped\nTHEN the system transitions to \"shipped\"\nWHEN delivery is confirmed\nTHEN the system transitions to \"delivered\"\n```\n\n## Anti-Patterns to Avoid\n\n### ❌ Vague Requirements\n\n**Bad**:\n```markdown\n### Requirement: Fast Performance\nThe system should be fast.\n```\n\n**Good**:\n```markdown\n### Requirement: API Response Time\nWHEN an API request is made,\nthe system SHALL respond within 200 milliseconds for 95% of requests.\n\n#### Scenario: Normal Load\nGIVEN the system is under normal load (< 100 requests/second)\nWHEN an API request is made\nTHEN the response time is less than 200ms\n```\n\n### ❌ Missing Scenarios\n\n**Bad**:\n```markdown\n### Requirement: File Upload\nWHEN a user uploads a file,\nthe system SHALL store it.\n```\n\n**Good**:\n```markdown\n### Requirement: File Upload\nWHEN a user uploads a file under 10MB,\nthe system SHALL store it in S3 and return a URL.\n\n#### Scenario: Successful Upload\nGIVEN a user selects a 5MB PDF file\nWHEN the upload completes\nTHEN the system stores the file in S3\nAND returns a signed URL valid for 1 hour\n\n#### Scenario: File Too Large\nGIVEN a user selects a 15MB video file\nWHEN the upload is attempted\nTHEN the system rejects the file\nAND displays error \"File size exceeds 10MB limit\"\n```\n\n### ❌ Implementation Details in Requirements\n\n**Bad**:\n```markdown\n### Requirement: Password Storage\nThe system SHALL use bcrypt with work factor 12 and store hashes in the users table.\n```\n\n**Good**:\n```markdown\n### Requirement: Secure Password Storage\nWHEN a user sets a password,\nthe system SHALL hash the password using industry-standard one-way hashing before storage.\n\n#### Scenario: Password Creation\nGIVEN a user sets password \"SecurePass123\"\nWHEN the system processes the password\nTHEN the system stores only a cryptographic hash\nAND discards the plaintext password\nAND uses a unique salt per user\n```\n\n(Implementation choice of bcrypt/work factor goes in design docs, not requirements)\n\n## Complete Example: User Registration\n\n```markdown\n## ADDED Requirements\n\n### Requirement: Account Creation\nWHEN a user submits a registration form with valid data,\nthe system SHALL create a new account and send a verification email.\n\n#### Scenario: Successful Registration\nGIVEN a user provides email \"new@example.com\"\nAND provides password \"SecurePass123\"\nAND provides name \"John Doe\"\nAND the email is not already registered\nWHEN the user submits the registration form\nTHEN the system creates a new user account\nAND sends a verification email to \"new@example.com\"\nAND displays message \"Check your email to verify your account\"\nAND redirects to the login page\n\n#### Scenario: Duplicate Email\nGIVEN a user provides email \"existing@example.com\"\nAND that email is already registered\nWHEN the user submits the registration form\nTHEN the system rejects the registration\nAND displays error \"This email is already registered\"\nAND does not send an email\n\n#### Scenario: Weak Password\nGIVEN a user provides password \"123\"\nWHEN the user submits the registration form\nTHEN the system rejects the registration\nAND displays error \"Password must be at least 8 characters\"\n\n### Requirement: Email Verification\nWHEN a user clicks a verification link,\nthe system SHALL activate the account if the token is valid and not expired.\n\n#### Scenario: Valid Token\nGIVEN a user received a verification email\nAND the verification token is less than 24 hours old\nWHEN the user clicks the verification link\nTHEN the system activates the account\nAND displays message \"Account verified successfully\"\nAND redirects to the login page\n\n#### Scenario: Expired Token\nGIVEN a verification token is more than 24 hours old\nWHEN the user clicks the verification link\nTHEN the system rejects the verification\nAND displays message \"Verification link expired. Request a new one.\"\n```\n\n## Summary Checklist\n\nWhen writing requirements:\n- [ ] Use SHALL for binding requirements\n- [ ] Include trigger clause (WHEN/IF/WHERE/WHILE)\n- [ ] Write clear action and outcome\n- [ ] Include at least one positive scenario\n- [ ] Include error/edge case scenarios\n- [ ] Use Given/When/Then format for scenarios\n- [ ] Avoid implementation details\n- [ ] Make requirements testable\n",
        "skills/openspec-proposal-creation/reference/VALIDATION_PATTERNS.md": "# Validation Patterns\n\nGrep and bash patterns to validate proposal structure without external CLI tools.\n\n## Contents\n- Directory structure validation\n- Proposal file validation\n- Spec delta validation\n- Requirement format validation\n- Common validation workflows\n\n## Directory Structure Validation\n\n### Check Change Directory Exists\n\n```bash\n# Verify change directory was created\ntest -d spec/changes/{change-id} && echo \"✓ Directory exists\" || echo \"✗ Directory missing\"\n```\n\n### List All Changes\n\n```bash\n# Show all active changes\nls -1 spec/changes/ | grep -v \"archive\"\n```\n\n### Check for Conflicts\n\n```bash\n# Search for similar change IDs\nls spec/changes/ | grep -i \"{search-term}\"\n```\n\n## Proposal File Validation\n\n### Check Required Sections\n\n```bash\n# Verify proposal.md has required sections\ngrep -c \"## Why\" spec/changes/{change-id}/proposal.md\ngrep -c \"## What Changes\" spec/changes/{change-id}/proposal.md\ngrep -c \"## Impact\" spec/changes/{change-id}/proposal.md\n```\n\n**Expected**: Each grep returns 1 (or more if subsections exist)\n\n### Validate Tasks File\n\n```bash\n# Count numbered tasks\ngrep -c \"^[0-9]\\+\\.\" spec/changes/{change-id}/tasks.md\n\n# Show task list\ngrep \"^[0-9]\\+\\.\" spec/changes/{change-id}/tasks.md\n```\n\n**Expected**: 5-15 tasks typically\n\n## Spec Delta Validation\n\n### Check Delta Operations Exist\n\n```bash\n# Count delta operation headers\ngrep -c \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**Expected**: At least 1 match\n\n### List Delta Operations\n\n```bash\n# Show all delta operations with line numbers\ngrep -n \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**Example output**:\n```\nspec/changes/add-auth/specs/authentication/spec-delta.md:3:## ADDED Requirements\nspec/changes/add-auth/specs/authentication/spec-delta.md:45:## MODIFIED Requirements\n```\n\n### Verify Each Section Has Content\n\n```bash\n# Check if ADDED section has requirements\nawk '/## ADDED/,/^## [A-Z]/ {if (/### Requirement:/) count++} END {print count}' \\\n    spec/changes/{change-id}/specs/**/*.md\n```\n\n## Requirement Format Validation\n\n### Check Requirement Headers\n\n```bash\n# List all requirement headers\ngrep -n \"### Requirement:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**Expected format**: `### Requirement: Descriptive Name`\n\n### Validate Scenario Format\n\n```bash\n# Check for scenarios (must be 4 hashtags)\ngrep -n \"#### Scenario:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**Expected format**: `#### Scenario: Descriptive Name`\n\n### Count Requirements vs Scenarios\n\n```bash\n# Count requirements\nREQS=$(grep -c \"### Requirement:\" spec/changes/{change-id}/specs/**/*.md)\n\n# Count scenarios\nSCENARIOS=$(grep -c \"#### Scenario:\" spec/changes/{change-id}/specs/**/*.md)\n\necho \"Requirements: $REQS\"\necho \"Scenarios: $SCENARIOS\"\necho \"Ratio: $(echo \"scale=1; $SCENARIOS/$REQS\" | bc)\"\n```\n\n**Expected**: Ratio >= 2.0 (at least 2 scenarios per requirement)\n\n### Check for SHALL Keyword\n\n```bash\n# Verify requirements use SHALL (binding requirement indicator)\ngrep -c \"SHALL\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**Expected**: At least as many SHALL as requirements\n\n## Complete Validation Workflow\n\n### Pre-Submit Validation Script\n\n```bash\n#!/bin/bash\n# Validate change proposal structure\n\nCHANGE_ID=\"$1\"\nBASE_PATH=\"spec/changes/$CHANGE_ID\"\n\necho \"Validating proposal: $CHANGE_ID\"\necho \"================================\"\n\n# 1. Directory exists\nif [ ! -d \"$BASE_PATH\" ]; then\n    echo \"✗ Change directory not found\"\n    exit 1\nfi\necho \"✓ Change directory exists\"\n\n# 2. Required files exist\nfor file in proposal.md tasks.md; do\n    if [ ! -f \"$BASE_PATH/$file\" ]; then\n        echo \"✗ Missing $file\"\n        exit 1\n    fi\n    echo \"✓ Found $file\"\ndone\n\n# 3. Proposal has required sections\nfor section in \"## Why\" \"## What Changes\" \"## Impact\"; do\n    if ! grep -q \"$section\" \"$BASE_PATH/proposal.md\"; then\n        echo \"✗ proposal.md missing section: $section\"\n        exit 1\n    fi\ndone\necho \"✓ Proposal has required sections\"\n\n# 4. Tasks file has numbered tasks\nTASK_COUNT=$(grep -c \"^[0-9]\\+\\.\" \"$BASE_PATH/tasks.md\" || echo \"0\")\nif [ \"$TASK_COUNT\" -lt 3 ]; then\n    echo \"✗ tasks.md has insufficient tasks ($TASK_COUNT)\"\n    exit 1\nfi\necho \"✓ Found $TASK_COUNT tasks\"\n\n# 5. Spec deltas exist\nDELTA_COUNT=$(find \"$BASE_PATH/specs\" -name \"*.md\" 2>/dev/null | wc -l)\nif [ \"$DELTA_COUNT\" -eq 0 ]; then\n    echo \"✗ No spec delta files found\"\n    exit 1\nfi\necho \"✓ Found $DELTA_COUNT spec delta file(s)\"\n\n# 6. Delta operations exist\nOPERATIONS=$(grep -h \"## ADDED\\|MODIFIED\\|REMOVED\" \"$BASE_PATH/specs\"/**/*.md 2>/dev/null | wc -l)\nif [ \"$OPERATIONS\" -eq 0 ]; then\n    echo \"✗ No delta operations found\"\n    exit 1\nfi\necho \"✓ Found $OPERATIONS delta operation(s)\"\n\n# 7. Requirements have scenarios\nREQ_COUNT=$(grep -h \"### Requirement:\" \"$BASE_PATH/specs\"/**/*.md 2>/dev/null | wc -l)\nSCENARIO_COUNT=$(grep -h \"#### Scenario:\" \"$BASE_PATH/specs\"/**/*.md 2>/dev/null | wc -l)\n\nif [ \"$REQ_COUNT\" -eq 0 ]; then\n    echo \"✗ No requirements found\"\n    exit 1\nfi\n\nif [ \"$SCENARIO_COUNT\" -lt \"$REQ_COUNT\" ]; then\n    echo \"⚠ Warning: Fewer scenarios ($SCENARIO_COUNT) than requirements ($REQ_COUNT)\"\n    echo \"  Recommendation: At least 2 scenarios per requirement\"\nelse\n    echo \"✓ Found $REQ_COUNT requirement(s) with $SCENARIO_COUNT scenario(s)\"\nfi\n\necho \"================================\"\necho \"✓ Validation passed\"\n```\n\n**Usage**:\n```bash\nbash validate-proposal.sh add-user-auth\n```\n\n## Common Issues and Fixes\n\n### Issue: Missing Scenarios\n\n**Detection**:\n```bash\n# Find requirements without scenarios\nawk '/### Requirement:/ {req=$0; getline; if ($0 !~ /#### Scenario:/) print req}' \\\n    spec/changes/{change-id}/specs/**/*.md\n```\n\n**Fix**: Add scenarios for each requirement\n\n### Issue: Wrong Scenario Level\n\n**Detection**:\n```bash\n# Find scenarios with wrong hashtag count (not exactly 4)\ngrep -n \"^###\\? Scenario:\\|^#####+ Scenario:\" spec/changes/{change-id}/specs/**/*.md\n```\n\n**Fix**: Scenarios must use exactly 4 hashtags: `#### Scenario:`\n\n### Issue: Missing Delta Operations\n\n**Detection**:\n```bash\n# Check if file has requirements but no delta header\nfor file in spec/changes/{change-id}/specs/**/*.md; do\n    if grep -q \"### Requirement:\" \"$file\" && \\\n       ! grep -q \"## ADDED\\|MODIFIED\\|REMOVED\" \"$file\"; then\n        echo \"Missing delta operation in: $file\"\n    fi\ndone\n```\n\n**Fix**: Add appropriate delta operation header (ADDED/MODIFIED/REMOVED)\n\n## Quick Validation Commands\n\n### One-Liner: Full Structure Check\n\n```bash\n# Quick validation of change structure\nCHANGE_ID=\"add-user-auth\" && \\\ntest -f spec/changes/$CHANGE_ID/proposal.md && \\\ntest -f spec/changes/$CHANGE_ID/tasks.md && \\\ngrep -q \"## ADDED\\|MODIFIED\\|REMOVED\" spec/changes/$CHANGE_ID/specs/**/*.md && \\\ngrep -q \"### Requirement:\" spec/changes/$CHANGE_ID/specs/**/*.md && \\\ngrep -q \"#### Scenario:\" spec/changes/$CHANGE_ID/specs/**/*.md && \\\necho \"✓ All validations passed\" || echo \"✗ Validation failed\"\n```\n\n### Show Proposal Summary\n\n```bash\n# Display proposal overview\nCHANGE_ID=\"add-user-auth\"\necho \"Proposal: $CHANGE_ID\"\necho \"Files: $(find spec/changes/$CHANGE_ID -type f | wc -l)\"\necho \"Tasks: $(grep -c \"^[0-9]\\+\\.\" spec/changes/$CHANGE_ID/tasks.md)\"\necho \"Requirements: $(grep -h \"### Requirement:\" spec/changes/$CHANGE_ID/specs/**/*.md | wc -l)\"\necho \"Scenarios: $(grep -h \"#### Scenario:\" spec/changes/$CHANGE_ID/specs/**/*.md | wc -l)\"\n```\n\n## Validation Checklist\n\nBefore presenting proposal to user:\n\n```markdown\nManual Checks:\n- [ ] Change ID is descriptive and unique\n- [ ] proposal.md Why section explains the problem\n- [ ] proposal.md What section lists concrete changes\n- [ ] proposal.md Impact section identifies affected areas\n- [ ] tasks.md has 5-15 concrete, testable tasks\n- [ ] Tasks are ordered by dependencies\n\nAutomated Checks:\n- [ ] Directory structure exists\n- [ ] Required files present (proposal.md, tasks.md, spec-delta.md)\n- [ ] Delta operations present (ADDED/MODIFIED/REMOVED)\n- [ ] Requirements follow format: `### Requirement: Name`\n- [ ] Scenarios follow format: `#### Scenario: Name`\n- [ ] At least 2 scenarios per requirement\n- [ ] Requirements use SHALL keyword\n```\n\nRun all automated checks:\n```bash\n# Execute validation script\nbash validate-proposal.sh {change-id}\n```\n",
        "skills/openspec-proposal-creation/templates/proposal.md": "# Proposal: {Change Title}\n\n## Why\n\n[Describe the problem or opportunity]\n\n**Context**:\n- [Background point 1]\n- [Background point 2]\n\n**Current state**: [How things work now]\n\n**Desired state**: [How things should work]\n\n## What Changes\n\n- [Change 1]\n- [Change 2]\n- [Change 3]\n\n## Impact\n\n### Affected Specifications\n- `spec/specs/{capability}/spec.md` - [What changes]\n\n### Affected Code\n- `src/{module}` - [What needs implementation]\n\n### User Impact\n- [How this affects users, if applicable]\n\n### API Changes\n- [Breaking changes, if any]\n- [New endpoints, if any]\n\n### Migration Required\n- [ ] Database migration\n- [ ] API version bump\n- [ ] User communication needed\n- [ ] Documentation updates\n\n## Timeline Estimate\n\n[Rough estimate: small/medium/large, or number of days]\n\n## Risks\n\n- [Risk 1 and mitigation]\n- [Risk 2 and mitigation]\n",
        "skills/openspec-proposal-creation/templates/spec-delta.md": "# Spec Delta: {Capability Name}\n\nThis file contains specification changes for `spec/specs/{capability}/spec.md`.\n\n## ADDED Requirements\n\n### Requirement: {Requirement Name}\n{WHEN/IF clause describing trigger}\nthe system SHALL {action and outcome}.\n\n#### Scenario: {Positive Scenario Name}\nGIVEN {preconditions}\nWHEN {action}\nTHEN {expected outcome}\nAND {additional outcome}\n\n#### Scenario: {Error Scenario Name}\nGIVEN {error preconditions}\nWHEN {action}\nTHEN {expected error handling}\n\n---\n\n## MODIFIED Requirements\n\n### Requirement: {Existing Requirement Name}\n**Previous**: {Brief summary of old behavior}\n\n{Complete updated requirement text in EARS format}\nWHEN {trigger},\nthe system SHALL {new action and outcome}.\n\n#### Scenario: {Updated Scenario Name}\nGIVEN {new preconditions}\nWHEN {action}\nTHEN {new expected outcome}\n\n---\n\n## REMOVED Requirements\n\n### Requirement: {Deprecated Requirement Name}\n**Reason for removal**: {Why this is being deprecated}\n\n**Migration path**: {How users should adapt}\n\n---\n\n## Notes\n\n- Use ADDED for completely new capabilities\n- Use MODIFIED when changing existing behavior (include full updated text)\n- Use REMOVED for deprecated features\n- Always include scenarios for each requirement\n- Consider both positive and error cases\n",
        "skills/openspec-proposal-creation/templates/tasks.md": "# Implementation Tasks\n\n## Phase 1: Foundation\n\n1. [Setup task - database schema, dependencies, etc.]\n2. [Core infrastructure task]\n\n## Phase 2: Core Implementation\n\n3. [Main feature task 1]\n4. [Main feature task 2]\n5. [Main feature task 3]\n\n## Phase 3: Integration\n\n6. [API integration task]\n7. [UI integration task]\n\n## Phase 4: Quality & Documentation\n\n8. [Unit tests for X]\n9. [Integration tests for Y]\n10. [Update API documentation]\n11. [Update user documentation]\n\n## Phase 5: Deployment\n\n12. [Database migration]\n13. [Deploy to staging]\n14. [Validation testing]\n15. [Deploy to production]\n\n---\n\n**Notes**:\n- Each task should be independently completable\n- Include test tasks for each major component\n- Order tasks by dependencies\n- Keep tasks concrete and verifiable\n",
        "skills/speckit-analyze-zh/SKILL.md": "---\nname: speckit-analyze-zh\ndescription: 对spec.md、plan.md和tasks.md三个核心文档进行非破坏性跨工件一致性和质量分析。在任务生成后识别不一致、重复、模糊和规范不足的项目。触发词包括：\"speckit-analyze\"、\"speckit分析\"、\"文档一致性分析\"、\"规范分析\"、\"质量检查\"、\"工件分析\"、\"spec分析\"、\"plan分析\"、\"task分析\"。\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 目标\n\n在实现之前，识别三个核心工件（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、歧义和未充分说明的项目。此命令必须仅在 `speckit-tasks` 成功生成完整的 `tasks.md` 后运行。\n\n## 操作约束\n\n**严格只读**：**不要**修改任何文件。输出结构化分析报告。提供可选的补救计划（用户必须明确批准后才能手动调用任何后续编辑命令）。\n\n**宪章权威性**：项目宪章（`.specify/memory/constitution.md`）在此分析范围内是**不可协商的**。宪章冲突自动为关键级别，需要调整规格、计划或任务——而不是稀释、重新解释或默默忽略原则。如果原则本身需要更改，必须在 `speckit-analyze` 之外的单独、明确的宪章更新中进行。\n\n## 执行步骤\n\nscripts:\n  sh: .specify/scripts/bash/check-prerequisites.sh --json\n  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json\n\n### 1. 初始化分析上下文\n\n从仓库根目录运行一次 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。推导绝对路径：\n\n- SPEC = FEATURE_DIR/spec.md\n- PLAN = FEATURE_DIR/plan.md\n- TASKS = FEATURE_DIR/tasks.md\n\n如果缺少任何必需文件，则中止并显示错误消息（指示用户运行缺少的先决条件命令）。\n对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n### 2. 加载工件（渐进式披露）\n\n仅加载每个工件的最小必要上下文：\n\n**来自 spec.md：**\n\n- 概述/上下文\n- 功能要求\n- 非功能要求\n- 用户故事\n- 边缘情况（如果存在）\n\n**来自 plan.md：**\n\n- 架构/技术栈选择\n- 数据模型引用\n- 阶段\n- 技术约束\n\n**来自 tasks.md：**\n\n- 任务 ID\n- 描述\n- 阶段分组\n- 并行标记 [P]\n- 引用的文件路径\n\n**来自 constitution：**\n\n- 加载 `.specify/memory/constitution.md` 用于原则验证\n\n### 3. 构建语义模型\n\n创建内部表示（不要在输出中包含原始工件）：\n\n- **要求清单**：每个功能+非功能要求带有一个稳定键（根据祈使句派生 slug；例如，\"用户可以上传文件\" → `user-can-upload-file`）\n- **用户故事/动作清单**：具有验收标准的离散用户动作\n- **任务覆盖映射**：将每个任务映射到一个或多个要求或故事（通过关键词/显式引用模式如 ID 或关键词进行推断）\n- **宪章规则集**：提取原则名称和 MUST/SHOULD 规范性陈述\n\n### 4. 检测过程（高效令牌分析）\n\n专注于高信号发现。限制总数为 50 个发现；在溢出摘要中聚合其余发现。\n\n#### A. 重复检测\n\n- 识别近似重复的要求\n- 标记质量较低的措辞以进行合并\n\n#### B. 歧义检测\n\n- 标记缺乏可测量标准的模糊形容词（快速、可扩展、安全、直观、健壮）\n- 标记未解决的占位符（TODO、TKTK、???、`<placeholder>` 等）\n\n#### C. 未充分说明\n\n- 有动词但缺少对象或可测量结果的要求\n- 缺少验收标准对齐的用户故事\n- 引用在规格/计划中未定义的文件或组件的任务\n\n#### D. 宪章对齐\n\n- 任何与 MUST 原则冲突的要求或计划元素\n- 缺少宪章中规定的章节或质量门\n\n#### E. 覆盖差距\n\n- 没有关联任务的要求\n- 没有映射要求/故事的任务\n- 未在任务中体现的非功能要求（例如，性能、安全性）\n\n#### F. 不一致\n\n- 术语漂移（同一概念在不同文件中有不同名称）\n- 计划中引用但在规格中缺失的数据实体（反之亦然）\n- 任务排序矛盾（例如，集成任务在基础设置任务之前但没有依赖注释）\n- 冲突的要求（例如，一个要求 Next.js 而另一个指定 Vue）\n\n### 5. 严重性分配\n\n使用此启发式方法来优先处理发现：\n\n- **关键**：违反宪章 MUST、缺少核心规格工件，或阻塞基本功能的零覆盖要求\n- **高**：重复或冲突的要求、模糊的安全/性能属性、不可测试的验收标准\n- **中**：术语漂移、缺少非功能任务覆盖、未充分说明的边缘情况\n- **低**：样式/措辞改进、不影响执行顺序的次要冗余\n\n### 6. 生成紧凑分析报告\n\n输出一个 Markdown 报告（不写入文件）具有以下结构：\n\n## 规格分析报告\n\n| ID   | 类别 | 严重性 | 位置             | 摘要               | 建议                       |\n| ---- | ---- | ------ | ---------------- | ------------------ | -------------------------- |\n| A1   | 重复 | 高     | spec.md:L120-134 | 两个相似的要求 ... | 合并措辞；保留更清晰的版本 |\n\n（每项发现添加一行；生成以类别首字母为前缀的稳定 ID。）\n\n**覆盖摘要表：**\n\n| 要求键 | 有任务？ | 任务 ID | 备注 |\n| ------ | -------- | ------- | ---- |\n\n**宪章对齐问题：**（如果有）\n\n**未映射的任务：**（如果有）\n\n**指标：**\n\n- 总要求\n- 总任务\n- 覆盖率%（有>=1个任务的要求）\n- 歧义计数\n- 重复计数\n- 关键问题计数\n\n### 7. 提供下一步行动\n\n在报告末尾，输出一个简洁的下一步行动块：\n\n- 如果存在关键问题：建议在 `speckit-implement` 之前解决\n- 如果只有低/中等：用户可以继续，但提供改进建议\n- 提供明确的命令建议：例如，\"使用改进运行 `speckit-specify`\"，\"运行 `speckit-plan` 调整架构\"，\"手动编辑 tasks.md 添加 'performance-metrics' 的覆盖\"\n\n### 8. 提供补救措施\n\n询问用户：\"您希望我为前 N 个问题建议具体的补救编辑吗？\"（不要自动应用它们。）\n\n## 操作原则\n\n### 上下文效率\n\n- **最小高信号令牌**：专注于可操作的发现，而不是详尽的文档\n- **渐进式披露**：增量加载工件；不要将所有内容倒入分析\n- **高效令牌输出**：限制发现表为 50 行；总结溢出\n- **确定性结果**：在没有更改的情况下重新运行应产生一致的 ID 和计数\n\n### 分析指南\n\n- **永不修改文件**（这是只读分析）\n- **永不虚构缺失部分**（如果缺失，准确报告）\n- **优先处理宪章违规**（这些总是关键的）\n- **使用示例而非详尽规则**（引用具体实例，而非通用模式）\n- **优雅报告零问题**（发出带有覆盖统计的成功报告）\n\n## 上下文\n\n{ARGS}\n\n",
        "skills/speckit-analyze-zh/references/analysis-patterns.md": "# 分析模式参考\n\n## 检测模式详解\n\n### 1. 重复检测模式\n\n**识别模式:**\n- 相似的动词结构\n- 同一概念的不同表述\n- 功能重叠的描述\n\n**处理策略:**\n- 保留更清晰的版本\n- 合并相似的描述\n- 统一术语表达\n\n### 2. 模糊性检测模式\n\n**常见模糊词汇:**\n- 性能相关: \"快速\"、\"高性能\"、\"优化\"\n- 安全相关: \"安全\"、\"可靠\"、\"保护\"\n- 用户体验: \"直观\"、\"友好\"、\"易用\"\n- 可扩展性: \"可扩展\"、\"灵活\"、\"适应性强\"\n\n**解决方案:**\n- 添加可量化指标\n- 提供具体的衡量标准\n- 明确测试条件\n\n### 3. 覆盖度分析模式\n\n**需求-任务映射规则:**\n- 直接关键词匹配\n- 语义相似性推断\n- 上下文关联分析\n\n**覆盖度计算:**\n- 有任务覆盖的需求数量 / 总需求数量\n- 非功能需求的覆盖检查\n- 验收标准的对齐验证\n\n## 严重性评估标准\n\n### CRITICAL级别\n- 违反项目宪章MUST原则\n- 缺少核心功能需求\n- 阻塞基线功能的实现\n- 安全或合规性违规\n\n### HIGH级别\n- 重复或冲突的需求定义\n- 关键性能指标缺失\n- 不可测试的验收标准\n- 架构决策冲突\n\n### MEDIUM级别\n- 术语使用不一致\n- 非功能需求覆盖不足\n- 边界情况定义不清\n- 任务依赖关系不明确\n\n### LOW级别\n- 文档风格问题\n- 轻微冗余表达\n- 格式规范化建议\n- 非关键改进建议",
        "skills/speckit-checklist-zh/SKILL.md": "---\nname: speckit-checklist-zh\ndescription: 基于用户需求为当前功能生成定制检查清单的专业工具。专门用于需求质量验证，生成\"英语的单元测试\"，验证需求的完整性、清晰度和一致性。触发词：speckit-checklist、检查清单、需求验证、质量检查、checklist、requirements validation、质量审查、spec review\n---\n\n## 检查表目的：\"中文的单元测试\"\n\n**关键概念**：检查表是**要求编写的单元测试** - 它们验证特定领域中要求的质量、清晰度和完整性。\n\n**不用于验证/测试**：\n\n- ❌ 不是\"验证按钮正确点击\"\n- ❌ 不是\"测试错误处理是否有效\"\n- ❌ 不是\"确认 API 返回 200\"\n- ❌ 不是检查代码/实现是否符合规格\n\n**用于要求质量验证**：\n\n- ✅ \"是否为所有卡片类型定义了视觉层次要求？\"（完整性）\n- ✅ \"是否用特定的尺寸/定位量化了'显著显示'？\"（清晰度）\n- ✅ \"所有交互元素的悬停状态要求是否一致？\"（一致性）\n- ✅ \"是否为键盘导航定义了可访问性要求？\"（覆盖范围）\n- ✅ \"规格是否定义了徽标图像加载失败时的情况？\"（边缘情况）\n\n**比喻**：如果您的规格是编写的代码，那么检查表就是它的单元测试套件。您正在测试要求是否编写良好、完整、明确并准备好实施 - 而不是测试实现是否有效。\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 执行步骤\n\nscripts:\n  sh: .specify/scripts/bash/check-prerequisites.sh --json\n  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json\n\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS 列表。\n\n   - 所有文件路径必须是绝对的。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **澄清意图（动态）**：推导出最多三个初始上下文澄清问题（无预设目录）。它们必须：\n\n   - 从用户的措辞 + 从规格/计划/任务中提取的信号生成\n   - 仅询问会实质性改变检查表内容的信息\n   - 如果在 `$ARGUMENTS` 中已经明确，则单独跳过\n   - 优先考虑精确性而非广度\n\n   生成算法：\n\n   1. 提取信号：功能领域关键词（例如，auth, latency, UX, API），风险指标（\"critical\", \"must\", \"compliance\"），利益相关者提示（\"QA\", \"review\", \"security team\"）和明确的交付物（\"a11y\", \"rollback\", \"contracts\"）。\n   2. 将信号聚类到候选关注领域（最多 4 个）按相关性排序。\n   3. 识别可能的受众和时机（作者、审阅者、QA、发布）如果不明确。\n   4. 检测缺失的维度：范围广度、深度/严谨性、风险重点、排除边界、可测量的验收标准。\n   5. 从这些原型中制定问题：\n      - 范围细化（例如，\"这应该包括与 X 和 Y 的集成接触点还是仅限于本地模块正确性？\"）\n      - 风险优先级（例如，\"这些潜在风险领域中哪些应该接受强制门控检查？\"）\n      - 深度校准（例如，\"这是一个轻量级的预提交健全性列表还是正式的发布门？\"）\n      - 受众框架（例如，\"这将仅由作者使用还是在 PR 审阅期间由同行使用？\"）\n      - 边界排除（例如，\"我们应该明确排除本轮的性能调优项目吗？\"）\n      - 场景类别差距（例如，\"未检测到恢复流程——回滚/部分故障路径是否在范围内？\"）\n\n   问题格式规则：\n\n   - 如果提供选项，生成一个紧凑的表格，列：选项 | 候选 | 重要性原因\n   - 限制最多 A-E 个选项；如果自由形式答案更清晰则省略表格\n   - 永远不要要求用户重述他们已经说过的话\n   - 避免推测性类别（无幻觉）。如果不确定，明确询问：\"确认 X 是否在范围内。\"\n\n   无法交互时的默认值：\n\n   - 深度：标准\n   - 受众：如果与代码相关则为审阅者（PR）；否则为作者\n   - 关注：前 2 个相关性聚类\n\n   输出问题（标记 Q1/Q2/Q3）。回答后：如果≥2 个场景类别（替代/异常/恢复/非功能性领域）仍不清楚，您可以要求最多两个更有针对性的后续问题（Q4/Q5），每个问题附带一行理由（例如，\"未解决的恢复路径风险\"）。不要超过五个总问题。如果用户明确拒绝更多问题则跳过升级。\n\n3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清答案：\n\n   - 推导检查表主题（例如，安全、审阅、部署、用户体验）\n   - 整合用户提到的明确必备项目\n   - 将焦点选择映射到类别脚手架\n   - 从规格/计划/任务中推断任何缺失的上下文（不要幻觉）\n\n4. **加载功能上下文**：从 FEATURE_DIR 读取：\n\n   - spec.md：功能要求和范围\n   - plan.md（如果存在）：技术细节、依赖关系\n   - tasks.md（如果存在）：实施任务\n\n   **上下文加载策略**：\n\n   - 仅加载与活跃关注领域相关的必要部分（避免完整文件转储）\n   - 更喜欢将长段落总结为简洁的场景/要求要点\n   - 使用渐进式披露：仅在检测到差距时添加后续检索\n   - 如果源文档很大，生成中间摘要项目而不是嵌入原始文本\n\n5. **生成检查表** - 创建\"要求的单元测试\"：\n\n   - 如果不存在则创建 `FEATURE_DIR/checklists/` 目录\n   - 生成唯一的检查表文件名：\n     - 使用基于领域的简短描述性名称（例如，`ux.md`, `api.md`, `security.md`）\n     - 格式：`[domain].md`\n     - 如果文件存在，则追加到现有文件\n   - 从 CHK001 开始顺序编号项目\n   - 每个 `speckit-checklist` 运行创建一个新文件（从不覆盖现有检查表）\n\n   **核心原则 - 测试要求，而不是实现**：\n   每个检查表项目必须评估要求本身：\n\n   - **完整性**：所有必要的要求是否存在？\n   - **清晰度**：要求是否明确且具体？\n   - **一致性**：要求是否相互对齐？\n   - **可测量性**：要求是否可以客观验证？\n   - **覆盖范围**：是否解决了所有场景/边缘情况？\n\n   **类别结构** - 按要求质量维度分组项目：\n\n   - **要求完整性**（是否记录了所有必要的要求？）\n   - **要求清晰度**（要求是否具体且明确？）\n   - **要求一致性**（要求是否对齐而无冲突？）\n   - **验收标准质量**（成功标准是否可测量？）\n   - **场景覆盖**（是否解决了所有流程/案例？）\n   - **边缘情况覆盖**（是否定义了边界条件？）\n   - **非功能性要求**（性能、安全性、可访问性等 - 是否指定？）\n   - **依赖关系和假设**（是否记录和验证？）\n   - **歧义和冲突**（需要澄清什么？）\n\n   **如何编写检查表项目 - \"英语的单元测试\"**：\n\n   ❌ **错误**（测试实现）：\n\n   - \"验证着陆页显示 3 个剧集卡片\"\n   - \"测试桌面端悬停状态是否有效\"\n   - \"确认徽标点击导航到主页\"\n\n   ✅ **正确**（测试要求质量）：\n\n   - \"是否明确指定了特色剧集的确切数量和布局？\" [完整性]\n   - \"是否用特定的尺寸/定位量化了'显著显示'？\" [清晰度]\n   - \"所有交互元素的悬停状态要求是否一致？\" [一致性]\n   - \"是否为所有交互式 UI 定义了键盘导航要求？\" [覆盖范围]\n   - \"当徽标图像加载失败时是否指定了回退行为？\" [边缘情况]\n   - \"是否为异步剧集数据定义了加载状态？\" [完整性]\n   - \"规格是否定义了竞争 UI 元素的视觉层次？\" [清晰度]\n\n   **项目结构**：\n   每个项目应遵循此模式：\n\n   - 询问要求质量的问题格式\n   - 关注规格/计划中编写（或未编写）的内容\n   - 包括质量维度在括号中 [完整性/清晰度/一致性等]\n   - 检查现有要求时引用规格部分 `[Spec §X.Y]`\n   - 使用 `[Gap]` 标记检查缺失的要求\n\n   **按质量维度的示例**：\n\n   完整性：\n\n   - \"是否为所有 API 故障模式定义了错误处理要求？ [Gap]\"\n   - \"是否为所有交互元素指定了可访问性要求？ [完整性]\"\n   - \"是否为响应式布局定义了移动断点要求？ [Gap]\"\n\n   清晰度：\n\n   - \"是否用特定的时间阈值量化了'快速加载'？ [清晰度, Spec §NFR-2]\"\n   - \"是否明确定义了'相关剧集'的选择标准？ [清晰度, Spec §FR-5]\"\n   - \"是否用可测量的视觉属性定义了'显著'？ [歧义, Spec §FR-4]\"\n\n   一致性：\n\n   - \"所有页面的导航要求是否对齐？ [一致性, Spec §FR-10]\"\n   - \"着陆页和详情页的卡片组件要求是否一致？ [一致性]\"\n\n   覆盖范围：\n\n   - \"是否为零状态场景（无剧集）定义了要求？ [覆盖范围, 边缘情况]\"\n   - \"是否解决了并发用户交互场景？ [覆盖范围, Gap]\"\n   - \"是否为部分数据加载失败指定了要求？ [覆盖范围, 异常流程]\"\n\n   可测量性：\n\n   - \"视觉层次要求是否可测量/可测试？ [验收标准, Spec §FR-1]\"\n   - \"是否可以客观验证'平衡的视觉权重'？ [可测量性, Spec §FR-2]\"\n\n   **场景分类和覆盖**（要求质量重点）：\n\n   - 检查是否存在要求：主要、替代、异常/错误、恢复、非功能性场景\n   - 对于每个场景类别，询问：\"[场景类型] 要求是否完整、清晰且一致？\"\n   - 如果场景类别缺失：\"[场景类型] 要求是故意排除还是缺失？ [Gap]\"\n   - 包括状态变更时的弹性/回滚：\"是否为迁移失败定义了回滚要求？ [Gap]\"\n\n   **可追溯性要求**：\n\n   - 最低要求：≥80% 的项目必须至少包含一个可追溯性引用\n   - 每个项目应引用：规格部分 `[Spec §X.Y]`，或使用标记：`[Gap]`、`[Ambiguity]`、`[Conflict]`、`[Assumption]`\n   - 如果不存在 ID 系统：\"是否建立了要求和验收标准 ID 方案？ [可追溯性]\"\n\n   **表面和解决问题**（要求质量问题）：\n   询问有关要求本身的问题：\n\n   - 歧义：\"'快速' 一词是否用具体指标量化？ [歧义, Spec §NFR-1]\"\n   - 冲突：\"§FR-10 和 §FR-10a 中的导航要求是否冲突？ [冲突]\"\n   - 假设：\"'始终可用的播客 API' 假设是否已验证？ [假设]\"\n   - 依赖关系：\"是否记录了外部播客 API 要求？ [依赖关系, Gap]\"\n   - 缺失定义：\"是否用可测量的标准定义了'视觉层次'？ [Gap]\"\n\n   **内容整合**：\n\n   - 软上限：如果原始候选项目 > 40，按风险/影响优先排序\n   - 合并检查相同要求方面的近似重复项\n   - 如果 >5 个低影响边缘情况，创建一个项目：\"边缘情况 X、Y、Z 是否在要求中解决？ [覆盖范围]\"\n\n   **🚫 绝对禁止** - 这些使其成为实现测试，而不是要求测试：\n\n   - ❌ 任何以\"验证\"、\"测试\"、\"确认\"、\"检查\" + 实现行为开头的项目\n   - ❌ 引用代码执行、用户操作、系统行为\n   - ❌ \"正确显示\"、\"正常工作\"、\"按预期功能\"\n   - ❌ \"点击\"、\"导航\"、\"渲染\"、\"加载\"、\"执行\"\n   - ❌ 测试用例、测试计划、QA 程序\n   - ❌ 实现细节（框架、API、算法）\n\n   **✅ 必需模式** - 这些测试要求质量：\n\n   - ✅ \"是否为 [场景] 定义/指定/记录了 [要求类型]？\"\n   - ✅ \"是否用具体标准量化/澄清了 [模糊术语]？\"\n   - ✅ \"[部分 A] 和 [部分 B] 的要求是否一致？\"\n   - ✅ \"是否可以客观测量/验证 [要求]？\"\n   - ✅ \"要求中是否解决了 [边缘情况/场景]？\"\n   - ✅ \"规格是否定义了 [缺失方面]？\"\n\n6. **结构参考**：按照 `.specify/templates/checklist-template.md` 中的规范模板生成检查表，包括标题、元部分、类别标题和 ID 格式。如果模板不可用，使用：H1 标题、目的/创建的元行、包含 `- [ ] CHK### <要求项目>` 行的 `##` 类别部分，全局递增 ID 从 CHK001 开始。\n\n7. **报告**：输出创建的检查表的完整路径、项目计数，并提醒用户每次运行都会创建一个新文件。总结：\n\n   - 选择的关注领域\n   - 深度级别\n   - 参与者/时机\n   - 任何包含的用户明确指定的必备项目\n\n**重要**：每个 `speckit-checklist` 命令调用都使用简短的描述性名称创建检查表文件，除非文件已存在。这允许：\n\n- 不同类型的多个检查表（例如，`ux.md`, `test.md`, `security.md`）\n- 简单、易记的文件名，指示检查表目的\n- 在 `checklists/` 文件夹中轻松识别和导航\n\n为避免混乱，使用描述性类型并在完成后清理过时的检查表。\n\n## 示例检查表类型和示例项目\n\n**用户体验要求质量：** `ux.md`\n\n示例项目（测试要求，而不是实现）：\n\n- \"是否用可测量的标准定义了视觉层次要求？ [清晰度, Spec §FR-1]\"\n- \"是否明确定义了 UI 元素的数量和定位？ [完整性, Spec §FR-1]\"\n- \"交互状态要求（悬停、焦点、活动）是否一致定义？ [一致性]\"\n- \"是否为所有交互元素指定了可访问性要求？ [覆盖范围, Gap]\"\n- \"图像加载失败时是否定义了回退行为？ [边缘情况, Gap]\"\n- \"是否可以客观测量'显著显示'？ [可测量性, Spec §FR-4]\"\n\n**API 要求质量：** `api.md`\n\n示例项目：\n\n- \"是否为所有故障场景指定了错误响应格式？ [完整性]\"\n- \"是否用具体阈值量化了速率限制要求？ [清晰度]\"\n- \"所有端点的身份验证要求是否一致？ [一致性]\"\n- \"是否为外部依赖关系定义了重试/超时要求？ [覆盖范围, Gap]\"\n- \"版本控制策略是否在要求中记录？ [Gap]\"\n\n**性能要求质量：** `performance.md`\n\n示例项目：\n\n- \"是否用具体指标量化了性能要求？ [清晰度]\"\n- \"是否为所有关键用户旅程定义了性能目标？ [覆盖范围]\"\n- \"是否为不同负载条件指定了性能要求？ [完整性]\"\n- \"是否可以客观测量性能要求？ [可测量性]\"\n- \"是否为高负载场景定义了降级要求？ [边缘情况, Gap]\"\n\n**安全要求质量：** `security.md`\n\n示例项目：\n\n- \"是否为所有受保护资源指定了身份验证要求？ [覆盖范围]\"\n- \"是否为敏感信息定义了数据保护要求？ [完整性]\"\n- \"威胁模型是否记录并与要求对齐？ [可追溯性]\"\n- \"安全要求是否与合规义务一致？ [一致性]\"\n- \"是否定义了安全故障/违规响应要求？ [Gap, 异常流程]\"\n\n## 反例：不要做的事情\n\n**❌ 错误 - 这些测试实现，而不是要求：**\n\n```markdown\n- [ ] CHK001 - 验证着陆页显示 3 个剧集卡片 [Spec §FR-001]\n- [ ] CHK002 - 测试桌面端悬停状态是否正确工作 [Spec §FR-003]\n- [ ] CHK003 - 确认徽标点击导航到主页 [Spec §FR-010]\n- [ ] CHK004 - 检查相关剧集部分显示 3-5 个项目 [Spec §FR-005]\n```\n\n**✅ 正确 - 这些测试要求质量：**\n\n```markdown\n- [ ] CHK001 - 是否明确定义了特色剧集的数量和布局？ [完整性, Spec §FR-001]\n- [ ] CHK002 - 是否为所有交互元素一致定义了悬停状态要求？ [一致性, Spec §FR-003]\n- [ ] CHK003 - 是否为所有可点击品牌元素明确了导航要求？ [清晰度, Spec §FR-010]\n- [ ] CHK004 - 是否记录了相关剧集的选择标准？ [Gap, Spec §FR-005]\n- [ ] CHK005 - 是否为异步剧集数据定义了加载状态要求？ [Gap]\n- [ ] CHK006 - 是否可以客观测量\"视觉层次\"要求？ [可测量性, Spec §FR-001]\n```\n\n**主要区别：**\n\n- 错误：测试系统是否正常工作\n- 正确：测试要求是否编写正确\n- 错误：行为验证\n- 正确：要求质量验证\n- 错误：\"它是否做 X？\"\n- 正确：\"X 是否明确定义？\"\n\n",
        "skills/speckit-checklist-zh/assets/checklist-template.md": "# [检查表类型] 检查表：[功能名称]\n\n**目的**：[此检查表涵盖内容的简要描述]\n**创建时间**：[日期]\n**功能**：[链接到 spec.md 或相关文档]\n\n**注意**：此检查表由 `/speckit.checklist` 命令根据功能上下文和要求生成。\n\n<!-- \n  ============================================================================\n  重要提示：下面的检查表项目仅为示例项目，仅用于说明。\n\n  /speckit.checklist 命令必须根据以下内容替换这些项目：\n  - 用户的具体检查表请求\n  - 来自 spec.md 的功能要求\n  - 来自 plan.md 的技术上下文\n  - 来自 tasks.md 的实现细节\n  \n  不要在生成的检查表文件中保留这些示例项目。\n  ============================================================================\n-->\n\n## [类别 1]\n\n- [ ] CHK001 第一个检查表项目，带有明确的操作\n- [ ] CHK002 第二个检查表项目\n- [ ] CHK003 第三个检查表项目\n\n## [类别 2]\n\n- [ ] CHK004 另一个类别的项目\n- [ ] CHK005 带有特定标准的项目\n- [ ] CHK006 此类别中的最后一个项目\n\n## 备注\n\n- 完成后勾选项目：`[x]`\n- 在线添加评论或发现\n- 链接到相关资源或文档\n- 项目按顺序编号以便于参考",
        "skills/speckit-checklist-zh/assets/correct-examples.md": "```markdown\n- [ ] CHK001 - Are the number and layout of featured episodes explicitly specified? [Completeness, Spec §FR-001]\n- [ ] CHK002 - Are hover state requirements consistently defined for all interactive elements? [Consistency, Spec §FR-003]\n- [ ] CHK003 - Are navigation requirements clear for all clickable brand elements? [Clarity, Spec §FR-010]\n- [ ] CHK004 - Is the selection criteria for related episodes documented? [Gap, Spec §FR-005]\n- [ ] CHK005 - Are loading state requirements defined for asynchronous episode data? [Gap]\n- [ ] CHK006 - Can \"visual hierarchy\" requirements be objectively measured? [Measurability, Spec §FR-001]\n```",
        "skills/speckit-checklist-zh/assets/example-snippets.md": "# 示例代码片段\n\n## PowerShell转义语法示例\n\n对于参数中的单引号，使用转义语法：\n```powershell\n# 错误：I'm Groot\n# 正确：'I'\\''m Groot'\n\n# 或者如果可能，使用双引号：\n\"I'm Groot\"\n```\n\n## 检查清单项目结构示例\n\n### 正确的项目格式：\n```markdown\n- [ ] CHK001 - Are the exact number and layout of featured episodes specified? [Completeness, Spec §FR-001]\n- [ ] CHK002 - Are hover state requirements consistently defined for all interactive elements? [Consistency, Spec §FR-003]\n- [ ] CHK003 - Is the selection criteria for related episodes documented? [Gap, Spec §FR-005]\n```\n\n### 项目组成要素：\n1. **复选框**：`- [ ]`\n2. **ID**：`CHK###`（从001开始顺序编号）\n3. **问题格式**：询问需求质量的问题\n4. **质量维度标签**：`[Completeness/Clarity/Consistency/etc.]`\n5. **规范引用**：`[Spec §X.Y]`（当检查现有需求时）\n6. **缺失标记**：`[Gap]`（当检查缺失需求时）\n\n## 问题格式化规则\n\n### 选项表格格式：\n```markdown\n| 选项 | 候选项 | 重要性 |\n|------|--------|---------|\n| A | 轻量级预提交检查 | 快速反馈，低摩擦 |\n| B | 正式发布门控 | 高质量保证，正式流程 |\n| C | PR审查辅助 | 协作改进，知识共享 |\n```\n\n### 限制：\n- 最多A-E选项\n- 如果自由形式答案更清晰，则省略表格\n- 绝不要要求用户重述他们已经说过的内容\n- 避免推测类别（无幻觉）\n\n## 默认值设置\n\n当交互不可能时：\n- **深度**：标准\n- **受众**：如果与代码相关则为审查者（PR）；否则为作者\n- **焦点**：前2个相关聚类",
        "skills/speckit-checklist-zh/assets/user-input-template.md": "```text\n$ARGUMENTS\n```",
        "skills/speckit-checklist-zh/assets/wrong-examples.md": "```markdown\n- [ ] CHK001 - Verify landing page displays 3 episode cards [Spec §FR-001]\n- [ ] CHK002 - Test hover states work correctly on desktop [Spec §FR-003]\n- [ ] CHK003 - Confirm logo click navigates to home page [Spec §FR-010]\n- [ ] CHK004 - Check that related episodes section shows 3-5 items [Spec §FR-005]\n```",
        "skills/speckit-checklist-zh/references/anti-examples.md": "# 反示例：什么不应该做\n\n## ❌ 错误 - 这些测试实施，而非需求：\n\n### 错误的项目类型：\n1. **验证行为**：\n   - \"验证登录页面显示3个剧集卡片\"\n   - \"测试悬停状态在桌面版上正常工作\"\n   - \"确认logo点击导航到主页\"\n\n2. **检查实施细节**：\n   - \"检查相关剧集部分显示3-5个项目\"\n   - \"验证按钮在点击时变蓝\"\n   - \"测试API调用返回200状态码\"\n\n3. **基于用户操作的项目**：\n   - \"点击提交按钮时表单应提交\"\n   - \"用户输入无效邮箱时显示错误消息\"\n   - \"滚动时导航栏保持固定在顶部\"\n\n## ✅ 正确 - 这些测试需求质量：\n\n### 正确的项目类型：\n1. **完整性检查**：\n   - \"是否明确指定了特色剧集的数量和布局？[完整性, Spec §FR-001]\"\n   - \"是否为所有异步剧集数据定义了加载状态需求？[Gap]\"\n\n2. **清晰度验证**：\n   - \"所有可点击品牌元素的导航需求是否清晰？[清晰度, Spec §FR-010]\"\n   - \"'视觉层次'需求是否可以客观测量？[可测量性, Spec §FR-001]\"\n\n3. **一致性检查**：\n   - \"所有交互元素的悬停状态需求是否一致定义？[一致性, Spec §FR-003]\"\n\n4. **覆盖度验证**：\n   - \"相关剧集的选择标准是否已记录？[Gap, Spec §FR-005]\"\n   - \"是否为零状态场景（无剧集）定义了需求？[覆盖度, 边界情况]\"\n\n## 关键差异总结：\n\n| 错误方法 | 正确方法 |\n|---------|---------|\n| 测试系统是否正常工作 | 测试需求是否编写正确 |\n| 行为验证 | 需求质量验证 |\n| \"它是否做X？\" | \"X是否明确指定？\" |\n| 关注实施结果 | 关注需求文档质量 |\n| 验证用户交互 | 验证交互需求定义 |\n\n## 识别错误项目的模式\n\n**应立即标记的警告词语：**\n- \"Verify\" / \"验证\"\n- \"Test\" / \"测试\"\n- \"Confirm\" / \"确认\"\n- \"Check\" / \"检查\"\n- \"Displays\" / \"显示\"\n- \"Works\" / \"工作\"\n- \"Functions\" / \"功能\"\n\n**应避免的动词：**\n- Click / 点击\n- Navigate / 导航\n- Render / 渲染\n- Load / 加载\n- Execute / 执行\n\n**正确的提问模式：**\n- \"Are [需求类型] defined/specified/documented for [场景]？\"\n- \"Is [模糊术语] quantified/clarified with specific criteria？\"\n- \"Are requirements consistent between [部分A] and [部分B]？\"\n- \"Can [需求] be objectively measured/verified？\"",
        "skills/speckit-checklist-zh/references/checklist-types.md": "# 检查清单类型和示例项目\n\n## UX需求质量检查清单：`ux.md`\n\n示例项目（测试需求，而非实施）：\n\n- \"是否使用可测量标准定义了视觉层次需求？[清晰度, Spec §FR-1]\"\n- \"是否明确指定了UI元素的数量和位置？[完整性, Spec §FR-1]\"\n- \"是否一致定义了交互状态需求（悬停、焦点、活动）？[一致性]\"\n- \"是否为所有交互元素指定了可访问性需求？[覆盖度, Gap]\"\n- \"是否在图像加载失败时定义了回退行为？[边界情况, Gap]\"\n- \"'突出显示'是否可以客观测量？[可测量性, Spec §FR-4]\"\n\n## API需求质量检查清单：`api.md`\n\n示例项目：\n\n- \"是否为所有故障场景指定了错误响应格式？[完整性]\"\n- \"是否使用特定阈值量化了速率限制需求？[清晰度]\"\n- \"所有端点的身份验证需求是否一致？[一致性]\"\n- \"是否为外部依赖项定义了重试/超时需求？[覆盖度, Gap]\"\n- \"版本控制策略是否在需求中记录？[Gap]\"\n\n## 性能需求质量检查清单：`performance.md`\n\n示例项目：\n\n- \"是否使用特定指标量化了性能需求？[清晰度]\"\n- \"是否为所有关键用户旅程定义了性能目标？[覆盖度]\"\n- \"是否指定了不同负载条件下的性能需求？[完整性]\"\n- \"性能需求是否可以客观测量？[可测量性]\"\n- \"是否为高负载场景定义了降级需求？[边界情况, Gap]\"\n\n## 安全需求质量检查清单：`security.md`\n\n示例项目：\n\n- \"是否为所有受保护资源指定了身份验证需求？[覆盖度]\"\n- \"是否为敏感信息定义了数据保护需求？[完整性]\"\n- \"威胁模型是否已记录并且需求与之保持一致？[可追溯性]\"\n- \"安全需求是否与合规义务保持一致？[一致性]\"\n- \"是否定义了安全失败/泄露响应需求？[Gap, 异常流程]\"\n\n## 检查清单命名约定\n\n**文件命名原则：**\n- 使用简短、描述性的名称基于域（例如 `ux.md`, `api.md`, `security.md`）\n- 格式：`[domain].md`\n- 如果文件存在，追加到现有文件\n\n**避免使用：**\n- 过于通用的名称（如 `checklist.md`, `review.md`）\n- 过于具体的名称（如 `api-endpoint-v2-security.md`）\n- 包含日期或版本的名称（这些信息应在文件内容中）",
        "skills/speckit-checklist-zh/references/execution-guide.md": "# 执行指南\n\n## 完整执行步骤详解\n\n### 1. 环境设置\n运行先决条件检查脚本：\n```powershell\n.scripts\\check-prerequisites.ps1 -Json\n```\n\n**解析输出：**\n- `FEATURE_DIR`: 功能根目录的绝对路径\n- `AVAILABLE_DOCS`: 可用文档列表 [spec.md, plan.md, tasks.md]\n\n### 2. 动态意图澄清算法\n\n**信号提取：**\n1. 功能域关键词：auth, latency, UX, API\n2. 风险指标：critical, must, compliance\n3. 利益相关者提示：QA, review, security team\n4. 明确交付物：a11y, rollback, contracts\n\n**问题生成原型：**\n- 范围细化：\"这应该包括与X和Y的集成接触点还是仅限于本地模块正确性？\"\n- 风险优先级：\"这些潜在风险区域中哪些应该接受强制性门控检查？\"\n- 深度校准：\"这是轻量级预提交健全性列表还是正式发布门？\"\n- 受众框架：\"这仅供作者使用还是在PR审查期间供同行使用？\"\n- 边界排除：\"本轮我们是否应明确排除性能调优项目？\"\n\n### 3. 上下文加载策略\n\n**渐进式披露原则：**\n- 仅加载与活动焦点区域相关的必要部分\n- 优先将长部分总结为简洁的场景/需求要点\n- 使用渐进式披露：仅在检测到缺失时添加后续检索\n- 如果源文档很大，生成临时摘要项目而不是嵌入原始文本\n\n### 4. 检查清单生成算法\n\n**核心原则 - 测试需求而非实施：**\n每个检查清单项目必须评估需求本身在以下方面的质量：\n- **完整性**：是否存在所有必要的需求？\n- **清晰度**：需求是否明确无歧义？\n- **一致性**：需求是否相互一致？\n- **可测量性**：需求是否可以客观验证？\n- **覆盖度**：是否处理了所有场景/边界情况？\n\n**可追溯性要求：**\n- 最低要求：≥80%的项目必须包含至少一个可追溯性引用\n- 每个项目应引用：规范章节 [Spec §X.Y]，或使用标记：[Gap], [Ambiguity], [Conflict], [Assumption]\n- 如果不存在ID系统：\"是否建立了需求和验收标准ID方案？[可追溯性]\"\n\n### 5. 内容整合策略\n\n**软上限：** 如果原始候选项目 > 40，按风险/影响优先排序\n**合并重复项：** 合并检查相同需求方面的近似重复项\n**边界情况分组：** 如果 > 5 个低影响边界情况，创建一个项目：\"需求中是否解决了边界情况X, Y, Z？[覆盖度]\"",
        "skills/speckit-checklist-zh/references/quality-dimensions.md": "# 质量维度详细说明\n\n## 九大需求质量维度\n\n### 1. 需求完整性 (Requirement Completeness)\n**关注点**：是否记录了所有必要的需求？\n\n**示例项目**：\n- \"是否为所有API故障模式定义了错误处理需求？[Gap]\"\n- \"是否为所有交互元素指定了可访问性需求？[完整性]\"\n- \"是否为响应式布局定义了移动断点需求？[Gap]\"\n\n### 2. 需求清晰度 (Requirement Clarity)\n**关注点**：需求是否明确无歧义？\n\n**示例项目**：\n- \"'快速加载'是否用特定时间阈值量化？[清晰度, Spec §NFR-2]\"\n- \"'相关剧集'选择标准是否明确定义？[清晰度, Spec §FR-5]\"\n- \"'突出'是否用可测量的视觉属性定义？[歧义, Spec §FR-4]\"\n\n### 3. 需求一致性 (Requirement Consistency)\n**关注点**：需求是否在无冲突的情况下保持一致？\n\n**示例项目**：\n- \"所有页面的导航需求是否一致？[一致性, Spec §FR-10]\"\n- \"登录页面和详情页面的卡片组件需求是否一致？[一致性]\"\n\n### 4. 验收标准质量 (Acceptance Criteria Quality)\n**关注点**：成功标准是否可测量？\n\n**示例项目**：\n- \"视觉层次需求是否可测量/可测试？[验收标准, Spec §FR-1]\"\n- \"'平衡视觉权重'是否可以客观验证？[可测量性, Spec §FR-2]\"\n\n### 5. 场景覆盖度 (Scenario Coverage)\n**关注点**：是否处理了所有流程/案例？\n\n**示例项目**：\n- \"是否为零状态场景（无剧集）定义了需求？[覆盖度, 边界情况]\"\n- \"是否解决了并发用户交互场景？[覆盖度, Gap]\"\n- \"是否为部分数据加载故障指定了需求？[覆盖度, 异常流程]\"\n\n### 6. 边界情况覆盖度 (Edge Case Coverage)\n**关注点**：是否定义了边界条件？\n\n**示例项目**：\n- \"是否在logo图像加载失败时指定了回退行为？[边界情况]\"\n- \"是否处理了网络连接完全丢失的情况？[边界情况, Gap]\"\n- \"是否定义了最大用户数限制的处理？[边界情况]\"\n\n### 7. 非功能性需求 (Non-Functional Requirements)\n**关注点**：是否指定了性能、安全性、可访问性等？\n\n**示例项目**：\n- \"是否用特定指标量化了性能需求？[清晰度]\"\n- \"是否为敏感数据定义了安全要求？[完整性]\"\n- \"是否符合WCAG 2.1 AA级可访问性标准？[覆盖度]\"\n\n### 8. 依赖项和假设 (Dependencies & Assumptions)\n**关注点**：是否记录并验证了依赖项和假设？\n\n**示例项目**：\n- \"'始终可用的播客API'假设是否已验证？[假设]\"\n- \"是否记录了外部播客API需求？[依赖项, Gap]\"\n- \"第三方服务级别的可用性要求是什么？[依赖项]\"\n\n### 9. 歧义和冲突 (Ambiguities & Conflicts)\n**关注点**：什么需要澄清？\n\n**示例项目**：\n- \"术语'快速'是否用特定指标量化？[歧义, Spec §NFR-1]\"\n- \"§FR-10和§FR-10a之间的导航需求是否冲突？[冲突]\"\n- \"'视觉层次'是否用可测量标准定义？[Gap]\"\n\n## 场景分类和覆盖度\n\n### 主要场景类型：\n1. **主要场景**：正常业务流程\n2. **备用场景**：替代路径和方法\n3. **异常/错误场景**：故障和错误条件\n4. **恢复场景**：从故障中恢复\n5. **非功能性场景**：性能、安全、可访问性等\n\n### 覆盖度检查模式：\n- 对于每种场景类型，询问：\"[场景类型]需求是否完整、清晰和一致？\"\n- 如果场景类型缺失：\"[场景类型]需求是故意排除还是缺失？[Gap]\"\n- 当发生状态变更时包含弹性/回滚：\"是否为迁移故障定义了回滚需求？[Gap]\"",
        "skills/speckit-clarify-zh/SKILL.md": "---\nname: speckit-clarify-zh\ndescription: 通过提出最多5个高度针对性的澄清问题来识别当前功能规范中未明确定义的领域，并将答案编码回规范中。触发词包括：\"speckit-clarify\"、\"speckit澄清\"、\"规范澄清\"、\"功能澄清\"、\"识别模糊点\"、\"澄清需求\"。\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n目标：检测并减少活动功能规格中的歧义或缺失决策点，并将澄清直接记录在规格文件中。\n\n注意：此澄清工作流程预计在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确表示他们正在跳过澄清（例如，探索性刺探），您可以继续，但必须警告下游返工风险会增加。\n\n执行步骤：\n\nscripts:\n   sh: .specify/scripts/bash/check-prerequisites.sh --json --paths-only\n   ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly\n\n1. 从仓库根目录运行一次 `{SCRIPT}`（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON 负载字段：\n\n   - `FEATURE_DIR`\n   - `FEATURE_SPEC`\n   - （可选捕获 `IMPL_PLAN`, `TASKS` 用于未来的链式流程。）\n   - 如果 JSON 解析失败，则中止并指示用户重新运行 `speckit-specify` 或验证功能分支环境。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. 加载当前规格文件。使用此分类法执行结构化歧义和覆盖扫描。对于每个类别，标记状态：清晰 / 部分 / 缺失。生成用于优先级排序的内部覆盖图（除非不问问题，否则不要输出原始图）。\n\n   功能范围和行为：\n\n   - 核心用户目标和成功标准\n   - 明确的范围外声明\n   - 用户角色 / 人物区分\n\n   领域和数据模型：\n\n   - 实体、属性、关系\n   - 身份和唯一性规则\n   - 生命周期/状态转换\n   - 数据量 / 规模假设\n\n   交互和用户体验流程：\n\n   - 关键用户旅程 / 序列\n   - 错误/空/加载状态\n   - 可访问性或本地化注释\n\n   非功能性质量属性：\n\n   - 性能（延迟、吞吐量目标）\n   - 可扩展性（水平/垂直、限制）\n   - 可靠性和可用性（正常运行时间、恢复期望）\n   - 可观察性（日志、指标、跟踪信号）\n   - 安全性和隐私（认证/授权、数据保护、威胁假设）\n   - 合规性 / 监管约束（如果有）\n\n   集成和外部依赖：\n\n   - 外部服务/API 和故障模式\n   - 数据导入/导出格式\n   - 协议/版本假设\n\n   边缘情况和故障处理：\n\n   - 负面场景\n   - 速率限制 / 节流\n   - 冲突解决（例如，并发编辑）\n\n   约束和权衡：\n\n   - 技术约束（语言、存储、托管）\n   - 明确的权衡或被拒绝的替代方案\n\n   术语和一致性：\n\n   - 规范术语表\n   - 避免的同义词 / 废弃术语\n\n   完成信号：\n\n   - 验收标准可测试性\n   - 可测量的完成定义风格指标\n\n   杂项 / 占位符：\n\n   - TODO 标记 / 未解决的决策\n   - 缺乏量化的模糊形容词（\"健壮的\"、\"直观的\"）\n\n   对于状态为部分或缺失的每个类别，添加一个候选问题机会，除非：\n\n   - 澄清不会实质性改变实施或验证策略\n   - 信息最好推迟到规划阶段（内部记录）\n\n3. 生成（内部）优先级候选澄清问题队列（最多 5 个）。不要一次性输出所有问题。应用这些约束：\n\n   - 整个会话最多 10 个问题。\n   - 每个问题必须可以通过以下方式回答：\n     - 短的多项选择（2-5 个不同的、互斥的选项），或\n     - 一个单词 / 短语答案（明确约束：\"答案 <=5 个单词\"）。\n   - 仅包括其答案实质性影响架构、数据建模、任务分解、测试设计、用户体验行为、运营准备或合规性验证的问题。\n   - 确保类别覆盖平衡：尝试首先覆盖最高影响的未解决类别；避免在单个高影响领域（例如，安全态势）未解决时问两个低影响问题。\n   - 排除已经回答的问题、琐碎的风格偏好或计划级执行细节（除非阻塞正确性）。\n   - 优先考虑减少下游返工风险或防止不一致验收测试的澄清。\n   - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。\n\n4. 顺序提问循环（交互式）：\n\n   - 一次只提出一个问题。\n\n   - 对于多项选择问题：\n\n     - **分析所有选项**并根据以下确定**最合适的选项**：\n       - 项目类型的最佳实践\n       - 类似实现中的常见模式\n       - 风险降低（安全性、性能、可维护性）\n       - 与规格中可见的任何明确项目目标或约束对齐\n     - 突出显示您的**推荐选项**在顶部，并提供明确的理由（1-2 句解释为什么这是最佳选择）。\n     - 格式为：`**推荐：** 选项 [X] - <理由>`\n     - 然后将所有选项呈现为 Markdown 表格：\n\n     | 选项 | 描述                                                         |\n     | ---- | ------------------------------------------------------------ |\n     | A    | <选项 A 描述>                                                |\n     | B    | <选项 B 描述>                                                |\n     | C    | <选项 C 描述>（根据需要添加 D/E 至多 5 个）                  |\n     | 简短 | 提供不同的简短答案（<=5 个单词）（仅在自由形式替代方案适当时包含） |\n\n     - 表格后添加：`您可以回复选项字母（例如，\"A\"），通过说\"yes\"或\"recommended\"接受推荐，或提供您自己的简短答案。`\n\n   - 对于简短答案风格（无有意义的离散选项）：\n\n     - 提供您的**建议答案**基于最佳实践和上下文。\n     - 格式为：`**建议：** <您的建议答案> - <简要理由>`\n     - 然后输出：`格式：简短答案（<=5 个单词）。您可以通过说\"yes\"或\"suggested\"接受建议，或提供您自己的答案。`\n\n   - 用户回答后：\n\n     - 如果用户回复\"yes\"、\"recommended\"或\"suggested\"，使用您之前声明的推荐/建议作为答案。\n     - 否则，验证答案映射到一个选项或符合 <=5 个单词的约束。\n     - 如果模糊，要求快速澄清（计数仍属于同一问题；不要前进）。\n     - 一旦满意，将其记录在工作内存中（尚不写入磁盘）并移至下一个排队问题。\n\n   - 停止进一步提问当：\n\n     - 所有关键歧义提前解决（剩余排队项目变得不必要），或\n     - 用户发出完成信号（\"done\"、\"good\"、\"no more\"），或\n     - 您达到 5 个已问问题。\n\n   - 永远不要提前透露未来排队的问题。\n\n   - 如果开始时没有有效问题，立即报告没有关键歧义。\n\n5. 每个接受答案后的集成（增量更新方法）：\n\n   - 维护规格的内存表示（启动时加载一次）加上原始文件内容。\n   - 对于此会话中的第一个集成答案：\n     - 确保存在 `## Clarifications` 部分（如果缺失，则在规格模板中最高级上下文/概述部分之后创建）。\n     - 在其下创建（如果不存在）一个 `### Session YYYY-MM-DD` 子标题用于今天。\n   - 接受后立即追加一个项目符号行：`- Q: <问题> → A: <最终答案>`。\n   - 然后立即将澄清应用到最合适的部分：\n     - 功能歧义 → 更新或在功能要求中添加项目符号。\n     - 用户交互 / 行为者区分 → 更新用户故事或行为者子部分（如果存在）与澄清的角色、约束或场景。\n     - 数据形状 / 实体 → 更新数据模型（添加字段、类型、关系）保持排序；简洁地记录添加的约束。\n     - 非功能性约束 → 在非功能性 / 质量属性部分添加/修改可测量标准（将模糊形容词转换为指标或明确目标）。\n     - 边缘情况 / 负面流程 → 在边缘情况 / 错误处理下添加新项目符号（或创建此类子部分如果模板提供占位符）。\n     - 术语冲突 → 规范化整个规格中的术语；仅在必要时保留原始术语，添加`(以前称为\"X\")`一次。\n   - 如果澄清使早期模糊声明无效，则替换该声明而不是重复；不留过时的矛盾文本。\n   - 每次集成后保存规格文件以最小化上下文丢失风险（原子覆盖）。\n   - 保持格式：不要重新排序无关部分；保持标题层次结构完整。\n   - 保持每个插入的澄清最小且可测试（避免叙述性漂移）。\n\n6. 验证（每次写入后执行加上最终通过）：\n\n   - 澄清会话包含每个接受答案的一个项目符号（无重复）。\n   - 总问（接受）问题 ≤ 5。\n   - 更新部分不包含新的答案应该解决的模糊占位符。\n   - 无矛盾的早期声明保留（扫描移除的无效替代选择）。\n   - Markdown 结构有效；仅允许新标题：`## Clarifications`, `### Session YYYY-MM-DD`。\n   - 术语一致性：所有更新部分使用相同的规范术语。\n\n7. 将更新的规格写回 `FEATURE_SPEC`。\n\n8. 报告完成（提问循环结束或提前终止后）：\n\n   - 问和回答的问题数量。\n   - 更新规格的路径。\n   - 触及的部分（列出名称）。\n   - 覆盖摘要表列出每个分类类别，状态：已解决（之前部分/缺失并已解决）、推迟（超出问题配额或更适合规划）、清晰（已足够）、未解决（仍部分/缺失但影响低）。\n   - 如果有任何未解决或推迟的，建议是否继续到 `speckit-plan` 或稍后再次运行 `speckit-clarify`。\n   - 建议的下一个命令。\n\n行为规则：\n\n- 如果未发现有意义的歧义（或所有潜在问题都是低影响的），回应：\"未检测到值得正式澄清的关键歧义。\"并建议继续。\n- 如果规格文件缺失，指示用户先运行 `speckit-specify`（不要在此处创建新规格）。\n- 永远不要超过 5 个总问问题（澄清重试单个问题不计入新问题）。\n- 避免推测性技术栈问题，除非缺失会阻塞功能清晰度。\n- 尊重用户提前终止信号（\"stop\"、\"done\"、\"proceed\"）。\n- 如果由于完全覆盖而未问问题，输出紧凑的覆盖摘要（所有类别清晰）然后建议前进。\n- 如果配额达到但仍有未解决的高影响类别，明确标记它们为推迟并附上理由。\n\n优先级上下文：{ARGS}\n",
        "skills/speckit-constitution-zh/SKILL.md": "---\nname: speckit-constitution-zh\ndescription: 从交互式或提供的原则输入创建或更新项目章程，确保所有依赖模板保持同步。用于项目管理、规范制定、章程维护和团队协作场景。触发词包括 \"speckit章程\"、\"创建章程\"、\"更新章程\"、\"项目章程\"、\"制定规范\"、\"团队章程\"。\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n在继续之前，您**必须**考虑用户输入（如果不为空）。\n\n## 大纲\n\n您正在更新位于 `.specify/memory/constitution.md` 的项目章程。此文件源自一个模板[assets/constitution-template.md](assets/constitution-template.md)，包含方括号中的占位符令牌（例如 `[项目名称]`、`[原则_1_名称]`）。您的工作是：(a) 收集/推导具体值，(b) 精确填充模板，以及 (c) 在依赖工件中传播任何修订。\n\n遵循此执行流程：\n\n1. 将 `assets/specify/` 所有文件（包括子目录）按原目录结构复制到仓库根目录下的`.specify` 目录，跳过已有文件，**不能覆盖原有同名文件**。cp命令的 -n（--no-clobber）选项可以防止覆盖已存在的文件。\n在此阶段，您的项目文件夹内容应类似于以下内容：\n\n```text\n仓库根目录\n└── .specify\n    ├── memory\n    │  └── constitution.md\n    ├── scripts\n    │  ├──bash    \n    │  │  ├── check-prerequisites.sh\n    │  │  ├── common.sh\n    │  │  ├── create-new-feature.sh\n    │  │  ├── setup-plan.sh\n    │  │  └── update-claude-md.sh\n    │  ├──powershell    \n    │  │  ├── check-prerequisites.ps1\n    │  │  ├── common.ps1\n    │  │  ├── create-new-feature.ps1\n    │  │  ├── setup-plan.ps1\n    │  │  └── update-claude-md.ps1    \n    ├── specs\n    │  └── 001-create-taskify\n    │      └── spec.md\n    └── templates\n        ├── plan-template.md\n        ├── spec-template.md\n        └── tasks-template.md\n```\n\n\n2. 加载位于相对仓库根目录 `.specify/memory/constitution.md` 的现有章程模板。\n   - 识别形式为 `[ALL_CAPS_IDENTIFIER]` 的每个占位符令牌。\n     **重要**：用户可能需要比模板中使用的更少或更多的原则。如果指定了数量，请遵守该数量 - 遵循通用模板。您将相应地更新文档。\n\n3. 收集/推导占位符的值：\n   - 如果用户输入（对话）提供了值，则使用它。\n   - 否则从现有仓库上下文推断（README、文档、嵌入的先前章程版本）。\n   - 对于治理日期：`批准日期` 是原始采用日期（如果未知则询问或标记 TODO），如果有更改则 `最后修订日期` 是今天，否则保持之前的日期。\n   - `章程版本` 必须根据语义版本规则递增：\n     - 主版本：向后不兼容的治理/原则删除或重新定义。\n     - 次版本：添加新原则/章节或实质性扩展指导。\n     - 补丁：澄清、措辞、拼写错误修复、非语义性优化。\n   - 如果版本升级类型不明确，在最终确定前提出理由。\n\n4. 起草更新的章程内容：\n   - 用具体文本替换每个占位符（除了项目选择尚未定义而有意保留的模板槽位——明确说明任何剩余的占位符）。\n   - 保留标题层次结构，一旦替换可以移除注释，除非它们仍然提供澄清指导。\n   - 确保每个原则部分：简洁的名称行，段落（或项目符号列表）捕捉不可协商的规则，如果不是显而易见则提供明确的理由。\n   - 确保治理部分列出修订程序、版本策略和合规审查期望。\n\n5. 一致性传播检查清单（将先前检查清单转换为积极验证）：\n   - 读取 `.specify/templates/plan-template.md` 并确保任何\"章程检查\"或规则与更新的原则一致。\n   - 读取 `.specify/templates/spec-template.md` 以对齐范围/要求——如果章程添加/删除强制性章节或约束则更新。\n   - 读取 `.specify/templates/tasks-template.md` 并确保任务分类反映新增或删除的原则驱动任务类型（例如，可观察性、版本控制、测试纪律）。\n   - 读取任何运行时指导文档（例如 `README.md`、`docs/quickstart.md` 或存在的特定代理指导文件）。更新对已更改原则的引用。\n\n6. 生成同步影响报告（在更新后作为 HTML 注释预置在章程文件顶部）：\n   - 版本变更：旧 → 新\n   - 修改的原则列表（旧标题 → 新标题如果重命名）\n   - 新增章节\n   - 删除章节\n   - 需要更新的模板（✅ 已更新 / ⚠ 待处理）及文件路径\n   - 如果有任何占位符被故意推迟，则列出后续待办事项。\n\n7. 最终输出前的验证：\n   - 没有剩余未解释的括号令牌。\n   - 版本行与报告匹配。\n   - 日期为 ISO 格式 YYYY-MM-DD。\n   - 原则是陈述性的、可测试的，并且没有模糊语言（\"应该\" → 在适当地方替换为 MUST/SHOULD 理由）。\n\n8. 将完成的章程写回到 `.specify/memory/constitution.md`（覆盖）。\n\n9.  向用户输出最终摘要：\n   - 新版本和升级理由。\n   - 任何标记为手动跟进的文件。\n   - 建议的提交消息（例如，`docs: 修订章程至 vX.Y.Z（原则添加 + 治理更新）`）。\n\n格式化和样式要求：\n\n- 完全按照模板中的 Markdown 标题使用（不要降级/升级级别）。\n- 包装长理由行以保持可读性（理想情况下 <100 个字符），但不要用生硬的断行强制执行。\n- 在章节之间保持单个空行。\n- 避免尾随空白。\n\n如果用户提供部分更新（例如，仅修订一个原则），仍需执行验证和版本决策步骤。\n\n如果关键信息缺失（例如，批准日期确实未知），插入 `TODO(<FIELD_NAME>): explanation` 并在同步影响报告的延期项目下包含。\n\n不要创建新模板；始终在现有的 `.specify/memory/constitution.md` 文件上操作。",
        "skills/speckit-constitution-zh/assets/specify/memory/constitution.md": "# [项目名称] 章程\n<!-- 示例：规范章程，任务流章程等 -->\n\n## 核心原则\n\n### [原则_1_名称]\n<!-- 示例：I. 库优先 -->\n[原则_1_描述]\n<!-- 示例：每个功能都以独立库开始；库必须自包含、可独立测试、有文档；需要明确目的 - 没有仅用于组织的库 -->\n\n### [原则_2_名称]\n<!-- 示例：II. CLI 接口 -->\n[原则_2_描述]\n<!-- 示例：每个库都通过 CLI 暴露功能；文本输入/输出协议：stdin/args → stdout，错误 → stderr；支持 JSON + 人类可读格式 -->\n\n### [原则_3_名称]\n<!-- 示例：III. 测试优先（不可协商） -->\n[原则_3_描述]\n<!-- 示例：TDD 强制：编写测试 → 用户批准 → 测试失败 → 然后实现；严格强制红-绿-重构循环 -->\n\n### [原则_4_名称]\n<!-- 示例：IV. 集成测试 -->\n[原则_4_描述]\n<!-- 示例：需要集成测试的重点领域：新库契约测试、契约变更、服务间通信、共享模式 -->\n\n### [原则_5_名称]\n<!-- 示例：V. 可观察性，VI. 版本控制和破坏性变更，VII. 简单性 -->\n[原则_5_描述]\n<!-- 示例：文本 I/O 确保可调试性；需要结构化日志；或：MAJOR.MINOR.BUILD 格式；或：从简单开始，YAGNI 原则 -->\n\n## [部分_2_名称]\n<!-- 示例：附加约束、安全要求、性能标准等 -->\n\n[部分_2_内容]\n<!-- 示例：技术栈要求、合规标准、部署策略等 -->\n\n## [部分_3_名称]\n<!-- 示例：开发工作流程、审查过程、质量门等 -->\n\n[部分_3_内容]\n<!-- 示例：代码审查要求、测试门、部署批准流程等 -->\n\n## 治理\n<!-- 示例：章程优于所有其他实践；修订需要文档、批准、迁移计划 -->\n\n[治理规则]\n<!-- 示例：所有 PR/审查必须验证合规性；复杂性必须有正当理由；使用 [指导文件] 作为运行时开发指导 -->\n\n**版本**：[章程版本] | **批准**：[批准日期] | **最后修订**：[最后修订日期]\n<!-- 示例：版本：2.1.1 | 批准：2025-06-13 | 最后修订：2025-07-16 -->",
        "skills/speckit-constitution-zh/assets/specify/templates/agent-file-template.md": "# [项目名称] 开发指南\n\n自动生成自所有功能计划。最后更新：[日期]\n\n## 活动技术\n\n[从所有计划文件中提取]\n\n## 项目结构\n\n```text\n[来自计划的实际结构]\n```\n\n## 命令\n\n[仅限活动技术的命令]\n\n## 代码风格\n\n[特定语言的规范，仅适用于正在使用的语言]\n\n## 最近变更\n\n[最近3个功能及其添加内容]\n\n<!-- 手动添加开始 -->\n<!-- 手动添加结束 -->",
        "skills/speckit-constitution-zh/assets/specify/templates/checklist-template.md": "# [检查表类型] 检查表：[功能名称]\n\n**目的**：[此检查表涵盖内容的简要描述]\n**创建时间**：[日期]\n**功能**：[链接到 spec.md 或相关文档]\n\n**注意**：此检查表由 `/speckit.checklist` 命令根据功能上下文和要求生成。\n\n<!-- \n  ============================================================================\n  重要提示：下面的检查表项目仅为示例项目，仅用于说明。\n\n  /speckit.checklist 命令必须根据以下内容替换这些项目：\n  - 用户的具体检查表请求\n  - 来自 spec.md 的功能要求\n  - 来自 plan.md 的技术上下文\n  - 来自 tasks.md 的实现细节\n  \n  不要在生成的检查表文件中保留这些示例项目。\n  ============================================================================\n-->\n\n## [类别 1]\n\n- [ ] CHK001 第一个检查表项目，带有明确的操作\n- [ ] CHK002 第二个检查表项目\n- [ ] CHK003 第三个检查表项目\n\n## [类别 2]\n\n- [ ] CHK004 另一个类别的项目\n- [ ] CHK005 带有特定标准的项目\n- [ ] CHK006 此类别中的最后一个项目\n\n## 备注\n\n- 完成后勾选项目：`[x]`\n- 在线添加评论或发现\n- 链接到相关资源或文档\n- 项目按顺序编号以便于参考",
        "skills/speckit-constitution-zh/assets/specify/templates/commands/analyze.md": "---\ndescription: 在任务生成后，对 spec.md、plan.md 和 tasks.md 进行非破坏性的跨工件一致性和质量分析。\nscripts:\n  sh: scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks\n  ps: scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 目标\n\n在实现之前，识别三个核心工件（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、歧义和未充分说明的项目。此命令必须仅在 `/speckit.tasks` 成功生成完整的 `tasks.md` 后运行。\n\n## 操作约束\n\n**严格只读**：**不要**修改任何文件。输出结构化分析报告。提供可选的补救计划（用户必须明确批准后才能手动调用任何后续编辑命令）。\n\n**宪章权威性**：项目宪章（`/memory/constitution.md`）在此分析范围内是**不可协商的**。宪章冲突自动为关键级别，需要调整规格、计划或任务——而不是稀释、重新解释或默默忽略原则。如果原则本身需要更改，必须在 `/speckit.analyze` 之外的单独、明确的宪章更新中进行。\n\n## 执行步骤\n\n### 1. 初始化分析上下文\n\n从仓库根目录运行一次 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。推导绝对路径：\n\n- SPEC = FEATURE_DIR/spec.md\n- PLAN = FEATURE_DIR/plan.md\n- TASKS = FEATURE_DIR/tasks.md\n\n如果缺少任何必需文件，则中止并显示错误消息（指示用户运行缺少的先决条件命令）。\n对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n### 2. 加载工件（渐进式披露）\n\n仅加载每个工件的最小必要上下文：\n\n**来自 spec.md：**\n\n- 概述/上下文\n- 功能要求\n- 非功能要求\n- 用户故事\n- 边缘情况（如果存在）\n\n**来自 plan.md：**\n\n- 架构/技术栈选择\n- 数据模型引用\n- 阶段\n- 技术约束\n\n**来自 tasks.md：**\n\n- 任务 ID\n- 描述\n- 阶段分组\n- 并行标记 [P]\n- 引用的文件路径\n\n**来自 constitution：**\n\n- 加载 `/memory/constitution.md` 用于原则验证\n\n### 3. 构建语义模型\n\n创建内部表示（不要在输出中包含原始工件）：\n\n- **要求清单**：每个功能+非功能要求带有一个稳定键（根据祈使句派生 slug；例如，\"用户可以上传文件\" → `user-can-upload-file`）\n- **用户故事/动作清单**：具有验收标准的离散用户动作\n- **任务覆盖映射**：将每个任务映射到一个或多个要求或故事（通过关键词/显式引用模式如 ID 或关键词进行推断）\n- **宪章规则集**：提取原则名称和 MUST/SHOULD 规范性陈述\n\n### 4. 检测过程（高效令牌分析）\n\n专注于高信号发现。限制总数为 50 个发现；在溢出摘要中聚合其余发现。\n\n#### A. 重复检测\n\n- 识别近似重复的要求\n- 标记质量较低的措辞以进行合并\n\n#### B. 歧义检测\n\n- 标记缺乏可测量标准的模糊形容词（快速、可扩展、安全、直观、健壮）\n- 标记未解决的占位符（TODO、TKTK、???、`<placeholder>` 等）\n\n#### C. 未充分说明\n\n- 有动词但缺少对象或可测量结果的要求\n- 缺少验收标准对齐的用户故事\n- 引用在规格/计划中未定义的文件或组件的任务\n\n#### D. 宪章对齐\n\n- 任何与 MUST 原则冲突的要求或计划元素\n- 缺少宪章中规定的章节或质量门\n\n#### E. 覆盖差距\n\n- 没有关联任务的要求\n- 没有映射要求/故事的任务\n- 未在任务中体现的非功能要求（例如，性能、安全性）\n\n#### F. 不一致\n\n- 术语漂移（同一概念在不同文件中有不同名称）\n- 计划中引用但在规格中缺失的数据实体（反之亦然）\n- 任务排序矛盾（例如，集成任务在基础设置任务之前但没有依赖注释）\n- 冲突的要求（例如，一个要求 Next.js 而另一个指定 Vue）\n\n### 5. 严重性分配\n\n使用此启发式方法来优先处理发现：\n\n- **关键**：违反宪章 MUST、缺少核心规格工件，或阻塞基本功能的零覆盖要求\n- **高**：重复或冲突的要求、模糊的安全/性能属性、不可测试的验收标准\n- **中**：术语漂移、缺少非功能任务覆盖、未充分说明的边缘情况\n- **低**：样式/措辞改进、不影响执行顺序的次要冗余\n\n### 6. 生成紧凑分析报告\n\n输出一个 Markdown 报告（不写入文件）具有以下结构：\n\n## 规格分析报告\n\n| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |\n|----|----------|----------|-------------|---------|----------------|\n| A1 | 重复 | 高 | spec.md:L120-134 | 两个相似的要求 ... | 合并措辞；保留更清晰的版本 |\n\n（每项发现添加一行；生成以类别首字母为前缀的稳定 ID。）\n\n**覆盖摘要表：**\n\n| 要求键 | 有任务？ | 任务 ID | 备注 |\n|-----------------|-----------|----------|-------|\n\n**宪章对齐问题：**（如果有）\n\n**未映射的任务：**（如果有）\n\n**指标：**\n\n- 总要求\n- 总任务\n- 覆盖率%（有>=1个任务的要求）\n- 歧义计数\n- 重复计数\n- 关键问题计数\n\n### 7. 提供下一步行动\n\n在报告末尾，输出一个简洁的下一步行动块：\n\n- 如果存在关键问题：建议在 `/speckit.implement` 之前解决\n- 如果只有低/中等：用户可以继续，但提供改进建议\n- 提供明确的命令建议：例如，\"使用改进运行 /speckit.specify\"，\"运行 /speckit.plan 调整架构\"，\"手动编辑 tasks.md 添加 'performance-metrics' 的覆盖\"\n\n### 8. 提供补救措施\n\n询问用户：\"您希望我为前 N 个问题建议具体的补救编辑吗？\"（不要自动应用它们。）\n\n## 操作原则\n\n### 上下文效率\n\n- **最小高信号令牌**：专注于可操作的发现，而不是详尽的文档\n- **渐进式披露**：增量加载工件；不要将所有内容倒入分析\n- **高效令牌输出**：限制发现表为 50 行；总结溢出\n- **确定性结果**：在没有更改的情况下重新运行应产生一致的 ID 和计数\n\n### 分析指南\n\n- **永不修改文件**（这是只读分析）\n- **永不虚构缺失部分**（如果缺失，准确报告）\n- **优先处理宪章违规**（这些总是关键的）\n- **使用示例而非详尽规则**（引用具体实例，而非通用模式）\n- **优雅报告零问题**（发出带有覆盖统计的成功报告）\n\n## 上下文\n\n{ARGS}",
        "skills/speckit-constitution-zh/assets/specify/templates/commands/checklist.md": "---\ndescription: 根据用户要求为当前功能生成自定义检查表。\nscripts:\n  sh: scripts/bash/check-prerequisites.sh --json\n  ps: scripts/powershell/check-prerequisites.ps1 -Json\n---\n\n## 检查表目的：\"中文的单元测试\"\n\n**关键概念**：检查表是**要求编写的单元测试** - 它们验证特定领域中要求的质量、清晰度和完整性。\n\n**不用于验证/测试**：\n\n- ❌ 不是\"验证按钮正确点击\"\n- ❌ 不是\"测试错误处理是否有效\"\n- ❌ 不是\"确认 API 返回 200\"\n- ❌ 不是检查代码/实现是否符合规格\n\n**用于要求质量验证**：\n\n- ✅ \"是否为所有卡片类型定义了视觉层次要求？\"（完整性）\n- ✅ \"是否用特定的尺寸/定位量化了'显著显示'？\"（清晰度）\n- ✅ \"所有交互元素的悬停状态要求是否一致？\"（一致性）\n- ✅ \"是否为键盘导航定义了可访问性要求？\"（覆盖范围）\n- ✅ \"规格是否定义了徽标图像加载失败时的情况？\"（边缘情况）\n\n**比喻**：如果您的规格是用英语编写的代码，那么检查表就是它的单元测试套件。您正在测试要求是否编写良好、完整、明确并准备好实施 - 而不是测试实现是否有效。\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 执行步骤\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS 列表。\n   - 所有文件路径必须是绝对的。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **澄清意图（动态）**：推导出最多三个初始上下文澄清问题（无预设目录）。它们必须：\n   - 从用户的措辞 + 从规格/计划/任务中提取的信号生成\n   - 仅询问会实质性改变检查表内容的信息\n   - 如果在 `$ARGUMENTS` 中已经明确，则单独跳过\n   - 优先考虑精确性而非广度\n\n   生成算法：\n   1. 提取信号：功能领域关键词（例如，auth, latency, UX, API），风险指标（\"critical\", \"must\", \"compliance\"），利益相关者提示（\"QA\", \"review\", \"security team\"）和明确的交付物（\"a11y\", \"rollback\", \"contracts\"）。\n   2. 将信号聚类到候选关注领域（最多 4 个）按相关性排序。\n   3. 识别可能的受众和时机（作者、审阅者、QA、发布）如果不明确。\n   4. 检测缺失的维度：范围广度、深度/严谨性、风险重点、排除边界、可测量的验收标准。\n   5. 从这些原型中制定问题：\n      - 范围细化（例如，\"这应该包括与 X 和 Y 的集成接触点还是仅限于本地模块正确性？\"）\n      - 风险优先级（例如，\"这些潜在风险领域中哪些应该接受强制门控检查？\"）\n      - 深度校准（例如，\"这是一个轻量级的预提交健全性列表还是正式的发布门？\"）\n      - 受众框架（例如，\"这将仅由作者使用还是在 PR 审阅期间由同行使用？\"）\n      - 边界排除（例如，\"我们应该明确排除本轮的性能调优项目吗？\"）\n      - 场景类别差距（例如，\"未检测到恢复流程——回滚/部分故障路径是否在范围内？\"）\n\n   问题格式规则：\n   - 如果提供选项，生成一个紧凑的表格，列：选项 | 候选 | 重要性原因\n   - 限制最多 A-E 个选项；如果自由形式答案更清晰则省略表格\n   - 永远不要要求用户重述他们已经说过的话\n   - 避免推测性类别（无幻觉）。如果不确定，明确询问：\"确认 X 是否在范围内。\"\n\n   无法交互时的默认值：\n   - 深度：标准\n   - 受众：如果与代码相关则为审阅者（PR）；否则为作者\n   - 关注：前 2 个相关性聚类\n\n   输出问题（标记 Q1/Q2/Q3）。回答后：如果≥2 个场景类别（替代/异常/恢复/非功能性领域）仍不清楚，您可以要求最多两个更有针对性的后续问题（Q4/Q5），每个问题附带一行理由（例如，\"未解决的恢复路径风险\"）。不要超过五个总问题。如果用户明确拒绝更多问题则跳过升级。\n\n3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清答案：\n   - 推导检查表主题（例如，安全、审阅、部署、用户体验）\n   - 整合用户提到的明确必备项目\n   - 将焦点选择映射到类别脚手架\n   - 从规格/计划/任务中推断任何缺失的上下文（不要幻觉）\n\n4. **加载功能上下文**：从 FEATURE_DIR 读取：\n   - spec.md：功能要求和范围\n   - plan.md（如果存在）：技术细节、依赖关系\n   - tasks.md（如果存在）：实施任务\n\n   **上下文加载策略**：\n   - 仅加载与活跃关注领域相关的必要部分（避免完整文件转储）\n   - 更喜欢将长段落总结为简洁的场景/要求要点\n   - 使用渐进式披露：仅在检测到差距时添加后续检索\n   - 如果源文档很大，生成中间摘要项目而不是嵌入原始文本\n\n5. **生成检查表** - 创建\"要求的单元测试\"：\n   - 如果不存在则创建 `FEATURE_DIR/checklists/` 目录\n   - 生成唯一的检查表文件名：\n     - 使用基于领域的简短描述性名称（例如，`ux.md`, `api.md`, `security.md`）\n     - 格式：`[domain].md`\n     - 如果文件存在，则追加到现有文件\n   - 从 CHK001 开始顺序编号项目\n   - 每个 `/speckit.checklist` 运行创建一个新文件（从不覆盖现有检查表）\n\n   **核心原则 - 测试要求，而不是实现**：\n   每个检查表项目必须评估要求本身：\n   - **完整性**：所有必要的要求是否存在？\n   - **清晰度**：要求是否明确且具体？\n   - **一致性**：要求是否相互对齐？\n   - **可测量性**：要求是否可以客观验证？\n   - **覆盖范围**：是否解决了所有场景/边缘情况？\n\n   **类别结构** - 按要求质量维度分组项目：\n   - **要求完整性**（是否记录了所有必要的要求？）\n   - **要求清晰度**（要求是否具体且明确？）\n   - **要求一致性**（要求是否对齐而无冲突？）\n   - **验收标准质量**（成功标准是否可测量？）\n   - **场景覆盖**（是否解决了所有流程/案例？）\n   - **边缘情况覆盖**（是否定义了边界条件？）\n   - **非功能性要求**（性能、安全性、可访问性等 - 是否指定？）\n   - **依赖关系和假设**（是否记录和验证？）\n   - **歧义和冲突**（需要澄清什么？）\n\n   **如何编写检查表项目 - \"英语的单元测试\"**：\n\n   ❌ **错误**（测试实现）：\n   - \"验证着陆页显示 3 个剧集卡片\"\n   - \"测试桌面端悬停状态是否有效\"\n   - \"确认徽标点击导航到主页\"\n\n   ✅ **正确**（测试要求质量）：\n   - \"是否明确指定了特色剧集的确切数量和布局？\" [完整性]\n   - \"是否用特定的尺寸/定位量化了'显著显示'？\" [清晰度]\n   - \"所有交互元素的悬停状态要求是否一致？\" [一致性]\n   - \"是否为所有交互式 UI 定义了键盘导航要求？\" [覆盖范围]\n   - \"当徽标图像加载失败时是否指定了回退行为？\" [边缘情况]\n   - \"是否为异步剧集数据定义了加载状态？\" [完整性]\n   - \"规格是否定义了竞争 UI 元素的视觉层次？\" [清晰度]\n\n   **项目结构**：\n   每个项目应遵循此模式：\n   - 询问要求质量的问题格式\n   - 关注规格/计划中编写（或未编写）的内容\n   - 包括质量维度在括号中 [完整性/清晰度/一致性等]\n   - 检查现有要求时引用规格部分 `[Spec §X.Y]`\n   - 使用 `[Gap]` 标记检查缺失的要求\n\n   **按质量维度的示例**：\n\n   完整性：\n   - \"是否为所有 API 故障模式定义了错误处理要求？ [Gap]\"\n   - \"是否为所有交互元素指定了可访问性要求？ [完整性]\"\n   - \"是否为响应式布局定义了移动断点要求？ [Gap]\"\n\n   清晰度：\n   - \"是否用特定的时间阈值量化了'快速加载'？ [清晰度, Spec §NFR-2]\"\n   - \"是否明确定义了'相关剧集'的选择标准？ [清晰度, Spec §FR-5]\"\n   - \"是否用可测量的视觉属性定义了'显著'？ [歧义, Spec §FR-4]\"\n\n   一致性：\n   - \"所有页面的导航要求是否对齐？ [一致性, Spec §FR-10]\"\n   - \"着陆页和详情页的卡片组件要求是否一致？ [一致性]\"\n\n   覆盖范围：\n   - \"是否为零状态场景（无剧集）定义了要求？ [覆盖范围, 边缘情况]\"\n   - \"是否解决了并发用户交互场景？ [覆盖范围, Gap]\"\n   - \"是否为部分数据加载失败指定了要求？ [覆盖范围, 异常流程]\"\n\n   可测量性：\n   - \"视觉层次要求是否可测量/可测试？ [验收标准, Spec §FR-1]\"\n   - \"是否可以客观验证'平衡的视觉权重'？ [可测量性, Spec §FR-2]\"\n\n   **场景分类和覆盖**（要求质量重点）：\n   - 检查是否存在要求：主要、替代、异常/错误、恢复、非功能性场景\n   - 对于每个场景类别，询问：\"[场景类型] 要求是否完整、清晰且一致？\"\n   - 如果场景类别缺失：\"[场景类型] 要求是故意排除还是缺失？ [Gap]\"\n   - 包括状态变更时的弹性/回滚：\"是否为迁移失败定义了回滚要求？ [Gap]\"\n\n   **可追溯性要求**：\n   - 最低要求：≥80% 的项目必须至少包含一个可追溯性引用\n   - 每个项目应引用：规格部分 `[Spec §X.Y]`，或使用标记：`[Gap]`、`[Ambiguity]`、`[Conflict]`、`[Assumption]`\n   - 如果不存在 ID 系统：\"是否建立了要求和验收标准 ID 方案？ [可追溯性]\"\n\n   **表面和解决问题**（要求质量问题）：\n   询问有关要求本身的问题：\n   - 歧义：\"'快速' 一词是否用具体指标量化？ [歧义, Spec §NFR-1]\"\n   - 冲突：\"§FR-10 和 §FR-10a 中的导航要求是否冲突？ [冲突]\"\n   - 假设：\"'始终可用的播客 API' 假设是否已验证？ [假设]\"\n   - 依赖关系：\"是否记录了外部播客 API 要求？ [依赖关系, Gap]\"\n   - 缺失定义：\"是否用可测量的标准定义了'视觉层次'？ [Gap]\"\n\n   **内容整合**：\n   - 软上限：如果原始候选项目 > 40，按风险/影响优先排序\n   - 合并检查相同要求方面的近似重复项\n   - 如果 >5 个低影响边缘情况，创建一个项目：\"边缘情况 X、Y、Z 是否在要求中解决？ [覆盖范围]\"\n\n   **🚫 绝对禁止** - 这些使其成为实现测试，而不是要求测试：\n   - ❌ 任何以\"验证\"、\"测试\"、\"确认\"、\"检查\" + 实现行为开头的项目\n   - ❌ 引用代码执行、用户操作、系统行为\n   - ❌ \"正确显示\"、\"正常工作\"、\"按预期功能\"\n   - ❌ \"点击\"、\"导航\"、\"渲染\"、\"加载\"、\"执行\"\n   - ❌ 测试用例、测试计划、QA 程序\n   - ❌ 实现细节（框架、API、算法）\n\n   **✅ 必需模式** - 这些测试要求质量：\n   - ✅ \"是否为 [场景] 定义/指定/记录了 [要求类型]？\"\n   - ✅ \"是否用具体标准量化/澄清了 [模糊术语]？\"\n   - ✅ \"[部分 A] 和 [部分 B] 的要求是否一致？\"\n   - ✅ \"是否可以客观测量/验证 [要求]？\"\n   - ✅ \"要求中是否解决了 [边缘情况/场景]？\"\n   - ✅ \"规格是否定义了 [缺失方面]？\"\n\n6. **结构参考**：按照 `templates/checklist-template.md` 中的规范模板生成检查表，包括标题、元部分、类别标题和 ID 格式。如果模板不可用，使用：H1 标题、目的/创建的元行、包含 `- [ ] CHK### <要求项目>` 行的 `##` 类别部分，全局递增 ID 从 CHK001 开始。\n\n7. **报告**：输出创建的检查表的完整路径、项目计数，并提醒用户每次运行都会创建一个新文件。总结：\n   - 选择的关注领域\n   - 深度级别\n   - 参与者/时机\n   - 任何包含的用户明确指定的必备项目\n\n**重要**：每个 `/speckit.checklist` 命令调用都使用简短的描述性名称创建检查表文件，除非文件已存在。这允许：\n\n- 不同类型的多个检查表（例如，`ux.md`, `test.md`, `security.md`）\n- 简单、易记的文件名，指示检查表目的\n- 在 `checklists/` 文件夹中轻松识别和导航\n\n为避免混乱，使用描述性类型并在完成后清理过时的检查表。\n\n## 示例检查表类型和示例项目\n\n**用户体验要求质量：** `ux.md`\n\n示例项目（测试要求，而不是实现）：\n\n- \"是否用可测量的标准定义了视觉层次要求？ [清晰度, Spec §FR-1]\"\n- \"是否明确定义了 UI 元素的数量和定位？ [完整性, Spec §FR-1]\"\n- \"交互状态要求（悬停、焦点、活动）是否一致定义？ [一致性]\"\n- \"是否为所有交互元素指定了可访问性要求？ [覆盖范围, Gap]\"\n- \"图像加载失败时是否定义了回退行为？ [边缘情况, Gap]\"\n- \"是否可以客观测量'显著显示'？ [可测量性, Spec §FR-4]\"\n\n**API 要求质量：** `api.md`\n\n示例项目：\n\n- \"是否为所有故障场景指定了错误响应格式？ [完整性]\"\n- \"是否用具体阈值量化了速率限制要求？ [清晰度]\"\n- \"所有端点的身份验证要求是否一致？ [一致性]\"\n- \"是否为外部依赖关系定义了重试/超时要求？ [覆盖范围, Gap]\"\n- \"版本控制策略是否在要求中记录？ [Gap]\"\n\n**性能要求质量：** `performance.md`\n\n示例项目：\n\n- \"是否用具体指标量化了性能要求？ [清晰度]\"\n- \"是否为所有关键用户旅程定义了性能目标？ [覆盖范围]\"\n- \"是否为不同负载条件指定了性能要求？ [完整性]\"\n- \"是否可以客观测量性能要求？ [可测量性]\"\n- \"是否为高负载场景定义了降级要求？ [边缘情况, Gap]\"\n\n**安全要求质量：** `security.md`\n\n示例项目：\n\n- \"是否为所有受保护资源指定了身份验证要求？ [覆盖范围]\"\n- \"是否为敏感信息定义了数据保护要求？ [完整性]\"\n- \"威胁模型是否记录并与要求对齐？ [可追溯性]\"\n- \"安全要求是否与合规义务一致？ [一致性]\"\n- \"是否定义了安全故障/违规响应要求？ [Gap, 异常流程]\"\n\n## 反例：不要做的事情\n\n**❌ 错误 - 这些测试实现，而不是要求：**\n\n```markdown\n- [ ] CHK001 - 验证着陆页显示 3 个剧集卡片 [Spec §FR-001]\n- [ ] CHK002 - 测试桌面端悬停状态是否正确工作 [Spec §FR-003]\n- [ ] CHK003 - 确认徽标点击导航到主页 [Spec §FR-010]\n- [ ] CHK004 - 检查相关剧集部分显示 3-5 个项目 [Spec §FR-005]\n```\n\n**✅ 正确 - 这些测试要求质量：**\n\n```markdown\n- [ ] CHK001 - 是否明确定义了特色剧集的数量和布局？ [完整性, Spec §FR-001]\n- [ ] CHK002 - 是否为所有交互元素一致定义了悬停状态要求？ [一致性, Spec §FR-003]\n- [ ] CHK003 - 是否为所有可点击品牌元素明确了导航要求？ [清晰度, Spec §FR-010]\n- [ ] CHK004 - 是否记录了相关剧集的选择标准？ [Gap, Spec §FR-005]\n- [ ] CHK005 - 是否为异步剧集数据定义了加载状态要求？ [Gap]\n- [ ] CHK006 - 是否可以客观测量\"视觉层次\"要求？ [可测量性, Spec §FR-001]\n```\n\n**主要区别：**\n\n- 错误：测试系统是否正常工作\n- 正确：测试要求是否编写正确\n- 错误：行为验证\n- 正确：要求质量验证\n- 错误：\"它是否做 X？\"\n- 正确：\"X 是否明确定义？\"",
        "skills/speckit-constitution-zh/assets/specify/templates/commands/clarify.md": "---\ndescription: 通过提出最多 5 个高度针对性的澄清问题并将其答案编码回规格中，识别当前功能规格中未充分说明的领域。\nscripts:\n   sh: scripts/bash/check-prerequisites.sh --json --paths-only\n   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n目标：检测并减少活动功能规格中的歧义或缺失决策点，并将澄清直接记录在规格文件中。\n\n注意：此澄清工作流程预计在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确表示他们正在跳过澄清（例如，探索性刺探），您可以继续，但必须警告下游返工风险会增加。\n\n执行步骤：\n\n1. 从仓库根目录运行一次 `{SCRIPT}`（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON 负载字段：\n   - `FEATURE_DIR`\n   - `FEATURE_SPEC`\n   - （可选捕获 `IMPL_PLAN`, `TASKS` 用于未来的链式流程。）\n   - 如果 JSON 解析失败，则中止并指示用户重新运行 `/speckit.specify` 或验证功能分支环境。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. 加载当前规格文件。使用此分类法执行结构化歧义和覆盖扫描。对于每个类别，标记状态：清晰 / 部分 / 缺失。生成用于优先级排序的内部覆盖图（除非不问问题，否则不要输出原始图）。\n\n   功能范围和行为：\n   - 核心用户目标和成功标准\n   - 明确的范围外声明\n   - 用户角色 / 人物区分\n\n   领域和数据模型：\n   - 实体、属性、关系\n   - 身份和唯一性规则\n   - 生命周期/状态转换\n   - 数据量 / 规模假设\n\n   交互和用户体验流程：\n   - 关键用户旅程 / 序列\n   - 错误/空/加载状态\n   - 可访问性或本地化注释\n\n   非功能性质量属性：\n   - 性能（延迟、吞吐量目标）\n   - 可扩展性（水平/垂直、限制）\n   - 可靠性和可用性（正常运行时间、恢复期望）\n   - 可观察性（日志、指标、跟踪信号）\n   - 安全性和隐私（认证/授权、数据保护、威胁假设）\n   - 合规性 / 监管约束（如果有）\n\n   集成和外部依赖：\n   - 外部服务/API 和故障模式\n   - 数据导入/导出格式\n   - 协议/版本假设\n\n   边缘情况和故障处理：\n   - 负面场景\n   - 速率限制 / 节流\n   - 冲突解决（例如，并发编辑）\n\n   约束和权衡：\n   - 技术约束（语言、存储、托管）\n   - 明确的权衡或被拒绝的替代方案\n\n   术语和一致性：\n   - 规范术语表\n   - 避免的同义词 / 废弃术语\n\n   完成信号：\n   - 验收标准可测试性\n   - 可测量的完成定义风格指标\n\n   杂项 / 占位符：\n   - TODO 标记 / 未解决的决策\n   - 缺乏量化的模糊形容词（\"健壮的\"、\"直观的\"）\n\n   对于状态为部分或缺失的每个类别，添加一个候选问题机会，除非：\n   - 澄清不会实质性改变实施或验证策略\n   - 信息最好推迟到规划阶段（内部记录）\n\n3. 生成（内部）优先级候选澄清问题队列（最多 5 个）。不要一次性输出所有问题。应用这些约束：\n    - 整个会话最多 10 个问题。\n    - 每个问题必须可以通过以下方式回答：\n       - 短的多项选择（2-5 个不同的、互斥的选项），或\n       - 一个单词 / 短语答案（明确约束：\"答案 <=5 个单词\"）。\n    - 仅包括其答案实质性影响架构、数据建模、任务分解、测试设计、用户体验行为、运营准备或合规性验证的问题。\n    - 确保类别覆盖平衡：尝试首先覆盖最高影响的未解决类别；避免在单个高影响领域（例如，安全态势）未解决时问两个低影响问题。\n    - 排除已经回答的问题、琐碎的风格偏好或计划级执行细节（除非阻塞正确性）。\n    - 优先考虑减少下游返工风险或防止不一致验收测试的澄清。\n    - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。\n\n4. 顺序提问循环（交互式）：\n    - 一次只提出一个问题。\n    - 对于多项选择问题：\n       - **分析所有选项**并根据以下确定**最合适的选项**：\n          - 项目类型的最佳实践\n          - 类似实现中的常见模式\n          - 风险降低（安全性、性能、可维护性）\n          - 与规格中可见的任何明确项目目标或约束对齐\n       - 突出显示您的**推荐选项**在顶部，并提供明确的理由（1-2 句解释为什么这是最佳选择）。\n       - 格式为：`**推荐：** 选项 [X] - <理由>`\n       - 然后将所有选项呈现为 Markdown 表格：\n\n       | 选项 | 描述 |\n       |--------|-------------|\n       | A | <选项 A 描述> |\n       | B | <选项 B 描述> |\n       | C | <选项 C 描述>（根据需要添加 D/E 至多 5 个） |\n       | 简短 | 提供不同的简短答案（<=5 个单词）（仅在自由形式替代方案适当时包含） |\n\n       - 表格后添加：`您可以回复选项字母（例如，\"A\"），通过说\"yes\"或\"recommended\"接受推荐，或提供您自己的简短答案。`\n    - 对于简短答案风格（无有意义的离散选项）：\n       - 提供您的**建议答案**基于最佳实践和上下文。\n       - 格式为：`**建议：** <您的建议答案> - <简要理由>`\n       - 然后输出：`格式：简短答案（<=5 个单词）。您可以通过说\"yes\"或\"suggested\"接受建议，或提供您自己的答案。`\n    - 用户回答后：\n       - 如果用户回复\"yes\"、\"recommended\"或\"suggested\"，使用您之前声明的推荐/建议作为答案。\n       - 否则，验证答案映射到一个选项或符合 <=5 个单词的约束。\n       - 如果模糊，要求快速澄清（计数仍属于同一问题；不要前进）。\n       - 一旦满意，将其记录在工作内存中（尚不写入磁盘）并移至下一个排队问题。\n    - 停止进一步提问当：\n       - 所有关键歧义提前解决（剩余排队项目变得不必要），或\n       - 用户发出完成信号（\"done\"、\"good\"、\"no more\"），或\n       - 您达到 5 个已问问题。\n    - 永远不要提前透露未来排队的问题。\n    - 如果开始时没有有效问题，立即报告没有关键歧义。\n\n5. 每个接受答案后的集成（增量更新方法）：\n    - 维护规格的内存表示（启动时加载一次）加上原始文件内容。\n    - 对于此会话中的第一个集成答案：\n       - 确保存在 `## Clarifications` 部分（如果缺失，则在规格模板中最高级上下文/概述部分之后创建）。\n       - 在其下创建（如果不存在）一个 `### Session YYYY-MM-DD` 子标题用于今天。\n    - 接受后立即追加一个项目符号行：`- Q: <问题> → A: <最终答案>`。\n    - 然后立即将澄清应用到最合适的部分：\n       - 功能歧义 → 更新或在功能要求中添加项目符号。\n       - 用户交互 / 行为者区分 → 更新用户故事或行为者子部分（如果存在）与澄清的角色、约束或场景。\n       - 数据形状 / 实体 → 更新数据模型（添加字段、类型、关系）保持排序；简洁地记录添加的约束。\n       - 非功能性约束 → 在非功能性 / 质量属性部分添加/修改可测量标准（将模糊形容词转换为指标或明确目标）。\n       - 边缘情况 / 负面流程 → 在边缘情况 / 错误处理下添加新项目符号（或创建此类子部分如果模板提供占位符）。\n       - 术语冲突 → 规范化整个规格中的术语；仅在必要时保留原始术语，添加`(以前称为\"X\")`一次。\n    - 如果澄清使早期模糊声明无效，则替换该声明而不是重复；不留过时的矛盾文本。\n    - 每次集成后保存规格文件以最小化上下文丢失风险（原子覆盖）。\n    - 保持格式：不要重新排序无关部分；保持标题层次结构完整。\n    - 保持每个插入的澄清最小且可测试（避免叙述性漂移）。\n\n6. 验证（每次写入后执行加上最终通过）：\n   - 澄清会话包含每个接受答案的一个项目符号（无重复）。\n   - 总问（接受）问题 ≤ 5。\n   - 更新部分不包含新的答案应该解决的模糊占位符。\n   - 无矛盾的早期声明保留（扫描移除的无效替代选择）。\n   - Markdown 结构有效；仅允许新标题：`## Clarifications`, `### Session YYYY-MM-DD`。\n   - 术语一致性：所有更新部分使用相同的规范术语。\n\n7. 将更新的规格写回 `FEATURE_SPEC`。\n\n8. 报告完成（提问循环结束或提前终止后）：\n   - 问和回答的问题数量。\n   - 更新规格的路径。\n   - 触及的部分（列出名称）。\n   - 覆盖摘要表列出每个分类类别，状态：已解决（之前部分/缺失并已解决）、推迟（超出问题配额或更适合规划）、清晰（已足够）、未解决（仍部分/缺失但影响低）。\n   - 如果有任何未解决或推迟的，建议是否继续到 `/speckit.plan` 或稍后再次运行 `/speckit.clarify`。\n   - 建议的下一个命令。\n\n行为规则：\n\n- 如果未发现有意义的歧义（或所有潜在问题都是低影响的），回应：\"未检测到值得正式澄清的关键歧义。\"并建议继续。\n- 如果规格文件缺失，指示用户先运行 `/speckit.specify`（不要在此处创建新规格）。\n- 永远不要超过 5 个总问问题（澄清重试单个问题不计入新问题）。\n- 避免推测性技术栈问题，除非缺失会阻塞功能清晰度。\n- 尊重用户提前终止信号（\"stop\"、\"done\"、\"proceed\"）。\n- 如果由于完全覆盖而未问问题，输出紧凑的覆盖摘要（所有类别清晰）然后建议前进。\n- 如果配额达到但仍有未解决的高影响类别，明确标记它们为推迟并附上理由。\n\n优先级上下文：{ARGS}",
        "skills/speckit-constitution-zh/assets/specify/templates/commands/constitution.md": "---\ndescription: 根据交互式或提供的原则输入创建或更新项目宪章，确保所有依赖模板保持同步\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n您正在更新位于 `/memory/constitution.md` 的项目宪章。此文件是一个模板，包含方括号中的占位符标记（例如 `[PROJECT_NAME]`, `[PRINCIPLE_1_NAME]`）。您的工作是 (a) 收集/推导具体值，(b) 精确填充模板，以及 (c) 传播任何修订到依赖工件。\n\n遵循此执行流程：\n\n1. 加载位于 `/memory/constitution.md` 的现有宪章模板。\n   - 识别形式为 `[ALL_CAPS_IDENTIFIER]` 的每个占位符标记。\n   **重要**：用户可能需要比模板中使用的更少或更多的原则。如果指定了数量，请尊重 - 遵循通用模板。您将相应地更新文档。\n\n2. 收集/推导占位符的值：\n   - 如果用户输入（对话）提供了值，则使用它。\n   - 否则从现有仓库上下文（README、文档、先前的宪章版本（如果嵌入））推断。\n   - 对于治理日期：`RATIFICATION_DATE` 是原始采用日期（如果未知则询问或标记 TODO），`LAST_AMENDED_DATE` 是今天如果进行了更改，否则保持先前日期。\n   - `CONSTITUTION_VERSION` 必须根据语义版本规则递增：\n     - MAJOR：向后不兼容的治理/原则删除或重新定义。\n     - MINOR：添加新原则/部分或实质性扩展指导。\n     - PATCH：澄清、措辞、拼写错误修复、非语义性改进。\n   - 如果版本提升类型不明确，在最终确定前提出理由。\n\n3. 起草更新的宪章内容：\n   - 用具体文本替换每个占位符（除了项目选择尚未定义的故意保留的模板槽位 - 明确说明任何保留的槽位）。\n   - 保持标题层次结构，注释可以在替换后删除，除非它们仍然提供澄清指导。\n   - 确保每个原则部分：简洁的名称行，段落（或项目符号列表）捕获不可协商的规则，如果不是显而易见则提供明确的理由。\n   - 确保治理部分列出修订程序、版本政策和合规性审查期望。\n\n4. 一致性传播检查表（将先前的检查表转换为积极验证）：\n   - 读取 `/templates/plan-template.md` 并确保任何\"宪章检查\"或规则与更新的原则对齐。\n   - 读取 `/templates/spec-template.md` 以对齐范围/要求 - 如果宪章添加/删除了强制性部分或约束则更新。\n   - 读取 `/templates/tasks-template.md` 并确保任务分类反映新增或删除的原则驱动任务类型（例如，可观察性、版本控制、测试纪律）。\n   - 读取 `/templates/commands/*.md` 中的每个命令文件（包括此文件）以验证没有过时的引用（仅当需要通用指导时保留特定代理名称如 CLAUDE）。\n   - 读取任何运行时指导文档（例如，`README.md`, `docs/quickstart.md`，或特定代理指导文件（如果存在））。更新对更改原则的引用。\n\n5. 生成同步影响报告（在更新后作为 HTML 注释预置在宪章文件顶部）：\n   - 版本变更：旧 → 新\n   - 修改的原则列表（旧标题 → 新标题如果重命名）\n   - 添加的部分\n   - 删除的部分\n   - 需要更新的模板（✅ 已更新 / ⚠ 待处理）及文件路径\n   - 如果有任何占位符故意推迟则列出。\n\n6. 最终输出前的验证：\n   - 没有剩余的未解释括号标记。\n   - 版本行与报告匹配。\n   - 日期为 ISO 格式 YYYY-MM-DD。\n   - 原则是陈述性的、可测试的，并且没有模糊语言（\"应该\" → 在适当时替换为 MUST/SHOULD 理由）。\n\n7. 将完成的宪章写回 `/memory/constitution.md`（覆盖）。\n\n8. 向用户输出最终摘要：\n   - 新版本和提升理由。\n   - 任何标记为手动跟进的文件。\n   - 建议的提交消息（例如，`docs: 修订宪章至 vX.Y.Z（原则添加 + 治理更新）`）。\n\n格式和样式要求：\n\n- 完全按照模板中的 Markdown 标题使用（不要降级/升级级别）。\n- 包装长理由行以保持可读性（理想情况下 <100 个字符），但不要用尴尬的断行强制执行。\n- 在部分之间保持单个空行。\n- 避免尾随空格。\n\n如果用户提供部分更新（例如，仅一个原则修订），仍执行验证和版本决策步骤。\n\n如果关键信息缺失（例如，批准日期真正未知），插入 `TODO(<FIELD_NAME>): explanation` 并在同步影响报告的推迟项目下列出。\n\n不要创建新模板；始终在现有的 `/memory/constitution.md` 文件上操作。",
        "skills/speckit-constitution-zh/assets/specify/templates/commands/implement.md": "---\ndescription: 通过处理和执行 tasks.md 中定义的所有任务来执行实现计划\nscripts:\n  sh: scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks\n  ps: scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. 从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **检查检查表状态**（如果 FEATURE_DIR/checklists/ 存在）：\n   - 扫描 checklists/ 目录中的所有检查表文件\n   - 对于每个检查表，计数：\n     - 总项目：所有匹配 `- [ ]` 或 `- [X]` 或 `- [x]` 的行\n     - 完成项目：匹配 `- [X]` 或 `- [x]` 的行\n     - 未完成项目：匹配 `- [ ]` 的行\n   - 创建状态表：\n\n     ```text\n     | 检查表 | 总计 | 已完成 | 未完成 | 状态 |\n     |-----------|-------|-----------|------------|--------|\n     | ux.md     | 12    | 12        | 0          | ✓ 通过 |\n     | test.md   | 8     | 5         | 3          | ✗ 失败 |\n     | security.md | 6   | 6         | 0          | ✓ 通过 |\n     ```\n\n   - 计算总体状态：\n     - **通过**：所有检查表都有 0 个未完成项目\n     - **失败**：一个或多个检查表有未完成项目\n\n   - **如果有任何检查表未完成**：\n     - 显示包含未完成项目计数的表格\n     - **停止**并询问：\"一些检查表未完成。您是否仍要继续执行实现？(yes/no)\"\n     - 等待用户响应后再继续\n     - 如果用户说\"no\"或\"wait\"或\"stop\"，则停止执行\n     - 如果用户说\"yes\"或\"proceed\"或\"continue\"，则继续到步骤 3\n\n   - **如果所有检查表都完成**：\n     - 显示表格显示所有检查表已通过\n     - 自动继续到步骤 3\n\n3. 加载和分析实现上下文：\n   - **必需**：读取 tasks.md 以获取完整的任务列表和执行计划\n   - **必需**：读取 plan.md 以获取技术栈、架构和文件结构\n   - **如果存在**：读取 data-model.md 以获取实体和关系\n   - **如果存在**：读取 contracts/ 以获取 API 规范和测试要求\n   - **如果存在**：读取 research.md 以获取技术决策和约束\n   - **如果存在**：读取 quickstart.md 以获取集成场景\n\n4. **项目设置验证**：\n   - **必需**：根据实际项目设置创建/验证忽略文件：\n\n   **检测和创建逻辑**：\n   - 检查以下命令是否成功以确定仓库是否为 git 仓库（如果是则创建/验证 .gitignore）：\n\n     ```sh\n     git rev-parse --git-dir 2>/dev/null\n     ```\n\n   - 检查是否存在 Dockerfile* 或 Docker 在 plan.md 中 → 创建/验证 .dockerignore\n   - 检查是否存在 .eslintrc* 或 eslint.config.* → 创建/验证 .eslintignore\n   - 检查是否存在 .prettierrc* → 创建/验证 .prettierignore\n   - 检查是否存在 .npmrc 或 package.json → 创建/验证 .npmignore（如果发布）\n   - 检查是否存在 terraform 文件 (*.tf) → 创建/验证 .terraformignore\n   - 检查是否需要 .helmignore（存在 helm 图表）→ 创建/验证 .helmignore\n\n   **如果忽略文件已存在**：验证它包含基本模式，仅追加缺失的关键模式\n   **如果忽略文件缺失**：创建包含检测技术的完整模式集\n\n   **按技术的常见模式**（来自 plan.md 技术栈）：\n   - **Node.js/JavaScript/TypeScript**：`node_modules/`, `dist/`, `build/`, `*.log`, `.env*`\n   - **Python**：`__pycache__/`, `*.pyc`, `.venv/`, `venv/`, `dist/`, `*.egg-info/`\n   - **Java**：`target/`, `*.class`, `*.jar`, `.gradle/`, `build/`\n   - **C#/.NET**：`bin/`, `obj/`, `*.user`, `*.suo`, `packages/`\n   - **Go**：`*.exe`, `*.test`, `vendor/`, `*.out`\n   - **Ruby**：`.bundle/`, `log/`, `tmp/`, `*.gem`, `vendor/bundle/`\n   - **PHP**：`vendor/`, `*.log`, `*.cache`, `*.env`\n   - **Rust**：`target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`\n   - **Kotlin**：`build/`, `out/`, `.gradle/`, `.idea/`, `*.class`, `*.jar`, `*.iml`, `*.log`, `.env*`\n   - **C++**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.so`, `*.a`, `*.exe`, `*.dll`, `.idea/`, `*.log`, `.env*`\n   - **C**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.a`, `*.so`, `*.exe`, `Makefile`, `config.log`, `.idea/`, `*.log`, `.env*`\n   - **Swift**：`.build/`, `DerivedData/`, `*.swiftpm/`, `Packages/`\n   - **R**：`.Rproj.user/`, `.Rhistory`, `.RData`, `.Ruserdata`, `*.Rproj`, `packrat/`, `renv/`\n   - **通用**：`.DS_Store`, `Thumbs.db`, `*.tmp`, `*.swp`, `.vscode/`, `.idea/`\n\n   **工具特定模式**：\n   - **Docker**：`node_modules/`, `.git/`, `Dockerfile*`, `.dockerignore`, `*.log*`, `.env*`, `coverage/`\n   - **ESLint**：`node_modules/`, `dist/`, `build/`, `coverage/`, `*.min.js`\n   - **Prettier**：`node_modules/`, `dist/`, `build/`, `coverage/`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`\n   - **Terraform**：`.terraform/`, `*.tfstate*`, `*.tfvars`, `.terraform.lock.hcl`\n   - **Kubernetes/k8s**：`*.secret.yaml`, `secrets/`, `.kube/`, `kubeconfig*`, `*.key`, `*.crt`\n\n5. 解析 tasks.md 结构并提取：\n   - **任务阶段**：设置、测试、核心、集成、完善\n   - **任务依赖**：顺序与并行执行规则\n   - **任务详情**：ID、描述、文件路径、并行标记 [P]\n   - **执行流程**：顺序和依赖要求\n\n6. 按照任务计划执行实现：\n   - **阶段执行**：完成每个阶段后再进入下一个\n   - **尊重依赖**：按顺序运行顺序任务，并行任务 [P] 可以一起运行  \n   - **遵循 TDD 方法**：在相应的实现任务之前执行测试任务\n   - **基于文件的协调**：影响相同文件的任务必须顺序运行\n   - **验证检查点**：在继续之前验证每个阶段的完成情况\n\n7. 实现执行规则：\n   - **首先设置**：初始化项目结构、依赖、配置\n   - **测试优先于代码**：如果需要为契约、实体和集成场景编写测试\n   - **核心开发**：实现模型、服务、CLI 命令、端点\n   - **集成工作**：数据库连接、中间件、日志、外部服务\n   - **完善和验证**：单元测试、性能优化、文档\n\n8. 进度跟踪和错误处理：\n   - 在每个完成的任务后报告进度\n   - 如果任何非并行任务失败则停止执行\n   - 对于并行任务 [P]，继续执行成功的任务，报告失败的任务\n   - 提供清晰的错误消息和调试上下文\n   - 如果实现无法继续则建议下一步\n   - **重要** 对于完成的任务，确保在任务文件中标记为 [X]。\n\n9. 完成验证：\n   - 验证所有必需任务已完成\n   - 检查实现的功能是否与原始规格匹配\n   - 验证测试通过且覆盖率符合要求\n   - 确认实现遵循技术计划\n   - 报告最终状态和已完成工作的摘要\n\n注意：此命令假设 tasks.md 中存在完整的任务分解。如果任务不完整或缺失，建议首先运行 `/speckit.tasks` 以重新生成任务列表。",
        "skills/speckit-constitution-zh/assets/specify/templates/commands/plan.md": "---\ndescription: 使用计划模板执行实现规划工作流程以生成设计工件。\nscripts:\n  sh: scripts/bash/setup-plan.sh --json\n  ps: scripts/powershell/setup-plan.ps1 -Json\nagent_scripts:\n  sh: scripts/bash/update-agent-context.sh __AGENT__\n  ps: scripts/powershell/update-agent-context.ps1 -AgentType __AGENT__\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_SPEC, IMPL_PLAN, SPECS_DIR, BRANCH。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载上下文**：读取 FEATURE_SPEC 和 `/memory/constitution.md`。加载 IMPL_PLAN 模板（已复制）。\n\n3. **执行计划工作流程**：按照 IMPL_PLAN 模板中的结构：\n   - 填写技术上下文（将未知标记为\"需要澄清\"）\n   - 从宪章填写宪章检查部分\n   - 评估门（如果违规未经证明则报错）\n   - 阶段 0：生成 research.md（解决所有\"需要澄清\"）\n   - 阶段 1：生成 data-model.md, contracts/, quickstart.md\n   - 阶段 1：通过运行代理脚本更新代理上下文\n   - 设计后重新评估宪章检查\n\n4. **停止并报告**：命令在阶段 2 规划后结束。报告分支、IMPL_PLAN 路径和生成的工件。\n\n## 阶段\n\n### 阶段 0：大纲和研究\n\n1. **从上面的技术上下文中提取未知项**：\n   - 对于每个\"需要澄清\" → 研究任务\n   - 对于每个依赖项 → 最佳实践任务\n   - 对于每个集成 → 模式任务\n\n2. **生成和派遣研究代理**：\n\n   ```text\n   对于技术上下文中的每个未知项：\n     任务：\"研究 {未知项} 用于 {功能上下文}\"\n   对于每个技术选择：\n     任务：\"查找 {技术} 在 {领域} 中的最佳实践\"\n   ```\n\n3. **在 `research.md` 中整合发现**，使用格式：\n   - 决策：[选择了什么]\n   - 理由：[为什么选择]\n   - 考虑的替代方案：[评估了什么其他选项]\n\n**输出**：research.md，解决所有\"需要澄清\"\n\n### 阶段 1：设计和契约\n\n**先决条件**：`research.md` 完成\n\n1. **从功能规格中提取实体** → `data-model.md`：\n   - 实体名称、字段、关系\n   - 来自要求的验证规则\n   - 如适用的状态转换\n\n2. **从功能要求生成 API 契约**：\n   - 对于每个用户操作 → 端点\n   - 使用标准 REST/GraphQL 模式\n   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`\n\n3. **代理上下文更新**：\n   - 运行 `{AGENT_SCRIPT}`\n   - 这些脚本检测使用中的 AI 代理\n   - 更新适当的代理特定上下文文件\n   - 仅添加当前计划中的新技术\n   - 保留标记之间的手动添加\n\n**输出**：data-model.md, /contracts/*, quickstart.md, 代理特定文件\n\n## 关键规则\n\n- 使用绝对路径\n- 门失败或未解决的澄清时报错",
        "skills/speckit-constitution-zh/assets/specify/templates/commands/specify.md": "---\ndescription: 根据自然语言功能描述创建或更新功能规格。\nscripts:\n  sh: scripts/bash/create-new-feature.sh --json \"{ARGS}\"\n  ps: scripts/powershell/create-new-feature.ps1 -Json \"{ARGS}\"\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n用户在触发消息中输入 `/speckit.specify` 后的文本**就是**功能描述。假设您在此对话中始终可以使用它，即使下面出现 `{ARGS}` 字面意思。除非用户提供了空命令，否则不要要求用户重复。\n\n根据该功能描述，执行以下操作：\n\n1. **生成简洁的短名称**（2-4 个单词）用于分支：\n   - 分析功能描述并提取最有意义的关键词\n   - 创建一个 2-4 个单词的短名称，捕捉功能的本质\n   - 尽可能使用动作-名词格式（例如，\"add-user-auth\"，\"fix-payment-bug\"）\n   - 保留技术术语和缩写（OAuth2, API, JWT 等）\n   - 保持简洁但描述性足够，一眼就能理解功能\n   - 示例：\n     - \"我想添加用户认证\" → \"user-auth\"\n     - \"为 API 实现 OAuth2 集成\" → \"oauth2-api-integration\"\n     - \"创建分析仪表板\" → \"analytics-dashboard\"\n     - \"修复支付处理超时错误\" → \"fix-payment-timeout\"\n\n2. **在创建新分支前检查现有分支**：\n   \n   a. 首先，获取所有远程分支以确保我们有最新信息：\n      ```bash\n      git fetch --all --prune\n      ```\n   \n   b. 查找短名称的最高功能编号：\n      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`\n      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`\n      - 规格目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录\n   \n   c. 确定下一个可用编号：\n      - 从所有三个来源提取所有编号\n      - 找到最高编号 N\n      - 使用 N+1 作为新分支编号\n   \n   d. 使用计算出的编号和短名称运行脚本 `{SCRIPT}`：\n      - 传递 `--number N+1` 和 `--short-name \"your-short-name\"` 以及功能描述\n      - Bash 示例：`{SCRIPT} --json --number 5 --short-name \"user-auth\" \"添加用户认证\"`\n      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName \"user-auth\" \"添加用户认证\"`\n   \n   **重要**：\n   - 检查所有三个来源（远程分支、本地分支、规格目录）以找到最高编号\n   - 仅匹配具有确切短名称模式的分支/目录\n   - 如果未找到具有此短名称的现有分支/目录，则从编号 1 开始\n   - 每个功能只能运行此脚本一次\n   - JSON 在终端中作为输出提供 - 始终参考它以获取您要查找的实际内容\n   - JSON 输出将包含 BRANCH_NAME 和 SPEC_FILE 路径\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）\n\n3. 加载 `templates/spec-template.md` 以了解必需部分。\n\n4. 遵循此执行流程：\n\n    1. 从输入解析用户描述\n       如果为空：错误 \"未提供功能描述\"\n    2. 从描述中提取关键概念\n       识别：参与者、动作、数据、约束\n    3. 对于不清楚的方面：\n       - 基于上下文和行业标准做出有根据的猜测\n       - 仅在以下情况下标记 [需要澄清：具体问题]：\n         - 选择显著影响功能范围或用户体验\n         - 存在多种合理解释且有不同的含义\n         - 没有合理的默认值\n       - **限制：最多 3 个 [需要澄清] 标记**\n       - 按影响优先级排序：范围 > 安全/隐私 > 用户体验 > 技术细节\n    4. 填写用户场景和测试部分\n       如果没有明确的用户流程：错误 \"无法确定用户场景\"\n    5. 生成功能要求\n       每个要求必须可测试\n       为未指定的细节使用合理的默认值（在假设部分记录假设）\n    6. 定义成功标准\n       创建可测量的、技术无关的结果\n       包括定量指标（时间、性能、数量）和定性措施（用户满意度、任务完成）\n       每个标准必须在没有实现细节的情况下可验证\n    7. 识别关键实体（如果涉及数据）\n    8. 返回：成功（规格已准备好规划）\n\n5. 使用模板结构将规格写入 SPEC_FILE，将占位符替换为从功能描述（参数）中得出的具体细节，同时保持部分顺序和标题。\n\n6. **规格质量验证**：在编写初始规格后，根据质量标准进行验证：\n\n   a. **创建规格质量检查表**：在 `FEATURE_DIR/checklists/requirements.md` 生成检查表文件，使用检查表模板结构和这些验证项目：\n\n      ```markdown\n      # 规格质量检查表：[功能名称]\n      \n      **目的**：在继续规划之前验证规格完整性和质量\n      **创建时间**：[日期]\n      **功能**：[链接到 spec.md]\n      \n      ## 内容质量\n      \n      - [ ] 无实现细节（语言、框架、API）\n      - [ ] 专注于用户价值和业务需求\n      - [ ] 为非技术利益相关者编写\n      - [ ] 所有必需部分已完成\n      \n      ## 要求完整性\n      \n      - [ ] 无 [需要澄清] 标记\n      - [ ] 要求可测试且明确\n      - [ ] 成功标准可测量\n      - [ ] 成功标准技术无关（无实现细节）\n      - [ ] 所有验收场景已定义\n      - [ ] 边缘情况已识别\n      - [ ] 范围明确界定\n      - [ ] 依赖关系和假设已识别\n      \n      ## 功能准备度\n      \n      - [ ] 所有功能要求都有明确的验收标准\n      - [ ] 用户场景涵盖主要流程\n      - [ ] 功能满足成功标准中定义的可测量结果\n      - [ ] 无实现细节泄露到规格中\n      \n      ## 备注\n      \n      - 标记为不完整的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新规格\n      ```\n\n   b. **运行验证检查**：根据每个检查表项目审查规格：\n      - 对于每个项目，确定它是通过还是失败\n      - 记录发现的具体问题（引用相关规格部分）\n\n   c. **处理验证结果**：\n\n      - **如果所有项目都通过**：标记检查表完成并继续到步骤 6\n\n      - **如果项目失败（不包括 [需要澄清]）**：\n        1. 列出失败的项目和具体问题\n        2. 更新规格以解决每个问题\n        3. 重新运行验证直到所有项目通过（最多 3 次迭代）\n        4. 如果 3 次迭代后仍失败，将剩余问题记录在检查表备注中并警告用户\n\n      - **如果 [需要澄清] 标记仍然存在**：\n        1. 从规格中提取所有 [需要澄清：...] 标记\n        2. **限制检查**：如果标记超过 3 个，仅保留 3 个最关键（按范围/安全/用户体验影响）并为其余标记做出有根据的猜测\n        3. 对于每个需要的澄清（最多 3 个），以以下格式向用户呈现选项：\n\n           ```markdown\n           ## 问题 [N]：[主题]\n           \n           **上下文**：[引用相关规格部分]\n           \n           **我们需要知道**：[来自需要澄清标记的具体问题]\n           \n           **建议答案**：\n           \n           | 选项 | 答案 | 影响 |\n           |--------|--------|--------------|\n           | A      | [第一个建议答案] | [这对功能意味着什么] |\n           | B      | [第二个建议答案] | [这对功能意味着什么] |\n           | C      | [第三个建议答案] | [这对功能意味着什么] |\n           | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |\n           \n           **您的选择**：_[等待用户响应]_\n           ```\n\n        4. **关键 - 表格格式**：确保 markdown 表格格式正确：\n           - 使用一致的间距，管道对齐\n           - 每个单元格应有内容周围的空格：`| 内容 |` 而不是 `|内容|`\n           - 标题分隔符必须至少有 3 个破折号：`|--------|`\n           - 测试表格在 markdown 预览中正确渲染\n        5. 顺序编号问题（Q1, Q2, Q3 - 最多 3 个总计）\n        6. 在等待响应之前一起呈现所有问题\n        7. 等待用户响应他们对所有问题的选择（例如，\"Q1: A, Q2: 自定义 - [详情], Q3: B\"）\n        8. 通过将每个 [需要澄清] 标记替换为用户选择或提供的答案来更新规格\n        9. 在所有澄清解决后重新运行验证\n\n   d. **更新检查表**：在每次验证迭代后，使用当前通过/失败状态更新检查表文件\n\n7. 报告完成情况，包括分支名称、规格文件路径、检查表结果和下一阶段的准备情况（`/speckit.clarify` 或 `/speckit.plan`）。\n\n**注意**：脚本创建并检出新分支并在写入前初始化规格文件。\n\n## 一般指南\n\n## 快速指南\n\n- 专注于用户需要**什么**和**为什么**。\n- 避免如何实现（无技术栈、API、代码结构）。\n- 为业务利益相关者编写，而不是开发人员。\n- 不要创建嵌入在规格中的任何检查表。那将是单独的命令。\n\n### 部分要求\n\n- **必需部分**：每个功能必须完成\n- **可选部分**：仅在与功能相关时包含\n- 当部分不适用时，完全删除（不要留作\"N/A\"）\n\n### 对于 AI 生成\n\n从用户提示创建此规格时：\n\n1. **做出有根据的猜测**：使用上下文、行业标准和常见模式填补空白\n2. **记录假设**：在假设部分记录合理的默认值\n3. **限制澄清**：最多 3 个 [需要澄清] 标记 - 仅用于关键决策：\n   - 显著影响功能范围或用户体验\n   - 有多种合理解释且有不同的含义\n   - 没有合理的默认值\n4. **优先级澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节\n5. **像测试人员一样思考**：每个模糊要求都应无法通过\"可测试和明确\"检查表项目\n6. **需要澄清的常见领域**（如果没有合理的默认值）：\n   - 功能范围和边界（包括/排除特定用例）\n   - 用户类型和权限（如果存在多个冲突解释）\n   - 安全/合规要求（当法律/财务重要时）\n\n**合理默认值示例**（不要询问这些）：\n\n- 数据保留：该领域的行业标准实践\n- 性能目标：标准网络/移动应用期望（除非指定）\n- 错误处理：用户友好的消息和适当的回退\n- 认证方法：标准基于会话或 OAuth2 用于 Web 应用\n- 集成模式：RESTful API（除非另有说明）\n\n### 成功标准指南\n\n成功标准必须：\n\n1. **可测量**：包括具体指标（时间、百分比、数量、比率）\n2. **技术无关**：不提及框架、语言、数据库或工具\n3. **用户导向**：从用户/业务角度描述结果，而不是系统内部\n4. **可验证**：可以在不知道实现细节的情况下测试/验证\n\n**好示例**：\n\n- \"用户可以在 3 分钟内完成结账\"\n- \"系统支持 10,000 个并发用户\"\n- \"95% 的搜索在 1 秒内返回结果\"\n- \"任务完成率提高 40%\"\n\n**坏示例**（实现导向）：\n\n- \"API 响应时间低于 200ms\"（太技术性，使用\"用户立即看到结果\"）\n- \"数据库可以处理 1000 TPS\"（实现细节，使用面向用户的指标）\n- \"React 组件高效渲染\"（框架特定）\n- \"Redis 缓存命中率高于 80%\"（技术特定）",
        "skills/speckit-constitution-zh/assets/specify/templates/commands/tasks.md": "---\ndescription: 基于可用设计工件为功能生成可操作的、按依赖顺序排列的 tasks.md。\nscripts:\n  sh: scripts/bash/check-prerequisites.sh --json\n  ps: scripts/powershell/check-prerequisites.ps1 -Json\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载设计文档**：从 FEATURE_DIR 读取：\n   - **必需**：plan.md（技术栈、库、结构），spec.md（带优先级的用户故事）\n   - **可选**：data-model.md（实体），contracts/（API 端点），research.md（决策），quickstart.md（测试场景）\n   - 注意：并非所有项目都有所有文档。根据可用内容生成任务。\n\n3. **执行任务生成工作流程**：\n   - 加载 plan.md 并提取技术栈、库、项目结构\n   - 加载 spec.md 并提取带优先级的用户故事（P1, P2, P3 等）\n   - 如果存在 data-model.md：提取实体并映射到用户故事\n   - 如果存在 contracts/：将端点映射到用户故事\n   - 如果存在 research.md：提取决策用于设置任务\n   - 生成按用户故事组织的任务（参见下面的任务生成规则）\n   - 生成依赖图显示用户故事完成顺序\n   - 为每个用户故事创建并行执行示例\n   - 验证任务完整性（每个用户故事都有所需任务，可独立测试）\n\n4. **生成 tasks.md**：使用 `.specify/templates/tasks-template.md` 作为结构，填充：\n   - 从 plan.md 获取正确的功能名称\n   - 阶段 1：设置任务（项目初始化）\n   - 阶段 2：基础任务（所有用户故事的阻塞先决条件）\n   - 阶段 3+：按 spec.md 中的优先级顺序排列的每个用户故事一个阶段\n   - 每个阶段包括：故事目标、独立测试标准、测试（如果要求）、实现任务\n   - 最终阶段：完善和跨领域关注点\n   - 所有任务必须遵循严格的检查表格式（参见下面的任务生成规则）\n   - 每个任务的明确文件路径\n   - 依赖关系部分显示故事完成顺序\n   - 每个故事的并行执行示例\n   - 实现策略部分（MVP 优先、增量交付）\n\n5. **报告**：输出生成的 tasks.md 路径和摘要：\n   - 总任务数\n   - 每个用户故事的任务数\n   - 识别的并行机会\n   - 每个故事的独立测试标准\n   - 建议的 MVP 范围（通常仅为用户故事 1）\n   - 格式验证：确认所有任务都遵循检查表格式（复选框、ID、标签、文件路径）\n\n为任务生成提供上下文：{ARGS}\n\ntasks.md 应该是立即可执行的 - 每个任务必须足够具体，以便 LLM 可以在没有额外上下文的情况下完成它。\n\n## 任务生成规则\n\n**关键**：任务必须按用户故事组织，以实现独立实现和测试。\n\n**测试是可选的**：仅在功能规格中明确要求或用户要求 TDD 方法时才生成测试任务。\n\n### 检查表格式（必需）\n\n每个任务必须严格遵循此格式：\n\n```text\n- [ ] [任务ID] [P?] [故事?] 带文件路径的描述\n```\n\n**格式组件**：\n\n1. **复选框**：始终以 `- [ ]` 开头（markdown 复选框）\n2. **任务 ID**：按执行顺序的序列号（T001, T002, T003...）\n3. **[P] 标记**：仅当任务可并行化时包含（不同文件，不依赖未完成任务）\n4. **[故事] 标签**：仅用户故事阶段任务必需\n   - 格式：[US1], [US2], [US3], 等（映射到 spec.md 中的用户故事）\n   - 设置阶段：无故事标签\n   - 基础阶段：无故事标签  \n   - 用户故事阶段：必须有故事标签\n   - 完善阶段：无故事标签\n5. **描述**：带确切文件路径的明确操作\n\n**示例**：\n\n- ✅ 正确：`- [ ] T001 根据实现计划创建项目结构`\n- ✅ 正确：`- [ ] T005 [P] 在 src/middleware/auth.py 中实现认证中间件`\n- ✅ 正确：`- [ ] T012 [P] [US1] 在 src/models/user.py 中创建用户模型`\n- ✅ 正确：`- [ ] T014 [US1] 在 src/services/user_service.py 中实现 UserService`\n- ❌ 错误：`- [ ] 创建用户模型`（缺少 ID 和故事标签）\n- ❌ 错误：`T001 [US1] 创建模型`（缺少复选框）\n- ❌ 错误：`- [ ] [US1] 创建用户模型`（缺少任务 ID）\n- ❌ 错误：`- [ ] T001 [US1] 创建模型`（缺少文件路径）\n\n### 任务组织\n\n1. **来自用户故事（spec.md）** - 主要组织：\n   - 每个用户故事（P1, P2, P3...）都有自己的阶段\n   - 将所有相关组件映射到它们的故事：\n     - 该故事需要的模型\n     - 该故事需要的服务\n     - 该故事需要的端点/UI\n     - 如果要求测试：该故事的特定测试\n   - 标记故事依赖关系（大多数故事应该是独立的）\n\n2. **来自契约**：\n   - 将每个契约/端点 → 映射到它服务的用户故事\n   - 如果要求测试：每个契约 → 在该故事阶段实现前的契约测试任务 [P]\n\n3. **来自数据模型**：\n   - 将每个实体映射到需要它的用户故事\n   - 如果实体服务于多个故事：放在最早的故事或设置阶段\n   - 关系 → 在适当的故事阶段中的服务层任务\n\n4. **来自设置/基础设施**：\n   - 共享基础设施 → 设置阶段（阶段 1）\n   - 基础/阻塞任务 → 基础阶段（阶段 2）\n   - 故事特定设置 → 在该故事的阶段内\n\n### 阶段结构\n\n- **阶段 1**：设置（项目初始化）\n- **阶段 2**：基础（阻塞先决条件 - 必须在用户故事前完成）\n- **阶段 3+**：按优先级顺序的用户故事（P1, P2, P3...）\n  - 在每个故事内：测试（如果要求）→ 模型 → 服务 → 端点 → 集成\n  - 每个阶段应该是一个完整的、可独立测试的增量\n- **最终阶段**：完善和跨领域关注点",
        "skills/speckit-constitution-zh/assets/specify/templates/constitution-template.md": "# [项目名称] 章程\n<!-- 示例：规范章程，任务流章程等 -->\n\n## 核心原则\n\n### [原则_1_名称]\n<!-- 示例：I. 库优先 -->\n[原则_1_描述]\n<!-- 示例：每个功能都以独立库开始；库必须自包含、可独立测试、有文档；需要明确目的 - 没有仅用于组织的库 -->\n\n### [原则_2_名称]\n<!-- 示例：II. CLI 接口 -->\n[原则_2_描述]\n<!-- 示例：每个库都通过 CLI 暴露功能；文本输入/输出协议：stdin/args → stdout，错误 → stderr；支持 JSON + 人类可读格式 -->\n\n### [原则_3_名称]\n<!-- 示例：III. 测试优先（不可协商） -->\n[原则_3_描述]\n<!-- 示例：TDD 强制：编写测试 → 用户批准 → 测试失败 → 然后实现；严格强制红-绿-重构循环 -->\n\n### [原则_4_名称]\n<!-- 示例：IV. 集成测试 -->\n[原则_4_描述]\n<!-- 示例：需要集成测试的重点领域：新库契约测试、契约变更、服务间通信、共享模式 -->\n\n### [原则_5_名称]\n<!-- 示例：V. 可观察性，VI. 版本控制和破坏性变更，VII. 简单性 -->\n[原则_5_描述]\n<!-- 示例：文本 I/O 确保可调试性；需要结构化日志；或：MAJOR.MINOR.BUILD 格式；或：从简单开始，YAGNI 原则 -->\n\n## [部分_2_名称]\n<!-- 示例：附加约束、安全要求、性能标准等 -->\n\n[部分_2_内容]\n<!-- 示例：技术栈要求、合规标准、部署策略等 -->\n\n## [部分_3_名称]\n<!-- 示例：开发工作流程、审查过程、质量门等 -->\n\n[部分_3_内容]\n<!-- 示例：代码审查要求、测试门、部署批准流程等 -->\n\n## 治理\n<!-- 示例：章程优于所有其他实践；修订需要文档、批准、迁移计划 -->\n\n[治理规则]\n<!-- 示例：所有 PR/审查必须验证合规性；复杂性必须有正当理由；使用 [指导文件] 作为运行时开发指导 -->\n\n**版本**：[章程版本] | **批准**：[批准日期] | **最后修订**：[最后修订日期]\n<!-- 示例：版本：2.1.1 | 批准：2025-06-13 | 最后修订：2025-07-16 -->",
        "skills/speckit-constitution-zh/assets/specify/templates/plan-template.md": "# 实现计划：[功能]\n\n**分支**：`[###-feature-name]` | **日期**：[日期] | **规格**：[链接]\n**输入**：来自 `/specs/[###-feature-name]/spec.md` 的功能规格\n\n**注意**：此模板由 `/speckit.plan` 命令填写。请参见 `.specify/templates/commands/plan.md` 了解执行工作流程。\n\n## 概要\n\n[从功能规格中提取：主要需求 + 研究中的技术方法]\n\n## 技术背景\n\n<!--\n  需要操作：用该项目的技术细节替换本节内容。\n  此处提供的结构是为了指导迭代过程而提供的建议性框架。\n-->\n\n**语言/版本**：[例如，Python 3.11, Swift 5.9, Rust 1.75 或需要澄清]  \n**主要依赖项**：[例如，FastAPI, UIKit, LLVM 或需要澄清]  \n**存储**：[如果适用，例如，PostgreSQL, CoreData, 文件 或不适用]  \n**测试**：[例如，pytest, XCTest, cargo test 或需要澄清]  \n**目标平台**：[例如，Linux 服务器, iOS 15+, WASM 或需要澄清]\n**项目类型**：[单体/网页/移动端 - 决定源码结构]  \n**性能目标**：[领域特定，例如，1000 请求/秒, 10k 行/秒, 60 帧/秒 或需要澄清]  \n**约束条件**：[领域特定，例如，<200ms p95, <100MB 内存, 支持离线 或需要澄清]  \n**规模/范围**：[领域特定，例如，10k 用户, 1M LOC, 50 屏幕 或需要澄清]\n\n## 宪章检查\n\n*关卡：必须在第 0 阶段研究前通过。在第 1 阶段设计后重新检查。*\n\n[基于宪章文件确定的关卡]\n\n## 项目结构\n\n### 文档（此功能）\n\n```text\nspecs/[###-feature]/\n├── plan.md              # 本文件（/speckit.plan 命令输出）\n├── research.md          # 第 0 阶段输出（/speckit.plan 命令）\n├── data-model.md        # 第 1 阶段输出（/speckit.plan 命令）\n├── quickstart.md        # 第 1 阶段输出（/speckit.plan 命令）\n├── contracts/           # 第 1 阶段输出（/speckit.plan 命令）\n└── tasks.md             # 第 2 阶段输出（/speckit.tasks 命令 - 不由 /speckit.plan 创建）\n```\n\n### 源代码（仓库根目录）\n<!--\n  需要操作：用此功能的具体布局替换下面的占位符树。\n  删除未使用的选项，并使用真实路径扩展所选结构（例如，apps/admin, packages/something）。\n  提供的计划不得包含选项标签。\n-->\n\n```text\n# [如果未使用则删除] 选项 1：单一项目（默认）\nsrc/\n├── models/\n├── services/\n├── cli/\n└── lib/\n\ntests/\n├── contract/\n├── integration/\n└── unit/\n\n# [如果未使用则删除] 选项 2：Web 应用程序（当检测到 \"frontend\" + \"backend\" 时）\nbackend/\n├── src/\n│   ├── models/\n│   ├── services/\n│   └── api/\n└── tests/\n\nfrontend/\n├── src/\n│   ├── components/\n│   ├── pages/\n│   └── services/\n└── tests/\n\n# [如果未使用则删除] 选项 3：移动端 + API（当检测到 \"iOS/Android\" 时）\napi/\n└── [与后端相同]\n\nios/ 或 android/\n└── [平台特定结构：功能模块、UI 流程、平台测试]\n```\n\n**结构决策**：[记录选择的结构并引用上面捕获的真实目录]\n\n## 复杂度跟踪\n\n> **仅当宪章检查存在必须证明合理性的违规情况时才填写**\n\n| 违规情况 | 为何需要 | 被拒绝的更简单替代方案原因 |\n|-----------|------------|-------------------------------------|\n| [例如，第 4 个项目] | [当前需求] | [为什么 3 个项目不够] |\n| [例如，仓储模式] | [具体问题] | [为什么直接数据库访问不够] |",
        "skills/speckit-constitution-zh/assets/specify/templates/spec-template.md": "# 功能规格：[功能名称]\n\n**功能分支**：`[###-feature-name]`  \n**创建时间**：[日期]  \n**状态**：草案  \n**输入**：用户描述：\"$ARGUMENTS\"\n\n## 用户场景与测试 *(必填)*\n\n<!--\n  重要：用户故事应按照重要性排序为用户旅程。\n  每个用户故事/旅程必须是独立可测试的 - 这意味着如果您只实现其中一个，\n  您仍应拥有一个可交付价值的可行MVP（最小可行产品）。\n  \n  为每个故事分配优先级（P1, P2, P3等），其中P1是最重要的。\n  将每个故事视为可以：\n  - 独立开发\n  - 独立测试\n  - 独立部署\n  - 独立向用户展示\n-->\n\n### 用户故事 1 - [简要标题] (优先级: P1)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试 - 例如，\"可以通过[具体操作]完全测试，并交付[具体价值]\"]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n2. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n### 用户故事 2 - [简要标题] (优先级: P2)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n### 用户故事 3 - [简要标题] (优先级: P3)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n[根据需要添加更多用户故事，每个都有分配的优先级]\n\n### 边缘情况\n\n<!--\n  需要操作：本节中的内容是占位符。\n  用正确的边缘情况填充它们。\n-->\n\n- 当[边界条件]发生时会怎样？\n- 系统如何处理[错误场景]？\n\n## 要求 *(必填)*\n\n<!--\n  需要操作：本节中的内容是占位符。\n  用正确的功能要求填充它们。\n-->\n\n### 功能要求\n\n- **FR-001**：系统必须[具体能力，例如，\"允许用户创建账户\"]\n- **FR-002**：系统必须[具体能力，例如，\"验证电子邮件地址\"]  \n- **FR-003**：用户必须能够[关键交互，例如，\"重置密码\"]\n- **FR-004**：系统必须[数据要求，例如，\"持久化用户偏好设置\"]\n- **FR-005**：系统必须[行为，例如，\"记录所有安全事件\"]\n\n*标记不明确要求的示例：*\n\n- **FR-006**：系统必须通过[需要澄清：未指定认证方法 - 电子邮件/密码、SSO、OAuth？]\n- **FR-007**：系统必须保留用户数据[需要澄清：未指定保留期]\n\n### 关键实体 *(如果功能涉及数据则包含)*\n\n- **[实体 1]**：[它代表什么，关键属性（无实现细节）]\n- **[实体 2]**：[它代表什么，与其他实体的关系]\n\n## 成功标准 *(必填)*\n\n<!--\n  需要操作：定义可衡量的成功标准。\n  这些必须是技术无关且可衡量的。\n-->\n\n### 可衡量的结果\n\n- **SC-001**：[可衡量的指标，例如，\"用户可以在2分钟内完成账户创建\"]\n- **SC-002**：[可衡量的指标，例如，\"系统在无降级情况下处理1000个并发用户\"]\n- **SC-003**：[用户满意度指标，例如，\"90%的用户首次尝试即可成功完成主要任务\"]\n- **SC-004**：[业务指标，例如，\"将与[X]相关的支持工单减少50%\"]",
        "skills/speckit-constitution-zh/assets/specify/templates/tasks-template.md": "---\ndescription: \"功能实现的任务列表模板\"\n---\n\n# 任务：[功能名称]\n\n**输入**：来自 `/specs/[###-功能名称]/` 的设计文档\n**先决条件**：plan.md（必需），spec.md（用户故事必需），research.md，data-model.md，contracts/\n\n**测试**：下面的示例包含测试任务。测试是可选的 - 仅在功能规格中明确要求时才包含它们。\n\n**组织**：任务按用户故事分组，以实现每个故事的独立实现和测试。\n\n## 格式：`[ID] [P?] [故事] 描述`\n\n- **[P]**：可以并行运行（不同文件，无依赖关系）\n- **[故事]**：此任务属于哪个用户故事（例如，US1, US2, US3）\n- 在描述中包含确切的文件路径\n\n## 路径约定\n\n- **单一项目**：`src/`, `tests/` 在仓库根目录\n- **Web 应用**：`backend/src/`, `frontend/src/`\n- **移动端**：`api/src/`, `ios/src/` 或 `android/src/`\n- 下面显示的路径假设为单一项目 - 根据 plan.md 结构进行调整\n\n<!-- \n  ============================================================================\n  重要提示：下面的任务仅为示例任务，仅用于说明目的。\n  \n  /speckit.tasks 命令必须根据以下内容替换这些任务：\n  - 来自 spec.md 的用户故事（及其优先级 P1, P2, P3...）\n  - 来自 plan.md 的功能要求\n  - 来自 data-model.md 的实体\n  - 来自 contracts/ 的端点\n  \n  任务必须按用户故事组织，以便每个故事可以：\n  - 独立实现\n  - 独立测试\n  - 作为 MVP 增量交付\n  \n  不要在生成的 tasks.md 文件中保留这些示例任务。\n  ============================================================================\n-->\n\n## 阶段 1：设置（共享基础设施）\n\n**目的**：项目初始化和基本结构\n\n- [ ] T001 根据实现计划创建项目结构\n- [ ] T002 使用 [框架] 依赖项初始化 [语言] 项目\n- [ ] T003 [P] 配置代码检查和格式化工具\n\n---\n\n## 阶段 2：基础（阻塞先决条件）\n\n**目的**：必须在任何用户故事实现之前完成的核心基础设施\n\n**⚠️ 关键**：在本阶段完成之前，任何用户故事工作都不能开始\n\n基础任务示例（根据您的项目进行调整）：\n\n- [ ] T004 设置数据库模式和迁移框架\n- [ ] T005 [P] 实现认证/授权框架\n- [ ] T006 [P] 设置 API 路由和中间件结构\n- [ ] T007 创建所有故事都依赖的基础模型/实体\n- [ ] T008 配置错误处理和日志基础设施\n- [ ] T009 设置环境配置管理\n\n**检查点**：基础就绪 - 用户故事实现现在可以并行开始\n\n---\n\n## 阶段 3：用户故事 1 - [标题] (优先级: P1) 🎯 MVP\n\n**目标**：[对此故事交付内容的简要描述]\n\n**独立测试**：[如何验证此故事独立工作]\n\n### 用户故事 1 的测试（可选 - 仅在要求测试时）⚠️\n\n> **注意：首先编写这些测试，确保在实现之前它们失败**\n\n- [ ] T010 [P] [US1] tests/contract/test_[name].py 中 [端点] 的契约测试\n- [ ] T011 [P] [US1] tests/integration/test_[name].py 中 [用户旅程] 的集成测试\n\n### 用户故事 1 的实现\n\n- [ ] T012 [P] [US1] 在 src/models/[entity1].py 中创建 [Entity1] 模型\n- [ ] T013 [P] [US1] 在 src/models/[entity2].py 中创建 [Entity2] 模型\n- [ ] T014 [US1] 在 src/services/[service].py 中实现 [服务]（依赖于 T012, T013）\n- [ ] T015 [US1] 在 src/[location]/[file].py 中实现 [端点/功能]\n- [ ] T016 [US1] 添加验证和错误处理\n- [ ] T017 [US1] 为用户故事 1 操作添加日志\n\n**检查点**：此时，用户故事 1 应该完全功能化并可独立测试\n\n---\n\n## 阶段 4：用户故事 2 - [标题] (优先级: P2)\n\n**目标**：[对此故事交付内容的简要描述]\n\n**独立测试**：[如何验证此故事独立工作]\n\n### 用户故事 2 的测试（可选 - 仅在要求测试时）⚠️\n\n- [ ] T018 [P] [US2] tests/contract/test_[name].py 中 [端点] 的契约测试\n- [ ] T019 [P] [US2] tests/integration/test_[name].py 中 [用户旅程] 的集成测试\n\n### 用户故事 2 的实现\n\n- [ ] T020 [P] [US2] 在 src/models/[entity].py 中创建 [实体] 模型\n- [ ] T021 [US2] 在 src/services/[service].py 中实现 [服务]\n- [ ] T022 [US2] 在 src/[location]/[file].py 中实现 [端点/功能]\n- [ ] T023 [US2] 与用户故事 1 组件集成（如果需要）\n\n**检查点**：此时，用户故事 1 和 2 都应该独立工作\n\n---\n\n## 阶段 5：用户故事 3 - [标题] (优先级: P3)\n\n**目标**：[对此故事交付内容的简要描述]\n\n**独立测试**：[如何验证此故事独立工作]\n\n### 用户故事 3 的测试（可选 - 仅在要求测试时）⚠️\n\n- [ ] T024 [P] [US3] tests/contract/test_[name].py 中 [端点] 的契约测试\n- [ ] T025 [P] [US3] tests/integration/test_[name].py 中 [用户旅程] 的集成测试\n\n### 用户故事 3 的实现\n\n- [ ] T026 [P] [US3] 在 src/models/[entity].py 中创建 [实体] 模型\n- [ ] T027 [US3] 在 src/services/[service].py 中实现 [服务]\n- [ ] T028 [US3] 在 src/[location]/[file].py 中实现 [端点/功能]\n\n**检查点**：所有用户故事现在都应该独立功能化\n\n---\n\n[根据需要添加更多用户故事阶段，遵循相同模式]\n\n---\n\n## 阶段 N：完善和跨领域关注点\n\n**目的**：影响多个用户故事的改进\n\n- [ ] TXXX [P] docs/ 中的文档更新\n- [ ] TXXX 代码清理和重构\n- [ ] TXXX 跨所有故事的性能优化\n- [ ] TXXX [P] 附加单元测试（如果要求）在 tests/unit/ 中\n- [ ] TXXX 安全加固\n- [ ] TXXX 运行 quickstart.md 验证\n\n---\n\n## 依赖关系和执行顺序\n\n### 阶段依赖关系\n\n- **设置（阶段 1）**：无依赖关系 - 可立即开始\n- **基础（阶段 2）**：依赖于设置完成 - 阻塞所有用户故事\n- **用户故事（阶段 3+）**：都依赖于基础阶段完成\n  - 用户故事然后可以并行进行（如果有人员）\n  - 或按优先级顺序依次进行（P1 → P2 → P3）\n- **完善（最终阶段）**：依赖于所有所需用户故事完成\n\n### 用户故事依赖关系\n\n- **用户故事 1 (P1)**：可在基础阶段完成后开始 - 无其他故事依赖\n- **用户故事 2 (P2)**：可在基础阶段完成后开始 - 可能与 US1 集成但应独立可测试\n- **用户故事 3 (P3)**：可在基础阶段完成后开始 - 可能与 US1/US2 集成但应独立可测试\n\n### 每个用户故事内部\n\n- 测试（如果包含）必须在实现之前编写并失败\n- 模型在服务之前\n- 服务在端点之前\n- 核心实现在集成之前\n- 故事完成后才进入下一个优先级\n\n### 并行机会\n\n- 所有标记为 [P] 的设置任务可以并行运行\n- 所有标记为 [P] 的基础任务可以并行运行（在阶段 2 内）\n- 一旦基础阶段完成，所有用户故事可以并行开始（如果团队容量允许）\n- 标记为 [P] 的用户故事的所有测试可以并行运行\n- 标记为 [P] 的故事内的模型可以并行运行\n- 不同的用户故事可以由不同团队成员并行处理\n\n---\n\n## 并行示例：用户故事 1\n\n```bash\n# 一起启动用户故事 1 的所有测试（如果要求测试）：\n任务：\"tests/contract/test_[name].py 中 [端点] 的契约测试\"\n任务：\"tests/integration/test_[name].py 中 [用户旅程] 的集成测试\"\n\n# 一起启动用户故事 1 的所有模型：\n任务：\"在 src/models/[entity1].py 中创建 [Entity1] 模型\"\n任务：\"在 src/models/[entity2].py 中创建 [Entity2] 模型\"\n```\n\n---\n\n## 实现策略\n\n### MVP 优先（仅用户故事 1）\n\n1. 完成阶段 1：设置\n2. 完成阶段 2：基础（关键 - 阻塞所有故事）\n3. 完成阶段 3：用户故事 1\n4. **停止并验证**：独立测试用户故事 1\n5. 如果准备就绪则部署/演示\n\n### 增量交付\n\n1. 完成设置 + 基础 → 基础就绪\n2. 添加用户故事 1 → 独立测试 → 部署/演示（MVP！）\n3. 添加用户故事 2 → 独立测试 → 部署/演示\n4. 添加用户故事 3 → 独立测试 → 部署/演示\n5. 每个故事在不破坏之前故事的情况下增加价值\n\n### 并行团队策略\n\n多个开发人员时：\n\n1. 团队一起完成设置 + 基础\n2. 一旦基础完成：\n   - 开发人员 A：用户故事 1\n   - 开发人员 B：用户故事 2\n   - 开发人员 C：用户故事 3\n3. 故事独立完成和集成\n\n---\n\n## 备注\n\n- [P] 任务 = 不同文件，无依赖关系\n- [故事] 标签将任务映射到特定用户故事以实现可追溯性\n- 每个用户故事应该是独立可完成和可测试的\n- 在实现之前验证测试失败\n- 每个任务或逻辑组之后提交\n- 在任何检查点停止以独立验证故事\n- 避免：模糊任务、相同文件冲突、破坏独立性的跨故事依赖",
        "skills/speckit-implement-zh/SKILL.md": "---\nname: speckit-implement-zh\ndescription: 通过测试与验证为先的方式，按序执行并实现已批准的规范提案。用于实施变更、应用提案、执行规范任务或按已批准计划构建。触发词包括 \"speckit-implement\", \"speckit开发\", \"开发\", \"实施\" \"实现提案\", \"应用变更\", \"执行规范\", \"按顺序完成任务\", \"构建功能\", \"开始实施\"。\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n          \nscripts:\n  sh: .specify/scripts/bash/check-prerequisites.sh --json\n  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json\n\n1. 从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **检查检查表状态**（如果 FEATURE_DIR/checklists/ 存在）：\n\n   - 扫描 checklists/ 目录中的所有检查表文件\n\n   - 对于每个检查表，计数：\n\n     - 总项目：所有匹配 `- [ ]` 或 `- [X]` 或 `- [x]` 的行\n     - 完成项目：匹配 `- [X]` 或 `- [x]` 的行\n     - 未完成项目：匹配 `- [ ]` 的行\n\n   - 创建状态表：\n\n     ```text\n     | 检查表 | 总计 | 已完成 | 未完成 | 状态 |\n     |-----------|-------|-----------|------------|--------|\n     | ux.md     | 12    | 12        | 0          | ✓ 通过 |\n     | test.md   | 8     | 5         | 3          | ✗ 失败 |\n     | security.md | 6   | 6         | 0          | ✓ 通过 |\n     ```\n\n   - 计算总体状态：\n\n     - **通过**：所有检查表都有 0 个未完成项目\n     - **失败**：一个或多个检查表有未完成项目\n\n   - **如果有任何检查表未完成**：\n\n     - 显示包含未完成项目计数的表格\n     - **停止**并询问：\"一些检查表未完成。您是否仍要继续执行实现？(yes/no)\"\n     - 等待用户响应后再继续\n     - 如果用户说\"no\"或\"wait\"或\"stop\"，则停止执行\n     - 如果用户说\"yes\"或\"proceed\"或\"continue\"，则继续到步骤 3\n\n   - **如果所有检查表都完成**：\n\n     - 显示表格显示所有检查表已通过\n     - 自动继续到步骤 3\n\n3. 加载和分析实现上下文：\n\n   - **必需**：读取 tasks.md 以获取完整的任务列表和执行计划\n   - **必需**：读取 plan.md 以获取技术栈、架构和文件结构\n   - **如果存在**：读取 data-model.md 以获取实体和关系\n   - **如果存在**：读取 contracts/ 以获取 API 规范和测试要求\n   - **如果存在**：读取 research.md 以获取技术决策和约束\n   - **如果存在**：读取 quickstart.md 以获取集成场景\n\n4. **项目设置验证**：\n\n   - **必需**：根据实际项目设置创建/验证忽略文件：\n\n   **检测和创建逻辑**：\n\n   - 检查以下命令是否成功以确定仓库是否为 git 仓库（如果是则创建/验证 .gitignore）：\n\n     ```sh\n     git rev-parse --git-dir 2>/dev/null\n     ```\n\n   - 检查是否存在 Dockerfile* 或 Docker 在 plan.md 中 → 创建/验证 .dockerignore\n\n   - 检查是否存在 .eslintrc* 或 eslint.config.* → 创建/验证 .eslintignore\n\n   - 检查是否存在 .prettierrc* → 创建/验证 .prettierignore\n\n   - 检查是否存在 .npmrc 或 package.json → 创建/验证 .npmignore（如果发布）\n\n   - 检查是否存在 terraform 文件 (*.tf) → 创建/验证 .terraformignore\n\n   - 检查是否需要 .helmignore（存在 helm 图表）→ 创建/验证 .helmignore\n\n   **如果忽略文件已存在**：验证它包含基本模式，仅追加缺失的关键模式\n   **如果忽略文件缺失**：创建包含检测技术的完整模式集\n\n   **按技术的常见模式**（来自 plan.md 技术栈）：\n\n   - **Node.js/JavaScript/TypeScript**：`node_modules/`, `dist/`, `build/`, `*.log`, `.env*`\n   - **Python**：`__pycache__/`, `*.pyc`, `.venv/`, `venv/`, `dist/`, `*.egg-info/`\n   - **Java**：`target/`, `*.class`, `*.jar`, `.gradle/`, `build/`\n   - **C#/.NET**：`bin/`, `obj/`, `*.user`, `*.suo`, `packages/`\n   - **Go**：`*.exe`, `*.test`, `vendor/`, `*.out`\n   - **Ruby**：`.bundle/`, `log/`, `tmp/`, `*.gem`, `vendor/bundle/`\n   - **PHP**：`vendor/`, `*.log`, `*.cache`, `*.env`\n   - **Rust**：`target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`\n   - **Kotlin**：`build/`, `out/`, `.gradle/`, `.idea/`, `*.class`, `*.jar`, `*.iml`, `*.log`, `.env*`\n   - **C++**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.so`, `*.a`, `*.exe`, `*.dll`, `.idea/`, `*.log`, `.env*`\n   - **C**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.a`, `*.so`, `*.exe`, `Makefile`, `config.log`, `.idea/`, `*.log`, `.env*`\n   - **Swift**：`.build/`, `DerivedData/`, `*.swiftpm/`, `Packages/`\n   - **R**：`.Rproj.user/`, `.Rhistory`, `.RData`, `.Ruserdata`, `*.Rproj`, `packrat/`, `renv/`\n   - **通用**：`.DS_Store`, `Thumbs.db`, `*.tmp`, `*.swp`, `.vscode/`, `.idea/`\n\n   **工具特定模式**：\n\n   - **Docker**：`node_modules/`, `.git/`, `Dockerfile*`, `.dockerignore`, `*.log*`, `.env*`, `coverage/`\n   - **ESLint**：`node_modules/`, `dist/`, `build/`, `coverage/`, `*.min.js`\n   - **Prettier**：`node_modules/`, `dist/`, `build/`, `coverage/`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`\n   - **Terraform**：`.terraform/`, `*.tfstate*`, `*.tfvars`, `.terraform.lock.hcl`\n   - **Kubernetes/k8s**：`*.secret.yaml`, `secrets/`, `.kube/`, `kubeconfig*`, `*.key`, `*.crt`\n\n5. 解析 tasks.md 结构并提取：\n\n   - **任务阶段**：设置、测试、核心、集成、完善\n   - **任务依赖**：顺序与并行执行规则\n   - **任务详情**：ID、描述、文件路径、并行标记 [P]\n   - **执行流程**：顺序和依赖要求\n\n6. 按照任务计划执行实现：\n\n   - **阶段执行**：完成每个阶段后再进入下一个\n   - **尊重依赖**：按顺序运行顺序任务，并行任务 [P] 可以一起运行  \n   - **遵循 TDD 方法**：在相应的实现任务之前执行测试任务\n   - **基于文件的协调**：影响相同文件的任务必须顺序运行\n   - **验证检查点**：在继续之前验证每个阶段的完成情况\n\n7. 实现执行规则：\n\n   - **首先设置**：初始化项目结构、依赖、配置\n   - **测试优先于代码**：如果需要为契约、实体和集成场景编写测试\n   - **核心开发**：实现模型、服务、CLI 命令、端点\n   - **集成工作**：数据库连接、中间件、日志、外部服务\n   - **完善和验证**：单元测试、性能优化、文档\n\n8. 进度跟踪和错误处理：\n\n   - 在每个完成的任务后报告进度\n   - 如果任何非并行任务失败则停止执行\n   - 对于并行任务 [P]，继续执行成功的任务，报告失败的任务\n   - 提供清晰的错误消息和调试上下文\n   - 如果实现无法继续则建议下一步\n   - **重要** 对于完成的任务，确保在任务文件中标记为 [X]。\n\n9. 完成验证：\n\n   - 验证所有必需任务已完成\n   - 检查实现的功能是否与原始规格匹配\n   - 验证测试通过且覆盖率符合要求\n   - 确认实现遵循技术计划\n   - 报告最终状态和已完成工作的摘要\n\n注意：此命令假设 tasks.md 中存在完整的任务分解。如果任务不完整或缺失，建议首先运行 `speckit-tasks` 以重新生成任务列表。\n\n",
        "skills/speckit-implement-zh/references/context-loading-order.md": "# 上下文加载顺序和优先级\n\n## 必需文档 (最高优先级)\n1. **tasks.md** - 完整的任务列表和执行计划\n   - 包含所有实施步骤\n   - 定义依赖关系和执行顺序\n   - 指定阶段划分\n\n2. **plan.md** - 技术栈、架构和文件结构\n   - 技术选型和架构决策\n   - 项目结构和组织方式\n   - 开发规范和标准\n\n## 条件文档 (如果存在)\n\n### 数据模型 (如果存在)\n3. **data-model.md** - 实体和关系\n   - 数据库模式设计\n   - 实体关系图\n   - 数据验证规则\n\n### API 规范 (如果存在)\n4. **contracts/** - API 规范和测试要求\n   - 端点定义\n   - 请求/响应模式\n   - 验证和错误处理\n\n### 研究文档 (如果存在)\n5. **research.md** - 技术决策和约束\n   - 技术调研结果\n   - 性能要求\n   - 安全考虑\n\n### 快速开始 (如果存在)\n6. **quickstart.md** - 集成场景\n   - 使用示例\n   - 部署配置\n   - 环境要求\n\n## 加载策略\n\n### 错误处理\n- 如果必需文档缺失，立即停止并提示\n- 如果条件文档缺失，记录但继续执行\n\n### 优先级原则\n1. 先加载任务计划，了解实施步骤\n2. 再加载技术规划，理解架构约束\n3. 最后加载补充信息，完善实施细节\n\n### 依赖分析\n- 分析文档间的依赖关系\n- 识别可能的冲突或矛盾\n- 提供解决建议\n\n## 文档完整性检查\n\n### 必需验证\n```markdown\n- [ ] tasks.md 存在且格式正确\n- [ ] plan.md 存在且内容完整\n- [ ] 文档间信息一致\n- [ ] 依赖关系明确\n```\n\n### 可选验证\n```markdown\n- [ ] data-model.md 与 tasks.md 一致\n- [ ] contracts/ 与 plan.md 架构匹配\n- [ ] research.md 决策已实施\n- [ ] quickstart.md 场景可执行\n```",
        "skills/speckit-implement-zh/references/ignore-patterns.md": "# Ignore 文件模式参考\n\n## 通用模式\n```\n.DS_Store\nThumbs.db\n*.tmp\n*.swp\n.vscode/\n.idea/\n```\n\n## 技术栈特定模式\n\n### Node.js/JavaScript/TypeScript\n```\nnode_modules/\ndist/\nbuild/\n*.log\n.env*\n```\n\n### Python\n```\n__pycache__/\n*.pyc\n.venv/\nvenv/\ndist/\n*.egg-info/\n```\n\n### Java\n```\ntarget/\n*.class\n*.jar\n.gradle/\nbuild/\n```\n\n### C#/.NET\n```\nbin/\nobj/\n*.user\n*.suo\npackages/\n```\n\n### Go\n```\n*.exe\n*.test\nvendor/\n*.out\n```\n\n### Ruby\n```\n.bundle/\nlog/\ntmp/\n*.gem\nvendor/bundle/\n```\n\n### PHP\n```\nvendor/\n*.log\n*.cache\n*.env\n```\n\n### Rust\n```\ntarget/\ndebug/\nrelease/\n*.rs.bk\n*.rlib\n*.prof*\n.idea/\n*.log\n.env*\n```\n\n### Kotlin\n```\nbuild/\nout/\n.gradle/\n.idea/\n*.class\n*.jar\n*.iml\n*.log\n.env*\n```\n\n### C++\n```\nbuild/\nbin/\nobj/\nout/\n*.o\n*.so\n*.a\n*.exe\n*.dll\n.idea/\n*.log\n.env*\n```\n\n### C\n```\nbuild/\nbin/\nobj/\nout/\n*.o\n*.a\n*.so\n*.exe\nMakefile\nconfig.log\n.idea/\n*.log\n.env*\n```\n\n### Swift\n```\n.build/\nDerivedData/\n*.swiftpm/\nPackages/\n```\n\n### R\n```\n.Rproj.user/\n.Rhistory\n.RData\n.Ruserdata\n*.Rproj\npackrat/\nrenv/\n```\n\n## 工具特定模式\n\n### Docker\n```\nnode_modules/\n.git/\nDockerfile*\n.dockerignore\n*.log*\n.env*\ncoverage/\n```\n\n### ESLint\n```\nnode_modules/\ndist/\nbuild/\ncoverage/\n*.min.js\n```\n\n### Prettier\n```\nnode_modules/\ndist/\nbuild/\ncoverage/\npackage-lock.json\nyarn.lock\npnpm-lock.yaml\n```\n\n### Terraform\n```\n.terraform/\n*.tfstate*\n*.tfvars\n.terraform.lock.hcl\n```\n\n### Kubernetes/k8s\n```\n*.secret.yaml\nsecrets/\n.kube/\nkubeconfig*\n*.key\n*.crt\n```",
        "skills/speckit-implement-zh/references/implementation-workflow.md": "# 实施工作流参考\n\n## 任务阶段\n实施通常分为以下几个阶段：\n\n1. **Setup** - 项目初始化和配置\n2. **Tests** - 测试设置和测试用例编写\n3. **Core** - 核心功能实现\n4. **Integration** - 集成和中间件\n5. **Polish** - 优化和完善\n\n## 任务执行规则\n\n### 依赖关系处理\n- **顺序任务**: 必须按定义顺序执行\n- **并行任务 [P]**: 可以同时执行，但不影响相同文件的任务必须保持顺序\n\n### TDD 方法\n- 测试任务优先于对应的实现任务\n- 先写测试，再写实现代码\n\n### 文件协调\n- 影响相同文件的任务必须按顺序执行\n- 避免并发修改冲突\n\n### 验证检查点\n- 每个阶段完成后进行验证\n- 确保质量标准满足要求\n\n## 错误处理\n\n### 非并行任务失败\n- 立即停止执行\n- 提供详细错误信息\n- 建议修复步骤\n\n### 并行任务失败\n- 继续执行成功的任务\n- 记录失败的任务\n- 汇总所有错误信息\n\n## 进度跟踪\n\n### 任务标记\n- 使用 `[X]` 标记已完成的任务\n- 保持任务文件同步更新\n\n### 状态报告\n- 每个任务完成后报告进度\n- 提供清晰的状态概览\n- 包含下一步建议\n\n## 完成验证\n\n### 必需检查\n- [ ] 所有必需任务已完成\n- [ ] 实现功能与原始规范匹配\n- [ ] 测试通过且覆盖率达到要求\n- [ ] 实现遵循技术计划\n\n### 最终报告\n- 提供完成工作的详细摘要\n- 列出所有实现的功能\n- 说明任何偏离或调整\n- 提供维护和扩展建议",
        "skills/speckit-plan-zh/SKILL.md": "---\nname: speckit-plan-zh\ndescription: 执行实施规划工作流程，使用计划模板生成设计工件。触发词包括：\"speckit计划\"。\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n在继续之前，您**必须**考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**: 从仓库根目录运行 `.specify/scripts/powershell/setup-plan.ps1 -Json` 并解析 JSON 以获取 FEATURE_SPEC、IMPL_PLAN、SPECS_DIR、BRANCH。对于参数中的单引号，如 \"I'm Groot\"，请使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载上下文**: 读取 FEATURE_SPEC 和 `.specify/memory/constitution.md`。加载 IMPL_PLAN 模板（已复制）。\n\n3. **执行计划工作流程**: 遵循 IMPL_PLAN 模板中的结构来：\n   - 填写技术上下文（将未知项标记为\"需要澄清\"）\n   - 从章程中填写章程检查部分\n   - 评估门禁（如果有未正当化的违规则报错）\n   - 阶段 0: 生成 research.md（解决所有\"需要澄清\"）\n   - 阶段 1: 生成 data-model.md、contracts/、quickstart.md\n   - 阶段 1: 通过运行代理脚本更新代理上下文\n   - 设计后重新评估章程检查\n\n4. **停止并报告**: 命令在阶段 2 规划后结束。报告分支、IMPL_PLAN 路径和生成的工件。\n\n## 阶段\n\n### 阶段 0: 大纲与研究\n\n1. **从上述技术上下文中提取未知项**:\n\n   - 对于每个\"需要澄清\" → 研究任务\n   - 对于每个依赖项 → 最佳实践任务\n   - 对于每个集成 → 模式任务\n\n2. **生成并分发研究代理**:\n\n   ```text\n   对于技术上下文中的每个未知项:\n     任务: \"研究 {未知项} 用于 {功能上下文}\"\n   对于每个技术选择:\n     任务: \"查找 {技术} 在 {领域} 中的最佳实践\"\n   ```\n\n3. **在 `research.md` 中整合发现结果**，使用格式:\n\n   - 决策: [选择了什么]\n   - 理由: [为什么选择]\n   - 考虑的替代方案: [还评估了什么]\n\n**输出**: 解决了所有\"需要澄清\"的 research.md\n\n### 阶段 1: 设计与契约\n\n**前提条件:** `research.md` 完成\n\n1. **从功能规格中提取实体** → `data-model.md`:\n   - 实体名称、字段、关系\n   - 来自需求的验证规则\n   - 如适用的状态转换\n\n2. **从功能需求生成 API 契约**:\n   - 对于每个用户操作 → 端点\n   - 使用标准的 REST/GraphQL 模式\n   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`\n\n3. **代理上下文更新**:\n   - 运行 `.specify/scripts/powershell/update-agent-context.ps1 -AgentType claude`\n   - 这些脚本检测正在使用的 AI 代理\n   - 更新相应的代理特定上下文文件\n   - 仅添加当前计划中的新技术\n   - 保留标记之间的手动添加内容\n\n**输出**: data-model.md、/contracts/*、quickstart.md、代理特定文件\n\n## 关键规则\n\n- 使用绝对路径\n- 如果检查点失败或存在未解决的澄清项，则报 ERROR\n\n",
        "skills/speckit-plan-zh/assets/key-rules.md": "# 关键规则\n\n## 执行规则\n\n- 使用绝对路径\n- 在网关失败或未解决的澄清时抛出 ERROR\n- 严格遵循工作流程阶段\n- 确保所有依赖项得到解决\n- 维护代理上下文更新",
        "skills/speckit-plan-zh/assets/phase0-research.md": "# Phase 0: Outline & Research\n\n## 研究工作流程\n\n### 1. 从技术上下文中提取未知项\n   - 对于每个 NEEDS CLARIFICATION → 研究任务\n   - 对于每个依赖项 → 最佳实践任务\n   - 对于每个集成 → 模式任务\n\n### 2. 生成和调度研究代理\n\n```\n对于技术上下文中的每个未知项：\n  任务：\"为 {功能上下文} 研究 {未知项}\"\n对于每个技术选择：\n  任务：\"在 {领域} 中找到 {技术} 的最佳实践\"\n```\n\n### 3. 在 research.md 中整合研究结果\n   - 决策：[选择了什么]\n   - 理由：[为什么选择]\n   - 考虑的替代方案：[还评估了什么]\n\n**输出**：包含所有已解决的 NEEDS CLARIFICATION 的 research.md",
        "skills/speckit-plan-zh/assets/phase1-design.md": "# Phase 1: Design & Contracts\n\n**前提条件**：research.md 完成\n\n## 设计工作流程\n\n### 1. 从功能规范中提取实体 → data-model.md\n   - 实体名称、字段、关系\n   - 来自需求的验证规则\n   - 状态转换（如适用）\n\n### 2. 根据功能需求生成 API 契约\n   - 对于每个用户操作 → 端点\n   - 使用标准 REST/GraphQL 模式\n   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`\n\n### 3. 代理上下文更新\n   - 运行 `.specify/scripts/powershell/update-agent-context.ps1 -AgentType claude`\n   - 这些脚本检测正在使用哪个 AI 代理\n   - 更新适当的代理特定上下文文件\n   - 仅添加来自当前计划的新技术\n   - 在标记之间保留手动添加的内容\n\n**输出**：data-model.md、/contracts/*、quickstart.md、代理特定文件",
        "skills/speckit-plan-zh/assets/plan-template.md": "# 实现计划：[功能]\n\n**分支**：`[###-feature-name]` | **日期**：[日期] | **规格**：[链接]\n**输入**：来自 `/specs/[###-feature-name]/spec.md` 的功能规格\n\n**注意**：此模板由 `/speckit.plan` 命令填写。请参见 `.specify/templates/commands/plan.md` 了解执行工作流程。\n\n## 概要\n\n[从功能规格中提取：主要需求 + 研究中的技术方法]\n\n## 技术背景\n\n<!--\n  需要操作：用该项目的技术细节替换本节内容。\n  此处提供的结构是为了指导迭代过程而提供的建议性框架。\n-->\n\n**语言/版本**：[例如，Python 3.11, Swift 5.9, Rust 1.75 或需要澄清]  \n**主要依赖项**：[例如，FastAPI, UIKit, LLVM 或需要澄清]  \n**存储**：[如果适用，例如，PostgreSQL, CoreData, 文件 或不适用]  \n**测试**：[例如，pytest, XCTest, cargo test 或需要澄清]  \n**目标平台**：[例如，Linux 服务器, iOS 15+, WASM 或需要澄清]\n**项目类型**：[单体/网页/移动端 - 决定源码结构]  \n**性能目标**：[领域特定，例如，1000 请求/秒, 10k 行/秒, 60 帧/秒 或需要澄清]  \n**约束条件**：[领域特定，例如，<200ms p95, <100MB 内存, 支持离线 或需要澄清]  \n**规模/范围**：[领域特定，例如，10k 用户, 1M LOC, 50 屏幕 或需要澄清]\n\n## 宪章检查\n\n*关卡：必须在第 0 阶段研究前通过。在第 1 阶段设计后重新检查。*\n\n[基于宪章文件确定的关卡]\n\n## 项目结构\n\n### 文档（此功能）\n\n```text\nspecs/[###-feature]/\n├── plan.md              # 本文件（/speckit.plan 命令输出）\n├── research.md          # 第 0 阶段输出（/speckit.plan 命令）\n├── data-model.md        # 第 1 阶段输出（/speckit.plan 命令）\n├── quickstart.md        # 第 1 阶段输出（/speckit.plan 命令）\n├── contracts/           # 第 1 阶段输出（/speckit.plan 命令）\n└── tasks.md             # 第 2 阶段输出（/speckit.tasks 命令 - 不由 /speckit.plan 创建）\n```\n\n### 源代码（仓库根目录）\n<!--\n  需要操作：用此功能的具体布局替换下面的占位符树。\n  删除未使用的选项，并使用真实路径扩展所选结构（例如，apps/admin, packages/something）。\n  提供的计划不得包含选项标签。\n-->\n\n```text\n# [如果未使用则删除] 选项 1：单一项目（默认）\nsrc/\n├── models/\n├── services/\n├── cli/\n└── lib/\n\ntests/\n├── contract/\n├── integration/\n└── unit/\n\n# [如果未使用则删除] 选项 2：Web 应用程序（当检测到 \"frontend\" + \"backend\" 时）\nbackend/\n├── src/\n│   ├── models/\n│   ├── services/\n│   └── api/\n└── tests/\n\nfrontend/\n├── src/\n│   ├── components/\n│   ├── pages/\n│   └── services/\n└── tests/\n\n# [如果未使用则删除] 选项 3：移动端 + API（当检测到 \"iOS/Android\" 时）\napi/\n└── [与后端相同]\n\nios/ 或 android/\n└── [平台特定结构：功能模块、UI 流程、平台测试]\n```\n\n**结构决策**：[记录选择的结构并引用上面捕获的真实目录]\n\n## 复杂度跟踪\n\n> **仅当宪章检查存在必须证明合理性的违规情况时才填写**\n\n| 违规情况 | 为何需要 | 被拒绝的更简单替代方案原因 |\n|-----------|------------|-------------------------------------|\n| [例如，第 4 个项目] | [当前需求] | [为什么 3 个项目不够] |\n| [例如，仓储模式] | [具体问题] | [为什么直接数据库访问不够] |",
        "skills/speckit-plan-zh/assets/setup-workflow.md": "# 设置工作流程\n\n## 初始设置步骤\n\n### 1. 环境设置\n从仓库根目录运行：\n```powershell\n.speckit/scripts/powershell/setup-plan.ps1 -Json\n```\n\n### 2. JSON 解析\n解析 JSON 输出以获取：\n- FEATURE_SPEC\n- IMPL_PLAN\n- SPECS_DIR\n- BRANCH\n\n### 3. 参数处理\n对于参数中的单引号（如 \"I'm Groot\"），使用转义语法：\n- 例如：'I'\\\\''m Groot'\n- 或者尽可能使用双引号：\"I'm Groot\"\n\n### 4. 上下文加载\n读取 FEATURE_SPEC 和 `.specify/memory/constitution.md`\n加载已复制的 IMPL_PLAN 模板",
        "skills/speckit-plan-zh/references/technical-context.md": "# 技术上下文参考\n\n## Speckit 工作流程架构\n\n### 组件说明\n- **功能规范 (Feature Spec)**: 描述要实现的功能需求\n- **实施计划 (Impl Plan)**: 结构化的实施计划和模板\n- **研究阶段 (Phase 0)**: 分析技术未知项和依赖关系\n- **设计阶段 (Phase 1)**: 生成数据模型和 API 契约\n\n### 目录结构规范\n```\n.specify/\n├── memory/\n│   ├── constitution.md          # 项目章程/约束条件\n│   └── agent-context/           # AI 代理上下文文件\n├── scripts/\n│   └── powershell/              # PowerShell 脚本\n├── templates/\n│   └── impl-plan.md            # 实施计划模板\n├── contracts/                   # API 契约文件\n├── research.md                 # 研究结果\n├── data-model.md              # 数据模型\n└── quickstart.md              # 快速开始指南\n```\n\n### 代理类型支持\n- **Claude**: 使用 claude-context.md\n- **ChatGPT**: 使用 chatgpt-context.md\n- **Auto**: 自动检测环境变量 AI_AGENT_TYPE\n\n### 关键概念\n- **NEEDS CLARIFICATION**: 需要进一步澄清的技术项\n- **Gate violations**: 违反项目约束条件\n- **Constitution checks**: 项目章程合规性检查\n- **Agent context**: AI 代理的项目特定上下文信息\n\n## 最佳实践\n\n1. **研究阶段**: 确保所有技术未知项得到解决\n2. **设计阶段**: 遵循 REST/GraphQL 标准模式\n3. **上下文管理**: 保留手动添加的内容在标记之间\n4. **错误处理**: 在关键失败点抛出 ERROR\n5. **文档维护**: 保持文档与实施同步",
        "skills/speckit-specify-zh/SKILL.md": "---\nname: speckit-specify-zh\ndescription: 中文功能规范创建工具，用于将自然语言功能描述转换为结构化的功能规范文档。支持自动生成分支名称、创建Git分支、初始化规范文件和质量验证。触发词包括：\"speckit规范\"、\"功能规范\"、\"创建规范\"、\"功能描述转换\"、\"speckit-specify\"。当用户需要将功能想法转换为结构化规范时使用此技能。\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n在继续之前，您**必须**考虑用户输入（如果非空）。\n\n## 大纲\n\n触发消息中用户在触发词后键入的文本**就是**功能描述。假设在此对话中始终可以使用该功能描述，即 `$ARGUMENTS`。除非用户提供了一个空命令，否则不要要求用户重复。\n\n根据该功能描述，请执行以下操作：\n\n1. 将 `assets/specify/` 所有文件（包括子目录）按原目录结构复制到仓库根目录下的`.specify` 目录，跳过已有文件，**不能覆盖原有同名文件**。cp命令的 -n（--no-clobber）选项可以防止覆盖已存在的文件。\n在此阶段，您的项目文件夹内容应类似于以下内容：\n\n```text\n仓库根目录\n└── .specify\n    ├── memory\n    │  └── constitution.md\n    ├── scripts\n    │  ├──bash    \n    │  │  ├── check-prerequisites.sh\n    │  │  ├── common.sh\n    │  │  ├── create-new-feature.sh\n    │  │  ├── setup-plan.sh\n    │  │  └── update-claude-md.sh\n    │  ├──powershell    \n    │  │  ├── check-prerequisites.ps1\n    │  │  ├── common.ps1\n    │  │  ├── create-new-feature.ps1\n    │  │  ├── setup-plan.ps1\n    │  │  └── update-claude-md.ps1    \n    ├── specs\n    │  └── 001-create-taskify\n    │      └── spec.md\n    └── templates\n        ├── plan-template.md\n        ├── spec-template.md\n        └── tasks-template.md\n```\n\n\n2. **生成一个简洁的短名称**（2-4个词）用于分支：\n\n   - 分析功能描述并提取最有意义的关键词\n   - 创建一个2-4个词的短名称，捕捉功能的本质\n   - 尽可能使用动词-名词格式（例如：\"add-user-auth\"、\"fix-payment-bug\"）\n   - 保留技术术语和缩写（OAuth2、API、JWT等）\n   - 保持简洁但足够描述性，以便一目了然地理解功能\n   - 示例：\n     - \"我想添加用户认证\" → \"user-auth\"\n     - \"为API实现OAuth2集成\" → \"oauth2-api-integration\"\n     - \"创建分析仪表板\" → \"analytics-dashboard\"\n     - \"修复支付处理超时错误\" → \"fix-payment-timeout\"\n\n3. **在创建新分支前检查现有分支**：\n\n   a. 首先获取所有远程分支以确保拥有最新信息：\n\n      ```bash\n   git fetch --all --prune\n      ```\n\n   b. 查找短名称在所有来源中的最高功能编号：\n\n      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`\n      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`\n      - 规范目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录\n\n   c. 确定下一个可用编号：\n\n      - 提取所有三个来源的所有数字\n      - 找到最大数字N\n      - 对于新分支使用N+1\n\n   d. 使用计算出的编号和短名称运行脚本 `create-new-feature.ps1 -Json \"$ARGUMENTS\"`：\n\n      - 传递 `--number N+1` 和 `--short-name \"your-short-name\"` 以及功能描述\n      - Bash示例：`create-new-feature.sh -Json \"$ARGUMENTS\" --json --number 5 --short-name \"user-auth\" \"添加用户认证\"`\n      - PowerShell示例：`create-new-feature.ps1 -Json \"$ARGUMENTS\" -Json -Number 5 -ShortName \"user-auth\" \"添加用户认证\"`\n\n   **重要**：\n\n   - 检查所有三个来源（远程分支、本地分支、规范目录）以找到最高编号\n   - 只匹配具有确切短名称模式的分支/目录\n   - 如果未找到具有此短名称的现有分支/目录，则从编号1开始\n   - 每个功能只能运行一次此脚本\n   - JSON在终端中作为输出提供 - 始终参考它来获取您正在查找的实际内容\n   - JSON输出将包含BRANCH_NAME和SPEC_FILE路径\n   - 对于参数中的单引号如\"I'm Groot\"，使用转义语法：例如'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）\n\n4. 加载 `.specify/templates/spec-template.md` 以了解必需的部分。\n\n5. 遵循此执行流程：\n\n   1. 解析来自输入的用户描述\n      如果为空：错误\"未提供功能描述\"\n   2. 从描述中提取关键概念\n      识别：参与者、动作、数据、约束\n   3. 对于不清楚的方面：\n      - 基于上下文和行业标准做出有根据的猜测\n      - 仅在以下情况下标记[需要澄清：具体问题]：\n        - 选择显著影响功能范围或用户体验\n        - 存在多种合理解释且有不同的含义\n        - 不存在合理的默认值\n      - **限制：最多总共3个[需要澄清]标记**\n      - 按影响优先排序：范围 > 安全/隐私 > 用户体验 > 技术细节\n   4. 填写用户场景与测试部分\n      如果没有清晰的用户流程：错误\"无法确定用户场景\"\n   5. 生成功能性需求\n      每个需求都必须是可测试的\n      对未指定的详细信息使用合理的默认值（在假设部分记录假设）\n   6. 定义成功标准\n      创建可测量的、技术无关的结果\n      包括定量指标（时间、性能、数量）和定性措施（用户满意度、任务完成度）\n      每个标准必须在没有实现细节的情况下可验证\n   7. 识别关键实体（如果涉及数据）\n   8. 返回：成功（规范已准备好进行规划）\n\n6. 使用模板结构将规范写入SPEC_FILE，用从功能描述（参数）派生的具体细节替换占位符，同时保持部分顺序和标题不变。\n\n7. **规范质量验证**：编写初始规范后，根据质量标准对其进行验证：\n\n   a. **创建规范质量检查清单**：使用检查清单模板结构在 `FEATURE_DIR/checklists/requirements.md` 生成一个检查清单文件，参考：[assets/quality-checklist-template.md](assets/quality-checklist-template.md)\n\n\n   b. **运行验证检查**：针对每个检查清单项目审查规范：\n\n      - 对于每个项目，确定它是通过还是失败\n      - 记录发现的具体问题（引用相关的规范部分）\n\n   c. **处理验证结果**：\n\n      - **如果所有项目都通过**：标记检查清单完成并进入步骤6\n\n      - **如果有项目失败（不包括[需要澄清]）**：\n\n        1. 列出失败的项目和具体问题\n        2. 更新规范以解决每个问题\n        3. 重新运行验证直到所有项目通过（最多3次迭代）\n        4. 如果在3次迭代后仍然失败，在检查清单注释中记录剩余问题并向用户发出警告\n\n      - **如果存在[需要澄清]标记**：\n\n        1. 从规范中提取所有[需要澄清：...]标记\n\n        2. **限制检查**：如果存在超过3个标记，则只保留按范围/安全/用户体验影响最重要的3个，并对其余的做出有根据的猜测\n\n        3. 对于每个需要澄清的问题（最多3个），参考[assets/clarification-template.md](assets/clarification-template.md)向用户呈现选项。\n\n        4. **关键 - 表格格式化**：确保markdown表格正确格式化：\n\n           - 使用一致的间距，管道对齐\n           - 每个单元格应在内容周围留有空格：`| 内容 |` 而不是 `|内容|`\n           - 表头分隔符必须至少有3个破折号：`|--------|`\n           - 测试表格在markdown预览中是否正确渲染\n\n        5. 按顺序编号问题（Q1、Q2、Q3 - 最多总共3个）\n\n        6. 在等待响应之前一起呈现所有问题\n\n        7. 等待用户响应他们对所有问题的选择（例如：\"Q1: A, Q2: 自定义 - [详情], Q3: B\"）\n\n        8. 通过用用户的选定或提供的答案替换每个[需要澄清]标记来更新规范\n\n        9. 在所有澄清解决后重新运行验证\n\n   d. **更新检查清单**：每次验证迭代后，使用当前通过/失败状态更新检查清单文件\n\n8. 报告完成情况，包括分支名称、规范文件路径、检查清单结果以及下一阶段（`speckit-clarify` 或 `speckit-plan`）的准备情况。\n\n**注意**：脚本会创建并检出新分支并在写入前初始化规范文件。\n\n## 通用指南\n\n## 快速指南\n\n- 关注用户需要**什么**以及**为什么**\n- 避免如何实现（无技术栈、API、代码结构）\n- 为业务利益相关者而非开发人员编写\n- 不要创建嵌入规范中的任何检查清单。那将是单独的命令\n\n### 部分要求\n\n- **必填部分**：每个功能都必须完成\n- **可选部分**：仅当与功能相关时才包含\n- 当某个部分不适用时，完全删除它（不要留下\"N/A\"）\n\n### 对于AI生成\n\n从用户提示创建此规范时：\n\n1. **做出有根据的猜测**：使用上下文、行业标准和常见模式填补空白\n2. **记录假设**：在假设部分记录合理的默认值\n3. **限制澄清**：最多3个[需要澄清]标记 - 仅用于那些：\n   - 显著影响功能范围或用户体验的关键决策\n   - 具有多种合理解释且不同含义的情况\n   - 缺乏任何合理默认值的情况\n4. **优先考虑澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节\n5. **像测试人员一样思考**：每个模糊的需求都应该未能通过\"可测试且明确\"的检查清单项\n6. **常见的需要澄清区域**（只有在没有合理默认值时）：\n   - 功能范围和边界（包括/排除特定用例）\n   - 用户类型和权限（如果存在多个冲突的解释可能性）\n   - 安全/合规要求（当法律/财务上重要时）\n\n**合理默认值示例**（不要询问这些）：\n\n- 数据保留：领域内的行业标准实践\n- 性能目标：标准网页/移动应用期望，除非另有规定\n- 错误处理：用户友好的消息和适当的回退\n- 认证方法：标准基于会话或OAuth2的Web应用程序\n- 集成模式：RESTful API，除非另有说明\n\n### 成功标准指南\n\n成功标准必须：\n\n1. **可衡量**：包括具体指标（时间、百分比、计数、比率）\n2. **技术无关**：不提及框架、语言、数据库或工具\n3. **以用户为中心**：从用户/业务角度描述结果，而不是系统内部机制\n4. **可验证**：无需知道实现细节即可测试/验证\n\n**良好示例**：\n\n- \"用户可在3分钟内完成结账\"\n- \"系统支持10,000个并发用户\"\n- \"95%的搜索在1秒内返回结果\"\n- \"任务完成率提高40%\"\n\n**不良示例**（实现导向）：\n\n- \"API响应时间低于200毫秒\"（过于技术性，应使用\"用户立即看到结果\"）\n\n- \"数据库可处理1000 TPS\"（实现细节，应使用面向用户的指标）\n\n- \"React组件高效渲染\"（框架特定）\n\n- \"Redis缓存命中率高于80%\"（技术特定）",
        "skills/speckit-specify-zh/assets/clarification-template.md": "## 问题[N]：[主题]\n\n**上下文**：[引用相关的规范部分]\n\n**我们需要知道什么**：[来自需要澄清标记的具体问题]\n\n**建议答案**：\n\n| 选项 | 答案 | 影响 |\n|------|------|------|\n| A    | [第一个建议答案] | [这对功能意味着什么] |\n| B    | [第二个建议答案] | [这对功能意味着什么] |\n| C    | [第三个建议答案] | [这对功能意味着什么] |\n| 自定义 | 提供您的答案 | [解释如何提供自定义输入] |\n\n**您的选择**：_[等待用户响应]_\n",
        "skills/speckit-specify-zh/assets/quality-checklist-template.md": "# 规范质量检查清单：[功能名称]\n\n**目的**：在进入规划阶段前验证规范完整性和质量\n**创建时间**：[日期]\n**功能**：[链接到spec.md]\n\n## 内容质量\n\n- [ ] 不包含实现细节（语言、框架、API）\n- [ ] 聚焦于用户价值和业务需求\n- [ ] 为非技术利益相关者编写\n- [ ] 所有必填部分已完成\n\n## 需求完整性\n\n- [ ] 没有剩余的[需要澄清]标记\n- [ ] 需求是可测试且明确的\n- [ ] 成功标准是可衡量的\n- [ ] 成功标准是技术无关的（不包含实现细节）\n- [ ] 所有验收场景已定义\n- [ ] 边缘情况已识别\n- [ ] 范围明确界定\n- [ ] 已识别依赖关系和假设\n\n## 功能就绪\n\n- [ ] 所有功能性需求都有明确的验收标准\n- [ ] 用户场景涵盖主要流程\n- [ ] 功能满足成功标准中定义的可衡量结果\n- [ ] 没有实现细节泄露到规范中\n\n## 注释\n\n- 标记为不完整的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新规范\n",
        "skills/speckit-specify-zh/assets/spec-template.md": "# 功能规格：[功能名称]\n\n**功能分支**：`[###-feature-name]`  \n**创建时间**：[日期]  \n**状态**：草案  \n**输入**：用户描述：\"$ARGUMENTS\"\n\n## 用户场景与测试 *(必填)*\n\n<!--\n  重要：用户故事应按照重要性排序为用户旅程。\n  每个用户故事/旅程必须是独立可测试的 - 这意味着如果您只实现其中一个，\n  您仍应拥有一个可交付价值的可行MVP（最小可行产品）。\n  \n  为每个故事分配优先级（P1, P2, P3等），其中P1是最重要的。\n  将每个故事视为可以：\n  - 独立开发\n  - 独立测试\n  - 独立部署\n  - 独立向用户展示\n-->\n\n### 用户故事 1 - [简要标题] (优先级: P1)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试 - 例如，\"可以通过[具体操作]完全测试，并交付[具体价值]\"]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n2. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n### 用户故事 2 - [简要标题] (优先级: P2)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n### 用户故事 3 - [简要标题] (优先级: P3)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n[根据需要添加更多用户故事，每个都有分配的优先级]\n\n### 边缘情况\n\n<!--\n  需要操作：本节中的内容是占位符。\n  用正确的边缘情况填充它们。\n-->\n\n- 当[边界条件]发生时会怎样？\n- 系统如何处理[错误场景]？\n\n## 要求 *(必填)*\n\n<!--\n  需要操作：本节中的内容是占位符。\n  用正确的功能要求填充它们。\n-->\n\n### 功能要求\n\n- **FR-001**：系统必须[具体能力，例如，\"允许用户创建账户\"]\n- **FR-002**：系统必须[具体能力，例如，\"验证电子邮件地址\"]  \n- **FR-003**：用户必须能够[关键交互，例如，\"重置密码\"]\n- **FR-004**：系统必须[数据要求，例如，\"持久化用户偏好设置\"]\n- **FR-005**：系统必须[行为，例如，\"记录所有安全事件\"]\n\n*标记不明确要求的示例：*\n\n- **FR-006**：系统必须通过[需要澄清：未指定认证方法 - 电子邮件/密码、SSO、OAuth？]\n- **FR-007**：系统必须保留用户数据[需要澄清：未指定保留期]\n\n### 关键实体 *(如果功能涉及数据则包含)*\n\n- **[实体 1]**：[它代表什么，关键属性（无实现细节）]\n- **[实体 2]**：[它代表什么，与其他实体的关系]\n\n## 成功标准 *(必填)*\n\n<!--\n  需要操作：定义可衡量的成功标准。\n  这些必须是技术无关且可衡量的。\n-->\n\n### 可衡量的结果\n\n- **SC-001**：[可衡量的指标，例如，\"用户可以在2分钟内完成账户创建\"]\n- **SC-002**：[可衡量的指标，例如，\"系统在无降级情况下处理1000个并发用户\"]\n- **SC-003**：[用户满意度指标，例如，\"90%的用户首次尝试即可成功完成主要任务\"]\n- **SC-004**：[业务指标，例如，\"将与[X]相关的支持工单减少50%\"]",
        "skills/speckit-specify-zh/assets/specify/memory/constitution.md": "# [项目名称] 章程\n<!-- 示例：规范章程，任务流章程等 -->\n\n## 核心原则\n\n### [原则_1_名称]\n<!-- 示例：I. 库优先 -->\n[原则_1_描述]\n<!-- 示例：每个功能都以独立库开始；库必须自包含、可独立测试、有文档；需要明确目的 - 没有仅用于组织的库 -->\n\n### [原则_2_名称]\n<!-- 示例：II. CLI 接口 -->\n[原则_2_描述]\n<!-- 示例：每个库都通过 CLI 暴露功能；文本输入/输出协议：stdin/args → stdout，错误 → stderr；支持 JSON + 人类可读格式 -->\n\n### [原则_3_名称]\n<!-- 示例：III. 测试优先（不可协商） -->\n[原则_3_描述]\n<!-- 示例：TDD 强制：编写测试 → 用户批准 → 测试失败 → 然后实现；严格强制红-绿-重构循环 -->\n\n### [原则_4_名称]\n<!-- 示例：IV. 集成测试 -->\n[原则_4_描述]\n<!-- 示例：需要集成测试的重点领域：新库契约测试、契约变更、服务间通信、共享模式 -->\n\n### [原则_5_名称]\n<!-- 示例：V. 可观察性，VI. 版本控制和破坏性变更，VII. 简单性 -->\n[原则_5_描述]\n<!-- 示例：文本 I/O 确保可调试性；需要结构化日志；或：MAJOR.MINOR.BUILD 格式；或：从简单开始，YAGNI 原则 -->\n\n## [部分_2_名称]\n<!-- 示例：附加约束、安全要求、性能标准等 -->\n\n[部分_2_内容]\n<!-- 示例：技术栈要求、合规标准、部署策略等 -->\n\n## [部分_3_名称]\n<!-- 示例：开发工作流程、审查过程、质量门等 -->\n\n[部分_3_内容]\n<!-- 示例：代码审查要求、测试门、部署批准流程等 -->\n\n## 治理\n<!-- 示例：章程优于所有其他实践；修订需要文档、批准、迁移计划 -->\n\n[治理规则]\n<!-- 示例：所有 PR/审查必须验证合规性；复杂性必须有正当理由；使用 [指导文件] 作为运行时开发指导 -->\n\n**版本**：[章程版本] | **批准**：[批准日期] | **最后修订**：[最后修订日期]\n<!-- 示例：版本：2.1.1 | 批准：2025-06-13 | 最后修订：2025-07-16 -->",
        "skills/speckit-specify-zh/assets/specify/templates/agent-file-template.md": "# [项目名称] 开发指南\n\n自动生成自所有功能计划。最后更新：[日期]\n\n## 活动技术\n\n[从所有计划文件中提取]\n\n## 项目结构\n\n```text\n[来自计划的实际结构]\n```\n\n## 命令\n\n[仅限活动技术的命令]\n\n## 代码风格\n\n[特定语言的规范，仅适用于正在使用的语言]\n\n## 最近变更\n\n[最近3个功能及其添加内容]\n\n<!-- 手动添加开始 -->\n<!-- 手动添加结束 -->",
        "skills/speckit-specify-zh/assets/specify/templates/checklist-template.md": "# [检查表类型] 检查表：[功能名称]\n\n**目的**：[此检查表涵盖内容的简要描述]\n**创建时间**：[日期]\n**功能**：[链接到 spec.md 或相关文档]\n\n**注意**：此检查表由 `/speckit.checklist` 命令根据功能上下文和要求生成。\n\n<!-- \n  ============================================================================\n  重要提示：下面的检查表项目仅为示例项目，仅用于说明。\n\n  /speckit.checklist 命令必须根据以下内容替换这些项目：\n  - 用户的具体检查表请求\n  - 来自 spec.md 的功能要求\n  - 来自 plan.md 的技术上下文\n  - 来自 tasks.md 的实现细节\n  \n  不要在生成的检查表文件中保留这些示例项目。\n  ============================================================================\n-->\n\n## [类别 1]\n\n- [ ] CHK001 第一个检查表项目，带有明确的操作\n- [ ] CHK002 第二个检查表项目\n- [ ] CHK003 第三个检查表项目\n\n## [类别 2]\n\n- [ ] CHK004 另一个类别的项目\n- [ ] CHK005 带有特定标准的项目\n- [ ] CHK006 此类别中的最后一个项目\n\n## 备注\n\n- 完成后勾选项目：`[x]`\n- 在线添加评论或发现\n- 链接到相关资源或文档\n- 项目按顺序编号以便于参考",
        "skills/speckit-specify-zh/assets/specify/templates/commands/analyze.md": "---\ndescription: 在任务生成后，对 spec.md、plan.md 和 tasks.md 进行非破坏性的跨工件一致性和质量分析。\nscripts:\n  sh: scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks\n  ps: scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 目标\n\n在实现之前，识别三个核心工件（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、歧义和未充分说明的项目。此命令必须仅在 `/speckit.tasks` 成功生成完整的 `tasks.md` 后运行。\n\n## 操作约束\n\n**严格只读**：**不要**修改任何文件。输出结构化分析报告。提供可选的补救计划（用户必须明确批准后才能手动调用任何后续编辑命令）。\n\n**宪章权威性**：项目宪章（`/memory/constitution.md`）在此分析范围内是**不可协商的**。宪章冲突自动为关键级别，需要调整规格、计划或任务——而不是稀释、重新解释或默默忽略原则。如果原则本身需要更改，必须在 `/speckit.analyze` 之外的单独、明确的宪章更新中进行。\n\n## 执行步骤\n\n### 1. 初始化分析上下文\n\n从仓库根目录运行一次 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS。推导绝对路径：\n\n- SPEC = FEATURE_DIR/spec.md\n- PLAN = FEATURE_DIR/plan.md\n- TASKS = FEATURE_DIR/tasks.md\n\n如果缺少任何必需文件，则中止并显示错误消息（指示用户运行缺少的先决条件命令）。\n对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n### 2. 加载工件（渐进式披露）\n\n仅加载每个工件的最小必要上下文：\n\n**来自 spec.md：**\n\n- 概述/上下文\n- 功能要求\n- 非功能要求\n- 用户故事\n- 边缘情况（如果存在）\n\n**来自 plan.md：**\n\n- 架构/技术栈选择\n- 数据模型引用\n- 阶段\n- 技术约束\n\n**来自 tasks.md：**\n\n- 任务 ID\n- 描述\n- 阶段分组\n- 并行标记 [P]\n- 引用的文件路径\n\n**来自 constitution：**\n\n- 加载 `/memory/constitution.md` 用于原则验证\n\n### 3. 构建语义模型\n\n创建内部表示（不要在输出中包含原始工件）：\n\n- **要求清单**：每个功能+非功能要求带有一个稳定键（根据祈使句派生 slug；例如，\"用户可以上传文件\" → `user-can-upload-file`）\n- **用户故事/动作清单**：具有验收标准的离散用户动作\n- **任务覆盖映射**：将每个任务映射到一个或多个要求或故事（通过关键词/显式引用模式如 ID 或关键词进行推断）\n- **宪章规则集**：提取原则名称和 MUST/SHOULD 规范性陈述\n\n### 4. 检测过程（高效令牌分析）\n\n专注于高信号发现。限制总数为 50 个发现；在溢出摘要中聚合其余发现。\n\n#### A. 重复检测\n\n- 识别近似重复的要求\n- 标记质量较低的措辞以进行合并\n\n#### B. 歧义检测\n\n- 标记缺乏可测量标准的模糊形容词（快速、可扩展、安全、直观、健壮）\n- 标记未解决的占位符（TODO、TKTK、???、`<placeholder>` 等）\n\n#### C. 未充分说明\n\n- 有动词但缺少对象或可测量结果的要求\n- 缺少验收标准对齐的用户故事\n- 引用在规格/计划中未定义的文件或组件的任务\n\n#### D. 宪章对齐\n\n- 任何与 MUST 原则冲突的要求或计划元素\n- 缺少宪章中规定的章节或质量门\n\n#### E. 覆盖差距\n\n- 没有关联任务的要求\n- 没有映射要求/故事的任务\n- 未在任务中体现的非功能要求（例如，性能、安全性）\n\n#### F. 不一致\n\n- 术语漂移（同一概念在不同文件中有不同名称）\n- 计划中引用但在规格中缺失的数据实体（反之亦然）\n- 任务排序矛盾（例如，集成任务在基础设置任务之前但没有依赖注释）\n- 冲突的要求（例如，一个要求 Next.js 而另一个指定 Vue）\n\n### 5. 严重性分配\n\n使用此启发式方法来优先处理发现：\n\n- **关键**：违反宪章 MUST、缺少核心规格工件，或阻塞基本功能的零覆盖要求\n- **高**：重复或冲突的要求、模糊的安全/性能属性、不可测试的验收标准\n- **中**：术语漂移、缺少非功能任务覆盖、未充分说明的边缘情况\n- **低**：样式/措辞改进、不影响执行顺序的次要冗余\n\n### 6. 生成紧凑分析报告\n\n输出一个 Markdown 报告（不写入文件）具有以下结构：\n\n## 规格分析报告\n\n| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |\n|----|----------|----------|-------------|---------|----------------|\n| A1 | 重复 | 高 | spec.md:L120-134 | 两个相似的要求 ... | 合并措辞；保留更清晰的版本 |\n\n（每项发现添加一行；生成以类别首字母为前缀的稳定 ID。）\n\n**覆盖摘要表：**\n\n| 要求键 | 有任务？ | 任务 ID | 备注 |\n|-----------------|-----------|----------|-------|\n\n**宪章对齐问题：**（如果有）\n\n**未映射的任务：**（如果有）\n\n**指标：**\n\n- 总要求\n- 总任务\n- 覆盖率%（有>=1个任务的要求）\n- 歧义计数\n- 重复计数\n- 关键问题计数\n\n### 7. 提供下一步行动\n\n在报告末尾，输出一个简洁的下一步行动块：\n\n- 如果存在关键问题：建议在 `/speckit.implement` 之前解决\n- 如果只有低/中等：用户可以继续，但提供改进建议\n- 提供明确的命令建议：例如，\"使用改进运行 /speckit.specify\"，\"运行 /speckit.plan 调整架构\"，\"手动编辑 tasks.md 添加 'performance-metrics' 的覆盖\"\n\n### 8. 提供补救措施\n\n询问用户：\"您希望我为前 N 个问题建议具体的补救编辑吗？\"（不要自动应用它们。）\n\n## 操作原则\n\n### 上下文效率\n\n- **最小高信号令牌**：专注于可操作的发现，而不是详尽的文档\n- **渐进式披露**：增量加载工件；不要将所有内容倒入分析\n- **高效令牌输出**：限制发现表为 50 行；总结溢出\n- **确定性结果**：在没有更改的情况下重新运行应产生一致的 ID 和计数\n\n### 分析指南\n\n- **永不修改文件**（这是只读分析）\n- **永不虚构缺失部分**（如果缺失，准确报告）\n- **优先处理宪章违规**（这些总是关键的）\n- **使用示例而非详尽规则**（引用具体实例，而非通用模式）\n- **优雅报告零问题**（发出带有覆盖统计的成功报告）\n\n## 上下文\n\n{ARGS}",
        "skills/speckit-specify-zh/assets/specify/templates/commands/checklist.md": "---\ndescription: 根据用户要求为当前功能生成自定义检查表。\nscripts:\n  sh: scripts/bash/check-prerequisites.sh --json\n  ps: scripts/powershell/check-prerequisites.ps1 -Json\n---\n\n## 检查表目的：\"中文的单元测试\"\n\n**关键概念**：检查表是**要求编写的单元测试** - 它们验证特定领域中要求的质量、清晰度和完整性。\n\n**不用于验证/测试**：\n\n- ❌ 不是\"验证按钮正确点击\"\n- ❌ 不是\"测试错误处理是否有效\"\n- ❌ 不是\"确认 API 返回 200\"\n- ❌ 不是检查代码/实现是否符合规格\n\n**用于要求质量验证**：\n\n- ✅ \"是否为所有卡片类型定义了视觉层次要求？\"（完整性）\n- ✅ \"是否用特定的尺寸/定位量化了'显著显示'？\"（清晰度）\n- ✅ \"所有交互元素的悬停状态要求是否一致？\"（一致性）\n- ✅ \"是否为键盘导航定义了可访问性要求？\"（覆盖范围）\n- ✅ \"规格是否定义了徽标图像加载失败时的情况？\"（边缘情况）\n\n**比喻**：如果您的规格是用英语编写的代码，那么检查表就是它的单元测试套件。您正在测试要求是否编写良好、完整、明确并准备好实施 - 而不是测试实现是否有效。\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 执行步骤\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS 列表。\n   - 所有文件路径必须是绝对的。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **澄清意图（动态）**：推导出最多三个初始上下文澄清问题（无预设目录）。它们必须：\n   - 从用户的措辞 + 从规格/计划/任务中提取的信号生成\n   - 仅询问会实质性改变检查表内容的信息\n   - 如果在 `$ARGUMENTS` 中已经明确，则单独跳过\n   - 优先考虑精确性而非广度\n\n   生成算法：\n   1. 提取信号：功能领域关键词（例如，auth, latency, UX, API），风险指标（\"critical\", \"must\", \"compliance\"），利益相关者提示（\"QA\", \"review\", \"security team\"）和明确的交付物（\"a11y\", \"rollback\", \"contracts\"）。\n   2. 将信号聚类到候选关注领域（最多 4 个）按相关性排序。\n   3. 识别可能的受众和时机（作者、审阅者、QA、发布）如果不明确。\n   4. 检测缺失的维度：范围广度、深度/严谨性、风险重点、排除边界、可测量的验收标准。\n   5. 从这些原型中制定问题：\n      - 范围细化（例如，\"这应该包括与 X 和 Y 的集成接触点还是仅限于本地模块正确性？\"）\n      - 风险优先级（例如，\"这些潜在风险领域中哪些应该接受强制门控检查？\"）\n      - 深度校准（例如，\"这是一个轻量级的预提交健全性列表还是正式的发布门？\"）\n      - 受众框架（例如，\"这将仅由作者使用还是在 PR 审阅期间由同行使用？\"）\n      - 边界排除（例如，\"我们应该明确排除本轮的性能调优项目吗？\"）\n      - 场景类别差距（例如，\"未检测到恢复流程——回滚/部分故障路径是否在范围内？\"）\n\n   问题格式规则：\n   - 如果提供选项，生成一个紧凑的表格，列：选项 | 候选 | 重要性原因\n   - 限制最多 A-E 个选项；如果自由形式答案更清晰则省略表格\n   - 永远不要要求用户重述他们已经说过的话\n   - 避免推测性类别（无幻觉）。如果不确定，明确询问：\"确认 X 是否在范围内。\"\n\n   无法交互时的默认值：\n   - 深度：标准\n   - 受众：如果与代码相关则为审阅者（PR）；否则为作者\n   - 关注：前 2 个相关性聚类\n\n   输出问题（标记 Q1/Q2/Q3）。回答后：如果≥2 个场景类别（替代/异常/恢复/非功能性领域）仍不清楚，您可以要求最多两个更有针对性的后续问题（Q4/Q5），每个问题附带一行理由（例如，\"未解决的恢复路径风险\"）。不要超过五个总问题。如果用户明确拒绝更多问题则跳过升级。\n\n3. **理解用户请求**：结合 `$ARGUMENTS` + 澄清答案：\n   - 推导检查表主题（例如，安全、审阅、部署、用户体验）\n   - 整合用户提到的明确必备项目\n   - 将焦点选择映射到类别脚手架\n   - 从规格/计划/任务中推断任何缺失的上下文（不要幻觉）\n\n4. **加载功能上下文**：从 FEATURE_DIR 读取：\n   - spec.md：功能要求和范围\n   - plan.md（如果存在）：技术细节、依赖关系\n   - tasks.md（如果存在）：实施任务\n\n   **上下文加载策略**：\n   - 仅加载与活跃关注领域相关的必要部分（避免完整文件转储）\n   - 更喜欢将长段落总结为简洁的场景/要求要点\n   - 使用渐进式披露：仅在检测到差距时添加后续检索\n   - 如果源文档很大，生成中间摘要项目而不是嵌入原始文本\n\n5. **生成检查表** - 创建\"要求的单元测试\"：\n   - 如果不存在则创建 `FEATURE_DIR/checklists/` 目录\n   - 生成唯一的检查表文件名：\n     - 使用基于领域的简短描述性名称（例如，`ux.md`, `api.md`, `security.md`）\n     - 格式：`[domain].md`\n     - 如果文件存在，则追加到现有文件\n   - 从 CHK001 开始顺序编号项目\n   - 每个 `/speckit.checklist` 运行创建一个新文件（从不覆盖现有检查表）\n\n   **核心原则 - 测试要求，而不是实现**：\n   每个检查表项目必须评估要求本身：\n   - **完整性**：所有必要的要求是否存在？\n   - **清晰度**：要求是否明确且具体？\n   - **一致性**：要求是否相互对齐？\n   - **可测量性**：要求是否可以客观验证？\n   - **覆盖范围**：是否解决了所有场景/边缘情况？\n\n   **类别结构** - 按要求质量维度分组项目：\n   - **要求完整性**（是否记录了所有必要的要求？）\n   - **要求清晰度**（要求是否具体且明确？）\n   - **要求一致性**（要求是否对齐而无冲突？）\n   - **验收标准质量**（成功标准是否可测量？）\n   - **场景覆盖**（是否解决了所有流程/案例？）\n   - **边缘情况覆盖**（是否定义了边界条件？）\n   - **非功能性要求**（性能、安全性、可访问性等 - 是否指定？）\n   - **依赖关系和假设**（是否记录和验证？）\n   - **歧义和冲突**（需要澄清什么？）\n\n   **如何编写检查表项目 - \"英语的单元测试\"**：\n\n   ❌ **错误**（测试实现）：\n   - \"验证着陆页显示 3 个剧集卡片\"\n   - \"测试桌面端悬停状态是否有效\"\n   - \"确认徽标点击导航到主页\"\n\n   ✅ **正确**（测试要求质量）：\n   - \"是否明确指定了特色剧集的确切数量和布局？\" [完整性]\n   - \"是否用特定的尺寸/定位量化了'显著显示'？\" [清晰度]\n   - \"所有交互元素的悬停状态要求是否一致？\" [一致性]\n   - \"是否为所有交互式 UI 定义了键盘导航要求？\" [覆盖范围]\n   - \"当徽标图像加载失败时是否指定了回退行为？\" [边缘情况]\n   - \"是否为异步剧集数据定义了加载状态？\" [完整性]\n   - \"规格是否定义了竞争 UI 元素的视觉层次？\" [清晰度]\n\n   **项目结构**：\n   每个项目应遵循此模式：\n   - 询问要求质量的问题格式\n   - 关注规格/计划中编写（或未编写）的内容\n   - 包括质量维度在括号中 [完整性/清晰度/一致性等]\n   - 检查现有要求时引用规格部分 `[Spec §X.Y]`\n   - 使用 `[Gap]` 标记检查缺失的要求\n\n   **按质量维度的示例**：\n\n   完整性：\n   - \"是否为所有 API 故障模式定义了错误处理要求？ [Gap]\"\n   - \"是否为所有交互元素指定了可访问性要求？ [完整性]\"\n   - \"是否为响应式布局定义了移动断点要求？ [Gap]\"\n\n   清晰度：\n   - \"是否用特定的时间阈值量化了'快速加载'？ [清晰度, Spec §NFR-2]\"\n   - \"是否明确定义了'相关剧集'的选择标准？ [清晰度, Spec §FR-5]\"\n   - \"是否用可测量的视觉属性定义了'显著'？ [歧义, Spec §FR-4]\"\n\n   一致性：\n   - \"所有页面的导航要求是否对齐？ [一致性, Spec §FR-10]\"\n   - \"着陆页和详情页的卡片组件要求是否一致？ [一致性]\"\n\n   覆盖范围：\n   - \"是否为零状态场景（无剧集）定义了要求？ [覆盖范围, 边缘情况]\"\n   - \"是否解决了并发用户交互场景？ [覆盖范围, Gap]\"\n   - \"是否为部分数据加载失败指定了要求？ [覆盖范围, 异常流程]\"\n\n   可测量性：\n   - \"视觉层次要求是否可测量/可测试？ [验收标准, Spec §FR-1]\"\n   - \"是否可以客观验证'平衡的视觉权重'？ [可测量性, Spec §FR-2]\"\n\n   **场景分类和覆盖**（要求质量重点）：\n   - 检查是否存在要求：主要、替代、异常/错误、恢复、非功能性场景\n   - 对于每个场景类别，询问：\"[场景类型] 要求是否完整、清晰且一致？\"\n   - 如果场景类别缺失：\"[场景类型] 要求是故意排除还是缺失？ [Gap]\"\n   - 包括状态变更时的弹性/回滚：\"是否为迁移失败定义了回滚要求？ [Gap]\"\n\n   **可追溯性要求**：\n   - 最低要求：≥80% 的项目必须至少包含一个可追溯性引用\n   - 每个项目应引用：规格部分 `[Spec §X.Y]`，或使用标记：`[Gap]`、`[Ambiguity]`、`[Conflict]`、`[Assumption]`\n   - 如果不存在 ID 系统：\"是否建立了要求和验收标准 ID 方案？ [可追溯性]\"\n\n   **表面和解决问题**（要求质量问题）：\n   询问有关要求本身的问题：\n   - 歧义：\"'快速' 一词是否用具体指标量化？ [歧义, Spec §NFR-1]\"\n   - 冲突：\"§FR-10 和 §FR-10a 中的导航要求是否冲突？ [冲突]\"\n   - 假设：\"'始终可用的播客 API' 假设是否已验证？ [假设]\"\n   - 依赖关系：\"是否记录了外部播客 API 要求？ [依赖关系, Gap]\"\n   - 缺失定义：\"是否用可测量的标准定义了'视觉层次'？ [Gap]\"\n\n   **内容整合**：\n   - 软上限：如果原始候选项目 > 40，按风险/影响优先排序\n   - 合并检查相同要求方面的近似重复项\n   - 如果 >5 个低影响边缘情况，创建一个项目：\"边缘情况 X、Y、Z 是否在要求中解决？ [覆盖范围]\"\n\n   **🚫 绝对禁止** - 这些使其成为实现测试，而不是要求测试：\n   - ❌ 任何以\"验证\"、\"测试\"、\"确认\"、\"检查\" + 实现行为开头的项目\n   - ❌ 引用代码执行、用户操作、系统行为\n   - ❌ \"正确显示\"、\"正常工作\"、\"按预期功能\"\n   - ❌ \"点击\"、\"导航\"、\"渲染\"、\"加载\"、\"执行\"\n   - ❌ 测试用例、测试计划、QA 程序\n   - ❌ 实现细节（框架、API、算法）\n\n   **✅ 必需模式** - 这些测试要求质量：\n   - ✅ \"是否为 [场景] 定义/指定/记录了 [要求类型]？\"\n   - ✅ \"是否用具体标准量化/澄清了 [模糊术语]？\"\n   - ✅ \"[部分 A] 和 [部分 B] 的要求是否一致？\"\n   - ✅ \"是否可以客观测量/验证 [要求]？\"\n   - ✅ \"要求中是否解决了 [边缘情况/场景]？\"\n   - ✅ \"规格是否定义了 [缺失方面]？\"\n\n6. **结构参考**：按照 `templates/checklist-template.md` 中的规范模板生成检查表，包括标题、元部分、类别标题和 ID 格式。如果模板不可用，使用：H1 标题、目的/创建的元行、包含 `- [ ] CHK### <要求项目>` 行的 `##` 类别部分，全局递增 ID 从 CHK001 开始。\n\n7. **报告**：输出创建的检查表的完整路径、项目计数，并提醒用户每次运行都会创建一个新文件。总结：\n   - 选择的关注领域\n   - 深度级别\n   - 参与者/时机\n   - 任何包含的用户明确指定的必备项目\n\n**重要**：每个 `/speckit.checklist` 命令调用都使用简短的描述性名称创建检查表文件，除非文件已存在。这允许：\n\n- 不同类型的多个检查表（例如，`ux.md`, `test.md`, `security.md`）\n- 简单、易记的文件名，指示检查表目的\n- 在 `checklists/` 文件夹中轻松识别和导航\n\n为避免混乱，使用描述性类型并在完成后清理过时的检查表。\n\n## 示例检查表类型和示例项目\n\n**用户体验要求质量：** `ux.md`\n\n示例项目（测试要求，而不是实现）：\n\n- \"是否用可测量的标准定义了视觉层次要求？ [清晰度, Spec §FR-1]\"\n- \"是否明确定义了 UI 元素的数量和定位？ [完整性, Spec §FR-1]\"\n- \"交互状态要求（悬停、焦点、活动）是否一致定义？ [一致性]\"\n- \"是否为所有交互元素指定了可访问性要求？ [覆盖范围, Gap]\"\n- \"图像加载失败时是否定义了回退行为？ [边缘情况, Gap]\"\n- \"是否可以客观测量'显著显示'？ [可测量性, Spec §FR-4]\"\n\n**API 要求质量：** `api.md`\n\n示例项目：\n\n- \"是否为所有故障场景指定了错误响应格式？ [完整性]\"\n- \"是否用具体阈值量化了速率限制要求？ [清晰度]\"\n- \"所有端点的身份验证要求是否一致？ [一致性]\"\n- \"是否为外部依赖关系定义了重试/超时要求？ [覆盖范围, Gap]\"\n- \"版本控制策略是否在要求中记录？ [Gap]\"\n\n**性能要求质量：** `performance.md`\n\n示例项目：\n\n- \"是否用具体指标量化了性能要求？ [清晰度]\"\n- \"是否为所有关键用户旅程定义了性能目标？ [覆盖范围]\"\n- \"是否为不同负载条件指定了性能要求？ [完整性]\"\n- \"是否可以客观测量性能要求？ [可测量性]\"\n- \"是否为高负载场景定义了降级要求？ [边缘情况, Gap]\"\n\n**安全要求质量：** `security.md`\n\n示例项目：\n\n- \"是否为所有受保护资源指定了身份验证要求？ [覆盖范围]\"\n- \"是否为敏感信息定义了数据保护要求？ [完整性]\"\n- \"威胁模型是否记录并与要求对齐？ [可追溯性]\"\n- \"安全要求是否与合规义务一致？ [一致性]\"\n- \"是否定义了安全故障/违规响应要求？ [Gap, 异常流程]\"\n\n## 反例：不要做的事情\n\n**❌ 错误 - 这些测试实现，而不是要求：**\n\n```markdown\n- [ ] CHK001 - 验证着陆页显示 3 个剧集卡片 [Spec §FR-001]\n- [ ] CHK002 - 测试桌面端悬停状态是否正确工作 [Spec §FR-003]\n- [ ] CHK003 - 确认徽标点击导航到主页 [Spec §FR-010]\n- [ ] CHK004 - 检查相关剧集部分显示 3-5 个项目 [Spec §FR-005]\n```\n\n**✅ 正确 - 这些测试要求质量：**\n\n```markdown\n- [ ] CHK001 - 是否明确定义了特色剧集的数量和布局？ [完整性, Spec §FR-001]\n- [ ] CHK002 - 是否为所有交互元素一致定义了悬停状态要求？ [一致性, Spec §FR-003]\n- [ ] CHK003 - 是否为所有可点击品牌元素明确了导航要求？ [清晰度, Spec §FR-010]\n- [ ] CHK004 - 是否记录了相关剧集的选择标准？ [Gap, Spec §FR-005]\n- [ ] CHK005 - 是否为异步剧集数据定义了加载状态要求？ [Gap]\n- [ ] CHK006 - 是否可以客观测量\"视觉层次\"要求？ [可测量性, Spec §FR-001]\n```\n\n**主要区别：**\n\n- 错误：测试系统是否正常工作\n- 正确：测试要求是否编写正确\n- 错误：行为验证\n- 正确：要求质量验证\n- 错误：\"它是否做 X？\"\n- 正确：\"X 是否明确定义？\"",
        "skills/speckit-specify-zh/assets/specify/templates/commands/clarify.md": "---\ndescription: 通过提出最多 5 个高度针对性的澄清问题并将其答案编码回规格中，识别当前功能规格中未充分说明的领域。\nscripts:\n   sh: scripts/bash/check-prerequisites.sh --json --paths-only\n   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n目标：检测并减少活动功能规格中的歧义或缺失决策点，并将澄清直接记录在规格文件中。\n\n注意：此澄清工作流程预计在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确表示他们正在跳过澄清（例如，探索性刺探），您可以继续，但必须警告下游返工风险会增加。\n\n执行步骤：\n\n1. 从仓库根目录运行一次 `{SCRIPT}`（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON 负载字段：\n   - `FEATURE_DIR`\n   - `FEATURE_SPEC`\n   - （可选捕获 `IMPL_PLAN`, `TASKS` 用于未来的链式流程。）\n   - 如果 JSON 解析失败，则中止并指示用户重新运行 `/speckit.specify` 或验证功能分支环境。\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. 加载当前规格文件。使用此分类法执行结构化歧义和覆盖扫描。对于每个类别，标记状态：清晰 / 部分 / 缺失。生成用于优先级排序的内部覆盖图（除非不问问题，否则不要输出原始图）。\n\n   功能范围和行为：\n   - 核心用户目标和成功标准\n   - 明确的范围外声明\n   - 用户角色 / 人物区分\n\n   领域和数据模型：\n   - 实体、属性、关系\n   - 身份和唯一性规则\n   - 生命周期/状态转换\n   - 数据量 / 规模假设\n\n   交互和用户体验流程：\n   - 关键用户旅程 / 序列\n   - 错误/空/加载状态\n   - 可访问性或本地化注释\n\n   非功能性质量属性：\n   - 性能（延迟、吞吐量目标）\n   - 可扩展性（水平/垂直、限制）\n   - 可靠性和可用性（正常运行时间、恢复期望）\n   - 可观察性（日志、指标、跟踪信号）\n   - 安全性和隐私（认证/授权、数据保护、威胁假设）\n   - 合规性 / 监管约束（如果有）\n\n   集成和外部依赖：\n   - 外部服务/API 和故障模式\n   - 数据导入/导出格式\n   - 协议/版本假设\n\n   边缘情况和故障处理：\n   - 负面场景\n   - 速率限制 / 节流\n   - 冲突解决（例如，并发编辑）\n\n   约束和权衡：\n   - 技术约束（语言、存储、托管）\n   - 明确的权衡或被拒绝的替代方案\n\n   术语和一致性：\n   - 规范术语表\n   - 避免的同义词 / 废弃术语\n\n   完成信号：\n   - 验收标准可测试性\n   - 可测量的完成定义风格指标\n\n   杂项 / 占位符：\n   - TODO 标记 / 未解决的决策\n   - 缺乏量化的模糊形容词（\"健壮的\"、\"直观的\"）\n\n   对于状态为部分或缺失的每个类别，添加一个候选问题机会，除非：\n   - 澄清不会实质性改变实施或验证策略\n   - 信息最好推迟到规划阶段（内部记录）\n\n3. 生成（内部）优先级候选澄清问题队列（最多 5 个）。不要一次性输出所有问题。应用这些约束：\n    - 整个会话最多 10 个问题。\n    - 每个问题必须可以通过以下方式回答：\n       - 短的多项选择（2-5 个不同的、互斥的选项），或\n       - 一个单词 / 短语答案（明确约束：\"答案 <=5 个单词\"）。\n    - 仅包括其答案实质性影响架构、数据建模、任务分解、测试设计、用户体验行为、运营准备或合规性验证的问题。\n    - 确保类别覆盖平衡：尝试首先覆盖最高影响的未解决类别；避免在单个高影响领域（例如，安全态势）未解决时问两个低影响问题。\n    - 排除已经回答的问题、琐碎的风格偏好或计划级执行细节（除非阻塞正确性）。\n    - 优先考虑减少下游返工风险或防止不一致验收测试的澄清。\n    - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。\n\n4. 顺序提问循环（交互式）：\n    - 一次只提出一个问题。\n    - 对于多项选择问题：\n       - **分析所有选项**并根据以下确定**最合适的选项**：\n          - 项目类型的最佳实践\n          - 类似实现中的常见模式\n          - 风险降低（安全性、性能、可维护性）\n          - 与规格中可见的任何明确项目目标或约束对齐\n       - 突出显示您的**推荐选项**在顶部，并提供明确的理由（1-2 句解释为什么这是最佳选择）。\n       - 格式为：`**推荐：** 选项 [X] - <理由>`\n       - 然后将所有选项呈现为 Markdown 表格：\n\n       | 选项 | 描述 |\n       |--------|-------------|\n       | A | <选项 A 描述> |\n       | B | <选项 B 描述> |\n       | C | <选项 C 描述>（根据需要添加 D/E 至多 5 个） |\n       | 简短 | 提供不同的简短答案（<=5 个单词）（仅在自由形式替代方案适当时包含） |\n\n       - 表格后添加：`您可以回复选项字母（例如，\"A\"），通过说\"yes\"或\"recommended\"接受推荐，或提供您自己的简短答案。`\n    - 对于简短答案风格（无有意义的离散选项）：\n       - 提供您的**建议答案**基于最佳实践和上下文。\n       - 格式为：`**建议：** <您的建议答案> - <简要理由>`\n       - 然后输出：`格式：简短答案（<=5 个单词）。您可以通过说\"yes\"或\"suggested\"接受建议，或提供您自己的答案。`\n    - 用户回答后：\n       - 如果用户回复\"yes\"、\"recommended\"或\"suggested\"，使用您之前声明的推荐/建议作为答案。\n       - 否则，验证答案映射到一个选项或符合 <=5 个单词的约束。\n       - 如果模糊，要求快速澄清（计数仍属于同一问题；不要前进）。\n       - 一旦满意，将其记录在工作内存中（尚不写入磁盘）并移至下一个排队问题。\n    - 停止进一步提问当：\n       - 所有关键歧义提前解决（剩余排队项目变得不必要），或\n       - 用户发出完成信号（\"done\"、\"good\"、\"no more\"），或\n       - 您达到 5 个已问问题。\n    - 永远不要提前透露未来排队的问题。\n    - 如果开始时没有有效问题，立即报告没有关键歧义。\n\n5. 每个接受答案后的集成（增量更新方法）：\n    - 维护规格的内存表示（启动时加载一次）加上原始文件内容。\n    - 对于此会话中的第一个集成答案：\n       - 确保存在 `## Clarifications` 部分（如果缺失，则在规格模板中最高级上下文/概述部分之后创建）。\n       - 在其下创建（如果不存在）一个 `### Session YYYY-MM-DD` 子标题用于今天。\n    - 接受后立即追加一个项目符号行：`- Q: <问题> → A: <最终答案>`。\n    - 然后立即将澄清应用到最合适的部分：\n       - 功能歧义 → 更新或在功能要求中添加项目符号。\n       - 用户交互 / 行为者区分 → 更新用户故事或行为者子部分（如果存在）与澄清的角色、约束或场景。\n       - 数据形状 / 实体 → 更新数据模型（添加字段、类型、关系）保持排序；简洁地记录添加的约束。\n       - 非功能性约束 → 在非功能性 / 质量属性部分添加/修改可测量标准（将模糊形容词转换为指标或明确目标）。\n       - 边缘情况 / 负面流程 → 在边缘情况 / 错误处理下添加新项目符号（或创建此类子部分如果模板提供占位符）。\n       - 术语冲突 → 规范化整个规格中的术语；仅在必要时保留原始术语，添加`(以前称为\"X\")`一次。\n    - 如果澄清使早期模糊声明无效，则替换该声明而不是重复；不留过时的矛盾文本。\n    - 每次集成后保存规格文件以最小化上下文丢失风险（原子覆盖）。\n    - 保持格式：不要重新排序无关部分；保持标题层次结构完整。\n    - 保持每个插入的澄清最小且可测试（避免叙述性漂移）。\n\n6. 验证（每次写入后执行加上最终通过）：\n   - 澄清会话包含每个接受答案的一个项目符号（无重复）。\n   - 总问（接受）问题 ≤ 5。\n   - 更新部分不包含新的答案应该解决的模糊占位符。\n   - 无矛盾的早期声明保留（扫描移除的无效替代选择）。\n   - Markdown 结构有效；仅允许新标题：`## Clarifications`, `### Session YYYY-MM-DD`。\n   - 术语一致性：所有更新部分使用相同的规范术语。\n\n7. 将更新的规格写回 `FEATURE_SPEC`。\n\n8. 报告完成（提问循环结束或提前终止后）：\n   - 问和回答的问题数量。\n   - 更新规格的路径。\n   - 触及的部分（列出名称）。\n   - 覆盖摘要表列出每个分类类别，状态：已解决（之前部分/缺失并已解决）、推迟（超出问题配额或更适合规划）、清晰（已足够）、未解决（仍部分/缺失但影响低）。\n   - 如果有任何未解决或推迟的，建议是否继续到 `/speckit.plan` 或稍后再次运行 `/speckit.clarify`。\n   - 建议的下一个命令。\n\n行为规则：\n\n- 如果未发现有意义的歧义（或所有潜在问题都是低影响的），回应：\"未检测到值得正式澄清的关键歧义。\"并建议继续。\n- 如果规格文件缺失，指示用户先运行 `/speckit.specify`（不要在此处创建新规格）。\n- 永远不要超过 5 个总问问题（澄清重试单个问题不计入新问题）。\n- 避免推测性技术栈问题，除非缺失会阻塞功能清晰度。\n- 尊重用户提前终止信号（\"stop\"、\"done\"、\"proceed\"）。\n- 如果由于完全覆盖而未问问题，输出紧凑的覆盖摘要（所有类别清晰）然后建议前进。\n- 如果配额达到但仍有未解决的高影响类别，明确标记它们为推迟并附上理由。\n\n优先级上下文：{ARGS}",
        "skills/speckit-specify-zh/assets/specify/templates/commands/constitution.md": "---\ndescription: 根据交互式或提供的原则输入创建或更新项目宪章，确保所有依赖模板保持同步\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n您正在更新位于 `/memory/constitution.md` 的项目宪章。此文件是一个模板，包含方括号中的占位符标记（例如 `[PROJECT_NAME]`, `[PRINCIPLE_1_NAME]`）。您的工作是 (a) 收集/推导具体值，(b) 精确填充模板，以及 (c) 传播任何修订到依赖工件。\n\n遵循此执行流程：\n\n1. 加载位于 `/memory/constitution.md` 的现有宪章模板。\n   - 识别形式为 `[ALL_CAPS_IDENTIFIER]` 的每个占位符标记。\n   **重要**：用户可能需要比模板中使用的更少或更多的原则。如果指定了数量，请尊重 - 遵循通用模板。您将相应地更新文档。\n\n2. 收集/推导占位符的值：\n   - 如果用户输入（对话）提供了值，则使用它。\n   - 否则从现有仓库上下文（README、文档、先前的宪章版本（如果嵌入））推断。\n   - 对于治理日期：`RATIFICATION_DATE` 是原始采用日期（如果未知则询问或标记 TODO），`LAST_AMENDED_DATE` 是今天如果进行了更改，否则保持先前日期。\n   - `CONSTITUTION_VERSION` 必须根据语义版本规则递增：\n     - MAJOR：向后不兼容的治理/原则删除或重新定义。\n     - MINOR：添加新原则/部分或实质性扩展指导。\n     - PATCH：澄清、措辞、拼写错误修复、非语义性改进。\n   - 如果版本提升类型不明确，在最终确定前提出理由。\n\n3. 起草更新的宪章内容：\n   - 用具体文本替换每个占位符（除了项目选择尚未定义的故意保留的模板槽位 - 明确说明任何保留的槽位）。\n   - 保持标题层次结构，注释可以在替换后删除，除非它们仍然提供澄清指导。\n   - 确保每个原则部分：简洁的名称行，段落（或项目符号列表）捕获不可协商的规则，如果不是显而易见则提供明确的理由。\n   - 确保治理部分列出修订程序、版本政策和合规性审查期望。\n\n4. 一致性传播检查表（将先前的检查表转换为积极验证）：\n   - 读取 `/templates/plan-template.md` 并确保任何\"宪章检查\"或规则与更新的原则对齐。\n   - 读取 `/templates/spec-template.md` 以对齐范围/要求 - 如果宪章添加/删除了强制性部分或约束则更新。\n   - 读取 `/templates/tasks-template.md` 并确保任务分类反映新增或删除的原则驱动任务类型（例如，可观察性、版本控制、测试纪律）。\n   - 读取 `/templates/commands/*.md` 中的每个命令文件（包括此文件）以验证没有过时的引用（仅当需要通用指导时保留特定代理名称如 CLAUDE）。\n   - 读取任何运行时指导文档（例如，`README.md`, `docs/quickstart.md`，或特定代理指导文件（如果存在））。更新对更改原则的引用。\n\n5. 生成同步影响报告（在更新后作为 HTML 注释预置在宪章文件顶部）：\n   - 版本变更：旧 → 新\n   - 修改的原则列表（旧标题 → 新标题如果重命名）\n   - 添加的部分\n   - 删除的部分\n   - 需要更新的模板（✅ 已更新 / ⚠ 待处理）及文件路径\n   - 如果有任何占位符故意推迟则列出。\n\n6. 最终输出前的验证：\n   - 没有剩余的未解释括号标记。\n   - 版本行与报告匹配。\n   - 日期为 ISO 格式 YYYY-MM-DD。\n   - 原则是陈述性的、可测试的，并且没有模糊语言（\"应该\" → 在适当时替换为 MUST/SHOULD 理由）。\n\n7. 将完成的宪章写回 `/memory/constitution.md`（覆盖）。\n\n8. 向用户输出最终摘要：\n   - 新版本和提升理由。\n   - 任何标记为手动跟进的文件。\n   - 建议的提交消息（例如，`docs: 修订宪章至 vX.Y.Z（原则添加 + 治理更新）`）。\n\n格式和样式要求：\n\n- 完全按照模板中的 Markdown 标题使用（不要降级/升级级别）。\n- 包装长理由行以保持可读性（理想情况下 <100 个字符），但不要用尴尬的断行强制执行。\n- 在部分之间保持单个空行。\n- 避免尾随空格。\n\n如果用户提供部分更新（例如，仅一个原则修订），仍执行验证和版本决策步骤。\n\n如果关键信息缺失（例如，批准日期真正未知），插入 `TODO(<FIELD_NAME>): explanation` 并在同步影响报告的推迟项目下列出。\n\n不要创建新模板；始终在现有的 `/memory/constitution.md` 文件上操作。",
        "skills/speckit-specify-zh/assets/specify/templates/commands/implement.md": "---\ndescription: 通过处理和执行 tasks.md 中定义的所有任务来执行实现计划\nscripts:\n  sh: scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks\n  ps: scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. 从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **检查检查表状态**（如果 FEATURE_DIR/checklists/ 存在）：\n   - 扫描 checklists/ 目录中的所有检查表文件\n   - 对于每个检查表，计数：\n     - 总项目：所有匹配 `- [ ]` 或 `- [X]` 或 `- [x]` 的行\n     - 完成项目：匹配 `- [X]` 或 `- [x]` 的行\n     - 未完成项目：匹配 `- [ ]` 的行\n   - 创建状态表：\n\n     ```text\n     | 检查表 | 总计 | 已完成 | 未完成 | 状态 |\n     |-----------|-------|-----------|------------|--------|\n     | ux.md     | 12    | 12        | 0          | ✓ 通过 |\n     | test.md   | 8     | 5         | 3          | ✗ 失败 |\n     | security.md | 6   | 6         | 0          | ✓ 通过 |\n     ```\n\n   - 计算总体状态：\n     - **通过**：所有检查表都有 0 个未完成项目\n     - **失败**：一个或多个检查表有未完成项目\n\n   - **如果有任何检查表未完成**：\n     - 显示包含未完成项目计数的表格\n     - **停止**并询问：\"一些检查表未完成。您是否仍要继续执行实现？(yes/no)\"\n     - 等待用户响应后再继续\n     - 如果用户说\"no\"或\"wait\"或\"stop\"，则停止执行\n     - 如果用户说\"yes\"或\"proceed\"或\"continue\"，则继续到步骤 3\n\n   - **如果所有检查表都完成**：\n     - 显示表格显示所有检查表已通过\n     - 自动继续到步骤 3\n\n3. 加载和分析实现上下文：\n   - **必需**：读取 tasks.md 以获取完整的任务列表和执行计划\n   - **必需**：读取 plan.md 以获取技术栈、架构和文件结构\n   - **如果存在**：读取 data-model.md 以获取实体和关系\n   - **如果存在**：读取 contracts/ 以获取 API 规范和测试要求\n   - **如果存在**：读取 research.md 以获取技术决策和约束\n   - **如果存在**：读取 quickstart.md 以获取集成场景\n\n4. **项目设置验证**：\n   - **必需**：根据实际项目设置创建/验证忽略文件：\n\n   **检测和创建逻辑**：\n   - 检查以下命令是否成功以确定仓库是否为 git 仓库（如果是则创建/验证 .gitignore）：\n\n     ```sh\n     git rev-parse --git-dir 2>/dev/null\n     ```\n\n   - 检查是否存在 Dockerfile* 或 Docker 在 plan.md 中 → 创建/验证 .dockerignore\n   - 检查是否存在 .eslintrc* 或 eslint.config.* → 创建/验证 .eslintignore\n   - 检查是否存在 .prettierrc* → 创建/验证 .prettierignore\n   - 检查是否存在 .npmrc 或 package.json → 创建/验证 .npmignore（如果发布）\n   - 检查是否存在 terraform 文件 (*.tf) → 创建/验证 .terraformignore\n   - 检查是否需要 .helmignore（存在 helm 图表）→ 创建/验证 .helmignore\n\n   **如果忽略文件已存在**：验证它包含基本模式，仅追加缺失的关键模式\n   **如果忽略文件缺失**：创建包含检测技术的完整模式集\n\n   **按技术的常见模式**（来自 plan.md 技术栈）：\n   - **Node.js/JavaScript/TypeScript**：`node_modules/`, `dist/`, `build/`, `*.log`, `.env*`\n   - **Python**：`__pycache__/`, `*.pyc`, `.venv/`, `venv/`, `dist/`, `*.egg-info/`\n   - **Java**：`target/`, `*.class`, `*.jar`, `.gradle/`, `build/`\n   - **C#/.NET**：`bin/`, `obj/`, `*.user`, `*.suo`, `packages/`\n   - **Go**：`*.exe`, `*.test`, `vendor/`, `*.out`\n   - **Ruby**：`.bundle/`, `log/`, `tmp/`, `*.gem`, `vendor/bundle/`\n   - **PHP**：`vendor/`, `*.log`, `*.cache`, `*.env`\n   - **Rust**：`target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`\n   - **Kotlin**：`build/`, `out/`, `.gradle/`, `.idea/`, `*.class`, `*.jar`, `*.iml`, `*.log`, `.env*`\n   - **C++**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.so`, `*.a`, `*.exe`, `*.dll`, `.idea/`, `*.log`, `.env*`\n   - **C**：`build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.a`, `*.so`, `*.exe`, `Makefile`, `config.log`, `.idea/`, `*.log`, `.env*`\n   - **Swift**：`.build/`, `DerivedData/`, `*.swiftpm/`, `Packages/`\n   - **R**：`.Rproj.user/`, `.Rhistory`, `.RData`, `.Ruserdata`, `*.Rproj`, `packrat/`, `renv/`\n   - **通用**：`.DS_Store`, `Thumbs.db`, `*.tmp`, `*.swp`, `.vscode/`, `.idea/`\n\n   **工具特定模式**：\n   - **Docker**：`node_modules/`, `.git/`, `Dockerfile*`, `.dockerignore`, `*.log*`, `.env*`, `coverage/`\n   - **ESLint**：`node_modules/`, `dist/`, `build/`, `coverage/`, `*.min.js`\n   - **Prettier**：`node_modules/`, `dist/`, `build/`, `coverage/`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`\n   - **Terraform**：`.terraform/`, `*.tfstate*`, `*.tfvars`, `.terraform.lock.hcl`\n   - **Kubernetes/k8s**：`*.secret.yaml`, `secrets/`, `.kube/`, `kubeconfig*`, `*.key`, `*.crt`\n\n5. 解析 tasks.md 结构并提取：\n   - **任务阶段**：设置、测试、核心、集成、完善\n   - **任务依赖**：顺序与并行执行规则\n   - **任务详情**：ID、描述、文件路径、并行标记 [P]\n   - **执行流程**：顺序和依赖要求\n\n6. 按照任务计划执行实现：\n   - **阶段执行**：完成每个阶段后再进入下一个\n   - **尊重依赖**：按顺序运行顺序任务，并行任务 [P] 可以一起运行  \n   - **遵循 TDD 方法**：在相应的实现任务之前执行测试任务\n   - **基于文件的协调**：影响相同文件的任务必须顺序运行\n   - **验证检查点**：在继续之前验证每个阶段的完成情况\n\n7. 实现执行规则：\n   - **首先设置**：初始化项目结构、依赖、配置\n   - **测试优先于代码**：如果需要为契约、实体和集成场景编写测试\n   - **核心开发**：实现模型、服务、CLI 命令、端点\n   - **集成工作**：数据库连接、中间件、日志、外部服务\n   - **完善和验证**：单元测试、性能优化、文档\n\n8. 进度跟踪和错误处理：\n   - 在每个完成的任务后报告进度\n   - 如果任何非并行任务失败则停止执行\n   - 对于并行任务 [P]，继续执行成功的任务，报告失败的任务\n   - 提供清晰的错误消息和调试上下文\n   - 如果实现无法继续则建议下一步\n   - **重要** 对于完成的任务，确保在任务文件中标记为 [X]。\n\n9. 完成验证：\n   - 验证所有必需任务已完成\n   - 检查实现的功能是否与原始规格匹配\n   - 验证测试通过且覆盖率符合要求\n   - 确认实现遵循技术计划\n   - 报告最终状态和已完成工作的摘要\n\n注意：此命令假设 tasks.md 中存在完整的任务分解。如果任务不完整或缺失，建议首先运行 `/speckit.tasks` 以重新生成任务列表。",
        "skills/speckit-specify-zh/assets/specify/templates/commands/plan.md": "---\ndescription: 使用计划模板执行实现规划工作流程以生成设计工件。\nscripts:\n  sh: scripts/bash/setup-plan.sh --json\n  ps: scripts/powershell/setup-plan.ps1 -Json\nagent_scripts:\n  sh: scripts/bash/update-agent-context.sh __AGENT__\n  ps: scripts/powershell/update-agent-context.ps1 -AgentType __AGENT__\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_SPEC, IMPL_PLAN, SPECS_DIR, BRANCH。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载上下文**：读取 FEATURE_SPEC 和 `/memory/constitution.md`。加载 IMPL_PLAN 模板（已复制）。\n\n3. **执行计划工作流程**：按照 IMPL_PLAN 模板中的结构：\n   - 填写技术上下文（将未知标记为\"需要澄清\"）\n   - 从宪章填写宪章检查部分\n   - 评估门（如果违规未经证明则报错）\n   - 阶段 0：生成 research.md（解决所有\"需要澄清\"）\n   - 阶段 1：生成 data-model.md, contracts/, quickstart.md\n   - 阶段 1：通过运行代理脚本更新代理上下文\n   - 设计后重新评估宪章检查\n\n4. **停止并报告**：命令在阶段 2 规划后结束。报告分支、IMPL_PLAN 路径和生成的工件。\n\n## 阶段\n\n### 阶段 0：大纲和研究\n\n1. **从上面的技术上下文中提取未知项**：\n   - 对于每个\"需要澄清\" → 研究任务\n   - 对于每个依赖项 → 最佳实践任务\n   - 对于每个集成 → 模式任务\n\n2. **生成和派遣研究代理**：\n\n   ```text\n   对于技术上下文中的每个未知项：\n     任务：\"研究 {未知项} 用于 {功能上下文}\"\n   对于每个技术选择：\n     任务：\"查找 {技术} 在 {领域} 中的最佳实践\"\n   ```\n\n3. **在 `research.md` 中整合发现**，使用格式：\n   - 决策：[选择了什么]\n   - 理由：[为什么选择]\n   - 考虑的替代方案：[评估了什么其他选项]\n\n**输出**：research.md，解决所有\"需要澄清\"\n\n### 阶段 1：设计和契约\n\n**先决条件**：`research.md` 完成\n\n1. **从功能规格中提取实体** → `data-model.md`：\n   - 实体名称、字段、关系\n   - 来自要求的验证规则\n   - 如适用的状态转换\n\n2. **从功能要求生成 API 契约**：\n   - 对于每个用户操作 → 端点\n   - 使用标准 REST/GraphQL 模式\n   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`\n\n3. **代理上下文更新**：\n   - 运行 `{AGENT_SCRIPT}`\n   - 这些脚本检测使用中的 AI 代理\n   - 更新适当的代理特定上下文文件\n   - 仅添加当前计划中的新技术\n   - 保留标记之间的手动添加\n\n**输出**：data-model.md, /contracts/*, quickstart.md, 代理特定文件\n\n## 关键规则\n\n- 使用绝对路径\n- 门失败或未解决的澄清时报错",
        "skills/speckit-specify-zh/assets/specify/templates/commands/specify.md": "---\ndescription: 根据自然语言功能描述创建或更新功能规格。\nscripts:\n  sh: scripts/bash/create-new-feature.sh --json \"{ARGS}\"\n  ps: scripts/powershell/create-new-feature.ps1 -Json \"{ARGS}\"\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n用户在触发消息中输入 `/speckit.specify` 后的文本**就是**功能描述。假设您在此对话中始终可以使用它，即使下面出现 `{ARGS}` 字面意思。除非用户提供了空命令，否则不要要求用户重复。\n\n根据该功能描述，执行以下操作：\n\n1. **生成简洁的短名称**（2-4 个单词）用于分支：\n   - 分析功能描述并提取最有意义的关键词\n   - 创建一个 2-4 个单词的短名称，捕捉功能的本质\n   - 尽可能使用动作-名词格式（例如，\"add-user-auth\"，\"fix-payment-bug\"）\n   - 保留技术术语和缩写（OAuth2, API, JWT 等）\n   - 保持简洁但描述性足够，一眼就能理解功能\n   - 示例：\n     - \"我想添加用户认证\" → \"user-auth\"\n     - \"为 API 实现 OAuth2 集成\" → \"oauth2-api-integration\"\n     - \"创建分析仪表板\" → \"analytics-dashboard\"\n     - \"修复支付处理超时错误\" → \"fix-payment-timeout\"\n\n2. **在创建新分支前检查现有分支**：\n   \n   a. 首先，获取所有远程分支以确保我们有最新信息：\n      ```bash\n      git fetch --all --prune\n      ```\n   \n   b. 查找短名称的最高功能编号：\n      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`\n      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`\n      - 规格目录：检查匹配 `specs/[0-9]+-<short-name>` 的目录\n   \n   c. 确定下一个可用编号：\n      - 从所有三个来源提取所有编号\n      - 找到最高编号 N\n      - 使用 N+1 作为新分支编号\n   \n   d. 使用计算出的编号和短名称运行脚本 `{SCRIPT}`：\n      - 传递 `--number N+1` 和 `--short-name \"your-short-name\"` 以及功能描述\n      - Bash 示例：`{SCRIPT} --json --number 5 --short-name \"user-auth\" \"添加用户认证\"`\n      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName \"user-auth\" \"添加用户认证\"`\n   \n   **重要**：\n   - 检查所有三个来源（远程分支、本地分支、规格目录）以找到最高编号\n   - 仅匹配具有确切短名称模式的分支/目录\n   - 如果未找到具有此短名称的现有分支/目录，则从编号 1 开始\n   - 每个功能只能运行此脚本一次\n   - JSON 在终端中作为输出提供 - 始终参考它以获取您要查找的实际内容\n   - JSON 输出将包含 BRANCH_NAME 和 SPEC_FILE 路径\n   - 对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）\n\n3. 加载 `templates/spec-template.md` 以了解必需部分。\n\n4. 遵循此执行流程：\n\n    1. 从输入解析用户描述\n       如果为空：错误 \"未提供功能描述\"\n    2. 从描述中提取关键概念\n       识别：参与者、动作、数据、约束\n    3. 对于不清楚的方面：\n       - 基于上下文和行业标准做出有根据的猜测\n       - 仅在以下情况下标记 [需要澄清：具体问题]：\n         - 选择显著影响功能范围或用户体验\n         - 存在多种合理解释且有不同的含义\n         - 没有合理的默认值\n       - **限制：最多 3 个 [需要澄清] 标记**\n       - 按影响优先级排序：范围 > 安全/隐私 > 用户体验 > 技术细节\n    4. 填写用户场景和测试部分\n       如果没有明确的用户流程：错误 \"无法确定用户场景\"\n    5. 生成功能要求\n       每个要求必须可测试\n       为未指定的细节使用合理的默认值（在假设部分记录假设）\n    6. 定义成功标准\n       创建可测量的、技术无关的结果\n       包括定量指标（时间、性能、数量）和定性措施（用户满意度、任务完成）\n       每个标准必须在没有实现细节的情况下可验证\n    7. 识别关键实体（如果涉及数据）\n    8. 返回：成功（规格已准备好规划）\n\n5. 使用模板结构将规格写入 SPEC_FILE，将占位符替换为从功能描述（参数）中得出的具体细节，同时保持部分顺序和标题。\n\n6. **规格质量验证**：在编写初始规格后，根据质量标准进行验证：\n\n   a. **创建规格质量检查表**：在 `FEATURE_DIR/checklists/requirements.md` 生成检查表文件，使用检查表模板结构和这些验证项目：\n\n      ```markdown\n      # 规格质量检查表：[功能名称]\n      \n      **目的**：在继续规划之前验证规格完整性和质量\n      **创建时间**：[日期]\n      **功能**：[链接到 spec.md]\n      \n      ## 内容质量\n      \n      - [ ] 无实现细节（语言、框架、API）\n      - [ ] 专注于用户价值和业务需求\n      - [ ] 为非技术利益相关者编写\n      - [ ] 所有必需部分已完成\n      \n      ## 要求完整性\n      \n      - [ ] 无 [需要澄清] 标记\n      - [ ] 要求可测试且明确\n      - [ ] 成功标准可测量\n      - [ ] 成功标准技术无关（无实现细节）\n      - [ ] 所有验收场景已定义\n      - [ ] 边缘情况已识别\n      - [ ] 范围明确界定\n      - [ ] 依赖关系和假设已识别\n      \n      ## 功能准备度\n      \n      - [ ] 所有功能要求都有明确的验收标准\n      - [ ] 用户场景涵盖主要流程\n      - [ ] 功能满足成功标准中定义的可测量结果\n      - [ ] 无实现细节泄露到规格中\n      \n      ## 备注\n      \n      - 标记为不完整的项目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新规格\n      ```\n\n   b. **运行验证检查**：根据每个检查表项目审查规格：\n      - 对于每个项目，确定它是通过还是失败\n      - 记录发现的具体问题（引用相关规格部分）\n\n   c. **处理验证结果**：\n\n      - **如果所有项目都通过**：标记检查表完成并继续到步骤 6\n\n      - **如果项目失败（不包括 [需要澄清]）**：\n        1. 列出失败的项目和具体问题\n        2. 更新规格以解决每个问题\n        3. 重新运行验证直到所有项目通过（最多 3 次迭代）\n        4. 如果 3 次迭代后仍失败，将剩余问题记录在检查表备注中并警告用户\n\n      - **如果 [需要澄清] 标记仍然存在**：\n        1. 从规格中提取所有 [需要澄清：...] 标记\n        2. **限制检查**：如果标记超过 3 个，仅保留 3 个最关键（按范围/安全/用户体验影响）并为其余标记做出有根据的猜测\n        3. 对于每个需要的澄清（最多 3 个），以以下格式向用户呈现选项：\n\n           ```markdown\n           ## 问题 [N]：[主题]\n           \n           **上下文**：[引用相关规格部分]\n           \n           **我们需要知道**：[来自需要澄清标记的具体问题]\n           \n           **建议答案**：\n           \n           | 选项 | 答案 | 影响 |\n           |--------|--------|--------------|\n           | A      | [第一个建议答案] | [这对功能意味着什么] |\n           | B      | [第二个建议答案] | [这对功能意味着什么] |\n           | C      | [第三个建议答案] | [这对功能意味着什么] |\n           | 自定义 | 提供您自己的答案 | [解释如何提供自定义输入] |\n           \n           **您的选择**：_[等待用户响应]_\n           ```\n\n        4. **关键 - 表格格式**：确保 markdown 表格格式正确：\n           - 使用一致的间距，管道对齐\n           - 每个单元格应有内容周围的空格：`| 内容 |` 而不是 `|内容|`\n           - 标题分隔符必须至少有 3 个破折号：`|--------|`\n           - 测试表格在 markdown 预览中正确渲染\n        5. 顺序编号问题（Q1, Q2, Q3 - 最多 3 个总计）\n        6. 在等待响应之前一起呈现所有问题\n        7. 等待用户响应他们对所有问题的选择（例如，\"Q1: A, Q2: 自定义 - [详情], Q3: B\"）\n        8. 通过将每个 [需要澄清] 标记替换为用户选择或提供的答案来更新规格\n        9. 在所有澄清解决后重新运行验证\n\n   d. **更新检查表**：在每次验证迭代后，使用当前通过/失败状态更新检查表文件\n\n7. 报告完成情况，包括分支名称、规格文件路径、检查表结果和下一阶段的准备情况（`/speckit.clarify` 或 `/speckit.plan`）。\n\n**注意**：脚本创建并检出新分支并在写入前初始化规格文件。\n\n## 一般指南\n\n## 快速指南\n\n- 专注于用户需要**什么**和**为什么**。\n- 避免如何实现（无技术栈、API、代码结构）。\n- 为业务利益相关者编写，而不是开发人员。\n- 不要创建嵌入在规格中的任何检查表。那将是单独的命令。\n\n### 部分要求\n\n- **必需部分**：每个功能必须完成\n- **可选部分**：仅在与功能相关时包含\n- 当部分不适用时，完全删除（不要留作\"N/A\"）\n\n### 对于 AI 生成\n\n从用户提示创建此规格时：\n\n1. **做出有根据的猜测**：使用上下文、行业标准和常见模式填补空白\n2. **记录假设**：在假设部分记录合理的默认值\n3. **限制澄清**：最多 3 个 [需要澄清] 标记 - 仅用于关键决策：\n   - 显著影响功能范围或用户体验\n   - 有多种合理解释且有不同的含义\n   - 没有合理的默认值\n4. **优先级澄清**：范围 > 安全/隐私 > 用户体验 > 技术细节\n5. **像测试人员一样思考**：每个模糊要求都应无法通过\"可测试和明确\"检查表项目\n6. **需要澄清的常见领域**（如果没有合理的默认值）：\n   - 功能范围和边界（包括/排除特定用例）\n   - 用户类型和权限（如果存在多个冲突解释）\n   - 安全/合规要求（当法律/财务重要时）\n\n**合理默认值示例**（不要询问这些）：\n\n- 数据保留：该领域的行业标准实践\n- 性能目标：标准网络/移动应用期望（除非指定）\n- 错误处理：用户友好的消息和适当的回退\n- 认证方法：标准基于会话或 OAuth2 用于 Web 应用\n- 集成模式：RESTful API（除非另有说明）\n\n### 成功标准指南\n\n成功标准必须：\n\n1. **可测量**：包括具体指标（时间、百分比、数量、比率）\n2. **技术无关**：不提及框架、语言、数据库或工具\n3. **用户导向**：从用户/业务角度描述结果，而不是系统内部\n4. **可验证**：可以在不知道实现细节的情况下测试/验证\n\n**好示例**：\n\n- \"用户可以在 3 分钟内完成结账\"\n- \"系统支持 10,000 个并发用户\"\n- \"95% 的搜索在 1 秒内返回结果\"\n- \"任务完成率提高 40%\"\n\n**坏示例**（实现导向）：\n\n- \"API 响应时间低于 200ms\"（太技术性，使用\"用户立即看到结果\"）\n- \"数据库可以处理 1000 TPS\"（实现细节，使用面向用户的指标）\n- \"React 组件高效渲染\"（框架特定）\n- \"Redis 缓存命中率高于 80%\"（技术特定）",
        "skills/speckit-specify-zh/assets/specify/templates/commands/tasks.md": "---\ndescription: 基于可用设计工件为功能生成可操作的、按依赖顺序排列的 tasks.md。\nscripts:\n  sh: scripts/bash/check-prerequisites.sh --json\n  ps: scripts/powershell/check-prerequisites.ps1 -Json\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载设计文档**：从 FEATURE_DIR 读取：\n   - **必需**：plan.md（技术栈、库、结构），spec.md（带优先级的用户故事）\n   - **可选**：data-model.md（实体），contracts/（API 端点），research.md（决策），quickstart.md（测试场景）\n   - 注意：并非所有项目都有所有文档。根据可用内容生成任务。\n\n3. **执行任务生成工作流程**：\n   - 加载 plan.md 并提取技术栈、库、项目结构\n   - 加载 spec.md 并提取带优先级的用户故事（P1, P2, P3 等）\n   - 如果存在 data-model.md：提取实体并映射到用户故事\n   - 如果存在 contracts/：将端点映射到用户故事\n   - 如果存在 research.md：提取决策用于设置任务\n   - 生成按用户故事组织的任务（参见下面的任务生成规则）\n   - 生成依赖图显示用户故事完成顺序\n   - 为每个用户故事创建并行执行示例\n   - 验证任务完整性（每个用户故事都有所需任务，可独立测试）\n\n4. **生成 tasks.md**：使用 `.specify/templates/tasks-template.md` 作为结构，填充：\n   - 从 plan.md 获取正确的功能名称\n   - 阶段 1：设置任务（项目初始化）\n   - 阶段 2：基础任务（所有用户故事的阻塞先决条件）\n   - 阶段 3+：按 spec.md 中的优先级顺序排列的每个用户故事一个阶段\n   - 每个阶段包括：故事目标、独立测试标准、测试（如果要求）、实现任务\n   - 最终阶段：完善和跨领域关注点\n   - 所有任务必须遵循严格的检查表格式（参见下面的任务生成规则）\n   - 每个任务的明确文件路径\n   - 依赖关系部分显示故事完成顺序\n   - 每个故事的并行执行示例\n   - 实现策略部分（MVP 优先、增量交付）\n\n5. **报告**：输出生成的 tasks.md 路径和摘要：\n   - 总任务数\n   - 每个用户故事的任务数\n   - 识别的并行机会\n   - 每个故事的独立测试标准\n   - 建议的 MVP 范围（通常仅为用户故事 1）\n   - 格式验证：确认所有任务都遵循检查表格式（复选框、ID、标签、文件路径）\n\n为任务生成提供上下文：{ARGS}\n\ntasks.md 应该是立即可执行的 - 每个任务必须足够具体，以便 LLM 可以在没有额外上下文的情况下完成它。\n\n## 任务生成规则\n\n**关键**：任务必须按用户故事组织，以实现独立实现和测试。\n\n**测试是可选的**：仅在功能规格中明确要求或用户要求 TDD 方法时才生成测试任务。\n\n### 检查表格式（必需）\n\n每个任务必须严格遵循此格式：\n\n```text\n- [ ] [任务ID] [P?] [故事?] 带文件路径的描述\n```\n\n**格式组件**：\n\n1. **复选框**：始终以 `- [ ]` 开头（markdown 复选框）\n2. **任务 ID**：按执行顺序的序列号（T001, T002, T003...）\n3. **[P] 标记**：仅当任务可并行化时包含（不同文件，不依赖未完成任务）\n4. **[故事] 标签**：仅用户故事阶段任务必需\n   - 格式：[US1], [US2], [US3], 等（映射到 spec.md 中的用户故事）\n   - 设置阶段：无故事标签\n   - 基础阶段：无故事标签  \n   - 用户故事阶段：必须有故事标签\n   - 完善阶段：无故事标签\n5. **描述**：带确切文件路径的明确操作\n\n**示例**：\n\n- ✅ 正确：`- [ ] T001 根据实现计划创建项目结构`\n- ✅ 正确：`- [ ] T005 [P] 在 src/middleware/auth.py 中实现认证中间件`\n- ✅ 正确：`- [ ] T012 [P] [US1] 在 src/models/user.py 中创建用户模型`\n- ✅ 正确：`- [ ] T014 [US1] 在 src/services/user_service.py 中实现 UserService`\n- ❌ 错误：`- [ ] 创建用户模型`（缺少 ID 和故事标签）\n- ❌ 错误：`T001 [US1] 创建模型`（缺少复选框）\n- ❌ 错误：`- [ ] [US1] 创建用户模型`（缺少任务 ID）\n- ❌ 错误：`- [ ] T001 [US1] 创建模型`（缺少文件路径）\n\n### 任务组织\n\n1. **来自用户故事（spec.md）** - 主要组织：\n   - 每个用户故事（P1, P2, P3...）都有自己的阶段\n   - 将所有相关组件映射到它们的故事：\n     - 该故事需要的模型\n     - 该故事需要的服务\n     - 该故事需要的端点/UI\n     - 如果要求测试：该故事的特定测试\n   - 标记故事依赖关系（大多数故事应该是独立的）\n\n2. **来自契约**：\n   - 将每个契约/端点 → 映射到它服务的用户故事\n   - 如果要求测试：每个契约 → 在该故事阶段实现前的契约测试任务 [P]\n\n3. **来自数据模型**：\n   - 将每个实体映射到需要它的用户故事\n   - 如果实体服务于多个故事：放在最早的故事或设置阶段\n   - 关系 → 在适当的故事阶段中的服务层任务\n\n4. **来自设置/基础设施**：\n   - 共享基础设施 → 设置阶段（阶段 1）\n   - 基础/阻塞任务 → 基础阶段（阶段 2）\n   - 故事特定设置 → 在该故事的阶段内\n\n### 阶段结构\n\n- **阶段 1**：设置（项目初始化）\n- **阶段 2**：基础（阻塞先决条件 - 必须在用户故事前完成）\n- **阶段 3+**：按优先级顺序的用户故事（P1, P2, P3...）\n  - 在每个故事内：测试（如果要求）→ 模型 → 服务 → 端点 → 集成\n  - 每个阶段应该是一个完整的、可独立测试的增量\n- **最终阶段**：完善和跨领域关注点",
        "skills/speckit-specify-zh/assets/specify/templates/constitution-template.md": "# [项目名称] 章程\n<!-- 示例：规范章程，任务流章程等 -->\n\n## 核心原则\n\n### [原则_1_名称]\n<!-- 示例：I. 库优先 -->\n[原则_1_描述]\n<!-- 示例：每个功能都以独立库开始；库必须自包含、可独立测试、有文档；需要明确目的 - 没有仅用于组织的库 -->\n\n### [原则_2_名称]\n<!-- 示例：II. CLI 接口 -->\n[原则_2_描述]\n<!-- 示例：每个库都通过 CLI 暴露功能；文本输入/输出协议：stdin/args → stdout，错误 → stderr；支持 JSON + 人类可读格式 -->\n\n### [原则_3_名称]\n<!-- 示例：III. 测试优先（不可协商） -->\n[原则_3_描述]\n<!-- 示例：TDD 强制：编写测试 → 用户批准 → 测试失败 → 然后实现；严格强制红-绿-重构循环 -->\n\n### [原则_4_名称]\n<!-- 示例：IV. 集成测试 -->\n[原则_4_描述]\n<!-- 示例：需要集成测试的重点领域：新库契约测试、契约变更、服务间通信、共享模式 -->\n\n### [原则_5_名称]\n<!-- 示例：V. 可观察性，VI. 版本控制和破坏性变更，VII. 简单性 -->\n[原则_5_描述]\n<!-- 示例：文本 I/O 确保可调试性；需要结构化日志；或：MAJOR.MINOR.BUILD 格式；或：从简单开始，YAGNI 原则 -->\n\n## [部分_2_名称]\n<!-- 示例：附加约束、安全要求、性能标准等 -->\n\n[部分_2_内容]\n<!-- 示例：技术栈要求、合规标准、部署策略等 -->\n\n## [部分_3_名称]\n<!-- 示例：开发工作流程、审查过程、质量门等 -->\n\n[部分_3_内容]\n<!-- 示例：代码审查要求、测试门、部署批准流程等 -->\n\n## 治理\n<!-- 示例：章程优于所有其他实践；修订需要文档、批准、迁移计划 -->\n\n[治理规则]\n<!-- 示例：所有 PR/审查必须验证合规性；复杂性必须有正当理由；使用 [指导文件] 作为运行时开发指导 -->\n\n**版本**：[章程版本] | **批准**：[批准日期] | **最后修订**：[最后修订日期]\n<!-- 示例：版本：2.1.1 | 批准：2025-06-13 | 最后修订：2025-07-16 -->",
        "skills/speckit-specify-zh/assets/specify/templates/plan-template.md": "# 实现计划：[功能]\n\n**分支**：`[###-feature-name]` | **日期**：[日期] | **规格**：[链接]\n**输入**：来自 `/specs/[###-feature-name]/spec.md` 的功能规格\n\n**注意**：此模板由 `/speckit.plan` 命令填写。请参见 `.specify/templates/commands/plan.md` 了解执行工作流程。\n\n## 概要\n\n[从功能规格中提取：主要需求 + 研究中的技术方法]\n\n## 技术背景\n\n<!--\n  需要操作：用该项目的技术细节替换本节内容。\n  此处提供的结构是为了指导迭代过程而提供的建议性框架。\n-->\n\n**语言/版本**：[例如，Python 3.11, Swift 5.9, Rust 1.75 或需要澄清]  \n**主要依赖项**：[例如，FastAPI, UIKit, LLVM 或需要澄清]  \n**存储**：[如果适用，例如，PostgreSQL, CoreData, 文件 或不适用]  \n**测试**：[例如，pytest, XCTest, cargo test 或需要澄清]  \n**目标平台**：[例如，Linux 服务器, iOS 15+, WASM 或需要澄清]\n**项目类型**：[单体/网页/移动端 - 决定源码结构]  \n**性能目标**：[领域特定，例如，1000 请求/秒, 10k 行/秒, 60 帧/秒 或需要澄清]  \n**约束条件**：[领域特定，例如，<200ms p95, <100MB 内存, 支持离线 或需要澄清]  \n**规模/范围**：[领域特定，例如，10k 用户, 1M LOC, 50 屏幕 或需要澄清]\n\n## 宪章检查\n\n*关卡：必须在第 0 阶段研究前通过。在第 1 阶段设计后重新检查。*\n\n[基于宪章文件确定的关卡]\n\n## 项目结构\n\n### 文档（此功能）\n\n```text\nspecs/[###-feature]/\n├── plan.md              # 本文件（/speckit.plan 命令输出）\n├── research.md          # 第 0 阶段输出（/speckit.plan 命令）\n├── data-model.md        # 第 1 阶段输出（/speckit.plan 命令）\n├── quickstart.md        # 第 1 阶段输出（/speckit.plan 命令）\n├── contracts/           # 第 1 阶段输出（/speckit.plan 命令）\n└── tasks.md             # 第 2 阶段输出（/speckit.tasks 命令 - 不由 /speckit.plan 创建）\n```\n\n### 源代码（仓库根目录）\n<!--\n  需要操作：用此功能的具体布局替换下面的占位符树。\n  删除未使用的选项，并使用真实路径扩展所选结构（例如，apps/admin, packages/something）。\n  提供的计划不得包含选项标签。\n-->\n\n```text\n# [如果未使用则删除] 选项 1：单一项目（默认）\nsrc/\n├── models/\n├── services/\n├── cli/\n└── lib/\n\ntests/\n├── contract/\n├── integration/\n└── unit/\n\n# [如果未使用则删除] 选项 2：Web 应用程序（当检测到 \"frontend\" + \"backend\" 时）\nbackend/\n├── src/\n│   ├── models/\n│   ├── services/\n│   └── api/\n└── tests/\n\nfrontend/\n├── src/\n│   ├── components/\n│   ├── pages/\n│   └── services/\n└── tests/\n\n# [如果未使用则删除] 选项 3：移动端 + API（当检测到 \"iOS/Android\" 时）\napi/\n└── [与后端相同]\n\nios/ 或 android/\n└── [平台特定结构：功能模块、UI 流程、平台测试]\n```\n\n**结构决策**：[记录选择的结构并引用上面捕获的真实目录]\n\n## 复杂度跟踪\n\n> **仅当宪章检查存在必须证明合理性的违规情况时才填写**\n\n| 违规情况 | 为何需要 | 被拒绝的更简单替代方案原因 |\n|-----------|------------|-------------------------------------|\n| [例如，第 4 个项目] | [当前需求] | [为什么 3 个项目不够] |\n| [例如，仓储模式] | [具体问题] | [为什么直接数据库访问不够] |",
        "skills/speckit-specify-zh/assets/specify/templates/spec-template.md": "# 功能规格：[功能名称]\n\n**功能分支**：`[###-feature-name]`  \n**创建时间**：[日期]  \n**状态**：草案  \n**输入**：用户描述：\"$ARGUMENTS\"\n\n## 用户场景与测试 *(必填)*\n\n<!--\n  重要：用户故事应按照重要性排序为用户旅程。\n  每个用户故事/旅程必须是独立可测试的 - 这意味着如果您只实现其中一个，\n  您仍应拥有一个可交付价值的可行MVP（最小可行产品）。\n  \n  为每个故事分配优先级（P1, P2, P3等），其中P1是最重要的。\n  将每个故事视为可以：\n  - 独立开发\n  - 独立测试\n  - 独立部署\n  - 独立向用户展示\n-->\n\n### 用户故事 1 - [简要标题] (优先级: P1)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试 - 例如，\"可以通过[具体操作]完全测试，并交付[具体价值]\"]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n2. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n### 用户故事 2 - [简要标题] (优先级: P2)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n### 用户故事 3 - [简要标题] (优先级: P3)\n\n[用通俗语言描述此用户旅程]\n\n**为何此优先级**：[解释价值以及为何具有此优先级]\n\n**独立测试**：[描述如何独立测试]\n\n**验收场景**：\n\n1. **给定** [初始状态]，**当** [操作]，**则** [预期结果]\n\n---\n\n[根据需要添加更多用户故事，每个都有分配的优先级]\n\n### 边缘情况\n\n<!--\n  需要操作：本节中的内容是占位符。\n  用正确的边缘情况填充它们。\n-->\n\n- 当[边界条件]发生时会怎样？\n- 系统如何处理[错误场景]？\n\n## 要求 *(必填)*\n\n<!--\n  需要操作：本节中的内容是占位符。\n  用正确的功能要求填充它们。\n-->\n\n### 功能要求\n\n- **FR-001**：系统必须[具体能力，例如，\"允许用户创建账户\"]\n- **FR-002**：系统必须[具体能力，例如，\"验证电子邮件地址\"]  \n- **FR-003**：用户必须能够[关键交互，例如，\"重置密码\"]\n- **FR-004**：系统必须[数据要求，例如，\"持久化用户偏好设置\"]\n- **FR-005**：系统必须[行为，例如，\"记录所有安全事件\"]\n\n*标记不明确要求的示例：*\n\n- **FR-006**：系统必须通过[需要澄清：未指定认证方法 - 电子邮件/密码、SSO、OAuth？]\n- **FR-007**：系统必须保留用户数据[需要澄清：未指定保留期]\n\n### 关键实体 *(如果功能涉及数据则包含)*\n\n- **[实体 1]**：[它代表什么，关键属性（无实现细节）]\n- **[实体 2]**：[它代表什么，与其他实体的关系]\n\n## 成功标准 *(必填)*\n\n<!--\n  需要操作：定义可衡量的成功标准。\n  这些必须是技术无关且可衡量的。\n-->\n\n### 可衡量的结果\n\n- **SC-001**：[可衡量的指标，例如，\"用户可以在2分钟内完成账户创建\"]\n- **SC-002**：[可衡量的指标，例如，\"系统在无降级情况下处理1000个并发用户\"]\n- **SC-003**：[用户满意度指标，例如，\"90%的用户首次尝试即可成功完成主要任务\"]\n- **SC-004**：[业务指标，例如，\"将与[X]相关的支持工单减少50%\"]",
        "skills/speckit-specify-zh/assets/specify/templates/tasks-template.md": "---\ndescription: \"功能实现的任务列表模板\"\n---\n\n# 任务：[功能名称]\n\n**输入**：来自 `/specs/[###-功能名称]/` 的设计文档\n**先决条件**：plan.md（必需），spec.md（用户故事必需），research.md，data-model.md，contracts/\n\n**测试**：下面的示例包含测试任务。测试是可选的 - 仅在功能规格中明确要求时才包含它们。\n\n**组织**：任务按用户故事分组，以实现每个故事的独立实现和测试。\n\n## 格式：`[ID] [P?] [故事] 描述`\n\n- **[P]**：可以并行运行（不同文件，无依赖关系）\n- **[故事]**：此任务属于哪个用户故事（例如，US1, US2, US3）\n- 在描述中包含确切的文件路径\n\n## 路径约定\n\n- **单一项目**：`src/`, `tests/` 在仓库根目录\n- **Web 应用**：`backend/src/`, `frontend/src/`\n- **移动端**：`api/src/`, `ios/src/` 或 `android/src/`\n- 下面显示的路径假设为单一项目 - 根据 plan.md 结构进行调整\n\n<!-- \n  ============================================================================\n  重要提示：下面的任务仅为示例任务，仅用于说明目的。\n  \n  /speckit.tasks 命令必须根据以下内容替换这些任务：\n  - 来自 spec.md 的用户故事（及其优先级 P1, P2, P3...）\n  - 来自 plan.md 的功能要求\n  - 来自 data-model.md 的实体\n  - 来自 contracts/ 的端点\n  \n  任务必须按用户故事组织，以便每个故事可以：\n  - 独立实现\n  - 独立测试\n  - 作为 MVP 增量交付\n  \n  不要在生成的 tasks.md 文件中保留这些示例任务。\n  ============================================================================\n-->\n\n## 阶段 1：设置（共享基础设施）\n\n**目的**：项目初始化和基本结构\n\n- [ ] T001 根据实现计划创建项目结构\n- [ ] T002 使用 [框架] 依赖项初始化 [语言] 项目\n- [ ] T003 [P] 配置代码检查和格式化工具\n\n---\n\n## 阶段 2：基础（阻塞先决条件）\n\n**目的**：必须在任何用户故事实现之前完成的核心基础设施\n\n**⚠️ 关键**：在本阶段完成之前，任何用户故事工作都不能开始\n\n基础任务示例（根据您的项目进行调整）：\n\n- [ ] T004 设置数据库模式和迁移框架\n- [ ] T005 [P] 实现认证/授权框架\n- [ ] T006 [P] 设置 API 路由和中间件结构\n- [ ] T007 创建所有故事都依赖的基础模型/实体\n- [ ] T008 配置错误处理和日志基础设施\n- [ ] T009 设置环境配置管理\n\n**检查点**：基础就绪 - 用户故事实现现在可以并行开始\n\n---\n\n## 阶段 3：用户故事 1 - [标题] (优先级: P1) 🎯 MVP\n\n**目标**：[对此故事交付内容的简要描述]\n\n**独立测试**：[如何验证此故事独立工作]\n\n### 用户故事 1 的测试（可选 - 仅在要求测试时）⚠️\n\n> **注意：首先编写这些测试，确保在实现之前它们失败**\n\n- [ ] T010 [P] [US1] tests/contract/test_[name].py 中 [端点] 的契约测试\n- [ ] T011 [P] [US1] tests/integration/test_[name].py 中 [用户旅程] 的集成测试\n\n### 用户故事 1 的实现\n\n- [ ] T012 [P] [US1] 在 src/models/[entity1].py 中创建 [Entity1] 模型\n- [ ] T013 [P] [US1] 在 src/models/[entity2].py 中创建 [Entity2] 模型\n- [ ] T014 [US1] 在 src/services/[service].py 中实现 [服务]（依赖于 T012, T013）\n- [ ] T015 [US1] 在 src/[location]/[file].py 中实现 [端点/功能]\n- [ ] T016 [US1] 添加验证和错误处理\n- [ ] T017 [US1] 为用户故事 1 操作添加日志\n\n**检查点**：此时，用户故事 1 应该完全功能化并可独立测试\n\n---\n\n## 阶段 4：用户故事 2 - [标题] (优先级: P2)\n\n**目标**：[对此故事交付内容的简要描述]\n\n**独立测试**：[如何验证此故事独立工作]\n\n### 用户故事 2 的测试（可选 - 仅在要求测试时）⚠️\n\n- [ ] T018 [P] [US2] tests/contract/test_[name].py 中 [端点] 的契约测试\n- [ ] T019 [P] [US2] tests/integration/test_[name].py 中 [用户旅程] 的集成测试\n\n### 用户故事 2 的实现\n\n- [ ] T020 [P] [US2] 在 src/models/[entity].py 中创建 [实体] 模型\n- [ ] T021 [US2] 在 src/services/[service].py 中实现 [服务]\n- [ ] T022 [US2] 在 src/[location]/[file].py 中实现 [端点/功能]\n- [ ] T023 [US2] 与用户故事 1 组件集成（如果需要）\n\n**检查点**：此时，用户故事 1 和 2 都应该独立工作\n\n---\n\n## 阶段 5：用户故事 3 - [标题] (优先级: P3)\n\n**目标**：[对此故事交付内容的简要描述]\n\n**独立测试**：[如何验证此故事独立工作]\n\n### 用户故事 3 的测试（可选 - 仅在要求测试时）⚠️\n\n- [ ] T024 [P] [US3] tests/contract/test_[name].py 中 [端点] 的契约测试\n- [ ] T025 [P] [US3] tests/integration/test_[name].py 中 [用户旅程] 的集成测试\n\n### 用户故事 3 的实现\n\n- [ ] T026 [P] [US3] 在 src/models/[entity].py 中创建 [实体] 模型\n- [ ] T027 [US3] 在 src/services/[service].py 中实现 [服务]\n- [ ] T028 [US3] 在 src/[location]/[file].py 中实现 [端点/功能]\n\n**检查点**：所有用户故事现在都应该独立功能化\n\n---\n\n[根据需要添加更多用户故事阶段，遵循相同模式]\n\n---\n\n## 阶段 N：完善和跨领域关注点\n\n**目的**：影响多个用户故事的改进\n\n- [ ] TXXX [P] docs/ 中的文档更新\n- [ ] TXXX 代码清理和重构\n- [ ] TXXX 跨所有故事的性能优化\n- [ ] TXXX [P] 附加单元测试（如果要求）在 tests/unit/ 中\n- [ ] TXXX 安全加固\n- [ ] TXXX 运行 quickstart.md 验证\n\n---\n\n## 依赖关系和执行顺序\n\n### 阶段依赖关系\n\n- **设置（阶段 1）**：无依赖关系 - 可立即开始\n- **基础（阶段 2）**：依赖于设置完成 - 阻塞所有用户故事\n- **用户故事（阶段 3+）**：都依赖于基础阶段完成\n  - 用户故事然后可以并行进行（如果有人员）\n  - 或按优先级顺序依次进行（P1 → P2 → P3）\n- **完善（最终阶段）**：依赖于所有所需用户故事完成\n\n### 用户故事依赖关系\n\n- **用户故事 1 (P1)**：可在基础阶段完成后开始 - 无其他故事依赖\n- **用户故事 2 (P2)**：可在基础阶段完成后开始 - 可能与 US1 集成但应独立可测试\n- **用户故事 3 (P3)**：可在基础阶段完成后开始 - 可能与 US1/US2 集成但应独立可测试\n\n### 每个用户故事内部\n\n- 测试（如果包含）必须在实现之前编写并失败\n- 模型在服务之前\n- 服务在端点之前\n- 核心实现在集成之前\n- 故事完成后才进入下一个优先级\n\n### 并行机会\n\n- 所有标记为 [P] 的设置任务可以并行运行\n- 所有标记为 [P] 的基础任务可以并行运行（在阶段 2 内）\n- 一旦基础阶段完成，所有用户故事可以并行开始（如果团队容量允许）\n- 标记为 [P] 的用户故事的所有测试可以并行运行\n- 标记为 [P] 的故事内的模型可以并行运行\n- 不同的用户故事可以由不同团队成员并行处理\n\n---\n\n## 并行示例：用户故事 1\n\n```bash\n# 一起启动用户故事 1 的所有测试（如果要求测试）：\n任务：\"tests/contract/test_[name].py 中 [端点] 的契约测试\"\n任务：\"tests/integration/test_[name].py 中 [用户旅程] 的集成测试\"\n\n# 一起启动用户故事 1 的所有模型：\n任务：\"在 src/models/[entity1].py 中创建 [Entity1] 模型\"\n任务：\"在 src/models/[entity2].py 中创建 [Entity2] 模型\"\n```\n\n---\n\n## 实现策略\n\n### MVP 优先（仅用户故事 1）\n\n1. 完成阶段 1：设置\n2. 完成阶段 2：基础（关键 - 阻塞所有故事）\n3. 完成阶段 3：用户故事 1\n4. **停止并验证**：独立测试用户故事 1\n5. 如果准备就绪则部署/演示\n\n### 增量交付\n\n1. 完成设置 + 基础 → 基础就绪\n2. 添加用户故事 1 → 独立测试 → 部署/演示（MVP！）\n3. 添加用户故事 2 → 独立测试 → 部署/演示\n4. 添加用户故事 3 → 独立测试 → 部署/演示\n5. 每个故事在不破坏之前故事的情况下增加价值\n\n### 并行团队策略\n\n多个开发人员时：\n\n1. 团队一起完成设置 + 基础\n2. 一旦基础完成：\n   - 开发人员 A：用户故事 1\n   - 开发人员 B：用户故事 2\n   - 开发人员 C：用户故事 3\n3. 故事独立完成和集成\n\n---\n\n## 备注\n\n- [P] 任务 = 不同文件，无依赖关系\n- [故事] 标签将任务映射到特定用户故事以实现可追溯性\n- 每个用户故事应该是独立可完成和可测试的\n- 在实现之前验证测试失败\n- 每个任务或逻辑组之后提交\n- 在任何检查点停止以独立验证故事\n- 避免：模糊任务、相同文件冲突、破坏独立性的跨故事依赖",
        "skills/speckit-tasks-zh/SKILL.md": "---\nname: speckit-tasks-zh\ndescription: 基于speckit工作流的任务生成技能，用于根据可用设计文档生成可操作的、依赖有序的tasks.md。当需要基于spec.md、plan.md、data-model.md、contracts/等设计文档为功能开发生成详细任务列表时使用此技能。触发词包括\"speckit tasks\"、\"生成任务\"、\"任务规划\"、\"功能任务分解\"、\"创建tasks.md\"等。\n---\n\n## 用户输入\n\n```text\n$ARGUMENTS\n```\n\n您**必须**在继续之前考虑用户输入（如果不为空）。\n\n## 大纲\n\nscripts:\n  sh: .specify/scripts/bash/check-prerequisites.sh --json\n  ps: .specify/scripts/powershell/check-prerequisites.ps1 -Json\n\n1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 FEATURE_DIR 和 AVAILABLE_DOCS 列表。所有路径必须是绝对的。对于参数中的单引号，如 \"I'm Groot\"，使用转义语法：例如 'I'\\''m Groot'（或者如果可能的话使用双引号：\"I'm Groot\"）。\n\n2. **加载设计文档**：从 FEATURE_DIR 读取：\n   - **必需**：plan.md（技术栈、库、结构），spec.md（带优先级的用户故事）\n   - **可选**：data-model.md（实体），contracts/（API 端点），research.md（决策），quickstart.md（测试场景）\n   - 注意：并非所有项目都有所有文档。根据可用内容生成任务。\n\n3. **执行任务生成工作流程**：\n   - 加载 plan.md 并提取技术栈、库、项目结构\n   - 加载 spec.md 并提取带优先级的用户故事（P1, P2, P3 等）\n   - 如果存在 data-model.md：提取实体并映射到用户故事\n   - 如果存在 contracts/：将端点映射到用户故事\n   - 如果存在 research.md：提取决策用于设置任务\n   - 生成按用户故事组织的任务（参见下面的任务生成规则）\n   - 生成依赖图显示用户故事完成顺序\n   - 为每个用户故事创建并行执行示例\n   - 验证任务完整性（每个用户故事都有所需任务，可独立测试）\n\n4. **生成 tasks.md**：使用 `.specify/templates/tasks-template.md` 作为结构，填充：\n   - 从 plan.md 获取正确的功能名称\n   - 阶段 1：设置任务（项目初始化）\n   - 阶段 2：基础任务（所有用户故事的阻塞先决条件）\n   - 阶段 3+：按 spec.md 中的优先级顺序排列的每个用户故事一个阶段\n   - 每个阶段包括：故事目标、独立测试标准、测试（如果要求）、实现任务\n   - 最终阶段：完善和跨领域关注点\n   - 所有任务必须遵循严格的检查表格式（参见下面的任务生成规则）\n   - 每个任务的明确文件路径\n   - 依赖关系部分显示故事完成顺序\n   - 每个故事的并行执行示例\n   - 实现策略部分（MVP 优先、增量交付）\n\n5. **报告**：输出生成的 tasks.md 路径和摘要：\n   - 总任务数\n   - 每个用户故事的任务数\n   - 识别的并行机会\n   - 每个故事的独立测试标准\n   - 建议的 MVP 范围（通常仅为用户故事 1）\n   - 格式验证：确认所有任务都遵循检查表格式（复选框、ID、标签、文件路径）\n\n为任务生成提供上下文：{ARGS}\n\ntasks.md 应该是立即可执行的 - 每个任务必须足够具体，以便 LLM 可以在没有额外上下文的情况下完成它。\n\n## 任务生成规则\n\n**关键**：任务必须按用户故事组织，以实现独立实现和测试。\n\n**测试是可选的**：仅在功能规格中明确要求或用户要求 TDD 方法时才生成测试任务。\n\n### 检查表格式（必需）\n\n每个任务必须严格遵循此格式：\n\n```text\n- [ ] [任务ID] [P?] [故事?] 带文件路径的描述\n```\n\n**格式组件**：\n\n1. **复选框**：始终以 `- [ ]` 开头（markdown 复选框）\n2. **任务 ID**：按执行顺序的序列号（T001, T002, T003...）\n3. **[P] 标记**：仅当任务可并行化时包含（不同文件，不依赖未完成任务）\n4. **[故事] 标签**：仅用户故事阶段任务必需\n   - 格式：[US1], [US2], [US3], 等（映射到 spec.md 中的用户故事）\n   - 设置阶段：无故事标签\n   - 基础阶段：无故事标签  \n   - 用户故事阶段：必须有故事标签\n   - 完善阶段：无故事标签\n5. **描述**：带确切文件路径的明确操作\n\n**示例**：\n\n- ✅ 正确：`- [ ] T001 根据实现计划创建项目结构`\n- ✅ 正确：`- [ ] T005 [P] 在 src/middleware/auth.py 中实现认证中间件`\n- ✅ 正确：`- [ ] T012 [P] [US1] 在 src/models/user.py 中创建用户模型`\n- ✅ 正确：`- [ ] T014 [US1] 在 src/services/user_service.py 中实现 UserService`\n- ❌ 错误：`- [ ] 创建用户模型`（缺少 ID 和故事标签）\n- ❌ 错误：`T001 [US1] 创建模型`（缺少复选框）\n- ❌ 错误：`- [ ] [US1] 创建用户模型`（缺少任务 ID）\n- ❌ 错误：`- [ ] T001 [US1] 创建模型`（缺少文件路径）\n\n### 任务组织\n\n1. **来自用户故事（spec.md）** - 主要组织：\n   - 每个用户故事（P1, P2, P3...）都有自己的阶段\n   - 将所有相关组件映射到它们的故事：\n     - 该故事需要的模型\n     - 该故事需要的服务\n     - 该故事需要的端点/UI\n     - 如果要求测试：该故事的特定测试\n   - 标记故事依赖关系（大多数故事应该是独立的）\n\n2. **来自契约**：\n   - 将每个契约/端点 → 映射到它服务的用户故事\n   - 如果要求测试：每个契约 → 在该故事阶段实现前的契约测试任务 [P]\n\n3. **来自数据模型**：\n   - 将每个实体映射到需要它的用户故事\n   - 如果实体服务于多个故事：放在最早的故事或设置阶段\n   - 关系 → 在适当的故事阶段中的服务层任务\n\n4. **来自设置/基础设施**：\n   - 共享基础设施 → 设置阶段（阶段 1）\n   - 基础/阻塞任务 → 基础阶段（阶段 2）\n   - 故事特定设置 → 在该故事的阶段内\n\n### 阶段结构\n\n- **阶段 1**：设置（项目初始化）\n- **阶段 2**：基础（阻塞先决条件 - 必须在用户故事前完成）\n- **阶段 3+**：按优先级顺序的用户故事（P1, P2, P3...）\n  - 在每个故事内：测试（如果要求）→ 模型 → 服务 → 端点 → 集成\n  - 每个阶段应该是一个完整的、可独立测试的增量\n- **最终阶段**：完善和跨领域关注点\n\n",
        "skills/speckit-tasks-zh/assets/TASK_EXAMPLES.md": "# 任务格式示例与规范\n\n## 检查表格式（必需）\n\n每个任务必须严格遵循此格式：\n\n```markdown\n- [ ] [TaskID] [P?] [Story?] 描述与文件路径\n```\n\n## 格式组件详解\n\n1. **复选框**: 始终以 `- [ ]` 开始（markdown复选框）\n2. **任务ID**: 顺序编号（T001、T002、T003...）按执行顺序\n3. **[P]标记**: 仅在任务可并行时包含（不同文件，无未完成任务的依赖）\n4. **[Story]标签**: 仅用户故事阶段任务必需\n   - 格式: [US1]、[US2]、[US3]等（映射自spec.md的用户故事）\n   - 设置阶段: 无故事标签\n   - 基础阶段: 无故事标签\n   - 用户故事阶段: 必须有故事标签\n   - 完善阶段: 无故事标签\n5. **描述**: 包含确切文件路径的清晰操作\n\n## 正确示例\n\n- ✅ 正确: `- [ ] T001 按实施计划创建项目结构`\n- ✅ 正确: `- [ ] T005 [P] 在src/middleware/auth.py中实现认证中间件`\n- ✅ 正确: `- [ ] T012 [P] [US1] 在src/models/user.py中创建User模型`\n- ✅ 正确: `- [ ] T014 [US1] 在src/services/user_service.py中实现UserService`\n\n## 错误示例\n\n- ❌ 错误: `- [ ] 创建User模型`（缺少ID和Story标签）\n- ❌ 错误: `T001 [US1] 创建模型`（缺少复选框）\n- ❌ 错误: `- [ ] [US1] 创建User模型`（缺少TaskID）\n- ❌ 错误: `- [ ] T001 [US1] 创建模型`（缺少文件路径）\n\n## 任务组织原则\n\n### 1. 从用户故事出发（spec.md）- 主要组织方式\n\n每个用户故事（P1、P2、P3...）获得自己的阶段：\n- 将所有相关组件映射到其故事：\n  - 该故事所需的模型\n  - 该故事所需的服务\n  - 该故事所需的端点/UI\n  - 如果需要测试: 特定于该故事的测试\n- 标记故事依赖关系（大多数故事应该是独立的）\n\n### 2. 从合同/端点出发\n\n- 将每个合同/端点映射到其服务的用户故事\n- 如果需要测试: 每个合同 → 在该故事阶段中实施前的合同测试任务[P]\n\n### 3. 从数据模型出发\n\n- 将每个实体映射到需要它的用户故事\n- 如果实体服务多个故事: 放入最早的故事或设置阶段\n- 关系 → 相应故事阶段中的服务层任务\n\n### 4. 从设置/基础设施出发\n\n- 共享基础设施 → 设置阶段（阶段1）\n- 基础/阻塞任务 → 基础阶段（阶段2）\n- 故事特定设置 → 在该故事的阶段内\n\n## 阶段结构\n\n- **阶段1**: 设置（项目初始化）\n- **阶段2**: 基础（阻塞先决条件 - 必须在用户故事前完成）\n- **阶段3+**: 用户故事按优先级（P1、P2、P3...）\n  - 在每个故事内: 测试（如果需要）→ 模型 → 服务 → 端点 → 集成\n  - 每个阶段应该是一个完整的、可独立测试的增量\n- **最终阶段**: 完善和横切关注点\n\n## 测试任务指南\n\n**测试是可选的**: 仅在功能规格中明确要求或用户要求TDD方法时生成测试任务。\n\n当需要测试时：\n- 为每个用户故事创建独立的测试标准\n- 确保测试可以独立运行\n- 在实施任务前包含测试设置任务",
        "skills/speckit-tasks-zh/assets/WORKFLOW.md": "# Speckit Tasks 工作流详细指南\n\n## 工作流概述\n\n本工作流用于根据可用设计文档生成可操作的、依赖有序的tasks.md。\n\n## 详细步骤\n\n### 1. 设置阶段\n\n运行环境检查脚本：\n```powershell\n.speckit/scripts/powershell/check-prerequisites.ps1 -Json\n```\n\n**重要注意事项**：\n- 所有路径必须是绝对路径\n- 对于参数中的单引号，使用转义语法：例如 `I'm Groot` 应写为 `'I'\\''m Groot'`\n- 或者尽可能使用双引号：`\"I'm Groot\"`\n\n### 2. 文档加载阶段\n\n从FEATURE_DIR读取以下文档：\n\n#### 必需文档\n- **plan.md**: 技术栈、库、项目结构\n- **spec.md**: 带优先级的用户故事\n\n#### 可选文档\n- **data-model.md**: 实体定义\n- **contracts/**: API端点定义\n- **research.md**: 技术决策\n- **quickstart.md**: 测试场景\n\n**注意**: 并非所有项目都有所有文档，基于可用内容生成任务。\n\n### 3. 任务生成工作流执行\n\n#### 文档解析步骤\n\n1. **加载plan.md**并提取：\n   - 技术栈\n   - 库依赖\n   - 项目结构\n\n2. **加载spec.md**并提取：\n   - 用户故事及其优先级（P1、P2、P3等）\n\n3. **可选文档处理**：\n   - 如果data-model.md存在：提取实体并映射到用户故事\n   - 如果contracts/存在：映射端点到用户故事\n   - 如果research.md存在：提取决策用于设置任务\n\n#### 任务组织生成\n\n1. **按用户故事组织任务**（参见任务生成规则）\n2. **生成依赖关系图**显示用户故事完成顺序\n3. **创建并行执行示例**（每个用户故事）\n4. **验证任务完整性**（每个用户故事都有所需任务，可独立测试）\n\n### 4. tasks.md生成\n\n使用模板结构填充以下内容：\n\n- 正确的功能名称（来自plan.md）\n- 阶段1: 设置任务（项目初始化）\n- 阶段2: 基础任务（所有用户故事的阻塞先决条件）\n- 阶段3+: 每个用户故事一个阶段（按spec.md中的优先级顺序）\n- 每个阶段包含：\n  - 故事目标\n  - 独立测试标准\n  - 测试（如果需要）\n  - 实施任务\n- 最终阶段: 完善和横切关注点\n- 所有任务必须遵循严格的检查表格式\n- 每个任务的清晰文件路径\n- 显示故事完成顺序的依赖关系部分\n- 每个故事的并行执行示例\n- 实施策略部分（MVP优先，增量交付）\n\n### 5. 报告生成\n\n输出以下内容的摘要：\n- 生成的tasks.md路径\n- 总任务数量\n- 每个用户故事的任务数量\n- 识别的并行机会\n- 每个故事的独立测试标准\n- 建议的MVP范围（通常仅为用户故事1）\n- 格式验证：确认所有任务都遵循检查表格式（复选框、ID、标签、文件路径）\n\n## 质量要求\n\n- tasks.md应立即可执行 - 每个任务必须足够具体，使LLM无需额外上下文即可完成\n- 确保任务间的依赖关系清晰明确\n- 验证每个用户故事的独立可测试性",
        "skills/speckit-tasks-zh/assets/tasks-template.md": "# Tasks Template\n\n# {{FEATURE_NAME}} 实施任务\n\n## 概述\n\n本文档包含 {{FEATURE_NAME}} 功能的详细实施任务，按阶段组织以确保有序执行。\n\n## 阶段 1: 设置任务（项目初始化）\n\n### 目标\n建立项目基础结构和配置。\n\n### 任务\n- [ ] T001 {{TASK_001_DESCRIPTION}}\n- [ ] T002 {{TASK_002_DESCRIPTION}}\n- [ ] T003 {{TASK_003_DESCRIPTION}}\n\n## 阶段 2: 基础任务（阻塞先决条件）\n\n### 目标\n完成所有用户故事的阻塞先决条件。\n\n### 任务\n- [ ] T004 {{TASK_004_DESCRIPTION}}\n- [ ] T005 {{TASK_005_DESCRIPTION}}\n- [ ] T006 {{TASK_006_DESCRIPTION}}\n\n## 阶段 3: 用户故事 1 {{USER_STORY_1_TITLE}}\n\n### 目标\n{{USER_STORY_1_GOAL}}\n\n### 独立测试标准\n{{USER_STORY_1_TEST_CRITERIA}}\n\n### 任务\n- [ ] T007 [P] [US1] {{US1_TASK_001}}\n- [ ] T008 [US1] {{US1_TASK_002}}\n- [ ] T009 [US1] {{US1_TASK_003}}\n\n## 阶段 4: 用户故事 2 {{USER_STORY_2_TITLE}}\n\n### 目标\n{{USER_STORY_2_GOAL}}\n\n### 独立测试标准\n{{USER_STORY_2_TEST_CRITERIA}}\n\n### 任务\n- [ ] T010 [P] [US2] {{US2_TASK_001}}\n- [ ] T011 [US2] {{US2_TASK_002}}\n- [ ] T012 [US2] {{US2_TASK_003}}\n\n## {{ADDITIONAL_PHASES}}\n\n## 最终阶段: 完善和横切关注点\n\n### 目标\n完成所有最终优化和系统级改进。\n\n### 任务\n- [ ] T{{FINAL_TASK_ID}} [P] {{FINAL_TASK_001}}\n- [ ] T{{FINAL_TASK_ID+1}} {{FINAL_TASK_002}}\n- [ ] T{{FINAL_TASK_ID+2}} {{FINAL_TASK_003}}\n\n## 依赖关系\n\n### 故事完成顺序\n1. 用户故事 1 {{USER_STORY_1_TITLE}} (P1)\n2. 用户故事 2 {{USER_STORY_2_TITLE}} (P2)\n{{ADDITIONAL_DEPENDENCIES}}\n\n## 并行执行机会\n\n### 用户故事 1\n以下任务可以并行执行：\n- {{PARALLEL_TASKS_US1}}\n\n### 用户故事 2\n以下任务可以并行执行：\n- {{PARALLEL_TASKS_US2}}\n\n## 实施策略\n\n### MVP方法\n建议首先实施用户故事1以实现MVP功能。\n\n### 增量交付\n- 第1增量: 用户故事1完成\n- 第2增量: 用户故事2完成\n{{ADDITIONAL_INCREMENTS}}\n\n## 验证检查表\n\n- [ ] 所有任务遵循正确的格式规范\n- [ ] 每个任务都有明确的文件路径\n- [ ] 用户故事可以独立测试\n- [ ] 依赖关系已明确标识\n- [ ] 并行机会已最大化"
      },
      "plugins": [
        {
          "name": "open-skilled-sdd",
          "source": "./",
          "description": "open spec-driven development workflow: OpenSpec, PRPs, Spec Kit, spec-workflow-mcp, BMad-Method, 6A workflow",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add forztf/open-skilled-sdd",
            "/plugin install open-skilled-sdd@open-skilled-sdd-marketplace"
          ]
        }
      ]
    }
  ]
}