{
  "author": {
    "id": "athola",
    "display_name": "Alex Thola",
    "avatar_url": "https://avatars.githubusercontent.com/u/9769290?u=28ab3d7bdb042234eee2a7f3d280a824092bdc10&v=4"
  },
  "marketplaces": [
    {
      "name": "claude-night-market",
      "version": null,
      "description": "Personal Claude Code plugin collection: architecture patterns, intelligent delegation, resource optimization, code review, and spatial memory systems",
      "repo_full_name": "athola/claude-night-market",
      "repo_url": "https://github.com/athola/claude-night-market",
      "repo_description": "Marketplace repo for Claude Code Plugins developed from personal projects and workflow",
      "signals": {
        "stars": 176,
        "forks": 18,
        "pushed_at": "2026-02-19T22:00:30Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-night-market\",\n  \"owner\": {\n    \"name\": \"athola\",\n    \"email\": \"athola@users.noreply.github.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Personal Claude Code plugin collection: architecture patterns, intelligent delegation, resource optimization, code review, and spatial memory systems\",\n    \"version\": \"1.4.3\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"abstract\",\n      \"source\": \"./plugins/abstract\",\n      \"description\": \"Meta-skills infrastructure for Claude Code plugin ecosystem - skill authoring, hook development, modular design patterns, and evaluation frameworks\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"attune\",\n      \"source\": \"./plugins/attune\",\n      \"description\": \"Full-cycle project development - brainstorm ideas, create specifications, plan architecture, initialize projects, and execute implementation with integrated workflows from superpowers and spec-kit\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"archetypes\",\n      \"source\": \"./plugins/archetypes\",\n      \"description\": \"Architecture paradigm selection and implementation planning - 14 paradigm skills from functional-core to microservices\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"conjure\",\n      \"source\": \"./plugins/conjure\",\n      \"description\": \"Intelligent delegation framework for routing tasks to external LLMs (Gemini, Qwen) while retaining strategic oversight\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"conserve\",\n      \"source\": \"./plugins/conserve\",\n      \"description\": \"Resource optimization and bloat detection - CPU/GPU performance monitoring, token conservation, bloat detection, and codebase cleanup\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"hookify\",\n      \"source\": \"./plugins/hookify\",\n      \"description\": \"Create custom behavioral rules through markdown configuration - prevent unwanted behaviors with pattern matching and zero-code rule authoring\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"imbue\",\n      \"source\": \"./plugins/imbue\",\n      \"description\": \"Intelligent workflow methodologies - review-core scaffolding, diff analysis, evidence logging, and catchup patterns\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"leyline\",\n      \"source\": \"./plugins/leyline\",\n      \"description\": \"Storage and persistence patterns - templates for data management and storage solutions\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"memory-palace\",\n      \"source\": \"./plugins/memory-palace\",\n      \"description\": \"Spatial knowledge organization with memory palace techniques - includes skill execution memory storage for continual learning\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"minister\",\n      \"source\": \"./plugins/minister\",\n      \"description\": \"Project management plugin that aligns initiatives with GitHub data - turns repositories, issues, and projects into status dashboards\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"parseltongue\",\n      \"source\": \"./plugins/parseltongue\",\n      \"description\": \"Language detection, pattern matching, and testing guidance for multi-language codebases\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"pensive\",\n      \"source\": \"./plugins/pensive\",\n      \"description\": \"Reflective code review toolkit - domain reviews (architecture, bugs, APIs, math, Rust, tests, Makefiles) plus skill performance analysis with stability gap detection\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"sanctum\",\n      \"source\": \"./plugins/sanctum\",\n      \"description\": \"Git and workspace operations - commit messages, PR prep, documentation updates, version bumping\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"scribe\",\n      \"source\": \"./plugins/scribe\",\n      \"description\": \"Documentation review, cleanup, and generation with AI slop detection, style learning, and human-quality writing enforcement\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"scry\",\n      \"source\": \"./plugins/scry\",\n      \"description\": \"Media generation - terminal recordings (VHS), browser recordings (Playwright), GIF processing, and media composition\",\n      \"version\": \"1.4.3\"\n    },\n    {\n      \"name\": \"spec-kit\",\n      \"source\": \"./plugins/spec-kit\",\n      \"description\": \"Specification-driven development - spec writing, implementation planning, and task orchestration\",\n      \"version\": \"1.4.3\"\n    }\n  ]\n}\n",
        "README.md": "# Claude Night Market\n\n**Claude Code plugins for software engineering workflows.**\n\nThis repository adds 16 plugins to Claude Code for git operations, code review, spec-driven development, and issue management. Each plugin functions independently to allow selective installation while sharing a common testing framework for consistency.\n\n## Features\n\n**Governance & Quality**\nHooks adapt context based on the active agent. `pensive` tracks usage frequency and failure rates to identify unstable workflows. `imbue` enforces test-driven development via a PreToolUse hook that verifies the existence of test files before allowing implementation writes. For complex tasks, `imbue:rigorous-reasoning` requires step-by-step logic checks before tool execution.\n\n**Security & Session Management**\n`leyline` manages OAuth flows for GitHub, GitLab, and AWS with local token caching. `conserve` implements permission checks, automatically approving safe commands like `ls` while blocking high-risk operations like `rm -rf /`. `sanctum` isolates named sessions for debugging, feature work, and PR reviews. Quality gates in `/create-skill` and `/create-command` halt execution if the project has failing tests.\n\n**Maintenance & Resilience**\n`/cleanup` orchestrates bloat removal, code refinement, and AI hygiene auditing in a single pass with progressive depth levels. `/update-ci` reconciles pre-commit hooks and GitHub Actions workflows with recent code changes, detecting renamed files and orphaned references. `/update-plugins` recommends updates based on plugin stability metrics and includes module auditing to detect orphaned or missing skill references. `/fix-workflow` attempts to repair failed runs by analyzing previous errors. `/abstract:make-dogfood` generates or validates Makefile targets for all documented commands across plugins, with automatic language detection for Python, Rust, and TypeScript projects. `abstract`'s homeostatic monitor tracks skill stability after each invocation and auto-triggers the `skill-improver` agent when degradation is detected, with rollback review via GitHub issues. For strategic decisions, `/attune:war-room` uses a Type 1/2 reversibility framework to route choices to appropriate expert subagents, with `war-room-checkpoint` enabling embedded escalation at decision points during implementation. `leyline` adds `damage-control` for agent-level crash recovery and context overflow handling, and `risk-classification` for 4-tier task risk gating (GREEN/YELLOW use heuristic matching, RED/CRITICAL escalate to war-room-checkpoint).\n\n**Cross-Session State (Claude Code 2.1.16+)**\n`attune`, `spec-kit`, and `sanctum` integrate with the native Claude Code Tasks system. Task creation occurs on-demand, and state persists across sessions via `CLAUDE_CODE_TASK_LIST_ID`. The `war-room-checkpoint` skill integrates with commands like `/do-issue`, `/pr-review`, `/fix-pr`, and `/architecture-review` to trigger expert deliberation when high-stakes decisions emerge during workflows. Ambiguity detection prompts for user decisions when task boundaries are unclear. Versions prior to 2.1.16 use file-based state by default. Claude Code 2.1.20+ supports task deletion via `TaskUpdate`, 2.1.32+ adds agent teams for parallel execution in `/do-issue`, `/fix-pr`, and `/pr-review` (with automatic downgrade for small-scope tasks), and 2.1.33+ adds persistent agent memory scoped to user, project, or session. 2.1.38 hardens heredoc delimiter parsing against command smuggling and sandboxes `.claude/skills` writes. 2.1.39 adds nested session guards and fixes agent teams model selection for Bedrock/Vertex/Foundry providers.\n\n## Workflow Improvements\n\nCommands automate multi-step processes to reduce manual intervention. `/prepare-pr` validates branch scope, runs configured linters, and verifies a clean git state before drafting a pull request. `/full-review` audits syntax, logic, and security in a single pass. `/speckit-specify` requires a written specification phase before generating code. To maintain context, `/catchup` reads recent git history, and `/attune:project-init` detects project types (Python, Node) to scaffold configuration files. `/attune:mission` wraps the full project lifecycle into a single resumable command with artifact-based state detection and error recovery via `leyline:damage-control`.\n\n## Requirements\n\n- **Claude Code** 2.1.16+ (2.1.32+ for agent teams, 2.1.38+ for full security features)\n- **Python 3.9+** — hooks execute under the system Python (macOS ships 3.9.6). Plugin packages and scripts may target 3.10+ or 3.12+ via virtual environments, but **all hook code must be 3.9-compatible**\n\n### Python 3.9 Hook Compatibility Rules\n\nHooks run outside virtual environments, so they must avoid syntax and APIs added after 3.9:\n\n| Feature | Requires | Use Instead |\n|---------|----------|-------------|\n| `X \\| Y` union types | 3.10+ | `from __future__ import annotations` |\n| `@dataclass(slots=True)` | 3.10+ | `@dataclass` (omit `slots`) |\n| `datetime.UTC` | 3.11+ | `datetime.timezone.utc` |\n| `import tomllib` | 3.11+ | `import tomli` or parse manually |\n| `import yaml` | not stdlib | wrap in `try/except ImportError` |\n\nSee the [Plugin Development Guide](docs/plugin-development-guide.md) for the full list.\n\n## Quick Start\n\n### Claude Code Plugin Commands\n\n```bash\n# 1. Add the marketplace\n/plugin marketplace add athola/claude-night-market\n\n# 2. Install plugins\n/plugin install sanctum@claude-night-market    # Git workflows\n/plugin install pensive@claude-night-market    # Code review\n/plugin install spec-kit@claude-night-market   # Spec-driven dev\n\n# 3. Use\n/prepare-pr                                    # Prepare a pull request\n/full-review                                   # Run code review\nSkill(sanctum:git-workspace-review)            # Invoke a skill\n```\n\n### npx skills\n\n```bash\n# Install the entire marketplace\nnpx skills add athola/claude-night-market\n\n# Or install specific plugins\nnpx skills add athola/claude-night-market/sanctum    # Git workflows\nnpx skills add athola/claude-night-market/pensive    # Code review\nnpx skills add athola/claude-night-market/conserve   # Resource optimization\n```\n\n### Post-Installation Setup (Claude Code 2.1.16+)\n\nInitialize plugins with Setup hooks:\n\n```bash\n# One-time initialization\nclaude --init\n\n# Weekly maintenance\nclaude --maintenance\n```\n\n> **Note:** If the `Skill` tool is unavailable, read skill files at `plugins/{plugin}/skills/{skill-name}/SKILL.md`.\n\n**Detailed instructions:** See the [Installation Guide](book/src/getting-started/installation.md).\n\n## What's Included\n\n**16 plugins** organized in layers, each building on foundations below:\n\n```mermaid\nflowchart TB\n    classDef domainClass fill:#e8f4f8,stroke:#2980b9,stroke-width:2px,color:#2c3e50\n    classDef utilityClass fill:#f8f4e8,stroke:#f39c12,stroke-width:2px,color:#2c3e50\n    classDef foundationClass fill:#f4e8f8,stroke:#8e44ad,stroke-width:2px,color:#2c3e50\n    classDef metaClass fill:#e8f4e8,stroke:#27ae60,stroke-width:2px,color:#2c3e50\n\n    subgraph Domain[\"Domain Specialists\"]\n        direction LR\n        D1[archetypes]:::domainClass\n        D2[pensive]:::domainClass\n        D3[parseltongue]:::domainClass\n        D4[memory-palace]:::domainClass\n        D5[spec-kit]:::domainClass\n        D6[minister]:::domainClass\n        D7[attune]:::domainClass\n        D8[scry]:::domainClass\n        D9[scribe]:::domainClass\n    end\n\n    subgraph Utility[\"Utility Layer\"]\n        direction LR\n        U1[conserve]:::utilityClass\n        U2[conjure]:::utilityClass\n        U3[hookify]:::utilityClass\n    end\n\n    subgraph Foundation[\"Foundation Layer\"]\n        direction LR\n        F1[imbue]:::foundationClass\n        F2[sanctum]:::foundationClass\n        F3[leyline]:::foundationClass\n    end\n\n    subgraph Meta[\"Meta Layer\"]\n        direction LR\n        M1[abstract]:::metaClass\n    end\n\n    Domain ==> Utility ==> Foundation ==> Meta\n```\n\n### Layer Overview\n\n1.  **Foundation Layer**: Core utilities. `sanctum` (git and sessions), `leyline` (auth and quotas), and `imbue` (TDD cycles).\n2.  **Utility Layer**: Resource management. `conserve` (context optimization) and `hookify` (rules engine with hook conversion and context-aware rule suggestions).\n3.  **Domain Specialists**: Task-specific logic. `pensive` (code review and refinement, including NASA Power of 10 safety patterns), `spec-kit` (requirements), `minister` (issue tracking), and `attune` (project lifecycle from brainstorm to execution). `attune` commands auto-chain forward by default (use `--standalone` to run a single phase). `/attune:mission` orchestrates the full brainstorm→specify→plan→execute lifecycle with state persistence and session recovery.\n4.  **Meta Layer**: `abstract` provides tools for plugin and skill authoring, including Makefile generation and command-to-target validation. Its self-adapting system monitors skill stability via a PostToolUse hook, queues degrading skills for automatic improvement, and creates human-gated GitHub issues when regressions are detected.\n\nSee [Capabilities Reference](book/src/reference/capabilities-reference.md) for the full list of 126 skills, 103 commands, and 41 agents across all 16 plugins.\n\n## Common Workflows\n\nDetails are available in the [Common Workflows Guide](book/src/getting-started/common-workflows.md).\n\n| Workflow | Command | Example |\n|----------|-------------|---------|\n| Full project lifecycle | `/attune:mission` | Auto-detects state, routes through phases, supports resume |\n| Initialize project | `/attune:arch-init` | `attune:arch-init --name my-api` |\n| Review a PR | `/full-review` | Run multi-discipline code review |\n| Architecture review | `/fpf-review` | FPF analysis |\n| Fix PR feedback | `/fix-pr` | Address review comments |\n| Implement issues | `/do-issue` | Progressive issue resolution |\n| Fix workflow issues | `/fix-workflow` | Self-correcting with Reflexion |\n| Prepare a PR | `/prepare-pr` | Quality gates before merge |\n| Create GitHub issue | `/create-issue` | Interactive issue creation |\n| Manage labels | `/update-labels` | GitHub label taxonomy |\n| Catch up on changes | `/catchup` | Context recovery |\n| Write specifications | `/speckit-specify` | Spec-driven development |\n| Debug issues | `Skill(superpowers:debugging)` | Root cause analysis |\n| Codebase cleanup | `/cleanup` | Orchestrated bloat, quality, and hygiene scan |\n| Update CI/CD | `/update-ci` | Reconcile hooks and workflows with code changes |\n| Refine code | `/refine-code` | Duplication, algorithms, and clean code analysis |\n| Safety review | `Skill(pensive:safety-critical-patterns)` | NASA Power of 10 guidelines for robust code |\n| Improve plugins | `/update-plugins` | Update based on stability metrics + module audit |\n| Generate Makefiles | `/abstract:make-dogfood` | Auto-generate Makefiles for plugins with language detection |\n| Strategic decisions | `/attune:war-room` | Expert routing with reversibility scoring |\n| Embedded escalation | `Skill(attune:war-room-checkpoint)` | Inline expert deliberation at decision points |\n\n## LSP Integration\n\nLSP (Language Server Protocol) support requires Claude Code v2.0.74+. It enables symbol search in ~50ms, significantly faster than standard text search.\n\n**Setup:**\n\n1.  Enable LSP in `~/.claude/settings.json`:\n    ```json\n    { \"env\": { \"ENABLE_LSP_TOOL\": \"1\" } }\n    ```\n2.  Install language servers (e.g., `npm install -g pyright`).\n3.  Install LSP plugins:\n    ```bash\n    /plugin install pyright-lsp@claude-plugins-official\n    ```\n\nSee [LSP Native Support Guide](docs/guides/lsp-native-support.md).\n\n## Extending Night Market\n\nTo create a new plugin:\n\n```bash\nmake create-plugin NAME=my-plugin\nmake validate\nmake lint && make test\n```\n\nRefer to the [Plugin Development Guide](docs/plugin-development-guide.md).\n\n## Prompt Context Usage\n\nThe ecosystem adds ~14.8k characters to the system prompt. As of Claude Code 2.1.32+, the skill description budget scales at 2% of context window instead of a fixed limit. Plugins use modular designs and progressive loading to stay within these limits.\n\n## Contributing\n\nEach plugin maintains its own tests and documentation. See the [Plugin Development Guide](docs/plugin-development-guide.md).\n\n## License\n\n[MIT](LICENSE)\n",
        "plugins/abstract/README.md": "# Abstract Plugin Infrastructure\n\nTools for building and evaluating Claude Code skills. Includes modular patterns, quality checks, and plugin validation.\n\n## Quick Start\n\n```bash\nmake check          # Install dependencies\nmake test           # Run quality checks\nmake install-hooks  # Set up git hooks\n```\n\n## Installation\n\nAdd to `marketplace.json`:\n\n```json\n{\n  \"name\": \"abstract\",\n  \"source\": { \"source\": \"url\", \"url\": \"https://github.com/athola/abstract.git\" },\n  \"description\": \"Meta-skills infrastructure - modular design and evaluation\",\n  \"version\": \"1.4.3\",\n  \"strict\": true\n}\n```\n\nClaude loads the plugin on startup.\n\n## What's Included\n\nAbstract provides skills, commands, and agents for plugin development. `methodology-curator` surfaces expert frameworks, while `modular-skills` provides architectural guidance. Use `skills-eval` to score and improve skill quality.\n\nThe `/validate-plugin` command checks structures against requirements. Specialized agents like `plugin-validator` and `meta-architect` assist during review.\n\n## Structure\n\n*   `skills/`: Skill implementations.\n*   `scripts/`: Validation and analysis tools.\n*   `src/abstract/`: Shared Python package.\n*   `shared-modules/`: Reusable enforcement patterns for cross-skill reference.\n    *   `iron-law-interlock.md`: Hard gate for TDD compliance in creation workflows.\n    *   `enforcement-language.md`: Language intensity calibration.\n    *   `anti-rationalization.md`: Bypass prevention patterns.\n    *   `trigger-patterns.md`: Skill trigger design patterns.\n*   `docs/`: Technical documentation, ADRs, and examples.\n    *   `docs/examples/modular-skills/`: Implementation examples for modular skill patterns.\n\n## Documentation\n\n- **Skill Observability & Continual Learning**: `../../docs/guides/skill-observability-guide.md` - zero-dependency skill tracking with PreToolUse/PostToolUse hooks and stability gap detection\n- **Skill Assurance Framework**: `docs/skill-assurance-framework.md` - patterns for reliable skill discovery (frontmatter-only triggers, enforcement language, migration guide)\n- **Migration Guide**: `docs/migration-guide.md` - updating skills to new patterns\n- **Python Structure**: `docs/python-structure.md` - package organization\n- **ADRs**: `docs/adr/` - architecture decisions\n- **Multi-Plugin Design**: `docs/multi-plugin-design.md` - composition model\n\nEach skill has its own `SKILL.md` with usage details. Run `make status` for a project overview.\n\n## Security\n\nThe CI pipeline runs Bandit, Safety, and Semgrep on each push. Pre-commit hooks catch issues locally.\n\n```bash\nmake security   # Run security scans locally\n```\n\n## Development\n\n```bash\nmake format        # Format code\nmake test          # Run all checks\nmake security      # Security scans\nmake clean         # Clean cache\nmake unit-tests    # Run tests\nmake test-coverage # Coverage report\n```\n\nTests validate skill discoverability and structure.\n",
        "plugins/attune/README.md": "# Attune\n\nProject development plugin for Claude Code. Support ideation, specification, architectural planning, project initialization, and implementation.\n\n## Overview\n\nStandardize project development:\n\n1. **Brainstorm**: Ideate and explore problem space.\n2. **War Room**: Multi-expert deliberation to select approach.\n3. **Specify**: Create detailed specifications.\n4. **Plan**: Design architecture and break down tasks.\n5. **Init**: Initialize or update project structure.\n6. **Execute**: Implement systematically with tracking.\n\n## Features\n\n### Supported Languages\n\n- **Python**: uv, pytest, ruff, mypy.\n- **Rust**: cargo, clippy, rustfmt.\n- **TypeScript/React**: npm/pnpm/yarn, vite, jest, eslint.\n\n### Configuration\n\n- Git initialization with .gitignore.\n- GitHub Actions workflows (test, lint, typecheck).\n- Pre-commit hooks and Makefiles.\n- Dependency management and project structure.\n\n## Discoverability (v1.4.0)\n\nAll attune skills, commands, and agents now feature **enhanced automatic discovery** through optimized descriptions following a proven pattern:\n\n```\n[WHAT it does]. Use when: [triggers]. Do not use when: [boundaries].\n```\n\n### How It Works\n\nClaude automatically matches your natural language requests to the appropriate attune component based on the description. Enhanced descriptions include:\n\n1. **WHAT**: Clear action or capability statement\n2. **WHEN**: Trigger keywords and scenarios (e.g., \"starting projects\", \"comparing approaches\")\n3. **WHEN NOT**: Explicit boundaries preventing false positives (e.g., \"requirements already exist\")\n\n### Discovery Examples\n\n| You say... | Claude invokes... | Why |\n|-----------|-------------------|-----|\n| \"I want to start a new web app\" | `/attune:brainstorm` | Matches \"starting projects\" trigger |\n| \"Create a specification from my brief\" | `/attune:specify` | Matches \"create specifications\" |\n| \"Design the system architecture\" | `project-architect` agent | Matches \"designing system architecture\" |\n| \"Should I convene a war room?\" | `Skill(attune:war-room)` | Matches \"strategic decisions\" |\n\n### Content Structure\n\nEvery skill and command includes:\n\n- **When To Use**: 5-7 specific scenarios triggering this component\n- **When NOT To Use**: Clear boundaries with alternatives (e.g., \"use `/attune:blueprint` instead\")\n\nThis prevents misuse and guides you to the right tool for your current workflow stage.\n\n### For Contributors\n\nWhen adding new skills or commands, follow the templates in `plugins/attune/templates/`:\n- `skill-discoverability-template.md` - For skills\n- `command-discoverability-template.md` - For commands\n- `agent-discoverability-template.md` - For agents\n- `TEMPLATE-GUIDE.md` - Detailed guidance and examples\n\n## Quick Start\n\n### Architecture-Aware Initialization\n\n```bash\n# Interactive mode with architecture selection\n/attune:arch-init --name my-project\n```\n\n### Standard Initialization\n\n```bash\n# Interactive mode\n/attune:project-init\n\n# Language specification\n/attune:project-init --lang python --name my-project --author \"Your Name\"\n```\n\n### Upgrade Existing Project\n\n```bash\n# Add missing configurations\n/attune:upgrade-project\n\n# Validate project structure\n/attune:validate\n```\n\n## Commands\n\n### Full-Cycle Workflow\n\n| Command | Description | Phase |\n|---------|-------------|-------|\n| `/attune:brainstorm` | Brainstorm project ideas using Socratic questioning | 1. Ideation |\n| `/attune:war-room` | **Multi-LLM expert deliberation for approach selection** | 2. Deliberation |\n| `/attune:arch-init` | **Architecture-aware initialization with research** | 3. Architecture |\n| `/attune:specify` | Create detailed specifications from war-room decision | 4. Specification |\n| `/attune:blueprint` | Plan architecture and break down into tasks | 5. Planning |\n| `/attune:project-init` | Initialize or update project structure with tooling | 6. Initialization |\n| `/attune:execute` | Execute implementation tasks systematically | 7. Implementation |\n\n**War Room Integration**: The war-room is a **mandatory phase** after brainstorming. It automatically routes to the appropriate deliberation intensity based on Reversibility Score (RS):\n- **Express** (RS ≤ 0.40): Quick decision by Chief Strategist (<2 min)\n- **Lightweight** (RS 0.41-0.60): 3-expert panel (5-10 min)\n- **Full Council** (RS 0.61-0.80): 7-expert deliberation (15-30 min)\n- **Delphi** (RS > 0.80): Iterative consensus for critical decisions (30-60 min)\n\nThe `war-room-checkpoint` skill can also trigger additional deliberation during planning or execution when high-stakes decisions arise.\n\n### Project Management\n\n| Command | Description |\n|---------|-------------|\n| `/attune:upgrade-project` | Add or update configurations in existing project |\n| `/attune:validate` | Validate project structure against best practices |\n\n## Skills\n\n### Full-Cycle Workflow Skills\n\n| Skill | Description | Use When |\n|-------|-------------|----------|\n| `project-brainstorming` | Socratic questioning and ideation | Starting new project from idea |\n| `war-room` | **Multi-LLM expert council with Type 1/2 routing** | Complex strategic decisions (RS > 0.40) |\n| `war-room-checkpoint` | **Inline RS assessment for embedded escalation** | Called by other commands at decision points |\n| `project-specification` | Spec-driven requirement definition | Need detailed requirements |\n| `project-planning` | Architecture design and task breakdown | Planning implementation |\n| `project-execution` | Systematic task execution with TDD | Implementing planned tasks |\n\n### Initialization Skills\n\n| Skill | Description | Use When |\n|-------|-------------|----------|\n| `architecture-aware-init` | **Research-based architecture selection and template customization** | Need architecture guidance |\n| `project-init` | Interactive project initialization | Setting up new project |\n| `makefile-generation` | Generate language-specific Makefile | Need build automation |\n| `workflow-setup` | Configure GitHub Actions workflows | Setting up CI/CD |\n| `precommit-setup` | Configure pre-commit hooks | Enforcing code quality |\n\n## Agents\n\n| Agent | Description | Capabilities |\n|-------|-------------|--------------|\n| `project-architect` | Architecture design agent | Requirement analysis, component design, data modeling |\n| `project-implementer` | Implementation execution agent | TDD workflow, checkpoint validation, progress tracking |\n\n## Templates\n\nTemplates are based on proven patterns from reference projects:\n\n- **Python**: Based on `simple-resume` project structure\n- **Rust**: Based on `skrills` project structure\n- **TypeScript**: Based on modern React/Vite patterns\n\n### Python Template Includes\n\n- `.gitignore` - Python-specific ignores\n- `pyproject.toml` - uv-based dependency management\n- `Makefile` - Development targets (test, lint, format, etc.)\n- `.pre-commit-config.yaml` - Formatting, linting, type checking hooks\n- `.github/workflows/test.yml` - CI testing workflow\n- `.github/workflows/lint.yml` - Linting workflow\n- `.github/workflows/typecheck.yml` - Type checking workflow\n\n## Configuration\n\nAttune can be configured via `.attune.yaml`:\n\n```yaml\nlanguage: python\npython_version: \"3.10\"\npackage_manager: uv\nauthor: \"Your Name\"\nlicense: MIT\n\nfeatures:\n  pre_commit: true\n  github_workflows: true\n  makefile: true\n  type_checking: true\n  testing: true\n\ncustomization:\n  makefile_targets:\n    - name: custom-task\n      command: ./scripts/custom.sh\n```\n\n## Template Customization\n\n### Override Templates\n\nPlace custom templates in `~/.claude/attune/templates/`:\n\n```\n~/.claude/attune/templates/\n└── python/\n    ├── .gitignore.template\n    └── Makefile.template\n```\n\n### Template Variables\n\nAvailable in all templates:\n\n- `{{PROJECT_NAME}}` - Project name.\n- `{{PROJECT_MODULE}}` - Python module name.\n- `{{AUTHOR}}` - Project author.\n- `{{PYTHON_VERSION}}` - Python version.\n- `{{YEAR}}` - Current year.\n- `{{LICENSE}}` - License type.\n\n## Integration with Other Plugins\n\n### Superpowers Integration\n\nWith the superpowers plugin, Attune integrates foundational methodology skills:\n\n- **Brainstorming**: `Skill(superpowers:brainstorming)`\n- **Planning**: `Skill(superpowers:writing-plans)`\n- **Execution**: `Skill(superpowers:executing-plans)`\n- **TDD**: Test-driven development during implementation.\n- **Debugging**: `Skill(superpowers:systematic-debugging)`\n\n### Spec-Kit Integration\n\nWith spec-kit, Attune aligns with specification patterns:\n\n- **Specifications**: `Skill(spec-kit:spec-writing)`\n- **Task Planning**: `Skill(spec-kit:task-planning)`\n\n## Philosophy\n\nAttune enforces structured workflows from ideation to implementation, integrating with plugins and requiring confirmation for file operations. Templates follow industry practices and support full customization.\n\n## License\n\nMIT\n\n## Related Projects\n\n- [simple-resume](https://github.com/athola/simple-resume) - Python reference project\n- [skrills](https://github.com/athola/skrills) - Rust reference project\n- [claude-night-market](https://github.com/athola/claude-night-market) - Plugin marketplace\n",
        "plugins/archetypes/README.md": "# Architecture Paradigms Collection\n\nSoftware architecture decision-making and implementation guidance across 14 architectural paradigms.\n\n- **Orchestrator**: Use `Skill(architecture-paradigms)` to select a paradigm.\n- **Comparison**: See [Quick Reference Matrix](#quick-reference-matrix).\n- **Learning**: Follow [Learning Paths](#learning-paths).\n\n## Paradigms\n\n### Core Architectural Patterns\n- **Layered Architecture**: Traditional N-tier separation of concerns.\n- **Hexagonal (Ports & Adapters)**: Infrastructure independence and flexibility.\n- **Functional Core, Imperative Shell**: Business logic isolation for testability.\n\n### Distributed Systems\n- **Microservices**: Independent business capability services.\n- **Service-Based Architecture**: Coarse-grained services (SOA-lite).\n- **Event-Driven Architecture**: Asynchronous, decoupled communication.\n- **CQRS + Event Sourcing**: Command/query separation with audit trails.\n\n### Specialized Patterns\n- **Modular Monolith**: Single deployable with strong internal boundaries.\n- **Serverless**: Function-as-a-Service systems.\n- **Space-Based**: In-memory data grids for linear scalability.\n- **Pipeline**: Processing stages for ETL workflows.\n- **Microkernel**: Plugin architecture for extensible platforms.\n- **Client-Server**: Traditional centralized or P2P systems.\n\n## Learning Paths\n\n### 1. Architecture Fundamentals (Beginner)\n**Duration**: 2-3 weeks\n**Goal**: Learn basic architectural concepts and patterns.\n\n1. **Start**: `architecture-paradigms` (overview and selection).\n2. **Core**: Study `architecture-paradigm-layered` (fundamental pattern).\n3. **Progress**: Learn `architecture-paradigm-functional-core` (testability principles).\n4. **Practice**: Apply layered architecture to a simple project.\n\n**Skills Covered**: Layered, Functional Core, basic architecture principles.\n\n### 2. Modern Architecture Patterns (Intermediate)\n**Duration**: 3-4 weeks\n**Goal**: Learn contemporary architectural approaches.\n\n1. **Foundation**: Complete Architecture Fundamentals path.\n2. **Flexibility**: Study `architecture-paradigm-hexagonal` (infrastructure independence).\n3. **Evolution**: Learn `architecture-paradigm-modular-monolith` (strong boundaries).\n4. **Integration**: Practice combining paradigms in a single system.\n\n**Skills Covered**: Hexagonal, Modular Monolith, paradigm combination.\n\n### 3. Distributed Systems Architecture (Advanced)\n**Duration**: 4-6 weeks\n**Goal**: Design and implement distributed architectures.\n\n1. **Prerequisites**: Complete Modern Architecture Patterns path.\n2. **Distributed Basics**: Study `architecture-paradigm-microservices` (independent services).\n3. **Communication**: Learn `architecture-paradigm-event-driven` (asynchronous systems).\n4. **Advanced**: Learn `architecture-paradigm-cqrs-es` (complex collaboration domains).\n5. **Specialization**: Choose serverless, space-based, or service-based patterns.\n\n**Skills Covered**: Microservices, Event-Driven, CQRS/ES, specialized patterns.\n\n### 4. Domain-Specific Architecture (Specialized)\n**Duration**: 2-3 weeks each\n**Goal**: Gain expertise in specific architectural domains.\n\n#### Real-time & Streaming Systems\n- **Primary**: Event-Driven Architecture.\n- **Secondary**: Space-Based Architecture.\n- **Tertiary**: Pipeline Architecture.\n- **Use Case**: IoT, financial trading, logistics platforms.\n\n#### High-Throughput Web Applications\n- **Primary**: Microservices.\n- **Secondary**: Serverless.\n- **Tertiary**: CQRS/ES.\n- **Use Case**: Social media, e-commerce, content platforms.\n\n#### Enterprise Integration\n- **Primary**: Service-Based Architecture.\n- **Secondary**: Hexagonal Architecture.\n- **Tertiary**: Modular Monolith.\n- **Use Case**: ERP systems, banking, legacy modernization.\n\n#### Extensible Platforms\n- **Primary**: Microkernel Architecture.\n- **Secondary**: Plugin-based design patterns.\n- **Use Case**: IDEs, marketplaces, integration platforms.\n\n## Quick Reference Matrix\n\n| Paradigm | Complexity | Team Size | Best For | Key Benefits | Common Use Cases |\n|----------|------------|------------|-----------|--------------|------------------|\n| **Layered** | Low | Small-Medium | Simple domains | Simplicity, familiarity | Basic web apps, internal tools |\n| **Functional Core** | Medium | Small-Large | Complex business logic | Testability, clarity | Financial systems, rule engines |\n| **Hexagonal** | Medium | Small-Large | Infrastructure changes | Flexibility, isolation | Framework migrations, integrations |\n| **Modular Monolith** | Medium | Medium-Large | Evolving systems | Strong boundaries, single deploy | Growing applications, team scaling |\n| **Microservices** | High | Large | Complex domains | Team autonomy, scaling | Enterprise applications, platforms |\n| **Service-Based** | Medium | Medium-Large | Shared database needs | Coarse-grained services | ERPs, legacy system evolution |\n| **Event-Driven** | High | Medium-Large | Real-time processing | Scalability, decoupling | IoT, analytics, notifications |\n| **CQRS/ES** | High | Medium-Large | Audit requirements | Immutable history | Financial systems, collaboration |\n| **Serverless** | Medium | Small-Medium | Bursty workloads | Minimal operations | APIs, cron jobs, data processing |\n| **Space-Based** | High | Medium-Large | High traffic stateful | Linear scalability | Trading platforms, gaming |\n| **Pipeline** | Medium | Small-Medium | ETL workflows | Stage isolation | Data processing, CI/CD |\n| **Microkernel** | Medium | Small-Medium | Extensible platforms | Plugin architecture | IDEs, marketplaces, frameworks |\n| **Client-Server** | Low | Small-Medium | Traditional apps | Simple deployment | Web apps, mobile backends |\n\n## Paradigm Evolution Path\n\n### Typical Architecture Evolution Journey\nStartups often begin with a Layered Architecture. As the team grows to 10-50 engineers, a Modular Monolith helps manage complexity. Scaling to 50-200 engineers typically necessitates a move to Microservices or a Service-Based architecture. At maturity (200+ engineers), systems often evolve into Event-Driven architectures combined with specialized patterns.\n\n### Common Migration Paths\nMigration from a monolith to a distributed system generally moves from Layered to Modular Monolith, then to Microservices, and finally to Event-Driven. Increasing complexity drives evolution from Layered to Hexagonal, then Functional Core, and potentially CQRS/ES. Cloud-native transitions typically progress from Layered to Modular Monolith, then to Serverless or Event-Driven architectures.\n\n### Architecture Decision Triggers\n\n**Scale Triggers** (When to evolve architecture):\n- Team size crosses threshold (5, 15, 50, 200 engineers).\n- Deployment frequency needs increase.\n- Independent scaling requirements emerge.\n- Geographic distribution becomes necessary.\n\n**Complexity Triggers** (When to adopt patterns):\n- Business rules become complex (Functional Core).\n- Integration points increase (Hexagonal).\n- Real-time requirements emerge (Event-Driven).\n- Audit/compliance needs arise (CQRS/ES).\n\n**Technology Triggers** (When to change patterns):\n- Framework migration needed (Hexagonal).\n- Cloud migration planned (Serverless/Microservices).\n- Performance bottlenecks appear (Space-Based/Pipeline).\n- Platform requirements emerge (Microkernel).\n\n## Repository Structure\n\n```\narchetypes/\n├── plugin.json                              # Plugin configuration\n├── README.md                               # This guide\n└── skills/\n    ├── architecture-paradigms/             # Main orchestrator skill\n    │   └── SKILL.md                        # Interactive paradigm selection\n    ├── architecture-paradigm-layered/      # Individual paradigm skills\n    ├── architecture-paradigm-functional-core/\n    ├── architecture-paradigm-hexagonal/\n    ├── architecture-paradigm-modular-monolith/\n    ├── architecture-paradigm-microservices/\n    ├── architecture-paradigm-service-based/\n    ├── architecture-paradigm-event-driven/\n    ├── architecture-paradigm-cqrs-es/\n    ├── architecture-paradigm-serverless/\n    ├── architecture-paradigm-space-based/\n    ├── architecture-paradigm-pipeline/\n    ├── architecture-paradigm-microkernel/\n    └── architecture-paradigm-client-server/\n        └── SKILL.md                        # Detailed guidance\n```\n\n## Usage Guidelines\n\n### For Architecture Reviews\n```bash\n# Start with paradigm selection\nSkill(architecture-paradigms)\n\n# Deep dive on specific paradigms\nSkill(architecture-paradigm-hexagonal)\nSkill(architecture-paradigm-microservices)\n```\n\n### For New Projects\n```bash\n# Use orchestrator for guided selection\nSkill(architecture-paradigms)\n\n# Load chosen paradigm for implementation\nSkill(architecture-paradigm-[selected-pattern])\n```\n\n### For Legacy Modernization\n```bash\n# Start with modular monolith assessment\nSkill(architecture-paradigm-modular-monolith)\n\n# Plan evolution to distributed systems\nSkill(architecture-paradigm-microservices)\n```\n\n## Integration with Other Skills\n\nThis collection integrates with:\n\n- **architecture-review**: Architecture evaluation.\n- **writing-plans**: Detailed implementation planning.\n- **systematic-debugging**: Architecture refactoring approaches.\n- **brainstorming**: Architecture design refinement.\n\n## Community and Contributions\n\nThese patterns reflect industry standards. Each paradigm skill includes:\n\n- Implementation patterns.\n- Case studies and examples.\n- Technology-specific guidance.\n- Risk mitigation strategies.\n- Evolution pathways.\n\n## License\n\nMIT License.\n",
        "plugins/conjure/README.md": "# Conjure\n\nDelegate tasks to external models from Claude Code. Delegate analysis, bulk work, and summarization to services like Gemini or Qwen.\n\nTrack quotas, log usage, and suggest delegation for large tasks.\n\n## Installation\n\n### As a Claude Code plugin\n\n```bash\n/plugin install athola@claude-night-market\n/status\n```\n\n### Development setup\n\n```bash\nuv sync             # install deps\nmake install-hooks  # pre-commit hooks\nmake test           # lint + type + security checks\n```\n\nRequirements: Python 3.10+, [uv](https://docs.astral.sh/uv/).\n\n### Optional Dependencies\n\n| Package | Purpose | Fallback |\n|---------|---------|----------|\n| tiktoken | Accurate token estimation | Heuristic (~4 chars/token) |\n| leyline | Quota tracking | Stub tracker (disabled) |\n\nFor accurate token counts, install tiktoken:\n```bash\npip install tiktoken\n```\n\n## Usage\n\n### Quick Start\n\n```bash\n# Check delegation readiness\nmake delegate-verify\n\n# Select best service for a task\nmake delegate-auto PROMPT=\"Summarize src\" FILES=\"src/\"\n\n# Monitor limits and usage\nmake quota-status\nmake usage-report\n```\n\n### Delegation Executor\n\n```bash\n# List services\nuv run python tools/delegation_executor.py --list-services\n\n# Verify a service\nuv run python tools/delegation_executor.py --verify gemini\n\n# Auto-select based on requirements\nuv run python tools/delegation_executor.py auto \"Analyze this code\" \\\n  --files src/ --requirement large_context\n\n# Force a specific service\nuv run python tools/delegation_executor.py gemini \"Summarize\" \\\n  --files docs/*.md --model gemini-2.5-pro-exp\n```\n\n### Make Commands\n\n```bash\n# Development\nmake format          # ruff format + check --fix\nmake lint            # ruff check\nmake typecheck       # mypy + ty\nmake security-check  # bandit\nmake test            # lint + type + security bundle\nmake validate-all    # full validation including hooks\nmake clean           # remove caches/venv\n\n# Delegation lifecycle\nmake delegate-status\nmake delegate-verify\nmake delegate-usage\nmake delegate-test\nmake delegate-gemini PROMPT=\"Analyze\" FILES=\"src/main.py\"\nmake delegate-qwen   PROMPT=\"Extract\" FILES=\"src/**/*.py\"\nmake delegate-auto   PROMPT=\"Best service\" FILES=\"src/\"\n\n# Quota & usage\nmake quota-status\nmake usage-report\n```\n\n### Quota & Usage Tools\n\n```bash\n# Quota tracker (Gemini)\nuv run python tools/quota_tracker.py --status\nuv run python tools/quota_tracker.py --estimate src/ docs/\nuv run python tools/quota_tracker.py --validate-config\n\n# Usage logger (Gemini)\nuv run python tools/usage_logger.py --report\nuv run python tools/usage_logger.py --validate\nuv run python tools/usage_logger.py --status\n```\n\n### In Claude Code\n\nUse skills directly in chat:\n\n```\nSkill(conjure:delegation-core)\nSkill(conjure:gemini-delegation)\nSkill(conjure:qwen-delegation)\n```\n\nHooks surface delegation suggestions for large tasks.\n\n## Commands\n\n### `delegate-auto`\n\nSelect the best external service based on requirements.\n\n### `delegate-gemini` / `delegate-qwen`\n\nForce a specific service with optional file globs and model hints.\n\n### `quota-status`\n\nDisplay current Gemini quota usage.\n\n### `usage-report`\n\nSummarize recent requests, token counts, and success rate.\n\n### `validate-delegation`\n\nCheck configuration integrity.\n\n## Architecture\n\nConjure is built around a Core Plugin that registers skills, commands, and hooks within Claude Code. Specialized Skills manage execution paths, while a Delegation Executor provides a unified interface for task processing and token estimation. Resource Management is handled by a quota tracker and usage logger that monitor limits and record outcomes, with a Makefile coordinating lifecycle automation and development tasks.\n\n## Workflow\n\nTask delegation begins with an **Assessment** by `delegation-core` to determine if delegation is appropriate, followed by **Selection** where `delegate-auto` identifies the best external service. **Execution** is then handled by the `delegation_executor`, with **Monitoring** provided by quota tracking and logging. Finally, **Integration** returns the results to the active Claude session.\n\n## Configuration & Paths\n\n- Delegation config: `~/.claude/hooks/delegation/config.json`\n- Quota data: `~/.claude/hooks/gemini/usage.json`\n- Usage logs: `~/.claude/hooks/gemini/logs/usage.jsonl`\n\n## Development\n\n```bash\nuv sync\nmake lint typecheck security-check\nmake test\n```\n\nSee `CHANGELOG.md` for release notes and `LICENSE` (MIT).\n\n## License\n\nMIT\n",
        "plugins/conserve/README.md": "# Conservation\n\nResource optimization and performance monitoring for Claude Code.\n\n## Quick Start\n\n```bash\n# Scan for code bloat\n/bloat-scan --level 2\n\n# Remediate identified bloat (with approval)\n/unbloat --from-scan report\n\n# Check for AI-generated code issues\n/ai-hygiene-audit\n\n# Invoke context optimization skill\nSkill(conserve:clear-context)\n```\n\n## Overview\n\nConservation manages token usage and session efficiency through resource monitoring and optimization. The plugin follows the Maximum Effective Context Window (MECW) principle, which maintains context pressure below 50% to preserve response quality. It identifies technical debt, eliminates response bloat, and provides strategies for codebase discovery to reduce the total token footprint.\n\n## Workflow Optimization\n\nMCP patterns process data at the source to avoid transmitting large datasets into the context window. Progressive loading fetches modules only when needed to keep the session footprint small. When context pressure exceeds 80%, the `clear-context` skill saves the session state and transitions to a fresh context window via subagent delegation.\n\n## Commands\n\n### `/bloat-scan`\n\nIdentifies dead code, duplication, and documentation bloat. Targeted analysis (level 2) can focus on specific areas, while detailed audits (level 3) generate a full report. It targets large files, code older than 6 months, unused dependencies, and duplicates.\n\n### `/unbloat`\n\nExecutes remediation by deleting, refactoring, or consolidating code with user approval. It includes a dry-run mode for previewing changes and can use existing scan reports for execution.\n\n### Safeguards\n\n`/unbloat` creates backup branches and requires interactive approval for all modifications. It runs verification tests after changes and rolls back if failures occur. File operations use `git rm` and `git mv` to maintain project history.\n\n### `/ai-hygiene-audit`\n\nDetects AI-specific code quality issues such as tab-completion bloat (repeated similar blocks), \"vibe coding\" patterns (massive single commits), and happy-path-only tests. It identifies problematic live code that traditional bloat detection might miss.\n\n## Agents\n\n| Agent | Purpose | Tools | Model |\n|-------|---------|-------|-------|\n| `bloat-auditor` | Orchestrates bloat detection scans. | Bash, Grep, Glob, Read, Write | Sonnet |\n| `unbloat-remediator` | Executes bloat remediation workflows. | Bash, Grep, Glob, Read, Write, Edit | Sonnet/Opus |\n| `ai-hygiene-auditor` | Detects AI-generated code quality issues. | Bash, Grep, Glob, Read | Sonnet |\n| `context-optimizer` | Assesses and optimizes MECW. | Read, Grep | Sonnet |\n| `continuation-agent` | Continues work from session state checkpoints. | Read, Write, Edit, Bash, Glob, Grep | default |\n\n## Skills\n\nThe `bloat-detector` skill uses three tiers of analysis, from heuristic-based checks to deep audits with full tooling. `clear-context` persists session state across context windows. `response-compression` eliminates filler words, hedging language, and hype words, saving between 150 and 350 tokens per response. `decisive-action` uses a reversibility/ambiguity matrix to determine when to proceed autonomously versus asking for clarification.\n\n## Token-Conscious Workflows\n\n### Discovery Strategy\n\nUse a three-tier approach for efficient discovery. First, use the Language Server Protocol (LSP) for semantic queries to get symbol-aware results in approximately 50ms. If LSP is unavailable, use targeted file reads to maintain a focused context window. As a secondary strategy, use `ripgrep` via the `Grep` tool for text-based searches. This approach reduces token usage by approximately 90% compared to broad exploratory reading.\n\n### STDOUT Verbosity Control\n\nVerbose command output consumes context. Use quiet or silent flags for package managers (npm, pip) and test runners (pytest). Limit git logs and diffs using `--oneline` or `--stat`. For file listings and search results, use `head` to truncate output. If a command fails three times, stop to verify assumptions or consider a simpler approach instead of retrying further.\n\n### Documentation Format\n\nAgents read Markdown directly; they do not read HTML. Markdown has lower syntax overhead and is version-control friendly. HTML should only be generated for external documentation sites or web-based viewing.\n\n## Hooks\n\n### Setup Hook (Claude Code 2.1.10+)\n\nInit tasks validate dependencies, create the `.claude/` session state directory, and persist the session state path. Maintenance tasks clean backups older than 7 days and rotate continuation audit logs. Run `--init` after cloning and `--maintenance` periodically.\n\n### PermissionRequest Hook\n\nAuto-approves safe patterns like read-only operations, search, and git status. Auto-denies dangerous patterns such as recursive deletes on home/root, privilege escalation (sudo), or pipe-to-shell commands.\n\n## Thresholds\n\n### Context Usage\n\nMonitoring levels trigger actions based on context pressure: LOW (<40%), WARNING (40-50%), CRITICAL (50-80%), and EMERGENCY (80%+). At the EMERGENCY level, the `clear-context` skill saves state to `.claude/session-state.md` and either spawns a continuation agent via Task tool or guides graceful wrap-up if Task tool is unavailable.\n\n### Context Measurement\n\nTwo methods are available depending on the use case:\n\n| Method | Use Case | Accuracy | Speed |\n|--------|----------|----------|-------|\n| File size heuristic | Real-time hooks | Approximate (~800KB ≈ 100%) | Fast |\n| CLI `/context` command | Headless/batch automation | Precise token breakdown | Slower |\n\nFor headless sessions, use `claude -p \"/context\" --verbose --output-format json` to get precise token breakdowns. See `/conserve:optimize-context` for full documentation.\n\n## Requirements\n\nPython 3.10+ and Claude Code.\n",
        "plugins/hookify/README.md": "# Hookify\n\nBehavioral rules and safety hooks for Claude Code.\n\n## Overview\n\nHookify provides a suite of pre-configured rules that are active immediately upon installation. These rules protect critical git branches, prevent destructive operations, and enforce security and workflow standards without requiring manual configuration.\n\n### Active Rules\n\nThe following rules are enabled by default:\n- **Git Safety**: Blocks force pushes to `main`/`master` and destructive operations like `reset --hard` or `clean -fd`. Warnings are issued for risky actions such as interactive rebases or soft resets.\n- **File Management**: Monitors for large binary files or large file operations that could bloat the repository or context.\n- **Code Standards**: Blocks dangerous dynamic code execution and warns about print statements in Python. Authentication changes require a security review, and new features must comply with `scope-guard` policies.\n\n## Architecture\n\nHookify uses a `ConfigLoader` to manage behavioral rules. It automatically searches for user-defined rules in the `.claude/` directory, which can override any of the default bundled rules. These configurations are processed by the `RuleEngine` to evaluate tool usage against the active rule set during execution. Bundled rules resolve their locations relative to the plugin's installation path to ensure portability across different environments.\n\n## Installation\n\n```bash\nclaude install hookify@claude-night-market\n```\n\nOr from source:\n\n```bash\ngit clone https://github.com/athola/claude-night-market\ncd claude-night-market\nclaude install ./plugins/hookify\n```\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/hookify:from-hook` | Convert Python SDK hooks to declarative hookify rules |\n| `/hookify:install` | Install a rule from the catalog or a custom file |\n| `/hookify:list` | List installed and available rules |\n| `/hookify:configure` | Configure rule settings |\n\n## Scripts\n\n### Rule Suggester\n\nAnalyze project context and suggest relevant rules:\n\n```bash\npython plugins/hookify/scripts/rule_suggester.py --project-dir .\n```\n\nDetects languages, frameworks, and tooling to recommend appropriate rules.\n\n## Documentation\n\n- **Rule Catalog**: `Skill(hookify:rule-catalog)`\n- **Rule Writing**: `Skill(hookify:writing-rules)`\n- **Hook Scope**: `Skill(abstract:hook-scope-guide)` (requires abstract plugin)\n\n## Optional Dependencies\n\n| Dependency | Purpose | Fallback |\n|------------|---------|----------|\n| abstract plugin | `hook-scope-guide` skill for advanced hook patterns | Hookify works fully without it; skill unavailable |\n\nHookify is fully functional without optional dependencies. The abstract plugin provides additional guidance for advanced hook development patterns.\n\n## Credits\n\nInspired by the original [hookify plugin](https://github.com/anthropics/claude-code/tree/main/plugins/hookify) by Daisy Hollman at Anthropic.\n\nEnhanced for claude-night-market with:\n- Zero-config bundled rules\n- Portable path resolution via `__file__`\n- User override support\n- Night-market plugin integration\n",
        "plugins/imbue/README.md": "# Imbue\n\nAnalysis methodologies and workflow patterns for evidence gathering and structured reporting.\n\n## Overview\n\nImbue provides technical evidence capture for reproducible analysis across git diffs, specifications, and logs. It focuses on audit trails and empirical verification rather than theoretical assessments. These methodologies back recommendations with specific data points and command outputs.\n\n## Analysis and Review Patterns\n\n### Review Methodology\nThe `review-core` skill establishes scope and baselines for architecture, security, or code quality audits. It requires validating assumptions and documenting artifacts before starting the analysis. Findings are logged with direct command evidence to support final deliverables.\n\n### Change Analysis\n`diff-analysis` categorizes changes and evaluates risks in code reviews or release notes. This involves establishing a clear baseline between \"before\" and \"after\" states to understand functional impact. For project activity summaries, `catchup` gathers raw change information to extract specific insights and action items.\n\n## Workflow Guards and Enforcement\n\n### Scope and Reasoning\n`scope-guard` helps prevent overengineering by using a decision framework to score feature worthiness against opportunity costs. This includes threshold monitoring and baseline scenarios to keep development focused on essential work.\n\nTo counter sycophantic reasoning, `rigorous-reasoning` uses checklist-based analysis that prioritizes truth-seeking over social comfort. It requires committing to conclusions without hedging and following an incremental reasoning protocol for complex problem-solving.\n\n### Proof of Work\nThe `proof-of-work` skill requires functional verification before a claim of completion is accepted. This is enforced by the `tdd_bdd_gate.py` PreToolUse hook, which checks for corresponding test files during write operations to implementation files. Completion claims must be backed by evidence of problem reproduction and verified fixes with actual test runs.\n\n## Feature Planning and Monitoring\n\n### Feature Review\n`feature-review` uses a hybrid RICE+WSJF scoring framework to prioritize features based on quality dimensions and tradeoffs. This process involves cataloging features and identifying improvement gaps to guide development decisions.\n\n### Monitoring\n`workflow-monitor` tracks execution for inefficiencies or errors. When a failure or timeout occurs, it automatically captures relevant logs and context to create GitHub issues for remediation.\n\n## Output and Documentation\n\nAnalysis results are structured through `evidence-logging` and `structured-output`. We record all commands, citations, and artifacts to provide a traceable record of the work. Final reports use established templates to define findings and action items.\n\n## Plugin Structure\n\n```\nimbue/\n├── plugin.json              # Plugin configuration\n├── README.md               # This file\n├── hooks/\n│   ├── hooks.json           # Hook configuration\n│   ├── session-start.sh     # Session initialization\n│   ├── user-prompt-submit.sh # Per-prompt threshold checks\n│   ├── pre_pr_scope_check.sh # Branch threshold monitoring\n│   └── tdd_bdd_gate.py      # PreToolUse: Iron Law enforcement\n├── commands/\n│   ├── full-review.md       # Structured review command\n│   ├── catchup.md           # Quick catchup command\n│   └── feature-review.md    # Feature prioritization command\n└── skills/\n    ├── review-core/        # Review workflow scaffolding\n    ├── evidence-logging/   # Evidence capture methodology\n    ├── structured-output/  # Output formatting patterns\n    ├── diff-analysis/      # Change analysis methodology\n    ├── catchup/            # Summarization methodology\n    ├── scope-guard/        # Anti-overengineering guardrails\n    ├── rigorous-reasoning/ # Anti-sycophancy guardrails\n    ├── feature-review/     # Feature prioritization framework\n    ├── proof-of-work/      # Verification enforcement\n    └── workflow-monitor/   # Execution monitoring and issue creation\n```\n\n## Usage\n\nUse `Skill(imbue:review-core)` for review scaffolding and `Skill(imbue:diff-analysis)` or `Skill(imbue:catchup)` for analysis methodologies. `Skill(imbue:scope-guard)` and `Skill(imbue:rigorous-reasoning)` provide workflow guardrails. Feature planning uses `Skill(imbue:feature-review)`, while `Skill(imbue:proof-of-work)` handles verification. `Skill(imbue:workflow-monitor)` tracks execution, and output patterns are managed via `Skill(imbue:evidence-logging)` and `Skill(imbue:structured-output)`.\n\nCommands include `/feature-review` for full inventory, scoring, and suggestions. Append `--inventory` to only discover features, or `--suggest` to include new feature suggestions. Use `--create-issues` to automate GitHub issue creation for suggestions.\n\n## Session Forking (Claude Code 2.0.73+)\n\nSession forking allows parallel evidence analysis from multiple perspectives without context overlap.\n\n### Use Cases\n\nFor **Multi-Perspective Code Analysis**, fork sessions to isolate security, performance, or maintainability audits. This allows for focused analysis before consolidating findings. **Parallel Feature Evaluation** uses separate forks for RICE and WSJF scoring to inform prioritization decisions. **Alternative Evidence Collection** strategies can compare bottom-up and top-down review approaches in parallel.\n\n### Standards\n\nEach fork must maintain a clear analytical scope. Save evidence logs to files before closing a fork. Synthesize findings from all forks into a final summary. Use perspective-based names for session IDs, such as `security-audit-pr-42`.\n",
        "plugins/leyline/README.md": "# Leyline\n\nInfrastructure and pipeline building blocks for Claude Code plugins.\n\n## Quick Start\n\n```bash\n# Use quota management for rate-limited services\nSkill(leyline:quota-management)\n\n# Implement standardized error handling\nSkill(leyline:error-patterns)\n\n# Set up authentication flows\nSkill(leyline:authentication-patterns)\n```\n\n## Overview\n\nLeyline provides shared utilities and services to maintain consistent plugin functionality. It handles resource tracking, service integration, and pipeline patterns such as error handling and circuit breakers. While Abstract manages evaluation and design, Leyline delivers the technical components required for cross-plugin communication and system stability.\n\n## Skills\n\n| Skill | Purpose | Use When |\n|-------|---------|----------|\n| `quota-management` | Track and enforce resource limits. | Implementing services with rate limits. |\n| `usage-logging` | Session-aware usage tracking. | Capturing audit trails or cost metrics. |\n| `service-registry` | Manage external service connections. | Coordinating multiple external services. |\n| `error-patterns` | Standardized error handling. | Implementing error recovery logic. |\n| `authentication-patterns` | Common auth flows. | Connecting to external APIs. |\n\n## Workflow and Integration\n\nOther plugins call Leyline for quota enforcement and standardized error recovery. The `quota_tracker` and `service_registry` utilities provide real-time monitoring of service health and rate limit compliance. These patterns use loose coupling to allow for progressive adoption throughout the codebase.\n\n## Optional Dependencies\n\n| Package | Purpose | Fallback |\n|---------|---------|----------|\n| tiktoken | Accurate token estimation | Heuristic (~4 chars/token) |\n\nFor accurate token counts, install tiktoken:\n```bash\npip install tiktoken\n```\n\n## Plugin Metadata Standards (Claude Code 2.0.73+)\n\nClaude Code 2.0.73+ supports search filtering in the plugin discovery screen. Descriptions should start with a direct statement of functionality, such as \"Infrastructure and pipeline building blocks for shared utilities.\" Include searchable keywords like \"quota management\" or \"error handling\" and mention specific capabilities like \"circuit breakers\" or \"auth flows.\" Descriptions should remain between 50 and 150 characters to ensure clarity in search results.\n",
        "plugins/memory-palace/README.md": "# Memory Palace Plugin\n\nSpatial knowledge organization using memory palace techniques for Claude Code.\n\n## Overview\n\nMemory Palace organizes complex information using spatial memory techniques for easier retrieval.\n\n## How This Differs from Native Claude Memory (2.1.32+)\n\nClaude Code now provides three layers of memory, each serving a different purpose:\n\n| Layer | Feature | Scope | Control |\n|-------|---------|-------|---------|\n| **Native Memory** (2.1.32+) | Automatic session summaries | Session continuity — \"what did I work on?\" | Implicit, automatic |\n| **Agent `memory` Frontmatter** (2.1.33+) | Per-agent persistent memory | Agent-scoped — `user`, `project`, or `local` | Opt-in per agent via frontmatter |\n| **Memory Palace** | Structured knowledge management | Domain knowledge — \"how does X relate to Y?\" | Explicit, user-designed architecture |\n\n**Native memory** handles session continuity and resumption. **Agent memory frontmatter** gives individual agents persistent recall across sessions (Memory Palace agents use `memory: project`). **Memory Palace** provides structured, navigable knowledge architectures with spatial hierarchies, bidirectional links, and multi-modal search that persist as a permanent knowledge corpus.\n\n## Features\n\nThe Memory Palace Architect allows users to design spatial knowledge structures using mnemonic techniques, while the Knowledge Locator facilitates multi-modal search across these palaces. Temporary structures for extended conversations are handled by the Session Palace Builder, and the Digital Garden Cultivator manages evolving knowledge bases with bidirectional linking. Additionally, a dedicated PR Review Chamber captures knowledge from PR reviews, and Skill Execution Memory automatically logs skill invocation history to support continual learning.\n\n## PR Review Room\n\nProjects function as palaces with a dedicated chamber for capturing knowledge from PR reviews.\n\n### Project Palace Structure\n\n```\nproject-palace/\n├── entrance/           # README, getting started\n├── library/            # Documentation, ADRs\n├── workshop/           # Development patterns, tooling\n├── review-chamber/     # PR Reviews\n│   ├── decisions/      # Architectural choices\n│   ├── patterns/       # Recurring issues/solutions\n│   ├── standards/      # Quality bar examples\n│   └── lessons/        # Post-mortems, learnings\n└── garden/             # Evolving knowledge\n```\n\n### Quick Start\n\n```bash\n# Capture knowledge from a PR review\n/review-room capture 42\n\n# Search past decisions\n/review-room search \"authentication\" --room decisions\n\n# List recent patterns\n/review-room list --room patterns --limit 5\n```\n\n### Integration with sanctum:pr-review\n\nKnowledge capture triggers after PR reviews:\n\n1. Review posted to GitHub.\n2. Findings captured to review-chamber.\n\nSee `skills/review-chamber/SKILL.md` for details.\n\n## Optional Dependencies\n\n| Package | Purpose | Fallback |\n|---------|---------|----------|\n| tiktoken | Accurate token estimation | Heuristic (~4 chars/token) |\n\nFor accurate token counts, install tiktoken:\n```bash\npip install tiktoken\n```\n\n## Skill Execution Memory\n\nMemory-palace automatically stores skill execution history via hooks, enabling continual learning and performance analysis.\n\n### Automatic Storage\n\nEvery skill invocation is automatically stored with:\n- **Timestamp**: When the skill was invoked\n- **Duration**: Execution time\n- **Outcome**: Success, failure, or partial\n- **Continual metrics**: Stability gap, accuracy trends\n\n### Storage Structure\n\n```\n~/.claude/skills/logs/\n├── .history.json              # Aggregated continual metrics\n├── abstract/\n│   ├── skill-auditor/\n│   │   └── 2025-01-08.jsonl   # Daily JSONL files\n│   └── plugin-validator/\n├── sanctum/\n│   └── pr-review/\n└── <your-plugin>/\n    └── <your-skill>/\n```\n\n### Quick Start\n\n```bash\n# View recent skill executions\n/skill-logs --last 1h\n\n# View failures only\n/skill-logs --failures-only\n\n# Filter by plugin\n/skill-logs --plugin abstract\n\n# Cleanup old logs\n/skill-logs cleanup --older-than 90d\n```\n\n### Integration with pensive\n\nUse `/pensive:skill-review` to analyze metrics and identify unstable skills:\n\n```bash\n# Check skill health\n/pensive:skill-review --unstable-only\n\n# Deep-dive specific skill\n/pensive:skill-review --skill abstract:skill-auditor\n```\n\n## Installation\n\n```bash\n# Clone the repository\ngit clone https://github.com/superpowers-marketplace/memory-palace.git\n\n# Install as Claude Code plugin\nclaude-code plugins add ./memory-palace\n```\n\n## Quick Start\n\n### Create a Palace\n```bash\npython scripts/palace_manager.py create \"K8s Concepts\" \"kubernetes\" --metaphor workshop\n```\n\n### List Palaces\n```bash\npython scripts/palace_manager.py list\n```\n\n### Search\n```bash\npython scripts/palace_manager.py search \"authentication\" --type semantic\n```\n\n### Garden Metrics\n```bash\npython scripts/garden_metrics.py path/to/garden.json --format brief\n```\n\n## Skills\n\n| Skill | Description |\n|-------|-------------|\n| `memory-palace-architect` | Design and construct virtual memory palaces. |\n| `knowledge-locator` | Find information using multi-modal search. |\n| `session-palace-builder` | Create temporary session-specific palaces. |\n| `digital-garden-cultivator` | Manage evolving knowledge bases. |\n| `knowledge-intake` | Process and evaluate external knowledge. |\n| `review-chamber` | Capture PR review knowledge in project palaces. |\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/palace` | Create and manage memory palaces. |\n| `/garden` | Manage digital gardens and metrics. |\n| `/navigate` | Search and navigate across palaces. |\n| `/review-room` | Manage PR review knowledge in project palaces. |\n| `/skill-logs` | View and manage skill execution memories. |\n\n## Agents\n\n| Agent | Description |\n|-------|-------------|\n| `palace-architect` | Design palace architectures. |\n| `knowledge-navigator` | Search and retrieve information. |\n| `garden-curator` | Maintain digital gardens. |\n\n## Hooks\n\n### Setup Hook (Claude Code 2.1.10+)\n\nOne-time initialization and periodic maintenance for knowledge gardens. Triggered via CLI flags:\n\n```bash\n# Initialize memory palace (creates garden structure, indexes)\nclaude --init\n\n# Run maintenance (cleans stale captures, rotates logs, rebuilds indexes)\nclaude --maintenance\n```\n\n**Init tasks:**\n- Creates knowledge garden structure (`~/.claude/knowledge-garden/`)\n- Creates project palace structure (if in a git repo)\n- Initializes skill logs directory\n- Creates web captures directory\n- Generates garden index file\n\n**Maintenance tasks:**\n- Composts stale web captures (>30 days to `compost/`)\n- Rotates skill logs (deletes >90 days)\n- Rebuilds garden index with current counts\n- Detects potential duplicate captures\n\n**Why use Setup vs SessionStart?** Garden maintenance and index rebuilding are expensive operations that shouldn't run on every session. Use `--init` when setting up a new project, and `--maintenance` weekly or monthly.\n\n### Runtime Hooks\n\nHooks integrate Memory Palace with Claude Code events:\n\n| Hook | Event | Description |\n|------|-------|-------------|\n| `research_interceptor.py` | PreToolUse | Checks local knowledge cache before web requests. |\n| `local_doc_processor.py` | PostToolUse | Monitors Read operations for indexing suggestions. |\n| `url_detector.py` | UserPromptSubmit | Detects URLs for potential knowledge intake. |\n| `web_content_processor.py` | PostToolUse | Processes web content for knowledge extraction. |\n| `skill_tracker_pre.py` | PreToolUse | Records start time when Skill tool is invoked. |\n| `skill_tracker_post.py` | PostToolUse | Logs completion, calculates metrics, stores memory. |\n\nHooks are configured via `hooks/hooks.json` and `hooks/memory-palace-config.yaml`.\n\n## Architecture\n\n```\nmemory-palace/\n├── .claude-plugin/\n│   ├── plugin.json      # Plugin manifest\n│   └── metadata.json    # Extended metadata\n├── skills/\n│   ├── memory-palace-architect/\n│   │   ├── SKILL.md\n│   │   └── modules/\n│   ├── knowledge-locator/\n│   ├── session-palace-builder/\n│   └── digital-garden-cultivator/\n├── commands/\n│   ├── palace.md\n│   ├── garden.md\n│   └── navigate.md\n├── agents/\n│   ├── palace-architect.md\n│   ├── knowledge-navigator.md\n│   └── garden-curator.md\n├── src/memory_palace/\n│   ├── palace_manager.py\n│   ├── project_palace.py    # NEW: Project palace with review chamber\n│   └── garden_metrics.py\n└── scripts/\n    └── memory_palace_cli.py\n```\n\n## Requirements\n\n- Python 3.12+\n- Claude Code\n\n## Session Forking Workflows (Claude Code 2.0.73+)\n\nSession forking allows testing knowledge organization strategies without committing to a single structure:\n\n```bash\n# Fork for hierarchical organization\nclaude --fork-session --session-id \"hierarchical-tags\" --resume\n> \"Organize using hierarchical tags\"\n\n# Fork for concept-map approach\nclaude --fork-session --session-id \"concept-map\" --resume\n> \"Organize using semantic relationships\"\n```\n\n**Best Practices**: Test with representative content, extract successful designs as templates.\n\nSee `plugins/abstract/docs/claude-code-compatibility.md` for detailed patterns.\n\n## License\n\nMIT\n",
        "plugins/minister/README.md": "# Minister\n\nProject management and initiative alignment using GitHub repository data.\n\n## Quick Start\n\n```bash\n# Create a GitHub issue\n/create-issue\n\n# Close an issue after verifying completion\n/close-issue --issue 123\n\n# Generate initiative status report\npython plugins/minister/scripts/tracker.py status --github-comment\n\n# Update repository labels\n/update-labels\n```\n\n## Overview\n\nMinister synchronizes GitHub Projects, issues, and status checks for roadmap tracking. It generates snapshots of initiative status from live GitHub data and executes release governance through automated checks on CI status and documentation completeness.\n\n## Capabilities\n\n| Area | Description | Assets |\n|------|-------------|--------|\n| Issue Lifecycle | Manage GitHub issues with analysis and automated triage. | `commands/create-issue.md`, `commands/close-issue.md`, `commands/update-labels.md` |\n| Initiative Tracking | Data model and CLI for tracking initiative metrics. | `scripts/tracker.py`, `src/minister/project_tracker.py` |\n| GitHub Integration | Generate markdown comments for issues and pull requests. | `scripts/tracker.py`, `.github/workflows/minister-comment.yml` |\n| Release Governance | Quality gates for CI status and documentation. | `skills/release-health-gates` |\n| Reporting | Status report templates and project playbooks. | `docs/templates/status-report-template.md`, `docs/playbooks/*` |\n| Data Store | JSON storage for synchronized GitHub Projects data. | `data/project-data.json` |\n\n## Workflow Integration\n\nThe `ProjectTracker` links tasks to GitHub issues or PRs. Execute `tracker.py status --github-comment` to generate markdown reports for the `gh` CLI. This allows for linking status updates back to Projects v2 view notes.\n\nReference Minister's skills in other plugins or automate data ingestion through cron jobs. Artifacts are stored in `.claude/minister/` to maintain organization. Leyline manages GitHub API calls to stay within quota limits.\n\n## Commands\n\n- **/create-issue**: Create GitHub issues with specific formatting and references.\n- **/close-issue**: Analyze commits and code to determine if an issue can be closed.\n- **/update-labels**: Reorganize repository labels into a standardized taxonomy.\n\n## Skills\n\n- **github-initiative-pulse**: Generate snapshots of initiative progress for status updates.\n- **release-health-gates**: Define and execute quality gates for release candidate approvals.\n\nEach skill includes a `SKILL.md` file with scenario modules and references to the underlying Python scripts.\n\n## Scripts\n\n`tracker.py` provides the CLI for initiative management. Use `add` to link tasks to GitHub entities and `update` to refresh their progress. The `status --github-comment` command produces markdown for GitHub, while `export` creates CSV files for external analysis.\n\n## Integration Patterns\n\nIntegrate Minister by calling its skills from other plugins. Use the `ProjectTracker` class for automated data ingestion via cron jobs. Manage GitHub API interactions through Leyline to respect rate limits and quotas.\n",
        "plugins/parseltongue/README.md": "# Parseltongue\n\nPython development skills for Claude Code, focusing on testing, performance profiling, async patterns, and packaging.\n\n## Overview\n\nParseltongue implements specialized patterns for Python development. It includes structured guides for `pytest` and TDD workflows, profiling methods for identifying CPU and memory hotspots, and `asyncio` patterns for concurrent I/O. The plugin also provides templates for `pyproject.toml` configuration and `uv` dependency management.\n\n## Features\n\n### Skills\n\n| Skill | Description |\n|-------|-------------|\n| **python-testing** | Pytest patterns, fixtures, mocking, and TDD cycles. |\n| **python-performance** | CPU/memory profiling and local benchmarking. |\n| **python-async** | asyncio concurrency and async/await patterns. |\n| **python-packaging** | pyproject.toml standards and uv integration. |\n\n### Commands\n\n| Command | Description |\n|---------|-------------|\n| `/analyze-tests` | Reports on test suite coverage and fixture usage. |\n| `/run-profiler` | Runs cProfile/memory_profiler on target scripts. |\n| `/check-async` | Scans for blocking calls in async functions. |\n\n## Integration\n\nParseltongue works with standard Python tools:\n- **Package Managers**: Native support for `uv`, `pip`, and `poetry`.\n- **Quality Tools**: Integration with `ruff` for linting and `mypy` for type checking.\n- **Frameworks**: Patterns for FastAPI, Django, and SQLAlchemy applications.\n\nTesting follows a Red-Green-Refactor cycle using `pytest` fixtures. Performance optimization focuses on identifying bottlenecks via line-profiling before applying caches or algorithmic improvements. Async patterns prioritize non-blocking I/O to manage high-concurrency workloads without thread overhead.\n\n## Structure\n\n```\nparseltongue/\n├── .claude-plugin/\n│   └── plugin.json          # Plugin manifest\n├── agents/\n│   ├── python-pro.md        # Python 3.12+ specialist\n│   ├── python-tester.md     # Pytest and TDD specialist\n│   ├── python-optimizer.md  # Performance tuning\n│   └── python-linter.md     # Linting enforcement\n├── commands/\n│   ├── analyze-tests.md\n│   ├── run-profiler.md\n│   └── check-async.md\n├── skills/\n│   ├── python-testing/\n│   ├── python-performance/\n│   ├── python-async/\n│   └── python-packaging/\n└── README.md\n```\n\n## Requirements\n\n- Python 3.12 or later (supported back to 3.9).\n- `uv` recommended for dependency isolation.\n\n## License\n\nMIT\n",
        "plugins/pensive/README.md": "# Pensive\n\nCode review skills for Claude Code. Specialized reviewers cover Rust, APIs, tests, and architecture.\n\n## Installation\n\nInstall via the Claude Code plugin manager:\n```bash\nclaude plugins install pensive\n```\n\nOr reference from the marketplace:\n```json\n{\n  \"plugins\": [\"pensive@claude-night-market\"]\n}\n```\n\n## Features\n\n### Skills\n\n| Skill | Description |\n|-------|-------------|\n| **unified-review** | Orchestrates reviews and selects appropriate domain-specific skills. |\n| **api-review** | Evaluates public API surfaces and consistency. |\n| **architecture-review** | Assesses architectural design and ADR compliance. |\n| **bug-review** | Identifies logic errors and security vulnerabilities. |\n| **rust-review** | Audits Rust code for ownership, safety, and concurrency issues. |\n| **test-review** | Evaluates test suite coverage and quality. |\n| **math-review** | Reviews mathematical algorithms and numerical stability. |\n| **makefile-review** | Audits and optimizes build systems. |\n| **shell-review** | Checks shell scripts for correctness, portability, and safety. |\n| **fpf-review** | Functional/Practical/Foundation architecture review. |\n| **code-refinement** | Analyzes living code for duplication, algorithmic inefficiency, clean code violations, and architectural misfit. |\n| **safety-critical-patterns** | NASA Power of 10 rules adapted for robust, verifiable code with context-appropriate rigor. |\n\n### Commands\n\n| Command | Description |\n|---------|-------------|\n| `/full-review` | Executes a unified review with automated skill selection. |\n| `/api-review` | Audits API surface consistency. |\n| `/architecture-review` | Evaluates design patterns and ADR alignment. |\n| `/bug-review` | Scans for bugs and potential exploits. |\n| `/rust-review` | Performs a safety audit for Rust projects. |\n| `/test-review` | Analyzes test suite quality. |\n| `/math-review` | Verifies mathematical correctness. |\n| `/makefile-review` | Audits Makefiles against best practices. |\n| `/shell-review` | Checks shell script safety and portability. |\n| `/fpf-review` | Executes an FPF architecture review. |\n| `/refine-code` | Analyzes and improves living code quality across 6 dimensions. |\n| `/skill-review` | Analyzes skill performance and stability. |\n| `/skill-history` | Displays recent skill execution data with context. |\n\n### Agents\n\n| Agent | Description |\n|-------|-------------|\n| **code-reviewer** | General review agent with bug detection capabilities. |\n| **architecture-reviewer** | Agent specialized in architectural assessment. |\n| **rust-auditor** | Agent focused on Rust safety and security. |\n| **code-refiner** | Agent for code quality refinement and refactoring plan generation. |\n\n## Quick Start\n\n### Unified Review\n\nRun `/full-review` to automatically detect and execute relevant checks. Focus on specific areas by appending the domain, such as `/full-review api` or `/full-review bugs`. Use `/full-review all` to execute all applicable domain reviews.\n\n### Domain-Specific Reviews\n\nTrigger specialized reviews directly for focused audits: `/rust-review`, `/api-review`, `/test-review`, or `/fpf-review` for architectural analysis.\n\n### Skill Performance Review\n\nUse `/skill-review` to view health metrics across all skills. Append `--unstable-only` to identify skills with a stability gap greater than 0.3. Use `/skill-history` to view executions from the last hour or filter by failures using `--failures-only`.\n\n## Skill Selection Logic\n\nUnified reviews select skills based on codebase patterns. Rust files (`*.rs`, `Cargo.toml`) trigger `rust-review`, `bug-review`, and `api-review`. API definitions (`openapi.yaml`) trigger `api-review` and `architecture-review`. Test files trigger `test-review`, and build scripts trigger `makefile-review` or `shell-review`.\n\n## Output Standards\n\nReviews produce structured output including an overall assessment, high/medium/low severity findings with file and line references, actionable tasks with owners and dates, and a final recommendation to approve, block, or approve with actions.\n\n## Review Workflow\n\nReviews identify modified files and apply domain-specific checks. Findings are documented with precise location data, severity rankings, and specific remediation steps.\n\n## Progress Tracking\n\nSkills use `TodoWrite` for lifecycle tracking, moving from surface inventory and exemplar research to consistency audits and evidence logging.\n\n## Session Forking (Claude Code 2.0.73+)\n\nFork sessions for parallel specialized reviews. For example, use `claude --fork-session --session-id \"security-audit\"` to isolate a security audit while maintaining the main review context. Extract findings before closing the fork and synthesize them into the final report.\n\n## Skill Performance Monitoring\n\nPensive tracks skill execution to identify brittle tools by calculating the stability gap (the difference between average and worst-case accuracy). A gap below 0.2 indicates stable performance, while a gap above 0.3 requires investigation. Data is stored in `~/.claude/skills/logs/` in JSONL format, with history aggregated in `.history.json`.\n",
        "plugins/sanctum/README.md": "# Sanctum\n\nGit and workspace management for commits, pull requests, documentation, and versioning.\n\n## Overview\n\nSanctum manages repository state and development workflows. It provides preflight checks for staged changes, drafts conventional commit messages, and prepares pull requests with quality gate verification. It automates version management and merges ephemeral documentation into permanent files to maintain project history and guides.\n\n## Features\n\n### Skills\n\n| Skill | Description |\n|-------|-------------|\n| **git-workspace-review** | Preflight checklist for repo state, staged changes, and diffs. |\n| **file-analysis** | Codebase structure mapping and file pattern detection. |\n| **commit-messages** | Conventional commit generation from staged changes. |\n| **pr-prep** | PR preparation with quality gates and template completion. |\n| **doc-consolidation** | Merge ephemeral LLM-generated docs into permanent files. |\n| **doc-updates** | Documentation updates with ADR support. |\n| **test-updates** | Test generation and enhancement with TDD/BDD patterns. |\n| **update-readme** | Update README with current project status. |\n| **version-updates** | Version bumping across configs and changelogs. |\n| **workflow-improvement** | Improve skills, agents, commands, and hooks based on the most recent session. |\n| **pr-review** | Scope-focused PR review with knowledge capture integration. |\n| **do-issue** | Fix GitHub issues using parallel execution via sub-agents. |\n| **tutorial-updates** | Generate tutorials with GIF recordings. |\n| **session-management** | Manage named sessions with `/rename`, `/resume`, and checkpoints. |\n\n### Commands\n\n| Command | Description |\n|---------|-------------|\n| `/git-catchup` | Catch up on git repository changes using the imbue methodology. |\n| `/commit-msg` | Draft conventional commit message. |\n| `/do-issue` | Fix GitHub issues using parallel execution via sub-agents. |\n| `/fix-workflow` | Improve the most recent workflow slice through a retrospective. |\n| `/fix-pr` | Address PR review comments, implement fixes, and resolve threads. |\n| `/pr` | Prepare PR description with quality gates. |\n| `/update-docs` | Update project documentation. |\n| `/update-readme` | Update README with recent changes. |\n| `/update-tests` | Update and maintain tests with TDD/BDD principles. |\n| `/update-version` | Bump project versions. |\n| `/update-dependencies` | Scan and update dependencies across ecosystems. |\n| `/update-tutorial` | Generate or update tutorial documentation with recordings. |\n| `/pr-review` | Scope-focused PR review with mandatory code quality analysis and knowledge capture. |\n| `/resolve-threads` | Batch-resolve unresolved PR review threads via GitHub GraphQL. |\n| `/create-tag` | Create git tags from merged PRs or version arguments. |\n| `/merge-docs` | Consolidate ephemeral LLM-generated docs into permanent files. |\n| `/prepare-pr` | Complete PR preparation with updates and code review. |\n| `/update-plugins` | Audit and sync plugin.json with disk contents. |\n\n### Agents\n\n| Agent | Description |\n|-------|-------------|\n| **git-workspace-agent** | Repository state analysis and change tracking. |\n| **commit-agent** | Conventional commit message generation. |\n| **pr-agent** | Pull request preparation and documentation. |\n| **workflow-recreate-agent** | Recreates the most recent workflow and identifies inefficiencies. |\n| **workflow-improvement-analysis-agent** | Generates improvement approaches with trade-offs and metrics. |\n| **workflow-improvement-planner-agent** | Defines a bounded plan with acceptance criteria. |\n| **workflow-improvement-implementer-agent** | Implements the agreed workflow improvements. |\n| **workflow-improvement-validator-agent** | Validates improvements via tests and replay. |\n| **dependency-updater** | Dependency scanning and updates across ecosystems. |\n\n### Hooks\n\n| Hook | Event | Description |\n|------|-------|-------------|\n| **security_pattern_check.py** | PreToolUse (Write\\|Edit\\|MultiEdit) | Checks for security anti-patterns in code changes. |\n| **post_implementation_policy.py** | SessionStart | Injects governance protocol and proof-of-work reminders. |\n| **verify_workflow_complete.py** | Stop | Post-implementation checklist reminder. |\n| **session_complete_notify.py** | Stop | Cross-platform toast notification on command completion. |\n\n#### Stop Hooks\n\n**verify_workflow_complete.py** displays a checklist when a session ends. It reminds the developer to complete proof-of-work verification, lists documentation update commands, and displays a quality gate checklist.\n\n**session_complete_notify.py** provides a desktop toast notification when commands complete. It supports Linux (notify-send), macOS (osascript), Windows (PowerShell), and WSL. It displays terminal info such as Zellij session, tmux window, and project name. Execution takes approximately 95ms. Notifications can be disabled by setting `CLAUDE_NO_NOTIFICATIONS=1` or muted with `CLAUDE_NOTIFICATION_SOUND=0`.\n\n## Quick Start\n\n### Git Workspace Review\n```bash\n# Understand repository state before other operations\nSkill(sanctum:git-workspace-review)\n```\n\n### Commit Message Generation\n```bash\n# Generate conventional commit from staged changes\n/commit-msg\n```\n\n### PR Preparation\n```bash\n# Full PR prep with quality gates\n/pr\n```\n\n### Documentation Updates\n```bash\n# Update docs based on changes\n/update-docs\n\n# Modernize README\n/update-readme\n\n# Bump version numbers\n/update-version\n```\n\n## Skill Dependencies\n\nMost sanctum skills require `git-workspace-review` as a foundation. Skills like `commit-messages`, `pr-prep`, `doc-updates`, `update-readme`, and `version-updates` depend on its output. `file-analysis` operates independently.\n\n## Workflow Patterns\n\n**Pre-Commit**: Stage changes using `git add -p`, execute `git-workspace-review` for a preflight check, and run `commit-messages` to generate the message.\n\n**Pre-PR**: Execute a preflight check, run quality gates such as `make fmt && make lint && make test`, and use `pr-prep` to generate the description.\n\n**Post-Review**: Use `/fix-pr` to triage comments, implement fixes, and resolve threads.\n\n**Release**: Run a preflight check, bump the version with `version-updates`, update documentation with `doc-updates`, then commit and tag the release.\n\n## Session Forking (Claude Code 2.0.73+)\n\nSession forking allows for exploring alternative implementations or commit strategies without affecting the main session history.\n\n### Use Cases\n\nFor **Alternative Implementations**, fork a session to try different approaches, such as comparing an OAuth 2.0 implementation with a JWT-based one. For **Commit Strategies**, use forks to test atomic commits per file versus grouping by feature area. **PR Descriptions** can be forked to generate technical-focused versions and business-value versions, which can then be combined for the final draft. **Refactoring Explorations** allow for trying functional, OOP, or composition-based styles in parallel to evaluate trade-offs before implementation.\n\n### Standards\n\nUse descriptive session IDs like `pr-123-security-focused` instead of generic names. Keep each fork focused on a single approach. Extract insights to files before closing and document the reasoning for the final choice.\n",
        "plugins/scribe/README.md": "# Scribe\n\nDocumentation review, cleanup, and generation with AI slop detection.\n\n## Installation\n\n```bash\nclaude plugins install scribe\n```\n\nOr reference from the marketplace:\n```json\n{\n  \"plugins\": [\"scribe@claude-night-market\"]\n}\n```\n\n## Features\n\n### Skills\n\n| Skill | Description |\n|-------|-------------|\n| **slop-detector** | Detect AI-generated content markers |\n| **style-learner** | Extract writing style from exemplar text |\n| **doc-generator** | Generate/remediate documentation |\n\n### Commands\n\n| Command | Description |\n|---------|-------------|\n| `/slop-scan` | Scan files for AI slop markers |\n| `/style-learn` | Create style profile from examples |\n| `/doc-polish` | Clean up AI-generated content |\n| `/doc-generate` | Generate new documentation |\n| `/doc-verify` | Validate documentation claims with proof-of-work |\n\n### Agents\n\n| Agent | Description |\n|-------|-------------|\n| **doc-editor** | Interactive documentation editing. |\n| **slop-hunter** | Detection of AI-generated markers and tropes. |\n| **doc-verifier** | QA validation using proof-of-work methodology. |\n\n## Quick Start\n\n### Detect AI Slop\n\n```bash\n# Scan current directory\n/slop-scan\n\n# Scan specific file with fix suggestions\n/slop-scan README.md --fix\n```\n\n### Clean Up Content\n\n```bash\n# Interactive polish\n/doc-polish docs/guide.md\n\n# Polish all markdown files\n/doc-polish **/*.md\n```\n\n### Learn a Style\n\n```bash\n# Create style profile from examples\n/style-learn good-examples/*.md --name house-style\n\n# Generate with learned style\n/doc-generate readme --style house-style\n```\n\n### Verify Documentation\n\n```bash\n# Verify README claims and commands\n/doc-verify README.md\n\n# Verify with strict mode\n/doc-verify docs/ --strict --report qa-report.md\n```\n\n## AI Slop Detection\n\nScribe detects patterns that reveal AI-generated content.\n\n### Tier 1 Words (Highest Confidence)\n\nWords that appear dramatically more often in AI text: delve, tapestry, realm, embark, beacon, multifaceted, nuanced, pivotal, meticulous, showcasing, leveraging, streamline, comprehensive.\n\n### Phrase Patterns\n\nFormulaic constructions like \"In today's fast-paced world,\" \"cannot be overstated,\" \"navigate the complexities,\" and \"treasure trove of.\"\n\n### Structural Markers\n\nOveruse of em dashes, excessive bullet points, uniform sentence length, perfect grammar without contractions.\n\n### Fiction-Specific Tells\n\nPhysical cliches (\"breath he didn't know he was holding\"), emotion washing (\"relief washed over\"), vague depth markers (\"something in his eyes\").\n\n## Writing Principles\n\nScribe enforces a grounded writing style by requiring specific claims over adjectives and removing formulaic openers or closers. It emphasizes authorial perspective by including reasoning and trade-offs, varies sentence structure to avoid monotony, and prioritizes active voice for direct, clear communication.\n\n## Vocabulary Substitutions\n\n| Instead of | Use |\n|------------|-----|\n| leverage | use |\n| utilize | use |\n| comprehensive | thorough |\n| robust | solid |\n| facilitate | help |\n| optimize | improve |\n| delve | explore |\n| embark | start |\n\n## Plugin Structure\n\n```\nscribe/\n├── .claude-plugin/\n│   └── plugin.json\n├── agents/\n│   ├── doc-editor.md\n│   ├── slop-hunter.md\n│   └── doc-verifier.md\n├── commands/\n│   ├── slop-scan.md\n│   ├── style-learn.md\n│   ├── doc-polish.md\n│   ├── doc-generate.md\n│   └── doc-verify.md\n├── skills/\n│   ├── shared/\n│   ├── slop-detector/\n│   │   └── modules/\n│   ├── style-learner/\n│   │   └── modules/\n│   └── doc-generator/\n│       └── modules/\n└── README.md\n```\n\n## Integration\n\nScribe integrates with other claude-night-market plugins:\n\n### Sanctum Documentation Workflows\n\n| Sanctum Command | Scribe Integration |\n|-----------------|-------------------|\n| `/pr-review` | Runs `slop-detector` on changed `.md` files, uses `doc-generator` principles for PR descriptions |\n| `/update-docs` | Runs `slop-detector` on edited docs, uses `doc-editor` for remediation |\n| `/update-readme` | Runs `slop-detector` on README, applies `doc-generator` principles |\n| `/prepare-pr` (`/pr`) | Verifies PR descriptions with `slop-detector` principles |\n\n### Other Integrations\n\n- **imbue:proof-of-work**: Evidence-based verification methodology (used by `doc-verifier`)\n- **conserve:bloat-detector**: Token and content optimization\n- **pensive:review skills**: Code review integration\n\n## License\n\nMIT\n",
        "plugins/scry/README.md": "# Scry\n\nMedia generation for terminal recordings, browser automation, GIF processing, and tutorial composition.\n\n## Quick Start\n\n```bash\n# Record a terminal session\n/record-terminal --output demo.gif\n\n# Record a browser session\n/record-browser --url https://example.com\n\n# Use VHS tape scripts for terminal recordings\nSkill(scry:vhs-recording)\n\n# Combine media assets into tutorials\nSkill(scry:media-composition)\n```\n\n## Overview\n\nScry manages terminal and browser recordings to create technical demos and tutorials. It uses VHS (Charmbracelet) for terminal tape scripts and Playwright for browser automation, allowing for both interactive and programmatic recording workflows. The plugin also handles GIF optimization and media composition to combine disparate assets into cohesive documentation.\n\n## Features\n\n### Skills\n\n| Skill | Description |\n|-------|-------------|\n| **vhs-recording** | Terminal recordings using VHS (Charmbracelet) with tape scripts. |\n| **browser-recording** | Browser automation recordings using Playwright. |\n| **gif-generation** | GIF processing and optimization. |\n| **media-composition** | Combine media assets into tutorials and demos. |\n\n### Commands\n\n| Command | Description |\n|---------|-------------|\n| `/record-terminal` | Create terminal recordings with VHS tape scripts. |\n| `/record-browser` | Record browser sessions using Playwright. |\n\n## Quick Start and Workflow Patterns\n\nTo create a tutorial, use `vhs-recording` for terminal demonstrations and `browser-recording` for web interface walkthroughs. These assets can then be merged using the `media-composition` skill. For standalone demos, record terminal sessions directly with `/record-terminal` and optimize the final output through `gif-generation`.\n\nPlaywright is recommended for automated recording and CI/CD environments, while Claude Code's native Chrome integration is often better for interactive debugging. When generating media, Claude Code 2.0.73+ supports clickable image links that allow for immediate verification of recording quality within the default viewer.\n",
        "plugins/spec-kit/README.md": "# spec-kit\n\nSpecification-driven development toolkit for Claude Code.\n\n## Overview\n\nSpec-kit provides a specification-driven workflow: writing a specification, generating an implementation plan, breaking it into tasks, and executing them with tracking.\n\n## Installation\n\nThis plugin is part of the [claude-night-market](https://github.com/athola/claude-night-market) collection.\n\n```bash\n# Add to your Claude Code plugins\nclaude plugins add spec-kit\n```\n\n**Requires**: `abstract` plugin for infrastructure.\n\n## Workflow Commands\n\n### Core Commands\n\n| Command | Description |\n|---------|-------------|\n| `/speckit-startup` | Initialize the speckit workflow for the session |\n| `/speckit-specify` | Create feature specifications from natural language |\n| `/speckit-clarify` | Refine specifications with targeted questions |\n| `/speckit-plan` | Execute the implementation planning workflow |\n| `/speckit-tasks` | Generate dependency-ordered tasks |\n| `/speckit-implement` | Execute implementation tasks |\n| `/speckit-analyze` | Analyze consistency across artifacts |\n| `/speckit-checklist` | Generate quality checklists for requirements |\n| `/speckit-constitution` | Manage project principles |\n\n## Skills\n\n### speckit-orchestrator\n\nWorkflow coordinator that validates skill loading and maintains consistency throughout the command lifecycle.\n\n### spec-writing\n\nGuides the creation of testable specifications from natural language descriptions.\n\n### task-planning\n\nTransforms specifications and implementation plans into dependency-ordered tasks.\n\n## Agents\n\n### spec-analyzer\n\nAnalyzes artifacts for consistency, coverage, and quality.\n\n### task-generator\n\nGenerates dependency-ordered implementation tasks.\n\n### implementation-executor\n\nExecutes implementation tasks according to the task plan.\n\n## Workflow Example\n\n1. `/speckit-startup`: Initialize the session.\n2. `/speckit-specify <feature>`: Create a specification.\n3. `/speckit-clarify`: Refine requirements.\n4. `/speckit-plan`: Generate an implementation plan.\n5. `/speckit-tasks`: Create a task breakdown.\n6. `/speckit-analyze`: Verify consistency.\n7. `/speckit-implement`: Execute tasks.\n8. `/speckit-checklist`: Run a final quality check.\n\n## Dependencies\n\n- **abstract**: Provides meta-skills infrastructure.\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "abstract",
          "source": "./plugins/abstract",
          "description": "Meta-skills infrastructure for Claude Code plugin ecosystem - skill authoring, hook development, modular design patterns, and evaluation frameworks",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install abstract@claude-night-market"
          ]
        },
        {
          "name": "attune",
          "source": "./plugins/attune",
          "description": "Full-cycle project development - brainstorm ideas, create specifications, plan architecture, initialize projects, and execute implementation with integrated workflows from superpowers and spec-kit",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install attune@claude-night-market"
          ]
        },
        {
          "name": "archetypes",
          "source": "./plugins/archetypes",
          "description": "Architecture paradigm selection and implementation planning - 14 paradigm skills from functional-core to microservices",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install archetypes@claude-night-market"
          ]
        },
        {
          "name": "conjure",
          "source": "./plugins/conjure",
          "description": "Intelligent delegation framework for routing tasks to external LLMs (Gemini, Qwen) while retaining strategic oversight",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install conjure@claude-night-market"
          ]
        },
        {
          "name": "conserve",
          "source": "./plugins/conserve",
          "description": "Resource optimization and bloat detection - CPU/GPU performance monitoring, token conservation, bloat detection, and codebase cleanup",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install conserve@claude-night-market"
          ]
        },
        {
          "name": "hookify",
          "source": "./plugins/hookify",
          "description": "Create custom behavioral rules through markdown configuration - prevent unwanted behaviors with pattern matching and zero-code rule authoring",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install hookify@claude-night-market"
          ]
        },
        {
          "name": "imbue",
          "source": "./plugins/imbue",
          "description": "Intelligent workflow methodologies - review-core scaffolding, diff analysis, evidence logging, and catchup patterns",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install imbue@claude-night-market"
          ]
        },
        {
          "name": "leyline",
          "source": "./plugins/leyline",
          "description": "Storage and persistence patterns - templates for data management and storage solutions",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install leyline@claude-night-market"
          ]
        },
        {
          "name": "memory-palace",
          "source": "./plugins/memory-palace",
          "description": "Spatial knowledge organization with memory palace techniques - includes skill execution memory storage for continual learning",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install memory-palace@claude-night-market"
          ]
        },
        {
          "name": "minister",
          "source": "./plugins/minister",
          "description": "Project management plugin that aligns initiatives with GitHub data - turns repositories, issues, and projects into status dashboards",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install minister@claude-night-market"
          ]
        },
        {
          "name": "parseltongue",
          "source": "./plugins/parseltongue",
          "description": "Language detection, pattern matching, and testing guidance for multi-language codebases",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install parseltongue@claude-night-market"
          ]
        },
        {
          "name": "pensive",
          "source": "./plugins/pensive",
          "description": "Reflective code review toolkit - domain reviews (architecture, bugs, APIs, math, Rust, tests, Makefiles) plus skill performance analysis with stability gap detection",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install pensive@claude-night-market"
          ]
        },
        {
          "name": "sanctum",
          "source": "./plugins/sanctum",
          "description": "Git and workspace operations - commit messages, PR prep, documentation updates, version bumping",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install sanctum@claude-night-market"
          ]
        },
        {
          "name": "scribe",
          "source": "./plugins/scribe",
          "description": "Documentation review, cleanup, and generation with AI slop detection, style learning, and human-quality writing enforcement",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install scribe@claude-night-market"
          ]
        },
        {
          "name": "scry",
          "source": "./plugins/scry",
          "description": "Media generation - terminal recordings (VHS), browser recordings (Playwright), GIF processing, and media composition",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install scry@claude-night-market"
          ]
        },
        {
          "name": "spec-kit",
          "source": "./plugins/spec-kit",
          "description": "Specification-driven development - spec writing, implementation planning, and task orchestration",
          "version": "1.4.3",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add athola/claude-night-market",
            "/plugin install spec-kit@claude-night-market"
          ]
        }
      ]
    }
  ]
}