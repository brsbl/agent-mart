{
  "author": {
    "id": "chadhietala",
    "display_name": "Chad Hietala",
    "avatar_url": "https://avatars.githubusercontent.com/u/183799?v=4"
  },
  "marketplaces": [
    {
      "name": "engram-marketplace",
      "version": null,
      "description": "Memory evolution system for Claude Code",
      "repo_full_name": "chadhietala/engram",
      "repo_url": "https://github.com/chadhietala/engram",
      "repo_description": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-05T15:42:38Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"engram-marketplace\",\n  \"owner\": {\n    \"name\": \"Chad Hietala\"\n  },\n  \"metadata\": {\n    \"description\": \"Memory evolution system for Claude Code\",\n    \"version\": \"0.1.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"engram\",\n      \"source\": \"./\",\n      \"description\": \"Learn from your Claude Code usage and generate reusable skills\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"engram\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Memory evolution system that learns from your Claude Code usage and generates reusable skills through Hegelian dialectic\",\n  \"author\": {\n    \"name\": \"Chad Hietala\",\n    \"url\": \"https://github.com/chietala/engram\"\n  },\n  \"homepage\": \"https://github.com/chietala/engram\",\n  \"repository\": \"https://github.com/chietala/engram\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"memory\", \"learning\", \"skills\", \"patterns\", \"dialectic\"]\n}\n",
        "README.md": "# Engram\n\nA memory system for Claude Code that learns how you work and generates new skills from your patterns.\n\n## Installation\n\n### As a Claude Code Plugin (Recommended)\n\n**Local Development:**\n```bash\n# Clone the repo\ngit clone https://github.com/chietala/engram.git\ncd engram\nbun install\n\n# Run Claude Code with the plugin\nclaude --plugin-dir /path/to/engram\n```\n\n**From GitHub:**\n```bash\n# Add the marketplace\n/plugin marketplace add chietala/engram\n\n# Install the plugin\n/plugin install engram@engram-marketplace\n```\n\n**Team Auto-Install:**\nAdd to your project's `.claude/settings.json`:\n```json\n{\n  \"extraKnownMarketplaces\": {\n    \"engram-marketplace\": {\n      \"source\": {\n        \"source\": \"github\",\n        \"repo\": \"chietala/engram\"\n      }\n    }\n  },\n  \"enabledPlugins\": {\n    \"engram@engram-marketplace\": true\n  }\n}\n```\n\n## The Idea\n\nEvery time you use Claude Code, you're teaching it something. Engram captures those lessons automatically:\n\n- **Watch**: Observes your tool usage (file reads, bash commands, edits)\n- **Remember**: Stores patterns with semantic understanding\n- **Evolve**: Challenges and refines patterns through contradiction\n- **Generate**: Creates reusable Claude Skills from mature patterns\n\n## Plugin Commands\n\nOnce installed, these commands are available:\n\n| Command | Description |\n|---------|-------------|\n| `/engram-status` | Show memory counts and system status |\n| `/engram-query <search>` | Search memories semantically |\n| `/engram-generate <name>` | Generate a skill from recent patterns |\n| `/engram-publish` | Publish mature patterns as Claude rules |\n\n## Features\n\n### Automatic Pattern Detection\n\nEngram notices when you do similar things repeatedly. Read a config file then run a command? Do it a few times and Engram recognizes the pattern.\n\n### Hegelian Learning\n\nPatterns evolve through dialectic:\n\n1. **Thesis** - Initial pattern: \"Always use `git status` before committing\"\n2. **Antithesis** - Contradiction: \"But sometimes you skip it for quick fixes\"\n3. **Synthesis** - Resolution: \"Use `git status` for multi-file changes, skip for single-line fixes\"\n\nThis creates nuanced, context-aware knowledge.\n\n### LLM-Powered Insights\n\nClaude analyzes your patterns and generates insights like:\n\n> \"The user is building a self-improving system that observes its own tool usage patterns and automatically generates new reusable skills\"\n\n### Native Memory Integration\n\nWhen patterns reach synthesis, Engram automatically publishes them as Claude rules—meaning **Claude remembers your patterns without the plugin running**:\n\n```\n.claude/rules/engram/\n├── testing-workflow.md      # \"Run tests before committing\"\n├── error-handling.md        # \"Check logs after deployments\"\n└── code-review.md           # \"Read tests before reviewing PRs\"\n```\n\nRules include:\n- **Path-specific triggers**: Only activate for relevant file types\n- **Linked skills**: Reference executable skills for automation\n- **Confidence tracking**: Update as patterns evolve\n\nExample generated rule:\n\n```markdown\n---\npaths:\n  - \"**/*.ts\"\n  - \"src/**\"\n---\n\n# Test Before Commit\n\nBefore committing any code changes, always run the test suite with `bun test`.\n\n## Related Skill\n\nThis pattern has an associated skill: **test-before-commit**\n\n> Runs tests and commits changes with conventional commit messages\n\n**To invoke this skill**, say:\n- \"commit my changes\"\n- \"run tests and commit\"\n- \"safe commit\"\n```\n\n### Automatic Skill Generation\n\nWhen a pattern matures enough (used consistently, survived contradictions), Engram generates a Claude Skill you can use in future sessions.\n\n### Hybrid Skill Scripts\n\nGenerated skills aren't just static instructions—they're executable scripts that combine:\n\n- **Deterministic code** for file operations, glob patterns, shell commands\n- **Intelligence points** for LLM-powered reasoning where judgment is needed\n\n```typescript\n// Deterministic: gather data\nconst files = await glob.scan({ pattern: \"**/*.ts\" });\nconst diff = await $`git diff --cached`.text();\n\n// Intelligence point: generate insights\nconst summary = await intelligence(\n  \"Summarize the key patterns in this codebase\",\n  { files: fileList, diff }\n);\n\n// Deterministic: output results\nconsole.log(summary);\n```\n\nThis creates scripts that are both reliable and intelligent.\n\n### Memory Consolidation\n\nLike human memory:\n- **Working memory** - Current session activity\n- **Short-term memory** - Recent patterns, subject to decay\n- **Long-term memory** - Proven patterns that persist\n\nOld, unused memories fade. Important ones strengthen.\n\n### Semantic Search\n\nQuery your memories naturally:\n\n```bash\n/engram-query \"how do I handle errors\"\n```\n\nFinds relevant patterns even if wording differs.\n\n## What Gets Captured\n\n| Event | What's Learned |\n|-------|----------------|\n| File reads | What you look at to understand code |\n| Bash commands | Your debugging and build workflows |\n| File edits | How you modify code |\n| Prompts | What you're trying to accomplish |\n\n## Example Generated Skill\n\nAfter observing codebase exploration patterns, Engram generates a hybrid script:\n\n```typescript\n#!/usr/bin/env bun\nimport { intelligence } from \"engram/skill-runtime\";\n\n// Deterministic: discover files\nconst glob = new Bun.Glob(\"**/*.ts\");\nconst files = [];\nfor await (const file of glob.scan({ cwd: targetDir })) {\n  files.push(file);\n}\n\n// Deterministic: read contents\nconst contents = await Promise.all(\n  files.map(f => Bun.file(f).text())\n);\n\n// Intelligence point: analyze with LLM reasoning\nconst analysis = await intelligence(\n  \"Identify the key architectural patterns in this codebase\",\n  { files: files.join(\"\\n\"), sampleCode: contents[0] }\n);\n\nconsole.log(analysis);\n```\n\nThe script uses deterministic code for file operations but calls `intelligence()` when human-like judgment is needed.\n\n## Data Storage\n\nEngram stores data in a project-local `.engram/` directory:\n- Each project gets its own isolated memory\n- Configure with `ENGRAM_DATA_DIR` environment variable if needed\n\n### Rules Publishing\n\nMature patterns are automatically published to `.claude/rules/engram/`:\n\n| Config | Default | Description |\n|--------|---------|-------------|\n| `ENGRAM_RULES_AUTO_PUBLISH` | `true` | Auto-publish on synthesis |\n| `ENGRAM_RULES_MIN_CONFIDENCE` | `0.7` | Minimum confidence to publish |\n| `ENGRAM_RULES_MIN_MEMORIES` | `3` | Minimum supporting memories |\n| `ENGRAM_RULES_DIR` | `.claude/rules/engram` | Project rules directory |\n| `ENGRAM_USER_RULES_DIR` | `~/.claude/rules` | User-level rules |\n\nPublished rules are tracked in the database and updated when patterns evolve.\n\n## Using Generated Skills\n\nGenerated skills are placed in `.claude/skills/` and can be run directly:\n\n```bash\n# Run a generated skill\nbun .claude/skills/explore-codebase/script.ts ./src\n\n# Skills support --help\nbun .claude/skills/explore-codebase/script.ts --help\n```\n\n### Skill Runtime\n\nGenerated scripts can import intelligence helpers:\n\n```typescript\nimport { intelligence, intelligenceWithSchema, decide, z } from \"engram/skill-runtime\";\n\n// Simple text response\nconst summary = await intelligence(\"Summarize this code\", { code });\n\n// Structured response with schema\nconst ReviewSchema = z.object({\n  approved: z.boolean(),\n  issues: z.array(z.string()),\n});\nconst review = await intelligenceWithSchema(\"Review this PR\", ReviewSchema, { diff });\n\n// Yes/no decision\nconst shouldProceed = await decide(\"Is this safe to deploy?\", { changes });\n```\n\n## Architecture\n\n```\n                    ┌─────────────────────────┐\n                    │   Tool Usage (Hooks)    │\n                    └───────────┬─────────────┘\n                                │\n                                ▼\n                    ┌─────────────────────────┐\n                    │   SQLite (Learning)     │\n                    │   - Raw memories        │\n                    │   - Pattern detection   │\n                    │   - Dialectic cycles    │\n                    └───────────┬─────────────┘\n                                │\n         ┌──────────────────────┼──────────────────────┐\n         │                      │                      │\n         ▼                      ▼                      ▼\n┌───────────────────┐  ┌───────────────────┐  ┌───────────────────┐\n│  .claude/rules/   │  │  .claude/skills/  │  │    CLAUDE.md      │\n│  engram/*.md      │  │  {skillName}/     │  │    (optional)     │\n│  (insights)       │  │  (procedures)     │  │                   │\n└───────────────────┘  └───────────────────┘  └───────────────────┘\n         │                      │                      │\n         └──────────────────────┼──────────────────────┘\n                                │\n                                ▼\n                    ┌─────────────────────────┐\n                    │  Claude's Native Memory │\n                    │  (auto-loaded context)  │\n                    └─────────────────────────┘\n```\n\nThe key insight: learning happens in SQLite, but mature knowledge graduates to Claude's native memory system—meaning it persists even without the plugin.\n\n## Privacy\n\nEverything runs locally:\n- SQLite database on your machine\n- Embeddings generated locally (no API calls)\n- LLM analysis uses Claude Agent SDK (your existing auth)\n\n## Requirements\n\n- Bun runtime\n- Claude Code CLI\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "engram",
          "source": "./",
          "description": "Learn from your Claude Code usage and generate reusable skills",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add chadhietala/engram",
            "/plugin install engram@engram-marketplace"
          ]
        }
      ]
    }
  ]
}