{
  "author": {
    "id": "joescharf",
    "display_name": "Joe Scharf",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/43955?u=a820a85e6d73e98364b71c323408c3f40d9ed98a&v=4",
    "url": "https://github.com/joescharf",
    "bio": "dbsnapper.com - database workload management for ci/cd pipelines and AI modeling",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "joescharf-marketplace",
      "version": null,
      "description": "Personal Claude Code marketplace with custom hooks, skills, and plugins",
      "owner_info": {
        "name": "Joe Scharf"
      },
      "keywords": [],
      "repo_full_name": "joescharf/cc-joescharf-marketplace",
      "repo_url": "https://github.com/joescharf/cc-joescharf-marketplace",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-19T03:13:07Z",
        "created_at": "2025-12-19T03:13:05Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 823
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/enforce-bun",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/enforce-bun/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/enforce-bun/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 174
        },
        {
          "path": "plugins/enforce-bun/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/enforce-bun/hooks/hooks.json",
          "type": "blob",
          "size": 255
        },
        {
          "path": "plugins/enforce-bun/hooks/pre_tool_use_bun.ts",
          "type": "blob",
          "size": 6304
        },
        {
          "path": "plugins/enforce-uv",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/enforce-uv/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/enforce-uv/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 165
        },
        {
          "path": "plugins/enforce-uv/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/enforce-uv/hooks/hooks.json",
          "type": "blob",
          "size": 720
        },
        {
          "path": "plugins/enforce-uv/hooks/notification_uv.py",
          "type": "blob",
          "size": 2266
        },
        {
          "path": "plugins/enforce-uv/hooks/post_tool_use_uv.py",
          "type": "blob",
          "size": 3421
        },
        {
          "path": "plugins/enforce-uv/hooks/pre_tool_use_uv.py",
          "type": "blob",
          "size": 5990
        },
        {
          "path": "plugins/homeassistant",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/homeassistant/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/homeassistant/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 160
        },
        {
          "path": "plugins/homeassistant/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/homeassistant/skills/control-office-lamp",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/homeassistant/skills/control-office-lamp/README.md",
          "type": "blob",
          "size": 1347
        },
        {
          "path": "plugins/homeassistant/skills/control-office-lamp/SKILL.md",
          "type": "blob",
          "size": 2095
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"joescharf-marketplace\",\n  \"owner\": {\n    \"name\": \"Joe Scharf\"\n  },\n  \"metadata\": {\n    \"description\": \"Personal Claude Code marketplace with custom hooks, skills, and plugins\",\n    \"version\": \"1.0.0\",\n    \"pluginRoot\": \"./plugins\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"homeassistant\",\n      \"source\": \"./plugins/homeassistant\",\n      \"description\": \"Home Assistant integrations for Claude Code\",\n      \"version\": \"0.1.0\"\n    },\n    {\n      \"name\": \"enforce-bun\",\n      \"source\": \"./plugins/enforce-bun\",\n      \"description\": \"Enforce bun usage over npm/pnpm/yarn in JavaScript projects\",\n      \"version\": \"0.1.0\"\n    },\n    {\n      \"name\": \"enforce-uv\",\n      \"source\": \"./plugins/enforce-uv\",\n      \"description\": \"Enforce uv usage over pip/python in Python projects\",\n      \"version\": \"0.1.0\"\n    }\n  ]\n}\n",
        "plugins/enforce-bun/.claude-plugin/plugin.json": "{\n  \"name\": \"enforce-bun\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Enforce bun usage over npm/pnpm/yarn in JavaScript projects\",\n  \"author\": {\n    \"name\": \"Joe Scharf\"\n  }\n}\n",
        "plugins/enforce-bun/hooks/hooks.json": "{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bun run ${CLAUDE_PLUGIN_ROOT}/hooks/pre_tool_use_bun.ts\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "plugins/enforce-bun/hooks/pre_tool_use_bun.ts": "#!/usr/bin/env bun\n\ninterface HookEvent {\n  tool_name: string;\n  tool_input: {\n    command?: string;\n    [key: string]: unknown;\n  };\n  session_id?: string;\n  transcript_path?: string;\n}\n\n// Commands that map directly to bun (same subcommand)\nconst DIRECT_MAPPINGS = new Set([\n  \"init\",\n  \"install\",\n  \"add\",\n  \"remove\",\n  \"run\",\n  \"test\",\n  \"start\",\n  \"build\",\n  \"update\",\n  \"outdated\",\n  \"link\",\n  \"unlink\",\n  \"publish\",\n  \"create\",\n]);\n\n// Special command mappings (npm/pnpm/yarn -> bun equivalent)\nconst SPECIAL_MAPPINGS: Record<string, string> = {\n  // Common aliases\n  i: \"install\",\n  rm: \"remove\",\n  uninstall: \"remove\",\n  exec: \"x\",\n  ci: \"install --frozen-lockfile\",\n  ls: \"pm ls\",\n  list: \"pm ls\",\n  // npm specific\n  pack: \"x npm pack\",\n  \"cache clean\": \"pm cache rm\",\n  audit: \"x npm audit\",\n  fund: \"x npm fund\",\n  doctor: \"x npm doctor\",\n  view: \"x npm view\",\n  info: \"x npm info\",\n  search: \"x npm search\",\n  // pnpm specific\n  dlx: \"x\",\n  \"store prune\": \"pm cache rm\",\n  // yarn specific\n  upgrade: \"update\",\n  \"global add\": \"add --global\",\n  \"global remove\": \"remove --global\",\n};\n\n// Package managers and their npx equivalents\nconst PACKAGE_MANAGERS = [\"npm\", \"pnpm\", \"yarn\"];\nconst NPX_EQUIVALENTS = [\"npx\", \"pnpx\"];\nconst ALL_MANAGERS = [...PACKAGE_MANAGERS, ...NPX_EQUIVALENTS];\n\n/**\n * Strip leading environment variable assignments from a command\n * e.g., \"NODE_ENV=production npm run build\" -> \"npm run build\"\n */\nfunction stripEnvVars(command: string): string {\n  return command.replace(/^(\\s*\\w+=\\S+\\s+)+/, \"\").trim();\n}\n\n/**\n * Check if a command segment starts with a package manager\n * Returns the manager name if found, null otherwise\n */\nfunction getPackageManager(segment: string): string | null {\n  const cleaned = stripEnvVars(segment);\n  const pattern = new RegExp(`^(${ALL_MANAGERS.join(\"|\")})(?:\\\\s|$)`, \"i\");\n  const match = cleaned.match(pattern);\n  return match ? match[1].toLowerCase() : null;\n}\n\n/**\n * Split a command into segments by shell operators\n * Handles &&, ||, ;, and | (pipe)\n */\nfunction splitCommandSegments(command: string): string[] {\n  // Simple split - doesn't handle quoted strings perfectly but covers most cases\n  return command.split(/\\s*(?:&&|\\|\\||;|\\|)\\s*/).filter(Boolean);\n}\n\n/**\n * Find the first package manager usage in a command\n * Returns the segment and manager, or null if none found\n */\nfunction findPackageManagerUsage(\n  command: string\n): { segment: string; manager: string } | null {\n  const segments = splitCommandSegments(command);\n\n  for (const segment of segments) {\n    const manager = getPackageManager(segment);\n    if (manager) {\n      return { segment: stripEnvVars(segment), manager };\n    }\n  }\n\n  return null;\n}\n\n/**\n * Generate the bun equivalent for a package manager command\n */\nfunction getBunEquivalent(segment: string, manager: string): string {\n  // Handle npx/pnpx - always map to bunx\n  if (NPX_EQUIVALENTS.includes(manager)) {\n    const args = segment.substring(manager.length).trim();\n    return `bunx ${args}`.trim();\n  }\n\n  // Parse the command after the package manager\n  const afterManager = segment.substring(manager.length).trim();\n  const words = afterManager.split(/\\s+/);\n  const subcommand = words[0] || \"\";\n  const args = words.slice(1).join(\" \");\n\n  // Check for multi-word commands first (e.g., \"cache clean\", \"global add\")\n  const multiWordCommand = words.slice(0, 2).join(\" \");\n  if (SPECIAL_MAPPINGS[multiWordCommand]) {\n    const remainingArgs = words.slice(2).join(\" \");\n    return `bun ${SPECIAL_MAPPINGS[multiWordCommand]} ${remainingArgs}`.trim();\n  }\n\n  // Check single word special mappings\n  if (SPECIAL_MAPPINGS[subcommand]) {\n    return `bun ${SPECIAL_MAPPINGS[subcommand]} ${args}`.trim();\n  }\n\n  // Direct mapping - just replace package manager with bun\n  if (DIRECT_MAPPINGS.has(subcommand)) {\n    return `bun ${afterManager}`;\n  }\n\n  // No subcommand - just the package manager alone\n  if (!subcommand) {\n    return \"bun\";\n  }\n\n  // Unknown command - fallback to generic replacement\n  return `bun ${afterManager}`;\n}\n\n/**\n * Check if this is a command we should skip entirely\n */\nfunction shouldSkipCommand(command: string): boolean {\n  const trimmed = command.trim();\n\n  // Skip git commands - we don't want to interfere with commit messages\n  // that might contain \"npm\" or other package manager names\n  if (trimmed.startsWith(\"git \")) {\n    return true;\n  }\n\n  // Skip grep/rg/ag searches that might search for \"npm\" as a string\n  if (/^(grep|rg|ag|ack)\\s/.test(trimmed)) {\n    return true;\n  }\n\n  // Skip echo/printf commands that might mention package managers\n  if (/^(echo|printf)\\s/.test(trimmed)) {\n    return true;\n  }\n\n  // Skip cat/head/tail/less/more reading files\n  if (/^(cat|head|tail|less|more)\\s/.test(trimmed)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * PreToolUse hook that enforces bun usage over npm/pnpm/yarn\n */\nfunction preToolUse(event: HookEvent): void {\n  // Only check Bash tool calls\n  if (event.tool_name !== \"Bash\") {\n    return;\n  }\n\n  const command = event.tool_input?.command || \"\";\n\n  // Skip commands we shouldn't interfere with\n  if (shouldSkipCommand(command)) {\n    return;\n  }\n\n  // Find any package manager usage in the command\n  const usage = findPackageManagerUsage(command);\n\n  if (usage) {\n    const { segment, manager } = usage;\n    const bunEquivalent = getBunEquivalent(segment, manager);\n\n    // Provide clear feedback to Claude\n    console.error(`❌ Blocked: \"${manager}\" is not allowed in this project.`);\n    console.error(`✅ Use bun instead: ${bunEquivalent}`);\n\n    // If the original command had multiple segments, note that\n    const segments = splitCommandSegments(command);\n    if (segments.length > 1) {\n      console.error(\n        `ℹ️  Note: The command had multiple parts. Replace \"${segment}\" with \"${bunEquivalent}\" in your full command.`\n      );\n    }\n\n    // Exit code 2 = error with feedback to Claude for substitution\n    process.exit(2);\n  }\n}\n\n// Main execution - read from stdin\nlet input = \"\";\n\nprocess.stdin.on(\"data\", (chunk) => {\n  input += chunk;\n});\n\nprocess.stdin.on(\"end\", () => {\n  try {\n    const eventData: HookEvent = JSON.parse(input);\n    preToolUse(eventData);\n  } catch (error) {\n    console.error(\"Error parsing hook event data:\", error);\n    process.exit(1);\n  }\n});\n",
        "plugins/enforce-uv/.claude-plugin/plugin.json": "{\n  \"name\": \"enforce-uv\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Enforce uv usage over pip/python in Python projects\",\n  \"author\": {\n    \"name\": \"Joe Scharf\"\n  }\n}\n",
        "plugins/enforce-uv/hooks/hooks.json": "{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"uv run ${CLAUDE_PLUGIN_ROOT}/hooks/pre_tool_use_uv.py\"\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"uv run ${CLAUDE_PLUGIN_ROOT}/hooks/post_tool_use_uv.py\"\n          }\n        ]\n      }\n    ],\n    \"Notification\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"uv run ${CLAUDE_PLUGIN_ROOT}/hooks/notification_uv.py\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "plugins/enforce-uv/hooks/notification_uv.py": "#!/usr/bin/env python3\n# /// script\n# requires-python = \">=3.8\"\n# dependencies = []\n# ///\n\"\"\"\nNotification hook for UV-related reminders.\n\nInjects a system message reminder when permission prompts mention Python-related commands.\nThis helps remind Claude to use UV commands in UV-managed projects.\n\"\"\"\n\nimport json\nimport sys\n\n\ndef main():\n    \"\"\"Main hook function.\"\"\"\n    try:\n        # Read input\n        input_data = json.loads(sys.stdin.read())\n        message = input_data.get('message', '')\n        notification_type = input_data.get('notification_type', '')\n\n        # Only act on permission prompts (when Claude is asking to run something)\n        if notification_type != 'permission_prompt':\n            print(json.dumps({}))\n            return\n\n        # Check for Python-related permission requests\n        python_keywords = ['python', 'pip', 'install', 'package', 'dependency',\n                          'pytest', 'ruff', 'mypy', 'black', 'flake8']\n        if any(keyword in message.lower() for keyword in python_keywords):\n            # Build reminder message\n            reminder = \"Reminder: This project uses UV. Use UV commands instead of direct pip/python.\"\n\n            # Provide context-specific suggestions\n            suggestions = []\n            if 'install' in message.lower() or 'pip' in message.lower():\n                suggestions.append(\"uv add <package> (not pip install)\")\n            if 'python' in message.lower():\n                suggestions.append(\"uv run python (not python directly)\")\n            if any(tool in message.lower() for tool in ['pytest', 'ruff', 'mypy', 'black']):\n                suggestions.append(\"uv run <tool> (not tool directly)\")\n\n            if suggestions:\n                reminder += \" \" + \"; \".join(suggestions) + \".\"\n\n            # Output using proper schema with systemMessage\n            output = {\n                \"systemMessage\": reminder\n            }\n            print(json.dumps(output))\n        else:\n            # No reminder needed\n            print(json.dumps({}))\n\n    except Exception as e:\n        # On error, just continue (don't block notifications)\n        print(f\"Notification hook error: {str(e)}\", file=sys.stderr)\n        print(json.dumps({}))\n\n\nif __name__ == \"__main__\":\n    main()",
        "plugins/enforce-uv/hooks/post_tool_use_uv.py": "#!/usr/bin/env python3\n# /// script\n# requires-python = \">=3.8\"\n# dependencies = []\n# ///\n\"\"\"\nPost-tool use hook for Claude Code to provide UV guidance after command execution.\n\nThis hook runs AFTER a command has executed. It can:\n1. Add context to help Claude learn from non-UV command usage\n2. Detect pip/python commands that succeeded and remind about UV alternatives\n\nNote: PostToolUse cannot prevent execution (tool already ran), but can provide\nfeedback that influences future Claude behavior in the conversation.\n\"\"\"\n\nimport json\nimport os\nimport re\nimport sys\nfrom pathlib import Path\n\n\ndef check_uv_project() -> bool:\n    \"\"\"Check if we're in a UV-managed Python project.\"\"\"\n    project_root = Path.cwd()\n    has_pyproject = (project_root / \"pyproject.toml\").exists()\n    has_uv = os.system(\"which uv > /dev/null 2>&1\") == 0\n    return has_pyproject and has_uv\n\n\ndef is_non_uv_python_command(command: str) -> bool:\n    \"\"\"Check if command used Python/pip directly instead of UV.\"\"\"\n    if command.strip().startswith(\"uv\"):\n        return False\n\n    python_patterns = [\n        r\"^python3?\\s+\",\n        r\"^pip3?\\s+\",\n        r\"^(pytest|ruff|mypy|black|flake8|isort)\\s+\",\n    ]\n    return any(re.search(pattern, command) for pattern in python_patterns)\n\n\ndef suggest_uv_alternative(command: str) -> str:\n    \"\"\"Suggest the UV alternative for a command.\"\"\"\n    if re.match(r\"^python3?\\s+\", command):\n        return re.sub(r\"^python3?\\s+\", \"uv run python \", command)\n    elif re.match(r\"^pip3?\\s+install\\s+\", command):\n        return re.sub(r\"^pip3?\\s+install\\s+\", \"uv add \", command)\n    elif re.match(r\"^pip3?\\s+\", command):\n        return re.sub(r\"^pip3?\\s+\", \"uv pip \", command)\n    elif re.match(r\"^(pytest|ruff|mypy|black|flake8|isort)\", command):\n        return f\"uv run {command}\"\n    return command\n\n\ndef main():\n    \"\"\"Main hook function.\"\"\"\n    try:\n        # Read input from Claude Code\n        input_data = json.loads(sys.stdin.read())\n\n        # Only process Bash/Run commands\n        tool_name = input_data.get(\"tool_name\", \"\")\n        if tool_name not in [\"Bash\", \"Run\"]:\n            print(json.dumps({}))\n            return\n\n        # Get the command and response\n        tool_input = input_data.get(\"tool_input\", {})\n        command = tool_input.get(\"command\", \"\")\n        tool_response = input_data.get(\"tool_response\", {})\n\n        if not command:\n            print(json.dumps({}))\n            return\n\n        # Only provide feedback in UV projects\n        if not check_uv_project():\n            print(json.dumps({}))\n            return\n\n        # Check if a non-UV Python command was used\n        if is_non_uv_python_command(command):\n            suggestion = suggest_uv_alternative(command)\n            context = (\n                f\"Note: Direct python/pip was used instead of UV. \"\n                f\"For future commands, prefer: {suggestion}\"\n            )\n\n            # Use additionalContext to inform Claude\n            output = {\n                \"hookSpecificOutput\": {\n                    \"hookEventName\": \"PostToolUse\",\n                    \"additionalContext\": context\n                }\n            }\n            print(json.dumps(output))\n        else:\n            print(json.dumps({}))\n\n    except Exception as e:\n        # On error, just continue\n        print(f\"PostToolUse hook error: {str(e)}\", file=sys.stderr)\n        print(json.dumps({}))\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "plugins/enforce-uv/hooks/pre_tool_use_uv.py": "#!/usr/bin/env python3\n# /// script\n# requires-python = \">=3.8\"\n# dependencies = []\n# ///\n\"\"\"\nPre-tool use hook for Claude Code to guide UV usage in Python projects.\n\nSince PreToolUse hooks cannot modify commands (Claude Code limitation),\nthis hook provides helpful guidance when Python commands are used in UV projects.\n\"\"\"\n\nimport json\nimport sys\nimport re\nimport os\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nclass UVCommandHandler:\n    \"\"\"Handle Python commands with UV awareness.\"\"\"\n    \n    def __init__(self):\n        self.project_root = Path.cwd()\n        self.has_uv = self.check_uv_available()\n        self.in_project = self.check_in_project()\n        \n    def check_uv_available(self) -> bool:\n        \"\"\"Check if UV is available in PATH.\"\"\"\n        return os.system(\"which uv > /dev/null 2>&1\") == 0\n        \n    def check_in_project(self) -> bool:\n        \"\"\"Check if we're in a Python project with pyproject.toml.\"\"\"\n        return (self.project_root / \"pyproject.toml\").exists()\n        \n    def analyze_command(self, command: str) -> Dict[str, Any]:\n        \"\"\"Analyze command to determine how to handle it.\"\"\"\n        # Check if command already uses uv (anywhere in the command)\n        if re.search(r'\\buv\\s+(run|add|pip|sync|lock)\\b', command):\n            return {\"action\": \"approve\", \"reason\": \"Already using uv\"}\n\n        # Check for actual Python command execution (including in compound commands)\n        python_exec_patterns = [\n            r'^python3?\\s+',      # python script.py\n            r'^python3?\\s*$',     # just python\n            r'\\|\\s*python3?\\s+',  # piped to python\n            r';\\s*python3?\\s+',   # after semicolon\n            r'&&\\s*python3?\\s+',  # after &&\n            r'^pip3?\\s+',         # pip commands\n            r'\\|\\s*pip3?\\s+',     # piped pip\n            r';\\s*pip3?\\s+',      # after semicolon\n            r'&&\\s*pip3?\\s+',     # after &&\n            r'^(pytest|ruff|mypy|black|flake8|isort)\\s+',  # dev tools\n            r';\\s*(pytest|ruff|mypy|black|flake8|isort)\\s+',\n            r'&&\\s*(pytest|ruff|mypy|black|flake8|isort)\\s+',\n        ]\n\n        is_python_exec = any(re.search(pattern, command) for pattern in python_exec_patterns)\n\n        if not is_python_exec:\n            return {\"action\": \"approve\", \"reason\": \"Not a Python execution command\"}\n            \n        # If we're in a UV project, provide guidance\n        if self.has_uv and self.in_project:\n            # Parse command to provide better suggestions\n            suggestion = self.suggest_uv_command(command)\n            return {\n                \"action\": \"block\",\n                \"reason\": f\"This project uses UV for Python management. {suggestion}\"\n            }\n            \n        # Otherwise, let it through\n        return {\"action\": \"approve\", \"reason\": \"UV not required\"}\n        \n    def suggest_uv_command(self, command: str) -> str:\n        \"\"\"Provide UV command suggestions.\"\"\"\n        # Handle compound commands (e.g., cd && python)\n        if '&&' in command:\n            parts = command.split('&&')\n            transformed_parts = []\n            \n            for part in parts:\n                part = part.strip()\n                # Only transform the Python-related parts\n                if re.search(r'\\b(python3?|pip3?|pytest|ruff|mypy|black)\\b', part):\n                    transformed_parts.append(self._transform_single_command(part))\n                else:\n                    transformed_parts.append(part)\n                    \n            return f\"Try: {' && '.join(transformed_parts)}\"\n            \n        # Simple commands\n        return f\"Try: {self._transform_single_command(command)}\"\n        \n    def _transform_single_command(self, command: str) -> str:\n        \"\"\"Transform a single Python command to use UV.\"\"\"\n        # Python execution\n        if re.match(r'^python3?\\s+', command):\n            return re.sub(r'^python3?\\s+', 'uv run python ', command)\n        \n        # Package installation\n        elif re.match(r'^pip3?\\s+install\\s+', command):\n            return re.sub(r'^pip3?\\s+install\\s+', 'uv add ', command)\n            \n        # Other pip commands\n        elif re.match(r'^pip3?\\s+', command):\n            return re.sub(r'^pip3?\\s+', 'uv pip ', command)\n            \n        # Development tools\n        elif re.match(r'^(pytest|ruff|mypy|black|flake8|isort)\\s+', command):\n            return f'uv run {command}'\n            \n        return command\n\ndef main():\n    \"\"\"Main hook function.\"\"\"\n    try:\n        # Read input from Claude Code\n        input_data = json.loads(sys.stdin.read())\n\n        # Only process Bash/Run commands\n        tool_name = input_data.get('tool_name', '')\n        if tool_name not in ['Bash', 'Run']:\n            # Allow non-Bash tools (empty output = allow)\n            print(json.dumps({}))\n            return\n\n        # Get the command\n        tool_input = input_data.get('tool_input', {})\n        command = tool_input.get('command', '')\n\n        if not command:\n            # Allow empty commands\n            print(json.dumps({}))\n            return\n\n        # Analyze command\n        handler = UVCommandHandler()\n        result = handler.analyze_command(command)\n\n        # Return decision using correct schema\n        if result[\"action\"] == \"block\":\n            # Use exit code 2 to block, with reason on stderr\n            print(result[\"reason\"], file=sys.stderr)\n            sys.exit(2)\n        else:\n            # Allow: empty output or explicit allow\n            output = {\n                \"hookSpecificOutput\": {\n                    \"hookEventName\": \"PreToolUse\",\n                    \"permissionDecision\": \"allow\",\n                    \"permissionDecisionReason\": result[\"reason\"]\n                }\n            }\n            print(json.dumps(output))\n\n    except Exception as e:\n        # On error, allow to avoid blocking workflow\n        print(f\"Hook error (allowing): {str(e)}\", file=sys.stderr)\n        print(json.dumps({}))\n\nif __name__ == \"__main__\":\n    main()",
        "plugins/homeassistant/.claude-plugin/plugin.json": "{\n  \"name\": \"homeassistant\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Home Assistant integrations for Claude Code\",\n  \"author\": {\n    \"name\": \"Joe Scharf\"\n  }\n}\n",
        "plugins/homeassistant/skills/control-office-lamp/README.md": "# Home Assistant Lamp Control Skill\n\nA Claude Code skill for controlling an office lamp via Home Assistant's REST API.\n\n## Structure\n\n```\nhomeassistant-lamp/\n├── SKILL.md              # Skill definition with frontmatter\n├── README.md             # This file\n├── config.json.example   # Configuration template\n├── .gitignore            # Excludes config.json (contains secrets)\n└── scripts/\n    └── lamp_control.py   # Control script with PEP 723 metadata\n```\n\n## Configuration\n\nCreate your config file at `~/.claude/skill-config/homeassistant-lamp/config.json`:\n\n```json\n{\n  \"url\": \"http://your-home-assistant:8123\",\n  \"token\": \"YOUR_LONG_LIVED_ACCESS_TOKEN\",\n  \"entity_id\": \"light.office_lamp\"\n}\n```\n\nThis location persists across skill updates.\n\n**Config lookup order:**\n1. `HA_CONFIG_PATH` environment variable\n2. `~/.claude/skill-config/homeassistant-lamp/config.json` (recommended)\n3. `<skill-directory>/config.json` (fallback)\n\n## Features\n\n- Turn lamp on/off/toggle\n- Check lamp status\n- JSON output for easy parsing\n- Environment variable override for config path (`HA_CONFIG_PATH`)\n\n## Usage\n\nOnce installed, Claude will automatically use this skill when you say things like:\n- \"Turn on my lamp\"\n- \"Is my office light on?\"\n- \"Toggle the lamp\"\n\nSee [SKILL.md](SKILL.md) for detailed usage instructions.\n",
        "plugins/homeassistant/skills/control-office-lamp/SKILL.md": "---\nname: control-office-lamp\ndescription: Control office lamp via Home Assistant. Use when the user asks to turn on, turn off, or toggle their office lamp, or check its status. Triggers on phrases like \"turn on my lamp\", \"office light on/off\", \"toggle the lamp\", or \"is my lamp on\".\nallowed-tools:\n  - Bash\n  - Read\n---\n\n# Home Assistant Office Lamp Control\n\nControl the office lamp through Home Assistant's REST API.\n\n## Setup (First-Time Only)\n\nCreate your config file at `~/.claude/skill-config/control-office-lamp/config.json`:\n\n```json\n{\n  \"url\": \"http://your-home-assistant:8123\",\n  \"token\": \"YOUR_LONG_LIVED_ACCESS_TOKEN_HERE\",\n  \"entity_id\": \"light.office_lamp\"\n}\n```\n\nThis location persists across skill updates.\n\nTo create a Long-Lived Access Token:\n1. Open Home Assistant -> Profile (bottom-left)\n2. Scroll to \"Long-Lived Access Tokens\" -> Create Token\n3. Copy the token into config.json\n\n**Config lookup order:**\n1. `HA_CONFIG_PATH` environment variable\n2. `~/.claude/skill-config/control-office-lamp/config.json` (recommended)\n3. `${CLAUDE_PLUGIN_ROOT}/skills/control-office-lamp/config.json` (plugin root)\n4. `<script-directory>/../config.json` (fallback)\n\n## Usage\n\nThe script is located relative to the plugin root using `${CLAUDE_PLUGIN_ROOT}`:\n\n```bash\n# Turn lamp on\nuv run \"${CLAUDE_PLUGIN_ROOT}/skills/control-office-lamp/scripts/lamp_control.py\" on\n\n# Turn lamp off\nuv run \"${CLAUDE_PLUGIN_ROOT}/skills/control-office-lamp/scripts/lamp_control.py\" off\n\n# Toggle lamp state\nuv run \"${CLAUDE_PLUGIN_ROOT}/skills/control-office-lamp/scripts/lamp_control.py\" toggle\n\n# Check current status\nuv run \"${CLAUDE_PLUGIN_ROOT}/skills/control-office-lamp/scripts/lamp_control.py\" status\n```\n\n## Response Handling\n\n**Success response:**\n```json\n{\"success\": true, \"action\": \"turn_on\", \"entity_id\": \"light.office_lamp\", \"response\": [...]}\n```\n\n**Error response:**\n```json\n{\"success\": false, \"error\": \"Connection failed: ...\"}\n```\n\nIf errors occur, verify:\n1. Home Assistant is running at the configured URL\n2. The token is valid and not expired\n3. The entity_id exists in Home Assistant\n"
      },
      "plugins": [
        {
          "name": "homeassistant",
          "source": "./plugins/homeassistant",
          "description": "Home Assistant integrations for Claude Code",
          "version": "0.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add joescharf/cc-joescharf-marketplace",
            "/plugin install homeassistant@joescharf-marketplace"
          ]
        },
        {
          "name": "enforce-bun",
          "source": "./plugins/enforce-bun",
          "description": "Enforce bun usage over npm/pnpm/yarn in JavaScript projects",
          "version": "0.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add joescharf/cc-joescharf-marketplace",
            "/plugin install enforce-bun@joescharf-marketplace"
          ]
        },
        {
          "name": "enforce-uv",
          "source": "./plugins/enforce-uv",
          "description": "Enforce uv usage over pip/python in Python projects",
          "version": "0.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add joescharf/cc-joescharf-marketplace",
            "/plugin install enforce-uv@joescharf-marketplace"
          ]
        }
      ]
    }
  ]
}