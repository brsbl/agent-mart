{
  "author": {
    "id": "evgenygurin",
    "display_name": "evgenygurin",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/222521953?v=4",
    "url": "https://github.com/evgenygurin",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "claude-mem0-project-memory",
      "version": null,
      "description": "Intelligent project memory management for Claude Code using Mem0. Automatically captures and persists decisions, patterns, and context across sessions.",
      "owner_info": {
        "name": "Evgeny Gurin",
        "email": "evgeny@example.com"
      },
      "keywords": [],
      "repo_full_name": "evgenygurin/claude-mem0-project-memory",
      "repo_url": "https://github.com/evgenygurin/claude-mem0-project-memory",
      "repo_description": "Intelligent project memory management for Claude Code using Mem0. Automatically captures decisions, patterns, and context across sessions.",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-14T20:05:44Z",
        "created_at": "2025-12-14T17:36:09Z",
        "license": "NOASSERTION"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 814
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 681
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 9168
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/mem0-capture.md",
          "type": "blob",
          "size": 2539
        },
        {
          "path": "commands/mem0-reflect.md",
          "type": "blob",
          "size": 3073
        },
        {
          "path": "commands/mem0-search.md",
          "type": "blob",
          "size": 2372
        },
        {
          "path": "commands/mem0-sync.md",
          "type": "blob",
          "size": 2957
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 1806
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/recall-project-memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/recall-project-memory/SKILL.md",
          "type": "blob",
          "size": 4684
        },
        {
          "path": "skills/recall-project-memory/reference.md",
          "type": "blob",
          "size": 4016
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-mem0-project-memory\",\n  \"owner\": {\n    \"name\": \"Evgeny Gurin\",\n    \"email\": \"evgeny@example.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"claude-mem0-project-memory\",\n      \"source\": \"./\",\n      \"description\": \"Intelligent project memory management for Claude Code using Mem0. Automatically captures and persists decisions, patterns, and context across sessions.\",\n      \"version\": \"0.3.0\",\n      \"author\": {\n        \"name\": \"Evgeny Gurin\",\n        \"email\": \"evgeny@example.com\"\n      },\n      \"homepage\": \"https://github.com/evgenygurin/claude-mem0-project-memory#readme\",\n      \"repository\": \"https://github.com/evgenygurin/claude-mem0-project-memory\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"memory\", \"mem0\", \"context\", \"mcp\", \"automation\"],\n      \"category\": \"productivity\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"claude-mem0-project-memory\",\n  \"version\": \"0.3.0\",\n  \"description\": \"Intelligent project memory management for Claude Code using Mem0. Automatically captures and persists decisions, patterns, and context across sessions.\",\n  \"author\": {\n    \"name\": \"Evgeny Gurin\",\n    \"email\": \"evgeny@example.com\"\n  },\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/evgenygurin/claude-mem0-project-memory\",\n  \"keywords\": [\"memory\", \"mem0\", \"context\", \"mcp\", \"automation\"],\n  \"homepage\": \"https://github.com/evgenygurin/claude-mem0-project-memory#readme\",\n  \"commands\": \"./commands/\",\n  \"skills\": \"./skills/\",\n  \"hooks\": \"./hooks/hooks.json\",\n  \"mcpServers\": \"./.mcp.json\"\n}\n",
        "README.md": "# Claude Mem0 Project Memory Plugin\n\nüß† Intelligent long-term memory management for Claude Code using Mem0\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Claude Code](https://img.shields.io/badge/Claude_Code-Plugin-blue)](https://code.claude.com)\n[![Mem0](https://img.shields.io/badge/Mem0-Powered-purple)](https://mem0.ai)\n\n## Features\n\n- ‚úÖ **Auto-Capture**: Automatically captures decisions, patterns, and learnings during coding sessions\n- üîç **Semantic Search**: Find relevant context from past work using natural language\n- üîÑ **Smart Sync**: Keeps your CLAUDE.md updated with important patterns\n- üéØ **Project-Scoped**: Memory is organized per-project with semantic tagging\n- üß† **Agent Skill**: Claude automatically recalls relevant memories when needed\n- üõ†Ô∏è **Explicit Control**: Slash commands for manual memory management\n- ü™ù **Hook-Based**: Automated workflows via SessionStart, SessionEnd, and PostToolUse hooks\n\n## Installation\n\n### Prerequisites\n\n1. **Mem0 Account**: Sign up at [mem0.ai](https://mem0.ai) and get your API key\n2. **Node.js**: Required for `@mem0/mcp-server` \n3. **jq**: For JSON processing in hooks (`brew install jq` / `apt install jq`)\n\n### Setup\n\n#### 1. Clone this repository\n\n```bash\ngit clone https://github.com/evgenygurin/claude-mem0-project-memory.git\ncd claude-mem0-project-memory\n```\n\n#### 2. Make scripts executable\n\n```bash\nchmod +x scripts/*.sh\n```\n\n#### 3. Install in your project\n\n```bash\ncd /path/to/your/project\nmkdir -p .claude/plugins\ncp -r /path/to/claude-mem0-project-memory .claude/plugins/\n```\n\n#### 4. Configure environment\n\nAdd to your shell profile or `.env`:\n\n```bash\nexport MEM0_API_KEY=\"your-mem0-api-key\"\nexport MEM0_USER_ID=\"your-user-id\"  # optional, defaults to project name\n```\n\n#### 5. Enable in Claude Code\n\n```text\n/settings plugins\n# Enable claude-mem0-project-memory\n```\n\n## Usage\n\n### ü§ñ Automatic Mode\n\nOnce enabled, the plugin automatically:\n\n1. **Initializes** at session start\n2. **Tracks changes** as you edit code (Write/Edit tool usage)\n3. **Recalls memories** when relevant context exists (via agent skill)\n4. **Auto-saves to Mem0** at session end (SessionEnd hook)\n   - Captures session summary with change count\n   - Stores directly to Mem0 via API (no manual intervention needed)\n   - Includes metadata: project, timestamp, type, changes count\n5. **Notifies** when sync threshold is reached (5+ changes)\n\n### üìù Manual Commands\n\n#### Capture Memory\n```bash\n/mem0-capture We standardized error handling to always use Result<T, AppError> pattern\n```\n\n#### Search Memory\n```bash\n/mem0-search error handling patterns\n/mem0-search database migration decisions\n```\n\n#### Sync to CLAUDE.md\n```bash\n/mem0-sync              # Sync all memories\n/mem0-sync decisions    # Sync only decisions\n```\n\n#### Reflect on Sessions\n```bash\n/mem0-reflect           # Analyze last 5 sessions\n/mem0-reflect 10        # Analyze last 10 sessions\n```\n\n## Configuration\n\nEdit `.claude/plugins/claude-mem0-project-memory/config/memory-config.json`:\n\n```json\n{\n  \"auto_capture\": true,                  // Enable hooks (tracking, notifications)\n  \"auto_add_to_mem0\": true,              // Auto-save session summaries to Mem0\n  \"sync_to_claude_md\": true,             // Auto-sync to CLAUDE.md\n  \"auto_load_context\": false,            // Load memories at session start\n  \"reflection_threshold\": 5,             // Changes before suggesting sync\n\n  \"skill_settings\": {\n    \"auto_recall_enabled\": true,         // Enable automatic memory recall\n    \"recall_threshold\": 0.75,            // Minimum relevance for auto-recall\n    \"max_context_memories\": 5            // Max memories to load per recall\n  },\n\n  \"hook_settings\": {\n    \"session_start_init\": true,          // Initialize at session start\n    \"track_tool_usage\": true,            // Track Write/Edit events\n    \"log_mem0_calls\": false,             // Debug logging (verbose)\n    \"min_changes_for_capture\": 3,        // Minimum edits before capture\n    \"capture_session_summary\": true,     // Capture session summaries\n    \"capture_significant_changes\": false // Capture individual changes (verbose)\n  }\n}\n```\n\n### Key Settings\n\n- **`auto_add_to_mem0`**: When `true`, SessionEnd hook automatically adds session summary to Mem0 via API\n- **`capture_session_summary`**: Control whether session summaries are captured\n- **`capture_significant_changes`**: (Future) Capture individual significant code changes\n\n## Architecture\n\n```text\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ     Claude Code Agent      ‚îÇ\n‚îÇ   (with Sonnet 4.5)       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n            ‚îÇ\n            ‚îú‚îÄ‚îÄ‚îÄ Skills (automatic)\n            ‚îÇ    ‚îî‚îÄ‚îÄ recall-project-memory\n            ‚îÇ\n            ‚îú‚îÄ‚îÄ‚îÄ Commands (user-invoked)\n            ‚îÇ    ‚îú‚îÄ‚îÄ /mem0-capture\n            ‚îÇ    ‚îú‚îÄ‚îÄ /mem0-search\n            ‚îÇ    ‚îú‚îÄ‚îÄ /mem0-sync\n            ‚îÇ    ‚îî‚îÄ‚îÄ /mem0-reflect\n            ‚îÇ\n            ‚îú‚îÄ‚îÄ‚îÄ Hooks (event-driven)\n            ‚îÇ    ‚îú‚îÄ‚îÄ SessionStart\n            ‚îÇ    ‚îú‚îÄ‚îÄ SessionEnd\n            ‚îÇ    ‚îú‚îÄ‚îÄ PostToolUse (Write|Edit)\n            ‚îÇ    ‚îî‚îÄ‚îÄ Stop\n            ‚îÇ\n            ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ      MCP Server              ‚îÇ\n‚îÇ    (@mem0/mcp-server)       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n            ‚îÇ\n            ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Mem0 API (Cloud/Self)    ‚îÇ\n‚îÇ  Long-term Semantic Memory ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## How It Works\n\n### 1. üéØ Capture\n\n**Automatic**:\n- SessionEnd hook analyzes transcript\n- Extracts decisions, patterns, errors, solutions\n- Stores significant insights to Mem0\n\n**Manual**:\n- Use `/mem0-capture` to explicitly save important context\n\n### 2. üíæ Store\n\nMemories stored with:\n- **Semantic embeddings** for similarity search\n- **Project scope** (user_id = project name)\n- **Rich metadata**: type, tags, timestamp, source\n- **Memory types**: decision, pattern, constraint, learning\n\n### 3. üîç Retrieve\n\n**Automatic (Agent Skill)**:\n- Claude detects when task might benefit from memory\n- Automatically searches Mem0\n- Applies relevant patterns/constraints\n- Maintains consistency with past decisions\n\n**Manual**:\n- `/mem0-search <query>` for explicit searches\n- Returns grouped, relevance-scored results\n\n### 4. üîÑ Sync\n\nImportant patterns synced to CLAUDE.md:\n- Auto-generated section updated periodically\n- Manual guidelines preserved\n- Threshold-based notifications\n- Traceable with memory IDs\n\n## Project Memory Structure\n\nIn your `CLAUDE.md`:\n\n```markdown\n## Project Memory\n\n### Manual Guidelines\n<!-- manual -->\n[Your hand-written rules - never auto-modified]\n<!-- /manual -->\n\n### Auto-Discovered Patterns\n<!-- BEGIN AUTO-GENERATED FROM MEM0 - Last synced: 2025-12-14 -->\n\n#### Architecture Decisions\n- **[2025-12-14]** Using Result<T, E> for error handling [[mem0:abc123]]\n- **[2025-12-10]** PostgreSQL chosen for JSONB support [[mem0:def456]]\n\n#### Code Patterns  \n- **[2025-12-13]** API routes follow /api/v1/{resource} structure [[mem0:ghi789]]\n- **[2025-12-11]** Builder pattern for complex configs [[mem0:jkl012]]\n\n#### Constraints\n- **[2025-12-12]** JWT tokens: 15min expiry (security requirement) [[mem0:mno345]]\n\n#### Key Learnings\n- **[2025-12-09]** Database indexes critical for query performance [[mem0:pqr678]]\n\n<!-- END AUTO-GENERATED FROM MEM0 -->\n```\n\n## Roadmap\n\n- [ ] **v0.3**: LLM-powered transcript summarization (vs simple heuristics)\n- [ ] **v0.4**: Team memory sharing across projects\n- [ ] **v0.5**: Memory analytics dashboard\n- [ ] **v0.6**: Integration with Linear/GitHub issues\n- [ ] **v0.7**: Smart memory pruning and archival\n- [ ] **v0.8**: Conflict resolution for CLAUDE.md updates\n- [ ] **v0.9**: Memory versioning and diff visualization\n- [ ] **v1.0**: Production-ready with comprehensive tests\n\n## Contributing\n\nContributions welcome! Please:\n\n1. Fork the repo\n2. Create feature branch (`git checkout -b feature/amazing-feature`)\n3. Follow the official Claude Code plugin spec\n4. Add tests if applicable\n5. Update documentation\n6. Submit PR with clear description\n\n## License\n\nMIT License - see [LICENSE](LICENSE) file\n\n## Support\n\n- **Issues**: [GitHub Issues](https://github.com/evgenygurin/claude-mem0-project-memory/issues)\n- **Docs**: [SETUP.md](SETUP.md), [CHANGELOG.md](CHANGELOG.md)\n- **Claude Code**: [docs.code.claude.com](https://code.claude.com/docs)\n- **Mem0**: [docs.mem0.ai](https://docs.mem0.ai/)\n\n## Credits\n\nBuilt with:\n- [Claude Code](https://claude.com/code) by Anthropic\n- [Mem0](https://mem0.ai/) for long-term semantic memory\n- [Model Context Protocol (MCP)](https://modelcontextprotocol.io/)\n\n---\n\n**Made with ‚ù§Ô∏è by [@evgenygurin](https://github.com/evgenygurin)**\n",
        "commands/mem0-capture.md": "---\nname: mem0-capture\ndescription: Explicitly capture an important insight, decision, or pattern into Mem0 project memory. Use this command to permanently store key learnings, architectural decisions, patterns, or constraints that should be remembered across sessions.\nargument-hint: \"[insight, decision, or pattern to remember]\"\nallowed-tools:\n  - MCP(mem0:*)\n  - Read\n---\n\n# Mem0 Memory Capture\n\nYou are capturing important project knowledge into long-term Mem0 storage.\n\n## When to Use\n\n- User explicitly asks to remember something\n- After making an important architectural decision\n- When establishing a new pattern or best practice\n- After solving a complex problem that should be documented\n\n## Process\n\n### 1. Parse Input\n\nFrom `$ARGUMENTS`, extract:\n- **What** changed or was learned\n- **Why** it matters for this project\n- **Context**: files, components, or decisions involved\n\n### 2. Prepare Memory Entry\n\nCreate a concise summary (1-2 sentences) with metadata:\n\n```json\n{\n  \"content\": \"Clear description of the insight\",\n  \"metadata\": {\n    \"project\": \"${CLAUDE_PROJECT_DIR_NAME}\",\n    \"timestamp\": \"<ISO 8601 timestamp>\",\n    \"type\": \"decision|pattern|constraint|learning\",\n    \"tags\": [\"relevant\", \"keywords\"],\n    \"source\": \"file paths or references\"\n  }\n}\n```\n\n### 3. Store in Mem0\n\n- Use MCP `mem0` tool to add the memory\n- Search for similar existing memories first\n- If a duplicate exists, update/merge instead of creating new\n- Use the project name as the user_id for scoping\n\n### 4. Confirm\n\nRespond to the user with:\n- Confirmation that memory was stored\n- Brief summary of what was captured\n- Memory ID for reference\n- Suggestion to search related memories if relevant\n\n## Examples\n\n**User:** \n```\n/mem0-capture We standardized error handling to always use Result<T, AppError> pattern for better type safety\n```\n\n**You should:**\n1. Create memory with type=\"pattern\"\n2. Tag with: error-handling, rust, type-safety\n3. Link to relevant files if discussed\n4. Confirm: \"‚úÖ Captured error handling pattern to project memory [mem0:abc123]\"\n\n**User:**\n```\n/mem0-capture Authentication now uses JWT with 15min expiry - security team requirement\n```\n\n**You should:**\n1. Create memory with type=\"decision\"\n2. Tag with: auth, jwt, security\n3. Note the constraint (security requirement)\n4. Confirm with decision rationale\n\n## Edge Cases\n\n- If input is too vague, ask for clarification\n- If similar memory exists, ask if they want to update or create separate\n- If Mem0 connection fails, save to local .claude/memory-backup.json\n",
        "commands/mem0-reflect.md": "---\nname: mem0-reflect\ndescription: Analyze recent development sessions to identify and capture recurring patterns, important decisions, and key learnings. Best used after completing a sprint, solving complex issues, or reaching milestones.\nargument-hint: \"[number of sessions to analyze, default: 5]\"\nallowed-tools:\n  - MCP(mem0:*)\n  - Read\n---\n\n# Mem0 Reflection\n\nAnalyze recent development sessions to extract and store important patterns.\n\n## When to Use\n\n- At end of sprint/milestone to capture learnings\n- After resolving a complex issue across multiple sessions\n- Weekly review of accumulated knowledge\n- Before starting similar work to avoid repeating mistakes\n\n## Process\n\n### 1. Load Session Data\n\n- Read last N session transcripts (from `$ARGUMENTS` or default to 5)\n- Look in `${CLAUDE_TRANSCRIPT_PATH}` or session history\n- Extract:\n  - Tool usage patterns\n  - Decisions made and rationale\n  - Errors encountered and solutions\n  - Performance insights\n  - Testing approaches\n\n### 2. Identify Patterns\n\nAnalyze for:\n\n**Recurring Problems & Solutions**\n- Same error fixed multiple times ‚Üí Document solution\n- Pattern emerges across sessions ‚Üí Create best practice\n\n**Design Decisions**\n- Why certain architectures were chosen\n- Trade-offs considered\n- Rejected alternatives and why\n\n**Performance Insights**\n- Bottlenecks discovered\n- Optimization strategies that worked\n- Benchmarking results\n\n**Testing Approaches**\n- Test strategies that caught bugs\n- Edge cases discovered\n- Useful test patterns\n\n**Architectural Choices**\n- Module boundaries\n- Dependency decisions\n- Technology selections\n\n### 3. Filter for Importance\n\n**Skip:**\n- One-off fixes unlikely to recur\n- Trivial style changes\n- Session navigation/setup\n\n**Capture:**\n- Reusable knowledge\n- \"This should be in CLAUDE.md\" moments\n- Hard-won insights\n- Team-relevant patterns\n\n### 4. Store in Mem0\n\nFor each significant pattern:\n- Create memory entry with appropriate type\n- Link related memories if applicable\n- Tag with relevant keywords\n- Include source session IDs\n\n### 5. Suggest CLAUDE.md Updates\n\n- If significant patterns found (‚â•3), offer to run `/mem0-sync`\n- Show preview of what would be added:\n\n```\nFound 5 significant patterns:\n- Decision: Switched to async error handling (session_7)\n- Pattern: Use builder pattern for complex configs (sessions 5-7)\n- Learning: Database indexes critical for query X (session_6)\n\nRun /mem0-sync to add these to CLAUDE.md?\n```\n\n## Examples\n\n**User:**\n```\n/mem0-reflect\n```\n\n**You should:**\n1. Analyze last 5 sessions\n2. Extract 3-10 key patterns\n3. Store in Mem0\n4. Suggest sync if valuable patterns found\n\n**User:**\n```\n/mem0-reflect 10\n```\n\n**You should:**\n1. Analyze last 10 sessions (broader retrospective)\n2. Look for longer-term trends\n3. Focus on strategic patterns\n\n## Edge Cases\n\n- No sessions available: Inform user gracefully\n- Sessions too old (>30 days): Ask if they want to proceed\n- Too many patterns (>20): Prioritize by impact, ask user to review\n- No significant patterns: Report \"No new patterns found, sessions were routine\"\n",
        "commands/mem0-search.md": "---\nname: mem0-search\ndescription: Search project memory for relevant context, decisions, patterns, or past solutions using semantic search. Helps you find what was done before and why, avoiding repeated mistakes and maintaining consistency.\nargument-hint: \"[search query - e.g., 'error handling patterns', 'database decisions']\"\nallowed-tools:\n  - MCP(mem0:*)\n---\n\n# Mem0 Memory Search\n\nSearch long-term project memory for relevant information using semantic search.\n\n## When to Use\n\n- User asks \"how did we handle X?\"\n- Before making a decision, check for past decisions\n- When stuck on a problem, find similar past solutions\n- To verify current approach aligns with established patterns\n\n## Process\n\n### 1. Parse Query\n\nFrom `$ARGUMENTS`, identify:\n- **Technical terms**: component names, technologies, patterns\n- **Problem domain**: what area/feature is this about?\n- **Time context**: recent vs. historical (if mentioned)\n\n### 2. Query Mem0\n\n- Use semantic search via MCP `mem0` tool\n- Filter by `project: ${CLAUDE_PROJECT_DIR_NAME}`\n- Retrieve top 5-10 most relevant memories\n- Set relevance threshold (default: 0.7)\n\n### 3. Present Results\n\nGroup results by type:\n\n#### üìù Decisions\n- [Date] Description [mem0:id]\n\n#### üîß Patterns\n- [Date] Description [mem0:id]\n\n#### ‚ö†Ô∏è Constraints\n- [Date] Description [mem0:id]\n\n#### üí° Learnings\n- [Date] Description [mem0:id]\n\nFor each result:\n- Show relevance score if available\n- Include key metadata (tags, source files)\n- Format clearly for readability\n\n### 4. Actionable Output\n\n- **Suggest applying** relevant patterns to current task\n- **Highlight conflicts** with current approach\n- **Offer to update** if memories seem outdated\n- **Provide links** to source files/PRs if available\n\n## Examples\n\n**User:**\n```\n/mem0-search error handling patterns\n```\n\n**You should:**\n1. Search for memories tagged with \"error-handling\", \"patterns\"\n2. Display grouped results\n3. Suggest: \"Based on past decisions, consider using Result<T, E> pattern\"\n\n**User:**\n```\n/mem0-search How did we decide on the database?\n```\n\n**You should:**\n1. Search for \"database\" + \"decision\" type\n2. Show decision with rationale\n3. Include any constraints or trade-offs noted\n\n## Edge Cases\n\n- No results: Suggest broader search terms\n- Too many results: Offer to filter by type or date\n- Mem0 unavailable: Gracefully fall back to local search\n",
        "commands/mem0-sync.md": "---\nname: mem0-sync\ndescription: Synchronize key patterns, decisions, and constraints from Mem0 back into the project's CLAUDE.md file. This keeps your project documentation up-to-date with the most important learnings and decisions.\nargument-hint: \"[optional: decisions|patterns|constraints|learnings|all]\"\nallowed-tools:\n  - MCP(mem0:*)\n  - Read\n  - Edit\n  - Write\n---\n\n# Mem0 to CLAUDE.md Sync\n\nSynchronize key patterns and decisions from Mem0 into the project's CLAUDE.md file.\n\n## When to Use\n\n- After accumulating several important memories\n- When onboarding new team members (ensure CLAUDE.md is current)\n- Periodically (weekly/monthly) to keep documentation fresh\n- After major architectural changes\n\n## Process\n\n### 1. Read Current CLAUDE.md\n\n- Locate `CLAUDE.md` in `${CLAUDE_PROJECT_DIR}`\n- Find or create \"## Project Memory\" section\n- Preserve content inside `<!-- manual -->` tags (user-written)\n- Identify auto-generated section boundaries\n\n### 2. Query Mem0\n\n- Fetch high-priority memories for `${CLAUDE_PROJECT_DIR_NAME}`\n- Filter by types: `decisions`, `patterns`, `constraints`\n- Sort by importance (number of references) and recency\n- Limit to top 20-30 most relevant\n\n### 3. Generate Updates\n\nFormat as Markdown:\n\n```markdown\n## Project Memory\n\n### Manual Guidelines\n<!-- manual -->\n[Existing user-written content - NEVER MODIFY]\n<!-- /manual -->\n\n### Auto-Discovered Patterns\n<!-- BEGIN AUTO-GENERATED FROM MEM0 - Last synced: YYYY-MM-DD -->\n\n#### Architecture Decisions\n- **[YYYY-MM-DD]** Decision description with rationale [[mem0:id]](link-if-available)\n\n#### Code Patterns\n- **[YYYY-MM-DD]** Pattern description and when to use [[mem0:id]](link)\n\n#### Constraints\n- **[YYYY-MM-DD]** Constraint with reason [[mem0:id]](link)\n\n#### Key Learnings\n- **[YYYY-MM-DD]** What we learned and impact [[mem0:id]](link)\n\n<!-- END AUTO-GENERATED FROM MEM0 -->\n```\n\n**Rules:**\n- Deduplicate with existing content\n- Keep descriptions concise (1-2 lines)\n- Include memory ID for traceability\n- Group by category\n- Most recent first within each category\n\n### 4. Write Back\n\n- Replace only the auto-generated section\n- Preserve manual guidelines\n- Update \"Last synced\" timestamp\n- Maintain proper Markdown formatting\n\n### 5. Report\n\nConfirm to user:\n- Number of memories synced\n- Categories updated\n- Summary of most important additions\n- Link to updated CLAUDE.md\n\n## Examples\n\n**User:**\n```\n/mem0-sync\n```\n\n**You should:**\n1. Sync all memory types\n2. Update CLAUDE.md\n3. Report: \"‚úÖ Synced 15 memories to CLAUDE.md (8 decisions, 5 patterns, 2 constraints)\"\n\n**User:**\n```\n/mem0-sync decisions\n```\n\n**You should:**\n1. Sync only decisions\n2. Update only that section\n3. Leave other sections unchanged\n\n## Edge Cases\n\n- CLAUDE.md doesn't exist: Create it with template\n- No auto-generated section: Add it after manual section\n- Mem0 unavailable: Inform user, suggest trying later\n- Manual section has no markers: Add markers to wrap existing content\n",
        "hooks/hooks.json": "{\n  \"description\": \"Automated memory capture and sync for Mem0-backed project memory\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"type\": \"command\",\n        \"description\": \"Initialize Mem0 plugin environment for the session\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/init-session.sh\",\n        \"args\": [\"${CLAUDE_PROJECT_DIR}\"],\n        \"timeout\": 10,\n        \"enabled\": true\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"type\": \"command\",\n        \"description\": \"Capture session summary and key insights into Mem0\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/summarize-session.sh\",\n        \"args\": [\"${CLAUDE_PROJECT_DIR}\"],\n        \"timeout\": 60,\n        \"enabled\": true\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"description\": \"Track significant code changes for memory sync\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/track-change.sh\",\n            \"args\": [\"${CLAUDE_PROJECT_DIR}\"],\n            \"timeout\": 5,\n            \"throttle\": 60,\n            \"enabled\": true\n          }\n        ]\n      },\n      {\n        \"matcher\": \"mcp__mem0__.*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"description\": \"Log Mem0 interactions for debugging\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/log-mem0-call.sh\",\n            \"timeout\": 3,\n            \"enabled\": false\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"type\": \"command\",\n        \"description\": \"Quick capture of important context on manual stop\",\n        \"command\": \"${CLAUDE_PLUGIN_ROOT}/scripts/summarize-session.sh\",\n        \"args\": [\"${CLAUDE_PROJECT_DIR}\", \"--quick\"],\n        \"timeout\": 30,\n        \"enabled\": true\n      }\n    ]\n  }\n}\n",
        "skills/recall-project-memory/SKILL.md": "---\nname: recall-project-memory\ndescription: Automatically search and retrieve relevant project memory from Mem0 when working on tasks that might benefit from past decisions, patterns, or learnings. Use this skill when starting new features, fixing bugs, or making architectural decisions to leverage historical context.\nallowed-tools:\n  - MCP(mem0:*)\n---\n\n# Recall Project Memory Skill\n\n## Purpose\n\nThis skill enables you to automatically search project memory for relevant context before making decisions or implementing features. It helps maintain consistency with past decisions and avoid repeating mistakes.\n\n## When to Invoke\n\nAutomatically consider using this skill when:\n\n1. **Starting new features**: Check if similar features exist or related patterns were established\n2. **Making architectural decisions**: See if similar decisions were made and what rationale was used\n3. **Debugging**: Look for past solutions to similar problems\n4. **Refactoring**: Understand why current structure exists before changing\n5. **User asks about history**: \"How did we handle X?\", \"Why did we choose Y?\"\n\n## How to Use\n\n### Step 1: Identify Context\n\nFrom the current task or conversation, extract:\n- Technical domain (auth, database, API, frontend, etc.)\n- Specific components or files being discussed\n- Type of work (decision, implementation, debugging, refactoring)\n- Key concepts or patterns mentioned\n\n### Step 2: Formulate Search Query\n\nCreate semantic search query combining:\n- Domain keywords\n- Problem/feature description\n- Technology stack terms\n\nExample queries:\n- \"authentication JWT token refresh\"\n- \"database migration strategy postgres\"\n- \"error handling async functions\"\n- \"API rate limiting implementation\"\n\n### Step 3: Query Mem0\n\nUse MCP mem0 tools to:\n```\nsearch_memories(\n  query: \"<semantic query>\",\n  user_id: \"${CLAUDE_PROJECT_DIR_NAME}\",\n  limit: 5-10\n)\n```\n\nFilter by:\n- Project scope (always use project name as user_id)\n- Relevance threshold (>0.7)\n- Memory types (decisions, patterns, constraints)\n\n### Step 4: Apply Retrieved Context\n\n**If relevant memories found:**\n- Briefly mention: \"Found relevant past decision about X\"\n- Apply patterns/constraints to current task\n- Maintain consistency with established approaches\n- If conflicting with past, explain why deviation is needed\n\n**If no relevant memories:**\n- Proceed normally\n- Consider capturing new decision if significant\n\n**If memories are outdated:**\n- Note the change in context\n- Suggest updating the memory\n\n## Examples\n\n### Example 1: Feature Implementation\n\n**User:** \"Add user authentication to the API\"\n\n**You should:**\n1. Search: \"authentication API security user\"\n2. Find memory: \"Decision [2024-10]: Use JWT with 15min expiry, refresh tokens\"\n3. Apply: \"I'll implement authentication using JWT tokens as previously decided...\"\n4. Reference: \"This aligns with our established auth pattern [mem0:xyz]\"\n\n### Example 2: Debugging\n\n**User:** \"The async function is throwing errors randomly\"\n\n**You should:**\n1. Search: \"error handling async functions\"\n2. Find memory: \"Pattern: Always use Result<T, E> for async operations\"\n3. Check: Review current code against pattern\n4. Fix: \"I see the issue - we should wrap this in Result<> per our pattern...\"\n\n### Example 3: No Relevant Memory\n\n**User:** \"Add caching layer\"\n\n**You should:**\n1. Search: \"caching cache layer\"\n2. No results\n3. Proceed: \"I don't see any past caching decisions. Let's design this...\"\n4. Later: Suggest capturing the decision\n\n## Output Format\n\nWhen memory is relevant:\n\n```markdown\nüß† **Project Memory**: Found relevant context from <date>\n- <brief summary of memory>\n- <how it applies to current task>\n```\n\nKeep it concise - don't overwhelm the user. The goal is to:\n- Surface relevant context seamlessly\n- Maintain consistency\n- Avoid redundant explanations\n\n## Best Practices\n\n1. **Don't over-retrieve**: Only search when genuinely relevant\n2. **Be specific**: Use precise search terms related to current task\n3. **Stay concise**: Mention memory briefly, focus on applying it\n4. **Update proactively**: If memory is outdated, suggest updating it\n5. **Trust the search**: Mem0 uses semantic similarity, so approximate terms work\n\n## Error Handling\n\n- **Mem0 unavailable**: Proceed without memory, log gracefully\n- **Search timeout**: Fall back to local knowledge, continue task\n- **No API key**: Skip memory retrieval, work normally\n- **Ambiguous results**: Ask user for clarification on which approach to follow\n\n## Progressive Loading\n\nIf you need more details about a memory:\n1. Initial search returns summary\n2. If needed, retrieve full memory by ID\n3. If memory references files, read those files for complete context\n",
        "skills/recall-project-memory/reference.md": "# Recall Project Memory - Reference Documentation\n\n## Memory Types\n\n### Decision\nArchitectural or technical decisions made by the team.\n- **When to capture**: After evaluating options and choosing approach\n- **Content**: What was decided, why, alternatives considered\n- **Tags**: decision, architecture, design\n\n### Pattern\nCode patterns, best practices, or conventions established.\n- **When to capture**: After standardizing on an approach\n- **Content**: Description of pattern, when to use, examples\n- **Tags**: pattern, best-practice, convention\n\n### Constraint\nLimitations, requirements, or rules that must be followed.\n- **When to capture**: When external requirement is imposed\n- **Content**: What constraint, why it exists, impact\n- **Tags**: constraint, requirement, limitation\n\n### Learning\nLessons learned from mistakes, bugs, or experiments.\n- **When to capture**: After resolving difficult issue\n- **Content**: Problem, solution, what we learned\n- **Tags**: learning, lesson, retrospective\n\n## Search Strategy\n\n### Semantic Search Tips\n\n1. **Use noun phrases**: \"authentication method\" not \"how to authenticate\"\n2. **Include technology**: \"postgres migration\" not just \"migration\"\n3. **Combine concepts**: \"async error handling\" better than \"errors\" or \"async\" alone\n4. **Avoid questions**: \"database choice\" not \"why did we choose this database?\"\n\n### Search Scope\n\n```javascript\n// Always scope to project\nuser_id: process.env.CLAUDE_PROJECT_DIR_NAME\n\n// Adjust limit based on task complexity\nlimit: 5-10  // Most tasks\nlimit: 15-20 // Complex decisions or refactoring\n\n// Filter by type when appropriate\nfilters: {\n  type: [\"decision\", \"pattern\"]  // Skip learnings for implementation\n}\n```\n\n### Relevance Threshold\n\n- **0.8+**: Highly relevant, definitely use\n- **0.7-0.8**: Relevant, consider applying\n- **0.6-0.7**: Possibly related, mention if useful\n- **<0.6**: Not relevant, ignore\n\n## Integration Points\n\n### With Commands\n\n- **Before `/mem0-capture`**: Search to avoid duplicates\n- **After `/mem0-search`**: User explicitly wants comprehensive results\n- **During `/mem0-sync`**: Prioritize memories for CLAUDE.md\n\n### With Hooks\n\n- **SessionStart**: Consider loading high-priority memories into context\n- **PostToolUse (Write/Edit)**: Optionally check if change conflicts with patterns\n\n### With Other Skills\n\nThis skill complements:\n- Code review skills (check against established patterns)\n- Testing skills (apply known test patterns)\n- Documentation skills (reference past decisions)\n\n## Performance Considerations\n\n- **Cache results**: Within same task, reuse search results\n- **Lazy loading**: Only retrieve full memory content if needed\n- **Throttle searches**: Don't search on every message\n- **Batch queries**: Combine related searches when possible\n\n## Privacy & Security\n\n- Memories are scoped per project (user_id = project name)\n- No cross-project memory leakage\n- Sensitive information should be tagged and filtered\n- Consider adding `.mem0ignore` for sensitive patterns\n\n## Troubleshooting\n\n### Skill Not Triggering\n\n**Symptoms**: Memory not being recalled when it should\n\n**Causes**:\n- Description in SKILL.md not specific enough\n- User query doesn't match trigger words\n- Skill disabled in plugin config\n\n**Solution**:\n- Enhance description with more use case examples\n- Test with explicit phrases\n- Check `config/memory-config.json`\n\n### Too Many False Positives\n\n**Symptoms**: Retrieving irrelevant memories\n\n**Causes**:\n- Search query too broad\n- Relevance threshold too low\n- Memory tags not specific enough\n\n**Solution**:\n- Narrow search terms\n- Increase threshold to 0.75+\n- Improve memory tagging during capture\n\n### Performance Issues\n\n**Symptoms**: Slow responses when skill activates\n\n**Causes**:\n- Too many memories in project\n- Network latency to Mem0 API\n- Large memory content\n\n**Solution**:\n- Reduce search limit\n- Implement caching\n- Archive old memories\n- Use summary-only retrieval\n\n## Version History\n\n- **v0.1.0** (2025-12-14): Initial skill implementation\n"
      },
      "plugins": [
        {
          "name": "claude-mem0-project-memory",
          "source": "./",
          "description": "Intelligent project memory management for Claude Code using Mem0. Automatically captures and persists decisions, patterns, and context across sessions.",
          "version": "0.3.0",
          "author": {
            "name": "Evgeny Gurin",
            "email": "evgeny@example.com"
          },
          "homepage": "https://github.com/evgenygurin/claude-mem0-project-memory#readme",
          "repository": "https://github.com/evgenygurin/claude-mem0-project-memory",
          "license": "MIT",
          "keywords": [
            "memory",
            "mem0",
            "context",
            "mcp",
            "automation"
          ],
          "category": "productivity",
          "categories": [
            "automation",
            "context",
            "mcp",
            "mem0",
            "memory",
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add evgenygurin/claude-mem0-project-memory",
            "/plugin install claude-mem0-project-memory@claude-mem0-project-memory"
          ]
        }
      ]
    }
  ]
}