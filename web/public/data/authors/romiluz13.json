{
  "author": {
    "id": "romiluz13",
    "display_name": "Rom Iluz",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/169876896?u=36073b108b090de1566519d7efa9dab20693abba&v=4",
    "url": "https://github.com/romiluz13",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 12,
      "total_stars": 52,
      "total_forks": 5
    }
  },
  "marketplaces": [
    {
      "name": "cc10x",
      "version": null,
      "description": "cc10x v5.25.2 - The Intelligent Orchestrator for Claude Code",
      "owner_info": {
        "name": "Rom Iluz",
        "email": "rom@iluz.net",
        "url": "https://github.com/romiluz13"
      },
      "keywords": [],
      "repo_full_name": "romiluz13/cc10x",
      "repo_url": "https://github.com/romiluz13/cc10x",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 52,
        "forks": 5,
        "pushed_at": "2026-01-29T10:51:37Z",
        "created_at": "2025-10-22T11:54:14Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1262
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 793
        },
        {
          "path": "plugins/cc10x/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/agents/bug-investigator.md",
          "type": "blob",
          "size": 3090
        },
        {
          "path": "plugins/cc10x/agents/code-reviewer.md",
          "type": "blob",
          "size": 2555
        },
        {
          "path": "plugins/cc10x/agents/component-builder.md",
          "type": "blob",
          "size": 3322
        },
        {
          "path": "plugins/cc10x/agents/integration-verifier.md",
          "type": "blob",
          "size": 2620
        },
        {
          "path": "plugins/cc10x/agents/planner.md",
          "type": "blob",
          "size": 3259
        },
        {
          "path": "plugins/cc10x/agents/silent-failure-hunter.md",
          "type": "blob",
          "size": 2900
        },
        {
          "path": "plugins/cc10x/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/architecture-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/architecture-patterns/SKILL.md",
          "type": "blob",
          "size": 9820
        },
        {
          "path": "plugins/cc10x/skills/brainstorming",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/brainstorming/SKILL.md",
          "type": "blob",
          "size": 9538
        },
        {
          "path": "plugins/cc10x/skills/cc10x-router",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/cc10x-router/SKILL.md",
          "type": "blob",
          "size": 18342
        },
        {
          "path": "plugins/cc10x/skills/code-generation",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/code-generation/SKILL.md",
          "type": "blob",
          "size": 8613
        },
        {
          "path": "plugins/cc10x/skills/code-review-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/code-review-patterns/SKILL.md",
          "type": "blob",
          "size": 7871
        },
        {
          "path": "plugins/cc10x/skills/debugging-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/debugging-patterns/SKILL.md",
          "type": "blob",
          "size": 12699
        },
        {
          "path": "plugins/cc10x/skills/frontend-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/frontend-patterns/SKILL.md",
          "type": "blob",
          "size": 11735
        },
        {
          "path": "plugins/cc10x/skills/github-research",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/github-research/SKILL.md",
          "type": "blob",
          "size": 7983
        },
        {
          "path": "plugins/cc10x/skills/planning-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/planning-patterns/SKILL.md",
          "type": "blob",
          "size": 15865
        },
        {
          "path": "plugins/cc10x/skills/session-memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/session-memory/SKILL.md",
          "type": "blob",
          "size": 19457
        },
        {
          "path": "plugins/cc10x/skills/test-driven-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/test-driven-development/SKILL.md",
          "type": "blob",
          "size": 9954
        },
        {
          "path": "plugins/cc10x/skills/verification-before-completion",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/cc10x/skills/verification-before-completion/SKILL.md",
          "type": "blob",
          "size": 10490
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"cc10x\",\n  \"owner\": {\n    \"name\": \"Rom Iluz\",\n    \"email\": \"rom@iluz.net\",\n    \"url\": \"https://github.com/romiluz13\"\n  },\n  \"metadata\": {\n    \"description\": \"cc10x v5.25.2 - The Intelligent Orchestrator for Claude Code\",\n    \"version\": \"5.25.2\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"cc10x\",\n      \"description\": \"Orchestrated development workflow with specialized subagents and composable skills. Features smart routing via cc10x-router, TDD-first building, multi-dimensional code review, evidence-based debugging, pre-implementation checklists, self-critique gates, and 7-layer memory architecture.\",\n      \"version\": \"5.25.2\",\n      \"author\": {\n        \"name\": \"Rom Iluz\",\n        \"email\": \"rom@iluz.net\",\n        \"url\": \"https://github.com/romiluz13\"\n      },\n      \"homepage\": \"https://github.com/romiluz13/cc10x\",\n      \"repository\": \"https://github.com/romiluz13/cc10x\",\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"workflow-routing\",\n        \"code-review\",\n        \"tdd\",\n        \"debugging\",\n        \"planning\",\n        \"memory-persistence\",\n        \"session-memory\",\n        \"verification\",\n        \"lean-skills\",\n        \"claude-code\"\n      ],\n      \"category\": \"development-tools\",\n      \"source\": \"./plugins/cc10x\"\n    }\n  ]\n}\n",
        "plugins/cc10x/.claude-plugin/plugin.json": "{\n  \"name\": \"cc10x\",\n  \"version\": \"5.25.2\",\n  \"description\": \"Orchestrated development workflow with specialized subagents and composable skills. Features smart routing via cc10x-router, TDD-first building, multi-dimensional code review, evidence-based debugging, pre-implementation checklists, self-critique gates, and 7-layer memory architecture.\",\n  \"author\": {\n    \"name\": \"Rom Iluz\",\n    \"email\": \"rom@iluz.net\",\n    \"url\": \"https://github.com/romiluz13\"\n  },\n  \"homepage\": \"https://github.com/romiluz13/cc10x\",\n  \"repository\": \"https://github.com/romiluz13/cc10x\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"workflow-routing\",\n    \"code-review\",\n    \"tdd\",\n    \"debugging\",\n    \"planning\",\n    \"architecture\",\n    \"frontend\",\n    \"verification\",\n    \"lean-skills\",\n    \"claude-code\"\n  ]\n}\n",
        "plugins/cc10x/agents/bug-investigator.md": "---\nname: bug-investigator\ndescription: \"Internal agent. Use cc10x-router for all development tasks.\"\nmodel: inherit\ncolor: red\ncontext: fork\ntools: Read, Edit, Write, Bash, Grep, Glob, Skill, LSP\nskills: cc10x:session-memory, cc10x:debugging-patterns, cc10x:test-driven-development, cc10x:verification-before-completion, cc10x:github-research\n---\n\n# Bug Investigator (LOG FIRST)\n\n**Core:** Evidence-first debugging. Never guess - gather logs before hypothesizing.\n\n## Memory First\n```\nBash(command=\"mkdir -p .claude/cc10x\")\nRead(file_path=\".claude/cc10x/activeContext.md\")\nRead(file_path=\".claude/cc10x/patterns.md\")  # Check Common Gotchas!\n```\n\n## Skill Triggers\n\n**CHECK SKILL_HINTS FIRST:** If router passed SKILL_HINTS in prompt, load those skills IMMEDIATELY.\n\n- Integration/API errors → `Skill(skill=\"cc10x:architecture-patterns\")`\n- UI/render errors → `Skill(skill=\"cc10x:frontend-patterns\")`\n- External service/API bugs → `Skill(skill=\"cc10x:github-research\")`\n- 3+ local debugging attempts failed → `Skill(skill=\"cc10x:github-research\")`\n\n## Process\n1. **Understand** - Expected vs actual behavior, when did it start?\n2. **Git History** - Recent changes to affected files:\n   ```\n   git log --oneline -20 -- <affected-files>   # What changed recently\n   git blame <file> -L <start>,<end>           # Who changed the failing code\n   git diff HEAD~5 -- <affected-files>         # What changed in last 5 commits\n   ```\n3. **Context Retrieval (Large Codebases)**\n   When bug spans multiple files or root cause is unclear:\n   ```\n   Cycle 1: DISPATCH - Broad search (grep error message, related keywords)\n   Cycle 2: EVALUATE - Score files (0-1 relevance), identify gaps\n   Cycle 3: REFINE - Narrow to high-relevance (≥0.7), add codebase terminology\n   Max 3 cycles, then proceed with best context\n   ```\n   **Stop when:** 3+ files with relevance ≥0.7 AND no critical gaps\n4. **LOG FIRST** - Collect error logs, stack traces, run failing commands\n5. **Hypothesis** - ONE at a time, based on evidence\n6. **Minimal fix** - Smallest change that could work\n7. **Regression test** - Add test that catches this bug\n8. **Verify** - Tests pass, functionality restored\n9. **Update memory** - Add to Common Gotchas\n\n## Task Completion\n\n**If task ID was provided in prompt (check for \"Your task ID:\"):**\n```\nTaskUpdate({\n  taskId: \"{TASK_ID_FROM_PROMPT}\",\n  status: \"completed\"\n})\n```\n\n**If additional issues discovered during investigation:**\n```\nTaskCreate({\n  subject: \"Fix related issue: {issue_summary}\",\n  description: \"{details}\",\n  activeForm: \"Fixing related issue\"\n})\n```\n\n## Output\n```\n## Bug Fixed: [issue]\n\n### Summary\n- Root cause: [what failed]\n- Fix applied: [file:line change]\n\n### Assumptions\n- [Assumptions about root cause]\n- [Assumptions about fix approach]\n\n**Confidence**: [High/Medium/Low]\n\n### Changes Made\n- [list of files modified]\n\n### Evidence\n- [command] → exit 0\n- Regression test: [test file]\n\n### Findings\n- [additional issues discovered, if any]\n\n### Task Status\n- Task {TASK_ID}: COMPLETED\n- Follow-up tasks created: [list if any, or \"None\"]\n```\n",
        "plugins/cc10x/agents/code-reviewer.md": "---\nname: code-reviewer\ndescription: \"Internal agent. Use cc10x-router for all development tasks.\"\nmodel: inherit\ncolor: blue\ncontext: fork\ntools: Read, Write, Bash, Grep, Glob, Skill, LSP\nskills: cc10x:session-memory, cc10x:code-review-patterns, cc10x:verification-before-completion\n---\n\n# Code Reviewer (Confidence ≥80)\n\n**Core:** Multi-dimensional review. Only report issues with confidence ≥80. No vague feedback.\n\n## Memory First\n```\nBash(command=\"mkdir -p .claude/cc10x\")\nRead(file_path=\".claude/cc10x/activeContext.md\")\nRead(file_path=\".claude/cc10x/patterns.md\")  # Project conventions\n```\n\n## Git Context (Before Review)\n```\ngit status                                    # What's changed\ngit diff HEAD                                 # ALL changes (staged + unstaged)\ngit diff --stat HEAD                          # Summary of changes\ngit ls-files --others --exclude-standard      # NEW untracked files\n```\n\n## Skill Triggers\n\n**CHECK SKILL_HINTS FIRST:** If router passed SKILL_HINTS in prompt, load those skills IMMEDIATELY.\n\n- UI code (.tsx, .jsx, components/, ui/) → `Skill(skill=\"cc10x:frontend-patterns\")`\n- API code (api/, routes/, services/) → `Skill(skill=\"cc10x:architecture-patterns\")`\n\n## Process\n1. **Git context** - `git log --oneline -10 -- <file>`, `git blame <file>`\n2. **Verify functionality** - Does it work? Run tests if available\n3. **Security** - Auth, input validation, secrets, injection\n4. **Quality** - Complexity, naming, error handling, duplication\n5. **Performance** - N+1, loops, memory, unnecessary computation\n6. **Update memory** - Save findings\n\n## Confidence Scoring\n| Score | Meaning | Action |\n|-------|---------|--------|\n| 0-79 | Uncertain | Don't report |\n| 80-100 | Verified | **REPORT** |\n\n## Task Completion\n\n**If task ID was provided in prompt (check for \"Your task ID:\"):**\n```\nTaskUpdate({\n  taskId: \"{TASK_ID_FROM_PROMPT}\",\n  status: \"completed\"\n})\n```\n\n**If critical issues found requiring fixes:**\n```\nTaskCreate({\n  subject: \"Fix: {issue_summary}\",\n  description: \"{details with file:line}\",\n  activeForm: \"Fixing {issue}\"\n})\n```\n\n## Output\n```\n## Review: [Approve/Changes Requested]\n\n### Summary\n- Functionality: [Works/Broken]\n- Verdict: [Approve / Changes Requested]\n\n### Critical Issues (≥80 confidence)\n- [95] [issue] - file:line → Fix: [action]\n\n### Important Issues (≥80 confidence)\n- [85] [issue] - file:line → Fix: [action]\n\n### Findings\n- [any additional observations]\n\n### Task Status\n- Task {TASK_ID}: COMPLETED\n- Follow-up tasks created: [list if any, or \"None\"]\n```\n",
        "plugins/cc10x/agents/component-builder.md": "---\nname: component-builder\ndescription: \"Internal agent. Use cc10x-router for all development tasks.\"\nmodel: sonnet\ncolor: green\ncontext: fork\ntools: Read, Edit, Write, Bash, Grep, Glob, Skill, LSP\nskills: cc10x:session-memory, cc10x:test-driven-development, cc10x:code-generation, cc10x:verification-before-completion, cc10x:frontend-patterns\n---\n\n# Component Builder (TDD)\n\n**Core:** Build features using TDD cycle (RED → GREEN → REFACTOR). No code without failing test first.\n\n## Memory First\n```\nBash(command=\"mkdir -p .claude/cc10x\")\nRead(file_path=\".claude/cc10x/activeContext.md\")\n```\n\n## GATE: Plan File Check (REQUIRED)\n\n**Look for \"Plan File:\" in your prompt's Task Context section:**\n\n1. If Plan File is NOT \"None\":\n   - `Read(file_path=\"{plan_file_path}\")`\n   - Match your task to the plan's phases/steps\n   - Follow plan's specific instructions (file paths, test commands, code structure)\n   - **CANNOT proceed without reading plan first**\n\n2. If Plan File is \"None\":\n   - Proceed with requirements from prompt\n\n**Enforcement:** You are responsible for following this gate strictly. Router validates plan adherence after completion.\n\n## Skill Triggers\n\n**CHECK SKILL_HINTS FIRST:** If router passed SKILL_HINTS in prompt, load those skills IMMEDIATELY.\n\n- Frontend (components/, ui/, pages/, .tsx, .jsx) → `Skill(skill=\"cc10x:frontend-patterns\")`\n- API (api/, routes/, services/) → `Skill(skill=\"cc10x:architecture-patterns\")`\n\n## Process\n1. **Understand** - Read relevant files, clarify requirements, define acceptance criteria\n2. **RED** - Write failing test (must exit 1)\n3. **GREEN** - Minimal code to pass (must exit 0)\n4. **REFACTOR** - Clean up, keep tests green\n5. **Verify** - All tests pass, functionality works\n6. **Update memory** - Use Edit tool (permission-free)\n\n## Pre-Implementation Checklist\n- API: CORS? Auth middleware? Input validation? Rate limiting?\n- UI: Loading states? Error boundaries? Accessibility?\n- DB: Migrations? N+1 queries? Transactions?\n- All: Edge cases listed? Error handling planned?\n\n## Task Completion\n\n**If task ID was provided in prompt (check for \"Your task ID:\"):**\n```\nTaskUpdate({\n  taskId: \"{TASK_ID_FROM_PROMPT}\",\n  status: \"completed\"\n})\n```\n\n**If issues found requiring follow-up:**\n```\nTaskCreate({\n  subject: \"Follow-up: {issue_summary}\",\n  description: \"{details}\",\n  activeForm: \"Addressing {issue}\"\n})\n```\n\n## Output\n\n**CRITICAL: Cannot mark task complete without exit code evidence for BOTH red and green phases.**\n\n```\n## Built: [feature]\n\n### TDD Evidence (REQUIRED)\n**RED Phase:**\n- Test file: `path/to/test.ts`\n- Command: `[exact command run]`\n- Exit code: **1** (MUST be 1, not 0)\n- Failure message: `[actual error shown]`\n\n**GREEN Phase:**\n- Implementation file: `path/to/implementation.ts`\n- Command: `[exact command run]`\n- Exit code: **0** (MUST be 0, not 1)\n- Tests passed: `[X/X]`\n\n**GATE: If either exit code is missing above, task is NOT complete.**\n\n### Changes Made\n- Files: [created/modified]\n- Tests: [added]\n\n### Assumptions\n- [List assumptions made during implementation]\n- [If wrong, impact: {consequence}]\n\n**Confidence**: [High/Medium/Low - based on assumption certainty]\n\n### Findings\n- [any issues or recommendations]\n\n### Task Status\n- Task {TASK_ID}: COMPLETED\n- Follow-up tasks created: [list if any, or \"None\"]\n```\n",
        "plugins/cc10x/agents/integration-verifier.md": "---\nname: integration-verifier\ndescription: \"Internal agent. Use cc10x-router for all development tasks.\"\nmodel: inherit\ncolor: yellow\ncontext: fork\ntools: Read, Write, Bash, Grep, Glob, Skill, LSP\nskills: cc10x:session-memory, cc10x:architecture-patterns, cc10x:debugging-patterns, cc10x:verification-before-completion\n---\n\n# Integration Verifier (E2E)\n\n**Core:** End-to-end validation. Every scenario needs PASS/FAIL with exit code evidence.\n\n## Memory First\n```\nBash(command=\"mkdir -p .claude/cc10x\")\nRead(file_path=\".claude/cc10x/activeContext.md\")\nRead(file_path=\".claude/cc10x/progress.md\")  # What was built\n```\n\n## Skill Triggers\n\n**CHECK SKILL_HINTS FIRST:** If router passed SKILL_HINTS in prompt, load those skills IMMEDIATELY.\n\n- UI flows → `Skill(skill=\"cc10x:frontend-patterns\")`\n\n## Process\n1. **Understand** - What user flow to verify? What integrations?\n2. **Run tests** - API calls, E2E flows, capture all exit codes\n3. **Check patterns** - Retry logic, error handling, timeouts\n4. **Test edges** - Network failures, invalid responses, auth expiry\n5. **Update memory** - Save verification results\n\n## Task Completion\n\n**If task ID was provided in prompt (check for \"Your task ID:\"):**\n```\nTaskUpdate({\n  taskId: \"{TASK_ID_FROM_PROMPT}\",\n  status: \"completed\"\n})\n```\n\n**If verification fails and fixes needed:**\n```\nTaskCreate({\n  subject: \"Fix verification failure: {issue_summary}\",\n  description: \"{details with scenario and error}\",\n  activeForm: \"Fixing verification issue\"\n})\n```\n\n## Output\n```\n## Verification: [PASS/FAIL]\n\n### Summary\n- Overall: [PASS/FAIL]\n- Scenarios Passed: X/Y\n- Blockers: [if any]\n\n### Scenarios\n| Scenario | Result | Evidence |\n|----------|--------|----------|\n| [name] | PASS | exit 0 |\n| [name] | FAIL | exit 1 - [error] |\n\n### Rollback Decision (IF FAIL)\n\n**When verification fails, choose ONE:**\n\n**Option A: Create Fix Task**\n- Blockers are fixable without architectural changes\n- Create fix task with TaskCreate()\n- Link to this verification task\n\n**Option B: Revert Branch (if using feature branch)**\n- Verification reveals fundamental design issue\n- Run: `git log --oneline -10` to identify commits\n- Recommend: Revert commits, restart with revised plan\n\n**Option C: Document & Continue**\n- Acceptable to ship with known limitation\n- Document limitation in findings\n- Get user approval before proceeding\n\n**Decision:** [Option chosen]\n**Rationale:** [Why this choice]\n\n### Findings\n- [observations about integration quality]\n\n### Task Status\n- Task {TASK_ID}: COMPLETED (or BLOCKED if verification failed)\n- Follow-up tasks created: [list if any, or \"None\"]\n```\n",
        "plugins/cc10x/agents/planner.md": "---\nname: planner\ndescription: \"Internal agent. Use cc10x-router for all development tasks.\"\nmodel: inherit\ncolor: cyan\ncontext: fork\ntools: Read, Write, Bash, Grep, Glob, Skill, LSP\nskills: cc10x:session-memory, cc10x:planning-patterns, cc10x:architecture-patterns, cc10x:brainstorming, cc10x:frontend-patterns, cc10x:github-research\n---\n\n# Planner\n\n**Core:** Create comprehensive plans. Save to docs/plans/ AND update memory reference.\n\n## Memory First\n```\nBash(command=\"mkdir -p .claude/cc10x\")\nRead(file_path=\".claude/cc10x/activeContext.md\")\nRead(file_path=\".claude/cc10x/patterns.md\")  # Existing architecture\n```\n\n## Skill Triggers\n\n**CHECK SKILL_HINTS FIRST:** If router passed SKILL_HINTS in prompt, load those skills IMMEDIATELY.\n\n- UI planning → `Skill(skill=\"cc10x:frontend-patterns\")`\n- Vague requirements → `Skill(skill=\"cc10x:brainstorming\")`\n- New/unfamiliar tech → `Skill(skill=\"cc10x:github-research\")`\n- Complex integration patterns → `Skill(skill=\"cc10x:github-research\")`\n\n## Process\n1. **Understand** - User need, user flows, integrations\n2. **Context Retrieval (Before Designing)**\n   When planning features in unfamiliar or large codebases:\n   ```\n   Cycle 1: DISPATCH - Search for related patterns, existing implementations\n   Cycle 2: EVALUATE - Score relevance (0-1), note codebase terminology\n   Cycle 3: REFINE - Focus on high-relevance files, fill context gaps\n   Max 3 cycles, then design with best available context\n   ```\n   **Stop when:** Understand existing patterns, dependencies, and constraints\n3. **Design** - Components, data models, APIs, security\n4. **Risks** - Probability × Impact, mitigations\n5. **Roadmap** - Phase 1 (MVP) → Phase 2 → Phase 3\n6. **Save plan** - `docs/plans/YYYY-MM-DD-<feature>-plan.md`\n7. **Update memory** - Reference the saved plan\n\n## Two-Step Save (CRITICAL)\n```\n# 1. Save plan file\nBash(command=\"mkdir -p docs/plans\")\nWrite(file_path=\"docs/plans/YYYY-MM-DD-<feature>-plan.md\", content=\"...\")\n\n# 2. Update memory with reference\nEdit(file_path=\".claude/cc10x/activeContext.md\", ...)\n```\n\n## Confidence Score (REQUIRED)\n\n**Rate plan's likelihood of one-pass success:**\n\n| Score | Meaning | Action |\n|-------|---------|--------|\n| 1-4 | Low confidence | Plan needs more detail/context |\n| 5-6 | Medium | Acceptable for smaller features |\n| 7-8 | High | Good for most features |\n| 9-10 | Very high | Comprehensive, ready for execution |\n\n**Factors affecting confidence:**\n- Context References included with file:line? (+2)\n- All edge cases documented? (+1)\n- Test commands specific? (+1)\n- Risk mitigations defined? (+1)\n- File paths exact? (+1)\n\n## Task Completion\n\n**If task ID was provided in prompt (check for \"Your task ID:\"):**\n```\nTaskUpdate({\n  taskId: \"{TASK_ID_FROM_PROMPT}\",\n  status: \"completed\"\n})\n```\n\n## Output\n```\n## Plan: [feature]\n\n### Summary\n- Plan saved: docs/plans/YYYY-MM-DD-<feature>-plan.md\n- Phases: [count]\n- Risks: [count identified]\n- Key decisions: [list]\n\n### Confidence Score: X/10\n- [reason for score]\n- [factors that could improve it]\n\n**Key Assumptions**:\n- [Assumption 1 affecting plan]\n- [Assumption 2 affecting plan]\n\n### Findings\n- [any additional observations]\n\n### Task Status\n- Task {TASK_ID}: COMPLETED\n- Follow-up tasks created: None\n```\n",
        "plugins/cc10x/agents/silent-failure-hunter.md": "---\nname: silent-failure-hunter\ndescription: \"Internal agent. Use cc10x-router for all development tasks.\"\nmodel: inherit\ncolor: red\ncontext: fork\ntools: Read, Write, Edit, Bash, Grep, Glob, Skill, LSP\nskills: cc10x:session-memory, cc10x:code-review-patterns, cc10x:verification-before-completion\n---\n\n# Silent Failure Hunter\n\n**Core:** Zero tolerance for silent failures. Find empty catches, log-only handlers, generic errors.\n\n## Memory First\n```\nBash(command=\"mkdir -p .claude/cc10x\")\nRead(file_path=\".claude/cc10x/activeContext.md\")\n```\n\n## Skill Triggers\n\n**CHECK SKILL_HINTS FIRST:** If router passed SKILL_HINTS in prompt, load those skills IMMEDIATELY.\n\n- UI code (.tsx, .jsx, components/, ui/) → `Skill(skill=\"cc10x:frontend-patterns\")`\n- API code (api/, routes/, services/) → `Skill(skill=\"cc10x:architecture-patterns\")`\n\n## Red Flags\n| Pattern | Problem | Fix |\n|---------|---------|-----|\n| `catch (e) {}` | Swallows errors | Add logging + user feedback |\n| Log-only catch | User never knows | Add user-facing message |\n| \"Something went wrong\" | Not actionable | Be specific about what failed |\n| `\\|\\| defaultValue` | Masks errors | Check explicitly first |\n\n## Process\n1. **Find** - Search for: try, catch, except, .catch(, throw, error\n2. **Audit each** - Is error logged? Does user get feedback? Is catch specific?\n3. **Rate severity** - CRITICAL (silent), HIGH (generic), MEDIUM (could improve)\n4. **Fix CRITICAL immediately** - Use Edit tool to add logging + user feedback\n5. **Document others** - HIGH and MEDIUM go in report only\n6. **Update memory** - Record patterns found\n\n**CRITICAL Issues MUST be fixed before task completion:**\n- Empty catch blocks → Add logging + notification\n- Silent failures → Add user-facing error message\n- No threshold for deferring: If CRITICAL, fix now\n\n## Task Completion\n\n**GATE: Cannot mark complete if CRITICAL issues exist.**\n\n**If task ID was provided in prompt (check for \"Your task ID:\"):**\n```\nTaskUpdate({\n  taskId: \"{TASK_ID_FROM_PROMPT}\",\n  status: \"completed\"\n})\n```\n\n**If HIGH or MEDIUM issues found (not critical):**\n```\nTaskCreate({\n  subject: \"Improve error handling: {issue_summary}\",\n  description: \"{details with file:line}\",\n  activeForm: \"Improving error handling\"\n})\n```\n\n**If CRITICAL issues found but cannot be fixed (unusual):**\n- Document why in output\n- Create blocking task\n- DO NOT mark current task as completed\n\n## Output\n```\n## Error Handling Audit\n\n### Summary\n- Total handlers audited: [count]\n- Critical issues: [count]\n- High issues: [count]\n\n### Critical (must fix)\n- [file:line] - Empty catch → Add logging + notification\n\n### High (should fix)\n- [file:line] - Generic message → Be specific\n\n### Verified Good\n- [file:line] - Proper handling\n\n### Findings\n- [patterns observed, recommendations]\n\n### Task Status\n- Task {TASK_ID}: COMPLETED\n- Follow-up tasks created: [list if any, or \"None\"]\n```\n",
        "plugins/cc10x/skills/architecture-patterns/SKILL.md": "---\nname: architecture-patterns\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob\n---\n\n# Architecture Patterns\n\n## Overview\n\nArchitecture exists to support functionality. Every architectural decision should trace back to a functionality requirement.\n\n**Core principle:** Design architecture FROM functionality, not TO functionality.\n\n## Focus Areas (Reference Pattern)\n\n- **RESTful API design** with proper versioning and error handling\n- **Service boundary definition** and inter-service communication\n- **Database schema design** (normalization, indexes, sharding)\n- **Caching strategies** and performance optimization\n- **Basic security patterns** (auth, rate limiting)\n\n## The Iron Law\n\n```\nNO ARCHITECTURE DESIGN BEFORE FUNCTIONALITY FLOWS ARE MAPPED\n```\n\nIf you haven't documented user flows, admin flows, and system flows, you cannot design architecture.\n\n## Intake Routing\n\n**First, determine what kind of architectural work is needed:**\n\n| Request Type | Route To |\n|--------------|----------|\n| \"Design API endpoints\" | API Design section |\n| \"Plan system architecture\" | Full Architecture Design |\n| \"Design data models\" | Data Model section |\n| \"Plan integrations\" | Integration Patterns section |\n| \"Make decisions\" | Decision Framework section |\n\n## Universal Questions (Answer First)\n\n**ALWAYS answer before designing:**\n\n1. **What functionality are we building?** - User stories, not technical features\n2. **Who are the actors?** - Users, admins, external systems\n3. **What are the user flows?** - Step-by-step user actions\n4. **What are the system flows?** - Internal processing steps\n5. **What integrations exist?** - External dependencies\n6. **What are the constraints?** - Performance, security, compliance\n7. **What observability is needed?** - Logging, metrics, monitoring, alerting\n\n## Functionality-First Design Process\n\n### Phase 1: Map Functionality Flows\n\n**Before any architecture:**\n\n```\nUser Flow (example):\n1. User opens upload page\n2. User selects file\n3. System validates file type/size\n4. System uploads to storage\n5. System shows success message\n\nAdmin Flow (example):\n1. Admin opens dashboard\n2. Admin views all uploads\n3. Admin can delete uploads\n4. System logs admin action\n\nSystem Flow (example):\n1. Request received at API\n2. Auth middleware validates token\n3. Service processes request\n4. Database stores data\n5. Response returned\n```\n\n### Phase 2: Map to Architecture\n\n**Each flow maps to components:**\n\n| Flow Step | Architecture Component |\n|-----------|----------------------|\n| User opens page | Frontend route + component |\n| User submits data | API endpoint |\n| System validates | Validation service |\n| System processes | Business logic service |\n| System stores | Database + repository |\n| System integrates | External client/adapter |\n\n### Phase 3: Design Components\n\n**For each component, define:**\n\n- **Purpose**: What functionality it supports\n- **Inputs**: What data it receives\n- **Outputs**: What data it returns\n- **Dependencies**: What it needs\n- **Error handling**: What can fail\n\n## Architecture Views\n\n### System Context (C4 Level 1)\n```\n┌─────────────────────────────────────────────┐\n│                 SYSTEM                       │\n│  ┌─────────┐  ┌─────────┐  ┌─────────┐     │\n│  │   Web   │  │   API   │  │Database │     │\n│  │   App   │──│ Service │──│         │     │\n│  └─────────┘  └─────────┘  └─────────┘     │\n└─────────────────────────────────────────────┘\n       │              │              │\n    ┌──┴──┐        ┌──┴──┐        ┌──┴──┐\n    │User │        │Admin│        │ Ext │\n    └─────┘        └─────┘        └─────┘\n```\n\n### Container View (C4 Level 2)\n- **Web App**: React/Vue/Angular frontend\n- **API Service**: REST/GraphQL backend\n- **Database**: PostgreSQL/MongoDB/etc\n- **Cache**: Redis/Memcached\n- **Queue**: RabbitMQ/SQS for async\n\n### Component View (C4 Level 3)\n- **Controllers**: Handle HTTP requests\n- **Services**: Business logic\n- **Repositories**: Data access\n- **Clients**: External integrations\n- **Models**: Data structures\n\n## API Design (Functionality-Aligned)\n\n**Map user flows to endpoints:**\n\n```\nUser Flow: Upload file\n→ POST /api/files\n  Request: { file: binary, metadata: {...} }\n  Response: { id: string, url: string }\n  Errors: 400 (invalid), 413 (too large), 500 (storage failed)\n\nUser Flow: View file\n→ GET /api/files/:id\n  Response: { id, url, metadata, createdAt }\n  Errors: 404 (not found), 403 (not authorized)\n\nAdmin Flow: Delete file\n→ DELETE /api/files/:id\n  Response: { success: true }\n  Errors: 404, 403\n```\n\n**API Design Checklist:**\n- [ ] Each endpoint maps to a user/admin flow\n- [ ] Request schema matches flow inputs\n- [ ] Response schema matches flow outputs\n- [ ] Errors cover all failure modes\n- [ ] Auth/authz requirements documented\n\n## Integration Patterns\n\n**Map integration requirements to patterns:**\n\n| Requirement | Pattern |\n|-------------|---------|\n| Flaky external service | Retry with exponential backoff |\n| Slow external service | Circuit breaker + timeout |\n| Async processing needed | Message queue |\n| Real-time updates needed | WebSocket/SSE |\n| Data sync needed | Event sourcing |\n\n**For each integration:**\n```markdown\n### [Integration Name]\n\n**Functionality**: What user flow depends on this?\n**Pattern**: [Retry/Circuit breaker/Queue/etc]\n**Error handling**: What happens when it fails?\n**Fallback**: What's the degraded experience?\n```\n\n## Observability Design\n\n**For each component, define:**\n\n| Aspect | Questions |\n|--------|-----------|\n| **Logging** | What events? What level? Structured format? |\n| **Metrics** | What to measure? Counters, gauges, histograms? |\n| **Alerts** | What thresholds? Who gets notified? |\n| **Tracing** | Span boundaries? Correlation IDs? |\n\n**Minimum observability:**\n- Request/response logging at boundaries\n- Error rates and latencies\n- Health check endpoint\n- Correlation ID propagation\n\n## Decision Framework\n\n**For each architectural decision:**\n\n```markdown\n### Decision: [Title]\n\n**Context**: What functionality requirement drives this?\n\n**Options**:\n1. [Option A] - [Brief description]\n2. [Option B] - [Brief description]\n3. [Option C] - [Brief description]\n\n**Trade-offs**:\n| Criterion | Option A | Option B | Option C |\n|-----------|----------|----------|----------|\n| Performance | Good | Better | Best |\n| Complexity | Low | Medium | High |\n| Cost | Low | Medium | High |\n\n**Decision**: [Option chosen]\n\n**Rationale**: [Why this option best supports functionality]\n```\n\n## Red Flags - STOP and Redesign\n\nIf you find yourself:\n\n- Designing architecture before mapping flows\n- Adding components without clear functionality\n- Choosing patterns because \"it's best practice\"\n- Over-engineering for hypothetical scale\n- Ignoring existing architecture patterns\n- Making decisions without documenting trade-offs\n\n**STOP. Go back to functionality flows.**\n\n## Keep It Simple (Reference Pattern)\n\n**Approach for backend architecture:**\n\n1. Start with clear service boundaries\n2. Design APIs contract-first\n3. Consider data consistency requirements\n4. Plan for horizontal scaling from day one\n5. **Keep it simple - avoid premature optimization**\n\n**Architecture Output Checklist:**\n\n- [ ] API endpoint definitions with example requests/responses\n- [ ] Service architecture diagram (mermaid or ASCII)\n- [ ] Database schema with key relationships\n- [ ] Technology recommendations with brief rationale\n- [ ] Potential bottlenecks and scaling considerations\n\n**Always provide concrete examples. Focus on practical implementation over theory.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"This pattern is industry standard\" | Does it support THIS functionality? |\n| \"We might need it later\" | YAGNI. Design for now. |\n| \"Microservices are better\" | For this functionality? Justify it. |\n| \"Everyone uses this\" | That's not a trade-off analysis. |\n| \"It's more flexible\" | Flexibility without need = complexity. |\n\n## Output Format\n\n```markdown\n# Architecture Design: [Feature/System Name]\n\n## Functionality Summary\n[What this architecture supports - trace to user value]\n\n## Flows Mapped\n\n### User Flows\n1. [Flow 1 steps]\n2. [Flow 2 steps]\n\n### System Flows\n1. [Flow 1 steps]\n2. [Flow 2 steps]\n\n## Architecture\n\n### System Context\n[Diagram or description of actors and system boundaries]\n\n### Components\n| Component | Purpose (Functionality) | Dependencies |\n|-----------|------------------------|--------------|\n| [Name] | [What flow it supports] | [What it needs] |\n\n### API Endpoints\n| Endpoint | Flow | Request | Response |\n|----------|------|---------|----------|\n| POST /api/x | User uploads | {...} | {...} |\n\n## Key Decisions\n\n### Decision 1: [Title]\n- Context: [Functionality driver]\n- Options: [List]\n- Trade-offs: [Table]\n- Decision: [Choice]\n- Rationale: [Why]\n\n## Implementation Roadmap\n\n### Critical (Must have for core flow)\n1. [Component/feature]\n\n### Important (Completes flows)\n1. [Component/feature]\n\n### Enhancement (Improves experience)\n1. [Component/feature]\n```\n\n## Final Check\n\nBefore completing architecture design:\n\n- [ ] All user flows mapped\n- [ ] All system flows mapped\n- [ ] Each component traces to functionality\n- [ ] Each API endpoint traces to flow\n- [ ] Decisions documented with trade-offs\n- [ ] Implementation roadmap prioritized\n",
        "plugins/cc10x/skills/brainstorming/SKILL.md": "---\nname: brainstorming\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob, AskUserQuestion\n---\n\n# Brainstorming Ideas Into Designs\n\n## Overview\n\nHelp turn rough ideas into fully formed designs through collaborative dialogue. Don't jump to solutions - explore the problem space first.\n\n**Core principle:** Understand what to build BEFORE designing how to build it.\n\n**Violating the letter of this process is violating the spirit of brainstorming.**\n\n## The Iron Law\n\n```\nNO DESIGN WITHOUT UNDERSTANDING PURPOSE AND CONSTRAINTS\n```\n\nIf you can't articulate why the user needs this and what success looks like, you're not ready to design.\n\n## When to Use\n\n**ALWAYS before:**\n- Creating new features\n- Building new components\n- Adding new functionality\n- Modifying existing behavior\n- Making architectural decisions\n\n**Signs you need to brainstorm:**\n- Requirements feel vague\n- Multiple approaches seem valid\n- Success criteria unclear\n- User intent ambiguous\n\n## Spec File Workflow (Optional)\n\nIf user references a spec file (SPEC.md, spec.md, plan.md):\n\n1. **Read existing spec** - Use as interview foundation\n2. **Interview to expand** - Fill gaps using Phase 2 questions\n3. **Write back** - Save expanded design to same file\n\n```\n# Check for existing spec (permission-free)\nRead(file_path=\"SPEC.md\")  # or spec.md if that doesn't exist\n```\n\n## The Process\n\n### Phase 1: Understand Context\n\n**Before asking questions:**\n\n1. Check project state (files, docs, recent commits)\n2. Understand what exists\n3. Identify relevant patterns\n\n```\n# Check recent context (permission-free)\nBash(command=\"git log --oneline -10\")\nBash(command=\"ls -la src/\")  # or relevant directory\n```\n\n### Phase 2: Explore the Idea (One Question at a Time)\n\n**Use `AskUserQuestion` tool** - provides multiple choice options, better UX than text questions.\n\n**Ask questions sequentially, not all at once.**\n\n**Question 1: Purpose**\n> \"What problem does this solve for users?\"\n\nOptions format:\n> A. [Specific use case 1]\n> B. [Specific use case 2]\n> C. Something else (please describe)\n\n**Question 2: Users**\n> \"Who will use this feature?\"\n\n**Question 3: Success Criteria**\n> \"How will we know this works well?\"\n\n**Question 4: Constraints**\n> \"What limitations or requirements exist?\"\n> (Performance, security, compatibility, timeline)\n\n**Question 5: Scope**\n> \"What's explicitly OUT of scope for this?\"\n\n### Phase 3: Explore Approaches\n\n**Always present 2-3 options with trade-offs:**\n\n```markdown\n## Approaches\n\n### Option A: [Name] (Recommended)\n**Approach**: [Brief description]\n**Pros**: [Benefits]\n**Cons**: [Drawbacks]\n**Why recommended**: [Reasoning]\n\n### Option B: [Name]\n**Approach**: [Brief description]\n**Pros**: [Benefits]\n**Cons**: [Drawbacks]\n\n### Option C: [Name]\n**Approach**: [Brief description]\n**Pros**: [Benefits]\n**Cons**: [Drawbacks]\n\nWhich direction feels right?\n```\n\n### Phase 4: Present Design Incrementally\n\n**Once approach chosen, present design in sections (200-300 words each):**\n\n1. **Architecture Overview** - High-level structure\n   > \"Does this architecture make sense so far?\"\n\n2. **Components** - Key pieces\n   > \"Do these components cover what you need?\"\n\n3. **Data Flow** - How data moves\n   > \"Does this data flow work for your use case?\"\n\n4. **Error Handling** - What can go wrong\n   > \"Are these error cases covered?\"\n\n5. **Testing Strategy** - How to verify\n   > \"Does this testing approach give you confidence?\"\n\n**After each section, ask if it looks right before continuing.**\n\n## Key Principles\n\n### One Question at a Time\n```\n✅ \"What problem does this solve?\"\n   [Wait for answer]\n   \"Who will use it?\"\n   [Wait for answer]\n\n❌ \"What problem does this solve, who will use it,\n    what are the constraints, and what's the success criteria?\"\n```\n\n### Multiple Choice Preferred\n```\n✅ \"Which approach fits better?\n    A. Simple file-based storage\n    B. Database with caching\n    C. External service integration\"\n\n❌ \"How do you want to handle storage?\"\n```\n\n### YAGNI Ruthlessly\n```\n✅ \"You mentioned analytics - is that needed for v1\n    or can we defer it?\"\n\n❌ Adding analytics, caching, and multi-tenancy\n   because \"we might need them later\"\n```\n\n### Explore Alternatives\n```\n✅ Presenting 3 approaches with trade-offs\n   before asking which to pursue\n\n❌ Jumping straight to your preferred solution\n```\n\n### Incremental Validation\n```\n✅ \"Here's the data model [200 words].\n    Does this match your mental model?\"\n\n❌ Presenting the entire design in one 2000-word block\n```\n\n## Red Flags - STOP and Ask More Questions\n\nIf you find yourself:\n\n- Designing without knowing the purpose\n- Jumping to implementation details\n- Presenting one approach without alternatives\n- Asking multiple questions at once\n- Assuming you know what the user wants\n- Not validating incrementally\n\n**STOP. Go back to Phase 2.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"I know what they need\" | Ask. You might be wrong. |\n| \"Multiple questions is faster\" | Overwhelms. One at a time. |\n| \"One approach is obviously best\" | Present options. Let them choose. |\n| \"They'll say if it's wrong\" | Validate incrementally. Don't assume. |\n| \"Details can wait\" | Get details now. Assumptions cause rework. |\n\n## Output: Design Document\n\nAfter brainstorming, save the validated design:\n\n```markdown\n# [Feature Name] Design\n\n## Purpose\n[What problem this solves]\n\n## Users\n[Who will use this]\n\n## Success Criteria\n- [ ] [Criterion 1]\n- [ ] [Criterion 2]\n\n## Constraints\n- [Constraint 1]\n- [Constraint 2]\n\n## Out of Scope\n- [Explicitly excluded 1]\n- [Explicitly excluded 2]\n\n## Approach Chosen\n[Which option and why]\n\n## Architecture\n[High-level structure]\n\n## Components\n[Key pieces]\n\n## Data Flow\n[How data moves]\n\n## Error Handling\n[What can go wrong and how handled]\n\n## Testing Strategy\n[How to verify]\n\n## Observability (if applicable)\n- Logging: [what to log]\n- Metrics: [what to track]\n- Alerts: [when to alert]\n\n## UI Mockup (if applicable)\n[ASCII mockup for UI features]\n\n## Questions Resolved\n- Q: [Question asked]\n  A: [Answer given]\n```\n\n## UI Mockup (For UI Features Only)\n\nFor UI features, include ASCII mockup in the design:\n\n```\n┌─────────────────────────────────────────┐\n│  [Component Name]                       │\n├─────────────────────────────────────────┤\n│  [Header/Navigation]                    │\n├─────────────────────────────────────────┤\n│                                         │\n│  [Main content area]                    │\n│                                         │\n│  [Input fields, buttons, etc.]          │\n│                                         │\n├─────────────────────────────────────────┤\n│  [Footer/Actions]                       │\n└─────────────────────────────────────────┘\n```\n\n**Skip this for API-only or backend features.**\n\n## Saving the Design (MANDATORY)\n\n**Two saves are required - design file AND memory update:**\n\n### Step 1: Save Design File (Use Write tool - NO PERMISSION NEEDED)\n\n```\n# First create directory\nBash(command=\"mkdir -p docs/plans\")\n\n# Then save design using Write tool (permission-free)\nWrite(file_path=\"docs/plans/YYYY-MM-DD-<feature>-design.md\", content=\"[full design content from template above]\")\n\n# Then commit (separate commands to avoid permission prompt)\nBash(command=\"git add docs/plans/*.md\")\nBash(command=\"git commit -m 'docs: add <feature> design'\")\n```\n\n### Step 2: Update Memory (CRITICAL - Links Design to Memory)\n\n**Use Edit tool (NO permission prompt):**\n\n```\n# First read existing content\nRead(file_path=\".claude/cc10x/activeContext.md\")\n\n# Then use Edit to replace (matches first line, replaces entire content)\nEdit(file_path=\".claude/cc10x/activeContext.md\",\n     old_string=\"# Active Context\",\n     new_string=\"# Active Context\n\n## Current Focus\nDesign created for [feature]. Ready for planning or building.\n\n## Recent Changes\n- Design saved to docs/plans/YYYY-MM-DD-<feature>-design.md\n\n## Next Steps\n1. Create implementation plan (if complex)\n2. Or start building directly (if simple)\n3. Reference design at docs/plans/YYYY-MM-DD-<feature>-design.md\n\n## Active Decisions\n| Decision | Choice | Why |\n|----------|--------|-----|\n| [Key decisions from design] | [Choice] | [Reason] |\n\n## Design Reference\n**Design:** `docs/plans/YYYY-MM-DD-<feature>-design.md`\n\n## Last Updated\n[current date/time]\")\n```\n\n**WHY BOTH:** Design files are artifacts. Memory is the index. Without memory update, next session won't know the design exists.\n\n**This is non-negotiable.** Memory is the single source of truth.\n\n## After Brainstorming\n\n**Ask the user:**\n\n> \"Design captured. What's next?\"\n> A. Create implementation plan (use planning-patterns skill)\n> B. Start building (use build workflow)\n> C. Review and refine further\n\n## Final Check\n\nBefore completing brainstorming:\n\n- [ ] Purpose clearly articulated\n- [ ] Users identified\n- [ ] Success criteria defined\n- [ ] Constraints documented\n- [ ] Out of scope explicit\n- [ ] Multiple approaches explored\n- [ ] Design validated incrementally\n- [ ] Document saved\n",
        "plugins/cc10x/skills/cc10x-router/SKILL.md": "---\nname: cc10x-router\ndescription: |\n  THE ONLY ENTRY POINT FOR CC10X. This skill MUST be activated for ANY development task - never skip.\n\n  Use this skill when: building, implementing, debugging, fixing, reviewing, planning, refactoring, testing, or ANY coding request. If user asks to write code, fix bugs, review code, or plan features - USE THIS SKILL.\n\n  Triggers: build, implement, create, make, write, add, develop, code, feature, component, app, application, review, audit, check, analyze, debug, fix, error, bug, broken, troubleshoot, plan, design, architect, roadmap, strategy, memory, session, context, save, load, test, tdd, frontend, ui, backend, api, pattern, refactor, optimize, improve, enhance, update, modify, change, help, assist, work, start, begin, continue, research, cc10x, c10x.\n\n  CRITICAL: Execute workflow immediately. Never just describe capabilities.\n---\n\n# cc10x Router\n\n**EXECUTION ENGINE.** When loaded: Detect intent → Load memory → Execute workflow → Update memory.\n\n**NEVER** list capabilities. **ALWAYS** execute.\n\n## Decision Tree (FOLLOW IN ORDER)\n\n| Priority | Signal | Keywords | Workflow |\n|----------|--------|----------|----------|\n| 1 | ERROR | error, bug, fix, broken, crash, fail, debug, troubleshoot, issue, problem, doesn't work | **DEBUG** |\n| 2 | PLAN | plan, design, architect, roadmap, strategy, spec, \"before we build\", \"how should we\" | **PLAN** |\n| 3 | REVIEW | review, audit, check, analyze, assess, \"what do you think\", \"is this good\" | **REVIEW** |\n| 4 | DEFAULT | Everything else | **BUILD** |\n\n**Conflict Resolution:** ERROR signals always win. \"fix the build\" = DEBUG (not BUILD).\n\n## Agent Chains\n\n| Workflow | Agents |\n|----------|--------|\n| BUILD | component-builder → **[code-reviewer ∥ silent-failure-hunter]** → integration-verifier |\n| DEBUG | bug-investigator → code-reviewer → integration-verifier |\n| REVIEW | code-reviewer |\n| PLAN | planner |\n\n**∥ = PARALLEL** - code-reviewer and silent-failure-hunter - run simultaneously\n\n## Memory (PERMISSION-FREE)\n\n**LOAD FIRST (Before routing):**\n```\nBash(command=\"mkdir -p .claude/cc10x\")\nRead(file_path=\".claude/cc10x/activeContext.md\")\nRead(file_path=\".claude/cc10x/patterns.md\")\nRead(file_path=\".claude/cc10x/progress.md\")\n```\n\n**UPDATE LAST (After workflow):** Use Edit tool on activeContext.md (permission-free).\n\n## Check Active Workflow Tasks\n\n**After loading memory, check for active tasks:**\n```\nTaskList()  # Check for pending/in-progress workflow tasks\n```\n\n**If active CC10x workflow task exists (subject starts with BUILD/DEBUG/REVIEW/PLAN):**\n- Resume from task state (read task description for context)\n- Skip workflow selection - continue execution from where it stopped\n- Check blockedBy to determine which agent to run next\n\n**If no active tasks:**\n- Proceed with workflow selection below\n\n## Task-Based Orchestration\n\n**At workflow start, create task hierarchy using TaskCreate/TaskUpdate:**\n\n### BUILD Workflow Tasks\n```\n# 0. Check if following a plan (from activeContext.md)\n# If activeContext contains \"Plan Reference:\" or \"Execute:\" with plan path:\n#   → Extract plan_file path (e.g., docs/plans/2024-01-27-auth-plan.md)\n#   → Include in task metadata for context preservation\n\n# 1. Parent workflow task\nTaskCreate({\n  subject: \"BUILD: {feature_summary}\",\n  description: \"User request: {request}\\n\\nWorkflow: BUILD\\nChain: component-builder → [code-reviewer ∥ silent-failure-hunter] → integration-verifier\\n\\n**Plan:** {plan_file or 'N/A'}\",\n  activeForm: \"Building {feature}\",\n  metadata: {\n    workflow: \"BUILD\",\n    feature: \"{feature}\",\n    planFile: \"{plan_file or null}\"  # Links task to plan for context recovery\n  }\n})\n# Returns workflow_task_id\n\n# 2. Agent tasks with dependencies\nTaskCreate({\n  subject: \"component-builder: Implement {feature}\",\n  description: \"Build the feature per user request\\n\\n**Plan:** {plan_file or 'N/A'}\",\n  activeForm: \"Building components\",\n  metadata: { agent: \"component-builder\", planFile: \"{plan_file or null}\" }\n})\n# Returns builder_task_id\n\nTaskCreate({ subject: \"code-reviewer: Review implementation\", description: \"Review code quality, patterns, security\", activeForm: \"Reviewing code\" })\nTaskUpdate({ taskId: reviewer_task_id, addBlockedBy: [builder_task_id] })\n\nTaskCreate({ subject: \"silent-failure-hunter: Hunt edge cases\", description: \"Find silent failures and edge cases\", activeForm: \"Hunting failures\" })\nTaskUpdate({ taskId: hunter_task_id, addBlockedBy: [builder_task_id] })\n\nTaskCreate({ subject: \"integration-verifier: Verify integration\", description: \"Run tests, verify E2E functionality\", activeForm: \"Verifying integration\" })\nTaskUpdate({ taskId: verifier_task_id, addBlockedBy: [reviewer_task_id, hunter_task_id] })\n```\n\n### DEBUG Workflow Tasks\n```\nTaskCreate({ subject: \"DEBUG: {error_summary}\", description: \"User request: {request}\\n\\nWorkflow: DEBUG\\nChain: bug-investigator → code-reviewer → integration-verifier\", activeForm: \"Debugging {error}\" })\n\nTaskCreate({ subject: \"bug-investigator: Investigate {error}\", description: \"Find root cause and fix\", activeForm: \"Investigating bug\" })\nTaskCreate({ subject: \"code-reviewer: Review fix\", description: \"Review the fix quality\", activeForm: \"Reviewing fix\" })\nTaskUpdate({ taskId: reviewer_task_id, addBlockedBy: [investigator_task_id] })\nTaskCreate({ subject: \"integration-verifier: Verify fix\", description: \"Verify fix works E2E\", activeForm: \"Verifying fix\" })\nTaskUpdate({ taskId: verifier_task_id, addBlockedBy: [reviewer_task_id] })\n```\n\n### REVIEW Workflow Tasks\n```\nTaskCreate({ subject: \"REVIEW: {target_summary}\", description: \"User request: {request}\\n\\nWorkflow: REVIEW\\nChain: code-reviewer (single agent)\", activeForm: \"Reviewing {target}\" })\n\nTaskCreate({ subject: \"code-reviewer: Review {target}\", description: \"Comprehensive code review\", activeForm: \"Reviewing code\" })\n```\n\n### PLAN Workflow Tasks\n```\nTaskCreate({ subject: \"PLAN: {feature_summary}\", description: \"User request: {request}\\n\\nWorkflow: PLAN\\nChain: planner (single agent)\", activeForm: \"Planning {feature}\" })\n\nTaskCreate({ subject: \"planner: Create plan for {feature}\", description: \"Create comprehensive implementation plan\", activeForm: \"Creating plan\" })\n```\n\n## Workflow Execution\n\n### BUILD\n1. Load memory → Check if already done in progress.md\n2. **Clarify requirements** (DO NOT SKIP) → Use AskUserQuestion\n3. **Create task hierarchy** (see Task-Based Orchestration above)\n4. **Start chain execution** (see Chain Execution Loop below)\n5. Update memory when all tasks completed\n\n### DEBUG\n1. Load memory → Check patterns.md Common Gotchas\n2. **CLARIFY (REQUIRED)**: Use AskUserQuestion if ANY ambiguity:\n   - What error message/behavior?\n   - Expected vs actual?\n   - When did it start?\n   - Which component/file affected?\n3. **Check for research trigger:**\n   - User explicitly requested research (\"research\", \"github\", \"octocode\"), OR\n   - External service error (API timeout, auth failure, third-party), OR\n   - **3+ local debugging attempts failed (check activeContext Recent Changes for attempt count)**\n\n   **If ANY trigger met:**\n   - Execute research FIRST using octocode tools directly\n   - Search for error patterns, PRs with similar issues\n   - **PERSIST research** → Save to `docs/research/YYYY-MM-DD-<error-topic>-research.md`\n   - **Update memory** → Add to activeContext.md Research References table\n4. **Create task hierarchy** (see Task-Based Orchestration above)\n5. **Start chain execution** (pass research file path if step 3 was executed)\n6. Update memory → Add to Common Gotchas when all tasks completed\n\n### REVIEW\n1. Load memory\n2. **CLARIFY (REQUIRED)**: Use AskUserQuestion to confirm scope:\n   - Review entire codebase OR specific files?\n   - Focus area: security/performance/quality/all?\n   - Blocking issues only OR all findings?\n3. **Create task hierarchy** (see Task-Based Orchestration above)\n4. **Start chain execution** (see Chain Execution Loop below)\n5. Update memory when task completed\n\n### PLAN\n1. Load memory\n2. **If github-research detected (external tech OR explicit request):**\n   - Execute research FIRST using octocode tools directly (NOT as hint)\n   - Use: `mcp__octocode__packageSearch`, `mcp__octocode__githubSearchCode`, etc.\n   - **PERSIST research** → Save to `docs/research/YYYY-MM-DD-<topic>-research.md`\n   - **Update memory** → Add to activeContext.md Research References table\n   - Summarize findings before invoking planner\n3. **Create task hierarchy** (see Task-Based Orchestration above)\n4. **Start chain execution** (pass research results + file path in prompt if step 2 was executed)\n5. Update memory → Reference saved plan when task completed\n\n**THREE-PHASE for External Research (MANDATORY):**\n```\nIf SKILL_HINTS includes github-research:\n  → PHASE 1: Execute research using octocode tools\n  → PHASE 2: PERSIST research (prevents context loss):\n      Bash(command=\"mkdir -p docs/research\")\n      Write(file_path=\"docs/research/YYYY-MM-DD-<topic>-research.md\", content=\"[research summary]\")\n      Edit(file_path=\".claude/cc10x/activeContext.md\", ...)  # Add to Research References\n  → PHASE 3: Task(cc10x:planner, prompt=\"...Research findings: {results}...\\nResearch saved to: docs/research/YYYY-MM-DD-<topic>-research.md\")\n```\nResearch is a PREREQUISITE, not a hint. Planner cannot skip it.\n**Research without persistence is LOST after context compaction.**\n\n## Agent Invocation\n\n**Pass task ID, plan file, and context to each agent:**\n```\nTask(subagent_type=\"cc10x:component-builder\", prompt=\"\n## Task Context\n- **Task ID:** {taskId}\n- **Plan File:** {planFile or 'None'}\n\n## User Request\n{request}\n\n## Requirements\n{from AskUserQuestion or 'See plan file'}\n\n## Memory Summary\n{brief summary from activeContext.md}\n\n## Project Patterns\n{key patterns from patterns.md}\n\n## SKILL_HINTS (Load IMMEDIATELY after memory)\n{detected skills from table below}\n\n---\nExecute the task. When complete, call TaskUpdate(taskId, status='completed').\n\")\n```\n\n**TASK ID is REQUIRED.** Agent MUST call `TaskUpdate(taskId, status=\"completed\")` when done.\n**SKILL_HINTS are MANDATORY.** Agent MUST call `Skill(skill=\"...\")` for each hint immediately after loading memory.\n\n**Post-Agent Validation (After agent completes):**\n\nWhen agent returns, verify output quality before proceeding.\n\n### Required Output by Agent\n\n| Agent | Required Sections | Required Evidence |\n|-------|-------------------|-------------------|\n| component-builder | TDD Evidence (RED + GREEN) | Exit codes: 1 (RED), 0 (GREEN) |\n| code-reviewer | Critical Issues, Verdict | Confidence scores (≥80) |\n| silent-failure-hunter | Critical (must fix) | Count of issues found |\n| integration-verifier | Scenarios table, Verdict | PASS/FAIL per scenario |\n| bug-investigator | Root cause, Fix applied | Exit 0 after fix |\n| planner | Plan saved path, Phases | Confidence score |\n\n### Validation Logic\n\n```\nAfter agent completes:\n\n1. Check for required sections in output\n2. Check for skill loading evidence (SKILL_HINTS loaded?)\n\n3. If CRITICAL missing (no exit codes, no verdict):\n   → Option A: Create remediation task:\n     TaskCreate({\n       subject: \"Complete {agent}: Missing {section}\",\n       description: \"Agent output incomplete. Missing: {sections}\",\n       activeForm: \"Completing output\"\n     })\n   → Option B: Ask user:\n     \"Agent output incomplete ({missing}). Continue anyway?\"\n\n4. If NON-CRITICAL missing (skill evidence):\n   → Note for improvement, continue workflow\n\n5. If validation PASSES:\n   → Proceed to next agent in chain\n```\n\n**Validation Evidence Format (include in your response):**\n```\n### Agent Validation: {agent_name}\n- Required Sections: [Present/Missing]\n- Evidence: [Present/Missing]\n- Proceeding: [Yes/No + reason]\n```\n\n**How it works:** Task() is synchronous - router waits for agent to complete and receives its output before proceeding to next agent.\n\n**Skill triggers for agents (DETECT AND PASS AS SKILL_HINTS):**\n\n| Detected Pattern | Skill | Agents |\n|------------------|-------|--------|\n| Frontend: components/, ui/, pages/, .tsx, .jsx, CSS, styling, \"button\", \"form\", \"modal\" | cc10x:frontend-patterns | planner, component-builder, code-reviewer, integration-verifier |\n| API/Backend: api/, routes/, services/, \"endpoint\", \"REST\", \"GraphQL\" | cc10x:architecture-patterns | planner, bug-investigator, code-reviewer |\n| Vague: \"not sure\", \"maybe\", \"options\", \"ideas\", unclear requirements | cc10x:brainstorming | planner |\n| External: new tech (post-2024), unfamiliar library, complex integration (auth, payments) | cc10x:github-research | planner, bug-investigator |\n| Debug exhausted: 3+ local attempts failed, external service error | cc10x:github-research | bug-investigator |\n| User explicitly requests: \"research\", \"github\", \"octocode\", \"find on github\", \"how do others\", \"best practices\" | cc10x:github-research | planner, bug-investigator |\n\n**Detection runs BEFORE agent invocation. Pass detected skills in SKILL_HINTS.**\n\n## Skill Loading Hierarchy (DEFINITIVE)\n\n**Three mechanisms exist. Here's how they interact:**\n\n### 1. Agent Frontmatter `skills:` (PRELOAD - Automatic)\n```yaml\nskills: cc10x:session-memory, cc10x:code-generation\n```\n- Load AUTOMATICALLY when agent starts\n- Full skill content injected into agent context\n- Agent does NOT need to call `Skill()` for these\n- Use for: Skills agent ALWAYS needs\n\n### 2. Router's SKILL_HINTS (MANDATORY - Agent Must Load)\n- Router detects patterns and passes hints in prompt\n- Agent MUST call `Skill(skill=\"cc10x:...\")` for EACH hint\n- Loaded AFTER frontmatter (additive, not duplicate)\n- Use for: Context-specific skills based on task\n\n### 3. Agent's Skill Triggers (OPTIONAL - Agent Judgment)\n- Agent's internal conditional logic\n- Agent MAY call `Skill()` if triggers match\n- Loaded as needed during execution\n- Use for: Agent's own judgment calls\n\n### Loading Order\n```\n1. Frontmatter skills (auto, at agent startup)\n   ↓\n2. SKILL_HINTS from router (mandatory, after memory load)\n   ↓\n3. Agent's trigger-based skills (optional, during execution)\n```\n\n### Deduplication\n- Same skill loaded multiple times: OK (idempotent)\n- No need for \"is this already loaded?\" checks\n\n## Gates (Must Pass)\n\n1. **MEMORY_LOADED** - Before routing\n2. **TASKS_CHECKED** - Check TaskList() for active workflow\n3. **INTENT_CLARIFIED** - User intent is unambiguous (all workflows)\n4. **RESEARCH_EXECUTED** - Before planner (if github-research detected)\n5. **RESEARCH_PERSISTED** - Save to docs/research/ + update activeContext.md (if research was executed)\n6. **REQUIREMENTS_CLARIFIED** - Before invoking agent (BUILD only)\n7. **TASKS_CREATED** - Workflow task hierarchy created\n8. **ALL_TASKS_COMPLETED** - All agent tasks status=\"completed\"\n9. **MEMORY_UPDATED** - Before marking done\n\n## Chain Execution Loop (Task-Based)\n\n**NEVER stop after one agent.** The workflow is NOT complete until ALL tasks are completed.\n\n### Execution Loop\n\n```\n1. Find runnable tasks:\n   TaskList() → Find tasks where:\n   - status = \"pending\"\n   - blockedBy is empty OR all blockedBy tasks are \"completed\"\n\n2. Start agent(s):\n   - TaskUpdate(taskId, status=\"in_progress\")\n   - If multiple tasks ready (e.g., code-reviewer + silent-failure-hunter):\n     → Invoke BOTH in same message (parallel execution)\n   - Pass task ID in prompt:\n     Task(subagent_type=\"cc10x:{agent}\", prompt=\"\n       Your task ID: {taskId}\n       User request: {request}\n       Requirements: {requirements}\n       Memory: {activeContext}\n       SKILL_HINTS: {detected skills}\n     \")\n\n3. After agent completes:\n   - Agent will have called TaskUpdate(taskId, status=\"completed\")\n   - Router calls TaskList() to check state\n\n4. Determine next:\n   - Find tasks where ALL blockedBy tasks are \"completed\"\n   - If multiple ready → Invoke ALL in parallel (same message)\n   - If one ready → Invoke sequentially\n   - If none ready AND uncompleted tasks exist → Wait (error state)\n   - If ALL tasks completed → Workflow complete\n\n5. Repeat until:\n   - All tasks have status=\"completed\"\n   - OR critical error detected (create error task, halt)\n```\n\n### Parallel Execution\n\nWhen multiple tasks become unblocked simultaneously (e.g., code-reviewer AND silent-failure-hunter after component-builder completes):\n\n```\n# Both ready after builder completes\nTaskUpdate(taskId=reviewer_id, status=\"in_progress\")\nTaskUpdate(taskId=hunter_id, status=\"in_progress\")\n\n# Invoke BOTH in same message = parallel execution\nTask(subagent_type=\"cc10x:code-reviewer\", prompt=\"Your task ID: {reviewer_id}...\")\nTask(subagent_type=\"cc10x:silent-failure-hunter\", prompt=\"Your task ID: {hunter_id}...\")\n```\n\n**CRITICAL:** Both Task calls in same message = both complete before you continue.\n\n### Chain Completion Criteria\n\nThe workflow is complete ONLY when:\n- `TaskList()` shows ALL agent tasks with status=\"completed\"\n- OR a critical error prevents continuation\n\n**DO NOT update memory until ALL tasks are completed.**\n\n## Results Collection (Parallel Agents)\n\n**Task system handles coordination. Router handles results.**\n\nWhen parallel agents complete (code-reviewer + silent-failure-hunter), their outputs must be passed to the next agent.\n\n### Pattern: Collect and Pass Findings\n\n```\n# After both parallel agents complete:\n1. TaskList()  # Verify both show \"completed\"\n\n2. Collect outputs from this response:\n   REVIEWER_FINDINGS = {code-reviewer's Critical Issues + Verdict}\n   HUNTER_FINDINGS = {silent-failure-hunter's Critical section}\n\n3. Pass to integration-verifier:\n   Task(subagent_type=\"cc10x:integration-verifier\", prompt=\"\n   ## Task Context\n   - **Task ID:** {verifier_task_id}\n\n   ## Previous Agent Findings (REVIEW BEFORE VERIFYING)\n\n   ### Code Reviewer\n   **Verdict:** {Approve/Changes Requested}\n   **Critical Issues:**\n   {REVIEWER_FINDINGS}\n\n   ### Silent Failure Hunter\n   **Critical Issues:**\n   {HUNTER_FINDINGS}\n\n   ---\n   Verify the implementation. Consider ALL findings above.\n   Any CRITICAL issues should block PASS verdict.\n   \")\n```\n\n### Why Both Task System AND Results Passing\n\n| Aspect | Tasks Handle | Router Handles |\n|--------|--------------|----------------|\n| Completion status | Automatic | - |\n| Dependency unblocking | Automatic | - |\n| Agent findings/output | NOT shared | Pass in prompt |\n| Conflict resolution | - | Include both findings |\n",
        "plugins/cc10x/skills/code-generation/SKILL.md": "---\nname: code-generation\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob, Write, Edit\n---\n\n# Code Generation\n\n## Overview\n\nYou are an expert software engineer with deep knowledge of the codebase. Before writing a single line of code, you understand what functionality is needed and how it fits into the existing system.\n\n**Core principle:** Understand first, write minimal code, match existing patterns.\n\n**Violating the letter of this process is violating the spirit of code generation.**\n\n## The Iron Law\n\n```\nNO CODE BEFORE UNDERSTANDING FUNCTIONALITY AND PROJECT PATTERNS\n```\n\nIf you haven't answered the Universal Questions, you cannot write code.\n\n## Expert Identity\n\nWhen generating code, you are:\n\n- **Expert in this codebase** - You know where things are and why they're there\n- **Pattern-aware** - You match existing conventions, not impose new ones\n- **Minimal** - You write only what's needed, nothing more\n- **Quality-focused** - You don't cut corners on error handling or edge cases\n\n## Universal Questions (Answer Before Writing)\n\n**ALWAYS answer these before generating any code:**\n\n1. **What is the functionality?** - What does this code need to DO (not just what it IS)?\n2. **Who are the users?** - Who will use this? What's their flow?\n3. **What are the inputs?** - What data comes in? What formats?\n4. **What are the outputs?** - What should be returned? What side effects?\n5. **What are the edge cases?** - What can go wrong? What's the error handling?\n6. **What patterns exist?** - How does the codebase do similar things?\n7. **Have you read the files?** - Never propose changes to code you haven't opened and read.\n8. **Is there a simpler approach?** - Can this be solved with less code/complexity?\n   - If YES: Present both approaches, recommend simpler\n   - If NO: Proceed with implementation\n\n## Context-Dependent Flows\n\n**After Universal Questions, ask context-specific questions:**\n\n### UI Components\n- What's the component's visual state (loading, error, empty, success)?\n- What user interactions does it handle?\n- What accessibility requirements exist?\n- How does styling work in this project?\n\n### API Endpoints\n- What authentication/authorization is required?\n- What validation is needed?\n- What are the response formats?\n- How does error handling work in this API?\n\n### Business Logic\n- What are the invariants that must be maintained?\n- What transactions or atomicity is needed?\n- What's the data flow?\n- What dependencies exist?\n\n### Database Operations\n- What's the query performance consideration?\n- Are there N+1 risks?\n- What indexes exist?\n- What's the transaction scope?\n\n## Process\n\n### 1. Study Project Patterns First\n\n```bash\n# Find similar implementations\ngrep -r \"similar_pattern\" --include=\"*.ts\" src/ | head -10\n\n# Check file structure\nls -la src/components/ # or relevant directory\n\n# Read existing similar code\ncat src/path/to/similar/file.ts\n```\n\n**Match:**\n- Naming conventions (`camelCase`, `PascalCase`, prefixes)\n- File structure (where things go)\n- Import patterns (relative vs absolute)\n- Export patterns (default vs named)\n- Error handling patterns\n- Logging patterns\n\n### 2. Write Minimal Implementation\n\nFollow **YAGNI** (You Ain't Gonna Need It). Prefer editing existing files over creating new ones.\n\n**Good:**\n```typescript\nfunction calculateTotal(items: Item[]): number {\n  return items.reduce((sum, item) => sum + item.price, 0);\n}\n```\n\n**Bad (Over-engineered):**\n```typescript\nfunction calculateTotal(\n  items: Item[],\n  options?: {\n    currency?: string;\n    discount?: number;\n    taxRate?: number;\n    roundingMode?: 'up' | 'down' | 'nearest';\n  }\n): CalculationResult {\n  // YAGNI - Was this asked for?\n}\n```\n\n### Minimal Diffs Principle\n\n**Only change what's necessary.** When fixing a bug, fix the bug - don't refactor surrounding code. When adding a feature, add the feature - don't \"improve\" unrelated code. Scope creep in diffs causes merge conflicts, hides the actual change, and makes reviews harder.\n\n### 3. Handle Edge Cases\n\n**Always handle:**\n- Empty inputs (`[]`, `null`, `undefined`)\n- Invalid inputs (wrong types, out of range)\n- Error conditions (network failures, timeouts)\n- Boundary conditions (zero, negative, max values)\n\n```typescript\nfunction getUser(id: string): User | null {\n  if (!id?.trim()) {\n    return null;\n  }\n  // ... implementation\n}\n```\n\n### 4. Align With Existing Conventions\n\n| Aspect | Check |\n|--------|-------|\n| **Naming** | Match existing style (`getUserById` not `fetchUser`) |\n| **Imports** | Match import style (`@/lib/` vs `../../lib/`) |\n| **Exports** | Match export style (default vs named) |\n| **Types** | Match type patterns (interfaces vs types) |\n| **Errors** | Match error handling (throw vs return) |\n| **Logging** | Match logging patterns (if any) |\n\n## Red Flags - STOP and Reconsider\n\nIf you find yourself:\n\n- Writing code before answering Universal Questions\n- Adding features not requested (\"while I'm here...\")\n- Ignoring project patterns (\"my way is better\")\n- Not handling edge cases (\"happy path only\")\n- Creating abstractions for one use case\n- Adding configuration options not requested\n- Writing comments instead of clear code\n- Multiple valid approaches exist but not presenting options\n\n**STOP. Go back to Universal Questions.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"This might be useful later\" | YAGNI. Build what's needed now. |\n| \"My pattern is better\" | Match existing patterns. Consistency > preference. |\n| \"Edge cases are unlikely\" | Edge cases cause production bugs. Handle them. |\n| \"I'll add docs later\" | Code should be self-documenting. Write clear code now. |\n| \"It's just a quick prototype\" | Prototypes become production. Write it right. |\n| \"I know a better way\" | The codebase has patterns. Follow them. |\n\n## When to Present Multiple Options\n\n**Present 2-3 approaches with tradeoffs if:**\n- Multiple design patterns could work (e.g., state management: Context vs Redux vs Zustand)\n- Complexity tradeoff exists (e.g., simple file storage vs database)\n- User said \"best way\" or \"how should I\" (signals uncertainty)\n\n**Proceed with single approach if:**\n- One approach is clearly simpler AND meets requirements\n- Project patterns already established (follow existing pattern)\n- User request is specific (no ambiguity)\n\n**Use brainstorming skill when presenting options.**\n\n## Code Quality Checklist\n\nBefore completing:\n\n- [ ] Universal Questions answered\n- [ ] Context-specific questions answered (if applicable)\n- [ ] Project patterns studied and matched\n- [ ] Minimal implementation (no over-engineering)\n- [ ] Edge cases handled\n- [ ] Error handling in place\n- [ ] Types correct and complete\n- [ ] Naming matches project conventions\n- [ ] No hardcoded values (use constants)\n- [ ] No debugging artifacts (console.log, TODO)\n- [ ] No commented-out code\n\n## Output Format\n\n```markdown\n## Code Implementation\n\n### Functionality\n[What this code does]\n\n### Universal Questions Answered\n1. **Functionality**: [answer]\n2. **Users**: [answer]\n3. **Inputs**: [answer]\n4. **Outputs**: [answer]\n5. **Edge cases**: [answer]\n6. **Existing patterns**: [answer]\n\n### Implementation\n\n```typescript\n// Code here\n```\n\n### Key Decisions\n- [Decision 1 and why]\n- [Decision 2 and why]\n\n### Assumptions\n- [Assumption 1]\n- [Assumption 2]\n```\n\n## Common Patterns\n\n### Functions\n```typescript\n// Clear name, typed parameters and return\nfunction calculateOrderTotal(items: OrderItem[]): Money {\n  if (!items.length) {\n    return Money.zero();\n  }\n  return items.reduce(\n    (total, item) => total.add(item.price.multiply(item.quantity)),\n    Money.zero()\n  );\n}\n```\n\n### Components (React example)\n```typescript\ninterface UserCardProps {\n  user: User;\n  onSelect?: (user: User) => void;\n}\n\nexport function UserCard({ user, onSelect }: UserCardProps) {\n  if (!user) {\n    return null;\n  }\n\n  return (\n    <div\n      className=\"user-card\"\n      onClick={() => onSelect?.(user)}\n      role=\"button\"\n      tabIndex={0}\n    >\n      <span>{user.name}</span>\n    </div>\n  );\n}\n```\n\n### Error Handling\n```typescript\n// Match project error patterns\nasync function fetchUser(id: string): Promise<Result<User>> {\n  try {\n    const response = await api.get(`/users/${id}`);\n    return Result.ok(response.data);\n  } catch (error) {\n    logger.error('Failed to fetch user', { id, error });\n    return Result.err(new UserNotFoundError(id));\n  }\n}\n```\n\n## Final Rule\n\n```\nFunctionality understood → Patterns studied → Minimal code → Edge cases handled\nOtherwise → Not ready to write code\n```\n",
        "plugins/cc10x/skills/code-review-patterns/SKILL.md": "---\nname: code-review-patterns\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob\n---\n\n# Code Review Patterns\n\n## Overview\n\nCode reviews catch bugs before they ship. But reviewing code quality before functionality is backwards.\n\n**Core principle:** First verify it works, THEN verify it's good.\n\n## Quick Review Checklist (Reference Pattern)\n\n**For rapid reviews, check these 8 items:**\n\n- [ ] Code is simple and readable\n- [ ] Functions and variables are well-named\n- [ ] No duplicated code\n- [ ] Proper error handling\n- [ ] No exposed secrets or API keys\n- [ ] Input validation implemented\n- [ ] Good test coverage\n- [ ] Performance considerations addressed\n\n## The Iron Law\n\n```\nNO CODE QUALITY REVIEW BEFORE SPEC COMPLIANCE\n```\n\nIf you haven't verified the code meets requirements, you cannot review code quality.\n\n## Two-Stage Review Process\n\n### Stage 1: Spec Compliance Review\n\n**Does it do what was asked?**\n\n1. **Read the Requirements**\n   - What was requested?\n   - What are the acceptance criteria?\n   - What are the edge cases?\n\n2. **Trace the Implementation**\n   - Does the code implement each requirement?\n   - Are all edge cases handled?\n   - Does it match the spec exactly?\n\n3. **Test Functionality**\n   - Run the tests\n   - Manual test if needed\n   - Verify outputs match expectations\n\n**Gate:** Only proceed to Stage 2 if Stage 1 passes.\n\n### Stage 2: Code Quality Review\n\n**Is it well-written?**\n\nReview in priority order:\n\n1. **Security** - Vulnerabilities that could be exploited\n2. **Correctness** - Logic errors, edge cases missed\n3. **Performance** - Unnecessary slowness\n4. **Maintainability** - Hard to understand or modify\n5. **UX** - User experience issues (if UI involved)\n6. **Accessibility** - A11y issues (if UI involved)\n\n## Security Review Checklist\n\n**Reference:** [OWASP Top 10](https://owasp.org/www-project-top-ten/) - Check against industry standard vulnerabilities.\n\n| Check | Looking For | Example Vulnerability |\n|-------|-------------|----------------------|\n| Input validation | Unvalidated user input | SQL injection, XSS |\n| Authentication | Missing auth checks | Unauthorized access |\n| Authorization | Missing permission checks | Privilege escalation |\n| Secrets | Hardcoded credentials | API key exposure |\n| SQL queries | String concatenation | SQL injection |\n| Output encoding | Unescaped output | XSS attacks |\n| CSRF | Missing tokens | Cross-site request forgery |\n| File handling | Path traversal | Reading arbitrary files |\n\n**For each security issue found:**\n```markdown\n- [CRITICAL] SQL injection at `src/api/users.ts:45`\n  - Problem: User input concatenated into query\n  - Fix: Use parameterized query\n  - Code: `db.query(\\`SELECT * FROM users WHERE id = ?\\`, [userId])`\n```\n\n## Quality Review Checklist\n\n| Check | Good | Bad |\n|-------|------|-----|\n| **Naming** | `calculateTotalPrice()` | `calc()`, `doStuff()` |\n| **Functions** | Does one thing | Multiple responsibilities |\n| **Complexity** | Linear flow | Nested conditions |\n| **Duplication** | DRY where sensible | Copy-paste code |\n| **Error handling** | Graceful failures | Silent failures |\n| **Testability** | Injectable dependencies | Global state |\n\n## Performance Review Checklist\n\n| Pattern | Problem | Fix |\n|---------|---------|-----|\n| N+1 queries | Loop with DB call | Batch query |\n| Unnecessary loops | Iterating full list | Early return |\n| Missing cache | Repeated expensive ops | Add caching |\n| Memory leaks | Objects never cleaned | Cleanup on dispose |\n| Sync blocking | Blocking main thread | Async operation |\n\n## UX Review Checklist (UI Code)\n\n| Check | Verify |\n|-------|--------|\n| Loading states | Shows loading indicator |\n| Error states | Shows helpful error message |\n| Empty states | Shows appropriate empty message |\n| Success feedback | Confirms action completed |\n| Form validation | Shows inline errors |\n| Responsive | Works on mobile/tablet |\n\n## Accessibility Review Checklist (UI Code)\n\n| Check | Verify |\n|-------|--------|\n| Semantic HTML | Uses correct elements (button, not div) |\n| Alt text | Images have meaningful alt text |\n| Keyboard | All interactions keyboard accessible |\n| Focus | Focus visible and logical order |\n| Color contrast | Meets WCAG AA (4.5:1 text) |\n| Screen reader | Labels and ARIA where needed |\n\n## Severity Classification\n\n| Severity | Definition | Action |\n|----------|------------|--------|\n| **CRITICAL** | Security vulnerability or blocks functionality | Must fix before merge |\n| **MAJOR** | Affects functionality or significant quality issue | Should fix before merge |\n| **MINOR** | Style issues, small improvements | Can merge, fix later |\n| **NIT** | Purely stylistic preferences | Optional |\n\n## Priority Output Format (Feedback Grouping)\n\n**Organize feedback by priority (from reference pattern):**\n\n```markdown\n## Code Review Feedback\n\n### Critical (must fix before merge)\n- [95] SQL injection at `src/api/users.ts:45`\n  → Fix: Use parameterized query `db.query('SELECT...', [userId])`\n\n### Warnings (should fix)\n- [85] N+1 query at `src/services/posts.ts:23`\n  → Fix: Batch query with WHERE IN clause\n\n### Suggestions (consider improving)\n- [70] Function `calc()` could be renamed to `calculateTotal()`\n  → More descriptive naming\n```\n\n**ALWAYS include specific examples of how to fix each issue.**\nDon't just say \"this is wrong\" - show the correct approach.\n\n## Red Flags - STOP and Re-review\n\nIf you find yourself:\n\n- Reviewing code style before checking functionality\n- Not running the tests\n- Skipping the security checklist\n- Giving generic feedback (\"looks good\")\n- Not providing file:line citations\n- Not explaining WHY something is wrong\n- Not providing fix recommendations\n\n**STOP. Start over with Stage 1.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Tests pass so it's fine\" | Tests can miss requirements. Check spec compliance. |\n| \"Code looks clean\" | Clean code can still be wrong. Verify functionality. |\n| \"I trust this developer\" | Trust but verify. Everyone makes mistakes. |\n| \"It's a small change\" | Small changes cause big bugs. Review thoroughly. |\n| \"No time for full review\" | Bugs take more time than reviews. Do it properly. |\n| \"Security is overkill\" | One vulnerability can sink the company. Check it. |\n\n## Output Format\n\n```markdown\n## Code Review: [PR Title/Component]\n\n### Stage 1: Spec Compliance ✅/❌\n\n**Requirements:**\n- [x] Requirement 1 - implemented at `file:line`\n- [x] Requirement 2 - implemented at `file:line`\n- [ ] Requirement 3 - NOT IMPLEMENTED\n\n**Tests:** PASS (24/24)\n\n**Verdict:** [Meets spec / Missing requirements]\n\n---\n\n### Stage 2: Code Quality\n\n**Security:**\n- [CRITICAL] Issue at `file:line` - Fix: [recommendation]\n- No issues found ✅\n\n**Performance:**\n- [MAJOR] N+1 query at `file:line` - Fix: Use batch query\n- No issues found ✅\n\n**Quality:**\n- [MINOR] Unclear naming at `file:line` - Suggestion: rename to X\n- No issues found ✅\n\n**UX/A11y:** (if UI code)\n- [MAJOR] Missing loading state - Fix: Add spinner\n- No issues found ✅\n\n---\n\n### Summary\n\n**Decision:** Approve / Request Changes\n\n**Critical:** [count]\n**Major:** [count]\n**Minor:** [count]\n\n**Required fixes before merge:**\n1. [Most important fix]\n2. [Second fix]\n```\n\n## Review Loop Protocol\n\nAfter requesting changes:\n\n1. **Wait for fixes** - Developer addresses issues\n2. **Re-review** - Check that fixes actually fix the issues\n3. **Verify no regressions** - Run tests again\n4. **Approve or request more changes** - Repeat if needed\n\n**Never approve without verifying fixes work.**\n\n## Final Check\n\nBefore approving:\n\n- [ ] Stage 1 complete (spec compliance verified)\n- [ ] Stage 2 complete (all checklists reviewed)\n- [ ] All critical/major issues addressed\n- [ ] Tests pass\n- [ ] No regressions introduced\n- [ ] Evidence captured for each claim\n",
        "plugins/cc10x/skills/debugging-patterns/SKILL.md": "---\nname: debugging-patterns\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob, Bash\n---\n\n# Systematic Debugging\n\n## Overview\n\nRandom fixes waste time and create new bugs. Quick patches mask underlying issues.\n\n**Core principle:** ALWAYS find root cause before attempting fixes. Symptom fixes are failure.\n\n**Violating the letter of this process is violating the spirit of debugging.**\n\n## The Iron Law\n\n```\nNO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST\n```\n\nIf you haven't completed Phase 1, you cannot propose fixes.\n\n## Quick Five-Step Process (Reference Pattern)\n\nFor rapid debugging, use this concise flow:\n\n```\n1. Capture error message and stack trace\n2. Identify reproduction steps\n3. Isolate the failure location\n4. Implement minimal fix\n5. Verify solution works\n```\n\n**Debugging techniques:**\n- Analyze error messages and logs\n- Check recent code changes\n- Form and test hypotheses\n- **Add strategic debug logging**\n- **Inspect variable states**\n\n**Root Cause Tracing Technique:**\n```\n1. Observe symptom - Where does error manifest?\n2. Find immediate cause - Which code produces the error?\n3. Ask \"What called this?\" - Map call chain upward\n4. Keep tracing up - Follow invalid data backward\n5. Find original trigger - Where did problem actually start?\n```\n**Never fix solely where errors appear—trace to the original trigger.**\n\n**For each issue provide:**\n- Root cause explanation\n- Evidence supporting diagnosis\n- Specific code fix\n- Testing approach\n- Prevention recommendations\n\n## Common Debugging Scenarios\n\n### Test Failures\n```\n1. Read FULL error message and stack trace\n2. Identify which assertion failed and why\n3. Check test setup - is environment correct?\n4. Check test data - are mocks/fixtures correct?\n5. Trace to source of unexpected value\n```\n\n### Runtime Errors\n```\n1. Capture full stack trace\n2. Identify line that throws\n3. Check what values are undefined/null\n4. Trace backward to where bad value originated\n5. Add validation at the source\n```\n\n### \"It worked before\"\n```\n1. Use `git bisect` to find breaking commit\n2. Compare change with previous working version\n3. Identify what assumption changed\n4. Fix at source of assumption violation\n```\n\n### Intermittent Failures\n```\n1. Look for race conditions\n2. Check for shared mutable state\n3. Examine async operation ordering\n4. Look for timing dependencies\n5. Add deterministic waits or proper synchronization\n```\n\n## When to Use\n\nUse for ANY technical issue:\n- Test failures\n- Bugs in production\n- Unexpected behavior\n- Performance problems\n- Build failures\n- Integration issues\n\n**Use this ESPECIALLY when:**\n- Under time pressure (emergencies make guessing tempting)\n- \"Just one quick fix\" seems obvious\n- You've already tried multiple fixes\n- Previous fix didn't work\n- You don't fully understand the issue\n\n**Don't skip when:**\n- Issue seems simple (simple bugs have root causes too)\n- You're in a hurry (rushing guarantees rework)\n- Manager wants it fixed NOW (systematic is faster than thrashing)\n\n## The Four Phases\n\nYou MUST complete each phase before proceeding to the next.\n\n### Phase 1: Root Cause Investigation\n\n**BEFORE attempting ANY fix:**\n\n1. **Read Error Messages Carefully**\n   - Don't skip past errors or warnings\n   - They often contain the exact solution\n   - Read stack traces completely\n   - Note line numbers, file paths, error codes\n\n2. **Reproduce Consistently**\n   - Can you trigger it reliably?\n   - What are the exact steps?\n   - Does it happen every time?\n   - If not reproducible → gather more data, don't guess\n\n3. **Check Recent Changes**\n   - What changed that could cause this?\n   - Git diff, recent commits\n   - New dependencies, config changes\n   - Environmental differences\n\n4. **Gather Evidence in Multi-Component Systems**\n\n   **WHEN system has multiple components (CI → build → signing, API → service → database):**\n\n   **BEFORE proposing fixes, add diagnostic instrumentation:**\n   ```\n   For EACH component boundary:\n     - Log what data enters component\n     - Log what data exits component\n     - Verify environment/config propagation\n     - Check state at each layer\n\n   Run once to gather evidence showing WHERE it breaks\n   THEN analyze evidence to identify failing component\n   THEN investigate that specific component\n   ```\n\n   **Example (multi-layer system):**\n   ```bash\n   # Layer 1: Entry point\n   echo \"=== Input data: ===\"\n   echo \"Request: ${REQUEST}\"\n\n   # Layer 2: Processing layer\n   echo \"=== After processing: ===\"\n   echo \"Transformed: ${TRANSFORMED}\"\n\n   # Layer 3: Output layer\n   echo \"=== Final state: ===\"\n   echo \"Result: ${RESULT}\"\n   ```\n\n   **This reveals:** Which layer fails (input → processing ✓, processing → output ✗)\n\n5. **Trace Data Flow**\n\n   **WHEN error is deep in call stack:**\n   - Where does bad value originate?\n   - What called this with bad value?\n   - Keep tracing up until you find the source\n   - Fix at source, not at symptom\n\n### Phase 2: Pattern Analysis\n\n**Find the pattern before fixing:**\n\n1. **Find Working Examples**\n   - Locate similar working code in same codebase\n   - What works that's similar to what's broken?\n\n2. **Compare Against References**\n   - If implementing pattern, read reference implementation COMPLETELY\n   - Don't skim - read every line\n   - Understand the pattern fully before applying\n\n3. **Identify Differences**\n   - What's different between working and broken?\n   - List every difference, however small\n   - Don't assume \"that can't matter\"\n\n4. **Understand Dependencies**\n   - What other components does this need?\n   - What settings, config, environment?\n   - What assumptions does it make?\n\n### Phase 3: Hypothesis and Testing\n\n**Scientific method:**\n\n1. **Form Single Hypothesis**\n   - State clearly: \"I think X is the root cause because Y\"\n   - Write it down\n   - Be specific, not vague\n\n2. **Test Minimally**\n   - Make the SMALLEST possible change to test hypothesis\n   - One variable at a time\n   - Don't fix multiple things at once\n\n3. **Verify Before Continuing**\n   - Did it work? Yes → Phase 4\n   - Didn't work? Form NEW hypothesis\n   - DON'T add more fixes on top\n\n4. **When You Don't Know**\n   - Say \"I don't understand X\"\n   - Don't pretend to know\n   - Ask for help\n   - Research more\n\n### Hypothesis Quality Criteria\n\n**Falsifiability Requirement:** A good hypothesis can be proven wrong. If you can't design an experiment to disprove it, it's not useful.\n\n**Bad (unfalsifiable):**\n- \"Something is wrong with the state\"\n- \"The timing is off\"\n- \"There's a race condition somewhere\"\n\n**Good (falsifiable):**\n- \"User state resets because component remounts when route changes\"\n- \"API call completes after unmount, causing state update on unmounted component\"\n- \"Two async operations modify same array without locking, causing data loss\"\n\n**The difference:** Specificity. Good hypotheses make specific, testable claims.\n\n### Cognitive Biases in Debugging\n\n| Bias | Trap | Antidote |\n|------|------|----------|\n| **Confirmation** | Only look for evidence supporting your hypothesis | \"What would prove me wrong?\" |\n| **Anchoring** | First explanation becomes your anchor | Generate 3+ hypotheses before investigating any |\n| **Availability** | Recent bugs → assume similar cause | Treat each bug as novel until evidence suggests otherwise |\n| **Sunk Cost** | Spent 2 hours on path, keep going despite evidence | Every 30 min: \"If fresh, would I take this path?\" |\n\n### Phase 4: Implementation\n\n**Fix the root cause, not the symptom:**\n\n1. **Create Failing Test Case**\n   - Simplest possible reproduction\n   - Automated test if possible\n   - One-off test script if no framework\n   - MUST have before fixing\n\n2. **Implement Single Fix**\n   - Address the root cause identified\n   - ONE change at a time\n   - No \"while I'm here\" improvements\n   - No bundled refactoring\n\n3. **Verify Fix**\n   - Test passes now?\n   - No other tests broken?\n   - Issue actually resolved?\n\n4. **If Fix Doesn't Work**\n   - STOP\n   - Count: How many fixes have you tried?\n   - If < 3: Return to Phase 1, re-analyze with new information\n   - **If >= 3: STOP and question the architecture (step 5 below)**\n   - DON'T attempt Fix #4 without architectural discussion\n\n5. **If 3+ Fixes Failed: Question Architecture**\n\n   **Pattern indicating architectural problem:**\n   - Each fix reveals new shared state/coupling/problem in different place\n   - Fixes require \"massive refactoring\" to implement\n   - Each fix creates new symptoms elsewhere\n\n   **STOP and question fundamentals:**\n   - Is this pattern fundamentally sound?\n   - Are we \"sticking with it through sheer inertia\"?\n   - Should we refactor architecture vs. continue fixing symptoms?\n\n   **Discuss with your human partner before attempting more fixes**\n\n   This is NOT a failed hypothesis - this is a wrong architecture.\n\n## Red Flags - STOP and Follow Process\n\nIf you catch yourself thinking:\n\n- \"Quick fix for now, investigate later\"\n- \"Just try changing X and see if it works\"\n- \"Add multiple changes, run tests\"\n- \"Skip the test, I'll manually verify\"\n- \"It's probably X, let me fix that\"\n- \"I don't fully understand but this might work\"\n- \"Pattern says X but I'll adapt it differently\"\n- \"Here are the main problems: [lists fixes without investigation]\"\n- Proposing solutions before tracing data flow\n- **\"One more fix attempt\" (when already tried 2+)**\n- **Each fix reveals new problem in different place**\n\n**ALL of these mean: STOP. Return to Phase 1.**\n\n**If 3+ fixes failed:** Question the architecture (see Phase 4.5)\n\n## User's Signals You're Doing It Wrong\n\n**Watch for these redirections:**\n- \"Is that not happening?\" - You assumed without verifying\n- \"Will it show us...?\" - You should have added evidence gathering\n- \"Stop guessing\" - You're proposing fixes without understanding\n- \"Ultrathink this\" - Question fundamentals, not just symptoms\n- \"We're stuck?\" (frustrated) - Your approach isn't working\n\n**When you see these:** STOP. Return to Phase 1.\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Issue is simple, don't need process\" | Simple issues have root causes too. Process is fast for simple bugs. |\n| \"Emergency, no time for process\" | Systematic debugging is FASTER than guess-and-check thrashing. |\n| \"Just try this first, then investigate\" | First fix sets the pattern. Do it right from the start. |\n| \"I'll write test after confirming fix works\" | Untested fixes don't stick. Test first proves it. |\n| \"Multiple fixes at once saves time\" | Can't isolate what worked. Causes new bugs. |\n| \"Reference too long, I'll adapt the pattern\" | Partial understanding guarantees bugs. Read it completely. |\n| \"I see the problem, let me fix it\" | Seeing symptoms ≠ understanding root cause. |\n| \"One more fix attempt\" (after 2+ failures) | 3+ failures = architectural problem. Question pattern, don't fix again. |\n\n## Quick Reference\n\n| Phase | Key Activities | Success Criteria |\n|-------|---------------|------------------|\n| **1. Root Cause** | Read errors, reproduce, check changes, gather evidence | Understand WHAT and WHY |\n| **2. Pattern** | Find working examples, compare | Identify differences |\n| **3. Hypothesis** | Form theory, test minimally | Confirmed or new hypothesis |\n| **4. Implementation** | Create test, fix, verify | Bug resolved, tests pass |\n\n## When Process Reveals \"No Root Cause\"\n\nIf systematic investigation reveals issue is truly environmental, timing-dependent, or external:\n\n1. You've completed the process\n2. Document what you investigated\n3. Implement appropriate handling (retry, timeout, error message)\n4. Add monitoring/logging for future investigation\n\n**But:** 95% of \"no root cause\" cases are incomplete investigation.\n\n## Output Format\n\n```markdown\n## Bug Investigation\n\n### Phase 1: Evidence Gathered\n- **Error**: [exact error message]\n- **Stack trace**: [relevant lines]\n- **Reproduction**: [steps to reproduce]\n- **Recent changes**: [commits/changes]\n\n### Phase 2: Pattern Analysis\n- **Working example**: [similar working code]\n- **Key differences**: [what's different]\n\n### Phase 3: Hypothesis\n- **Theory**: [I think X because Y]\n- **Test**: [minimal change made]\n- **Result**: [confirmed/refuted]\n\n### Phase 4: Fix\n- **Root cause**: [actual cause with evidence]\n- **Change**: [summary of fix]\n- **File**: [path:line]\n- **Regression test**: [test added]\n\n### Verification\n- Test command: [command] → exit 0\n- All tests: PASS\n- Functionality: Restored\n```\n\n## Real-World Impact\n\nFrom debugging sessions:\n- Systematic approach: 15-30 minutes to fix\n- Random fixes approach: 2-3 hours of thrashing\n- First-time fix rate: 95% vs 40%\n- New bugs introduced: Near zero vs common\n",
        "plugins/cc10x/skills/frontend-patterns/SKILL.md": "---\nname: frontend-patterns\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob\n---\n\n# Frontend Patterns\n\n## Overview\n\nUser interfaces exist to help users accomplish tasks. Every UI decision should make the user's task easier or the interface more accessible.\n\n**Core principle:** Design for user success, not aesthetic preference.\n\n**Violating the letter of this process is violating the spirit of frontend design.**\n\n## Focus Areas (Reference Pattern)\n\n- **React component architecture** (hooks, context, performance)\n- **Responsive CSS** with Tailwind/CSS-in-JS\n- **State management** (Redux, Zustand, Context API)\n- **Frontend performance** (lazy loading, code splitting, memoization)\n- **Accessibility** (WCAG compliance, ARIA labels, keyboard navigation)\n\n## Approach (Reference Pattern)\n\n1. **Component-first thinking** - reusable, composable UI pieces\n2. **Mobile-first responsive design** - start small, scale up\n3. **Performance budgets** - aim for sub-3s load times\n4. **Semantic HTML** and proper ARIA attributes\n5. **Type safety** with TypeScript when applicable\n\n## Component Output Checklist\n\n**Every frontend deliverable should include:**\n\n- [ ] Complete React component with props interface\n- [ ] Styling solution (Tailwind classes or styled-components)\n- [ ] State management implementation if needed\n- [ ] Basic unit test structure\n- [ ] Accessibility checklist for the component\n- [ ] Performance considerations and optimizations\n\n**Focus on working code over explanations. Include usage examples in comments.**\n\n## The Iron Law\n\n```\nNO UI DESIGN BEFORE USER FLOW IS UNDERSTOOD\n```\n\nIf you haven't mapped what the user is trying to accomplish, you cannot design UI.\n\n## Loading State Order (CRITICAL)\n\n**Always handle states in this order:**\n\n```typescript\n// CORRECT order\nif (error) return <ErrorState error={error} onRetry={refetch} />;\nif (loading && !data) return <LoadingState />;\nif (!data?.items.length) return <EmptyState />;\nreturn <ItemList items={data.items} />;\n```\n\n**Loading State Decision Tree:**\n```\nIs there an error? → Yes: Show error with retry\n                   → No: Continue\nIs loading AND no data? → Yes: Show loading indicator\n                        → No: Continue\nDo we have data? → Yes, with items: Show data\n                 → Yes, but empty: Show empty state\n                 → No: Show loading (fallback)\n```\n\n**Golden Rule:** Show loading indicator ONLY when there's no data to display.\n\n## Skeleton vs Spinner\n\n| Use Skeleton When | Use Spinner When |\n|-------------------|------------------|\n| Known content shape | Unknown content shape |\n| List/card layouts | Modal actions |\n| Initial page load | Button submissions |\n| Content placeholders | Inline operations |\n\n## Error Handling Hierarchy\n\n| Level | Use For |\n|-------|---------|\n| **Inline error** | Field-level validation |\n| **Toast notification** | Recoverable errors, user can retry |\n| **Error banner** | Page-level errors, data still partially usable |\n| **Full error screen** | Unrecoverable, needs user action |\n\n## Success Criteria Framework\n\n**Every UI must have explicit success criteria:**\n\n1. **Task completion**: Can user complete their goal?\n2. **Error recovery**: Can user recover from mistakes?\n3. **Accessibility**: Can all users access it?\n4. **Performance**: Does it feel responsive?\n\n## Universal Questions (Answer First)\n\n**ALWAYS answer before designing/reviewing:**\n\n1. **What is the user trying to accomplish?** - Specific task, not feature\n2. **What are the steps?** - Click by click\n3. **What can go wrong?** - Every error state\n4. **Who might struggle?** - Accessibility needs\n5. **What's the existing pattern?** - Project conventions\n\n## User Flow First\n\n**Before any UI work, map the flow:**\n\n```\nUser Flow: Create Account\n1. User lands on signup page\n2. User enters email\n3. User enters password\n4. User confirms password\n5. System validates inputs (inline)\n6. User clicks submit\n7. System processes (loading state)\n8. Success: User sees confirmation + redirect\n9. Error: User sees error + can retry\n```\n\n**For each step, identify:**\n- What user sees\n- What user does\n- What feedback they get\n- What can go wrong\n\n## UX Review Checklist\n\n| Check | Criteria | Example Issue |\n|-------|----------|---------------|\n| **Task completion** | Can user complete goal? | Button doesn't work |\n| **Discoverability** | Can user find what they need? | Hidden navigation |\n| **Feedback** | Does user know what's happening? | No loading state |\n| **Error handling** | Can user recover from errors? | No error message |\n| **Efficiency** | Can user complete task quickly? | Too many steps |\n\n**Severity levels:**\n- **BLOCKS**: User cannot complete task\n- **IMPAIRS**: User can complete but with difficulty\n- **MINOR**: Small friction, not blocking\n\n## Accessibility Review Checklist (WCAG 2.1 AA)\n\n| Check | Criterion | How to Verify |\n|-------|-----------|---------------|\n| **Keyboard** | All interactive elements keyboard accessible | Tab through entire flow |\n| **Focus visible** | Current focus clearly visible | Tab and check highlight |\n| **Focus order** | Logical tab order | Tab matches visual order |\n| **Labels** | All inputs have labels | Check `<label>` or `aria-label` |\n| **Alt text** | Images have meaningful alt | Check `alt` attributes |\n| **Color contrast** | 4.5:1 for text, 3:1 for large | Use contrast checker |\n| **Color alone** | Info not conveyed by color only | Check without color |\n| **Screen reader** | Content accessible via SR | Test with VoiceOver/NVDA |\n\n**For each issue found:**\n```markdown\n- [WCAG 2.1 1.4.3] Color contrast at `component:line`\n  - Current: 3.2:1 (fails AA)\n  - Required: 4.5:1\n  - Fix: Change text color to #333 (7.1:1)\n```\n\n## Visual Design Checklist\n\n| Check | Good | Bad |\n|-------|------|-----|\n| **Hierarchy** | Clear visual priority | Everything same size |\n| **Spacing** | Consistent rhythm | Random gaps |\n| **Alignment** | Elements aligned to grid | Misaligned elements |\n| **Interactive states** | Hover/active/focus distinct | No state changes |\n| **Feedback** | Clear response to actions | Silent interactions |\n\n### Visual Creativity (Avoid AI Slop)\n\nWhen creating frontends, avoid generic AI aesthetics:\n\n- **Fonts**: Choose distinctive typography, not defaults (avoid Inter, Roboto, Arial, system fonts)\n- **Colors**: Commit to cohesive palette. Dominant colors with sharp accents > safe gradients\n- **Avoid**: Purple gradients on white, predictable layouts, cookie-cutter Bootstrap/Tailwind defaults\n\nMake creative choices that feel designed for the specific context.\n\n## Component Patterns\n\n### Buttons\n```tsx\n// Primary action button with all states\n<button\n  type=\"button\"\n  onClick={handleAction}\n  disabled={isLoading || isDisabled}\n  aria-busy={isLoading}\n  aria-disabled={isDisabled}\n  className={cn(\n    'btn-primary',\n    isLoading && 'btn-loading'\n  )}\n>\n  {isLoading ? (\n    <>\n      <Spinner aria-hidden />\n      <span>Processing...</span>\n    </>\n  ) : (\n    'Submit'\n  )}\n</button>\n```\n\n### Forms with Validation\n```tsx\n<form onSubmit={handleSubmit} noValidate>\n  <div className=\"form-field\">\n    <label htmlFor=\"email\">\n      Email <span aria-hidden>*</span>\n      <span className=\"sr-only\">(required)</span>\n    </label>\n    <input\n      id=\"email\"\n      type=\"email\"\n      value={email}\n      onChange={handleChange}\n      aria-invalid={errors.email ? 'true' : undefined}\n      aria-describedby={errors.email ? 'email-error' : 'email-hint'}\n      required\n    />\n    <span id=\"email-hint\" className=\"hint\">\n      We'll never share your email\n    </span>\n    {errors.email && (\n      <span id=\"email-error\" role=\"alert\" className=\"error\">\n        {errors.email}\n      </span>\n    )}\n  </div>\n</form>\n```\n\n### Loading States\n```tsx\nfunction DataList({ isLoading, data, error }) {\n  if (isLoading) {\n    return (\n      <div aria-live=\"polite\" aria-busy=\"true\">\n        <Spinner />\n        <span>Loading items...</span>\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div role=\"alert\" className=\"error-state\">\n        <p>Failed to load items: {error.message}</p>\n        <button onClick={retry}>Try again</button>\n      </div>\n    );\n  }\n\n  if (!data?.length) {\n    return (\n      <div className=\"empty-state\">\n        <p>No items found</p>\n        <button onClick={createNew}>Create your first item</button>\n      </div>\n    );\n  }\n\n  return <ul>{data.map(item => <Item key={item.id} {...item} />)}</ul>;\n}\n```\n\n### Error Messages\n```tsx\n// Inline error with recovery action\n<div role=\"alert\" className=\"error-banner\">\n  <Icon name=\"error\" aria-hidden />\n  <div>\n    <p className=\"error-title\">Upload failed</p>\n    <p className=\"error-detail\">File too large. Maximum size is 10MB.</p>\n  </div>\n  <button onClick={selectFile}>Choose different file</button>\n</div>\n```\n\n## Responsive Design Checklist\n\n| Breakpoint | Check |\n|------------|-------|\n| **Mobile (< 640px)** | Touch targets 44px+, no horizontal scroll |\n| **Tablet (640-1024px)** | Layout adapts, navigation accessible |\n| **Desktop (> 1024px)** | Content readable, not too wide |\n\n## Red Flags - STOP and Reconsider\n\nIf you find yourself:\n\n- Designing UI before mapping user flow\n- Focusing on aesthetics before functionality\n- Ignoring accessibility (\"we'll add it later\")\n- Not handling error states\n- Not providing loading feedback\n- Using color alone to convey information\n- Making decisions based on \"it looks nice\"\n\n**STOP. Go back to user flow.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Most users don't use keyboard\" | Some users ONLY use keyboard. |\n| \"We'll add accessibility later\" | Retrofitting is 10x harder. |\n| \"Error states are edge cases\" | Errors happen. Handle them. |\n| \"Loading is fast, no need for state\" | Network varies. Show state. |\n| \"It looks better without labels\" | Unlabeled inputs are inaccessible. |\n| \"Users can figure it out\" | If it's confusing, fix it. |\n\n## Output Format\n\n```markdown\n## Frontend Review: [Component/Feature]\n\n### User Flow\n[Step-by-step what user is trying to do]\n\n### Success Criteria\n- [ ] User can complete [task]\n- [ ] User can recover from errors\n- [ ] All users can access (keyboard, screen reader)\n- [ ] Interface feels responsive\n\n### UX Issues\n| Severity | Issue | Location | Impact | Fix |\n|----------|-------|----------|--------|-----|\n| BLOCKS | [Issue] | `file:line` | [Impact] | [Fix] |\n\n### Accessibility Issues\n| WCAG | Issue | Location | Fix |\n|------|-------|----------|-----|\n| 1.4.3 | [Issue] | `file:line` | [Fix] |\n\n### Visual Issues\n| Issue | Location | Fix |\n|-------|----------|-----|\n| [Issue] | `file:line` | [Fix] |\n\n### Recommendations\n1. [Most critical fix]\n2. [Second fix]\n```\n\n## UI States Checklist (CRITICAL)\n\n**Before completing ANY UI component:**\n\n### States\n- [ ] Error state handled and shown to user\n- [ ] Loading state shown ONLY when no data exists\n- [ ] Empty state provided for all collections/lists\n- [ ] Success state with appropriate feedback\n\n### Buttons & Mutations\n- [ ] Buttons disabled during async operations\n- [ ] Buttons show loading indicator\n- [ ] Mutations have onError handler with user feedback\n- [ ] No double-click possible on submit buttons\n\n### Data Handling\n- [ ] State order: Error → Loading (no data) → Empty → Success\n- [ ] All user actions have feedback (toast/visual)\n\n## Final Check\n\nBefore completing frontend work:\n\n- [ ] User flow mapped and understood\n- [ ] All states handled (loading, error, empty, success)\n- [ ] Keyboard navigation works\n- [ ] Screen reader tested\n- [ ] Color contrast verified\n- [ ] Touch targets adequate on mobile\n- [ ] Error messages clear and actionable\n- [ ] Success criteria met\n",
        "plugins/cc10x/skills/github-research/SKILL.md": "---\nname: github-research\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: WebFetch, mcp__octocode__githubSearchCode, mcp__octocode__githubSearchRepositories, mcp__octocode__githubViewRepoStructure, mcp__octocode__githubGetFileContent, mcp__octocode__githubSearchPullRequests, mcp__octocode__packageSearch, mcp__context7__resolve-library-id, mcp__context7__query-docs, Read, Write, Edit, Bash\n---\n\n# External Code Research\n\n## Overview\n\nResearch external patterns, documentation, and best practices from GitHub and library docs when AI knowledge is insufficient. Use Octocode MCP for GitHub research, Context7 MCP for library documentation, with WebFetch as final fallback.\n\n**Core principle:** Research BEFORE building, not during. External research enhances planning, not execution.\n\n**This skill is ONLY for external research.** Local codebase search is handled by other cc10x tools (Grep/Glob/Read).\n\n## The Iron Law\n\n```\nNO EXTERNAL RESEARCH WITHOUT CLEAR AI KNOWLEDGE GAP OR EXPLICIT USER REQUEST\n```\n\nIf AI training knowledge covers the technology well, skip external research - UNLESS user explicitly asks. This skill is for NEW technologies, complex integrations, unfamiliar APIs, and explicit user requests.\n\n## When to Use\n\n**ALWAYS invoke when:**\n- User explicitly requests research (\"research X\", \"how do others\", \"best practices\", \"find on github\", \"use octocode\")\n- Technology released after 2024 (AI knowledge cutoff)\n- Complex integration patterns (auth, payments, real-time)\n- Local debugging failed 3+ times with external service errors\n\n**NEVER invoke when:**\n- User says \"quick\" or \"simple\"\n- Standard patterns AI knows well (CRUD, REST, React basics)\n- Code review or refactoring tasks\n- Technology released before 2024 (unless user explicitly asks)\n\n**The rule:** Trust octocode for HOW. This skill only decides WHEN.\n\n## Availability Check (REQUIRED)\n\n**Before using Octocode tools, verify availability:**\n\n```\n# Try a simple package lookup to test MCP availability\nmcp__octocode__packageSearch(name=\"express\", ecosystem=\"npm\")\n```\n\n**If Octocode unavailable → Fall back to Context7 MCP**\n**If Context7 unavailable → Fall back to WebFetch**\n\n## Research Process\n\n### Phase 1: Confirm Need\n\nBefore using octocode tools, verify:\n1. User explicitly requested research? → Proceed\n2. Technology is post-2024? → Proceed\n3. Complex integration with uncertainty? → Proceed\n4. None of the above? → STOP. Use AI knowledge.\n\n### Phase 2: Let Octocode Guide the Research\n\n**Trust octocode's embedded guidance.** It will:\n- Select the right tools and order\n- Optimize queries for token efficiency\n- Handle pagination and error recovery\n\n**Your job:** Provide clear research goals in the tool parameters:\n- `mainResearchGoal`: The overall question you're trying to answer\n- `researchGoal`: What this specific query seeks to find\n- `reasoning`: Why this query helps answer the main goal\n\n### Phase 3: Summarize for cc10x Memory\n\nExtract only what's needed for the task at hand:\n- Key patterns/approaches found\n- Gotchas or warnings discovered\n- Specific code snippets (minimal)\n- Links for future reference\n\n**DO NOT dump entire files - summarize and cite.**\n\n## Fallback Chain\n\n```\nTIER 1: Octocode MCP → TIER 2: Context7 MCP → TIER 3: WebFetch\n```\n\nTry each tier in order. Fall back only if current tier is unavailable or fails.\n\n**NO LOCAL SEARCH** - This skill is for external research only. Local codebase search uses Grep/Glob/Read directly.\n\n## Output Format\n\n```markdown\n## External Research Summary\n\n**Knowledge Gap**: [What we didn't know]\n\n**Research Conducted**:\n- Source: [repo/docs URL]\n- Query: [what we searched]\n\n**Key Findings**:\n1. [Pattern/approach found]\n2. [Gotcha or warning]\n3. [Relevant code snippet - minimal]\n\n**Application to Task**:\n[How this applies to current work]\n\n**References Saved**:\n- [URL for future debugging]\n```\n\n## Integration Points\n\n**Two-Phase Execution (via cc10x-router):**\n\nThe router executes research BEFORE invoking agents. This is NOT a hint - it's a prerequisite.\n\n```\n1. Router detects github-research trigger (explicit request OR knowledge gap)\n2. Router executes octocode tools directly (this skill's guidance)\n3. Router passes research results to agent in prompt\n```\n\n**Research results passed to:**\n- `planner` agent - For informed planning decisions\n- `bug-investigator` agent - For external error patterns\n\n**Never used during:**\n- `code-reviewer` - Review focuses on code itself\n- `silent-failure-hunter` - Speed is priority\n- `integration-verifier` - Verification, not research\n\n## Save Research (MANDATORY)\n\n**Research insights are LOST after context compaction unless saved.** This section is NON-NEGOTIABLE.\n\n### Step 1: Save Research File\n\n```\n# Create directory (permission-free)\nBash(command=\"mkdir -p docs/research\")\n\n# Save research using Write tool (permission-free for new files)\nWrite(file_path=\"docs/research/YYYY-MM-DD-<topic>-research.md\", content=\"[full research from Output Format above]\")\n```\n\n**File naming convention:** `YYYY-MM-DD-<topic>-research.md`\n- Use today's date\n- Use kebab-case for topic (e.g., `claude-code-tasks-system`, `react-server-components`)\n\n### ATOMIC CHECKPOINT (DO NOT PROCEED UNTIL BOTH COMPLETE)\n\n**The next two operations MUST complete in sequence with NO agent invocations between them:**\n- ✓ Research file saved to docs/research/\n- ⏸️ IMMEDIATELY proceed to Step 2 (do not invoke agents, do not pass go)\n\n**Why this is critical:** If context compaction occurs between Step 1 and Step 2, the research file becomes orphaned (exists but not indexed in memory). These two operations must be atomic.\n\n### Step 2: Update Memory (Links Research to Memory)\n\n**CRITICAL: This must happen in the same execution block as Step 1**\n\n**Use Edit tool (permission-free):**\n\n```\n# First read existing content\nRead(file_path=\".claude/cc10x/activeContext.md\")\n\n# Then append to Research References section using Edit\nEdit(file_path=\".claude/cc10x/activeContext.md\",\n     old_string=\"## Research References\",\n     new_string=\"## Research References\n| [Topic] | docs/research/YYYY-MM-DD-topic-research.md | [Key insight from findings] |\")\n```\n\n**If Research References section doesn't exist, add it:**\n```\nEdit(file_path=\".claude/cc10x/activeContext.md\",\n     old_string=\"## Last Updated\",\n     new_string=\"## Research References\n| Topic | File | Key Insight |\n|-------|------|-------------|\n| [Topic] | docs/research/YYYY-MM-DD-topic-research.md | [Key insight] |\n\n## Last Updated\")\n```\n\n### Step 3: Extract Patterns (Auto-Promote Learnings)\n\n**If research found gotchas or reusable patterns, add to patterns.md:**\n\n```\nRead(file_path=\".claude/cc10x/patterns.md\")\n\nEdit(file_path=\".claude/cc10x/patterns.md\",\n     old_string=\"## Common Gotchas\",\n     new_string=\"## Common Gotchas\n- [Gotcha from research]: [Solution] (Source: docs/research/YYYY-MM-DD-topic-research.md)\")\n```\n\n**What to extract:**\n- Error patterns and their solutions\n- API quirks and workarounds\n- Integration gotchas\n- Best practices discovered\n\n**What NOT to extract:**\n- Task-specific implementation details\n- One-time findings not applicable to future work\n- Raw code snippets without context\n\n### Step 4: Commit Research (Optional but Recommended)\n\n```\nBash(command=\"git add docs/research/*.md\")\nBash(command=\"git commit -m 'docs: add <topic> research'\")\n```\n\n## Red Flags - Research NOT Complete\n\nIf you finish research WITHOUT:\n- [ ] Saving to `docs/research/YYYY-MM-DD-topic-research.md`\n- [ ] Updating `activeContext.md` with research reference\n- [ ] Extracting patterns to `patterns.md` (if applicable)\n\n**STOP. Research is NOT complete. Go back and save.**\n\n## Why This Matters\n\n```\nWITHOUT SAVE:\nResearch → Context compaction → LOST FOREVER\n\nWITH SAVE:\nResearch → docs/research/ → Memory reference → PERSISTS ACROSS SESSIONS\n         → patterns.md → LEARNINGS COMPOUND\n```\n\n**Research without documentation is wasted effort.**\n",
        "plugins/cc10x/skills/planning-patterns/SKILL.md": "---\nname: planning-patterns\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob, AskUserQuestion\n---\n\n# Writing Plans\n\n## Overview\n\nWrite comprehensive implementation plans assuming the engineer has zero context for the codebase and questionable taste. Document everything they need to know: which files to touch for each task, code, testing, docs they might need to check, how to test it. Give them the whole plan as bite-sized tasks. DRY. YAGNI. TDD. Frequent commits.\n\nAssume they are a skilled developer, but know almost nothing about the toolset or problem domain. Assume they don't know good test design very well.\n\n**Core principle:** Plans must be executable without asking questions.\n\n## The Iron Law\n\n```\nNO VAGUE STEPS - EVERY STEP IS A SPECIFIC ACTION\n```\n\n\"Add validation\" is not a step. \"Write test for empty email, run it, implement check, run it, commit\" - that's 5 steps.\n\n## Bite-Sized Task Granularity\n\n**Each step is one action (2-5 minutes):**\n\n- \"Write the failing test\" - step\n- \"Run it to make sure it fails\" - step\n- \"Implement the minimal code to make the test pass\" - step\n- \"Run the tests and make sure they pass\" - step\n- \"Commit\" - step\n\n**Not a step:**\n\n- \"Add authentication\" (too vague)\n- \"Implement the feature\" (multiple actions)\n- \"Test it\" (which tests? how?)\n\n## Plan Document Header\n\n**Every plan MUST start with this header:**\n\n```markdown\n# [Feature Name] Implementation Plan\n\n> **For Claude:** REQUIRED: Follow this plan task-by-task using TDD.\n> **Design:** See `docs/plans/YYYY-MM-DD-<feature>-design.md` for full specification.\n\n**Goal:** [One sentence describing what this builds]\n\n**Architecture:** [2-3 sentences about approach]\n\n**Tech Stack:** [Key technologies/libraries]\n\n**Prerequisites:** [What must exist before starting]\n\n---\n```\n\n**Note:** If a design document exists, always reference it in the header.\n\n## Task Structure\n\n```markdown\n### Task N: [Component Name]\n\n**Files:**\n- Create: `exact/path/to/file.ts`\n- Modify: `exact/path/to/existing.ts:123-145`\n- Test: `tests/exact/path/to/test.ts`\n\n**Step 1: Write the failing test**\n\n```typescript\ntest('specific behavior being tested', () => {\n  const result = functionName(input);\n  expect(result).toBe(expected);\n});\n```\n\n**Step 2: Run test to verify it fails**\n\nRun: `npm test tests/path/test.ts -- --grep \"specific behavior\"`\nExpected: FAIL with \"functionName is not defined\"\n\n**Step 3: Write minimal implementation**\n\n```typescript\nfunction functionName(input: InputType): OutputType {\n  return expected;\n}\n```\n\n**Step 4: Run test to verify it passes**\n\nRun: `npm test tests/path/test.ts -- --grep \"specific behavior\"`\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add tests/path/test.ts src/path/file.ts\ngit commit -m \"feat: add specific feature\"\n```\n```\n\n## Context is King (Cole Medin Principle)\n\n**The plan must contain ALL information for a single-pass implementation.**\n\nA developer with zero codebase context should be able to execute the plan WITHOUT asking any questions.\n\n### Context References Section (MUST READ!)\n\n**Every plan MUST include a Context References section:**\n\n```markdown\n## Relevant Codebase Files\n\n### Patterns to Follow\n- `src/components/Button.tsx` (lines 15-45) - Component structure pattern\n- `src/services/api.ts` (lines 23-67) - API service pattern\n\n### Configuration Files\n- `tsconfig.json` - TypeScript settings\n- `.env.example` - Environment variables needed\n\n### Related Documentation\n- `docs/architecture.md#authentication` - Auth flow overview\n- `README.md#running-tests` - Test commands\n```\n\n**Why:** Claude forgets context. External docs get stale. File:line references are always accurate.\n\n## Validation Levels\n\n**Match validation depth to plan complexity:**\n\n| Level | Name | Commands | When |\n|-------|------|----------|------|\n| 1 | Syntax & Style | `npm run lint`, `tsc --noEmit` | Every task |\n| 2 | Unit Tests | `npm test` | Low-Medium risk |\n| 3 | Integration Tests | `npm run test:integration` | Medium-High risk |\n| 4 | Manual Validation | User flow walkthrough | High-Critical risk |\n\n**Include specific validation commands in each task step.**\n\n## Requirements Checklist\n\nBefore writing a plan:\n\n- [ ] Problem statement clear\n- [ ] Users identified\n- [ ] Functional requirements listed\n- [ ] Non-functional requirements listed (performance, security, scale)\n- [ ] Constraints documented\n- [ ] Success criteria defined\n- [ ] Existing code patterns understood\n- [ ] Context References section prepared with file:line references\n\n## Risk Assessment Table\n\nFor each identified risk:\n\n| Risk | Probability (1-5) | Impact (1-5) | Score | Mitigation |\n|------|-------------------|--------------|-------|------------|\n| API timeout | 3 | 4 | 12 | Retry with backoff |\n| Invalid input | 4 | 2 | 8 | Validation layer |\n| Auth bypass | 2 | 5 | 10 | Security review |\n\nScore = Probability × Impact. Address risks with score > 8 first.\n\n## Risk-Based Testing Matrix\n\n**Match testing depth to task risk:**\n\n| Task Risk | Example | Tests Required |\n|-----------|---------|----------------|\n| Trivial | Typo fix, docs update | None |\n| Low | Single file change, utility function | Unit tests only |\n| Medium | Multi-file feature, new component | Unit + Integration tests |\n| High | Cross-service, auth, state management | Unit + Integration + E2E tests |\n| Critical | Payments, security, data migrations | All tests + Security audit |\n\n**How to assess risk:**\n- How many files touched? (1 = low, 3+ = medium, cross-service = high)\n- Is it auth/payments/security? (always high or critical)\n- Is it user-facing? (medium minimum)\n- Can it cause data loss? (high or critical)\n\n**Use this matrix when planning test steps. Don't over-test trivial changes. Don't under-test critical ones.**\n\n## Functionality Flow Mapping\n\nBefore planning, document all flows:\n\n**User Flow:**\n```\n1. User clicks [button]\n2. System shows [form]\n3. User enters [data]\n4. System validates [input]\n5. System saves [data]\n6. System shows [confirmation]\n```\n\n**Admin Flow:**\n```\n1. Admin opens [dashboard]\n2. Admin selects [item]\n3. System shows [details]\n4. Admin changes [setting]\n5. System applies [change]\n```\n\n**System Flow:**\n```\n1. Request arrives at [endpoint]\n2. Middleware validates [auth]\n3. Controller calls [service]\n4. Service queries [database]\n5. Response returns [data]\n```\n\n## Architecture Decision Records (ADR)\n\n**When comparing approaches, document the decision formally:**\n\nUse this format when a plan involves choosing between multiple valid approaches:\n\n```markdown\n## ADR: [Decision Title]\n\n**Context:** What situation or requirement prompted this decision?\n\n**Decision:** What approach did we choose?\n\n**Consequences:**\n- **Positive:** [benefits of this choice]\n- **Negative:** [tradeoffs we accept]\n- **Alternatives Considered:** [what we didn't choose and why]\n```\n\n**When to use ADR:**\n- Choosing between architectures (monolith vs microservices)\n- Selecting libraries/frameworks (React vs Vue)\n- Database decisions (SQL vs NoSQL)\n- Authentication approaches (JWT vs sessions)\n\n**Save ADRs to:** `docs/decisions/ADR-NNN-title.md`\n\n## Red Flags - STOP and Revise\n\nIf you find yourself:\n\n- Writing \"add feature\" without exact file paths\n- Skipping the test step\n- Combining multiple actions into one step\n- Using \"etc.\" or \"similar\" instead of explicit steps\n- Planning without understanding existing code patterns\n- Creating steps that take more than 5 minutes\n- Not including expected output for test commands\n\n**STOP. Revise the plan with more specific steps.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"They'll know what I mean\" | No they won't. Be explicit. |\n| \"Too much detail is annoying\" | Vague plans cause bugs. |\n| \"Testing is obvious\" | Write the test command. |\n| \"File paths are discoverable\" | Write the exact path. |\n| \"Commits are implied\" | Write when to commit. |\n| \"They can figure out edge cases\" | List every edge case. |\n\n## Output Format\n\n```markdown\n# [Feature Name] Implementation Plan\n\n> **For Claude:** REQUIRED: Follow this plan task-by-task using TDD.\n\n**Goal:** [One sentence]\n\n**Architecture:** [2-3 sentences]\n\n**Tech Stack:** [Technologies]\n\n**Prerequisites:** [Requirements]\n\n---\n\n## Phase 1: [Demonstrable Milestone]\n\n> **Exit Criteria:** [What must be true when this phase is complete - e.g., \"User can log in and receive JWT\"]\n\n### Task 1: [First Component]\n\n**Files:**\n- Create: `src/path/file.ts`\n- Test: `tests/path/file.test.ts`\n\n**Step 1:** Write failing test\n[code block with test]\n\n**Step 2:** Run test, verify fails\nRun: `[command]`\nExpected: FAIL\n\n**Step 3:** Implement\n[code block with implementation]\n\n**Step 4:** Run test, verify passes\nRun: `[command]`\nExpected: PASS\n\n**Step 5:** Commit\n```bash\ngit add [files]\ngit commit -m \"feat: [description]\"\n```\n\n### Task 2: [Second Component]\n...\n\n---\n\n## Risks\n\n| Risk | P | I | Score | Mitigation |\n|------|---|---|-------|------------|\n| ... | ... | ... | ... | ... |\n\n---\n\n## Success Criteria\n\n- [ ] All tests pass\n- [ ] Feature works as specified\n- [ ] No regressions\n- [ ] Code reviewed\n```\n\n## Save the Plan (MANDATORY)\n\n**Two saves are required - plan file AND memory update:**\n\n### Step 1: Save Plan File (Use Write tool - NO PERMISSION NEEDED)\n\n```\n# First create directory\nBash(command=\"mkdir -p docs/plans\")\n\n# Then save plan using Write tool (permission-free)\nWrite(file_path=\"docs/plans/YYYY-MM-DD-<feature>-plan.md\", content=\"[full plan content from output format above]\")\n\n# Then commit (separate commands to avoid permission prompt)\nBash(command=\"git add docs/plans/*.md\")\nBash(command=\"git commit -m 'docs: add <feature> implementation plan'\")\n```\n\n### Step 2: Update Memory (CRITICAL - Links Plan to Memory)\n\n**Use Edit tool (NO permission prompt):**\n\n```\n# First read existing content\nRead(file_path=\".claude/cc10x/activeContext.md\")\n\n# Then use Edit to replace (matches first line, replaces entire content)\nEdit(file_path=\".claude/cc10x/activeContext.md\",\n     old_string=\"# Active Context\",\n     new_string=\"# Active Context\n\n## Current Focus\nPlan created for [feature]. Ready for execution.\n\n## Recent Changes\n- Plan saved to docs/plans/YYYY-MM-DD-<feature>-plan.md\n\n## Next Steps\n1. Execute plan at docs/plans/YYYY-MM-DD-<feature>-plan.md\n2. Follow TDD cycle for each task\n3. Update progress.md after each task\n\n## Active Decisions\n| Decision | Choice | Why |\n|----------|--------|-----|\n| [Key decisions from plan] | [Choice] | [Reason] |\n\n## Plan Reference\n**Execute:** `docs/plans/YYYY-MM-DD-<feature>-plan.md`\n\n## Last Updated\n[current date/time]\")\n```\n\n**Also append to progress.md using Edit:**\n```\nRead(file_path=\".claude/cc10x/progress.md\")\n\nEdit(file_path=\".claude/cc10x/progress.md\",\n     old_string=\"[last section heading]\",\n     new_string=\"[last section heading]\n\n## Plan Created\n- [x] Plan saved - docs/plans/YYYY-MM-DD-<feature>-plan.md\")\n```\n\n**WHY BOTH:** Plan files are artifacts. Memory is the index. Without memory update, next session won't know the plan exists.\n\n**This is non-negotiable.** Memory is the single source of truth.\n\n## Task-Based Execution Tracking\n\nAfter saving plan, create execution tasks for tracking progress:\n\n### Step 1: Create Parent Task\n```\nTaskCreate({\n  subject: \"Execute: {feature} Plan\",\n  description: \"Plan file: docs/plans/YYYY-MM-DD-{feature}-plan.md\\n\\n{brief_plan_summary}\",\n  activeForm: \"Executing {feature} plan\",\n  metadata: {\n    planFile: \"docs/plans/YYYY-MM-DD-{feature}-plan.md\",\n    workflow: \"PLAN_EXECUTION\",\n    feature: \"{feature}\"\n  }\n})\n# Returns parent_task_id\n```\n\n### Step 2: Create Phase Tasks with Dependencies\n```\n# For each phase in plan:\nTaskCreate({\n  subject: \"Phase 1: {phase_title}\",\n  description: \"**Plan:** docs/plans/YYYY-MM-DD-{feature}-plan.md\\n**Section:** Phase 1\\n**Exit Criteria:** {demonstrable_milestone}\\n\\n{phase_details}\",\n  activeForm: \"Working on {phase_title}\",\n  metadata: {\n    planFile: \"docs/plans/YYYY-MM-DD-{feature}-plan.md\",\n    phase: \"1\",\n    phaseTitle: \"{phase_title}\"\n  }\n})\n# Returns phase_1_id\n\nTaskCreate({\n  subject: \"Phase 2: {phase_title}\",\n  description: \"**Plan:** docs/plans/YYYY-MM-DD-{feature}-plan.md\\n**Section:** Phase 2\\n**Exit Criteria:** {demonstrable_milestone}\\n\\n{phase_details}\",\n  activeForm: \"Working on {phase_title}\",\n  metadata: {\n    planFile: \"docs/plans/YYYY-MM-DD-{feature}-plan.md\",\n    phase: \"2\",\n    phaseTitle: \"{phase_title}\"\n  }\n})\nTaskUpdate({ taskId: phase_2_id, addBlockedBy: [phase_1_id] })\n\n# Continue for all phases...\n```\n\n### Step 3: Store Task IDs in Memory\n\nUpdate `.claude/cc10x/progress.md` with task IDs:\n```\nEdit(file_path=\".claude/cc10x/progress.md\",\n     old_string=\"## Current Workflow\",\n     new_string=\"## Current Workflow\nPLAN → Execution\n\n## Active Workflow Tasks\n\n| Task ID | Subject | Status | Blocked By |\n|---------|---------|--------|------------|\n| {parent_id} | Execute: {feature} Plan | pending | - |\n| {phase_1_id} | Phase 1: {title} | pending | - |\n| {phase_2_id} | Phase 2: {title} | pending | {phase_1_id} |\n\nLast Updated: {timestamp}\")\n```\n\n**WHY:** Tasks enable resume capability across sessions. If conversation compacts or session ends, TaskList() will show where to continue.\n\n## Plan-Task Linkage (Context Preservation)\n\n**The relationship between Plan Files and Tasks:**\n\n```\n┌─────────────────────────────────────────────────────────────────────┐\n│  PLAN FILE (Persistent - Source of Truth)                           │\n│  Location: docs/plans/YYYY-MM-DD-{feature}-plan.md                 │\n│  Contains: Full implementation details, TDD steps, file paths      │\n│  Survives: Session close, context compaction, conversation reset   │\n└─────────────────────────────────────────────────────────────────────┘\n                              ↕ metadata.planFile links them\n┌─────────────────────────────────────────────────────────────────────┐\n│  TASKS (Session-Scoped - Execution Engine)                          │\n│  Storage: In-memory (ephemeral per session)                        │\n│  Contains: Status, dependencies, progress tracking                 │\n│  Survives: Within session only (unless using TASK_LIST_ID)         │\n└─────────────────────────────────────────────────────────────────────┘\n```\n\n**metadata.planFile is CRITICAL:** If context compacts mid-execution, the task description contains enough info to:\n1. Find the plan file\n2. Locate the exact phase/task\n3. Continue without asking questions\n\n**Phase Exit Criteria are CRITICAL:** Each phase MUST have a demonstrable milestone (not arbitrary naming):\n- ❌ \"Phase 1: Foundation\" - Vague, when is it done?\n- ✅ \"Phase 1: User can authenticate\" - Demonstrable, testable\n\n## Execution Handoff\n\nAfter saving the plan, offer execution choice:\n\n**\"Plan complete and saved to `docs/plans/<filename>.md`. Two execution options:**\n\n**1. Subagent-Driven (this session)** - Fresh subagent per task, review between tasks, fast iteration\n\n**2. Manual Execution** - Follow plan step by step, verify each step\n\n**Which approach?\"**\n\n## Remember\n\n- Exact file paths always\n- Complete code in plan (not \"add validation\")\n- Exact commands with expected output\n- DRY, YAGNI, TDD, frequent commits\n- Each step = one action (2-5 minutes)\n- No assumptions about context\n",
        "plugins/cc10x/skills/session-memory/SKILL.md": "---\nname: session-memory\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Write, Edit, Bash\n---\n\n# Session Memory (MANDATORY)\n\n## The Iron Law\n\n```\nEVERY WORKFLOW MUST:\n1. LOAD memory at START (and before key decisions)\n2. UPDATE memory at END (and after learnings/decisions)\n```\n\n### READ Side (Equally Important)\n**If memory is not loaded:** You work blind, repeat mistakes, lose context.\n**If decisions made without checking memory:** You contradict prior choices, waste effort.\n\n### WRITE Side\n**If memory is not updated:** Next session loses everything learned.\n**If learnings not recorded:** Same mistakes will be repeated.\n\n**BOTH SIDES ARE NON-NEGOTIABLE.**\n\n## Permission-Free Operations (CRITICAL)\n\n**ALL memory operations are PERMISSION-FREE using the correct tools.**\n\n| Operation | Tool | Permission |\n|-----------|------|------------|\n| Create memory directory | `Bash(command=\"mkdir -p .claude/cc10x\")` | FREE |\n| **Read memory files** | `Read(file_path=\".claude/cc10x/activeContext.md\")` | **FREE** |\n| **Create NEW memory file** | `Write(file_path=\"...\", content=\"...\")` | **FREE** (file doesn't exist) |\n| **Update EXISTING memory** | `Edit(file_path=\"...\", old_string=\"...\", new_string=\"...\")` | **FREE** |\n| Save plan/design files | `Write(file_path=\"docs/plans/...\", content=\"...\")` | FREE |\n\n### CRITICAL: Write vs Edit\n\n| Tool | Use For | Asks Permission? |\n|------|---------|------------------|\n| **Write** | Creating NEW files | NO (if file doesn't exist) |\n| **Write** | Overwriting existing files | **YES - asks \"Do you want to overwrite?\"** |\n| **Edit** | Updating existing files | **NO - always permission-free** |\n\n**RULE: Use Write for NEW files, Edit for UPDATES.**\n\n### CRITICAL: Use Read Tool, NOT Bash(cat)\n\n**NEVER use Bash compound commands** (`mkdir && cat`) - they ASK PERMISSION.\n**ALWAYS use Read tool** for reading files - it's PERMISSION-FREE.\n\n```\n# WRONG (asks permission - compound Bash command)\nmkdir -p .claude/cc10x && cat .claude/cc10x/activeContext.md\n\n# RIGHT (permission-free - separate tools)\nBash(command=\"mkdir -p .claude/cc10x\")\nRead(file_path=\".claude/cc10x/activeContext.md\")\n```\n\n**NEVER use heredoc writes** (`cat > file << 'EOF'`) - they ASK PERMISSION.\n**Use Write for NEW files, Edit for EXISTING files.**\n\n```\n# WRONG (asks permission - heredoc)\ncat > .claude/cc10x/activeContext.md << 'EOF'\ncontent here\nEOF\n\n# RIGHT for NEW files (permission-free)\nWrite(file_path=\".claude/cc10x/activeContext.md\", content=\"content here\")\n\n# RIGHT for EXISTING files (permission-free)\nEdit(file_path=\".claude/cc10x/activeContext.md\",\n     old_string=\"# Active Context\",\n     new_string=\"# Active Context\\n\\n[new content]\")\n```\n\n## Why This Matters\n\n> \"My memory resets between sessions. The Memory Bank is my ONLY link to previous work.\"\n\nWithout memory persistence:\n- Context lost on conversation compaction\n- Patterns relearned from scratch\n- Decisions forgotten and remade differently\n- Progress tracking lost\n- Same mistakes repeated\n\n**Memory is the difference between an expert who learns and a novice who forgets.**\n\n## Memory Structure\n\n```\n.claude/\n└── cc10x/\n    ├── activeContext.md   # Current focus + learnings + decisions (MOST IMPORTANT)\n    ├── patterns.md        # Project patterns, conventions, gotchas\n    └── progress.md        # What works, what's left, verification evidence\n```\n\n## Memory Efficiency (Token-Aware Loading)\n\n### Quick Index Pattern (OPTIONAL)\n\nWhen a memory file exceeds ~200 lines, add a Quick Index at the top for faster scanning:\n\n```markdown\n## Quick Index\n| Section | Summary | Lines |\n|---------|---------|-------|\n| Current Focus | [1-line summary of active work] | 5-15 |\n| Recent Changes | [count] changes recorded | 20-50 |\n| Active Decisions | [count] decisions | 10-30 |\n| Learnings | [count] insights | 15-25 |\n| Blockers | [None / count active] | 5-10 |\n\n---\n[Rest of file content below...]\n```\n\n**When to add Quick Index:**\n- File exceeds 200 lines\n- Multiple distinct sections with significant content\n- Frequent partial reads needed\n\n**When NOT needed:**\n- File under 200 lines (most projects)\n- Simple, focused content\n- File rarely referenced\n\n### Selective Loading\n\nFor large memory files (200+ lines), agents MAY load selectively:\n\n```\n# Step 1: Load first 50 lines (Quick Index + Current Focus)\nRead(file_path=\".claude/cc10x/activeContext.md\", limit=50)\n\n# Step 2: Decide which sections are relevant to current task\n# - Building new feature → Load \"Active Decisions\", \"Patterns\"\n# - Debugging → Load \"Learnings\", \"Recent Changes\"\n# - Continuing work → Load \"Current Focus\", \"Next Steps\"\n\n# Step 3: Load specific sections using offset/limit\nRead(file_path=\".claude/cc10x/activeContext.md\", offset=100, limit=50)\n```\n\n**Selective Loading Decision Matrix:**\n| Task Type | Load First | Then Load If Needed |\n|-----------|------------|---------------------|\n| BUILD (new feature) | Current Focus, Active Decisions | Patterns, Recent Changes |\n| DEBUG (fix issue) | Learnings, Recent Changes | Blockers, Patterns |\n| REVIEW (audit code) | Patterns, Active Decisions | Recent Changes |\n| PLAN (design) | Current Focus, Active Decisions | Full file |\n| Continue session | Current Focus, Next Steps | As needed |\n\n**DEFAULT: For files under 200 lines, load the entire file. Selective loading adds complexity—only use when needed.**\n\n### Pruning Guidelines\n\nKeep memory files trim for token efficiency:\n\n**When to prune (any file exceeding 200 lines):**\n\n| Memory File | Prune By | Move To |\n|-------------|----------|---------|\n| **activeContext.md** | Archive completed decisions | patterns.md (if reusable) |\n| **activeContext.md** | Remove old \"Recent Changes\" | Keep last 10 only |\n| **activeContext.md** | Move resolved blockers | progress.md \"Completed\" |\n| **patterns.md** | Archive rarely-used patterns | Separate archive file |\n| **progress.md** | Collapse old completed items | Keep last 2 workflows |\n\n**Pruning Rules:**\n1. **Recent Changes**: Keep last 10 entries. Older changes move to git history.\n2. **Active Decisions**: Archive decisions older than 2 workflows if no longer referenced.\n3. **Learnings**: Promote repeated learnings to patterns.md, then remove from activeContext.\n4. **Completed Tasks**: Summarize completed workflows into a single line after verification.\n\n**Pruning is a READ operation first:**\n```\n# Step 1: Read and assess size\nRead(file_path=\".claude/cc10x/activeContext.md\")\n\n# Step 2: If > 200 lines, identify prunable content\n# Step 3: Move reusable content to appropriate file\n# Step 4: Edit to remove old content\n```\n\n**DO NOT prune:**\n- Active decisions still being referenced\n- Recent learnings (< 2 sessions old)\n- Unresolved blockers\n- Current focus content\n\n## Pre-Compaction Memory Safety\n\n### Context Length Awareness\n\nConversations auto-compact when they get too long. If memory isn't updated before compaction, context is lost forever.\n\n**The Risk:**\n```\nLong session → Auto-compact → Memory NOT updated → Context LOST\n```\n\n### Proactive Update Triggers\n\nUpdate memory IMMEDIATELY when you notice:\n- Extended debugging sessions (5+ error cycles)\n- Long planning discussions\n- Multi-file refactoring\n- Any session with 30+ tool calls\n- User says \"we've been at this a while\"\n\n### The Rule\n\n**When in doubt, update memory NOW.**\n\nDon't wait for workflow end. It's better to have duplicate entries than lost context.\n\n### Checkpoint Pattern\n\nDuring long sessions, periodically checkpoint:\n```\n# After significant progress, even mid-task:\nEdit(file_path=\".claude/cc10x/activeContext.md\",\n     old_string=\"## Current Focus\",\n     new_string=\"## Current Focus\n\n[Updated focus with recent progress]\n\n### Checkpoint (mid-session)\n- [Key decision made]\n- [Important learning]\n- [Current state]\")\n```\n\n### Red Flags - Update Memory NOW\n\n| Situation | Action |\n|-----------|--------|\n| \"We've made several decisions\" | Checkpoint decisions to activeContext.md |\n| \"We've been debugging for a while\" | Record learnings + what we've tried |\n| \"Let me try a different approach\" | Record why previous approach failed |\n| \"This is getting complex\" | Update memory before continuing |\n\n## Context Tiers (Reference Pattern)\n\n**Optimize context for relevance, not completeness:**\n\n### Quick Context (< 500 tokens)\nUse for simple tasks and handoffs:\n- Current task and immediate goals\n- Recent decisions affecting current work\n- Active blockers or dependencies\n\n### Full Context (< 2000 tokens)\nUse for complex tasks and session starts:\n- Project architecture overview\n- Key design decisions\n- Integration points and APIs\n- Active work streams\n\n### Archived Context (stored in memory files)\nReference when needed:\n- Historical decisions with rationale\n- Resolved issues and solutions\n- Pattern library\n- Performance benchmarks\n\n**Good context accelerates work; bad context creates confusion.**\n\n## Context Management Functions (Reference Pattern)\n\n### Context Capture (at workflow end)\n1. Extract key decisions and rationale from outputs\n2. Identify reusable patterns and solutions\n3. Document integration points between components\n4. Track unresolved issues and TODOs\n\n### Context Distribution (at workflow start)\n1. Prepare minimal, relevant context for the task\n2. Maintain a context index for quick retrieval\n3. Prune outdated or irrelevant information\n\n### Memory Management (ongoing)\n- Store critical project decisions in memory\n- Maintain a rolling summary of recent changes\n- Create context checkpoints at major milestones\n\n## File Purposes\n\n### activeContext.md (Read/Write EVERY session)\n\n**Current state of work - ALWAYS check this first:**\n\n```markdown\n# Active Context\n\n## Current Focus\n[What we're actively working on RIGHT NOW]\n\n## Recent Changes\n- [Change 1] - [file:line]\n- [Change 2] - [file:line]\n\n## Next Steps\n1. [Immediate next action]\n2. [Following action]\n3. [After that]\n\n## Active Decisions\n| Decision | Choice | Why |\n|----------|--------|-----|\n| [Decision 1] | [What we chose] | [Reasoning] |\n| [Decision 2] | [What we chose] | [Reasoning] |\n\n## Learnings This Session\n- [Insight 1]: [What we learned]\n- [Insight 2]: [What we learned]\n\n## Blockers / Issues\n- [Blocker 1]: [Status]\n\n## User Preferences Discovered\n- [Preference]: [Details]\n\n## Research References\n| Topic | File | Key Insight |\n|-------|------|-------------|\n| [Research topic] | docs/research/YYYY-MM-DD-topic-research.md | [One-line key insight] |\n\n## Last Updated\n[timestamp]\n```\n\n### patterns.md (Accumulates over time)\n\n**Project-specific knowledge that persists:**\n\n```markdown\n# Project Patterns\n\n## Architecture Patterns\n- [Pattern]: [How this project implements it]\n\n## Code Conventions\n- [Convention]: [Example]\n\n## File Structure\n- [File type]: [Where it goes, naming convention]\n\n## Testing Patterns\n- [Test type]: [How to write, where to put]\n\n## Common Gotchas\n- [Gotcha]: [How to avoid / solution]\n- [Gotcha from research]: [Solution] (Source: docs/research/YYYY-MM-DD-topic.md)\n\n## API Patterns\n- [Endpoint pattern]: [Convention used]\n\n## Error Handling\n- [Error type]: [How project handles it]\n\n## Dependencies\n- [Dependency]: [Why used, how configured]\n```\n\n### progress.md (Tracks completion)\n\n**What's done, what's not:**\n\n```markdown\n# Progress Tracking\n\n## Current Workflow\n[PLAN | BUILD | REVIEW | DEBUG]\n\n## Active Workflow Tasks\n\n**Task-based tracking for resume capability:**\n\n| Task ID | Subject | Status | Blocked By |\n|---------|---------|--------|------------|\n| {id}    | {subject} | pending/in_progress/completed | {deps} |\n\nLast Updated: {timestamp}\nWorkflow: BUILD/DEBUG/REVIEW/PLAN\n\n**Note:** Use `TaskList()` to get current state. This table is for reference/backup.\n\n## Completed\n- [x] [Task 1] - [verification evidence]\n- [x] [Task 2] - [verification evidence]\n\n## In Progress\n- [ ] [Task 3] - [current status]\n\n## Remaining\n- [ ] [Task 4]\n- [ ] [Task 5]\n\n## Verification Evidence\n| Check | Command | Result |\n|-------|---------|--------|\n| Tests | `npm test` | exit 0 (34/34) |\n| Build | `npm run build` | exit 0 |\n\n## Known Issues\n- [Issue 1]: [Status]\n\n## Evolution of Decisions\n- [Date]: [Decision changed from X to Y because Z]\n\n## Implementation Results (append-only after build)\n| Planned | Actual | Deviation Reason |\n|---------|--------|------------------|\n| [What was planned] | [What happened] | [Why it differed] |\n```\n\n## READ Triggers - When to Load Memory\n\n### ALWAYS Read (Non-Negotiable)\n\n| Trigger | Action | Why |\n|---------|--------|-----|\n| **Session start** | Load ALL 3 files | Fresh context needed |\n| **Workflow start** | Load ALL 3 files | Before BUILD/REVIEW/DEBUG/PLAN |\n| **Continuation session** | Load ALL 3 files | Resume from where we left |\n| **User says \"continue\"** | Load activeContext.md | Get current state |\n\n### Read BEFORE These Actions\n\n| Before This Action | Read This File | Why |\n|--------------------|----------------|-----|\n| **Making architectural decision** | patterns.md | Check existing patterns |\n| **Choosing implementation approach** | patterns.md + activeContext.md | Align with conventions + prior decisions |\n| **Starting to build something** | progress.md | Check if already done |\n| **Debugging an error** | activeContext.md + patterns.md | May have seen before + known gotchas |\n| **Planning next steps** | progress.md | Know what's remaining |\n| **Reviewing code** | patterns.md | Apply project conventions |\n| **Making any decision** | activeContext.md (Active Decisions table) | Check prior decisions |\n\n### Read WHEN You Notice\n\n| Situation | Action | Why |\n|-----------|--------|-----|\n| User references \"what we did\" | Load activeContext.md | Get history |\n| You're about to repeat work | Load progress.md | Check if done |\n| You're unsure of convention | Load patterns.md | Project standards |\n| Error seems familiar | Load patterns.md (Common Gotchas) | Known issues |\n| Decision feels arbitrary | Load activeContext.md | Prior reasoning |\n\n### File Selection Matrix\n\n```\nWhat do I need?              → Which file?\n─────────────────────────────────────────\nCurrent state / focus        → activeContext.md\nPrior decisions + reasoning  → activeContext.md (Active Decisions)\nWhat we learned              → activeContext.md (Learnings)\nProject conventions          → patterns.md\nHow to structure code        → patterns.md\nCommon gotchas to avoid      → patterns.md\nWhat's done / remaining      → progress.md\nVerification evidence        → progress.md\nPrior research on topic      → activeContext.md (Research References) → docs/research/\n```\n\n### Decision Integration\n\n**Before ANY decision, ask:**\n\n1. **Did we decide this before?** → Check activeContext.md Active Decisions table\n2. **Is there a project pattern?** → Check patterns.md\n3. **Did we learn something relevant?** → Check activeContext.md Learnings\n\n**If memory has relevant info:**\n- Follow prior decision (or document why changing)\n- Apply project pattern\n- Use learned insight\n\n**If memory is empty/irrelevant:**\n- Make decision\n- RECORD it in activeContext.md for next time\n\n---\n\n## Mandatory Operations\n\n### At Workflow START (REQUIRED)\n\n**Use separate tool calls (PERMISSION-FREE):**\n\n```\n# Step 1: Create directory (single Bash command - permission-free)\nBash(command=\"mkdir -p .claude/cc10x\")\n\n# Step 2: Load ALL 3 memory files using Read tool (permission-free)\nRead(file_path=\".claude/cc10x/activeContext.md\")\nRead(file_path=\".claude/cc10x/patterns.md\")\nRead(file_path=\".claude/cc10x/progress.md\")\n\n# Step 3: Git Context - Understand project state (RECOMMENDED)\nBash(command=\"git status\")                 # Current working state\nBash(command=\"git ls-files | head -50\")    # Project file structure\nBash(command=\"git log --oneline -10\")      # Recent commits\n```\n\n**NEVER use this (asks permission):**\n```bash\n# WRONG - compound command asks permission\nmkdir -p .claude/cc10x && cat .claude/cc10x/activeContext.md\n```\n\n**If file doesn't exist:** Read tool returns an error - that's fine, means starting fresh.\n\n### At Workflow END (REQUIRED)\n\n**MUST update before completing ANY workflow. Use Edit tool (NO permission prompt):**\n\n```\n# First, read the existing content\nRead(file_path=\".claude/cc10x/activeContext.md\")\n\n# Then use Edit to replace (matches first line, replaces entire content)\nEdit(file_path=\".claude/cc10x/activeContext.md\",\n     old_string=\"# Active Context\",\n     new_string=\"# Active Context\n\n## Current Focus\n[What we just finished / what's next]\n\n## Recent Changes\n- [Changes made this session]\n\n## Next Steps\n1. [What to do next]\n\n## Active Decisions\n| Decision | Choice | Why |\n|----------|--------|-----|\n| [Decisions made] | [Choice] | [Reason] |\n\n## Learnings This Session\n- [What we learned]\n\n## Last Updated\n[current date/time]\")\n```\n\n**WHY Edit not Write?** Write asks \"Do you want to overwrite?\" for existing files. Edit is always permission-free.\n\n### When Learning Patterns (APPEND)\n\n**Read existing patterns.md, then append using Edit:**\n\n```\n# Read existing content\nRead(file_path=\".claude/cc10x/patterns.md\")\n\n# Append by matching end of file and adding new content\nEdit(file_path=\".claude/cc10x/patterns.md\",\n     old_string=\"[last section heading]\",\n     new_string=\"[last section heading]\n\n## [New Category]\n- [Pattern]: [Details learned]\")\n```\n\n### When Completing Tasks (UPDATE)\n\n```\n# Read progress.md, find the task, mark it complete using Edit\nRead(file_path=\".claude/cc10x/progress.md\")\n\nEdit(file_path=\".claude/cc10x/progress.md\",\n     old_string=\"- [ ] [Task being completed]\",\n     new_string=\"- [x] [Task being completed] - [verification evidence]\")\n```\n\n## Integration with Agents\n\n**ALL agents MUST:**\n\n1. **START**: Load memory files before any work\n2. **DURING**: Note learnings and decisions\n3. **END**: Update memory files with new context\n\n**Failure to update memory = incomplete work.**\n\n## Red Flags - STOP IMMEDIATELY\n\nIf you catch yourself:\n- Starting work WITHOUT loading memory\n- Making decisions WITHOUT checking Active Decisions table\n- Completing work WITHOUT updating memory\n- Saying \"I'll remember\" instead of writing to memory\n\n**STOP. Load/update memory FIRST.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"I know what we decided\" | Check the Active Decisions table. |\n| \"Small task, no need\" | Small tasks have context too. Always update. |\n| \"I'll remember\" | You won't. Conversation compacts. Write it down. |\n| \"Memory is optional\" | Memory is MANDATORY. No exceptions. |\n\n## Verification Checklist\n\n- [ ] Memory loaded at workflow start\n- [ ] Decisions checked before making new ones\n- [ ] Learnings documented in activeContext.md\n- [ ] Progress updated in progress.md\n\n**Cannot check all boxes? Memory cycle incomplete.**\n\n## The Bottom Line\n\n```\nSTART → Load Memory → Do Work → Update Memory → END\n         ↑               ↑              ↑\n      MANDATORY    Check before    MANDATORY\n                   decisions\n```\n\n**The Full Cycle:**\n```\n1. LOAD all memory (START)\n2. CHECK memory before decisions (DURING)\n3. UPDATE memory with learnings (END)\n```\n\n**Memory persistence is not a feature. It's a requirement.**\n\nYour effectiveness depends entirely on memory accuracy. Treat it with the same importance as the code itself.\n\nREAD without WRITE = Stale memory.\nWRITE without READ = Contradictory decisions.\n**Both are equally critical.**\n",
        "plugins/cc10x/skills/test-driven-development/SKILL.md": "---\nname: test-driven-development\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob, Bash, Write, Edit\n---\n\n# Test-Driven Development (TDD)\n\n## Overview\n\nWrite the test first. Watch it fail. Write minimal code to pass.\n\n**Core principle:** If you didn't watch the test fail, you don't know if it tests the right thing.\n\n**Violating the letter of the rules is violating the spirit of the rules.**\n\n## When to Use\n\n**Always:**\n- New features\n- Bug fixes\n- Refactoring\n- Behavior changes\n\n**Exceptions (ask your human partner):**\n- Throwaway prototypes\n- Generated code\n- Configuration files\n\nThinking \"skip TDD just this once\"? Stop. That's rationalization.\n\n## The Iron Law\n\n```\nNO PRODUCTION CODE WITHOUT A FAILING TEST FIRST\n```\n\nWrite code before the test? Delete it. Start over.\n\n**No exceptions:**\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n\nImplement fresh from tests. Period.\n\n## Red-Green-Refactor\n\n```\n    ┌─────────┐       ┌─────────┐       ┌───────────┐\n    │   RED   │──────>│  GREEN  │──────>│ REFACTOR  │\n    │ (Fail)  │       │ (Pass)  │       │ (Clean)   │\n    └─────────┘       └─────────┘       └───────────┘\n         ^                                    │\n         │                                    │\n         └────────────────────────────────────┘\n                    Next Feature\n```\n\n### RED - Write Failing Test\n\nWrite one minimal test showing what should happen.\n\n**Good:**\n```typescript\ntest('retries failed operations 3 times', async () => {\n  let attempts = 0;\n  const operation = () => {\n    attempts++;\n    if (attempts < 3) throw new Error('fail');\n    return 'success';\n  };\n\n  const result = await retryOperation(operation);\n\n  expect(result).toBe('success');\n  expect(attempts).toBe(3);\n});\n```\nClear name, tests real behavior, one thing\n\n**Bad:**\n```typescript\ntest('retry works', async () => {\n  const mock = jest.fn()\n    .mockRejectedValueOnce(new Error())\n    .mockRejectedValueOnce(new Error())\n    .mockResolvedValueOnce('success');\n  await retryOperation(mock);\n  expect(mock).toHaveBeenCalledTimes(3);\n});\n```\nVague name, tests mock not code\n\n**Requirements:**\n- One behavior\n- Clear name\n- Real code (no mocks unless unavoidable)\n\n### Verify RED - Watch It Fail\n\n**MANDATORY. Never skip.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n- Test fails (not errors)\n- Failure message is expected\n- Fails because feature missing (not typos)\n\n**Test passes?** You're testing existing behavior. Fix test.\n\n**Test errors?** Fix error, re-run until it fails correctly.\n\n### GREEN - Minimal Code\n\nWrite simplest code to pass the test.\n\n**Good:**\n```typescript\nasync function retryOperation<T>(fn: () => Promise<T>): Promise<T> {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await fn();\n    } catch (e) {\n      if (i === 2) throw e;\n    }\n  }\n  throw new Error('unreachable');\n}\n```\nJust enough to pass\n\n**Bad:**\n```typescript\nasync function retryOperation<T>(\n  fn: () => Promise<T>,\n  options?: {\n    maxRetries?: number;\n    backoff?: 'linear' | 'exponential';\n    onRetry?: (attempt: number) => void;\n  }\n): Promise<T> {\n  // YAGNI - You Ain't Gonna Need It\n}\n```\nOver-engineered\n\nDon't add features, refactor other code, or \"improve\" beyond the test. Don't hard-code test values - implement general logic that works for ALL inputs.\n\n### Verify GREEN - Watch It Pass\n\n**MANDATORY.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n- Test passes\n- Other tests still pass\n- Output pristine (no errors, warnings)\n\n**Test fails?** Fix code, not test.\n\n**Other tests fail?** Fix now.\n\n### REFACTOR - Clean Up\n\nAfter green only:\n- Remove duplication\n- Improve names\n- Extract helpers\n\nKeep tests green. Don't add behavior.\n\n### Repeat\n\nNext failing test for next feature.\n\n## Good Tests\n\n| Quality | Good | Bad |\n|---------|------|-----|\n| **Minimal** | One thing. \"and\" in name? Split it. | `test('validates email and domain and whitespace')` |\n| **Clear** | Name describes behavior | `test('test1')` |\n| **Shows intent** | Demonstrates desired API | Obscures what code should do |\n\n## Factory Pattern for Tests (Reference Pattern)\n\nCreate `getMockX(overrides?: Partial<X>)` functions for reusable test data:\n\n```typescript\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  role: 'admin' | 'user';\n}\n\nconst getMockUser = (overrides?: Partial<User>): User => ({\n  id: '123',\n  name: 'John Doe',\n  email: 'john@example.com',\n  role: 'user',\n  ...overrides,\n});\n\n// Usage - override only what matters for the test\nit('shows admin badge for admin users', () => {\n  const user = getMockUser({ role: 'admin' });\n  render(<UserCard user={user} />);\n  expect(screen.getByText('Admin')).toBeTruthy();\n});\n```\n\n**Benefits:**\n- Sensible defaults - less boilerplate per test\n- Override specific properties - focus on what test cares about\n- Type-safe - catches missing properties\n- DRY - change mock in one place\n\n## Why Order Matters\n\n**\"I'll write tests after to verify it works\"**\n\nTests written after code pass immediately. Passing immediately proves nothing:\n- Might test wrong thing\n- Might test implementation, not behavior\n- Might miss edge cases you forgot\n- You never saw it catch the bug\n\nTest-first forces you to see the test fail, proving it actually tests something.\n\n**\"I already manually tested all the edge cases\"**\n\nManual testing is ad-hoc. You think you tested everything but:\n- No record of what you tested\n- Can't re-run when code changes\n- Easy to forget cases under pressure\n- \"It worked when I tried it\" ≠ comprehensive\n\nAutomated tests are systematic. They run the same way every time.\n\n**\"Deleting X hours of work is wasteful\"**\n\nSunk cost fallacy. The time is already gone. Your choice now:\n- Delete and rewrite with TDD (X more hours, high confidence)\n- Keep it and add tests after (30 min, low confidence, likely bugs)\n\nThe \"waste\" is keeping code you can't trust. Working code without real tests is technical debt.\n\n## Red Flags - STOP and Start Over\n\nIf you catch yourself:\n\n- Code before test\n- Test after implementation\n- Test passes immediately\n- Can't explain why test failed\n- Tests added \"later\"\n- Rationalizing \"just this once\"\n- \"I already manually tested it\"\n- \"Tests after achieve the same purpose\"\n- \"It's about spirit not ritual\"\n- \"Keep as reference\" or \"adapt existing code\"\n- \"Already spent X hours, deleting is wasteful\"\n- \"TDD is dogmatic, I'm being pragmatic\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Too simple to test\" | Simple code breaks. Test takes 30 seconds. |\n| \"I'll test after\" | Tests passing immediately prove nothing. |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n| \"Already manually tested\" | Ad-hoc ≠ systematic. No record, can't re-run. |\n| \"Deleting X hours is wasteful\" | Sunk cost fallacy. Keeping unverified code is technical debt. |\n| \"Keep as reference, write tests first\" | You'll adapt it. That's testing after. Delete means delete. |\n| \"Need to explore first\" | Fine. Throw away exploration, start with TDD. |\n| \"Test hard = design unclear\" | Listen to test. Hard to test = hard to use. |\n| \"TDD will slow me down\" | TDD faster than debugging. Pragmatic = test-first. |\n| \"Manual test faster\" | Manual doesn't prove edge cases. You'll re-test every change. |\n| \"Existing code has no tests\" | You're improving it. Add tests for existing code. |\n\n## Example: Bug Fix\n\n**Bug:** Empty email accepted\n\n**RED**\n```typescript\ntest('rejects empty email', async () => {\n  const result = await submitForm({ email: '' });\n  expect(result.error).toBe('Email required');\n});\n```\n\n**Verify RED**\n```bash\n$ npm test\nFAIL: expected 'Email required', got undefined\n```\n\n**GREEN**\n```typescript\nfunction submitForm(data: FormData) {\n  if (!data.email?.trim()) {\n    return { error: 'Email required' };\n  }\n  // ...\n}\n```\n\n**Verify GREEN**\n```bash\n$ npm test\nPASS\n```\n\n**REFACTOR**\nExtract validation for multiple fields if needed.\n\n## Verification Checklist\n\nBefore marking work complete:\n\n- [ ] Every new function/method has a test\n- [ ] Watched each test fail before implementing\n- [ ] Each test failed for expected reason (feature missing, not typo)\n- [ ] Wrote minimal code to pass each test\n- [ ] All tests pass\n- [ ] Output pristine (no errors, warnings)\n- [ ] Tests use real code (mocks only if unavoidable)\n- [ ] Edge cases and errors covered\n\nCan't check all boxes? You skipped TDD. Start over.\n\n## When Stuck\n\n| Problem | Solution |\n|---------|----------|\n| Don't know how to test | Write wished-for API. Write assertion first. Ask your human partner. |\n| Test too complicated | Design too complicated. Simplify interface. |\n| Must mock everything | Code too coupled. Use dependency injection. |\n| Test setup huge | Extract helpers. Still complex? Simplify design. |\n\n## Output Format\n\n```markdown\n## TDD Cycle\n\n### Requirements\n[What functionality is being built]\n\n### RED Phase\n- Test: [test name]\n- Command: `npm test -- --grep \"test name\"`\n- Result: exit 1 (FAIL as expected)\n- Failure reason: [function not defined / expected X got Y]\n\n### GREEN Phase\n- Implementation: [summary]\n- File: [path:line]\n- Command: `npm test -- --grep \"test name\"`\n- Result: exit 0 (PASS)\n\n### REFACTOR Phase\n- Changes: [what was improved]\n- Command: `npm test`\n- Result: exit 0 (all tests pass)\n```\n\n## Final Rule\n\n```\nProduction code → test exists and failed first\nOtherwise → not TDD\n```\n\nNo exceptions without your human partner's permission.\n",
        "plugins/cc10x/skills/verification-before-completion/SKILL.md": "---\nname: verification-before-completion\ndescription: \"Internal skill. Use cc10x-router for all development tasks.\"\nallowed-tools: Read, Grep, Glob, Bash\n---\n\n# Verification Before Completion\n\n## Overview\n\nClaiming work is complete without verification is dishonesty, not efficiency.\n\n**Core principle:** Evidence before claims, always.\n\n**Violating the letter of this rule is violating the spirit of this rule.**\n\n## The Iron Law\n\n```\nNO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE\n```\n\nIf you haven't run the verification command in this message, you cannot claim it passes.\n\n## The Gate Function\n\n```\nBEFORE claiming any status or expressing satisfaction:\n\n1. IDENTIFY: What command proves this claim?\n2. RUN: Execute the FULL command (fresh, complete)\n3. READ: Full output, check exit code, count failures\n4. VERIFY: Does output confirm the claim?\n   - If NO: State actual status with evidence\n   - If YES: State claim WITH evidence\n5. REFLECT: Pause to consider tool results before next action\n6. ONLY THEN: Make the claim\n\nSkip any step = lying, not verifying\n```\n\n## Common Failures\n\n| Claim | Requires | Not Sufficient |\n|-------|----------|----------------|\n| Tests pass | Test command output: 0 failures | Previous run, \"should pass\" |\n| Linter clean | Linter output: 0 errors | Partial check, extrapolation |\n| Build succeeds | Build command: exit 0 | Linter passing, logs look good |\n| Bug fixed | Test original symptom: passes | Code changed, assumed fixed |\n| Regression test works | Red-green cycle verified | Test passes once |\n| Agent completed | VCS diff shows changes | Agent reports \"success\" |\n| Requirements met | Line-by-line checklist | Tests passing |\n\n## Red Flags - STOP\n\nIf you find yourself:\n\n- Using \"should\", \"probably\", \"seems to\"\n- Expressing satisfaction before verification (\"Great!\", \"Perfect!\", \"Done!\", etc.)\n- About to commit/push/PR without verification\n- Trusting agent success reports\n- Relying on partial verification\n- Thinking \"just this once\"\n- Tired and wanting work over\n- **ANY wording implying success without having run verification**\n\n**STOP. Run verification. Get evidence. THEN speak.**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Should work now\" | RUN the verification |\n| \"I'm confident\" | Confidence ≠ evidence |\n| \"Just this once\" | No exceptions |\n| \"Linter passed\" | Linter ≠ compiler |\n| \"Agent said success\" | Verify independently |\n| \"I'm tired\" | Exhaustion ≠ excuse |\n| \"Partial check is enough\" | Partial proves nothing |\n| \"Different words so rule doesn't apply\" | Spirit over letter |\n| \"I already tested it manually\" | Manual ≠ automated evidence |\n| \"The code looks correct\" | Looking ≠ running |\n\n## Key Patterns\n\n**Tests:**\n```\n✅ [Run test command] [See: 34/34 pass] \"All tests pass\"\n❌ \"Should pass now\" / \"Looks correct\"\n```\n\n**Regression tests (TDD Red-Green):**\n```\n✅ Write → Run (pass) → Revert fix → Run (MUST FAIL) → Restore → Run (pass)\n❌ \"I've written a regression test\" (without red-green verification)\n```\n\n**Build:**\n```\n✅ [Run build] [See: exit 0] \"Build passes\"\n❌ \"Linter passed\" (linter doesn't check compilation)\n```\n\n**Requirements:**\n```\n✅ Re-read plan → Create checklist → Verify each → Report gaps or completion\n❌ \"Tests pass, phase complete\"\n```\n\n**Agent delegation:**\n```\n✅ Agent reports success → Check VCS diff → Verify changes → Report actual state\n❌ Trust agent report\n```\n\n## Why This Matters\n\nFrom real failure patterns:\n\n- Your user said \"I don't believe you\" - trust broken\n- Undefined functions shipped - would crash in production\n- Missing requirements shipped - incomplete features\n- Time wasted on false completion → redirect → rework\n- Violates: \"Honesty is a core value. If you lie, you'll be replaced.\"\n\n## When To Apply\n\n**ALWAYS before:**\n\n- ANY variation of success/completion claims\n- ANY expression of satisfaction\n- ANY positive statement about work state\n- Committing, PR creation, task completion\n- Moving to next task\n- Delegating to agents\n\n**Rule applies to:**\n\n- Exact phrases\n- Paraphrases and synonyms\n- Implications of success\n- ANY communication suggesting completion/correctness\n\n## Self-Critique Gate (BEFORE Verification Commands)\n\n**MANDATORY: Check these BEFORE running verification commands:**\n\n### Code Quality\n- [ ] Follows patterns from reference files?\n- [ ] Naming matches project conventions?\n- [ ] Error handling in place?\n- [ ] No debug artifacts (console.log, TODO)?\n- [ ] No commented-out code?\n- [ ] No hardcoded values that should be constants?\n\n### Implementation Completeness\n- [ ] All required files modified?\n- [ ] No unexpected files changed?\n- [ ] Requirements fully met?\n- [ ] No scope creep?\n\n### Self-Critique Verdict\n\n**PROCEED:** [YES/NO]\n**CONFIDENCE:** [High/Medium/Low]\n\n- If NO → Fix issues before verification\n- If YES → Proceed to verification commands below\n\n---\n\n## Validation Levels\n\n**Match validation depth to task complexity:**\n\n| Level | Name | Commands | When to Use |\n|-------|------|----------|-------------|\n| 1 | Syntax & Style | `npm run lint`, `tsc --noEmit` | Every task |\n| 2 | Unit Tests | `npm test` | Low-Medium risk tasks |\n| 3 | Integration Tests | `npm run test:integration` | Medium-High risk tasks |\n| 4 | Manual Validation | User flow walkthrough | High-Critical risk tasks |\n\n**Include the appropriate validation level for each verification step.**\n\n## Verification Checklist\n\nBefore marking work complete:\n\n- [ ] All relevant tests pass (exit 0) - **with fresh evidence**\n- [ ] Build succeeds (exit 0) - **with fresh evidence**\n- [ ] Feature functionality verified - **with command output**\n- [ ] No regressions introduced - **with test output**\n- [ ] Evidence captured for each check - **in this message**\n- [ ] Deviations from plan documented - **if implementation differed from design**\n- [ ] Appropriate validation level applied for task risk\n\n## Output Format\n\n```markdown\n## Verification Summary\n\n### Scope\n[What was completed]\n\n### Criteria\n[What was verified]\n\n### Evidence\n\n| Check | Command | Exit Code | Result |\n|-------|---------|-----------|--------|\n| Tests | `npm test` | 0 | PASS (34/34) |\n| Build | `npm run build` | 0 | PASS |\n| Feature | `npm test -- --grep \"feature\"` | 0 | PASS (3/3) |\n\n### Deviations from Plan (if any)\n| Planned | Actual | Reason |\n|---------|--------|--------|\n| [Original design] | [What changed] | [Why] |\n\n### Status\nCOMPLETE - All verifications passed with fresh evidence\n```\n\n## Goal-Backward Lens (GSD-Inspired)\n\nAfter standard verification passes, apply this additional check:\n\n### Three Questions\n1. **Truths:** What must be OBSERVABLE? (user-facing behaviors)\n2. **Artifacts:** What must EXIST? (files, endpoints, tests)\n3. **Wiring:** What must be CONNECTED? (component → API → database)\n\n### Why This Catches Stubs\nA component can:\n- Exist ✓\n- Pass lint ✓\n- Have tests ✓\n- But NOT be wired to the system ✗\n\nGoal-backward asks: \"Does the GOAL work?\" not \"Did the TASK complete?\"\n\n### Quick Check Template\n```\nGOAL: [What user wants to achieve]\n\nTRUTHS (observable):\n- [ ] [User-facing behavior 1]\n- [ ] [User-facing behavior 2]\n\nARTIFACTS (exist):\n- [ ] [Required file/endpoint 1]\n- [ ] [Required file/endpoint 2]\n\nWIRING (connected):\n- [ ] [Component] → [calls] → [API]\n- [ ] [API] → [queries] → [Database]\n\nStandard verification: exit code 0 ✓\nGoal check: All boxes checked?\n```\n\n### When to Apply\n- After integration-verifier runs\n- After any \"feature complete\" claim\n- Before marking BUILD workflow as done\n\n**Iron Law unchanged:** Exit code 0 still required. This is an additional verification lens, not a replacement.\n\n## Stub Detection Patterns\n\nAfter Goal-Backward Lens passes, scan for these stub indicators:\n\n### Universal Stubs\n```bash\n# Check for TODO/placeholder markers\ngrep -rE \"TODO|FIXME|placeholder|not implemented|coming soon\" --include=\"*.ts\" --include=\"*.tsx\" --include=\"*.js\"\n\n# Check for empty returns\ngrep -rE \"return null|return undefined|return \\{\\}|return \\[\\]\" --include=\"*.ts\" --include=\"*.tsx\"\n```\n\n### React Component Stubs\n| Pattern | Why It's a Stub |\n|---------|-----------------|\n| `return <div>Placeholder</div>` | Renders nothing useful |\n| `onClick={() => {}}` | Click does nothing |\n| `onSubmit={(e) => e.preventDefault()}` | Only prevents default, no action |\n| `useState` with no setter calls | State never changes |\n\n### API Route Stubs\n| Pattern | Why It's a Stub |\n|---------|-----------------|\n| `return Response.json({ message: \"Not implemented\" })` | Explicit stub |\n| `return Response.json([])` without DB query | Returns empty, no real data |\n| `return NextResponse.json({})` with no logic | Empty response |\n\n### Function Stubs\n| Pattern | Why It's a Stub |\n|---------|-----------------|\n| `throw new Error(\"Not implemented\")` | Will crash at runtime |\n| `console.log(\"TODO\")` | Debug artifact |\n| `// TODO: implement` | Marked incomplete |\n\n### Quick Stub Check\n```bash\n# Run before claiming completion\ngrep -rE \"(TODO|FIXME|placeholder|not implemented)\" src/\ngrep -rE \"onClick=\\{?\\(\\) => \\{\\}\\}?\" src/\ngrep -rE \"return (null|undefined|\\{\\}|\\[\\])\" src/\n```\n\n**If any stub patterns found:** DO NOT claim completion. Fix or document why it's intentional.\n\n### Wiring Verification (Component → API → Database)\n\nArtifacts can exist, pass lint, and have tests but NOT be wired to the system.\n\n**Component → API Check:**\n```bash\n# Does component actually call the API?\ngrep -E \"fetch\\(['\\\"].*api|axios\\.(get|post)\" src/components/\n# Is response actually used?\ngrep -A 5 \"fetch\\|axios\" src/components/ | grep -E \"await|\\.then|setData|setState\"\n```\n\n**API → Database Check:**\n```bash\n# Does API actually query database?\ngrep -E \"prisma\\.|db\\.|mongoose\\.\" src/app/api/\n# Is result actually returned?\ngrep -E \"return.*json.*data|Response\\.json\" src/app/api/\n```\n\n**Red Flags:**\n| Pattern | Problem |\n|---------|---------|\n| `fetch('/api/x')` with no `await` | Call ignored |\n| `await prisma.findMany()` → `return { ok: true }` | Query result discarded |\n| Handler only has `e.preventDefault()` | Form does nothing |\n\n**Line Count Minimums:**\n| File Type | Minimum Lines | Below = Likely Stub |\n|-----------|---------------|---------------------|\n| Component | 15 | Too thin |\n| API route | 10 | Too thin |\n| Hook/util | 10 | Too thin |\n\n## The Bottom Line\n\n**No shortcuts for verification.**\n\nRun the command. Read the output. THEN claim the result.\n\nThis is non-negotiable.\n"
      },
      "plugins": [
        {
          "name": "cc10x",
          "description": "Orchestrated development workflow with specialized subagents and composable skills. Features smart routing via cc10x-router, TDD-first building, multi-dimensional code review, evidence-based debugging, pre-implementation checklists, self-critique gates, and 7-layer memory architecture.",
          "version": "5.25.2",
          "author": {
            "name": "Rom Iluz",
            "email": "rom@iluz.net",
            "url": "https://github.com/romiluz13"
          },
          "homepage": "https://github.com/romiluz13/cc10x",
          "repository": "https://github.com/romiluz13/cc10x",
          "license": "MIT",
          "keywords": [
            "workflow-routing",
            "code-review",
            "tdd",
            "debugging",
            "planning",
            "memory-persistence",
            "session-memory",
            "verification",
            "lean-skills",
            "claude-code"
          ],
          "category": "development-tools",
          "source": "./plugins/cc10x",
          "categories": [
            "claude-code",
            "code-review",
            "debugging",
            "development-tools",
            "lean-skills",
            "memory-persistence",
            "planning",
            "session-memory",
            "tdd",
            "verification",
            "workflow-routing"
          ],
          "install_commands": [
            "/plugin marketplace add romiluz13/cc10x",
            "/plugin install cc10x@cc10x"
          ]
        }
      ]
    }
  ]
}