{
  "author": {
    "id": "gaarutyunov",
    "display_name": "German Arutyunov",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/36804225?u=b0c60badab41aeb1fdc849d6fb30d06850af69e7&v=4",
    "url": "https://github.com/gaarutyunov",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 0,
      "total_skills": 5,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "dev-skills",
      "version": null,
      "description": "Personal collection of skills for infrastructure tools - CLIs, APIs, and SDKs",
      "owner_info": {
        "name": "German Arutyunov"
      },
      "keywords": [],
      "repo_full_name": "gaarutyunov/dev-skills",
      "repo_url": "https://github.com/gaarutyunov/dev-skills",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-23T20:43:38Z",
        "created_at": "2025-12-19T01:26:08Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 927
        },
        {
          "path": "bazel",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 369
        },
        {
          "path": "bazel/README.md",
          "type": "blob",
          "size": 1165
        },
        {
          "path": "bazel/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/skills/developing-bazel-rules",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/skills/developing-bazel-rules/SKILL.md",
          "type": "blob",
          "size": 5175
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/api-reference.md",
          "type": "blob",
          "size": 5649
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/go-patterns.md",
          "type": "blob",
          "size": 6661
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/providers.md",
          "type": "blob",
          "size": 4637
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/testing.md",
          "type": "blob",
          "size": 5739
        },
        {
          "path": "bazel/skills/developing-bazel-rules/references/toolchains.md",
          "type": "blob",
          "size": 5565
        },
        {
          "path": "gitea",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 334
        },
        {
          "path": "gitea/README.md",
          "type": "blob",
          "size": 1721
        },
        {
          "path": "gitea/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/go-sdk",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/go-sdk/SKILL.md",
          "type": "blob",
          "size": 3375
        },
        {
          "path": "gitea/skills/go-sdk/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/go-sdk/references/api-reference.md",
          "type": "blob",
          "size": 9925
        },
        {
          "path": "gitea/skills/go-sdk/references/examples.md",
          "type": "blob",
          "size": 9353
        },
        {
          "path": "gitea/skills/go-sdk/references/types.md",
          "type": "blob",
          "size": 6247
        },
        {
          "path": "gitea/skills/tea-cli",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/tea-cli/SKILL.md",
          "type": "blob",
          "size": 2557
        },
        {
          "path": "gitea/skills/tea-cli/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "gitea/skills/tea-cli/references/authentication.md",
          "type": "blob",
          "size": 1974
        },
        {
          "path": "gitea/skills/tea-cli/references/commands.md",
          "type": "blob",
          "size": 5547
        },
        {
          "path": "gitea/skills/tea-cli/references/workflows.md",
          "type": "blob",
          "size": 3477
        },
        {
          "path": "hetzner",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 377
        },
        {
          "path": "hetzner/README.md",
          "type": "blob",
          "size": 1395
        },
        {
          "path": "hetzner/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-cli",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-cli/SKILL.md",
          "type": "blob",
          "size": 4352
        },
        {
          "path": "hetzner/skills/hcloud-cli/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-cli/references/commands.md",
          "type": "blob",
          "size": 10639
        },
        {
          "path": "hetzner/skills/hcloud-cli/references/configuration.md",
          "type": "blob",
          "size": 3627
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk/SKILL.md",
          "type": "blob",
          "size": 4388
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk/references/api-reference.md",
          "type": "blob",
          "size": 14949
        },
        {
          "path": "hetzner/skills/hcloud-go-sdk/references/patterns.md",
          "type": "blob",
          "size": 9633
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"dev-skills\",\n  \"description\": \"Personal collection of skills for infrastructure tools - CLIs, APIs, and SDKs\",\n  \"owner\": {\n    \"name\": \"German Arutyunov\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"gitea\",\n      \"description\": \"Skills for Gitea: tea CLI operations and Go SDK development\",\n      \"version\": \"1.0.0\",\n      \"source\": \"./gitea\",\n      \"author\": {\n        \"name\": \"German Arutyunov\"\n      }\n    },\n    {\n      \"name\": \"hetzner\",\n      \"description\": \"Skills for Hetzner Cloud: hcloud CLI operations and Go SDK development\",\n      \"version\": \"1.0.0\",\n      \"source\": \"./hetzner\",\n      \"author\": {\n        \"name\": \"German Arutyunov\"\n      }\n    },\n    {\n      \"name\": \"bazel\",\n      \"description\": \"Skills for developing custom Bazel rules, toolchains, providers, and aspects\",\n      \"version\": \"1.0.0\",\n      \"source\": \"./bazel\",\n      \"author\": {\n        \"name\": \"German Arutyunov\"\n      }\n    }\n  ]\n}\n",
        "bazel/.claude-plugin/plugin.json": "{\n  \"name\": \"bazel\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Skills for developing custom Bazel rules, toolchains, providers, and aspects\",\n  \"author\": {\n    \"name\": \"German Arutyunov\"\n  },\n  \"repository\": \"https://github.com/germanarutyunov/dev-skills\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"bazel\", \"starlark\", \"rules\", \"toolchains\", \"providers\", \"aspects\", \"build\"]\n}\n",
        "bazel/README.md": "# Bazel Rules Development Skills\n\nSkills for developing custom Bazel rules, toolchains, providers, and aspects.\n\n## Skills Included\n\n### developing-bazel-rules\n\nUse when creating custom Bazel rules for new languages, build systems, or tools.\n\nCovers:\n- Rule structure and implementation patterns\n- Provider design for dependency propagation\n- Efficient use of depsets for transitive data\n- Action registration and execution\n- Toolchain development for cross-platform support\n- Testing Bazel rules with analysistest\n- Patterns from production rulesets (rules_go)\n\n## Installation\n\nAdd to your Claude Code plugins:\n\n```bash\nclaude plugins add bazel@dev-skills\n```\n\n## Reference Documentation\n\nThe skill includes detailed reference files:\n- `api-reference.md` - Starlark API quick reference\n- `providers.md` - Provider design patterns\n- `toolchains.md` - Toolchain development guide\n- `testing.md` - Testing Bazel rules\n- `go-patterns.md` - Patterns from rules_go\n\n## Resources\n\n- [Bazel Rules API](https://bazel.build/rules/lib)\n- [rules_go source](https://github.com/bazel-contrib/rules_go)\n- [Bazel examples](https://github.com/bazelbuild/examples/tree/main/rules)\n",
        "bazel/skills/developing-bazel-rules/SKILL.md": "---\nname: developing-bazel-rules\ndescription: Use when creating custom Bazel rules, toolchains, providers, or aspects. Use when extending Bazel for new languages, build systems, or custom actions. Use when debugging Starlark rule implementations or understanding Bazel build phases.\n---\n\n# Developing Bazel Rules\n\n## Overview\n\nBazel rules define how to transform inputs into outputs through actions. A rule has an implementation function executed during analysis phase that registers actions for execution phase.\n\n**Core principle:** Rules don't execute commands directly - they register actions that Bazel executes later based on dependency analysis.\n\n## When to Use\n\n- Creating rules for new languages or tools\n- Building custom toolchains\n- Implementing providers for dependency propagation\n- Creating aspects for cross-cutting concerns\n- Wrapping existing tools with Bazel\n\n## Build Phases\n\n| Phase | What Happens | Rule Author's Role |\n|-------|--------------|-------------------|\n| **Loading** | `BUILD` files evaluated, rules instantiated | Define rule with `rule()`, macros expand |\n| **Analysis** | Implementation functions run | Register actions, return providers |\n| **Execution** | Actions run (if needed) | Actions produce outputs |\n\n## Quick Start: Minimal Rule\n\n```python\n# my_rules.bzl\ndef _my_compile_impl(ctx):\n    output = ctx.actions.declare_file(ctx.label.name + \".out\")\n    ctx.actions.run(\n        mnemonic = \"MyCompile\",\n        executable = ctx.executable._compiler,\n        arguments = [\"-o\", output.path] + [f.path for f in ctx.files.srcs],\n        inputs = ctx.files.srcs,\n        outputs = [output],\n    )\n    return [DefaultInfo(files = depset([output]))]\n\nmy_compile = rule(\n    implementation = _my_compile_impl,\n    attrs = {\n        \"srcs\": attr.label_list(allow_files = True),\n        \"_compiler\": attr.label(\n            default = \"//tools:compiler\",\n            executable = True,\n            cfg = \"exec\",\n        ),\n    },\n)\n```\n\n## Core Concepts\n\n### Providers - Passing Data Between Rules\n\nProviders are the mechanism for rules to communicate:\n\n```python\nMyInfo = provider(\n    doc = \"Information from my_library targets\",\n    fields = {\n        \"files\": \"depset of output files\",\n        \"transitive_files\": \"depset of all transitive files\",\n    },\n)\n\ndef _impl(ctx):\n    # Collect from dependencies\n    transitive = [dep[MyInfo].transitive_files for dep in ctx.attr.deps]\n\n    # Return new provider\n    return [\n        DefaultInfo(files = depset([output])),\n        MyInfo(\n            files = depset([output]),\n            transitive_files = depset([output], transitive = transitive),\n        ),\n    ]\n```\n\n**Require providers in deps:**\n```python\n\"deps\": attr.label_list(providers = [MyInfo])\n```\n\n### Depsets - Efficient Transitive Collections\n\nUse depsets to avoid quadratic complexity:\n\n```python\n# GOOD: O(1) per target\ntransitive_srcs = depset(\n    direct = ctx.files.srcs,\n    transitive = [dep[MyInfo].srcs for dep in ctx.attr.deps],\n)\n\n# BAD: O(n) copying - becomes O(n^2) across graph\ntransitive_srcs = list(ctx.files.srcs)\nfor dep in ctx.attr.deps:\n    transitive_srcs.extend(dep[MyInfo].srcs.to_list())\n```\n\n**Only call `.to_list()` in binary rules, never in libraries.**\n\n### Actions - Registering Work\n\n```python\n# Run executable (preferred)\nctx.actions.run(\n    mnemonic = \"Compile\",\n    executable = ctx.executable._tool,\n    arguments = [args],\n    inputs = inputs,\n    outputs = [output],\n)\n\n# Use args builder for large inputs\nargs = ctx.actions.args()\nargs.add(\"-o\", output)\nargs.add_all(srcs)  # Deferred expansion - efficient!\n\n# Write file content\nctx.actions.write(output, content, is_executable = True)\n```\n\n### Attributes - Rule Parameters\n\n| Type | Use Case |\n|------|----------|\n| `attr.label_list` | File/target inputs (`srcs`, `deps`) |\n| `attr.label` | Single target (`_compiler`) |\n| `attr.string` | Config value (`importpath`) |\n| `attr.bool` | Toggle (`cgo = True`) |\n\n**Private attributes** (underscore prefix) for implicit deps:\n```python\n\"_stdlib\": attr.label(default = \"//go:stdlib\")\n```\n\n**cfg for tools:**\n```python\n\"_compiler\": attr.label(executable = True, cfg = \"exec\")\n```\n\n## Implementation Checklist\n\n1. Get toolchain (if using): `ctx.toolchains[\"//my:type\"]`\n2. Access inputs: `ctx.files.srcs`, `ctx.attr.deps`\n3. Declare outputs: `ctx.actions.declare_file()`\n4. Build depsets for transitive data\n5. Register actions: `ctx.actions.run()`\n6. Return providers: `[DefaultInfo(...), MyInfo(...)]`\n\n## Common Mistakes\n\n| Mistake | Fix |\n|---------|-----|\n| Flattening depsets in library | Keep as depset, flatten only in binary |\n| Missing `cfg = \"exec\"` for tools | Add `cfg = \"exec\"` to tool attributes |\n| Not returning DefaultInfo | Always return DefaultInfo with files |\n| Reading files in analysis | Files can only be read by actions |\n| Action without outputs | All actions must produce output files |\n\n## Reference Files\n\nSee `references/` for detailed guides:\n- `api-reference.md` - Starlark API quick reference\n- `providers.md` - Provider design patterns\n- `toolchains.md` - Toolchain development\n- `testing.md` - Testing Bazel rules\n- `go-patterns.md` - Patterns from rules_go\n",
        "bazel/skills/developing-bazel-rules/references/api-reference.md": "# Starlark API Quick Reference\n\n## ctx Object\n\n### Attributes Access\n\n| Property | Returns | Description |\n|----------|---------|-------------|\n| `ctx.attr.name` | Target value | Attribute values from rule call |\n| `ctx.files.name` | `[File]` | Files from label/label_list attr |\n| `ctx.file.name` | `File` | Single file (when `allow_single_file=True`) |\n| `ctx.executable.name` | `File` | Executable file (when `executable=True`) |\n| `ctx.outputs.name` | `File` | Predeclared outputs |\n\n### Context Properties\n\n| Property | Returns | Description |\n|----------|---------|-------------|\n| `ctx.label` | `Label` | Target's label |\n| `ctx.label.name` | `str` | Target name |\n| `ctx.label.package` | `str` | Package path |\n| `ctx.workspace_name` | `str` | Workspace name |\n| `ctx.bin_dir` | `root` | bazel-bin root |\n| `ctx.genfiles_dir` | `root` | Generated files root |\n| `ctx.toolchains[\"//type\"]` | `ToolchainInfo` | Resolved toolchain |\n| `ctx.fragments.cpp` | `fragment` | Configuration fragment |\n\n### Actions\n\n```python\n# Declare output file\noutput = ctx.actions.declare_file(name)\noutput = ctx.actions.declare_file(name, sibling=other_file)\n\n# Declare directory\ndir = ctx.actions.declare_directory(name)\n\n# Run executable\nctx.actions.run(\n    mnemonic = \"Name\",           # Short name for progress\n    executable = file,           # Tool to run\n    arguments = [str],           # Command arguments\n    inputs = depset/list,        # Input files\n    outputs = [File],            # Output files\n    env = {str: str},            # Environment variables\n    execution_requirements = {}, # Execution constraints\n    use_default_shell_env = False,\n)\n\n# Run shell command\nctx.actions.run_shell(\n    mnemonic = \"Name\",\n    command = \"shell command\",\n    arguments = [str],           # Passed as $1, $2, etc.\n    inputs = depset/list,\n    outputs = [File],\n    env = {},\n)\n\n# Write file\nctx.actions.write(\n    output = File,\n    content = str,\n    is_executable = False,\n)\n\n# Expand template\nctx.actions.expand_template(\n    template = File,\n    output = File,\n    substitutions = {\"%key%\": \"value\"},\n)\n\n# Build args efficiently\nargs = ctx.actions.args()\nargs.add(\"-flag\")\nargs.add(\"-o\", output)\nargs.add_all(files)\nargs.add_joined(\"-I\", dirs, join_with=\":\")\n```\n\n### Runfiles\n\n```python\nrunfiles = ctx.runfiles(\n    files = [File],              # Explicit files\n    transitive_files = depset,   # Additional files\n    symlinks = {path: File},     # Symlinks in runfiles\n)\n\n# Merge from dependencies\nrunfiles = runfiles.merge(other_runfiles)\nrunfiles = runfiles.merge_all([rf1, rf2])\n```\n\n## Attribute Types\n\n```python\nattr.label(\n    default = Label(\"//pkg:target\"),\n    allow_files = [\".ext\"],      # Or True for any\n    allow_single_file = True,    # ctx.file instead of ctx.files\n    executable = True,           # Must be executable\n    cfg = \"exec\",                # \"exec\", \"target\", or transition\n    providers = [InfoProvider],  # Required providers\n    mandatory = True,\n)\n\nattr.label_list(\n    allow_files = [\".go\"],\n    providers = [GoInfo],\n    cfg = \"target\",\n)\n\nattr.string(default = \"\", values = [\"a\", \"b\"])\nattr.string_list(default = [])\nattr.int(default = 0, values = [1, 2, 3])\nattr.bool(default = False)\nattr.string_dict(default = {})\n\nattr.output()                    # Single output\nattr.output_list()               # Multiple outputs\n```\n\n## File Object\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `file.path` | `str` | Execution-relative path |\n| `file.short_path` | `str` | Runfiles-relative path |\n| `file.basename` | `str` | File name without directory |\n| `file.dirname` | `str` | Directory path |\n| `file.extension` | `str` | File extension |\n| `file.root` | `root` | Output root (bin/genfiles) |\n| `file.is_source` | `bool` | True if source file |\n\n## Label Object\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `label.name` | `str` | Target name |\n| `label.package` | `str` | Package path |\n| `label.workspace_name` | `str` | Repository name |\n| `label.workspace_root` | `str` | Repository path |\n\n## Depset\n\n```python\n# Create\nd = depset(direct=[a, b], transitive=[d1, d2], order=\"default\")\n\n# Orders: \"default\", \"postorder\", \"preorder\", \"topological\"\n\n# Convert to list (expensive - do in binary only)\nitems = d.to_list()\n\n# Check membership (also expensive)\nhas_item = item in d.to_list()\n```\n\n## Provider\n\n```python\n# Define\nMyInfo = provider(\n    doc = \"Description\",\n    fields = {\n        \"field1\": \"Description of field1\",\n        \"field2\": \"Description of field2\",\n    },\n)\n\n# Create instance\ninfo = MyInfo(field1 = value1, field2 = value2)\n\n# Access from target\ntarget[MyInfo].field1\n\n# Check if target has provider\nMyInfo in target\n```\n\n## Rule Definition\n\n```python\nmy_rule = rule(\n    implementation = _impl,\n    attrs = {...},\n    outputs = {\"out\": \"%{name}.out\"},  # Predeclared\n    executable = True,           # For binaries\n    test = True,                 # For tests (name must end in _test)\n    toolchains = [\"//type\"],     # Required toolchains\n    fragments = [\"cpp\"],         # Config fragments\n    provides = [MyInfo],         # Guaranteed providers\n    cfg = transition,            # Configuration transition\n    doc = \"Rule documentation\",\n)\n```\n\n## Built-in Providers\n\n| Provider | Fields | Use |\n|----------|--------|-----|\n| `DefaultInfo` | `files`, `runfiles`, `executable` | Default outputs |\n| `OutputGroupInfo` | `<group_name>` | Named output groups |\n| `RunEnvironmentInfo` | `environment`, `inherited_environment` | Test env |\n| `InstrumentedFilesInfo` | `...` | Coverage support |\n| `ToolchainInfo` | Custom fields | Toolchain data |\n",
        "bazel/skills/developing-bazel-rules/references/go-patterns.md": "# Patterns from rules_go\n\nThese patterns are extracted from [rules_go](https://github.com/bazel-contrib/rules_go), a production-quality Bazel ruleset.\n\n## Go Context Pattern\n\nCreate a unified context object that encapsulates toolchain access and common operations:\n\n```python\n# context.bzl\ndef go_context(ctx, include_deprecated_properties = True):\n    \"\"\"Create a Go build context from a rule context.\"\"\"\n    toolchain = ctx.toolchains[\"@rules_go//go:toolchain\"]\n\n    return struct(\n        # SDK and toolchain\n        go = toolchain.sdk.go,\n        sdk = toolchain.sdk,\n        stdlib = ctx.attr._stdlib[GoStdLib],\n\n        # Configuration\n        mode = struct(\n            goos = toolchain.default_goos,\n            goarch = toolchain.default_goarch,\n            race = ctx.attr.race == \"on\",\n            pure = ctx.attr.pure == \"on\",\n        ),\n\n        # Convenience methods\n        actions = ctx.actions,\n        declare_file = lambda name: ctx.actions.declare_file(name),\n        label = ctx.label,\n\n        # Action emitters\n        archive = toolchain.actions.archive,\n        link = toolchain.actions.link,\n    )\n```\n\nUsage in implementation:\n\n```python\ndef _go_library_impl(ctx):\n    go = go_context(ctx)\n\n    # Use context for all operations\n    archive = go.archive(go, sources)\n\n    return [GoInfo(...), archive]\n```\n\n## Layered Provider Architecture\n\nSeparate providers for different purposes:\n\n```python\n# 1. Source-level info (before compilation)\nGoInfo = provider(fields = {\n    \"srcs\": \"Source files\",\n    \"deps\": \"Direct dependencies\",\n    \"importpath\": \"Import path\",\n})\n\n# 2. Compiled archive (single target)\nGoArchive = provider(fields = {\n    \"source\": \"GoInfo this was built from\",\n    \"file\": \"The compiled .a file\",\n    \"export_file\": \"Export data for incremental compilation\",\n    \"data\": \"GoArchiveData for transitive use\",\n})\n\n# 3. Lightweight transitive data\nGoArchiveData = provider(fields = {\n    \"file\": \"Archive file\",\n    \"importpath\": \"Import path\",\n    \"importmap\": \"Real path (may differ for vendor)\",\n})\n```\n\n## Embed Pattern\n\nAllow composing sources from multiple targets:\n\n```python\n\"embed\": attr.label_list(\n    providers = [GoInfo],\n    doc = \"Libraries whose sources compile with this package\",\n),\n\ndef _impl(ctx):\n    srcs = list(ctx.files.srcs)\n    deps = list(ctx.attr.deps)\n\n    for embed in ctx.attr.embed:\n        embed_info = embed[GoInfo]\n        srcs.extend(embed_info.srcs.to_list())\n        deps.extend(embed_info.deps)\n```\n\n## Mode-Based Configuration\n\nUse string attributes with controlled values for build modes:\n\n```python\n\"pure\": attr.string(\n    default = \"auto\",\n    values = [\"on\", \"off\", \"auto\"],\n    doc = \"Disable cgo\",\n),\n\"race\": attr.string(\n    default = \"auto\",\n    values = [\"on\", \"off\", \"auto\"],\n    doc = \"Enable race detector\",\n),\n\"linkmode\": attr.string(\n    default = \"auto\",\n    values = [\"auto\", \"normal\", \"pie\", \"plugin\", \"c-shared\", \"c-archive\"],\n),\n```\n\nResolve \"auto\" based on configuration:\n\n```python\ndef resolve_mode(ctx, toolchain):\n    pure = ctx.attr.pure\n    if pure == \"auto\":\n        pure = \"on\" if toolchain.cross_compile else \"off\"\n\n    return struct(\n        pure = pure == \"on\",\n        race = ctx.attr.race == \"on\",\n        # ...\n    )\n```\n\n## Action Emitter Pattern\n\nSeparate action creation into reusable functions:\n\n```python\n# actions/archive.bzl\ndef emit_archive(go, source):\n    \"\"\"Compile Go sources to an archive.\"\"\"\n    out = go.declare_file(go, ext = \".a\")\n\n    args = go.actions.args()\n    args.add(\"-o\", out)\n    args.add(\"-importpath\", source.importpath)\n    args.add_all(source.srcs)\n\n    go.actions.run(\n        mnemonic = \"GoCompile\",\n        executable = go.toolchain._builder,\n        arguments = [args],\n        inputs = depset(source.srcs, transitive = [...]),\n        outputs = [out],\n    )\n\n    return GoArchive(\n        source = source,\n        file = out,\n        # ...\n    )\n```\n\n## Reset Target Pattern\n\nCreate targets that reset configuration for tool binaries:\n\n```python\n# Avoid tools being built with race detection, coverage, etc.\ngo_reset_target = rule(\n    implementation = _go_reset_target_impl,\n    attrs = {\n        \"dep\": attr.label(mandatory = True),\n        \"_allowlist_function_transition\": attr.label(\n            default = \"@bazel_tools//tools/allowlists/function_transition_allowlist\",\n        ),\n    },\n    cfg = _go_reset_transition,\n)\n\ndef _go_reset_transition_impl(settings, attr):\n    return {\n        \"//go/config:race\": False,\n        \"//go/config:msan\": False,\n        \"//go/config:pure\": True,\n    }\n```\n\n## Validation Output Pattern\n\nUse validation output group for checks that don't block compilation:\n\n```python\ndef _impl(ctx):\n    # Main compilation\n    archive = compile(...)\n\n    # Validation (linting, etc.)\n    validation_output = None\n    if ctx.attr._nogo:\n        validation_output = run_nogo(ctx, archive)\n\n    return [\n        DefaultInfo(files = depset([archive.file])),\n        OutputGroupInfo(\n            compilation_outputs = [archive.file],\n            _validation = [validation_output] if validation_output else [],\n        ),\n    ]\n```\n\n## Cross-Compilation Pattern\n\nUse goos/goarch attributes with transitions:\n\n```python\n\"goos\": attr.string(\n    default = \"auto\",\n    doc = \"Target OS. auto = use platform\",\n),\n\"goarch\": attr.string(\n    default = \"auto\",\n    doc = \"Target arch. auto = use platform\",\n),\n\ndef _go_cross_transition_impl(settings, attr):\n    goos = attr.goos\n    goarch = attr.goarch\n\n    if goos == \"auto\":\n        goos = settings[\"//go/toolchain:goos\"]\n    if goarch == \"auto\":\n        goarch = settings[\"//go/toolchain:goarch\"]\n\n    return {\n        \"//go/toolchain:goos\": goos,\n        \"//go/toolchain:goarch\": goarch,\n    }\n```\n\n## Runfiles Pattern\n\nProper runfiles merging for binaries:\n\n```python\ndef _go_binary_impl(ctx):\n    runfiles = ctx.runfiles(files = ctx.files.data)\n\n    # Merge from all dependency types\n    for runfiles_attr in (ctx.attr.srcs, ctx.attr.deps, ctx.attr.data):\n        for target in runfiles_attr:\n            runfiles = runfiles.merge(target[DefaultInfo].default_runfiles)\n\n    return [DefaultInfo(\n        executable = executable,\n        runfiles = runfiles,\n    )]\n```\n\n## Gazelle Integration\n\nDesign rules to work with Gazelle for automatic BUILD file generation:\n\n```python\n# Standard attribute names Gazelle expects\n\"srcs\": attr.label_list(allow_files = [\".go\"]),\n\"deps\": attr.label_list(providers = [GoInfo]),\n\"importpath\": attr.string(),\n\"embed\": attr.label_list(providers = [GoInfo]),\n```\n\nGazelle directives in BUILD files:\n\n```python\n# gazelle:prefix github.com/example/repo\n# gazelle:go_naming_convention go_default_library\n```\n",
        "bazel/skills/developing-bazel-rules/references/providers.md": "# Provider Design Patterns\n\n## Basic Provider Definition\n\nAlways define providers with explicit fields and documentation:\n\n```python\nMyLanguageInfo = provider(\n    doc = \"Information needed to compile MyLanguage code.\",\n    fields = {\n        \"sources\": \"depset of source Files\",\n        \"compile_flags\": \"list of compilation flags\",\n        \"transitive_deps\": \"depset of MyLanguageArchive for all transitive dependencies\",\n    },\n)\n```\n\n## Transitive Information Pattern\n\nPropagate information through the dependency graph using depsets:\n\n```python\ndef _my_library_impl(ctx):\n    # Collect transitive info from deps\n    transitive_sources = depset(\n        direct = ctx.files.srcs,\n        transitive = [dep[MyInfo].transitive_sources for dep in ctx.attr.deps],\n    )\n\n    transitive_deps = depset(\n        direct = [archive],\n        transitive = [dep[MyInfo].transitive_deps for dep in ctx.attr.deps],\n    )\n\n    return [\n        MyInfo(\n            sources = depset(ctx.files.srcs),\n            transitive_sources = transitive_sources,\n            transitive_deps = transitive_deps,\n        ),\n    ]\n```\n\n## Compilation Archive Pattern\n\nSeparate compiled artifacts from source info (used by rules_go, rules_rust):\n\n```python\n# Raw source information\nGoSource = provider(fields = {\n    \"srcs\": \"Source files\",\n    \"deps\": \"Direct dependencies\",\n    \"importpath\": \"Import path\",\n})\n\n# Compiled artifact\nGoArchive = provider(fields = {\n    \"source\": \"GoSource this was built from\",\n    \"file\": \"Compiled .a file\",\n    \"export_file\": \"Export data file\",\n    \"data\": \"GoArchiveData for transitive use\",\n})\n\n# Lightweight transitive data\nGoArchiveData = provider(fields = {\n    \"file\": \"Archive file\",\n    \"importpath\": \"Import path\",\n    \"importmap\": \"Actual import path\",\n})\n```\n\n## Provider with Init Validation\n\nUse init function for validation and preprocessing:\n\n```python\ndef _my_info_init(*, sources, deps = None):\n    if not sources:\n        fail(\"sources cannot be empty\")\n    return {\n        \"sources\": sources,\n        \"deps\": deps or [],\n    }\n\nMyInfo, _new_my_info = provider(\n    fields = [\"sources\", \"deps\"],\n    init = _my_info_init,\n)\n\n# Usage:\ninfo = MyInfo(sources = files)  # Goes through validation\nraw = _new_my_info(sources = [], deps = [])  # Bypasses validation\n```\n\n## Multiple Providers Pattern\n\nReturn multiple providers for different consumers:\n\n```python\ndef _my_library_impl(ctx):\n    return [\n        # Standard build info\n        DefaultInfo(\n            files = depset([archive.file]),\n            runfiles = ctx.runfiles(files = ctx.files.data),\n        ),\n\n        # Language-specific compilation info\n        MyLangInfo(\n            archive = archive,\n            transitive_deps = transitive_deps,\n        ),\n\n        # Coverage instrumentation info\n        coverage_common.instrumented_files_info(\n            ctx,\n            source_attributes = [\"srcs\"],\n            dependency_attributes = [\"deps\"],\n        ),\n\n        # Additional output groups\n        OutputGroupInfo(\n            compilation_outputs = [archive.file],\n            _validation = [validation_output] if validation_output else [],\n        ),\n    ]\n```\n\n## Provider Merging Pattern\n\nFor aspects or rules that need to combine providers:\n\n```python\ndef _merge_my_info(infos):\n    \"\"\"Merge multiple MyInfo providers into one.\"\"\"\n    return MyInfo(\n        sources = depset(transitive = [i.sources for i in infos]),\n        compile_flags = [f for i in infos for f in i.compile_flags],\n    )\n```\n\n## Aspect Provider Pattern\n\nAspects return providers that augment the target:\n\n```python\nMyAspectInfo = provider(fields = {\"generated\": \"Files generated by aspect\"})\n\ndef _my_aspect_impl(target, ctx):\n    # Access original target's providers\n    original_srcs = target[MyInfo].sources\n\n    # Create new outputs\n    output = ctx.actions.declare_file(target.label.name + \".gen\")\n\n    return [MyAspectInfo(generated = depset([output]))]\n```\n\n## Conditional Provider Pattern\n\nReturn different providers based on rule configuration:\n\n```python\ndef _impl(ctx):\n    providers = [DefaultInfo(files = depset([output]))]\n\n    if ctx.attr.generate_proto:\n        providers.append(ProtoInfo(...))\n\n    if ctx.attr.testonly:\n        providers.append(TestInfo(...))\n\n    return providers\n```\n\n## Provider Documentation Best Practices\n\n1. **Always use `fields` dict** - enables documentation generation\n2. **Document each field** - explain type and purpose\n3. **Use depsets for collections** - enables efficient merging\n4. **Separate transitive from direct** - clearer API\n5. **Define separate provider for archives** - keeps compilation data separate\n",
        "bazel/skills/developing-bazel-rules/references/testing.md": "# Testing Bazel Rules\n\n## Analysis Tests\n\nTest rule behavior without executing actions using `analysistest` from bazel_skylib.\n\n### Basic Analysis Test\n\n```python\n# my_rules_test.bzl\nload(\"@bazel_skylib//lib:unittest.bzl\", \"analysistest\", \"asserts\")\nload(\"//my_lang:rules.bzl\", \"my_library\")\n\ndef _provider_test_impl(ctx):\n    env = analysistest.begin(ctx)\n    target = analysistest.target_under_test(env)\n\n    # Check provider exists\n    asserts.true(env, MyInfo in target, \"Expected MyInfo provider\")\n\n    # Check provider values\n    info = target[MyInfo]\n    asserts.equals(env, \"expected_value\", info.some_field)\n\n    # Check file count\n    asserts.equals(env, 2, len(info.sources.to_list()))\n\n    return analysistest.end(env)\n\nprovider_test = analysistest.make(_provider_test_impl)\n\ndef _test_my_library_provider():\n    my_library(\n        name = \"target_under_test\",\n        srcs = [\"a.ml\", \"b.ml\"],\n        tags = [\"manual\"],\n    )\n    provider_test(\n        name = \"my_library_provider_test\",\n        target_under_test = \":target_under_test\",\n    )\n\ndef my_library_test_suite(name):\n    _test_my_library_provider()\n\n    native.test_suite(\n        name = name,\n        tests = [\":my_library_provider_test\"],\n    )\n```\n\n### Testing Actions\n\n```python\ndef _action_test_impl(ctx):\n    env = analysistest.begin(ctx)\n    target = analysistest.target_under_test(env)\n    actions = analysistest.target_actions(env)\n\n    # Find specific action by mnemonic\n    compile_actions = [a for a in actions if a.mnemonic == \"MyCompile\"]\n    asserts.equals(env, 1, len(compile_actions))\n\n    action = compile_actions[0]\n\n    # Check arguments\n    asserts.true(env, \"-O2\" in action.argv)\n\n    # Check inputs/outputs\n    input_paths = [f.path for f in action.inputs.to_list()]\n    asserts.true(env, any(\"source.ml\" in p for p in input_paths))\n\n    return analysistest.end(env)\n\naction_test = analysistest.make(_action_test_impl)\n```\n\n### Testing Failures\n\n```python\ndef _failure_test_impl(ctx):\n    env = analysistest.begin(ctx)\n    # Test expects failure, nothing to assert if it reaches here\n    asserts.expect_failure(env, \"missing required attribute\")\n    return analysistest.end(env)\n\nfailure_test = analysistest.make(\n    _failure_test_impl,\n    expect_failure = True,\n)\n\ndef _test_missing_srcs_fails():\n    my_library(\n        name = \"missing_srcs_target\",\n        # srcs intentionally missing\n        tags = [\"manual\"],\n    )\n    failure_test(\n        name = \"missing_srcs_fails_test\",\n        target_under_test = \":missing_srcs_target\",\n    )\n```\n\n### Testing with Configuration\n\n```python\ndef _config_test_impl(ctx):\n    env = analysistest.begin(ctx)\n    # Access configuration\n    config = ctx.configuration\n    # Test config-dependent behavior\n    return analysistest.end(env)\n\nconfig_test = analysistest.make(\n    _config_test_impl,\n    config_settings = {\n        \"//my_lang:some_flag\": \"value\",\n    },\n)\n```\n\n## Integration Tests\n\nTest actual build output with `sh_test` or `py_test`:\n\n```python\n# BUILD\nload(\"//my_lang:rules.bzl\", \"my_binary\")\n\nmy_binary(\n    name = \"hello\",\n    srcs = [\"hello.ml\"],\n)\n\nsh_test(\n    name = \"hello_test\",\n    srcs = [\"hello_test.sh\"],\n    data = [\":hello\"],\n)\n```\n\n```bash\n# hello_test.sh\n#!/bin/bash\nOUTPUT=$(./hello)\nif [[ \"$OUTPUT\" != \"Hello, World!\" ]]; then\n    echo \"Expected 'Hello, World!' but got '$OUTPUT'\"\n    exit 1\nfi\n```\n\n## Testing Output File Contents\n\n```python\n# file_content_test.bzl\ndef _file_content_test_impl(ctx):\n    env = analysistest.begin(ctx)\n    target = analysistest.target_under_test(env)\n\n    # Get output files\n    files = target[DefaultInfo].files.to_list()\n    asserts.equals(env, 1, len(files))\n\n    # Check file extension\n    asserts.true(env, files[0].path.endswith(\".out\"))\n\n    return analysistest.end(env)\n```\n\n## Testing Toolchains\n\n```python\ndef _toolchain_test_impl(ctx):\n    env = analysistest.begin(ctx)\n    target = analysistest.target_under_test(env)\n    actions = analysistest.target_actions(env)\n\n    # Verify toolchain was used\n    compile_action = [a for a in actions if a.mnemonic == \"MyCompile\"][0]\n\n    # Check toolchain executable was used\n    asserts.true(\n        env,\n        compile_action.executable.path.endswith(\"my_compiler\"),\n        \"Expected toolchain compiler\",\n    )\n\n    return analysistest.end(env)\n```\n\n## Testing Aspects\n\n```python\ndef _aspect_test_impl(ctx):\n    env = analysistest.begin(ctx)\n    target = analysistest.target_under_test(env)\n\n    # Check aspect provider\n    asserts.true(env, MyAspectInfo in target)\n\n    return analysistest.end(env)\n\naspect_test = analysistest.make(\n    _aspect_test_impl,\n    extra_target_under_test_aspects = [my_aspect],\n)\n```\n\n## Test Suite Organization\n\n```python\n# tests/BUILD\nload(\":my_library_tests.bzl\", \"my_library_test_suite\")\nload(\":my_binary_tests.bzl\", \"my_binary_test_suite\")\n\nmy_library_test_suite(name = \"my_library_tests\")\nmy_binary_test_suite(name = \"my_binary_tests\")\n\ntest_suite(\n    name = \"all_tests\",\n    tests = [\n        \":my_library_tests\",\n        \":my_binary_tests\",\n    ],\n)\n```\n\n## Debugging Test Failures\n\n```bash\n# Run with verbose output\nbazel test //tests:my_test --test_output=all\n\n# Run analysis tests with debug\nbazel test //tests:my_test --test_output=errors --verbose_failures\n\n# Check what targets are created\nbazel query 'deps(//tests:my_test)'\n```\n\n## Best Practices\n\n1. **Test providers** - Verify all expected providers are returned\n2. **Test actions** - Check mnemonic, inputs, outputs, arguments\n3. **Test failures** - Ensure invalid inputs fail appropriately\n4. **Test configurations** - Cover different build settings\n5. **Test output groups** - Verify validation outputs\n6. **Use `tags = [\"manual\"]`** - Prevent test targets from normal builds\n",
        "bazel/skills/developing-bazel-rules/references/toolchains.md": "# Toolchain Development\n\n## Why Toolchains?\n\nToolchains decouple rules from platform-specific tools:\n- Rules declare they need \"a compiler\" (toolchain type)\n- Toolchains provide specific compilers for each platform\n- Bazel automatically selects the right toolchain\n\n## Complete Toolchain Setup\n\n### 1. Define Toolchain Type\n\n```python\n# //my_lang:BUILD\ntoolchain_type(\n    name = \"toolchain_type\",\n    visibility = [\"//visibility:public\"],\n)\n```\n\n### 2. Create Toolchain Rule\n\n```python\n# //my_lang:toolchain.bzl\n\nMyLangToolchainInfo = provider(fields = {\n    \"compiler\": \"Compiler executable\",\n    \"stdlib\": \"Standard library files\",\n    \"compile_flags\": \"Default compilation flags\",\n})\n\ndef _my_lang_toolchain_impl(ctx):\n    return [\n        platform_common.ToolchainInfo(\n            my_lang_info = MyLangToolchainInfo(\n                compiler = ctx.executable.compiler,\n                stdlib = ctx.files.stdlib,\n                compile_flags = ctx.attr.compile_flags,\n            ),\n        ),\n    ]\n\nmy_lang_toolchain = rule(\n    implementation = _my_lang_toolchain_impl,\n    attrs = {\n        \"compiler\": attr.label(\n            mandatory = True,\n            executable = True,\n            cfg = \"exec\",\n        ),\n        \"stdlib\": attr.label_list(\n            allow_files = True,\n        ),\n        \"compile_flags\": attr.string_list(),\n    },\n    provides = [platform_common.ToolchainInfo],\n)\n```\n\n### 3. Define Toolchain Instances\n\n```python\n# //my_lang/toolchains:BUILD\n\nload(\"//my_lang:toolchain.bzl\", \"my_lang_toolchain\")\n\nmy_lang_toolchain(\n    name = \"linux_x86_64_impl\",\n    compiler = \"//my_lang/compilers:linux_x86_64\",\n    stdlib = [\"//my_lang/stdlib:linux_x86_64\"],\n    compile_flags = [\"-O2\"],\n)\n\ntoolchain(\n    name = \"linux_x86_64\",\n    toolchain = \":linux_x86_64_impl\",\n    toolchain_type = \"//my_lang:toolchain_type\",\n    exec_compatible_with = [\n        \"@platforms//os:linux\",\n        \"@platforms//cpu:x86_64\",\n    ],\n    target_compatible_with = [\n        \"@platforms//os:linux\",\n        \"@platforms//cpu:x86_64\",\n    ],\n)\n\nmy_lang_toolchain(\n    name = \"macos_arm64_impl\",\n    compiler = \"//my_lang/compilers:macos_arm64\",\n    stdlib = [\"//my_lang/stdlib:macos_arm64\"],\n    compile_flags = [\"-O2\"],\n)\n\ntoolchain(\n    name = \"macos_arm64\",\n    toolchain = \":macos_arm64_impl\",\n    toolchain_type = \"//my_lang:toolchain_type\",\n    exec_compatible_with = [\n        \"@platforms//os:macos\",\n        \"@platforms//cpu:arm64\",\n    ],\n    target_compatible_with = [\n        \"@platforms//os:macos\",\n        \"@platforms//cpu:arm64\",\n    ],\n)\n```\n\n### 4. Register Toolchains\n\n```python\n# MODULE.bazel\nregister_toolchains(\n    \"//my_lang/toolchains:linux_x86_64\",\n    \"//my_lang/toolchains:macos_arm64\",\n)\n```\n\n### 5. Use Toolchain in Rules\n\n```python\n# //my_lang:rules.bzl\n\ndef _my_lang_binary_impl(ctx):\n    toolchain = ctx.toolchains[\"//my_lang:toolchain_type\"]\n    tc = toolchain.my_lang_info\n\n    output = ctx.actions.declare_file(ctx.label.name)\n\n    args = ctx.actions.args()\n    args.add_all(tc.compile_flags)\n    args.add(\"-o\", output)\n    args.add_all(ctx.files.srcs)\n\n    ctx.actions.run(\n        mnemonic = \"MyLangCompile\",\n        executable = tc.compiler,\n        arguments = [args],\n        inputs = depset(ctx.files.srcs, transitive = [depset(tc.stdlib)]),\n        outputs = [output],\n    )\n\n    return [DefaultInfo(\n        files = depset([output]),\n        executable = output,\n    )]\n\nmy_lang_binary = rule(\n    implementation = _my_lang_binary_impl,\n    attrs = {\n        \"srcs\": attr.label_list(allow_files = [\".ml\"]),\n    },\n    toolchains = [\"//my_lang:toolchain_type\"],\n    executable = True,\n)\n```\n\n## Cross-Compilation\n\nToolchains enable cross-compilation by separating:\n- **Execution platform**: Where build actions run\n- **Target platform**: What platform the output runs on\n\n```python\ntoolchain(\n    name = \"cross_linux_arm\",\n    toolchain = \":cross_compiler_impl\",\n    toolchain_type = \"//my_lang:toolchain_type\",\n    # Build actions run on Linux x86_64\n    exec_compatible_with = [\n        \"@platforms//os:linux\",\n        \"@platforms//cpu:x86_64\",\n    ],\n    # Output runs on Linux ARM\n    target_compatible_with = [\n        \"@platforms//os:linux\",\n        \"@platforms//cpu:arm64\",\n    ],\n)\n```\n\n## Optional Toolchains\n\n```python\nmy_rule = rule(\n    implementation = _impl,\n    toolchains = [\n        config_common.toolchain_type(\"//my_lang:toolchain_type\", mandatory = False),\n    ],\n)\n\ndef _impl(ctx):\n    tc = ctx.toolchains[\"//my_lang:toolchain_type\"]\n    if tc:\n        # Use toolchain\n        ...\n    else:\n        # Fallback behavior\n        ...\n```\n\n## Toolchain with Dependencies\n\nToolchains can have their own dependencies:\n\n```python\ndef _my_toolchain_impl(ctx):\n    return [platform_common.ToolchainInfo(\n        compiler = ctx.executable.compiler,\n        # cfg = \"target\" means these are for the output platform\n        runtime_libs = ctx.attr.runtime_libs,\n        # cfg = \"exec\" means these are for the build platform\n        build_tools = ctx.files.build_tools,\n    )]\n\nmy_lang_toolchain = rule(\n    implementation = _my_toolchain_impl,\n    attrs = {\n        \"compiler\": attr.label(executable = True, cfg = \"exec\"),\n        \"runtime_libs\": attr.label_list(cfg = \"target\"),\n        \"build_tools\": attr.label_list(cfg = \"exec\"),\n    },\n)\n```\n\n## Debugging Toolchains\n\n```bash\n# See toolchain resolution\nbazel build //my:target --toolchain_resolution_debug='.*'\n\n# See which toolchain was selected\nbazel cquery 'deps(//my:target, 1)' --output=starlark \\\n  --starlark:expr='providers(target).keys()'\n```\n",
        "gitea/.claude-plugin/plugin.json": "{\n  \"name\": \"gitea\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Skills for Gitea: tea CLI operations and Go SDK development\",\n  \"author\": {\n    \"name\": \"German Arutyunov\"\n  },\n  \"repository\": \"https://github.com/germanarutyunov/dev-skills\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"gitea\", \"tea\", \"git\", \"forge\", \"sdk\", \"go\", \"cli\", \"api\"]\n}\n",
        "gitea/README.md": "# Gitea Skills Plugin for Claude Code\n\nSkills for interacting with Gitea - the self-hosted Git service.\n\n## Skills Included\n\n### `gitea:tea-cli`\nCommand-line operations using the official Gitea CLI (`tea`).\n\n**Use when:** Managing issues, PRs, releases, repos via command line, scripting, or CI/CD.\n\n**Covers:**\n- Issues & comments\n- Pull requests & reviews\n- Releases & assets\n- Repositories & branches\n- Labels, milestones, organizations\n- Webhooks, notifications, time tracking\n- Actions (secrets/variables)\n\n### `gitea:go-sdk`\nProgrammatic access using the official Gitea Go SDK.\n\n**Use when:** Writing Go code for automation, bots, integrations, or migrations.\n\n**Covers:**\n- 332+ API methods with full type safety\n- All Gitea entities (repos, issues, PRs, releases, orgs, users)\n- Pagination, error handling, concurrent operations\n- Webhook handler patterns\n- Bot development patterns\n\n## Installation\n\n```bash\n# Install from dev-skills marketplace\n/plugin install gitea@dev-skills\n```\n\n## Quick Start\n\n### Tea CLI\n```bash\n# Setup\ntea login add --name myserver --url https://gitea.example.com --token TOKEN\n\n# Create issue\ntea issues create --title \"Bug report\" --body \"Description\"\n\n# Create PR\ntea pr create --head feature --base main --title \"Add feature\"\n\n# Merge PR\ntea pr merge 45\n```\n\n### Go SDK\n```go\nimport \"code.gitea.io/sdk/gitea\"\n\nclient, _ := gitea.NewClient(\n    \"https://gitea.example.com\",\n    gitea.SetToken(\"your-token\"),\n)\n\n// Create issue\nissue, _, _ := client.CreateIssue(\"owner\", \"repo\", gitea.CreateIssueOption{\n    Title: \"Bug report\",\n    Body:  \"Description\",\n})\n```\n\n## Source Repositories\n\n- Tea CLI: https://gitea.com/gitea/tea\n- Go SDK: https://gitea.com/gitea/go-sdk\n\n## License\n\nMIT\n",
        "gitea/skills/go-sdk/SKILL.md": "---\nname: go-sdk\ndescription: Use when writing Go code to interact with Gitea API - automation, bots, integrations, migrations, or programmatic git forge operations\n---\n\n# Gitea Go SDK\n\n## Overview\n\nThe official Go SDK for Gitea provides 332+ API methods with full type safety. Use it for bots, automation, integrations, and complex workflows. For quick CLI operations, use `gitea:tea-cli` instead.\n\n## Quick Setup\n\n```go\nimport \"code.gitea.io/sdk/gitea\"\n\n// Create client\nclient, err := gitea.NewClient(\n    \"https://gitea.example.com\",\n    gitea.SetToken(\"your-token\"),\n)\n```\n\n```bash\ngo get code.gitea.io/sdk/gitea\n```\n\nSee `references/authentication.md` in tea-cli for token creation.\n\n## Quick Reference\n\n| Task | Method |\n|------|--------|\n| **Repos** | |\n| List my repos | `client.ListMyRepos(ListReposOptions{})` |\n| Get repo | `client.GetRepo(owner, repo)` |\n| Create repo | `client.CreateRepo(CreateRepoOption{})` |\n| **Issues** | |\n| List issues | `client.ListRepoIssues(owner, repo, ListIssueOption{})` |\n| Create issue | `client.CreateIssue(owner, repo, CreateIssueOption{})` |\n| Edit issue | `client.EditIssue(owner, repo, index, EditIssueOption{})` |\n| **PRs** | |\n| List PRs | `client.ListRepoPullRequests(owner, repo, ListPullRequestsOptions{})` |\n| Create PR | `client.CreatePullRequest(owner, repo, CreatePullRequestOption{})` |\n| Merge PR | `client.MergePullRequest(owner, repo, index, MergePullRequestOption{})` |\n| **Releases** | |\n| List releases | `client.ListReleases(owner, repo, ListReleasesOptions{})` |\n| Create release | `client.CreateRelease(owner, repo, CreateReleaseOption{})` |\n\n## API Categories\n\nSee `references/api-reference.md` for complete method list:\n- Repositories (70+ methods)\n- Issues & comments (50+ methods)\n- Pull requests & reviews (40+ methods)\n- Releases & attachments\n- Organizations & teams\n- Users, webhooks, actions\n\n## Common Types\n\nSee `references/types.md` for struct definitions:\n- `Repository`, `Issue`, `PullRequest`, `Release`\n- `User`, `Organization`, `Team`\n- `ListOptions` for pagination\n- Option structs for create/edit\n\n## Patterns\n\nSee `references/examples.md` for idiomatic patterns:\n- Error handling\n- Pagination\n- Context usage\n- Webhook handlers\n\n## Authentication Options\n\n```go\n// Token auth (recommended)\nclient, _ := gitea.NewClient(url, gitea.SetToken(token))\n\n// Basic auth\nclient, _ := gitea.NewClient(url, gitea.SetBasicAuth(user, pass))\n\n// With 2FA\nclient, _ := gitea.NewClient(url,\n    gitea.SetBasicAuth(user, pass),\n    gitea.SetOTP(otp),\n)\n\n// SSH key\nclient, _ := gitea.NewClient(url,\n    gitea.UseSSHPubkey(fingerprint, keyPath, passphrase),\n)\n```\n\n## Common Patterns\n\n```go\n// Pagination\nopts := gitea.ListOptions{Page: 1, PageSize: 50}\nfor {\n    repos, resp, _ := client.ListMyRepos(gitea.ListReposOptions{ListOptions: opts})\n    // process repos...\n    if resp.NextPage == 0 {\n        break\n    }\n    opts.Page = resp.NextPage\n}\n\n// Context support\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\nclient.SetContext(ctx)\n```\n\n## Common Mistakes\n\n| Problem | Solution |\n|---------|----------|\n| Nil pointer panic | Always check error before using result |\n| Missing pagination | Use `resp.NextPage` to get all results |\n| Context timeout | Set appropriate timeout for bulk operations |\n| Rate limiting | Check `resp.Header` for rate limit info |\n",
        "gitea/skills/go-sdk/references/api-reference.md": "# Gitea Go SDK API Reference\n\n## Client Initialization\n\n```go\nimport \"code.gitea.io/sdk/gitea\"\n\n// Basic\nclient, err := gitea.NewClient(\"https://gitea.example.com\")\n\n// With options\nclient, err := gitea.NewClient(url,\n    gitea.SetToken(token),\n    gitea.SetContext(ctx),\n    gitea.SetDebugMode(),           // Log HTTP requests\n    gitea.SetHTTPClient(httpClient), // Custom HTTP client\n)\n\n// Set sudo (impersonate user)\nclient.SetSudo(\"username\")\n```\n\n---\n\n## Repositories\n\n### CRUD\n```go\n// List\nrepos, resp, err := client.ListMyRepos(ListReposOptions{})\nrepos, resp, err := client.ListUserRepos(username, ListReposOptions{})\nrepos, resp, err := client.ListOrgRepos(org, ListReposOptions{})\nrepos, resp, err := client.SearchRepos(SearchRepoOptions{Keyword: \"query\"})\n\n// Get\nrepo, resp, err := client.GetRepo(owner, repoName)\nrepo, resp, err := client.GetRepoByID(repoID)\n\n// Create\nrepo, resp, err := client.CreateRepo(CreateRepoOption{\n    Name:        \"repo-name\",\n    Description: \"Description\",\n    Private:     true,\n    AutoInit:    true,\n})\nrepo, resp, err := client.CreateOrgRepo(org, CreateRepoOption{})\n\n// Edit\nrepo, resp, err := client.EditRepo(owner, repo, EditRepoOption{})\n\n// Delete\nresp, err := client.DeleteRepo(owner, repo)\n```\n\n### Branches\n```go\nbranches, resp, err := client.ListRepoBranches(owner, repo, ListRepoBranchesOptions{})\nbranch, resp, err := client.GetRepoBranch(owner, repo, branchName)\nbranch, resp, err := client.CreateBranch(owner, repo, CreateBranchOption{})\nresp, err := client.DeleteRepoBranch(owner, repo, branchName)\n\n// Protection\nprotection, resp, err := client.CreateBranchProtection(owner, repo, CreateBranchProtectionOption{})\nprotections, resp, err := client.ListBranchProtections(owner, repo, ListBranchProtectionsOptions{})\nresp, err := client.DeleteBranchProtection(owner, repo, protectionName)\n```\n\n### Files\n```go\n// Get content\ncontent, resp, err := client.GetContents(owner, repo, filepath, ref)\nfile, resp, err := client.GetFile(owner, repo, branch, filepath)\nreader, resp, err := client.GetFileReader(owner, repo, branch, filepath)\n\n// Create/Update/Delete\nfileResp, resp, err := client.CreateFile(owner, repo, filepath, CreateFileOptions{\n    Content: base64Content,\n    Message: \"commit message\",\n    Branch:  \"main\",\n})\nfileResp, resp, err := client.UpdateFile(owner, repo, filepath, UpdateFileOptions{})\nresp, err := client.DeleteFile(owner, repo, filepath, DeleteFileOptions{})\n```\n\n### Other\n```go\n// Forks\nrepos, resp, err := client.ListForks(owner, repo, ListForksOptions{})\nrepo, resp, err := client.CreateFork(owner, repo, CreateForkOption{})\n\n// Stars\nstargazers, resp, err := client.ListRepoStargazers(owner, repo, ListStargazersOptions{})\nresp, err := client.StarRepo(owner, repo)\nresp, err := client.UnStarRepo(owner, repo)\n\n// Collaborators\ncollabs, resp, err := client.ListCollaborators(owner, repo, ListCollaboratorsOptions{})\nresp, err := client.AddCollaborator(owner, repo, user, AddCollaboratorOption{})\nresp, err := client.DeleteCollaborator(owner, repo, user)\n\n// Topics\ntopics, resp, err := client.ListRepoTopics(owner, repo, ListRepoTopicsOptions{})\nresp, err := client.SetRepoTopics(owner, repo, SetRepoTopicsOption{Topics: []string{}})\n```\n\n---\n\n## Issues\n\n### CRUD\n```go\n// List\nissues, resp, err := client.ListRepoIssues(owner, repo, ListIssueOption{\n    State:     gitea.StateOpen,\n    Labels:    []string{\"bug\"},\n    Milestones: []string{\"v1.0\"},\n})\nissues, resp, err := client.ListIssues(ListIssueOption{}) // All accessible\n\n// Get\nissue, resp, err := client.GetIssue(owner, repo, issueIndex)\n\n// Create\nissue, resp, err := client.CreateIssue(owner, repo, CreateIssueOption{\n    Title:     \"Issue title\",\n    Body:      \"Description\",\n    Labels:    []int64{labelID},\n    Assignees: []string{\"user1\"},\n    Milestone: milestoneID,\n})\n\n// Edit\nissue, resp, err := client.EditIssue(owner, repo, issueIndex, EditIssueOption{\n    Title: &newTitle,\n    State: &gitea.StateClosed,\n})\n```\n\n### Comments\n```go\ncomments, resp, err := client.ListIssueComments(owner, repo, issueIndex, ListIssueCommentOptions{})\ncomment, resp, err := client.CreateIssueComment(owner, repo, issueIndex, CreateIssueCommentOption{Body: \"text\"})\ncomment, resp, err := client.EditIssueComment(owner, repo, commentID, EditIssueCommentOption{})\nresp, err := client.DeleteIssueComment(owner, repo, commentID)\n```\n\n### Labels\n```go\nlabels, resp, err := client.GetIssueLabels(owner, repo, issueIndex)\nlabels, resp, err := client.AddIssueLabels(owner, repo, issueIndex, IssueLabelsOption{Labels: []int64{}})\nresp, err := client.DeleteIssueLabel(owner, repo, issueIndex, labelID)\nresp, err := client.ClearIssueLabels(owner, repo, issueIndex)\n```\n\n### Time Tracking\n```go\ntimes, resp, err := client.ListIssueTrackedTimes(owner, repo, issueIndex, ListTrackedTimesOptions{})\ntime, resp, err := client.AddTime(owner, repo, issueIndex, AddTimeOption{Time: 3600})\nresp, err := client.DeleteTime(owner, repo, issueIndex, timeID)\nresp, err := client.ResetIssueTime(owner, repo, issueIndex)\n```\n\n---\n\n## Pull Requests\n\n### CRUD\n```go\n// List\nprs, resp, err := client.ListRepoPullRequests(owner, repo, ListPullRequestsOptions{\n    State: gitea.StateOpen,\n    Sort:  \"newest\",\n})\n\n// Get\npr, resp, err := client.GetPullRequest(owner, repo, prIndex)\n\n// Create\npr, resp, err := client.CreatePullRequest(owner, repo, CreatePullRequestOption{\n    Head:  \"feature-branch\",\n    Base:  \"main\",\n    Title: \"Add feature\",\n    Body:  \"Description\",\n})\n\n// Edit\npr, resp, err := client.EditPullRequest(owner, repo, prIndex, EditPullRequestOption{})\n```\n\n### Merge\n```go\nmerged, resp, err := client.IsPullRequestMerged(owner, repo, prIndex)\nresp, err := client.MergePullRequest(owner, repo, prIndex, MergePullRequestOption{\n    Style:   gitea.MergeStyleSquash,\n    Title:   \"Merge commit title\",\n    Message: \"Merge commit message\",\n})\n```\n\n### Reviews\n```go\nreviews, resp, err := client.ListPullReviews(owner, repo, prIndex, ListPullReviewsOptions{})\nreview, resp, err := client.CreatePullReview(owner, repo, prIndex, CreatePullReviewOptions{\n    State: gitea.ReviewStateApproved,\n    Body:  \"LGTM!\",\n})\nresp, err := client.SubmitPullReview(owner, repo, prIndex, reviewID, SubmitPullReviewOptions{})\nresp, err := client.DismissPullReview(owner, repo, prIndex, reviewID, DismissPullReviewOptions{})\n```\n\n### Files & Diff\n```go\nfiles, resp, err := client.ListPullRequestFiles(owner, repo, prIndex, ListPullRequestFilesOptions{})\ndiff, resp, err := client.GetPullRequestDiff(owner, repo, prIndex, GetPullRequestDiffOptions{})\ncommits, resp, err := client.ListPullRequestCommits(owner, repo, prIndex, ListPullRequestCommitsOptions{})\n```\n\n---\n\n## Releases\n\n```go\n// List\nreleases, resp, err := client.ListReleases(owner, repo, ListReleasesOptions{})\n\n// Get\nrelease, resp, err := client.GetRelease(owner, repo, releaseID)\nrelease, resp, err := client.GetReleaseByTag(owner, repo, tagName)\nrelease, resp, err := client.GetLatestRelease(owner, repo)\n\n// Create\nrelease, resp, err := client.CreateRelease(owner, repo, CreateReleaseOption{\n    TagName:      \"v1.0.0\",\n    Title:        \"Version 1.0\",\n    Note:         \"Release notes\",\n    IsDraft:      false,\n    IsPrerelease: false,\n})\n\n// Edit/Delete\nrelease, resp, err := client.EditRelease(owner, repo, releaseID, EditReleaseOption{})\nresp, err := client.DeleteRelease(owner, repo, releaseID)\nresp, err := client.DeleteReleaseByTag(owner, repo, tagName)\n\n// Attachments\nattachments, resp, err := client.ListReleaseAttachments(owner, repo, releaseID, ListReleaseAttachmentsOptions{})\nattachment, resp, err := client.CreateReleaseAttachment(owner, repo, releaseID, file, filename)\nresp, err := client.DeleteReleaseAttachment(owner, repo, releaseID, attachmentID)\n```\n\n---\n\n## Organizations\n\n```go\n// List\norgs, resp, err := client.ListMyOrgs(ListOrgsOptions{})\norgs, resp, err := client.ListUserOrgs(username, ListOrgsOptions{})\n\n// Get/Create/Edit/Delete\norg, resp, err := client.GetOrg(orgName)\norg, resp, err := client.CreateOrg(CreateOrgOption{Name: \"org\", Visibility: gitea.VisibleTypePublic})\nresp, err := client.EditOrg(orgName, EditOrgOption{})\nresp, err := client.DeleteOrg(orgName)\n\n// Teams\nteams, resp, err := client.ListOrgTeams(org, ListTeamsOptions{})\nteam, resp, err := client.CreateTeam(org, CreateTeamOption{})\nresp, err := client.AddTeamMember(teamID, username)\nresp, err := client.RemoveTeamMember(teamID, username)\n```\n\n---\n\n## Users\n\n```go\n// Current user\nuser, resp, err := client.GetMyUserInfo()\n\n// Other users\nuser, resp, err := client.GetUserInfo(username)\nusers, resp, err := client.SearchUsers(SearchUsersOption{Keyword: \"query\"})\n\n// Keys\nkeys, resp, err := client.ListMyPublicKeys(ListPublicKeysOptions{})\nkey, resp, err := client.CreatePublicKey(CreateKeyOption{Title: \"key\", Key: pubKey})\nresp, err := client.DeletePublicKey(keyID)\n\n// Followers\nusers, resp, err := client.ListMyFollowers(ListFollowersOptions{})\nusers, resp, err := client.ListMyFollowing(ListFollowingOptions{})\nresp, err := client.Follow(username)\nresp, err := client.Unfollow(username)\n```\n\n---\n\n## Webhooks\n\n```go\n// Repository\nhooks, resp, err := client.ListRepoHooks(owner, repo, ListHooksOptions{})\nhook, resp, err := client.CreateRepoHook(owner, repo, CreateHookOption{\n    Type:   gitea.HookTypeGitea,\n    Config: map[string]string{\"url\": hookURL, \"content_type\": \"json\"},\n    Events: []string{\"push\", \"pull_request\"},\n    Active: true,\n})\nresp, err := client.DeleteRepoHook(owner, repo, hookID)\n\n// Organization\nhooks, resp, err := client.ListOrgHooks(org, ListHooksOptions{})\nhook, resp, err := client.CreateOrgHook(org, CreateHookOption{})\n```\n\n---\n\n## Admin (requires admin privileges)\n\n```go\nusers, resp, err := client.AdminListUsers(AdminListUsersOptions{})\nuser, resp, err := client.AdminCreateUser(CreateUserOption{})\nresp, err := client.AdminDeleteUser(username)\nresp, err := client.AdminEditUser(username, EditUserOption{})\n```\n",
        "gitea/skills/go-sdk/references/examples.md": "# Gitea Go SDK Examples\n\n## Client Setup\n\n### Basic Client\n```go\npackage main\n\nimport (\n    \"log\"\n    \"code.gitea.io/sdk/gitea\"\n)\n\nfunc main() {\n    client, err := gitea.NewClient(\n        \"https://gitea.example.com\",\n        gitea.SetToken(\"your-token\"),\n    )\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    user, _, err := client.GetMyUserInfo()\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Printf(\"Logged in as: %s\", user.UserName)\n}\n```\n\n### With Context and Timeout\n```go\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\nclient, _ := gitea.NewClient(url,\n    gitea.SetToken(token),\n    gitea.SetContext(ctx),\n)\n```\n\n---\n\n## Error Handling\n\n### Standard Pattern\n```go\nrepo, resp, err := client.GetRepo(\"owner\", \"repo\")\nif err != nil {\n    if resp != nil && resp.StatusCode == 404 {\n        log.Println(\"Repository not found\")\n        return\n    }\n    log.Fatalf(\"API error: %v\", err)\n}\n// Safe to use repo here\n```\n\n### Checking Specific Errors\n```go\n_, resp, err := client.GetRepo(owner, repo)\nif err != nil {\n    switch resp.StatusCode {\n    case 401:\n        return fmt.Errorf(\"authentication failed\")\n    case 403:\n        return fmt.Errorf(\"access denied\")\n    case 404:\n        return fmt.Errorf(\"not found\")\n    default:\n        return fmt.Errorf(\"API error: %w\", err)\n    }\n}\n```\n\n---\n\n## Pagination\n\n### Iterate All Pages\n```go\nfunc listAllRepos(client *gitea.Client) ([]*gitea.Repository, error) {\n    var allRepos []*gitea.Repository\n    opts := gitea.ListReposOptions{\n        ListOptions: gitea.ListOptions{Page: 1, PageSize: 50},\n    }\n\n    for {\n        repos, resp, err := client.ListMyRepos(opts)\n        if err != nil {\n            return nil, err\n        }\n        allRepos = append(allRepos, repos...)\n\n        if resp.NextPage == 0 {\n            break\n        }\n        opts.Page = resp.NextPage\n    }\n    return allRepos, nil\n}\n```\n\n### Generic Paginator\n```go\nfunc paginate[T any](\n    fetch func(page int) ([]T, *gitea.Response, error),\n) ([]T, error) {\n    var all []T\n    page := 1\n    for {\n        items, resp, err := fetch(page)\n        if err != nil {\n            return nil, err\n        }\n        all = append(all, items...)\n        if resp.NextPage == 0 {\n            break\n        }\n        page = resp.NextPage\n    }\n    return all, nil\n}\n\n// Usage\nissues, err := paginate(func(page int) ([]*gitea.Issue, *gitea.Response, error) {\n    return client.ListRepoIssues(owner, repo, gitea.ListIssueOption{\n        ListOptions: gitea.ListOptions{Page: page, PageSize: 100},\n    })\n})\n```\n\n---\n\n## Common Workflows\n\n### Create Issue with Labels\n```go\nfunc createBugReport(client *gitea.Client, owner, repo, title, body string) (*gitea.Issue, error) {\n    // First, find the \"bug\" label\n    labels, _, err := client.ListRepoLabels(owner, repo, gitea.ListLabelsOptions{})\n    if err != nil {\n        return nil, err\n    }\n\n    var bugLabelID int64\n    for _, label := range labels {\n        if label.Name == \"bug\" {\n            bugLabelID = label.ID\n            break\n        }\n    }\n\n    return client.CreateIssue(owner, repo, gitea.CreateIssueOption{\n        Title:  title,\n        Body:   body,\n        Labels: []int64{bugLabelID},\n    })\n}\n```\n\n### Create PR and Wait for CI\n```go\nfunc createPRAndWaitForCI(client *gitea.Client, owner, repo, head, base, title string) error {\n    // Create PR\n    pr, _, err := client.CreatePullRequest(owner, repo, gitea.CreatePullRequestOption{\n        Head:  head,\n        Base:  base,\n        Title: title,\n    })\n    if err != nil {\n        return err\n    }\n\n    // Poll for CI status\n    for {\n        status, _, err := client.GetCombinedStatus(owner, repo, pr.Head.Sha)\n        if err != nil {\n            return err\n        }\n\n        switch status.State {\n        case gitea.StatusSuccess:\n            log.Println(\"CI passed!\")\n            return nil\n        case gitea.StatusFailure, gitea.StatusError:\n            return fmt.Errorf(\"CI failed: %s\", status.State)\n        default:\n            log.Printf(\"CI status: %s, waiting...\", status.State)\n            time.Sleep(30 * time.Second)\n        }\n    }\n}\n```\n\n### Release with Assets\n```go\nfunc createReleaseWithAssets(client *gitea.Client, owner, repo, tag string, files []string) error {\n    // Create release\n    release, _, err := client.CreateRelease(owner, repo, gitea.CreateReleaseOption{\n        TagName: tag,\n        Title:   fmt.Sprintf(\"Release %s\", tag),\n        Note:    \"Release notes here\",\n    })\n    if err != nil {\n        return err\n    }\n\n    // Upload assets\n    for _, filepath := range files {\n        file, err := os.Open(filepath)\n        if err != nil {\n            return err\n        }\n        defer file.Close()\n\n        _, _, err = client.CreateReleaseAttachment(\n            owner, repo, release.ID,\n            file,\n            path.Base(filepath),\n        )\n        if err != nil {\n            return fmt.Errorf(\"failed to upload %s: %w\", filepath, err)\n        }\n        log.Printf(\"Uploaded: %s\", filepath)\n    }\n    return nil\n}\n```\n\n---\n\n## Webhook Handler\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"log\"\n    \"net/http\"\n    \"code.gitea.io/sdk/gitea\"\n)\n\ntype PushPayload struct {\n    Ref        string            `json:\"ref\"`\n    Before     string            `json:\"before\"`\n    After      string            `json:\"after\"`\n    Commits    []gitea.Commit    `json:\"commits\"`\n    Repository *gitea.Repository `json:\"repository\"`\n    Pusher     *gitea.User       `json:\"pusher\"`\n}\n\ntype PRPayload struct {\n    Action      string            `json:\"action\"`\n    Number      int64             `json:\"number\"`\n    PullRequest *gitea.PullRequest `json:\"pull_request\"`\n    Repository  *gitea.Repository  `json:\"repository\"`\n    Sender      *gitea.User        `json:\"sender\"`\n}\n\nfunc webhookHandler(w http.ResponseWriter, r *http.Request) {\n    eventType := r.Header.Get(\"X-Gitea-Event\")\n\n    switch eventType {\n    case \"push\":\n        var payload PushPayload\n        if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {\n            http.Error(w, err.Error(), 400)\n            return\n        }\n        log.Printf(\"Push to %s by %s: %d commits\",\n            payload.Repository.FullName,\n            payload.Pusher.UserName,\n            len(payload.Commits))\n\n    case \"pull_request\":\n        var payload PRPayload\n        if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {\n            http.Error(w, err.Error(), 400)\n            return\n        }\n        log.Printf(\"PR #%d %s: %s\",\n            payload.Number,\n            payload.Action,\n            payload.PullRequest.Title)\n    }\n\n    w.WriteHeader(200)\n}\n\nfunc main() {\n    http.HandleFunc(\"/webhook\", webhookHandler)\n    log.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n```\n\n---\n\n## Concurrent Operations\n\n```go\nfunc closeStaleIssues(client *gitea.Client, owner, repo string, staleDays int) error {\n    cutoff := time.Now().AddDate(0, 0, -staleDays)\n\n    issues, err := paginate(func(page int) ([]*gitea.Issue, *gitea.Response, error) {\n        return client.ListRepoIssues(owner, repo, gitea.ListIssueOption{\n            State:       gitea.StateOpen,\n            ListOptions: gitea.ListOptions{Page: page},\n        })\n    })\n    if err != nil {\n        return err\n    }\n\n    var wg sync.WaitGroup\n    sem := make(chan struct{}, 10) // Limit concurrency\n\n    for _, issue := range issues {\n        if issue.Updated.Before(cutoff) {\n            wg.Add(1)\n            go func(issue *gitea.Issue) {\n                defer wg.Done()\n                sem <- struct{}{}\n                defer func() { <-sem }()\n\n                closed := gitea.StateClosed\n                _, _, err := client.EditIssue(owner, repo, issue.Index, gitea.EditIssueOption{\n                    State: &closed,\n                })\n                if err != nil {\n                    log.Printf(\"Failed to close #%d: %v\", issue.Index, err)\n                } else {\n                    log.Printf(\"Closed stale issue #%d\", issue.Index)\n                }\n            }(issue)\n        }\n    }\n\n    wg.Wait()\n    return nil\n}\n```\n\n---\n\n## Bot Pattern\n\n```go\ntype Bot struct {\n    client *gitea.Client\n    owner  string\n    repo   string\n}\n\nfunc NewBot(url, token, owner, repo string) (*Bot, error) {\n    client, err := gitea.NewClient(url, gitea.SetToken(token))\n    if err != nil {\n        return nil, err\n    }\n    return &Bot{client: client, owner: owner, repo: repo}, nil\n}\n\nfunc (b *Bot) AutoLabel(issue *gitea.Issue) error {\n    var labels []int64\n\n    // Auto-detect labels from title/body\n    text := strings.ToLower(issue.Title + \" \" + issue.Body)\n    if strings.Contains(text, \"bug\") || strings.Contains(text, \"error\") {\n        labels = append(labels, b.getLabelID(\"bug\"))\n    }\n    if strings.Contains(text, \"feature\") || strings.Contains(text, \"enhancement\") {\n        labels = append(labels, b.getLabelID(\"enhancement\"))\n    }\n\n    if len(labels) > 0 {\n        _, _, err := b.client.AddIssueLabels(b.owner, b.repo, issue.Index,\n            gitea.IssueLabelsOption{Labels: labels})\n        return err\n    }\n    return nil\n}\n\nfunc (b *Bot) getLabelID(name string) int64 {\n    labels, _, _ := b.client.ListRepoLabels(b.owner, b.repo, gitea.ListLabelsOptions{})\n    for _, l := range labels {\n        if l.Name == name {\n            return l.ID\n        }\n    }\n    return 0\n}\n```\n",
        "gitea/skills/go-sdk/references/types.md": "# Gitea Go SDK Types Reference\n\n## Core Types\n\n### Repository\n```go\ntype Repository struct {\n    ID            int64\n    Owner         *User\n    Name          string\n    FullName      string\n    Description   string\n    Private       bool\n    Fork          bool\n    Mirror        bool\n    HTMLURL       string\n    SSHURL        string\n    CloneURL      string\n    DefaultBranch string\n    Stars         int\n    Forks         int\n    Watchers      int\n    OpenIssues    int\n    Size          int\n    Created       time.Time\n    Updated       time.Time\n    Permissions   *Permission\n}\n\ntype Permission struct {\n    Admin bool\n    Push  bool\n    Pull  bool\n}\n```\n\n### Issue\n```go\ntype Issue struct {\n    ID          int64\n    Index       int64\n    URL         string\n    HTMLURL     string\n    Poster      *User\n    Title       string\n    Body        string\n    Labels      []*Label\n    Milestone   *Milestone\n    Assignees   []*User\n    State       StateType  // StateOpen, StateClosed\n    IsLocked    bool\n    Comments    int\n    Created     time.Time\n    Updated     time.Time\n    Closed      *time.Time\n    Deadline    *time.Time\n}\n```\n\n### PullRequest\n```go\ntype PullRequest struct {\n    ID        int64\n    Index     int64\n    URL       string\n    HTMLURL   string\n    Poster    *User\n    Title     string\n    Body      string\n    Labels    []*Label\n    Milestone *Milestone\n    Assignees []*User\n    State     StateType\n    Head      *PRBranchInfo\n    Base      *PRBranchInfo\n    DIFFURL   string\n    PatchURL  string\n    Mergeable bool\n    Merged    bool\n    MergedBy  *User\n    Created   time.Time\n    Updated   time.Time\n    Closed    *time.Time\n    Merged    *time.Time\n}\n\ntype PRBranchInfo struct {\n    Name       string\n    Ref        string\n    Sha        string\n    RepoID     int64\n    Repository *Repository\n}\n```\n\n### Release\n```go\ntype Release struct {\n    ID           int64\n    TagName      string\n    Target       string\n    Title        string\n    Note         string\n    URL          string\n    HTMLURL      string\n    TarURL       string\n    ZipURL       string\n    IsDraft      bool\n    IsPrerelease bool\n    Created      time.Time\n    Published    time.Time\n    Publisher    *User\n    Attachments  []*Attachment\n}\n\ntype Attachment struct {\n    ID            int64\n    Name          string\n    Size          int64\n    DownloadCount int64\n    Created       time.Time\n    UUID          string\n    DownloadURL   string\n}\n```\n\n### User\n```go\ntype User struct {\n    ID          int64\n    UserName    string\n    LoginName   string\n    FullName    string\n    Email       string\n    AvatarURL   string\n    Language    string\n    IsAdmin     bool\n    IsActive    bool\n    Visibility  VisibleType\n    Created     time.Time\n    LastLogin   time.Time\n}\n```\n\n### Organization\n```go\ntype Organization struct {\n    ID          int64\n    UserName    string\n    FullName    string\n    AvatarURL   string\n    Description string\n    Website     string\n    Location    string\n    Visibility  VisibleType\n}\n\ntype Team struct {\n    ID                      int64\n    Name                    string\n    Description             string\n    Organization            *Organization\n    Permission              AccessMode\n    CanCreateOrgRepo        bool\n    IncludesAllRepositories bool\n    Units                   []string\n}\n```\n\n---\n\n## Option Types\n\n### List Options (Pagination)\n```go\ntype ListOptions struct {\n    Page     int  // Page number (1-indexed)\n    PageSize int  // Items per page (default varies)\n}\n```\n\n### Create Options\n```go\ntype CreateRepoOption struct {\n    Name          string\n    Description   string\n    Private       bool\n    AutoInit      bool\n    Gitignores    string\n    License       string\n    Readme        string\n    DefaultBranch string\n}\n\ntype CreateIssueOption struct {\n    Title     string\n    Body      string\n    Assignees []string\n    Deadline  *time.Time\n    Milestone int64\n    Labels    []int64\n    Closed    bool\n}\n\ntype CreatePullRequestOption struct {\n    Head      string\n    Base      string\n    Title     string\n    Body      string\n    Assignees []string\n    Labels    []int64\n    Milestone int64\n    Deadline  *time.Time\n}\n\ntype CreateReleaseOption struct {\n    TagName      string\n    Target       string\n    Title        string\n    Note         string\n    IsDraft      bool\n    IsPrerelease bool\n}\n```\n\n### Edit Options\n```go\ntype EditRepoOption struct {\n    Name          *string\n    Description   *string\n    Private       *bool\n    DefaultBranch *string\n    // Many more fields...\n}\n\ntype EditIssueOption struct {\n    Title     *string\n    Body      *string\n    Assignees []string\n    Milestone *int64\n    State     *StateType\n    Deadline  *time.Time\n}\n```\n\n---\n\n## Enums\n\n### State\n```go\ntype StateType string\nconst (\n    StateOpen   StateType = \"open\"\n    StateClosed StateType = \"closed\"\n    StateAll    StateType = \"all\"\n)\n```\n\n### Merge Style\n```go\ntype MergeStyle string\nconst (\n    MergeStyleMerge        MergeStyle = \"merge\"\n    MergeStyleRebase       MergeStyle = \"rebase\"\n    MergeStyleRebaseMerge  MergeStyle = \"rebase-merge\"\n    MergeStyleSquash       MergeStyle = \"squash\"\n)\n```\n\n### Review State\n```go\ntype ReviewStateType string\nconst (\n    ReviewStateApproved         ReviewStateType = \"APPROVED\"\n    ReviewStatePending          ReviewStateType = \"PENDING\"\n    ReviewStateComment          ReviewStateType = \"COMMENT\"\n    ReviewStateRequestChanges   ReviewStateType = \"REQUEST_CHANGES\"\n    ReviewStateRequestReview    ReviewStateType = \"REQUEST_REVIEW\"\n)\n```\n\n### Visibility\n```go\ntype VisibleType string\nconst (\n    VisibleTypePublic  VisibleType = \"public\"\n    VisibleTypeLimited VisibleType = \"limited\"\n    VisibleTypePrivate VisibleType = \"private\"\n)\n```\n\n### Access Mode\n```go\ntype AccessMode string\nconst (\n    AccessModeNone  AccessMode = \"none\"\n    AccessModeRead  AccessMode = \"read\"\n    AccessModeWrite AccessMode = \"write\"\n    AccessModeAdmin AccessMode = \"admin\"\n    AccessModeOwner AccessMode = \"owner\"\n)\n```\n\n---\n\n## Response Type\n\n```go\ntype Response struct {\n    *http.Response\n    NextPage  int\n    PrevPage  int\n    FirstPage int\n    LastPage  int\n}\n```\n\nUse for pagination:\n```go\nif resp.NextPage > 0 {\n    opts.Page = resp.NextPage\n    // fetch next page\n}\n```\n",
        "gitea/skills/tea-cli/SKILL.md": "---\nname: tea-cli\ndescription: Use when interacting with Gitea via command line - managing issues, PRs, releases, repos, or any git forge operations with tea CLI\n---\n\n# Tea CLI for Gitea\n\n## Overview\n\nTea is the official CLI for Gitea. Use it for quick operations, scripting, and CI/CD workflows. For complex automation or custom integrations, use the `gitea:go-sdk` skill instead.\n\n## Quick Setup\n\n```bash\n# Install\nbrew install tea  # or: go install code.gitea.io/tea@latest\n\n# Authenticate\ntea login add --name myserver --url https://gitea.example.com --token YOUR_TOKEN\n```\n\nSee `references/authentication.md` for detailed auth options.\n\n## Quick Reference\n\n| Task | Command |\n|------|---------|\n| **Issues** | |\n| List issues | `tea issues` |\n| Create issue | `tea issues create --title \"Bug\" --body \"Details\"` |\n| Close issue | `tea issues close 123` |\n| **Pull Requests** | |\n| List PRs | `tea pr` |\n| Create PR | `tea pr create --head feature --base main` |\n| Checkout PR | `tea pr checkout 45` |\n| Merge PR | `tea pr merge 45` |\n| Review PR | `tea pr review 45 --approve` |\n| **Releases** | |\n| List releases | `tea releases` |\n| Create release | `tea release create --tag v1.0.0 --title \"Release\"` |\n| Upload asset | `tea release assets create --tag v1.0.0 FILE` |\n| **Repos** | |\n| List repos | `tea repos` |\n| Create repo | `tea repos create --name myrepo` |\n| Clone repo | `tea clone owner/repo` |\n| Fork repo | `tea repos fork owner/repo` |\n\n## Command Categories\n\nSee `references/commands.md` for complete command reference:\n- Issues & comments\n- Pull requests & reviews\n- Releases & assets\n- Repositories & branches\n- Labels, milestones, organizations\n- Webhooks, notifications, time tracking\n- Actions (secrets/variables)\n\n## Common Workflows\n\nSee `references/workflows.md` for patterns:\n- Feature branch to merged PR\n- Release with assets\n- Issue triage\n- Multi-instance management\n\n## Output Formats\n\n```bash\ntea issues --output json    # JSON\ntea issues --output yaml    # YAML\ntea issues --output csv     # CSV\ntea issues --output simple  # Plain text\n```\n\n## Repository Context\n\nTea auto-detects repo from current directory's git remote. Override with:\n```bash\ntea issues --repo owner/repo\ntea issues --login myserver  # specific Gitea instance\n```\n\n## Common Mistakes\n\n| Problem | Solution |\n|---------|----------|\n| \"not logged in\" | Run `tea login add` first |\n| Wrong repo context | Use `--repo owner/repo` flag |\n| Can't find PR | Check `--state` flag (open/closed/all) |\n| Token expired | Re-run `tea login add` with new token |\n",
        "gitea/skills/tea-cli/references/authentication.md": "# Tea CLI Authentication\n\n## Token Creation\n\n1. Open Gitea web UI\n2. Go to **Settings  Applications**\n3. Under \"Generate New Token\", enter a name\n4. Select scopes (or leave empty for full access)\n5. Click **Generate Token**\n6. Copy the token immediately (shown only once)\n\n## Adding a Login\n\n```bash\n# Interactive\ntea login add\n\n# Non-interactive\ntea login add \\\n  --name myserver \\\n  --url https://gitea.example.com \\\n  --token ghp_xxxxxxxxxxxx\n\n# With SSH key authentication\ntea login add \\\n  --name myserver \\\n  --url https://gitea.example.com \\\n  --ssh-key ~/.ssh/id_ed25519\n```\n\n## Managing Logins\n\n```bash\ntea login list              # List all logins\ntea login default myserver  # Set default\ntea login edit myserver     # Modify login\ntea login delete myserver   # Remove login\n```\n\n## Environment Variables\n\n```bash\nexport GITEA_SERVER_URL=https://gitea.example.com\nexport GITEA_SERVER_TOKEN=your_token\n\n# Or per-command\nGITEA_SERVER_TOKEN=xxx tea issues\n```\n\n## Multiple Instances\n\n```bash\n# Add multiple servers\ntea login add --name work --url https://git.work.com --token xxx\ntea login add --name personal --url https://gitea.io --token yyy\n\n# Switch between them\ntea issues --login work\ntea pr --login personal\n\n# Set default\ntea login default work\n```\n\n## OAuth Flow\n\n```bash\n# Browser-based OAuth\ntea login add --name myserver --url https://gitea.example.com\n\n# Refresh expired OAuth token\ntea login oauth-refresh myserver\n```\n\n## CI/CD Usage\n\n```yaml\n# GitHub Actions example\n- name: Create PR\n  env:\n    GITEA_SERVER_URL: ${{ secrets.GITEA_URL }}\n    GITEA_SERVER_TOKEN: ${{ secrets.GITEA_TOKEN }}\n  run: tea pr create --head ${{ github.ref_name }} --base main\n```\n\n## Troubleshooting\n\n| Issue | Solution |\n|-------|----------|\n| \"401 Unauthorized\" | Token expired or invalid - regenerate |\n| \"no login\" | Run `tea login add` first |\n| Wrong server | Check `tea login list`, use `--login name` |\n| SSH auth fails | Ensure key is added to Gitea account |\n",
        "gitea/skills/tea-cli/references/commands.md": "# Tea CLI Command Reference\n\n## Global Flags\n\nAll commands support:\n```\n--login, -l     Use specific login\n--repo, -r      Override repository (owner/repo)\n--output, -o    Output format: table|csv|simple|tsv|yaml|json\n```\n\n---\n\n## Issues\n\n```bash\ntea issues                          # List open issues\ntea issues --state all              # All issues\ntea issues --state closed           # Closed only\ntea issues --mine                   # Assigned to me\ntea issues --author username        # By author\ntea issues --labels bug,urgent      # With labels\ntea issues --milestones v1.0        # In milestone\n\ntea issues create \\\n  --title \"Title\" \\\n  --body \"Description\" \\\n  --labels bug,priority \\\n  --assignees user1,user2 \\\n  --milestone \"v1.0\"\n\ntea issues edit 123 --title \"New title\"\ntea issues close 123\ntea issues reopen 123\n\n# View issue details\ntea issues 123\n```\n\n## Pull Requests\n\n```bash\ntea pr                              # List open PRs\ntea pr --state all\ntea pr --author username\n\ntea pr create \\\n  --head feature-branch \\\n  --base main \\\n  --title \"Add feature\" \\\n  --body \"Description\"\n\ntea pr edit 45 --title \"Updated title\"\ntea pr close 45\ntea pr reopen 45\n\n# Checkout PR locally\ntea pr checkout 45\ntea pr clean                        # Remove checked-out PR branches\n\n# Reviews\ntea pr review 45 --approve\ntea pr review 45 --reject --body \"Needs changes\"\ntea pr review 45 --comment --body \"Looking good\"\ntea pr approve 45                   # Shorthand\ntea pr reject 45\n\n# Merge\ntea pr merge 45                     # Default merge\ntea pr merge 45 --style rebase\ntea pr merge 45 --style squash\n\n# View PR details\ntea pr 45\n```\n\n## Releases\n\n```bash\ntea releases                        # List releases\ntea release 1                       # View release details\n\ntea release create \\\n  --tag v1.0.0 \\\n  --title \"Version 1.0\" \\\n  --note \"Release notes here\" \\\n  --draft \\\n  --prerelease\n\ntea release edit 1 --title \"New title\"\ntea release delete 1\n\n# Assets\ntea release assets 1                # List assets\ntea release assets create 1 ./dist/app.zip\ntea release assets delete 1 asset-id\n```\n\n## Repositories\n\n```bash\ntea repos                           # List your repos\ntea repos --type owner              # Owned repos\ntea repos --type member             # Member repos\ntea repos search query              # Search repos\n\ntea repos create \\\n  --name myrepo \\\n  --description \"Description\" \\\n  --private \\\n  --init                            # Initialize with README\n\ntea repos create-from-template \\\n  --template owner/template \\\n  --name newrepo\n\ntea repos fork owner/repo\ntea repos fork owner/repo --name myfork\n\ntea repos migrate \\\n  --clone-addr https://github.com/owner/repo \\\n  --repo-name imported\n\ntea repos delete owner/repo\n\n# Clone\ntea clone owner/repo\ntea clone owner/repo --depth 1\n```\n\n## Branches\n\n```bash\ntea branches                        # List branches\ntea branches --output json\n\ntea branches protect main           # Protect branch\ntea branches unprotect main\n```\n\n## Labels\n\n```bash\ntea labels                          # List labels\ntea labels create \\\n  --name bug \\\n  --color \"#ff0000\" \\\n  --description \"Bug reports\"\n\ntea labels update bug --color \"#cc0000\"\ntea labels delete bug\n```\n\n## Milestones\n\n```bash\ntea milestones                      # List milestones\ntea ms                              # Alias\n\ntea milestones create \\\n  --title \"v1.0\" \\\n  --description \"First release\" \\\n  --deadline 2024-12-31\n\ntea milestones close 1\ntea milestones reopen 1\ntea milestones delete 1\ntea milestones issues 1             # Issues in milestone\n```\n\n## Organizations\n\n```bash\ntea orgs                            # List organizations\ntea orgs create \\\n  --name myorg \\\n  --description \"Organization\"\n\ntea orgs delete myorg\n```\n\n## Comments\n\n```bash\ntea comment 123 --body \"Comment text\"    # Comment on issue #123\ntea comment 45 --body \"LGTM\"             # Comment on PR #45\n```\n\n## Notifications\n\n```bash\ntea notifications                   # List notifications\ntea notifications mark-read 1       # Mark as read\ntea notifications mark-read --all   # Mark all as read\ntea notifications mark-pinned 1     # Pin notification\ntea notifications unpin 1\n```\n\n## Time Tracking\n\n```bash\ntea times                           # List tracked times\ntea times --mine                    # My tracked time\ntea times add 123 1h30m             # Add time to issue\ntea times delete 123 time-id\ntea times reset 123                 # Reset issue time\n```\n\n## Webhooks\n\n```bash\ntea webhooks                        # List repo webhooks\ntea webhooks --org myorg            # Org webhooks\n\ntea webhooks create \\\n  --url https://example.com/hook \\\n  --events push,pull_request \\\n  --secret mysecret\n\ntea webhooks update 1 --url https://new.url\ntea webhooks delete 1\n```\n\n## Actions (CI/CD)\n\n```bash\n# Secrets\ntea actions secrets                 # List secrets\ntea actions secrets create \\\n  --name SECRET_NAME \\\n  --value \"secret-value\"\ntea actions secrets delete SECRET_NAME\n\n# Variables\ntea actions variables               # List variables\ntea actions variables set VAR_NAME \"value\"\ntea actions variables delete VAR_NAME\n```\n\n## Utility Commands\n\n```bash\ntea whoami                          # Current user info\ntea open                            # Open repo in browser\ntea open 123                        # Open issue #123\ntea open pulls                      # Open PRs page\ntea open milestones                 # Open milestones page\n```\n\n## Admin Commands\n\n```bash\ntea admin users                     # List all users (admin only)\n```\n",
        "gitea/skills/tea-cli/references/workflows.md": "# Tea CLI Workflows\n\n## Feature Branch to PR\n\n```bash\n# 1. Create branch and make changes\ngit checkout -b feature/new-feature\n# ... make changes ...\ngit add . && git commit -m \"Add new feature\"\ngit push -u origin feature/new-feature\n\n# 2. Create PR\ntea pr create \\\n  --head feature/new-feature \\\n  --base main \\\n  --title \"Add new feature\" \\\n  --body \"## Changes\n- Added X\n- Fixed Y\n\n## Testing\n- [ ] Unit tests pass\n- [ ] Manual testing done\"\n\n# 3. Address review feedback\n# ... make changes ...\ngit push\n\n# 4. Merge when approved\ntea pr merge 45 --style squash\n```\n\n## Release Workflow\n\n```bash\n# 1. Create and push tag\ngit tag -a v1.0.0 -m \"Release v1.0.0\"\ngit push origin v1.0.0\n\n# 2. Create release\ntea release create \\\n  --tag v1.0.0 \\\n  --title \"Version 1.0.0\" \\\n  --note \"## What's New\n- Feature A\n- Feature B\n\n## Bug Fixes\n- Fixed issue #42\"\n\n# 3. Upload release assets\ntea release assets create --tag v1.0.0 ./dist/app-linux-amd64\ntea release assets create --tag v1.0.0 ./dist/app-darwin-amd64\ntea release assets create --tag v1.0.0 ./dist/app-windows-amd64.exe\n```\n\n## Issue Triage\n\n```bash\n# Review new issues\ntea issues --state open --labels \"\"\n\n# Label and assign\ntea issues edit 123 \\\n  --labels bug,priority-high \\\n  --assignees developer1 \\\n  --milestone v1.1\n\n# Close duplicates\ntea comment 124 --body \"Duplicate of #123\"\ntea issues close 124\n```\n\n## Batch Operations with Scripts\n\n```bash\n# Close all issues with label \"wontfix\"\ntea issues --labels wontfix --output json | \\\n  jq -r '.[].number' | \\\n  xargs -I {} tea issues close {}\n\n# Export all issues to CSV\ntea issues --state all --output csv > issues.csv\n\n# Create issues from file\nwhile IFS=, read -r title body labels; do\n  tea issues create --title \"$title\" --body \"$body\" --labels \"$labels\"\ndone < issues.csv\n```\n\n## Multi-Instance Workflow\n\n```bash\n# Morning: Check work notifications\ntea notifications --login work\n\n# Create issue on work instance\ntea issues create --login work \\\n  --repo team/project \\\n  --title \"Bug report\"\n\n# Evening: Personal project\ntea pr --login personal\n```\n\n## CI/CD Integration\n\n```yaml\n# .github/workflows/pr.yml (or Gitea Actions)\nname: Create PR\non:\n  push:\n    branches: [feature/*]\n\njobs:\n  create-pr:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install tea\n        run: |\n          curl -sL https://dl.gitea.com/tea/main/tea-main-linux-amd64 -o tea\n          chmod +x tea\n\n      - name: Create PR\n        env:\n          GITEA_SERVER_URL: ${{ secrets.GITEA_URL }}\n          GITEA_SERVER_TOKEN: ${{ secrets.GITEA_TOKEN }}\n        run: |\n          ./tea pr create \\\n            --head ${GITHUB_REF_NAME} \\\n            --base main \\\n            --title \"Auto PR: ${GITHUB_REF_NAME}\"\n```\n\n## PR Review Workflow\n\n```bash\n# 1. List PRs awaiting review\ntea pr --state open\n\n# 2. Checkout and test locally\ntea pr checkout 45\nmake test\n\n# 3. Approve or request changes\ntea pr approve 45\n# or\ntea pr review 45 --reject --body \"Please fix the failing tests\"\n\n# 4. Clean up after merge\ntea pr clean\n```\n\n## Managing Labels Across Repos\n\n```bash\n# Export labels from one repo\ntea labels --output json > labels.json\n\n# Apply to another repo (script)\ncat labels.json | jq -c '.[]' | while read label; do\n  name=$(echo $label | jq -r '.name')\n  color=$(echo $label | jq -r '.color')\n  desc=$(echo $label | jq -r '.description')\n  tea labels create --repo other/repo \\\n    --name \"$name\" --color \"$color\" --description \"$desc\"\ndone\n```\n",
        "hetzner/.claude-plugin/plugin.json": "{\n  \"name\": \"hetzner\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Skills for Hetzner Cloud: hcloud CLI operations and Go SDK development\",\n  \"author\": {\n    \"name\": \"German Arutyunov\"\n  },\n  \"repository\": \"https://github.com/gaarutyunov/dev-skills\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"hetzner\", \"hcloud\", \"cloud\", \"infrastructure\", \"sdk\", \"go\", \"cli\", \"api\", \"servers\", \"vps\"]\n}\n",
        "hetzner/README.md": "# Hetzner Cloud Skills\n\nSkills for working with Hetzner Cloud infrastructure via CLI and Go SDK.\n\n## Skills Included\n\n### hcloud-cli\n\nReference skill for the official Hetzner Cloud CLI (`hcloud`).\n\n**Use when:** Managing Hetzner Cloud resources via command line - servers, networks, volumes, load balancers, firewalls, DNS, or any cloud infrastructure operations.\n\n**Covers:**\n- Server lifecycle management\n- Network and subnet configuration\n- Volume creation and attachment\n- Firewall rules and application\n- Load balancer setup\n- DNS zone management\n- Multi-project context management\n- Output formatting (JSON, YAML, Go templates)\n\n### hcloud-go-sdk\n\nReference skill for the official Hetzner Cloud Go SDK (`hcloud-go`).\n\n**Use when:** Writing Go code to interact with Hetzner Cloud API - automation, infrastructure provisioning, bots, integrations.\n\n**Covers:**\n- Client configuration and authentication\n- CRUD operations for all resource types\n- Action polling and error handling\n- Pagination patterns\n- Complete API reference\n\n## Installation\n\n```bash\n/plugin marketplace add /path/to/dev-skills\n/plugin install hetzner@dev-skills\n```\n\n## Resources\n\n- [Hetzner Cloud Console](https://console.hetzner.cloud)\n- [Hetzner Cloud API Docs](https://docs.hetzner.cloud/)\n- [hcloud CLI GitHub](https://github.com/hetznercloud/cli)\n- [hcloud-go SDK GitHub](https://github.com/hetznercloud/hcloud-go)\n",
        "hetzner/skills/hcloud-cli/SKILL.md": "---\nname: hcloud-cli\ndescription: Use when interacting with Hetzner Cloud via command line - managing servers, networks, volumes, load balancers, firewalls, DNS, or any cloud infrastructure operations with hcloud CLI\n---\n\n# Hetzner Cloud CLI (hcloud)\n\n## Overview\n\nhcloud is the official CLI for Hetzner Cloud. Use it for quick operations, scripting, and CI/CD workflows. For complex automation or custom Go integrations, use the `hetzner:hcloud-go-sdk` skill instead.\n\n## Quick Setup\n\n```bash\n# Install\nbrew install hcloud  # or: go install github.com/hetznercloud/cli/cmd/hcloud@latest\n\n# Authenticate\nhcloud context create myproject\n# Enter your API token when prompted (from https://console.hetzner.cloud)\n```\n\nSee `references/configuration.md` for multi-project and advanced setup.\n\n## Quick Reference\n\n| Task | Command |\n|------|---------|\n| **Servers** | |\n| List servers | `hcloud server list` |\n| Create server | `hcloud server create --name web --type cpx22 --image ubuntu-24.04` |\n| SSH to server | `hcloud server ssh web` |\n| Delete server | `hcloud server delete web` |\n| Reboot/Reset | `hcloud server reboot web` / `hcloud server reset web` |\n| **Networks** | |\n| Create network | `hcloud network create --name private --ip-range 10.0.0.0/8` |\n| Attach server | `hcloud server attach-to-network web --network private` |\n| **Volumes** | |\n| Create volume | `hcloud volume create --name data --size 100 --server web` |\n| Attach volume | `hcloud volume attach data --server web --automount` |\n| **Firewalls** | |\n| Create firewall | `hcloud firewall create --name web-fw` |\n| Add rule | `hcloud firewall add-rule web-fw --direction in --protocol tcp --port 80` |\n| Apply to server | `hcloud firewall apply-to-resource web-fw --type server --server web` |\n| **Load Balancers** | |\n| Create LB | `hcloud load-balancer create --name lb --type lb11 --location fsn1` |\n| Add target | `hcloud load-balancer add-target lb --server web` |\n| **SSH Keys** | |\n| Upload key | `hcloud ssh-key create --name mykey --public-key-from-file ~/.ssh/id_rsa.pub` |\n| **DNS (Zones)** | |\n| List zones | `hcloud zone list` |\n| Create zone | `hcloud zone create --name example.com` |\n\n## Command Categories\n\nSee `references/commands.md` for complete command reference:\n- Servers (lifecycle, rescue, metrics, console)\n- Networks, subnets, routes\n- Volumes, storage boxes\n- Firewalls and rules\n- Load balancers, targets, services\n- Floating IPs, primary IPs\n- SSH keys, images, ISOs\n- DNS zones and records\n- Certificates, placement groups\n\n## Output Formats\n\n```bash\n# JSON output for scripting\nhcloud server list --output json | jq '.[] | select(.status == \"running\")'\n\n# YAML output\nhcloud server describe web --output yaml\n\n# Go template formatting\nhcloud server describe web --output format='{{.ServerType.Cores}} cores'\n\n# Table customization\nhcloud server list --output columns=id,name,status,ipv4\nhcloud server list --output noheader\n```\n\n## Context Management (Multi-Project)\n\n```bash\n# Create contexts for different projects/tokens\nhcloud context create production\nhcloud context create staging\n\n# Switch context\nhcloud context use production\n\n# List contexts\nhcloud context list\n```\n\n## Common Patterns\n\n```bash\n# Create server with SSH key and private network\nhcloud server create \\\n  --name web-01 \\\n  --type cpx22 \\\n  --image ubuntu-24.04 \\\n  --ssh-key mykey \\\n  --network private \\\n  --location fsn1\n\n# Create firewall with rules file\nhcloud firewall create --name web-fw --rules-file rules.json\n\n# Bulk server creation\nfor i in {1..3}; do\n  hcloud server create --name \"node-$i\" --type cx22 --image ubuntu-24.04\ndone\n\n# Wait for server to be running\nhcloud server create --name app --type cx22 --image ubuntu-24.04\nwhile [[ $(hcloud server describe app -o format='{{.Status}}') != \"running\" ]]; do\n  sleep 2\ndone\n```\n\n## Common Mistakes\n\n| Problem | Solution |\n|---------|----------|\n| \"context not set\" | Run `hcloud context create <name>` and enter token |\n| \"resource not found\" | Check `hcloud <resource> list` - might be in different project |\n| Token expired | Update with `hcloud context create <name>` (same name replaces) |\n| Wrong location | Use `--location fsn1` or `nbg1` or `hel1` explicitly |\n| Server unreachable | Check firewall rules, ensure SSH port 22 is open |\n| Volume not visible | Use `--automount` or mount manually via SSH |\n",
        "hetzner/skills/hcloud-cli/references/commands.md": "# hcloud CLI Command Reference\n\n## Global Flags\n\n```bash\n--config string      Config file (default ~/.config/hcloud/cli.toml)\n--context string     Active context name\n--endpoint string    Hetzner Cloud API endpoint\n--debug             Enable debug output\n--poll-interval     Action polling interval (default 500ms)\n--quiet             Only print errors\n--output            Output format: table|json|yaml|format=|columns=|noheader\n```\n\n---\n\n## Servers\n\n### Lifecycle\n```bash\nhcloud server list [--status running|starting|stopping|off]\nhcloud server describe <name|id>\nhcloud server create --name NAME --type TYPE --image IMAGE [options]\nhcloud server delete <name|id>\nhcloud server rebuild <name|id> --image IMAGE\nhcloud server update <name|id> [--name NEW_NAME]\n\n# Power\nhcloud server poweron <name|id>\nhcloud server poweroff <name|id>\nhcloud server shutdown <name|id>     # Graceful via ACPI\nhcloud server reboot <name|id>       # Graceful\nhcloud server reset <name|id>        # Hard reset\n```\n\n### Create Options\n```bash\nhcloud server create \\\n  --name NAME \\\n  --type cx22|cpx22|cax21|...        # Server type\n  --image ubuntu-24.04|debian-12|... # OS image\n  --location fsn1|nbg1|hel1|ash|hil  # Datacenter location\n  --datacenter fsn1-dc14             # Specific datacenter\n  --ssh-key KEY_NAME                 # SSH key (repeatable)\n  --network NETWORK                  # Private network (repeatable)\n  --firewall FIREWALL                # Firewall (repeatable)\n  --volume VOLUME                    # Volume to attach (repeatable)\n  --user-data-from-file FILE         # Cloud-init user data\n  --label key=value                  # Labels (repeatable)\n  --placement-group GROUP            # Placement group\n  --public-net-ipv4-disabled         # No public IPv4\n  --public-net-ipv6-disabled         # No public IPv6\n  --start-after-create=false         # Don't start immediately\n  --automount                        # Auto-mount volumes\n  --without-ipv4                     # Skip IPv4 allocation\n  --without-ipv6                     # Skip IPv6 allocation\n```\n\n### Networking\n```bash\nhcloud server attach-to-network <server> --network NETWORK [--ip IP]\nhcloud server detach-from-network <server> --network NETWORK\nhcloud server change-alias-ips <server> --network NETWORK --alias-ips IP1,IP2\nhcloud server set-rdns <server> --ip IP --hostname FQDN\n```\n\n### Other Operations\n```bash\nhcloud server ssh <server> [-i IDENTITY_FILE] [-- COMMAND]\nhcloud server enable-rescue <server> [--type linux64|linux32|freebsd64]\nhcloud server disable-rescue <server>\nhcloud server request-console <server>       # Get VNC console URL\nhcloud server reset-password <server>        # Root password\nhcloud server change-type <server> --type TYPE [--upgrade-disk]\nhcloud server enable-backup <server>\nhcloud server disable-backup <server>\nhcloud server create-image <server> --type snapshot|backup\nhcloud server metrics <server> --type cpu|disk|network\nhcloud server enable-protection <server> --type delete|rebuild\nhcloud server disable-protection <server> --type delete|rebuild\nhcloud server add-label <server> key=value\nhcloud server remove-label <server> key\n```\n\n---\n\n## Networks\n\n```bash\nhcloud network list\nhcloud network describe <name|id>\nhcloud network create --name NAME --ip-range CIDR\nhcloud network delete <name|id>\nhcloud network update <name|id> --name NEW_NAME\nhcloud network add-label <network> key=value\nhcloud network remove-label <network> key\n\n# Subnets\nhcloud network add-subnet <network> \\\n  --type cloud|server|vswitch \\\n  --network-zone eu-central|us-east|us-west \\\n  --ip-range CIDR\nhcloud network remove-subnet <network> --ip-range CIDR\n\n# Routes\nhcloud network add-route <network> --destination CIDR --gateway IP\nhcloud network remove-route <network> --destination CIDR --gateway IP\n\n# Protection\nhcloud network enable-protection <network> --type delete\nhcloud network disable-protection <network> --type delete\n```\n\n---\n\n## Volumes\n\n```bash\nhcloud volume list [--status available|creating]\nhcloud volume describe <name|id>\nhcloud volume create --name NAME --size SIZE_GB [--server SERVER] [--location LOCATION]\nhcloud volume delete <name|id>\nhcloud volume update <name|id> --name NEW_NAME\nhcloud volume resize <name|id> --size SIZE_GB\n\n# Attach/Detach\nhcloud volume attach <volume> --server SERVER [--automount]\nhcloud volume detach <volume>\n\n# Protection\nhcloud volume enable-protection <volume> --type delete\nhcloud volume disable-protection <volume> --type delete\n```\n\n---\n\n## Firewalls\n\n```bash\nhcloud firewall list\nhcloud firewall describe <name|id>\nhcloud firewall create --name NAME [--rules-file FILE]\nhcloud firewall delete <name|id>\nhcloud firewall update <name|id> --name NEW_NAME\nhcloud firewall set-rules <firewall> --rules-file FILE\nhcloud firewall replace-rules <firewall> --rules-file FILE\n\n# Rules\nhcloud firewall add-rule <firewall> \\\n  --direction in|out \\\n  --protocol tcp|udp|icmp|esp|gre \\\n  --port PORT|RANGE                  # e.g., 80, 8000-9000\n  --source-ips CIDR                  # For inbound (repeatable)\n  --destination-ips CIDR             # For outbound (repeatable)\n  --description \"Description\"\nhcloud firewall delete-rule <firewall> \\\n  --direction in|out --protocol tcp --port PORT\n\n# Apply to resources\nhcloud firewall apply-to-resource <firewall> \\\n  --type server|label_selector \\\n  --server SERVER                    # For type server\n  --label-selector \"env=prod\"        # For type label_selector\nhcloud firewall remove-from-resource <firewall> --type TYPE [options]\n```\n\n### Rules File Format (JSON)\n```json\n[\n  {\n    \"direction\": \"in\",\n    \"protocol\": \"tcp\",\n    \"port\": \"80\",\n    \"source_ips\": [\"0.0.0.0/0\", \"::/0\"],\n    \"description\": \"HTTP\"\n  },\n  {\n    \"direction\": \"in\",\n    \"protocol\": \"tcp\",\n    \"port\": \"443\",\n    \"source_ips\": [\"0.0.0.0/0\", \"::/0\"],\n    \"description\": \"HTTPS\"\n  }\n]\n```\n\n---\n\n## Load Balancers\n\n```bash\nhcloud load-balancer list\nhcloud load-balancer describe <name|id>\nhcloud load-balancer create --name NAME --type lb11 --location LOCATION\nhcloud load-balancer delete <name|id>\nhcloud load-balancer update <name|id> --name NEW_NAME\nhcloud load-balancer metrics <lb> --type open_connections|...\n\n# Targets\nhcloud load-balancer add-target <lb> \\\n  --server SERVER [--use-private-ip]\n  # or --label-selector \"env=prod\" [--use-private-ip]\n  # or --ip IP\nhcloud load-balancer remove-target <lb> --server SERVER\nhcloud load-balancer update-targets <lb>\n\n# Services\nhcloud load-balancer add-service <lb> \\\n  --protocol http|https|tcp \\\n  --listen-port PORT \\\n  --destination-port PORT \\\n  --http-redirect-http              # Redirect HTTP to HTTPS\n  --http-sticky-sessions            # Enable sticky sessions\n  --http-cookie-name NAME           # Cookie name for stickiness\n  --http-cookie-lifetime SECONDS\n  --health-check-protocol http|https|tcp \\\n  --health-check-port PORT \\\n  --health-check-interval SECONDS \\\n  --health-check-timeout SECONDS \\\n  --health-check-retries N \\\n  --health-check-http-domain DOMAIN \\\n  --health-check-http-path /health \\\n  --health-check-http-status-codes 2??,3??\nhcloud load-balancer update-service <lb> --listen-port PORT [options]\nhcloud load-balancer delete-service <lb> --listen-port PORT\n\n# Network\nhcloud load-balancer attach-to-network <lb> --network NETWORK [--ip IP]\nhcloud load-balancer detach-from-network <lb> --network NETWORK\nhcloud load-balancer change-algorithm <lb> --algorithm round_robin|least_connections\n\n# Public IP\nhcloud load-balancer enable-public-interface <lb>\nhcloud load-balancer disable-public-interface <lb>\nhcloud load-balancer change-type <lb> --type lb11|lb21|lb31\n```\n\n---\n\n## Floating IPs\n\n```bash\nhcloud floating-ip list\nhcloud floating-ip describe <id>\nhcloud floating-ip create --type ipv4|ipv6 --home-location LOCATION\nhcloud floating-ip delete <id>\nhcloud floating-ip update <id> --description DESC\n\n# Assign/Unassign\nhcloud floating-ip assign <ip> --server SERVER\nhcloud floating-ip unassign <ip>\n\n# DNS\nhcloud floating-ip set-rdns <ip> --hostname FQDN\n```\n\n---\n\n## Primary IPs\n\n```bash\nhcloud primary-ip list\nhcloud primary-ip describe <name|id>\nhcloud primary-ip create --name NAME --type ipv4|ipv6 --datacenter DC\nhcloud primary-ip delete <name|id>\nhcloud primary-ip update <name|id> [--name NAME] [--auto-delete]\n\n# Assign/Unassign\nhcloud primary-ip assign <ip> --server SERVER\nhcloud primary-ip unassign <ip>\n```\n\n---\n\n## SSH Keys\n\n```bash\nhcloud ssh-key list\nhcloud ssh-key describe <name|id>\nhcloud ssh-key create --name NAME --public-key \"ssh-rsa AAAA...\"\nhcloud ssh-key create --name NAME --public-key-from-file ~/.ssh/id_rsa.pub\nhcloud ssh-key delete <name|id>\nhcloud ssh-key update <name|id> --name NEW_NAME\n```\n\n---\n\n## Images\n\n```bash\nhcloud image list [--type system|snapshot|backup|app]\nhcloud image describe <name|id>\nhcloud image delete <id>                    # Snapshots/backups only\nhcloud image update <id> --description DESC\nhcloud image enable-protection <id> --type delete\nhcloud image disable-protection <id> --type delete\n```\n\n---\n\n## DNS Zones\n\n```bash\nhcloud zone list\nhcloud zone describe <name|id>\nhcloud zone create --name example.com\nhcloud zone delete <name|id>\nhcloud zone update <name|id> --name NEW_NAME\nhcloud zone import <zone> --file ZONEFILE\nhcloud zone export <zone>\n\n# Records (via file import or API)\n# Use zone import with standard BIND zone file format\n```\n\n---\n\n## Certificates\n\n```bash\nhcloud certificate list\nhcloud certificate describe <name|id>\nhcloud certificate delete <name|id>\n\n# Managed (Let's Encrypt)\nhcloud certificate create --name NAME --type managed --domain example.com\nhcloud certificate retry <name|id>  # Retry failed issuance\n\n# Uploaded\nhcloud certificate create --name NAME --type uploaded \\\n  --cert-file cert.pem --key-file key.pem\n```\n\n---\n\n## Placement Groups\n\n```bash\nhcloud placement-group list\nhcloud placement-group describe <name|id>\nhcloud placement-group create --name NAME --type spread\nhcloud placement-group delete <name|id>\nhcloud placement-group update <name|id> --name NEW_NAME\n```\n\n---\n\n## Reference Data\n\n```bash\n# Server types\nhcloud server-type list\nhcloud server-type describe cx22\n\n# Locations\nhcloud location list\nhcloud location describe fsn1\n\n# Datacenters\nhcloud datacenter list\nhcloud datacenter describe fsn1-dc14\n\n# ISOs\nhcloud iso list\nhcloud iso describe <name|id>\n```\n\n---\n\n## Context & Config\n\n```bash\n# Contexts\nhcloud context create NAME           # Prompts for token\nhcloud context list\nhcloud context use NAME\nhcloud context delete NAME\n\n# Config\nhcloud config list                   # Show all config\nhcloud config get KEY\nhcloud config set KEY VALUE\nhcloud config unset KEY\n```\n",
        "hetzner/skills/hcloud-cli/references/configuration.md": "# hcloud CLI Configuration Reference\n\n## Configuration Hierarchy\n\nSettings are applied in order (later overrides earlier):\n\n1. **Config file** (`~/.config/hcloud/cli.toml`)\n2. **Environment variables** (`HCLOUD_*`)\n3. **Command-line flags** (`--flag`)\n\n## Configuration File\n\nDefault location: `~/.config/hcloud/cli.toml`\n\nOverride with `HCLOUD_CONFIG` env var or `--config` flag.\n\n### Format\n```toml\n# Active context name\nactive_context = \"production\"\n\n# Preferences (applied to all contexts)\n[preferences]\ndebug = false\npoll_interval = \"500ms\"\n\n# Context-specific settings\n[[contexts]]\nname = \"production\"\ntoken = \"your-api-token\"\n\n[[contexts]]\nname = \"staging\"\ntoken = \"another-token\"\n\n# Context-specific preference overrides\n[contexts.preferences]\npoll_interval = \"1s\"\n```\n\n## Environment Variables\n\n| Variable | Description | Example |\n|----------|-------------|---------|\n| `HCLOUD_TOKEN` | API token (overrides context) | `export HCLOUD_TOKEN=xxx` |\n| `HCLOUD_CONTEXT` | Active context name | `export HCLOUD_CONTEXT=prod` |\n| `HCLOUD_CONFIG` | Config file path | `export HCLOUD_CONFIG=/path/to/cli.toml` |\n| `HCLOUD_ENDPOINT` | Custom API endpoint | `export HCLOUD_ENDPOINT=https://...` |\n| `HCLOUD_DEBUG` | Enable debug output | `export HCLOUD_DEBUG=1` |\n\n## Multi-Project Setup\n\n### Create Contexts\n```bash\n# Interactive (prompts for token)\nhcloud context create production\nhcloud context create staging\nhcloud context create development\n\n# Switch between contexts\nhcloud context use production\nhcloud context list\n```\n\n### CI/CD Usage\n```bash\n# Use environment variable (no config file needed)\nexport HCLOUD_TOKEN=\"your-token\"\nhcloud server list\n\n# Or specify context per-command\nhcloud server list --context staging\n```\n\n## API Token\n\n1. Go to https://console.hetzner.cloud\n2. Select your project\n3. Navigate to **Security** > **API Tokens**\n4. Generate a token with appropriate permissions:\n   - **Read**: List/describe resources\n   - **Read & Write**: Full management access\n\n**Security Note**: Never commit tokens. Use:\n- Environment variables in CI/CD\n- Secrets management (Vault, AWS Secrets Manager)\n- Per-project tokens with minimal permissions\n\n## Locations & Datacenters\n\n| Location Code | City | Network Zone |\n|---------------|------|--------------|\n| `fsn1` | Falkenstein, DE | eu-central |\n| `nbg1` | Nuremberg, DE | eu-central |\n| `hel1` | Helsinki, FI | eu-central |\n| `ash` | Ashburn, US | us-east |\n| `hil` | Hillsboro, US | us-west |\n\n```bash\n# List all locations\nhcloud location list\n\n# List datacenters\nhcloud datacenter list\n```\n\n## Debug Mode\n\n```bash\n# Enable for single command\nhcloud server list --debug\n\n# Enable globally\nexport HCLOUD_DEBUG=1\n\n# Or in config\n[preferences]\ndebug = true\n```\n\nDebug output shows:\n- HTTP requests/responses\n- API endpoint URLs\n- Response payloads\n\n## Polling Configuration\n\nFor long-running operations (server create, volume attach):\n\n```bash\n# Poll every 2 seconds\nhcloud server create --name web --type cx22 --image ubuntu-24.04 --poll-interval 2s\n\n# In config\n[preferences]\npoll_interval = \"1s\"\n```\n\n## Output Configuration\n\n```bash\n# Default preferences\nhcloud config set default_output_format json\nhcloud config set default_sort_key name\n\n# Per-command\nhcloud server list --output json\nhcloud server list --output columns=id,name,ipv4 --output noheader\n```\n\n## Shell Completion\n\n```bash\n# Bash\nhcloud completion bash > /etc/bash_completion.d/hcloud\n\n# Zsh\nhcloud completion zsh > \"${fpath[1]}/_hcloud\"\n\n# Fish\nhcloud completion fish > ~/.config/fish/completions/hcloud.fish\n\n# PowerShell\nhcloud completion powershell | Out-String | Invoke-Expression\n```\n",
        "hetzner/skills/hcloud-go-sdk/SKILL.md": "---\nname: hcloud-go-sdk\ndescription: Use when writing Go code to interact with Hetzner Cloud API - automation, infrastructure provisioning, bots, integrations, or programmatic cloud operations\n---\n\n# Hetzner Cloud Go SDK\n\n## Overview\n\nThe official Go SDK for Hetzner Cloud provides type-safe access to 23+ resource types with automatic retries, action polling, and comprehensive error handling. Use it for bots, automation, integrations, and complex workflows. For quick CLI operations, use `hetzner:hcloud-cli` instead.\n\n## Quick Setup\n\n```go\nimport \"github.com/hetznercloud/hcloud-go/v2/hcloud\"\n\n// Create client\nclient := hcloud.NewClient(hcloud.WithToken(\"your-api-token\"))\n```\n\n```bash\ngo get github.com/hetznercloud/hcloud-go/v2/hcloud\n```\n\n## Quick Reference\n\n| Task | Method |\n|------|--------|\n| **Servers** | |\n| List servers | `client.Server.All(ctx)` |\n| Get server | `client.Server.GetByID(ctx, 123)` or `GetByName(ctx, \"web\")` |\n| Create server | `client.Server.Create(ctx, hcloud.ServerCreateOpts{})` |\n| Delete server | `client.Server.Delete(ctx, server)` |\n| Reboot/Reset | `client.Server.Reboot(ctx, server)` / `Reset(ctx, server)` |\n| **Networks** | |\n| Create network | `client.Network.Create(ctx, hcloud.NetworkCreateOpts{})` |\n| Attach server | `client.Server.AttachToNetwork(ctx, server, opts)` |\n| **Volumes** | |\n| Create volume | `client.Volume.Create(ctx, hcloud.VolumeCreateOpts{})` |\n| Attach volume | `client.Volume.Attach(ctx, volume, server)` |\n| **Actions** | |\n| Wait for action | `client.Action.WaitFor(ctx, action)` |\n| Poll with callback | `client.Action.WaitForFunc(ctx, callback, action)` |\n\n## API Categories\n\nSee `references/api-reference.md` for complete method list:\n- Servers (create, lifecycle, networking)\n- Networks, subnets, routes\n- Volumes\n- Firewalls and rules\n- Load balancers, targets, services\n- Floating IPs, Primary IPs\n- SSH keys, images, certificates\n- DNS zones (GA in v2.30.0)\n- Storage boxes (experimental)\n\n## Client Configuration\n\n```go\nclient := hcloud.NewClient(\n    hcloud.WithToken(\"token\"),                    // Required\n    hcloud.WithEndpoint(\"https://api.hetzner.cloud/v1\"), // Custom endpoint\n    hcloud.WithApplication(\"myapp\", \"1.0.0\"),     // User-Agent\n    hcloud.WithDebugWriter(os.Stderr),            // Debug logging\n    hcloud.WithHTTPClient(customClient),          // Custom HTTP client\n    hcloud.WithRetryOpts(hcloud.RetryOpts{        // Retry config\n        MaxRetries: 5,\n        BackoffFunc: hcloud.ExponentialBackoff(2, time.Second),\n    }),\n    hcloud.WithPollOpts(hcloud.PollOpts{          // Action polling\n        BackoffFunc: hcloud.ConstantBackoff(500 * time.Millisecond),\n    }),\n)\n```\n\n## Common Patterns\n\nSee `references/patterns.md` for idiomatic patterns:\n- Error handling\n- Action polling\n- Pagination\n- Resource lookups\n\n## Action Handling\n\nAll long-running operations return an `Action`:\n\n```go\nresult, _, err := client.Server.Create(ctx, opts)\nif err != nil {\n    return err\n}\n\n// Wait for completion\nif err := client.Action.WaitFor(ctx, result.Action); err != nil {\n    return err\n}\n\n// Or with progress callback\nerr = client.Action.WaitForFunc(ctx,\n    func(update *hcloud.Action) error {\n        fmt.Printf(\"Progress: %.0f%%\\n\", update.Progress)\n        return nil\n    },\n    result.Action,\n)\n```\n\n## Error Handling\n\n```go\nimport \"github.com/hetznercloud/hcloud-go/v2/hcloud\"\n\nerr := someAPICall()\n\n// Check specific error codes\nif hcloud.IsError(err, hcloud.ErrorCodeNotFound) {\n    // Resource doesn't exist\n}\n\n// Get error details\nif apiErr, ok := err.(*hcloud.APIError); ok {\n    fmt.Printf(\"Error: %s - %s\\n\", apiErr.Code, apiErr.Message)\n}\n```\n\nCommon error codes:\n- `ErrorCodeNotFound` - Resource doesn't exist\n- `ErrorCodeInvalidInput` - Validation error\n- `ErrorCodeForbidden` - Insufficient permissions\n- `ErrorCodeRateLimitExceeded` - Rate limit hit (auto-retried)\n- `ErrorCodeConflict` - Resource changed (auto-retried)\n- `ErrorCodeLocked` - Another action running\n\n## Common Mistakes\n\n| Problem | Solution |\n|---------|----------|\n| Nil pointer panic | Always check error before using result |\n| Action timeout | Use `ctx, cancel := context.WithTimeout(...)` |\n| Missing pagination | Use `client.Server.All(ctx)` for complete list |\n| Action failed | Check action error with `WaitFor()` return value |\n| Rate limiting | SDK auto-retries, but add backoff for bulk ops |\n",
        "hetzner/skills/hcloud-go-sdk/references/api-reference.md": "# hcloud-go SDK API Reference\n\n## Client Initialization\n\n```go\nimport \"github.com/hetznercloud/hcloud-go/v2/hcloud\"\n\n// Basic\nclient := hcloud.NewClient(hcloud.WithToken(\"token\"))\n\n// With all options\nclient := hcloud.NewClient(\n    hcloud.WithToken(token),\n    hcloud.WithEndpoint(\"https://api.hetzner.cloud/v1\"),\n    hcloud.WithApplication(\"myapp\", \"1.0.0\"),\n    hcloud.WithDebugWriter(os.Stderr),\n    hcloud.WithHTTPClient(httpClient),\n    hcloud.WithInstrumentation(prometheusRegistry), // Prometheus metrics\n)\n```\n\n---\n\n## Servers\n\n### CRUD\n```go\n// List\nservers, err := client.Server.All(ctx)\nservers, resp, err := client.Server.List(ctx, hcloud.ServerListOpts{\n    Name:   \"web\",\n    Status: []hcloud.ServerStatus{hcloud.ServerStatusRunning},\n    ListOpts: hcloud.ListOpts{Page: 1, PerPage: 50},\n})\n\n// Get\nserver, resp, err := client.Server.GetByID(ctx, 123)\nserver, resp, err := client.Server.GetByName(ctx, \"web\")\nserver, resp, err := client.Server.Get(ctx, \"123\") // ID or name\n\n// Create\nresult, resp, err := client.Server.Create(ctx, hcloud.ServerCreateOpts{\n    Name:       \"web-01\",\n    ServerType: &hcloud.ServerType{Name: \"cx22\"},\n    Image:      &hcloud.Image{Name: \"ubuntu-24.04\"},\n    Location:   &hcloud.Location{Name: \"fsn1\"},\n    SSHKeys:    []*hcloud.SSHKey{{ID: 123}},\n    Networks:   []*hcloud.Network{{ID: 456}},\n    Firewalls:  []*hcloud.ServerCreateFirewall{{Firewall: hcloud.Firewall{ID: 789}}},\n    Labels:     map[string]string{\"env\": \"prod\"},\n    UserData:   \"#!/bin/bash\\necho hello\",\n    Automount:  hcloud.Ptr(true),\n})\n// result.Server, result.Action, result.RootPassword\n\n// Update\nserver, resp, err := client.Server.Update(ctx, server, hcloud.ServerUpdateOpts{\n    Name:   \"web-02\",\n    Labels: map[string]string{\"env\": \"staging\"},\n})\n\n// Delete\nresult, resp, err := client.Server.Delete(ctx, server)\n// Wait for deletion action\nclient.Action.WaitFor(ctx, result.Action)\n```\n\n### Power Operations\n```go\naction, resp, err := client.Server.Poweron(ctx, server)\naction, resp, err := client.Server.Poweroff(ctx, server)\naction, resp, err := client.Server.Shutdown(ctx, server)  // Graceful via ACPI\naction, resp, err := client.Server.Reboot(ctx, server)    // Graceful\naction, resp, err := client.Server.Reset(ctx, server)     // Hard reset\n```\n\n### Networking\n```go\n// Attach to network\naction, resp, err := client.Server.AttachToNetwork(ctx, server, hcloud.ServerAttachToNetworkOpts{\n    Network: network,\n    IP:      net.ParseIP(\"10.0.0.5\"), // Optional specific IP\n})\n\n// Detach from network\naction, resp, err := client.Server.DetachFromNetwork(ctx, server, hcloud.ServerDetachFromNetworkOpts{\n    Network: network,\n})\n\n// Change alias IPs\naction, resp, err := client.Server.ChangeAliasIPs(ctx, server, hcloud.ServerChangeAliasIPsOpts{\n    Network:  network,\n    AliasIPs: []net.IP{net.ParseIP(\"10.0.0.10\")},\n})\n\n// Change reverse DNS\naction, resp, err := client.Server.ChangeDNSPtr(ctx, server, \"1.2.3.4\", hcloud.Ptr(\"server.example.com\"))\n```\n\n### Other Operations\n```go\n// Change type\naction, resp, err := client.Server.ChangeType(ctx, server, hcloud.ServerChangeTypeOpts{\n    ServerType:  &hcloud.ServerType{Name: \"cx32\"},\n    UpgradeDisk: true,\n})\n\n// Rebuild\nresult, resp, err := client.Server.Rebuild(ctx, server, hcloud.ServerRebuildOpts{\n    Image: &hcloud.Image{Name: \"ubuntu-24.04\"},\n})\n\n// Enable/Disable rescue\nresult, resp, err := client.Server.EnableRescue(ctx, server, hcloud.ServerEnableRescueOpts{\n    Type:    hcloud.ServerRescueTypeLinux64,\n    SSHKeys: []*hcloud.SSHKey{{ID: 123}},\n})\naction, resp, err := client.Server.DisableRescue(ctx, server)\n\n// Enable/Disable backup\naction, resp, err := client.Server.EnableBackup(ctx, server)\naction, resp, err := client.Server.DisableBackup(ctx, server)\n\n// Create image/snapshot\nresult, resp, err := client.Server.CreateImage(ctx, server, &hcloud.ServerCreateImageOpts{\n    Type:        hcloud.ImageTypeSnapshot,\n    Description: hcloud.Ptr(\"Backup before upgrade\"),\n    Labels:      map[string]string{\"backup\": \"true\"},\n})\n\n// Request console\nresult, resp, err := client.Server.RequestConsole(ctx, server)\n// result.WSSURL, result.Password\n\n// Reset password\nresult, resp, err := client.Server.ResetPassword(ctx, server)\n// result.RootPassword\n\n// Get metrics\nmetrics, resp, err := client.Server.GetMetrics(ctx, server, hcloud.ServerGetMetricsOpts{\n    Types: []hcloud.ServerMetricType{hcloud.ServerMetricCPU},\n    Start: time.Now().Add(-1 * time.Hour),\n    End:   time.Now(),\n})\n```\n\n---\n\n## Networks\n\n```go\n// List\nnetworks, err := client.Network.All(ctx)\n\n// Create\nresult, resp, err := client.Network.Create(ctx, hcloud.NetworkCreateOpts{\n    Name:    \"private\",\n    IPRange: &net.IPNet{IP: net.ParseIP(\"10.0.0.0\"), Mask: net.CIDRMask(8, 32)},\n    Labels:  map[string]string{\"env\": \"prod\"},\n})\n\n// Delete\nresp, err := client.Network.Delete(ctx, network)\n\n// Add subnet\naction, resp, err := client.Network.AddSubnet(ctx, network, hcloud.NetworkAddSubnetOpts{\n    Type:        hcloud.NetworkSubnetTypeCloud,\n    NetworkZone: hcloud.NetworkZoneEUCentral,\n    IPRange:     &net.IPNet{IP: net.ParseIP(\"10.0.1.0\"), Mask: net.CIDRMask(24, 32)},\n})\n\n// Remove subnet\naction, resp, err := client.Network.DeleteSubnet(ctx, network, hcloud.NetworkDeleteSubnetOpts{\n    Subnet: subnet,\n})\n\n// Add/Remove route\naction, resp, err := client.Network.AddRoute(ctx, network, hcloud.NetworkAddRouteOpts{\n    Route: hcloud.NetworkRoute{\n        Destination: &net.IPNet{...},\n        Gateway:     net.ParseIP(\"10.0.0.1\"),\n    },\n})\n```\n\n---\n\n## Volumes\n\n```go\n// Create\nresult, resp, err := client.Volume.Create(ctx, hcloud.VolumeCreateOpts{\n    Name:     \"data\",\n    Size:     100, // GB\n    Location: &hcloud.Location{Name: \"fsn1\"},\n    Labels:   map[string]string{\"type\": \"database\"},\n    Format:   hcloud.Ptr(\"ext4\"),\n})\n\n// Attach\naction, resp, err := client.Volume.Attach(ctx, volume, server)\n\n// Attach with automount\naction, resp, err := client.Volume.AttachWithOpts(ctx, volume, hcloud.VolumeAttachOpts{\n    Server:    server,\n    Automount: hcloud.Ptr(true),\n})\n\n// Detach\naction, resp, err := client.Volume.Detach(ctx, volume)\n\n// Resize\naction, resp, err := client.Volume.Resize(ctx, volume, 200)\n\n// Delete\nresp, err := client.Volume.Delete(ctx, volume)\n```\n\n---\n\n## Firewalls\n\n```go\n// Create with rules\nresult, resp, err := client.Firewall.Create(ctx, hcloud.FirewallCreateOpts{\n    Name:   \"web-fw\",\n    Labels: map[string]string{\"role\": \"web\"},\n    Rules: []hcloud.FirewallRule{\n        {\n            Direction:   hcloud.FirewallRuleDirectionIn,\n            Protocol:    hcloud.FirewallRuleProtocolTCP,\n            Port:        hcloud.Ptr(\"80\"),\n            SourceIPs:   []net.IPNet{{IP: net.ParseIP(\"0.0.0.0\"), Mask: net.CIDRMask(0, 32)}},\n            Description: hcloud.Ptr(\"HTTP\"),\n        },\n        {\n            Direction:   hcloud.FirewallRuleDirectionIn,\n            Protocol:    hcloud.FirewallRuleProtocolTCP,\n            Port:        hcloud.Ptr(\"443\"),\n            SourceIPs:   []net.IPNet{{IP: net.ParseIP(\"0.0.0.0\"), Mask: net.CIDRMask(0, 32)}},\n            Description: hcloud.Ptr(\"HTTPS\"),\n        },\n    },\n})\n\n// Set rules (replace all)\nactions, resp, err := client.Firewall.SetRules(ctx, firewall, hcloud.FirewallSetRulesOpts{\n    Rules: []hcloud.FirewallRule{...},\n})\n\n// Apply to server\nactions, resp, err := client.Firewall.ApplyToResources(ctx, firewall, []hcloud.FirewallResource{\n    {Type: hcloud.FirewallResourceTypeServer, Server: &hcloud.FirewallResourceServer{ID: server.ID}},\n})\n\n// Apply via label selector\nactions, resp, err := client.Firewall.ApplyToResources(ctx, firewall, []hcloud.FirewallResource{\n    {Type: hcloud.FirewallResourceTypeLabelSelector, LabelSelector: &hcloud.FirewallResourceLabelSelector{Selector: \"env=prod\"}},\n})\n\n// Remove from resources\nactions, resp, err := client.Firewall.RemoveFromResources(ctx, firewall, []hcloud.FirewallResource{...})\n```\n\n---\n\n## Load Balancers\n\n```go\n// Create\nresult, resp, err := client.LoadBalancer.Create(ctx, hcloud.LoadBalancerCreateOpts{\n    Name:             \"lb-01\",\n    LoadBalancerType: &hcloud.LoadBalancerType{Name: \"lb11\"},\n    Location:         &hcloud.Location{Name: \"fsn1\"},\n    Network:          &hcloud.Network{ID: 123}, // Optional private network\n    Labels:           map[string]string{\"role\": \"frontend\"},\n})\n\n// Add service\naction, resp, err := client.LoadBalancer.AddService(ctx, lb, hcloud.LoadBalancerAddServiceOpts{\n    Protocol:        hcloud.LoadBalancerServiceProtocolHTTP,\n    ListenPort:      hcloud.Ptr(80),\n    DestinationPort: hcloud.Ptr(8080),\n    HealthCheck: &hcloud.LoadBalancerAddServiceOptsHealthCheck{\n        Protocol: hcloud.LoadBalancerServiceProtocolHTTP,\n        Port:     hcloud.Ptr(8080),\n        Interval: hcloud.Ptr(15 * time.Second),\n        Timeout:  hcloud.Ptr(10 * time.Second),\n        Retries:  hcloud.Ptr(3),\n        HTTP: &hcloud.LoadBalancerAddServiceOptsHealthCheckHTTP{\n            Domain: hcloud.Ptr(\"example.com\"),\n            Path:   hcloud.Ptr(\"/health\"),\n        },\n    },\n})\n\n// Add target (server)\naction, resp, err := client.LoadBalancer.AddServerTarget(ctx, lb, hcloud.LoadBalancerAddServerTargetOpts{\n    Server:       server,\n    UsePrivateIP: hcloud.Ptr(true),\n})\n\n// Add target (label selector)\naction, resp, err := client.LoadBalancer.AddLabelSelectorTarget(ctx, lb, hcloud.LoadBalancerAddLabelSelectorTargetOpts{\n    Selector:     \"role=backend\",\n    UsePrivateIP: hcloud.Ptr(true),\n})\n\n// Add target (IP)\naction, resp, err := client.LoadBalancer.AddIPTarget(ctx, lb, hcloud.LoadBalancerAddIPTargetOpts{\n    IP: net.ParseIP(\"10.0.0.5\"),\n})\n\n// Change algorithm\naction, resp, err := client.LoadBalancer.ChangeAlgorithm(ctx, lb, hcloud.LoadBalancerChangeAlgorithmOpts{\n    Type: hcloud.LoadBalancerAlgorithmTypeLeastConnections,\n})\n\n// Attach to network\naction, resp, err := client.LoadBalancer.AttachToNetwork(ctx, lb, hcloud.LoadBalancerAttachToNetworkOpts{\n    Network: network,\n    IP:      net.ParseIP(\"10.0.0.100\"), // Optional specific IP\n})\n```\n\n---\n\n## Floating IPs\n\n```go\n// Create\nresult, resp, err := client.FloatingIP.Create(ctx, hcloud.FloatingIPCreateOpts{\n    Type:         hcloud.FloatingIPTypeIPv4,\n    HomeLocation: &hcloud.Location{Name: \"fsn1\"},\n    Description:  hcloud.Ptr(\"Web frontend IP\"),\n    Labels:       map[string]string{\"service\": \"web\"},\n})\n\n// Assign to server\naction, resp, err := client.FloatingIP.Assign(ctx, floatingIP, server)\n\n// Unassign\naction, resp, err := client.FloatingIP.Unassign(ctx, floatingIP)\n\n// Change reverse DNS\naction, resp, err := client.FloatingIP.ChangeDNSPtr(ctx, floatingIP, \"1.2.3.4\", hcloud.Ptr(\"web.example.com\"))\n```\n\n---\n\n## Primary IPs\n\n```go\n// Create\nresult, resp, err := client.PrimaryIP.Create(ctx, hcloud.PrimaryIPCreateOpts{\n    Name:         \"web-ip\",\n    Type:         hcloud.PrimaryIPTypeIPv4,\n    Datacenter:   \"fsn1-dc14\",\n    AssigneeType: \"server\",\n    AutoDelete:   hcloud.Ptr(false),\n    Labels:       map[string]string{},\n})\n\n// Assign\naction, resp, err := client.PrimaryIP.Assign(ctx, primaryIP, hcloud.PrimaryIPAssignOpts{\n    AssigneeType: \"server\",\n    AssigneeID:   server.ID,\n})\n\n// Unassign\naction, resp, err := client.PrimaryIP.Unassign(ctx, primaryIP)\n```\n\n---\n\n## SSH Keys\n\n```go\n// Create\nsshKey, resp, err := client.SSHKey.Create(ctx, hcloud.SSHKeyCreateOpts{\n    Name:      \"my-key\",\n    PublicKey: \"ssh-rsa AAAA...\",\n    Labels:    map[string]string{},\n})\n\n// List\nkeys, err := client.SSHKey.All(ctx)\n\n// Get\nkey, resp, err := client.SSHKey.GetByName(ctx, \"my-key\")\n\n// Delete\nresp, err := client.SSHKey.Delete(ctx, sshKey)\n```\n\n---\n\n## Images\n\n```go\n// List\nimages, err := client.Image.All(ctx)\nimages, resp, err := client.Image.List(ctx, hcloud.ImageListOpts{\n    Type:   []hcloud.ImageType{hcloud.ImageTypeSnapshot},\n    Status: []hcloud.ImageStatus{hcloud.ImageStatusAvailable},\n})\n\n// Get\nimage, resp, err := client.Image.GetByID(ctx, 123)\nimage, resp, err := client.Image.GetByName(ctx, \"ubuntu-24.04\")\n\n// Update\nimage, resp, err := client.Image.Update(ctx, image, hcloud.ImageUpdateOpts{\n    Description: hcloud.Ptr(\"Updated description\"),\n    Labels:      map[string]string{},\n})\n\n// Delete (snapshots/backups only)\nresp, err := client.Image.Delete(ctx, image)\n```\n\n---\n\n## Certificates\n\n```go\n// Create managed (Let's Encrypt)\nresult, resp, err := client.Certificate.Create(ctx, hcloud.CertificateCreateOpts{\n    Name:        \"example-cert\",\n    Type:        hcloud.CertificateTypeManaged,\n    DomainNames: []string{\"example.com\", \"www.example.com\"},\n    Labels:      map[string]string{},\n})\n\n// Create uploaded\nresult, resp, err := client.Certificate.Create(ctx, hcloud.CertificateCreateOpts{\n    Name:        \"custom-cert\",\n    Type:        hcloud.CertificateTypeUploaded,\n    Certificate: certPEM,\n    PrivateKey:  keyPEM,\n})\n\n// Retry issuance (managed)\naction, resp, err := client.Certificate.RetryIssuance(ctx, certificate)\n```\n\n---\n\n## DNS Zones\n\n```go\n// Create zone\nresult, resp, err := client.Zone.Create(ctx, hcloud.ZoneCreateOpts{\n    Name: \"example.com\",\n    TTL:  hcloud.Ptr(int(86400)),\n})\n\n// Get zone\nzone, resp, err := client.Zone.GetByID(ctx, zoneID)\n\n// Update records (RRsets)\n_, resp, err := client.Zone.BulkUpdateRecords(ctx, zone, []hcloud.ZoneRRset{\n    {\n        Name: \"www\",\n        Type: \"A\",\n        TTL:  hcloud.Ptr(int(3600)),\n        Records: []hcloud.ZoneRRsetRecordData{\n            {Value: \"1.2.3.4\"},\n        },\n    },\n    {\n        Name: \"@\",\n        Type: \"MX\",\n        TTL:  hcloud.Ptr(int(3600)),\n        Records: []hcloud.ZoneRRsetRecordData{\n            {Value: \"10 mail.example.com.\"},\n        },\n    },\n})\n\n// Import zone file\nresult, resp, err := client.Zone.Import(ctx, zone, hcloud.ZoneImportOpts{\n    ZoneFile: zoneFileContent,\n})\n\n// Export zone\nzoneFile, resp, err := client.Zone.Export(ctx, zone)\n```\n\n---\n\n## Actions\n\n```go\n// Wait for single action\nerr := client.Action.WaitFor(ctx, action)\nif err != nil {\n    if actionErr, ok := err.(hcloud.ActionError); ok {\n        fmt.Printf(\"Action failed: %s (%s)\\n\", actionErr.Message, actionErr.Code)\n    }\n}\n\n// Wait with progress callback\nerr = client.Action.WaitForFunc(ctx,\n    func(update *hcloud.Action) error {\n        fmt.Printf(\"Action %d: %s (%.0f%%)\\n\", update.ID, update.Status, update.Progress)\n        return nil\n    },\n    action,\n)\n\n// Get action by ID\naction, resp, err := client.Action.GetByID(ctx, actionID)\n\n// List actions\nactions, resp, err := client.Action.List(ctx, hcloud.ActionListOpts{\n    Status: []hcloud.ActionStatus{hcloud.ActionStatusRunning},\n})\n```\n\n---\n\n## Reference Data\n\n```go\n// Server types\ntypes, err := client.ServerType.All(ctx)\nserverType, resp, err := client.ServerType.GetByName(ctx, \"cx22\")\n\n// Locations\nlocations, err := client.Location.All(ctx)\nlocation, resp, err := client.Location.GetByName(ctx, \"fsn1\")\n\n// Datacenters\ndatacenters, err := client.Datacenter.All(ctx)\n\n// Pricing\npricing, resp, err := client.Pricing.Get(ctx)\n```\n",
        "hetzner/skills/hcloud-go-sdk/references/patterns.md": "# hcloud-go SDK Patterns\n\n## Error Handling\n\n### Check Specific Error Codes\n```go\nimport \"github.com/hetznercloud/hcloud-go/v2/hcloud\"\n\nserver, _, err := client.Server.GetByID(ctx, 123)\nif err != nil {\n    if hcloud.IsError(err, hcloud.ErrorCodeNotFound) {\n        // Resource doesn't exist - handle gracefully\n        return nil, nil\n    }\n    if hcloud.IsError(err, hcloud.ErrorCodeForbidden) {\n        // Permission denied\n        return nil, fmt.Errorf(\"access denied: %w\", err)\n    }\n    // Other errors\n    return nil, fmt.Errorf(\"failed to get server: %w\", err)\n}\n```\n\n### Get Error Details\n```go\nif apiErr, ok := err.(*hcloud.APIError); ok {\n    fmt.Printf(\"Code: %s\\n\", apiErr.Code)\n    fmt.Printf(\"Message: %s\\n\", apiErr.Message)\n    if apiErr.CorrelationID != \"\" {\n        fmt.Printf(\"Correlation ID: %s (for Hetzner support)\\n\", apiErr.CorrelationID)\n    }\n}\n```\n\n### Handle Action Errors\n```go\nresult, _, err := client.Server.Create(ctx, opts)\nif err != nil {\n    return err\n}\n\nif err := client.Action.WaitFor(ctx, result.Action); err != nil {\n    // Action failed\n    if actionErr, ok := err.(hcloud.ActionError); ok {\n        fmt.Printf(\"Action failed: %s (%s)\\n\", actionErr.Message, actionErr.Code)\n    }\n    return err\n}\n```\n\n---\n\n## Pagination\n\n### Get All Resources\n```go\n// Simplest - use All() methods\nservers, err := client.Server.All(ctx)\nif err != nil {\n    return err\n}\n```\n\n### Get All with Filters\n```go\nservers, err := client.Server.AllWithOpts(ctx, hcloud.ServerListOpts{\n    Status: []hcloud.ServerStatus{hcloud.ServerStatusRunning},\n    ListOpts: hcloud.ListOpts{\n        LabelSelector: \"env=prod\",\n    },\n})\n```\n\n### Manual Pagination\n```go\nopts := hcloud.ServerListOpts{\n    ListOpts: hcloud.ListOpts{Page: 1, PerPage: 50},\n}\n\nfor {\n    servers, resp, err := client.Server.List(ctx, opts)\n    if err != nil {\n        return err\n    }\n\n    for _, server := range servers {\n        // Process server\n    }\n\n    if resp.Meta.Pagination.NextPage == 0 {\n        break\n    }\n    opts.ListOpts.Page = resp.Meta.Pagination.NextPage\n}\n```\n\n---\n\n## Resource Lookups\n\n### By ID or Name\n```go\n// Get() tries ID first, then name\nserver, _, err := client.Server.Get(ctx, \"123\")      // By ID\nserver, _, err := client.Server.Get(ctx, \"web-01\")   // By name\n\n// Explicit methods\nserver, _, err := client.Server.GetByID(ctx, 123)\nserver, _, err := client.Server.GetByName(ctx, \"web-01\")\n```\n\n### Handle \"Not Found\" Gracefully\n```go\nfunc getServerIfExists(ctx context.Context, client *hcloud.Client, name string) (*hcloud.Server, error) {\n    server, _, err := client.Server.GetByName(ctx, name)\n    if err != nil {\n        if hcloud.IsError(err, hcloud.ErrorCodeNotFound) {\n            return nil, nil\n        }\n        return nil, err\n    }\n    return server, nil\n}\n```\n\n---\n\n## Action Polling\n\n### Simple Wait\n```go\nresult, _, err := client.Server.Create(ctx, opts)\nif err != nil {\n    return err\n}\n\n// Block until complete\nif err := client.Action.WaitFor(ctx, result.Action); err != nil {\n    return err\n}\n\nfmt.Println(\"Server created:\", result.Server.Name)\n```\n\n### With Progress Reporting\n```go\nerr = client.Action.WaitForFunc(ctx,\n    func(update *hcloud.Action) error {\n        fmt.Printf(\"\\rProgress: %.0f%% (%s)\", update.Progress, update.Status)\n        return nil\n    },\n    result.Action,\n)\nfmt.Println() // Newline after progress\n```\n\n### With Timeout\n```go\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)\ndefer cancel()\n\nif err := client.Action.WaitFor(ctx, action); err != nil {\n    if ctx.Err() == context.DeadlineExceeded {\n        return fmt.Errorf(\"action timed out after 5 minutes\")\n    }\n    return err\n}\n```\n\n### Multiple Actions\n```go\n// Wait for multiple actions in parallel\nactions := []*hcloud.Action{action1, action2, action3}\n\ng, ctx := errgroup.WithContext(ctx)\nfor _, action := range actions {\n    action := action // Capture for goroutine\n    g.Go(func() error {\n        return client.Action.WaitFor(ctx, action)\n    })\n}\n\nif err := g.Wait(); err != nil {\n    return err\n}\n```\n\n---\n\n## Context Usage\n\n### Timeouts\n```go\n// Per-operation timeout\nctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)\ndefer cancel()\n\nserver, _, err := client.Server.GetByID(ctx, 123)\n```\n\n### Cancellation\n```go\nctx, cancel := context.WithCancel(context.Background())\n\n// Start long operation\ngo func() {\n    if err := client.Action.WaitFor(ctx, action); err != nil {\n        if ctx.Err() == context.Canceled {\n            log.Println(\"Operation cancelled\")\n            return\n        }\n        log.Printf(\"Error: %v\", err)\n    }\n}()\n\n// Cancel from elsewhere\ncancel()\n```\n\n---\n\n## Complete Example: Create Server\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"log\"\n    \"time\"\n\n    \"github.com/hetznercloud/hcloud-go/v2/hcloud\"\n)\n\nfunc main() {\n    client := hcloud.NewClient(hcloud.WithToken(\"your-token\"))\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)\n    defer cancel()\n\n    // Get SSH key\n    sshKey, _, err := client.SSHKey.GetByName(ctx, \"my-key\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    if sshKey == nil {\n        log.Fatal(\"SSH key not found\")\n    }\n\n    // Create server\n    result, _, err := client.Server.Create(ctx, hcloud.ServerCreateOpts{\n        Name:       \"web-01\",\n        ServerType: &hcloud.ServerType{Name: \"cx22\"},\n        Image:      &hcloud.Image{Name: \"ubuntu-24.04\"},\n        Location:   &hcloud.Location{Name: \"fsn1\"},\n        SSHKeys:    []*hcloud.SSHKey{sshKey},\n        Labels:     map[string]string{\"env\": \"prod\", \"role\": \"web\"},\n    })\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Wait for creation\n    if err := client.Action.WaitFor(ctx, result.Action); err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\"Server created!\\n\")\n    fmt.Printf(\"  ID: %d\\n\", result.Server.ID)\n    fmt.Printf(\"  Name: %s\\n\", result.Server.Name)\n    fmt.Printf(\"  IPv4: %s\\n\", result.Server.PublicNet.IPv4.IP)\n    fmt.Printf(\"  Root Password: %s\\n\", result.RootPassword)\n}\n```\n\n---\n\n## Complete Example: Setup with Firewall\n\n```go\nfunc setupServerWithFirewall(ctx context.Context, client *hcloud.Client) error {\n    // 1. Create firewall\n    fwResult, _, err := client.Firewall.Create(ctx, hcloud.FirewallCreateOpts{\n        Name: \"web-fw\",\n        Rules: []hcloud.FirewallRule{\n            {\n                Direction: hcloud.FirewallRuleDirectionIn,\n                Protocol:  hcloud.FirewallRuleProtocolTCP,\n                Port:      hcloud.Ptr(\"22\"),\n                SourceIPs: []net.IPNet{{IP: net.ParseIP(\"0.0.0.0\"), Mask: net.CIDRMask(0, 32)}},\n            },\n            {\n                Direction: hcloud.FirewallRuleDirectionIn,\n                Protocol:  hcloud.FirewallRuleProtocolTCP,\n                Port:      hcloud.Ptr(\"80\"),\n                SourceIPs: []net.IPNet{{IP: net.ParseIP(\"0.0.0.0\"), Mask: net.CIDRMask(0, 32)}},\n            },\n            {\n                Direction: hcloud.FirewallRuleDirectionIn,\n                Protocol:  hcloud.FirewallRuleProtocolTCP,\n                Port:      hcloud.Ptr(\"443\"),\n                SourceIPs: []net.IPNet{{IP: net.ParseIP(\"0.0.0.0\"), Mask: net.CIDRMask(0, 32)}},\n            },\n        },\n    })\n    if err != nil {\n        return fmt.Errorf(\"create firewall: %w\", err)\n    }\n    for _, action := range fwResult.Actions {\n        if err := client.Action.WaitFor(ctx, action); err != nil {\n            return fmt.Errorf(\"wait for firewall: %w\", err)\n        }\n    }\n\n    // 2. Create server with firewall attached\n    serverResult, _, err := client.Server.Create(ctx, hcloud.ServerCreateOpts{\n        Name:       \"web-01\",\n        ServerType: &hcloud.ServerType{Name: \"cx22\"},\n        Image:      &hcloud.Image{Name: \"ubuntu-24.04\"},\n        Location:   &hcloud.Location{Name: \"fsn1\"},\n        Firewalls: []*hcloud.ServerCreateFirewall{\n            {Firewall: hcloud.Firewall{ID: fwResult.Firewall.ID}},\n        },\n    })\n    if err != nil {\n        return fmt.Errorf(\"create server: %w\", err)\n    }\n\n    if err := client.Action.WaitFor(ctx, serverResult.Action); err != nil {\n        return fmt.Errorf(\"wait for server: %w\", err)\n    }\n\n    fmt.Printf(\"Server %s created with firewall\\n\", serverResult.Server.Name)\n    return nil\n}\n```\n\n---\n\n## Retry Patterns\n\n### With Backoff for Bulk Operations\n```go\nfunc createServersWithBackoff(ctx context.Context, client *hcloud.Client, count int) error {\n    for i := 0; i < count; i++ {\n        result, _, err := client.Server.Create(ctx, hcloud.ServerCreateOpts{\n            Name:       fmt.Sprintf(\"node-%d\", i),\n            ServerType: &hcloud.ServerType{Name: \"cx22\"},\n            Image:      &hcloud.Image{Name: \"ubuntu-24.04\"},\n        })\n        if err != nil {\n            if hcloud.IsError(err, hcloud.ErrorCodeRateLimitExceeded) {\n                // SDK auto-retries, but add extra backoff for bulk\n                time.Sleep(time.Duration(i+1) * time.Second)\n                i-- // Retry this iteration\n                continue\n            }\n            return err\n        }\n\n        if err := client.Action.WaitFor(ctx, result.Action); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```\n\n---\n\n## Helper Functions\n\n### Pointer Helper\n```go\n// The SDK provides hcloud.Ptr() for optional fields\nopts := hcloud.ServerCreateOpts{\n    Name:      \"server\",\n    Automount: hcloud.Ptr(true),  // *bool\n}\n\n// Or use your own for other types\nfunc Ptr[T any](v T) *T { return &v }\n```\n\n### Labels Map\n```go\n// Common label pattern\nlabels := map[string]string{\n    \"env\":     \"production\",\n    \"team\":    \"backend\",\n    \"project\": \"api\",\n}\n```\n"
      },
      "plugins": [
        {
          "name": "gitea",
          "description": "Skills for Gitea: tea CLI operations and Go SDK development",
          "version": "1.0.0",
          "source": "./gitea",
          "author": {
            "name": "German Arutyunov"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add gaarutyunov/dev-skills",
            "/plugin install gitea@dev-skills"
          ]
        },
        {
          "name": "hetzner",
          "description": "Skills for Hetzner Cloud: hcloud CLI operations and Go SDK development",
          "version": "1.0.0",
          "source": "./hetzner",
          "author": {
            "name": "German Arutyunov"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add gaarutyunov/dev-skills",
            "/plugin install hetzner@dev-skills"
          ]
        },
        {
          "name": "bazel",
          "description": "Skills for developing custom Bazel rules, toolchains, providers, and aspects",
          "version": "1.0.0",
          "source": "./bazel",
          "author": {
            "name": "German Arutyunov"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add gaarutyunov/dev-skills",
            "/plugin install bazel@dev-skills"
          ]
        }
      ]
    }
  ]
}