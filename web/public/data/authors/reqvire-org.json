{
  "author": {
    "id": "reqvire-org",
    "display_name": "reqvire-org",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/209501850?v=4",
    "url": "https://github.com/reqvire-org",
    "bio": "Requirements-as-context framework for modern engineering teams.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 19,
      "total_skills": 1,
      "total_stars": 7,
      "total_forks": 2
    }
  },
  "marketplaces": [
    {
      "name": "reqvire-org-marketplace",
      "version": "1.0.0",
      "description": "Official marketplace for reqvire-org plugins.",
      "owner_info": {
        "name": "Ilija Ljubicic",
        "email": "ilijaljubicic@users.noreply.github.com"
      },
      "keywords": [],
      "repo_full_name": "reqvire-org/reqvire",
      "repo_url": "https://github.com/reqvire-org/reqvire",
      "repo_description": "Requirements-as-context framework for modern engineering teams.",
      "homepage": "https://www.reqvire.org",
      "signals": {
        "stars": 7,
        "forks": 2,
        "pushed_at": "2026-01-25T21:15:06Z",
        "created_at": "2024-12-27T14:39:23Z",
        "license": "Apache-2.0"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 2367
        },
        {
          "path": "claude-plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/commands/add-feature.md",
          "type": "blob",
          "size": 2982
        },
        {
          "path": "claude-plugins/commands/add-requirement.md",
          "type": "blob",
          "size": 4568
        },
        {
          "path": "claude-plugins/commands/add-verification.md",
          "type": "blob",
          "size": 7067
        },
        {
          "path": "claude-plugins/commands/analyze-coverage.md",
          "type": "blob",
          "size": 2312
        },
        {
          "path": "claude-plugins/commands/analyze-impact.md",
          "type": "blob",
          "size": 2924
        },
        {
          "path": "claude-plugins/commands/analyze-model.md",
          "type": "blob",
          "size": 1949
        },
        {
          "path": "claude-plugins/commands/collect.md",
          "type": "blob",
          "size": 8487
        },
        {
          "path": "claude-plugins/commands/consolidate.md",
          "type": "blob",
          "size": 10332
        },
        {
          "path": "claude-plugins/commands/containment.md",
          "type": "blob",
          "size": 5898
        },
        {
          "path": "claude-plugins/commands/find-redundant-verifications.md",
          "type": "blob",
          "size": 2308
        },
        {
          "path": "claude-plugins/commands/generate-tasks.md",
          "type": "blob",
          "size": 4943
        },
        {
          "path": "claude-plugins/commands/link.md",
          "type": "blob",
          "size": 5432
        },
        {
          "path": "claude-plugins/commands/lint-model.md",
          "type": "blob",
          "size": 2230
        },
        {
          "path": "claude-plugins/commands/mv-file.md",
          "type": "blob",
          "size": 4817
        },
        {
          "path": "claude-plugins/commands/mv.md",
          "type": "blob",
          "size": 3262
        },
        {
          "path": "claude-plugins/commands/rename-element.md",
          "type": "blob",
          "size": 2998
        },
        {
          "path": "claude-plugins/commands/rm.md",
          "type": "blob",
          "size": 3320
        },
        {
          "path": "claude-plugins/commands/setup.md",
          "type": "blob",
          "size": 4668
        },
        {
          "path": "claude-plugins/commands/unlink.md",
          "type": "blob",
          "size": 3409
        },
        {
          "path": "claude-plugins/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/skills/syseng",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/skills/syseng/SKILL.md",
          "type": "blob",
          "size": 19525
        },
        {
          "path": "claude-plugins/skills/syseng/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugins/skills/syseng/reference/AddFeature.md",
          "type": "blob",
          "size": 11266
        },
        {
          "path": "claude-plugins/skills/syseng/reference/ConsolidateRequirements.md",
          "type": "blob",
          "size": 9253
        },
        {
          "path": "claude-plugins/skills/syseng/reference/CreatingTasks.md",
          "type": "blob",
          "size": 12308
        },
        {
          "path": "claude-plugins/skills/syseng/reference/SpecificationsExtractionLogic.md",
          "type": "blob",
          "size": 13455
        },
        {
          "path": "claude-plugins/skills/syseng/reference/explore.md",
          "type": "blob",
          "size": 8332
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n    \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n    \"name\": \"reqvire-org-marketplace\",\n    \"description\": \"Official marketplace for reqvire-org plugins.\",\n    \"version\": \"1.0.0\",\n    \"owner\": {\n        \"name\": \"Ilija Ljubicic\",\n        \"email\": \"ilijaljubicic@users.noreply.github.com\"\n    },\n    \"plugins\": [\n        {\n            \"version\": \"1.5.0\",\n            \"name\": \"reqvire\",\n            \"description\": \"Expert MBSE engineer for system models, specifications and architectures. Use when exploring, updating and refactoring requirements, specifications and system model, adding features, managing verifications and creating tasks from introduced changes in requirements and system model.\",\n            \"author\": {\n                \"name\": \"Ilija Ljubicic\",\n                \"email\": \"ilijaljubicic@users.noreply.github.com\"\n            },\n            \"repository\": \"https://github.com/reqvire-org/reqvire\",\n            \"homepage\": \"https://www.reqvire.org\",\n            \"license\": \"Apache-2.0\",\n            \"keywords\": [\n                \"mbse\",\n                \"requirements\",\n                \"specifications\",\n                \"context\",\n                \"systems-engineering\",\n                \"verification\",\n                \"traceability\",\n                \"rust\"\n            ],\n            \"commands\": [\n                \"./commands/setup.md\",\n                \"./commands/add-feature.md\",\n                \"./commands/analyze-model.md\",\n                \"./commands/lint-model.md\",\n                \"./commands/add-requirement.md\",\n                \"./commands/consolidate.md\",\n                \"./commands/mv-file.md\",\n                \"./commands/add-verification.md\",\n                \"./commands/containment.md\",\n                \"./commands/mv.md\",\n                \"./commands/analyze-coverage.md\",\n                \"./commands/find-redundant-verifications.md\",\n                \"./commands/rename-element.md\",\n                \"./commands/analyze-impact.md\",\n                \"./commands/collect.md\",\n                \"./commands/generate-tasks.md\",\n                \"./commands/rm.md\",\n                \"./commands/link.md\",\n                \"./commands/unlink.md\"\n            ],\n            \"skills\": [\n                \"./skills/syseng/\"\n            ],\n            \"source\": \"./claude-plugins\",\n            \"strict\": false\n        }\n    ]\n}\n",
        "claude-plugins/commands/add-feature.md": "---\nallowed-tools: Read, Write, Edit, Bash(reqvire:*), SlashCommand\nargument-hint: [feature-name]\ndescription: Add a complete feature by orchestrating requirement and verification creation following MBSE workflow\nmodel: claude-sonnet-4-5\n---\n\n# Add Feature\n\nAdd a complete feature by orchestrating multiple commands to create requirements, verifications, and proper traceability.\n\n## Current Model Context\n\n- Total requirements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n- Verification coverage: !`reqvire coverage --json | jq -r '.summary.leaf_requirements_coverage_percentage'`%\n\n## User Request\n\n${1:+Feature name: $1}\n${1:-The user will provide feature details.}\n\n## MBSE Workflow\n\nThis command orchestrates the complete workflow:\n1. Define requirements (parent → children)\n2. Create verifications for leaf requirements\n3. Validate and check coverage\n\n## Steps\n\n1. **Understand the feature:**\n   - Ask user for feature description\n   - Identify if this derives from existing requirement\n   - Plan requirement hierarchy (parent → leaf requirements)\n\n2. **Create parent requirement (if needed):**\n   ```bash\n   /reqvire:add-requirement\n   ```\n\n   This creates the high-level feature requirement.\n\n3. **Create leaf requirements:**\n\n   For each specific capability:\n   ```bash\n   /reqvire:add-requirement\n   ```\n\n   Link each to the parent via `derivedFrom`.\n\n4. **Create verifications for leaf requirements:**\n\n   For each leaf requirement:\n   ```bash\n   /reqvire:add-verification\n   ```\n\n   This will:\n   - Check if verification is needed (leaf vs parent)\n   - Read all requirements in trace chain\n   - Create verification with comprehensive test criteria\n   - Link to tests if applicable\n\n5. **Validate complete feature:**\n   ```bash\n   reqvire validate\n   reqvire coverage --filter-name=\"<feature-name>\"\n   reqvire traces --filter-name=\"<feature-name>\"\n   ```\n\n6. **Clean up model:**\n   ```bash\n   reqvire lint --fix\n   ```\n\n## Command Flow\n\n```\n/reqvire:add-feature\n  ├─> /reqvire:add-requirement (parent)\n  ├─> /reqvire:add-requirement (leaf 1)\n  ├─> /reqvire:add-requirement (leaf 2)\n  ├─> /reqvire:add-requirement (leaf 3)\n  ├─> /reqvire:add-verification (for leaf 1)\n  ├─> /reqvire:add-verification (for leaf 2)\n  ├─> /reqvire:add-verification (for leaf 3)\n  └─> reqvire lint --fix\n```\n\n## Best Practices\n\n- **Requirements first**: Create all requirements before verifications\n- **Hierarchical**: Parent requirement → leaf requirements\n- **Verify leaves only**: Use `/reqvire:add-verification` for leaf requirements\n- **Delegate**: Let individual commands handle their specific logic\n- **Validate often**: Run validation after each major step\n\n## Notes\n\n- This is an orchestration command - it calls other commands\n- Follow MBSE methodology: requirements → verifications → tests\n- Each step uses specialized commands for consistency\n- Run `reqvire coverage` at the end to confirm complete feature coverage\n",
        "claude-plugins/commands/add-requirement.md": "---\nallowed-tools: Read, Bash(reqvire:*)\nargument-hint: [requirement-name]\ndescription: Add a new requirement to the Reqvire model with proper structure and traceability\nmodel: claude-sonnet-4-5\n---\n\n# Add New Requirement\n\nAdd a new requirement to the Reqvire model following MBSE best practices.\n\n## Current Model Context\n\n- Total requirements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n- Verification coverage: !`reqvire coverage --json | jq -r '.summary.leaf_requirements_coverage_percentage'`%\n- Unverified leaf requirements: !`reqvire coverage --json | jq -r '.summary.unverified_leaf_requirements'`\n\n## User Request\n\n${1:+Requirement name: $1}\n${1:-The user will provide requirement details.}\n\n## Steps\n\n1. **Understand the context:**\n   - Ask user for requirement details (name, description) if not provided\n   - Identify parent requirement if this is a derived requirement\n   - Identify target file (user specifies or follows project conventions)\n\n2. **Draft the requirement content:**\n\n   Follow EARS patterns for requirement statements:\n   - **Ubiquitous**: \"The system shall [capability]\"\n   - **Event-driven**: \"when [trigger] the system shall [response]\"\n   - **State-driven**: \"while [state] the system shall [capability]\"\n   - **Unwanted**: \"if [condition] then the system shall [response]\"\n   - **Optional**: \"where [feature] the system shall [capability]\"\n\n   Template:\n   ```markdown\n   ### Requirement Name\n\n   The system shall [capability/constraint following EARS patterns].\n\n   #### Metadata\n     * type: requirement\n\n   #### Relations\n     * derivedFrom: [Parent Requirement](path/to/parent.md#parent-requirement)\n   ```\n\n   Optional details section for clarifications:\n   ```markdown\n   #### Details\n\n   <details>\n   <summary>Additional Context</summary>\n\n   - Clarification points\n   - Rationale\n   - Examples\n\n   </details>\n   ```\n\n3. **Add the requirement using reqvire add command:**\n   ```bash\n   reqvire add \"<file-path>\" <<'EOF'\n   ### Requirement Name\n\n   The system shall [capability].\n\n   #### Metadata\n     * type: requirement\n\n   #### Relations\n     * derivedFrom: [Parent](path.md#parent)\n   EOF\n   ```\n\n   Optional: Insert at specific position (0-based index):\n   ```bash\n   reqvire add \"<file-path>\" 0 <<'EOF'\n   ...\n   EOF\n   ```\n\n   Alternative using pipe:\n   ```bash\n   cat element.md | reqvire add \"<file-path>\"\n   ```\n\n   The add command automatically:\n   - Validates markdown format\n   - Checks element name uniqueness\n   - Validates relation format\n   - Updates the file\n\n4. **Check if verification is needed:**\n   - **Leaf requirement** (no derived children): Needs verification\n   - **Parent requirement** (has derived children): Verification rolls up from children\n\n   Run traces to check hierarchy:\n   ```bash\n   reqvire traces --filter-name=\"<requirement-name>\"\n   ```\n\n5. **Check coverage:**\n   ```bash\n   reqvire coverage --filter-name=\"<requirement-name>\"\n   ```\n\n6. **Next steps:**\n   - If **leaf requirement**: Suggest `/add-verification` to create verification\n   - If **parent requirement**: Explain verification will roll up from child requirements\n\n## Element Manipulation\n\nAfter adding requirements, you may need to reorganize:\n\n**Move element to different file:**\n```bash\nreqvire mv \"<element-name>\" \"<target-file>\"\n```\n\n**Move element with specific position (0-based index):**\n```bash\nreqvire mv \"<element-name>\" \"<target-file>\" 0\n```\n\n**Remove element:**\n```bash\nreqvire rm \"<element-name>\"\n```\n\n## Best Practices\n\n- **Atomic requirements**: One capability per requirement\n- **Refinement in Details**: Clarifications go in `#### Details`, not new requirements\n- **Leaf verification**: Only leaf requirements need direct verification\n- **Roll-up coverage**: Parent requirements inherit verification from children\n- **Clear**: Use ears patterns for consistency\n- **Traceable**: Always link to parent via derivedFrom\n- **Unique names**: Element names must be unique within each file\n\n## Verification Philosophy\n\nReqvire uses **bottom roll-up verification coverage**:\n- **Leaf requirements** must be verified directly\n- **Parent requirements** inherit verification from their children\n- High-level requirements are rarely verified directly\n- Run `reqvire traces` to see verification roll-up structure\n\n## Notes\n\n- Element names become URL fragments (spaces → hyphens, lowercase)\n- Use two-space indentation for Relations entries\n- Use `#### Details` for refinements that don't add capabilities\n- For complete feature (requirement + verification + test), use `/reqvire:add-feature`\n",
        "claude-plugins/commands/add-verification.md": "---\nallowed-tools: Read, Edit, Bash(reqvire:*)\nargument-hint: [requirement-id]\ndescription: Add a verification for an existing requirement, checking if verification is needed based on requirement hierarchy\nmodel: claude-sonnet-4-5\n---\n\n# Add Verification\n\nAdd a verification for an existing requirement following Reqvire's bottom roll-up verification philosophy.\n\n## Current Model Context\n\n- Total verifications: !`reqvire search --json | jq -r '.global_counters.verifications'`\n- Verification coverage: !`reqvire coverage --json | jq -r '.summary.leaf_requirements_coverage_percentage'`%\n- Unverified leaf requirements: !`reqvire coverage --json | jq -r '.summary.unverified_leaf_requirements'`\n\n## User Request\n\n${1:+Requirement ID: $1}\n${1:-The user will specify which requirement needs verification.}\n\n## Steps\n\n1. **Identify the requirement:**\n   - Ask user which requirement needs verification if not provided\n   - Get the requirement identifier or name\n\n2. **Check if verification is needed:**\n   ```bash\n   reqvire traces --filter-name=\"<requirement-name>\"\n   ```\n\n   Analyze the trace tree:\n   - **Leaf requirement** (no children): Needs direct verification\n   - **Parent requirement** (has children): Verification rolls up from children - usually no direct verification needed\n\n3. **Check current coverage:**\n   ```bash\n   reqvire coverage --filter-name=\"<requirement-name>\"\n   ```\n\n4. **If leaf requirement needs verification:**\n\n   Choose verification type:\n   - **verification** (or test-verification): Automated testing\n   - **analysis-verification**: Mathematical/computational analysis\n   - **inspection-verification**: Manual inspection/review\n   - **demonstration-verification**: Operational demonstration\n\n5. **Read all requirements in trace chain:**\n\n   For each requirement this verification will verify:\n   ```bash\n   reqvire search --filter-id=\"<requirement-id>\"\n   ```\n\n   Extract:\n   - Requirement content (capabilities and constraints)\n   - All requirements in derivedFrom chain up to root\n   - Build complete understanding of what needs verification\n\n6. **Draft verification content:**\n\n   Template for verification:\n   ```markdown\n   ### Verification Name\n\n   [Description of how ALL requirements in the trace chain will be verified]\n\n   #### Details\n\n   ##### Acceptance Criteria\n   - [Criterion for leaf requirement 1]\n   - [Criterion for leaf requirement 2]\n   - [Criterion that verifies parent capabilities through leaf tests]\n\n   ##### Test Criteria\n   - [How to test criterion 1]\n   - [How to test criterion 2]\n   - [Expected outcomes]\n\n   #### Metadata\n     * type: test-verification\n\n   #### Relations\n     * verify: [Leaf Requirement 1](../path/to/req1.md#leaf-requirement-1)\n     * verify: [Leaf Requirement 2](../path/to/req2.md#leaf-requirement-2)\n     * satisfiedBy: [test.sh](../../tests/test-name/test.sh)\n   ```\n\n   Note: Only test-verification type can have satisfiedBy relations to test files.\n\n7. **Add verification using reqvire add command:**\n\n   ```bash\n   reqvire add \"requirements/Verifications/<file>.md\" <<'EOF'\n   ### Verification Name\n\n   [Description of verification approach]\n\n   #### Details\n\n   ##### Acceptance Criteria\n   - [What must be satisfied]\n   - [Functional criteria]\n\n   ##### Test Criteria\n   - [How to verify]\n   - [Expected behavior]\n\n   #### Metadata\n     * type: test-verification\n\n   #### Relations\n     * verify: [Requirement](../path.md#requirement)\n   EOF\n   ```\n\n   Optional: Insert at specific position (0-based index):\n   ```bash\n   reqvire add \"requirements/Verifications/<file>.md\" 0 <<'EOF'\n   ...\n   EOF\n   ```\n\n   Alternative using pipe:\n   ```bash\n   cat element.md | reqvire add \"requirements/Verifications/<file>.md\"\n   ```\n\n   The add command automatically:\n   - Validates markdown format\n   - Checks element name uniqueness\n   - Validates relation format\n   - Updates the file\n\n8. **Update the requirements with verifiedBy relations:**\n   Add `verifiedBy` relation to each verified requirement:\n   ```markdown\n   #### Relations\n     * derivedFrom: [Parent](...)\n     * verifiedBy: [Verification Name](../Verifications/file.md#verification-name)\n   ```\n\n9. **Check updated coverage:**\n    ```bash\n    reqvire coverage --filter-name=\"<requirement-name>\"\n    ```\n\n10. **Verify roll-up and check for redundancies:**\n    ```bash\n    reqvire traces --filter-name=\"<verification-name>\"\n    reqvire lint --json > /tmp/lint.json\n    ```\n\n    Check if verification creates redundant verify relations (verifying both leaf and parent).\n\n## Element Manipulation\n\nAfter adding verifications, you may need to reorganize:\n\n**Move verification to different file:**\n```bash\nreqvire mv \"<verification-name>\" \"requirements/Verifications/<file>.md\"\n```\n\n**Move verification with specific position (0-based index):**\n```bash\nreqvire mv \"<verification-name>\" \"<target-file>\" 0\n```\n\n**Remove verification:**\n```bash\nreqvire rm \"<verification-name>\"\n```\n\n## Decision Logic\n\n**If parent requirement with children:**\n- Explain verification rolls up from children\n- Show trace tree demonstrating coverage\n- Usually no direct verification needed\n\n**If leaf requirement without verification:**\n- Read ALL requirements in trace chain\n- Create verification with test criteria covering entire chain\n- Link to requirement(s)\n- Add test linkage ONLY if type is test-verification AND test exists\n\n**If existing verification needs update:**\n- Read all requirements currently verified\n- Read all requirements in their trace chains\n- Update test criteria to cover all requirements comprehensively\n\n## Best Practices\n\n- **Read trace chain**: Always read full requirement hierarchy to understand scope\n- **Comprehensive criteria**: Test criteria must cover all verified requirements\n- **Verify leaf requirements**: Focus on leaf-level verification\n- **Roll-up coverage**: Parent requirements inherit from children\n- **Avoid redundancy**: Don't verify both leaf and parent directly\n- **Use traces**: Run `reqvire traces` to understand verification structure\n- **Test links for test-verification only**: Only test-verifications link to test files\n\n## Verification Types\n\n- **test-verification**: Links to automated test files via satisfiedBy\n- **analysis-verification**: No test linkage, verified through analysis\n- **inspection-verification**: No test linkage, verified through manual inspection\n- **demonstration-verification**: No test linkage, verified through demonstration\n\n## Verification Philosophy\n\nReqvire uses **bottom roll-up verification**:\n1. Verify leaf requirements directly\n2. Parent requirements inherit coverage from children\n3. One verification can verify multiple leaf requirements\n4. Verification traces automatically propagate upward\n5. Test criteria must cover ALL requirements in the trace chain\n\n## Notes\n\n- Verifications go in `requirements/Verifications/` directory\n- Use two-space indentation for Relations entries\n- Always read full trace chain before writing test criteria\n- Run `reqvire lint --fix` after adding to remove redundancies\n- Check `reqvire coverage` to confirm improvement\n",
        "claude-plugins/commands/analyze-coverage.md": "---\nallowed-tools: Read, Bash(reqvire:*)\ndescription: Analyze verification coverage and identify unverified requirements\nmodel: claude-sonnet-4-5\n---\n\n# Analyze Verification Coverage\n\nAnalyze verification coverage to identify gaps and unverified requirements.\n\n## Current Coverage\n\n- Total requirements: !`reqvire coverage --json | jq -r '.summary.total_leaf_requirements'`\n- Verified: !`reqvire coverage --json | jq -r '.summary.verified_leaf_requirements'`\n- Coverage: !`reqvire coverage --json | jq -r '.summary.leaf_requirements_coverage_percentage'`%\n- Unverified: !`reqvire coverage --json | jq -r '.summary.unverified_leaf_requirements'`\n\n## Steps\n\n1. **Generate coverage report:**\n   ```bash\n   reqvire coverage\n   reqvire coverage --json > /tmp/coverage.json\n   ```\n\n2. **Analyze coverage statistics:**\n   - Extract total requirements count\n   - Calculate verification percentage\n   - Identify unverified requirements count\n\n3. **Identify unverified leaf requirements:**\n\n   From coverage JSON:\n   ```bash\n   jq '.unverified_leaf_requirements' /tmp/coverage.json\n   ```\n\n   Focus on leaf requirements (requirements without derived children).\n\n4. **Check if parent requirements need verification:**\n\n   For each unverified requirement:\n   ```bash\n   reqvire traces --filter-name=\"<requirement-name>\"\n   ```\n\n   Determine:\n   - Is this a leaf requirement? (needs verification)\n   - Is this a parent requirement? (should inherit from children)\n\n5. **Present findings:**\n\n   **Coverage Summary:**\n   - Total requirements: X\n   - Verified requirements: Y\n   - Coverage percentage: Z%\n\n   **Unverified Leaf Requirements:**\n   - [Requirement Name](file.md#requirement-name) - needs verification\n   - [Another Requirement](file.md#another) - needs verification\n\n   **Parent Requirements (OK - coverage rolls up):**\n   - [Parent Requirement](file.md#parent) - covered by children\n\n6. **Provide recommendations:**\n   - List leaf requirements needing verifications\n   - Suggest using `/add-verification` for each\n   - Explain which parents are OK (inherit from children)\n\n## Notes\n\n- Focus on leaf requirements for verification\n- Parent requirements inherit coverage from children\n- Use `/add-verification` to create missing verifications\n- Run `reqvire coverage` after adding verifications to confirm improvement\n",
        "claude-plugins/commands/analyze-impact.md": "---\nallowed-tools: Read, Bash(reqvire:*), Bash(git:*)\nargument-hint: [commit-hash]\ndescription: Analyze change impact for modified requirements using git commit history\nmodel: claude-sonnet-4-5\n---\n\n# Analyze Change Impact\n\nAnalyze how changes to requirements propagate through the model.\n\n## Git Context\n\n- Current branch: !`git branch --show-current`\n- Recent commits: !`git log --oneline -5`\n- Base branch merge-base: !`git merge-base main HEAD 2>/dev/null || echo \"N/A\"`\n\n## Comparison Target\n\n${1:+Comparing against: $1}\n${1:-Comparing against: HEAD~1 (previous commit)}\n\n## Steps\n\n1. **Get base commit:**\n\n   ${1:+Using provided commit: $1}\n   ${1:-Ask user for commit hash or use default:}\n   ```bash\n   # Compare against HEAD~1 (previous commit)\n   BASE_COMMIT=\"${1:-HEAD~1}\"\n\n   # Or compare against specific commit\n   BASE_COMMIT=\"<commit-hash>\"\n\n   # Or compare against base branch\n   BASE_COMMIT=$(git merge-base main HEAD)\n   ```\n\n2. **Run change impact analysis:**\n   ```bash\n   reqvire change-impact --git-commit=${1:-HEAD~1}\n   reqvire change-impact --git-commit=${1:-HEAD~1} --json > /tmp/impact.json\n   ```\n\n3. **Analyze the results:**\n\n   Extract from JSON:\n   - `added_elements[]` - New requirements/verifications\n   - `modified_elements[]` - Changed requirements/verifications\n   - `affected_elements[]` - Elements impacted by changes\n\n4. **For each modified requirement:**\n\n   ```bash\n   reqvire search --filter-id=\"<requirement-id>\"\n   reqvire traces --filter-id=\"<requirement-id>\"\n   ```\n\n   Identify:\n   - What changed in the requirement\n   - Which verifications verify this requirement\n   - Which implementations satisfy this requirement\n   - Which children derive from this requirement\n\n5. **Present impact findings:**\n\n   **Added Elements:**\n   - [New Requirement](file.md#new-req) - type: requirement\n\n   **Modified Elements:**\n   - [Changed Requirement](file.md#changed) - review needed\n\n   **Affected Elements (propagation):**\n   - Verifications needing review: X\n   - Implementations needing update: Y\n   - Child requirements affected: Z\n\n6. **Provide recommendations:**\n   - Review and update affected verifications\n   - Update test criteria if requirements changed\n   - Review implementations marked with satisfiedBy\n   - Run tests for affected verifications\n   - Update child requirements if parent semantics changed\n\n## Change Propagation Rules\n\n- **Parent → Child**: Parent changes propagate to all derived children\n- **Requirement → Verification**: Requirement changes invalidate verifications\n- **Requirement → Implementation**: May need implementation updates\n- **Verification changes**: Generally don't propagate upward\n\n## Notes\n\n- Use for understanding impact before making changes\n- Run after making changes to identify affected elements\n- Focus on verifications - they need review when requirements change\n- Use `/generate-tasks` to create implementation tasks from impact\n",
        "claude-plugins/commands/analyze-model.md": "---\nallowed-tools: Read, Bash(reqvire:*)\ndescription: Analyze the current Reqvire model structure, identify issues, coverage gaps, and provide improvement recommendations\nmodel: claude-sonnet-4-5\n---\n\n# Analyze Reqvire Model\n\nPerform comprehensive analysis of the current Reqvire model.\n\n## Current Model State\n\n- Validation status: !`reqvire validate 2>&1 | head -1`\n- Total elements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n- Verification coverage: !`reqvire coverage --json | jq -r '.summary.leaf_requirements_coverage_percentage'`%\n- Test satisfaction: !`reqvire coverage --json | jq -r '.summary.test_verifications_satisfaction_percentage'`%\n\n## Steps\n\n1. **Run validation:**\n   ```bash\n   reqvire validate --json > /tmp/validation.json\n   ```\n\n2. **Generate model search:**\n   ```bash\n   reqvire search --short --json > /tmp/search.json\n   ```\n\n   Use `--short` to get model structure without full content.\n\n3. **Check coverage:**\n   ```bash\n   reqvire coverage --json > /tmp/coverage.json\n   ```\n\n4. **Run lint checks:**\n   ```bash\n   reqvire lint --json > /tmp/lint.json\n   ```\n\n5. **Analyze the results:**\n   - Review validation errors and warnings\n   - Identify unverified requirements from coverage report\n   - Check for model quality issues from lint report\n   - Calculate coverage percentages and statistics\n\n6. **Provide recommendations:**\n   - List specific issues found with file locations\n   - Suggest improvements prioritized by impact\n   - Recommend commands to fix issues (e.g., `reqvire lint --fix`)\n   - Identify requirements needing verifications\n\n## Output Format\n\nPresent findings in clear sections:\n- **Validation Results**: Errors and warnings\n- **Coverage Analysis**: Verification coverage statistics\n- **Model Quality**: Lint findings (auto-fixable vs needs review)\n- **Recommendations**: Prioritized action items\n\n## Notes\n\n- Use `/tmp` for JSON outputs\n- Focus on actionable recommendations\n",
        "claude-plugins/commands/collect.md": "---\nallowed-tools: Read, Bash(reqvire:*)\nargument-hint: <element-name>\ndescription: Collect and summarize requirement context via derivedFrom chain\nmodel: claude-sonnet-4-5\n---\n\n# Collect Requirement Context\n\nCollect and present a comprehensive summary of requirement context via the derivedFrom chain.\n\n## Model Context\n\n- Total elements: !`reqvire search --json 2>/dev/null | jq -r '.global_counters.total_elements // \"N/A\"'`\n- Validation status: !`reqvire validate 2>&1 | head -1`\n\n## Element\n\n${1:+Target element: **$1**}\n${1:-The user will provide the element name.}\n\n## Steps\n\n### 1. Collect Raw Content\n\nRun the `reqvire collect` command to gather the complete requirement context:\n\n```bash\nreqvire collect \"${1}\" --json > /tmp/collect_output.json\n```\n\nThis command collects:\n- The target element's content and metadata\n- Full derivedFrom chain (all ancestor requirements)\n- Attached specifications, constraints, and behaviors\n- Related documentation files\n- Source citations and file paths\n- Verification and satisfaction relations\n\n**Error Handling:**\n- If the command fails, check that the element name is correct\n- Element names are case-sensitive and must match exactly\n- Use `reqvire search --short` to find the exact element name if needed\n\n### 2. Read and Analyze JSON Output\n\nRead the collected JSON file:\n\n```bash\n# The file /tmp/collect_output.json contains structured data\n```\n\nThe JSON structure includes:\n- **`element`**: The target element's content, metadata, and type\n- **`ancestors`**: Array of parent elements in the derivedFrom chain (from root to target)\n- **`attachments`**: Specifications, constraints, and behaviors attached to requirements\n- **`documents`**: Related markdown documentation files with content\n- **`citations`**: Source file paths and anchors for traceability\n- **`relations`**: verifiedBy and satisfiedBy links to other elements\n\nExtract and organize:\n- **Target element details**: Name, type, full content\n- **Derivation hierarchy**: Parent requirements showing refinement path\n- **Attached specifications**: All specs, constraints, behaviors\n- **Documentation**: Content from attached markdown files\n- **Verification info**: verifiedBy relations and test criteria\n- **Implementation info**: satisfiedBy relations and code references\n- **Source locations**: File paths and anchors for all elements\n\n### 3. Generate Comprehensive Context Document\n\nCreate a complete, readable markdown document that synthesizes all collected information into a coherent narrative.\n\n**CRITICAL FORMATTING REQUIREMENTS:**\n- **NO page limits** - include complete details regardless of length\n- **Rephrase all content** into coherent, readable narrative (don't copy-paste raw data)\n- **Synthesize and explain** - make it flow as documentation someone would want to read\n- **Organize by topic** - not by source or element type\n- **All references at end** - citations and traceability links in References section\n\n#### Document Structure\n\n```markdown\n# Requirement Context: [Element Name]\n\n## Overview\n\n[Write a comprehensive description of what this requirement accomplishes, its purpose, and business value. Rephrase the requirement content to be narrative and readable, not just quoted. Explain what problem it solves and who benefits.]\n\n## Background\n\n[Explain the requirement chain and why this requirement exists. Describe the derivedFrom chain from root requirements down to this element. For each level in the hierarchy, explain the refinement - how each child adds specificity or detail to its parent. This section tells the \"why\" story.]\n\n## Detailed Specifications\n\n### Core Requirements\n\n[Include ALL requirement content, rephrased as a coherent narrative. Break down into logical subsections if the requirement is complex. Don't just list - explain what the requirement means and implies. Include all details but make them readable.]\n\n### Implementation Details\n\n[Describe how this requirement is satisfied. Extract information from satisfiedBy relations and attached specifications:]\n\n- **Code/Components**: [List and describe all satisfiedBy elements - what they are and how they satisfy the requirement]\n- **API Endpoints**: [If applicable, detail all API specifications including methods, paths, parameters, responses]\n- **Algorithms**: [If applicable, describe technical approaches and logic]\n- **Data Structures**: [If applicable, describe data models and schemas]\n- **Architecture**: [If applicable, explain system components and interactions]\n\n### Constraints and Validation\n\n[Detail ALL constraints and validation rules from attached constraint elements. Don't just list - explain what each constraint means, why it exists, and what it prevents or ensures. Make the constraints understandable.]\n\n### Attached Specifications\n\n[Include content from ALL attached specifications, constraints, and behaviors. Rephrase this content to flow naturally as part of the document narrative. Synthesize related specs together rather than treating them as separate items.]\n\n## Verification\n\n[Describe how this requirement is verified, extracted from verifiedBy relations and attached verification elements:]\n\n- **Verification Methods**: [List and describe verifiedBy elements - what type of verification (test, inspection, analysis, demonstration)]\n- **Test Criteria**: [Explain what the tests validate and how they prove the requirement is satisfied]\n- **Acceptance Criteria**: [Detail what constitutes successful verification - what must pass]\n- **Coverage**: [If applicable, mention any unverified aspects or verification gaps]\n\n## Related Documentation\n\n[Describe attached documentation files and their relevance. Include key insights and important information from these documents. Summarize what developers need to know from the documentation.]\n\n## References\n\n[All source citations, file paths, and traceability links go here at the end:]\n\n**Source:**\n- File: [path/to/file.md#element-anchor]\n- Type: [requirement/specification/etc.]\n\n**Derived From:**\n[List all parent requirements in the derivedFrom chain with links]\n- [Parent Requirement 1](path/to/file.md#parent-1)\n- [Parent Requirement 2](path/to/file.md#parent-2)\n\n**Verified By:**\n[List all verifications that verify this requirement]\n- [Verification 1](path/to/file.md#verification-1)\n- [Verification 2](path/to/file.md#verification-2)\n\n**Satisfied By:**\n[List all implementations that satisfy this requirement]\n- [Implementation 1](path/to/file.md#impl-1)\n- [Implementation 2](path/to/file.md#impl-2)\n\n**Attached Elements:**\n[List all attached specifications, constraints, behaviors]\n- [Specification 1](path/to/file.md#spec-1)\n- [Constraint 1](path/to/file.md#constraint-1)\n\n**Related Documents:**\n[List all attached documentation files]\n- [Document 1](path/to/doc.md)\n\n---\n*Generated by `reqvire collect \"[Element Name]\"`*\n*For raw JSON data, see `/tmp/collect_output.json`*\n```\n\n## Output Guidelines\n\n### Writing Style\n\n- **Narrative, not lists**: Write flowing prose that explains concepts\n- **Synthesis**: Combine related information from multiple sources\n- **Context**: Explain the \"why\" behind decisions and requirements\n- **Clarity**: Use clear language that new team members can understand\n- **Completeness**: Include ALL details - nothing should be omitted\n- **Length**: As long as needed - simple features might be 1-2 pages, complex features might be 5-10 pages\n\n### Organization\n\n- **Logical grouping**: Group related specifications together\n- **Progressive detail**: Start with overview, then dive into details\n- **Topic-based**: Organize by what the information is about, not where it came from\n- **References at end**: All source links in one place for easy lookup\n\n### Content Treatment\n\n- **Rephrase everything**: Don't copy-paste requirement text verbatim\n- **Explain implications**: What does this requirement mean in practice?\n- **Connect the dots**: How do different pieces relate to each other?\n- **Extract insights**: What are the key takeaways?\n- **Preserve precision**: Keep technical accuracy while improving readability\n\n## Notes\n\n- The collect command gathers complete context, but your job is to make it readable\n- Larger requirements will naturally produce longer documents - that's expected\n- Focus on creating documentation that developers would want to read\n- All traceability is preserved in the References section\n- The goal is comprehensive understanding, not brevity\n- Use the JSON data to inform the narrative, but don't dump JSON into the output\n",
        "claude-plugins/commands/consolidate.md": "---\nallowed-tools: Read, Bash(reqvire:*)\ndescription: Consolidate elements using automated merge + intelligent cleanup workflow\nmodel: claude-sonnet-4-5\n---\n\n# Consolidate Requirements Model\n\nConsolidate child requirements that only refine their parents (without introducing new capabilities) into the parent requirement. This uses a two-phase workflow: automated merge followed by intelligent content cleanup.\n\n## Model Context\n\n- Total elements: !`reqvire search --json 2>/dev/null | jq -r '.global_counters.total_elements // \"N/A\"'`\n- Leaf requirements: !`reqvire coverage --json 2>/dev/null | jq -r '.summary.total_leaf_requirements // \"N/A\"'`\n- Validation status: !`reqvire validate 2>&1 | head -1`\n\n## When to Use\n\nUse this command when:\n- Model has grown with many small refinement requirements\n- Child requirements only elaborate on implementation details of parents\n- You want to reduce model clutter while preserving all information\n- Requirements are split via derivedFrom relations but don't add new capabilities\n\n**When to use consolidate vs direct merge:**\n- **Direct merge** (`reqvire merge`): Quick merge when raw output is acceptable, or when merging duplicates\n- **Consolidate** (`/reqvire:consolidate`): When content needs intelligent restructuring - AI reads merged element, fixes the body, and overrides with clean version\n\n## Consolidation Heuristics\n\nA child requirement is a candidate for consolidation if it meets **multiple** of these criteria:\n\n1. **Very similar names to parent** - e.g., parent: \"HTML Export\", child: \"HTML Export Verification\" or \"Export Related System Elements\"\n2. **Short content** - Less than 200 words of requirement text (excluding relations)\n3. **No verifications** - Has no verifiedBy relations of its own\n4. **Implementation-level details** - Mentions specific technical details, file formats, parameters, or procedural steps\n5. **Leaf requirement** - No children of its own, derives from only one parent\n6. **Procedural/step-by-step details** - Contains \"how-to\" information that expands on parent\n7. **Refinement keywords** - Contains phrases like \"shall support\", \"shall provide\", \"shall include\", \"formatting\", \"structure\", \"output\", \"options\", \"flags\"\n\n## Process Overview\n\nThe consolidation follows a **two-phase** approach:\n\n**Phase 1: Automated Merge**\nUse `reqvire merge` to combine elements. This automatically:\n- Appends source content to target's Details section\n- Creates \"Merged Details (Source Name)\" subsections\n- Merges and deduplicates relations\n- Redirects all references to sources to point to target\n- Deletes source elements\n\n**Phase 2: Intelligent Cleanup (CRITICAL)**\nRead the merged element, restructure its content to remove merge artifacts, and override with the clean version using `reqvire add --override`.\n\n## Steps\n\n### Step 1: Analyze Model for Candidates\n\nFirst, analyze the model to identify consolidation candidates:\n\n```bash\n# Get model structure\nreqvire search --short --json > /tmp/search.json\n```\n\nReview the model structure and identify parent-child requirement pairs based on:\n- derivedFrom relationships\n- Requirement naming patterns\n- Content length and complexity\n- Presence of verifications\n\n### Step 2: Execute Merge\n\nOnce candidates are identified, execute the merge:\n\n```bash\n# Preview the merge first (recommended)\nreqvire merge \"<target-element>\" \"<source1>\" \"<source2>\" --dry-run\n\n# Execute the merge\nreqvire merge \"<target-element>\" \"<source1>\" \"<source2>\"\n```\n\n**Example:**\n```bash\n# Merge two child refinements into parent\nreqvire merge \"Format Consistency Enforcement\" \"Excess Whitespace Format\" \"Missing Separators Format\"\n```\n\n### Step 3: Read Merged Element (CRITICAL)\n\nAfter merge, read the merged element to see the raw output:\n\n```bash\n# Read the merged element to see what needs cleanup\nreqvire search --filter-name=\"<target-name>\" --json\n```\n\nThe merged element will have **artifacts that need cleanup**:\n- `#### Merged Details (Source Name)` subsections for each merged source\n- Potentially duplicated content\n- Awkward structure from concatenation\n- Multiple \"Details\" sections or subsections\n\n**Example of merge artifacts:**\n```markdown\n### Format Consistency Enforcement\n\nThe system shall provide formatting capability...\n\n#### Details\n\n[Original parent details]\n\n#### Merged Details (Excess Whitespace Format)\n\nDetect and fix excess whitespace after element headers...\n\n#### Merged Details (Missing Separators Format)\n\nDetect consecutive element sections...\n\n#### Metadata\n  * type: requirement\n\n#### Relations\n  * derivedFrom: [Model Formatting]\n  * satisfiedBy: [format.rs]\n```\n\n### Step 4: Prepare Fixed Element Body (CRITICAL)\n\nAnalyze the merged content and create a **clean, restructured version**:\n\n1. **Remove all `#### Merged Details (X)` subsection headers** - These are merge artifacts\n2. **Integrate all content logically into a single `#### Details` section** - Combine related information\n3. **Remove duplicate information** - Merge may have introduced redundancy\n4. **Ensure proper EARS statement structure** - Main content should be clear requirement statement\n5. **Maintain all Relations** - These are already correctly merged, keep them intact\n6. **Keep Metadata and Attachments** - Preserve these unchanged\n\n**Example of clean, restructured content:**\n```markdown\n### Format Consistency Enforcement\n\nThe system shall provide formatting capability for maintaining consistent document structure.\n\n#### Details\n\n**Excess Whitespace:**\n- Detect and fix excess whitespace after element headers\n- Maintain consistent formatting across all requirements documents\n\n**Missing Separators:**\n- Detect consecutive element sections that lack separators\n- Insert separators to maintain consistent visual separation\n\n#### Metadata\n  * type: requirement\n\n#### Relations\n  * derivedFrom: [Model Formatting](../ModelFormatting.md#model-formatting)\n  * satisfiedBy: [format.rs](../../core/src/format.rs)\n```\n\n### Step 5: Override with Fixed Content (CRITICAL)\n\nReplace the merged element with the clean version:\n\n```bash\nreqvire add \"<file-path>\" --override <<'EOF'\n### <Element Name>\n\n<Clean main content - EARS statement>\n\n#### Details\n\n<Consolidated details - all merged content properly integrated>\n\n#### Metadata\n  * type: <type>\n\n#### Relations\n  * <all merged relations - copy exactly from merged element>\n---\nEOF\n```\n\n**Example:**\n```bash\nreqvire add \"requirements/SystemRequirements/Formatting.md\" --override <<'EOF'\n### Format Consistency Enforcement\n\nThe system shall provide formatting capability for maintaining consistent document structure.\n\n#### Details\n\n**Excess Whitespace:**\n- Detect and fix excess whitespace after element headers\n- Maintain consistent formatting across all requirements documents\n\n**Missing Separators:**\n- Detect consecutive element sections that lack separators\n- Insert separators to maintain consistent visual separation\n\n#### Metadata\n  * type: requirement\n\n#### Relations\n  * derivedFrom: [Model Formatting](../ModelFormatting.md#model-formatting)\n  * satisfiedBy: [format.rs](../../core/src/format.rs)\n---\nEOF\n```\n\n### Step 6: Validate\n\nAfter cleanup, validate the model:\n\n```bash\n# Validate model\nreqvire validate\n\n# If validation passes, continue to next consolidation\n# If validation fails, fix issues before continuing\n```\n\n### Step 7: Format and Final Validation\n\nAfter all consolidations:\n\n```bash\n# Format all files\nreqvire format --fix\n\n# Final validation\nreqvire validate\n```\n\n## Complete Workflow Example\n\nHere's a complete example consolidating CLI option children into parent:\n\n```bash\n# 1. Identify candidates\nreqvire search --filter-name=\"CLI Traces\" --short\n# Found: CLI Traces Command, CLI Traces Filter Options, CLI Traces From-Folder Option\n\n# 2. Execute merge\nreqvire merge \"CLI Traces Command\" \"CLI Traces Filter Options\" \"CLI Traces From-Folder Option\"\n\n# 3. Read merged element\nreqvire search --filter-name=\"CLI Traces Command\" --json\n# Shows element with \"Merged Details\" sections\n\n# 4. Prepare and override with clean version\nreqvire add \"requirements/CLI/Commands.md\" --override <<'EOF'\n### CLI Traces Command\n\nThe system shall implement traces subcommand for generating verification trace reports.\n\n#### Details\n\nThe traces command outputs verification traces showing upward paths from verifications to root requirements.\n\n**Filter Options:**\nThe system shall support filtering verification traces by:\n- `--filter-id=<id>`: Filter by verification element ID\n- `--filter-name=<regex>`: Filter by name pattern\n- `--filter-type=<type>`: Filter by verification type\n\n**From-Folder Option:**\nSupport `--from-folder` option that specifies relative path for portable links:\n- Accept relative path parameter\n- Adjust clickable links in diagrams to be relative\n- Work with both Markdown and JSON output\n\n#### Metadata\n  * type: requirement\n\n#### Relations\n  * derivedFrom: [Verification Trace Builder](../Features.md#verification-trace-builder)\n  * satisfiedBy: [cli.rs](../../cli/src/cli.rs)\n---\nEOF\n\n# 5. Validate\nreqvire validate\n```\n\n## Anti-Patterns (When NOT to Consolidate)\n\nDo NOT consolidate if:\n- Child introduces **new functional capability** beyond parent\n- Child has **extensive content** (>300 words) that would overwhelm parent Details\n- Child has **many verifications** (3+) indicating significant independent functionality\n- Child is referenced by **many other elements** as a key concept\n- Child represents a **distinct abstraction level** (e.g., user requirement vs system requirement)\n- There's **uncertainty** about whether child is truly refinement-only\n\n## Expected Benefits\n\nAfter consolidation, the model will have:\n- **Reduced clutter**: Fewer top-level requirements to navigate\n- **Better organization**: Implementation details nested under conceptual parents\n- **Improved readability**: Related information grouped together\n- **Maintained traceability**: All relations preserved through parent requirements\n- **Cleaner structure**: Hierarchical organization matches conceptual dependencies\n\n## Verification\n\nAfter consolidation is complete, verify:\n- Model validates with no errors: `reqvire validate`\n- All relations are preserved (no missing targets)\n- Verification coverage percentage unchanged or improved\n- Test verifications still link correctly to requirements\n- Documentation exports correctly: `reqvire export`\n",
        "claude-plugins/commands/containment.md": "---\nallowed-tools: Read, Bash(reqvire:*)\ndescription: Analyze model's containment structure (folders, files, and elements) to understand organization and suggest improvements\nmodel: claude-sonnet-4-5\n---\n\n# Containment View\n\nAnalyze the physical structure of your Reqvire model to understand how elements are organized across folders and files, identify organizational issues, and suggest improvements.\n\n## Current Model Context\n\n- Total elements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n- Total files: !`reqvire search --json | jq -r '.global_counters.total_files'`\n\n## Steps\n\n1. **Get containment structure in JSON format:**\n   ```bash\n   reqvire containment --json\n   ```\n\n   This provides the hierarchical structure showing:\n   - Folder hierarchy\n   - Files within each folder\n   - Elements within each file (**filtered to show only top-level parents** - elements without hierarchical parent relations in same file)\n   - Element types and identifiers\n\n   **Note:** Element count in containment view does not represent total file size. Use `reqvire search --filter-file=\"path\" --json` to get actual element counts per file.\n\n2. **Get actual element counts per file:**\n   ```bash\n   # Count total elements per file\n   reqvire search --json | jq -r '.files | to_entries[] | \"\\(.key): \\(.value.total_elements) elements\"'\n\n   # Find files with many elements (>20)\n   reqvire search --json | jq -r '.files | to_entries[] | select(.value.total_elements > 20) | \"\\(.key): \\(.value.total_elements) elements\"'\n\n   # Find files with few elements (<3)\n   reqvire search --json | jq -r '.files | to_entries[] | select(.value.total_elements < 3) | \"\\(.key): \\(.value.total_elements) elements\"'\n   ```\n\n3. **Analyze the structure:**\n   - Identify files with too many elements (>20 suggests need for splitting)\n   - Find files with too few elements (<3 suggests potential for consolidation)\n   - Check if folder structure reflects logical organization\n   - Verify naming conventions are consistent\n   - Look for orphaned or misplaced files\n\n4. **Generate text diagram for visualization:**\n   ```bash\n   reqvire containment\n   ```\n\n   This creates a Mermaid graph showing the containment tree structure.\n\n5. **Provide recommendations:**\n   Based on the analysis, suggest:\n   - Files that should be split (too many elements)\n   - Files that could be merged (too few elements)\n   - Better folder organization\n   - Naming improvements\n   - Structural refactoring using mv-file or mv commands\n\n## Understanding Containment vs. Traceability\n\n**Containment** (physical structure):\n- How elements are organized in folders and files\n- File system hierarchy\n- Element grouping within files\n- Use for: Reorganizing, refactoring, improving maintainability\n\n**Traceability** (logical relationships):\n- How elements relate through derivedFrom, verify, satisfiedBy relations\n- Requirement flow-down and verification chains\n- Use for: Understanding dependencies, impact analysis, coverage\n\n## When to Use Containment View\n\nUse containment analysis when:\n- **Model organization needs assessment** - Check if file structure makes sense\n- **Refactoring planning** - Decide which files to split, merge, or reorganize\n- **Onboarding** - Help new team members understand model structure\n- **Finding organizational issues** - Locate files that are too large, too small, or misplaced\n- **Planning mv-file operations** - Understand current structure before reorganizing\n\n## Analysis Questions to Ask\n\n1. **Are files too large?**\n   - Files with >20 elements are hard to navigate\n   - Consider splitting by feature, subsystem, or level\n\n2. **Are files too small?**\n   - Files with 1-2 elements may indicate over-fragmentation\n   - Consider using --squash to consolidate\n\n3. **Does folder structure make sense?**\n   - Are related requirements grouped together?\n   - Do folder names reflect content?\n   - Is hierarchy appropriate (not too deep, not too flat)?\n\n4. **Are elements well-distributed?**\n   - Look for imbalanced distribution across files\n   - Check if related elements are in same file\n\n5. **Is naming consistent?**\n   - File naming conventions followed?\n   - Folder names descriptive and standardized?\n\n## Example Analysis Workflow\n\n```bash\n# 1. Get containment structure (folder/file hierarchy)\nreqvire containment --json > /tmp/containment.json\n\n# 2. Get actual element counts per file\nreqvire search --json | jq -r '.files | to_entries[] | \"\\(.key): \\(.value.total_elements) elements\"' > /tmp/file_sizes.txt\n\n# 3. Find files with many elements (candidates for splitting)\nreqvire search --json | jq -r '.files | to_entries[] | select(.value.total_elements > 20) | \"\\(.key): \\(.value.total_elements) elements\"'\n\n# 4. Find files with few elements (candidates for consolidation)\nreqvire search --json | jq -r '.files | to_entries[] | select(.value.total_elements < 3) | \"\\(.key): \\(.value.total_elements) elements\"'\n\n# 5. Visualize folder structure\nreqvire containment\n\n# 6. Plan refactoring based on findings\n```\n\n## Recommendations Format\n\nProvide clear, actionable recommendations:\n\n**Files to Split:**\n- `requirements/LargeFile.md` (45 elements) → Consider splitting into:\n  - `requirements/Feature1.md` (requirements for Feature 1)\n  - `requirements/Feature2.md` (requirements for Feature 2)\n\n**Files to Consolidate:**\n- `temp/A.md` (2 elements) + `temp/B.md` (3 elements) → Use:\n  ```bash\n  reqvire mv-file \"temp/B.md\" \"temp/A.md\" --squash\n  ```\n\n**Folder Reorganization:**\n- Move security-related files from `requirements/` to new `security/` folder\n\n## Related Commands\n\n- **Move file**: `/reqvire:mv-file` - Reorganize files based on analysis\n- **Move element**: `/reqvire:mv` - Move individual elements between files\n- **Analyze model**: `/analyze-model` - Check logical model structure and relationships\n- **Search**: `reqvire search` - Find specific elements to understand placement\n",
        "claude-plugins/commands/find-redundant-verifications.md": "---\nallowed-tools: Read, Bash(reqvire:*)\ndescription: Find and analyze redundant verify relations in the Reqvire model\nmodel: claude-sonnet-4-5\n---\n\n# Find Redundant Verify Relations\n\nAnalyze the verification traces to find redundant verify relations in the model.\n\n## Current Status\n\n- Auto-fixable issues: !`reqvire lint --json 2>&1 | jq -r '\"\\(if .auto_fixable then (.auto_fixable | length) else 0 end) (including redundant verifications)\"'`\n\n## Instructions\n\n1. Run the lint command to find redundancies:\n   ```bash\n   reqvire lint --json > /tmp/lint.json\n   ```\n\n2. Parse the JSON to find redundant verify relations:\n   ```bash\n   jq -r '\n   .auto_fixable[] |\n   select(.type == \"redundant_verify_relations\") |\n   \"## Verification: \\(.verification.name)\\n\" +\n   \"**File**: \\(.verification.file)\\n\" +\n   \"**Identifier**: `\\(.verification.identifier)`\\n\\n\" +\n   \"**Redundant VERIFY Relations** (will be auto-removed with lint --fix):\\n\" +\n   (.redundant_relations[] | \"  * verify: \\(.target)\\n\") +\n   \"\\n**Reason**: \\(.rationale)\\n\\n\" +\n   \"---\\n\"\n   ' /tmp/lint.json || echo \"No redundant verify relations found.\"\n   ```\n\n3. Present the results to the user showing:\n   - Which verifications have redundant relations\n   - Which specific verify relations can be removed\n   - Explanation of why they're redundant\n\n4. If no redundancies found, report: \"No redundant verify relations found in the model.\"\n\n5. **Auto-fix option:**\n   ```bash\n   reqvire lint --fix\n   ```\n\n## Background\n\nA verify relation is redundant when:\n- A verification directly verifies both a child requirement AND its parent\n- Since verification traces roll up automatically, verifying the child is sufficient\n- The direct verification of the parent adds noise to the model\n\nExample:\n```\nVerification \"Password Test\" verifies:\n  - \"Password Strength\" (leaf requirement)\n  - \"Password Authentication\" (parent of Password Strength)\n\n→ The verify relation to \"Password Authentication\" is REDUNDANT\n```\n\nThe system automatically detects this by building trace trees and checking if any ancestor requirements are also directly verified.\n\n## Notes\n\n- Use `reqvire lint --fix` to automatically remove redundant relations\n- Redundant verify relations are always safe to remove\n- Run `reqvire validate` after fixing to confirm model integrity\n",
        "claude-plugins/commands/generate-tasks.md": "---\nallowed-tools: Read, Bash(reqvire:*), Bash(git:*)\nargument-hint: [base-commit]\ndescription: Generate implementation task plan from requirement changes using change-impact analysis\nmodel: claude-sonnet-4-5\n---\n\n# Generate Tasks\n\nGenerate implementation task plan from requirement changes on a feature branch.\n\n## Context\n\n- Current branch: !`git rev-parse --abbrev-ref HEAD`\n- Base commit: ${1:-!`git merge-base main HEAD 2>/dev/null || git merge-base master HEAD`}\n\n## Steps\n\n1. **Detect base branch:**\n   ```bash\n   CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\n\n   if git show-ref --verify --quiet refs/heads/main; then\n       BASE_BRANCH=\"main\"\n   elif git show-ref --verify --quiet refs/heads/master; then\n       BASE_BRANCH=\"master\"\n   else\n       echo \"Specify base commit manually\"\n       exit 1\n   fi\n\n   BASE_COMMIT=\"${1:-$(git merge-base $BASE_BRANCH HEAD)}\"\n   ```\n\n2. **Run change impact:**\n   ```bash\n   reqvire change-impact --git-commit=$BASE_COMMIT --json > /tmp/impact.json\n   ```\n\n3. **For each changed requirement:**\n\n   Get full context using collect:\n   ```bash\n   reqvire collect \"<requirement-name>\" --json > /tmp/req_<requirement-id>.json\n   ```\n\n   This provides:\n   - Complete requirement chain via derivedFrom relations\n   - All parent requirements for context\n   - Specifications that satisfy the requirement\n   - Attached design documents\n   - Full implementation context\n\n   Also get direct details:\n   ```bash\n   reqvire search --filter-id=\"<requirement-id>\" --json\n   ```\n\n   Extract:\n   - Requirement content\n   - verifiedBy relations (tests to run)\n   - satisfiedBy relations (code to update)\n   - derivedFrom relations (context)\n\n4. **For each verification:**\n\n   Get test paths:\n   ```bash\n   reqvire search --filter-id=\"<verification-id>\" --json\n   ```\n\n   Extract satisfiedBy relations (test files).\n\n5. **Generate TodoWrite task plan:**\n\n   **Use collected context** from `/tmp/req_<requirement-id>.json` to create concise summaries:\n   - Extract parent requirement purpose (why this exists)\n   - Identify key specifications (how to implement)\n   - Note important constraints and validation rules\n   - Summarize in ~2-3 sentences\n\n   **For new requirements:**\n   ```\n   ☐ Implement \"{Requirement Name}\" ({REQ-ID})\n     Context: [2-3 sentence summary from collected chain]\n     Purpose: [Why - from parent requirement]\n     Implementation: [Key specs/API endpoints from collected data]\n\n     ☐ Review full requirement context: [link to collect output]\n     ☐ Review requirement: [link to blob]\n     ☐ Implement functionality per specifications\n     ☐ Run tests: {test paths}\n     ☐ Add satisfiedBy relation\n     ☐ Validate: reqvire validate\n   ```\n\n   **For modified requirements:**\n   ```\n   ☐ Update \"{Requirement Name}\" ({REQ-ID})\n     Context: [What changed - from collected chain]\n     Impact: [Affected specs/constraints from collected data]\n\n     ☐ Review full requirement context: [link to collect output]\n     ☐ Review changes: [link to blob]\n     ☐ Review code: {satisfiedBy paths}\n     ☐ Update implementation\n     ☐ Run tests: {test paths}\n     ☐ Validate: reqvire validate\n   ```\n\n6. **Generate git blob links:**\n   ```bash\n   REPO_URL=$(git remote get-url origin | sed 's/\\.git$//' | sed 's/git@github.com:/https:\\/\\/github.com\\//')\n   BLOB_URL=\"${REPO_URL}/blob/${BASE_COMMIT}/${file_path}#${element-anchor}\"\n   ```\n\n7. **Save collected context for reference:**\n\n   For each requirement, save a formatted summary:\n   ```bash\n   # Save collected output to /tmp for reference\n   reqvire collect \"<requirement-name>\" > /tmp/req_context_<requirement-id>.md\n   ```\n\n   This provides developers with full context documents they can reference during implementation.\n\n8. **Present task plan:**\n   - Phase 1: New requirements to implement (with context summaries)\n   - Phase 2: Modified requirements to update (with impact analysis)\n   - Phase 3: Affected verifications to review\n   - Appendix: Links to full context documents in /tmp\n\n## Task Plan Structure\n\n```markdown\n# Implementation Task Plan\n\n**Base**: {base_branch}@{base_commit}\n**Feature**: {current_branch}\n\n## Summary\n- New requirements: X\n- Modified requirements: Y\n- Tests to run: Z\n\n## Tasks\n{TodoWrite formatted tasks with context summaries}\n\n## Reference Documents\n\nFull requirement context available in `/tmp/`:\n- `/tmp/req_context_<req-id-1>.md` - Full context for {Requirement Name 1}\n- `/tmp/req_context_<req-id-2>.md` - Full context for {Requirement Name 2}\n\nEach context document shows:\n- Complete requirement chain (derivedFrom)\n- Parent requirements and purpose\n- Specifications and implementation details\n- Attached design documents\n- Constraints and validation rules\n```\n\n## Notes\n\n- Task plan uses TodoWrite format for tracking\n- Links to exact requirement versions via git blob URLs\n- Repository-agnostic: no technology assumptions\n- Always read full requirements, not just summaries\n",
        "claude-plugins/commands/link.md": "---\nallowed-tools: Read, Bash(reqvire:*)\nargument-hint: <source> <relation-type-or-attaching> <target>\ndescription: Link elements with a relation or attach files/elements\nmodel: claude-sonnet-4-5\n---\n\n# Link Elements\n\nCreate a relation between elements or attach files/refinement elements. This unified command handles both relations and attachments.\n\n## Current Model Context\n\n- Total elements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n\n## User Request\n\n${1:+Source element: $1}\n${2:+Relation type or 'attaching': $2}\n${3:+Target: $3}\n${1:-The user will provide source element, relation type (or 'attaching'), and target.}\n\n## Steps\n\n1. **Understand the context:**\n   - Identify the source element (by name)\n   - Determine if this is a relation or attachment ('attaching' keyword)\n   - Identify the target (element name, file path, or URL)\n   - Verify source element exists\n\n2. **Preview the link operation:**\n   ```bash\n   reqvire link \"<source-element>\" \"<relation-type-or-attaching>\" \"<target>\" --dry-run\n   ```\n\n   This shows:\n   - Which file will be modified\n   - The relation/attachment that will be added\n   - Git-style diff for the affected file\n\n3. **Apply the link:**\n   ```bash\n   reqvire link \"<source-element>\" \"<relation-type-or-attaching>\" \"<target>\"\n   ```\n\n   The link command automatically:\n   - For relations: Adds to the source element's Relations section\n   - For attachments: Adds to the source element's Attachments section\n   - Calculates correct relative path for cross-file links\n   - Creates the section if it doesn't exist\n   - Maintains idempotency (no duplicate relations/attachments)\n\n4. **Verify the changes:**\n   ```bash\n   reqvire validate\n   ```\n\n## Supported Relation Types\n\n| Relation Type | Description | Usage |\n|---------------|-------------|-------|\n| `derivedFrom` | Source derives from target | Child to parent requirement |\n| `derive` | Source has derived target | Parent to child requirement |\n| `verifiedBy` | Source is verified by target | Requirement to verification |\n| `verify` | Source verifies target | Verification to requirement |\n| `satisfiedBy` | Source is satisfied by target | Requirement to implementation |\n| `satisfy` | Source satisfies target | Implementation to requirement |\n| `trace` | General traceability link | Any traceability relationship |\n| `attaching` | Attach file or element | Attach documents or refinements |\n\n## Target Types\n\n**For relations:**\n- Element name (e.g., \"System Requirement\")\n- Internal file path (e.g., \"src/impl.rs\")\n- External URL (e.g., \"https://example.com/spec.html\")\n\n**For attaching:**\n- Internal file path (e.g., \"docs/SLA.pdf\")\n- Refinement element name (e.g., \"Performance Constraint\")\n\n## Important Notes\n\n- **Duplicate detection**: The link command fails with an error if the relation or attachment already exists\n- **Cross-section duplicates**: Cannot add a relation to a target that already exists as an attachment (and vice versa) - this is a validation error\n- **Element names**: Use the exact element name as it appears in the heading\n- **Cross-file links**: Relative paths are calculated automatically\n- **Inverse relations**: Reqvire auto-generates inverse relations (e.g., derive from derivedFrom)\n- **Attachments**: Only Refinement elements (constraint, behavior, specification) can be attached\n\n## Link Options\n\n- `<source>`: Name of source element (required)\n- `<relation-type-or-attaching>`: Relation type OR 'attaching' keyword (required)\n- `<target>`: Element name, file path, or URL (required)\n- `--dry-run`: Preview changes without applying\n\n## Error Cases\n\nThe link operation will fail with a clear error if:\n- The source element does not exist\n- The target element does not exist (for element relations)\n- The relation type is invalid\n- For attaching: the target element is not a Refinement type\n- For attaching: the refinement has no `satisfy` relations (must satisfy a requirement first)\n- For attaching: source and refinement's owner are in the same derivation hierarchy\n- The relation or attachment already exists (duplicate)\n- The target already exists in the other section (cross-section duplicate)\n\n## Examples\n\n**Link requirement to parent:**\n```bash\nreqvire link \"Feature Requirement\" derivedFrom \"User Story\"\n```\n\n**Link requirement to implementation file:**\n```bash\nreqvire link \"Authentication Requirement\" satisfiedBy \"src/auth/login.rs\"\n```\n\n**Link to external URL:**\n```bash\nreqvire link \"Compliance Requirement\" trace \"https://example.com/regulations.html\"\n```\n\n**Attach a document:**\n```bash\nreqvire link \"System Requirement\" attaching \"docs/SLA.pdf\"\n```\n\n**Attach a refinement element:**\n```bash\nreqvire link \"System Requirement\" attaching \"Performance Constraint\"\n```\n\n**Preview before linking:**\n```bash\nreqvire link \"Feature X\" trace \"Feature Y\" --dry-run\n```\n\n## When to Use link\n\nUse link when:\n- Establishing traceability between requirements\n- Connecting requirements to verifications\n- Creating derivation hierarchies\n- Adding trace relations for impact analysis\n- Linking to implementation files\n- Attaching documents or reference materials\n- Attaching refinement elements (constraints, behaviors, specifications)\n\n## Related Commands\n\n- **Unlink**: `reqvire unlink <source> <target>` (auto-detects relation vs attachment)\n- **Search relations**: `reqvire search --have-relations=\"derivedFrom\"`\n- **Search attachments**: `reqvire search --has-attachments`\n",
        "claude-plugins/commands/lint-model.md": "---\nallowed-tools: Read, Bash(reqvire:*)\ndescription: Lint and clean up the Reqvire model by fixing issues and identifying items needing review\nmodel: claude-sonnet-4-5\n---\n\n# Lint Model\n\nLint the Reqvire model to fix quality issues and identify items needing manual review.\n\n## Current Lint Status\n\n- Auto-fixable: !`reqvire lint --json 2>&1 | jq -r '\"\\(if .auto_fixable then (.auto_fixable | length) else 0 end) issues\"'`\n- Manual review: !`reqvire lint --json 2>&1 | jq -r '\"\\(if .needs_manual_review then (.needs_manual_review | length) else 0 end) items\"'`\n\n## Steps\n\n1. **Apply auto-fixes immediately:**\n   ```bash\n   reqvire lint --fix\n   ```\n\n   This automatically fixes:\n   - Syntax and formatting issues\n   - Redundant verify relations (verification verifying both leaf and parent)\n   - Safe redundant hierarchical relations (single-chain derivedFrom paths)\n\n2. **Check for manual review items:**\n   ```bash\n   reqvire lint --json > /tmp/lint.json\n   jq '.needs_manual_review' /tmp/lint.json\n   ```\n\n3. **For manual review items:**\n\n   Read affected specifications:\n   ```bash\n   reqvire search --filter-id=\"<element-id>\"\n   ```\n\n   Provide recommendations:\n   - Show the potentially redundant relation\n   - Explain why it may be redundant\n   - Ask user if they want to remove it\n\n4. **Validate after changes:**\n   ```bash\n   reqvire validate\n   ```\n\n## Lint Categories\n\n### Auto-Fixable (always safe to apply)\n\n- **Redundant verify relations**: Verification verifies both leaf and parent requirement\n- **Safe redundant hierarchical relations**: Single-chain derivedFrom paths that can be safely removed\n\n### Needs Review (requires judgment)\n\n- **Multi-branch convergence**: Element reaches ancestor through multiple distinct paths\n- **Complex hierarchical relations**: Multi-path derivedFrom relations requiring human judgment\n\n## Best Practices\n\n- Run `reqvire lint --fix` after adding features\n- Review manual items carefully before removing\n- Validate model after manual changes\n- Use after `/reqvire:add-feature` or `/reqvire:add-verification` to clean up\n\n## Notes\n\n- Auto-fixes are always safe - just apply them\n- Manual review items need human judgment and context\n- Run lint regularly to maintain model quality\n",
        "claude-plugins/commands/mv-file.md": "---\nallowed-tools: Read, Bash(reqvire:*)\nargument-hint: [source-file] [target-file]\ndescription: Move entire specification file with all its elements to a new location\nmodel: claude-sonnet-4-5\n---\n\n# Move File\n\nMove an entire specification file with all its elements to a new location, automatically updating all relations that reference elements in the moved file.\n\n## Current Model Context\n\n- Total elements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n\n## User Request\n\n${1:+Source file: $1}\n${2:+Target file: $2}\n${1:-The user will provide source and target file paths.}\n\n## Steps\n\n1. **Understand the context:**\n   - Identify the source file to move\n   - Determine the target file location\n   - Verify source file exists in the model\n\n2. **Preview the move operation:**\n   ```bash\n   reqvire mv-file \"<source-file>\" \"<target-file>\" --dry-run\n   ```\n\n   This shows:\n   - Which files will be modified\n   - How many elements will be moved\n   - What relations will be updated\n   - Git-style diffs for all affected files\n\n3. **Apply the file move:**\n   ```bash\n   reqvire mv-file \"<source-file>\" \"<target-file>\"\n   ```\n\n   The mv-file command automatically:\n   - Moves all elements from source file to target file\n   - Updates all element identifiers to reflect new file path\n   - Updates all incoming relations (from other files) to reference new location\n   - Preserves all element content, metadata, and outgoing relations\n   - Deletes the source file after successful move\n   - Creates the target file with all moved elements\n\n4. **Verify the changes:**\n   ```bash\n   reqvire validate\n   ```\n\n## Important Notes\n\n- **Path resolution**: File paths are resolved relative to current working directory\n- **Automatic relation updates**: All relations pointing to moved elements are automatically updated throughout the model\n- **Identifier updates**: Element identifiers change from `<source-file>#<slug>` to `<target-file>#<slug>`\n- **Subdirectory support**: Works correctly when executed from subdirectories within git repository\n- **Atomic operation**: Either all elements move successfully or none move (on validation failure)\n\n## Squash Mode\n\nWhen the target file already exists, use the **`--squash`** flag to merge all elements from source into the target file:\n\n```bash\nreqvire mv-file \"<source-file>\" \"<existing-target-file>\" --squash\n```\n\n**Squash behavior:**\n- All source elements are appended to target file\n- Target file's existing elements remain unchanged\n- Source file is deleted after successful move\n- All relations are updated throughout the model\n\n**When to use --squash:**\n- Consolidating multiple specification files into one\n- Merging temporary/experimental specs back into main file\n- Reorganizing model structure by combining related files\n\n## Error Cases\n\nThe mv-file operation will fail with a clear error if:\n- The source file does not exist or contains no elements\n- The target file already exists in the model (unless --squash flag is provided)\n- The operation would result in invalid model state\n\n## Examples\n\n**Move file within specifications directory:**\n```bash\nreqvire mv-file \"requirements/OldFile.md\" \"requirements/NewFile.md\"\n```\n\n**Move file to different directory:**\n```bash\nreqvire mv-file \"requirements/Auth.md\" \"security/Authentication.md\"\n```\n\n**Preview before moving:**\n```bash\nreqvire mv-file \"specs/File.md\" \"requirements/File.md\" --dry-run\n```\n\n**Get JSON output with element mappings:**\n```bash\nreqvire mv-file \"old/path.md\" \"new/path.md\" --json\n```\n\n**Works from subdirectories (paths relative to current directory):**\n```bash\ncd submodule/\nreqvire mv-file \"specs/File.md\" \"requirements/File.md\"\n```\n\n**Squash elements from multiple files:**\n```bash\n# Merge experimental specs into main requirements\nreqvire mv-file \"temp/Experiments.md\" \"requirements/Requirements.md\" --squash\n```\n\n**Preview squash before applying:**\n```bash\nreqvire mv-file \"old/File.md\" \"requirements/MainFile.md\" --squash --dry-run\n```\n\n## When to Use mv-file\n\nUse mv-file when:\n- Reorganizing specification file structure\n- Moving all requirements for a feature to a different location\n- Consolidating or splitting specification files\n- Refactoring the model directory structure\n\nUse mv-file with --squash when:\n- Merging multiple specification files into one\n- Consolidating temporary or experimental requirements back into main specs\n- Simplifying model structure by reducing file count\n\n**Note**: mv-file moves entire files with all their elements. To move individual elements between files, use `reqvire mv` instead.\n\n## Related Commands\n\n- **Move element**: `reqvire mv <element-name> <target-file>`\n- **Rename element**: `reqvire rename <current-name> <new-name>`\n- **Remove element**: `reqvire rm <element-name>`\n- **Add element**: `reqvire add <file> < element.md`\n",
        "claude-plugins/commands/mv.md": "---\nallowed-tools: Read, Bash(reqvire:*)\nargument-hint: <element-name> <file> [index]\ndescription: Move an element to a different file or position\nmodel: claude-sonnet-4-5\n---\n\n# Move Element\n\nMove an existing model element to a different file or position within the model.\n\n## Current Model Context\n\n- Total elements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n\n## User Request\n\n${1:+Element name: $1}\n${1:-The user will provide element name and target location.}\n\n## Steps\n\n1. **Understand the context:**\n   - Identify the element to move (by name)\n   - Determine the target location (file and/or index)\n   - Verify element exists in the model\n\n2. **Preview the move operation:**\n   ```bash\n   reqvire mv \"<element-name>\" \"<target-file>\" --dry-run\n   ```\n\n   This shows:\n   - Which files will be modified\n   - Where the element will be moved\n   - What relations will be updated\n   - Git-style diffs for all affected files\n\n3. **Apply the move:**\n   ```bash\n   reqvire mv \"<element-name>\" \"<target-file>\"\n   ```\n\n   The mv command automatically:\n   - Removes element from source file\n   - Adds element to target file\n   - Updates the element identifier to reflect new location\n   - Updates all forward relations (from the element to others)\n   - Updates all backward relations (from other elements to this one)\n   - Maintains model consistency\n\n4. **Verify the changes:**\n   ```bash\n   reqvire validate\n   ```\n\n## Important Notes\n\n- **Global uniqueness**: Element names are globally unique, so you only need the element name\n- **Path resolution**: File paths are resolved relative to current working directory\n- **Automatic relation updates**: All relations throughout the model are automatically updated\n- **Identifier update**: Element identifier changes from `<old-file>#<slug>` to `<new-file>#<slug>`\n\n## Move Options\n\n- `<element-name>`: Name of element to move (required)\n- `<file>`: Target file path (required)\n- `[index]`: Position within target file (0-based, default: append to end)\n- `--dry-run`: Preview changes without applying\n- `--json`: Output results in JSON format\n\n## Error Cases\n\nThe mv operation will fail with a clear error if:\n- The element name does not exist\n- The target file does not exist (must exist in git)\n- The operation would result in invalid model state\n\n## Examples\n\n**Move element to different file:**\n```bash\nreqvire mv \"User Authentication\" \"requirements/Security.md\"\n```\n\n**Insert at specific position (index 0 = first element in file):**\n```bash\nreqvire mv \"High Priority Req\" \"requirements/Critical.md\" 0\n```\n\n**Preview before moving:**\n```bash\nreqvire mv \"Feature X\" \"NewFile.md\" --dry-run\n```\n\n**Get JSON output:**\n```bash\nreqvire mv \"Element\" \"File.md\" --json\n```\n\n## When to Use mv\n\nUse mv when:\n- Moving individual requirements or verifications between files\n- Reorganizing elements within specification structure\n- Reordering elements within files\n\n**Note**: To move entire files with all their elements, use `reqvire mv-file` instead.\n\n## Related Commands\n\n- **Move file**: `reqvire mv-file <source-file> <target-file>`\n- **Rename element**: `reqvire rename <current-name> <new-name>`\n- **Remove element**: `reqvire rm <element-name>`\n- **Add element**: `reqvire add <file> < element.md`\n",
        "claude-plugins/commands/rename-element.md": "---\nallowed-tools: Read, Bash(reqvire:*)\nargument-hint: [current-name] [new-name]\ndescription: Rename an existing element while updating all relations that reference it\nmodel: claude-sonnet-4-5\n---\n\n# Rename Element\n\nRename an existing model element while automatically updating all relation references throughout the model.\n\n## Current Model Context\n\n- Total elements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n\n## User Request\n\n${1:+Current element name: $1}\n${2:+New element name: $2}\n${1:-The user will provide element names.}\n\n## Steps\n\n1. **Understand the context:**\n   - Identify the element to rename (current name)\n   - Determine the new name\n   - Verify element exists in the model\n\n2. **Preview the rename operation:**\n   ```bash\n   reqvire rename \"<current-name>\" \"<new-name>\" --dry-run\n   ```\n\n   This shows:\n   - Which files will be modified\n   - What relations will be updated\n   - The identifier change (old → new)\n\n3. **Apply the rename:**\n   ```bash\n   reqvire rename \"<current-name>\" \"<new-name>\"\n   ```\n\n   The rename command automatically:\n   - Updates the element's heading text in the markdown file\n   - Updates the element identifier in the registry\n   - Updates all forward relations (from the element to others)\n   - Updates all backward relations (from other elements to this one)\n   - Maintains model consistency\n\n4. **Verify the changes:**\n   ```bash\n   reqvire validate\n   ```\n\n## Important Notes\n\n- **Global uniqueness**: Element names are globally unique in Reqvire, so you only need the element name (not the full file path identifier)\n- **Automatic relation updates**: All relations throughout the model are automatically updated\n- **Identifier format**: The element identifier changes from `<file>#<old-name-slug>` to `<file>#<new-name-slug>`\n- **Name slugification**: Element names are converted to slugs (lowercase, spaces → hyphens) for identifiers\n\n## Error Cases\n\nThe rename operation will fail with a clear error if:\n- The current element name does not exist\n- The new name conflicts with an existing element\n- Multiple elements have the same name (should not happen due to uniqueness constraint)\n\n## Examples\n\n**Rename a requirement:**\n```bash\nreqvire rename \"User Authentication\" \"User Login Authentication\"\n```\n\n**Preview before renaming:**\n```bash\nreqvire rename \"Data Storage\" \"Persistent Data Storage\" --dry-run\n```\n\n**Get JSON output:**\n```bash\nreqvire rename \"Old Feature\" \"New Feature\" --json\n```\n\n## When to Use Rename\n\nUse rename when:\n- A requirement or verification needs a better name\n- Terminology changes in the project\n- Consolidating or clarifying element names\n- Refactoring the model structure\n\n**Note**: Rename only changes the element name and heading. To move an element to a different file, use `reqvire mv` instead.\n\n## Related Commands\n\n- **Move element**: `reqvire mv <element-name> <target-file>`\n- **Remove element**: `reqvire rm <element-name>`\n- **Add element**: `reqvire add <file> < element.md`\n",
        "claude-plugins/commands/rm.md": "---\nallowed-tools: Read, Bash(reqvire:*)\nargument-hint: [element-name]\ndescription: Remove an element from the model\nmodel: claude-sonnet-4-5\n---\n\n# Remove Element\n\nRemove an existing model element from the specifications.\n\n## Current Model Context\n\n- Total elements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n\n## User Request\n\n${1:+Element name: $1}\n${1:-The user will provide element name to remove.}\n\n## Steps\n\n1. **Understand the context:**\n   - Identify the element to remove (by name)\n   - Verify element exists in the model\n   - Check if other elements have relations to this element\n\n2. **Preview the remove operation:**\n   ```bash\n   reqvire rm \"<element-name>\" --dry-run\n   ```\n\n   This shows:\n   - Which file will be modified\n   - The element that will be removed\n   - Git-style diff showing the deletion\n\n3. **Apply the removal:**\n   ```bash\n   reqvire rm \"<element-name>\"\n   ```\n\n   The rm command automatically:\n   - Removes the element from its markdown file\n   - Removes the element from the model registry\n   - Deletes all relations from this element\n   - **Note**: Does NOT automatically update relations FROM other elements TO this element (you may need to clean those up)\n\n4. **Verify the changes:**\n   ```bash\n   reqvire validate\n   ```\n\n   **Important**: After removing an element, validation may show errors if other elements still reference the removed element. You'll need to manually update or remove those relations.\n\n## Important Notes\n\n- **Global uniqueness**: Element names are globally unique, so you only need the element name\n- **Relations cleanup**: The removed element's outgoing relations are deleted, but incoming relations (from other elements) are NOT automatically removed\n- **Validation warnings**: Removing elements that are referenced by others will cause validation errors\n- **Breaking changes**: Removing requirements or verifications can break traceability chains\n\n## Remove Options\n\n- `--dry-run`: Preview changes without applying\n- `--json`: Output results in JSON format\n\n## Error Cases\n\nThe rm operation will fail with a clear error if:\n- The element name does not exist\n- Multiple elements have the same name (should not happen due to uniqueness constraint)\n\n## Examples\n\n**Remove a requirement:**\n```bash\nreqvire rm \"Deprecated Feature\"\n```\n\n**Preview before removing:**\n```bash\nreqvire rm \"Old Requirement\" --dry-run\n```\n\n**Get JSON output:**\n```bash\nreqvire rm \"Obsolete Element\" --json\n```\n\n## When to Use rm\n\nUse rm when:\n- Removing deprecated or obsolete requirements\n- Cleaning up test elements\n- Removing duplicate or incorrect entries\n- Refactoring the model structure\n\n**Warning**: Be careful when removing elements that are referenced by other elements, as this will break those relations and cause validation errors.\n\n## Cleanup After Removal\n\nAfter removing an element, you may need to:\n1. Find elements that referenced the removed element (validation will show these)\n2. Update or remove those relations manually\n3. Re-run validation to ensure model consistency\n\n## Related Commands\n\n- **Move element**: `reqvire mv <element-name> <target-file>`\n- **Rename element**: `reqvire rename <current-name> <new-name>`\n- **Add element**: `reqvire add <file> < element.md`\n- **Search elements**: `reqvire search --filter-name=\"<pattern>\"`\n",
        "claude-plugins/commands/setup.md": "---\nallowed-tools: Read, Bash, Write, Edit, AskUserQuestion\nargument-hint: [install]\ndescription: Setup reqvire environment (includes plugin self-update)\nmodel: claude-sonnet-4-5\n---\n\n## Setup Steps\n\n1. Update plugin to latest version\n2. Install/update reqvire CLI binary\n3. Ask user permission to update CLAUDE.md with reqvire instructions\n\n### Step 1: Update Plugin\n\nFirst, update the Reqvire plugin itself to ensure you have the latest commands and features.\n\n**Detect OS and plugin path:**\n- **Linux/macOS**: `$HOME/.claude/plugins/marketplaces/reqvire-org-marketplace`\n- **Windows**: `$USERPROFILE\\.claude\\plugins\\marketplaces\\reqvire-org-marketplace`\n\n**Update plugin from GitHub:**\n\n#### Linux/macOS\n```bash\nPLUGIN_DIR=\"$HOME/.claude/plugins/marketplaces/reqvire-org-marketplace\"\ncd \"$PLUGIN_DIR\" && git fetch origin && git reset --hard origin/main\n```\n\n#### Windows (PowerShell)\n```powershell\n$PLUGIN_DIR = \"$env:USERPROFILE\\.claude\\plugins\\marketplaces\\reqvire-org-marketplace\"\nSet-Location $PLUGIN_DIR\ngit fetch origin\ngit reset --hard origin/main\n```\n\nAfter updating, show the user what version they now have:\n```bash\ncd \"$PLUGIN_DIR\" && git log --oneline -1\n```\n\n**Note**: User may need to restart Claude Code after plugin update for changes to take effect.\n\n### Step 2: Installing reqvire CLI\n\nDetect the operating system and install reqvire accordingly:\n\n1. First check the platform (look at the `<env>` context for \"Platform:\" info)\n2. Run the appropriate installation commands for that platform\n\n#### Linux x86_64\n```bash\nmkdir -p ~/.local/bin\ncurl -fsSL -o /tmp/reqvire.tar.gz https://github.com/Reqvire/reqvire/releases/download/v0.9.0/reqvire-linux-x86_64.tar.gz\ntar -xzf /tmp/reqvire.tar.gz -C ~/.local/bin\nmv ~/.local/bin/reqvire-linux-x86_64 ~/.local/bin/reqvire\nchmod +x ~/.local/bin/reqvire\n```\n\n#### Mac Silicon (ARM64)\n```bash\nmkdir -p ~/.local/bin\ncurl -fsSL -o /tmp/reqvire.tar.gz https://github.com/Reqvire/reqvire/releases/download/v0.9.0/reqvire-darwin-aarch64.tar.gz\ntar -xzf /tmp/reqvire.tar.gz -C ~/.local/bin\nmv ~/.local/bin/reqvire-darwin-aarch64 ~/.local/bin/reqvire\nchmod +x ~/.local/bin/reqvire\n```\n\n#### Mac Intel (x86_64)\n```bash\nmkdir -p ~/.local/bin\ncurl -fsSL -o /tmp/reqvire.tar.gz https://github.com/Reqvire/reqvire/releases/download/v0.9.0/reqvire-darwin-x86_64.tar.gz\ntar -xzf /tmp/reqvire.tar.gz -C ~/.local/bin\nmv ~/.local/bin/reqvire-darwin-x86_64 ~/.local/bin/reqvire\nchmod +x ~/.local/bin/reqvire\n```\n\n#### Windows (PowerShell)\n```powershell\nNew-Item -ItemType Directory -Force -Path \"$env:USERPROFILE\\.local\\bin\"\nInvoke-WebRequest -Uri \"https://github.com/Reqvire/reqvire/releases/download/v0.9.0/reqvire-windows-x86_64.zip\" -OutFile \"$env:TEMP\\reqvire.zip\"\nExpand-Archive -Path \"$env:TEMP\\reqvire.zip\" -DestinationPath \"$env:USERPROFILE\\.local\\bin\" -Force\nRename-Item \"$env:USERPROFILE\\.local\\bin\\reqvire-windows-x86_64.exe\" \"reqvire.exe\"\n```\n\n### Step 3: Update CLAUDE.md (Ask Permission First)\n\n**IMPORTANT**: Before modifying CLAUDE.md, you MUST ask the user for permission using AskUserQuestion.\n\nAsk: \"Would you like me to add Reqvire instructions to your repository's CLAUDE.md file? This will guide Claude to use the syseng skill and /reqvire:* commands for all requirements and model work.\"\n\nIf the user approves, add the following content to the repository's CLAUDE.md file:\n\n#### Content to add at the TOP of CLAUDE.md (after any existing header):\n\n```markdown\n## CRITICAL: Requirements & Specifications & System Model Work\n\n**FOR ANY CONVERSATION, WORK, REQUEST, OR TASK RELATED TO:**\n- Requirements (user requirements, system requirements)\n- Specifications\n- System model (MBSE model)\n- Verifications\n- Architecture decisions\n- Model refactoring or analysis\n\n**YOU MUST:**\n1. **Use the `syseng` skill** for all requirements and model work\n2. **Use `/reqvire:*` commands** from the reqvire plugin for model operations\n3. **NEVER manually edit** requirements files without using reqvire commands unless reqvire tool is not able to cover the need.\n4. **ALWAYS validate** the model after changes with `reqvire validate`\n```\n\n#### Content to add at the BOTTOM of CLAUDE.md:\n\n```markdown\n---\n\n**Remember**: For ANY work involving requirements, specifications, or the system model, **ALWAYS use the `syseng` skill and `/reqvire:*` commands**. Manual editing of requirements files will break model integrity!\n```\n\n#### Implementation Notes:\n- If CLAUDE.md doesn't exist, create it with these sections\n- If CLAUDE.md exists, read it first, then add the top section after the first heading (or at the top if no heading), and append the bottom section at the end\n- Do not duplicate content if it already exists\n\n",
        "claude-plugins/commands/unlink.md": "---\nallowed-tools: Read, Bash(reqvire:*)\nargument-hint: <source> <target>\ndescription: Remove a relation or attachment (auto-detects type)\nmodel: claude-sonnet-4-5\n---\n\n# Unlink Elements\n\nRemove an existing relation or attachment between elements. The command auto-detects whether the target is a relation or attachment.\n\n## Current Model Context\n\n- Total elements: !`reqvire search --json | jq -r '.global_counters.total_elements'`\n\n## User Request\n\n${1:+Source element: $1}\n${2:+Target: $2}\n${1:-The user will provide source element and target.}\n\n## Steps\n\n1. **Understand the context:**\n   - Identify the source element (by name)\n   - Identify the target (element name or file path)\n   - The command will auto-detect if it's a relation or attachment\n\n2. **Preview the unlink operation:**\n   ```bash\n   reqvire unlink \"<source-element>\" \"<target>\" --dry-run\n   ```\n\n   This shows:\n   - Which file will be modified\n   - The relation/attachment that will be removed\n   - Git-style diff for the affected file\n\n3. **Apply the unlink:**\n   ```bash\n   reqvire unlink \"<source-element>\" \"<target>\"\n   ```\n\n   The unlink command automatically:\n   - Searches relations first, then attachments\n   - Removes the relation/attachment from the source element\n   - Cleans up empty sections automatically\n   - Maintains model consistency\n\n4. **Verify the changes:**\n   ```bash\n   reqvire validate\n   ```\n\n## Auto-Detection Behavior\n\nThe unlink command auto-detects the type:\n1. **First**: Searches for a relation from source to target element\n2. **Then**: If no relation found, searches for an attachment matching the target\n3. Only one relation per source-target pair is allowed, so no ambiguity\n\n## Important Notes\n\n- **Auto-detection**: No need to specify relation type - the command finds it automatically\n- **Explicit relations only**: Only removes user-created relations (not auto-generated inverse relations)\n- **Element names**: Use the exact element name as it appears in the heading\n- **Cleanup**: Empty Relations/Attachments sections are removed automatically\n- **Validation**: Consider model validity after unlinking (orphaned elements may cause validation errors)\n\n## Unlink Options\n\n- `<source>`: Name of source element (required)\n- `<target>`: Element name or file path (required)\n- `--dry-run`: Preview changes without applying\n\n## Error Cases\n\nThe unlink operation will fail with a clear error if:\n- The source element does not exist\n- No relation or attachment found from source to target\n\n## Examples\n\n**Remove a relation (auto-detected):**\n```bash\nreqvire unlink \"Feature Requirement\" \"User Story\"\n```\n\n**Remove an attachment file:**\n```bash\nreqvire unlink \"System Requirement\" \"docs/SLA.pdf\"\n```\n\n**Remove an attached element:**\n```bash\nreqvire unlink \"System Requirement\" \"Performance Constraint\"\n```\n\n**Preview before unlinking:**\n```bash\nreqvire unlink \"Feature X\" \"Feature Y\" --dry-run\n```\n\n## When to Use unlink\n\nUse unlink when:\n- Removing incorrect traceability links\n- Refactoring requirement hierarchies\n- Disconnecting deprecated verifications\n- Cleaning up obsolete trace relations\n- Detaching documents or files\n- Removing attached refinement elements\n\n## Related Commands\n\n- **Link elements**: `reqvire link <source> <relation-type-or-attaching> <target>`\n- **Search relations**: `reqvire search --have-relations=\"derivedFrom\"`\n- **Search attachments**: `reqvire search --has-attachments`\n",
        "claude-plugins/skills/syseng/SKILL.md": "---\nname: System Engineer\ndescription: Expert MBSE and requirements engineer. Use when (1) exploring models and finding requirements, (2) adding features with proper MBSE traceability, (3) refactoring cluttered models and extracting specifications, (4) generating implementation tasks from requirement changes. Orchestrates reqvire commands and provides systems engineering guidance.\n---\n\n# System and Requirements Engineer Skill\n\nYou are an expert System and Requirements Engineer specializing in Model-Based Systems Engineering (MBSE) using Reqvire framework.\n\n## Your Role\n\nYou orchestrate Reqvire commands and provide expert guidance on systems engineering workflows. You help users navigate the MBSE methodology and manage requirements models and specifications.\n\n## Environment setup\n\nCRITICAL: Run `/reqvire:setup` to ensure both the plugin and reqvire CLI are up to date.\n\nTo check if reqvire CLI is installed: `reqvire --version`\n* If not installed, use `/reqvire:setup` to install it\n* If installed, compare version with latest on GitHub and ask user before updating (breaking changes possible)\n\nCRITICAL PATH REQUIREMENT:\n- If reqvire was already in PATH: use `reqvire` directly\n- If you just installed reqvire via `/reqvire:setup`: you MUST use `~/.local/bin/reqvire` (Linux/Mac) or `$env:USERPROFILE\\.local\\bin\\reqvire.exe` (Windows) for ALL commands in this session.\n\n## Element Types\n\n### Requirements\n\n**User Requirements** (`type: user-requirement`) - Stakeholder needs:\n- Business needs - Operational efficiency, cost optimization\n- Customer needs - What end users need from the system\n- Compliance needs - GDPR, security audits, regulatory\n\n**System Requirements** (`type: system-requirement`) - Technical implementation:\n- Functional, Performance, Interface, Security, Reliability, Operational\n\n### Refinements\n\n- **Specifications** (`type: specification`) - Detailed definitions that satisfy requirements\n- **Constraints** (`type: constraint`) - Limits and boundaries on system behavior\n- **Behaviors** (`type: behavior`) - How the system behaves in specific conditions\n\n### Verification\n\n- **Verifications** - Typed by verification method:\n  - `test-verification` - Automated or manual testing (can have satisfiedBy to test code)\n  - `analysis-verification` - Review, calculation, simulation\n  - `inspection-verification` - Visual examination, audit\n  - `demonstration-verification` - Showing capability works\n\n## Relation Types\n\n**`satisfiedBy`** - Requirement is fulfilled by:\n- Specification elements - Detailed definitions in the model\n- Design documents - DD.md files with architectural details\n- Code implementations - Source code that implements the requirement\n\n**`verifiedBy`** - Requirement is verified by verification elements:\n- `test` - Verification by testing (can have satisfiedBy to test code)\n- `analysis` - Verification by analysis/review\n- `inspection` - Verification by inspection\n- `demonstration` - Verification by demonstration\n\n**`derivedFrom`** - Traceability to parent requirements:\n- System requirement derives from user requirement\n- Detailed requirement derives from high-level requirement\n\n**`Attachments`** - Requirement *references* or *depends on* existing refinements:\n- Refinements must have `satisfy` relations first (establishing an owner requirement)\n- Only requirements OUTSIDE the owner's derivation hierarchy can attach it\n- NOT for defining the refinement (owner uses satisfiedBy, refinement uses satisfy)\n\n### MBSE Traceability Flow\n\n```\nUser Requirement (Stakeholder Need)\n    ↓ derive\nSystem Requirement (Technical Implementation)\n    ↓ satisfiedBy                    ↓ verifiedBy\nImplementation                       Verification Element\n(Specification/Design/Code)              ↓ satisfiedBy (for test type)\n                                     Test Code Implementation\n```\n\n## Document Structure\n\n**File Header**:\n- All specification files must begin with `# Elements` as the first level-1 heading\n- Files without this header can be used as attachment documents\n\n**Elements** (`###` headers):\n- Must have unique names within each file\n- Element names become URL fragments (lowercase, hyphens)\n\n**Reserved Subsections** (`####`):\n- **Metadata**: Element type and custom properties\n- **Relations**: Relationships between elements\n- **Details**: Additional details (use for EARS statements)\n- **Attachments**: References to files or Refinement elements (NOT for Refinement types)\n\n**Other Subsections** (`####`):\n- Any non-reserved subsection becomes part of element content\n- Use `#### Specifications` or `#### Behaviors` for inline definitions that don't need separate elements (i.e., not referenced by other requirements)\n\n**Attachments syntax** (two-space indentation):\n```markdown\n#### Attachments\n  * [Drop Down Constraints](path.md#drop-down-constraints)\n  * [Design Documents](../relative/path/to/DesignDocument.md)\n```\n\n**Relations syntax** (two-space indentation):\n```markdown\n#### Relations\n  * derivedFrom: [Parent](path.md#parent)\n  * verifiedBy: [Verification](path.md#verification)\n  * satisfiedBy: path/to/implementation\n  * satisfy: [Requirement](path.md#requirement)\n```\n\n## EARS Patterns\n\nUse for requirement statements:\n- **Ubiquitous**: \"The system shall [capability]\"\n- **Event-driven**: \"When [trigger] the system shall [response]\"\n- **State-driven**: \"While [state] the system shall [capability]\"\n- **Unwanted**: \"If [condition] then the system shall [response]\"\n- **Optional**: \"Where [feature] the system shall [capability]\"\n\nRequirement element mostly should only contain EARS statements: one in main body and other in '#### Details'. All specifications and constraints must go into refinement elements.\nRefinements must `satisfy` their owner requirement (owner gets auto-generated `satisfiedBy`). Other requirements can attach refinements only if they're outside the owner's derivation hierarchy.\n\n## Important Notes\n\n1. Always run commands from the git root folder\n2. Use full paths starting with `requirements/`: if not available (has other content) ask for new main specification folder name\n3. Never guess - read files before making changes\n4. Validate after each significant change\n5. When reading requirements, always check for **attachments** (documents, diagrams, images)\n6. Use `reqvire collect` to gather full context from requirement chains (ancestors + attachments)\n\nUse `reqvire collect` to gather complete context for a requirement:\n\n```bash\n# Get full requirement chain with all ancestor content and attachments\nreqvire collect \"Feature Requirement\"\n\n# JSON format for programmatic use\nreqvire collect \"Feature Requirement\" --json\n```\n\n**When to use collect:**\n- Before implementing a requirement - get full specification context\n- When analyzing impact of changes - understand complete requirement chain\n- When creating tasks from requirements - gather all related specifications\n- When reviewing requirements - see full derivation hierarchy with sources\n\nThe collect command traverses `derivedFrom` relations upward and includes:\n- All ancestor requirement content\n- Attached markdown files (read as content)\n- Attached refinement elements (specifications, constraints, behaviors)\n- Source citations for traceability\n\n## Command Reference\n\nThis section consolidates the most common reqvire commands. For detailed options and advanced usage, see reference files.\n\n### Search & Explore\n\n```bash\n# Quick model summary\nreqvire search --short --json | jq '.summary'\n\n# Find elements by type\nreqvire search --filter-type=\"requirement\" --short\nreqvire search --filter-type=\"user-requirement,system-requirement\" --short\n\n# Find elements by name pattern\nreqvire search --filter-name=\".*Auth.*\" --short\n\n# Find elements by relations\nreqvire search --not-have-relations=\"verifiedBy\" --short\nreqvire search --have-relations=\"satisfiedBy,verifiedBy\" --short\n\n# Model-centric view\nreqvire model                    # Show all root requirements\nreqvire model --from \"Element\"   # Start from specific element\nreqvire model --reverse          # Trace from verifications upward\n```\n\n### Context Gathering\n\n```bash\n# Collect full requirement chain with ancestors and attachments\nreqvire collect \"Requirement Name\"\nreqvire collect \"Requirement Name\" --json\n```\n\n### Manipulation\n\n```bash\n# Link elements\nreqvire link \"Source\" \"derivedFrom\" \"Target\"\nreqvire link \"Source\" \"verifiedBy\" \"Verification\"\nreqvire link \"Source\" attaching \"file.pdf\"\nreqvire link \"Source\" attaching \"Specification Element\"\n\n# Unlink elements\nreqvire unlink \"Source\" \"Target\"\n\n# Move elements\nreqvire mv \"Element\" \"target.md\"\nreqvire mv \"Element\" \"target.md\" 0  # Move to specific position\n\n# Move entire files\nreqvire mv-file \"source.md\" \"target.md\"\nreqvire mv-file \"source.md\" \"target.md\" --squash  # Merge into existing file\n\n# Merge duplicate elements\nreqvire merge \"Primary\" \"Duplicate\"\nreqvire merge \"Primary\" \"Dup1\" \"Dup2\"  # Merge multiple\n\n# Remove elements\nreqvire rm \"Element Name\"\n\n# Rename elements\nreqvire rename-element \"Old Name\" \"New Name\"\n```\n\n### Quality & Validation\n\n```bash\n# Validate model structure\nreqvire validate\nreqvire validate --json\n\n# Lint and fix issues\nreqvire lint                  # Show all issues\nreqvire lint --fixable        # Show auto-fixable issues\nreqvire lint --auditable      # Show manual review items\nreqvire lint --fix            # Apply automatic fixes\n\n# Check verification coverage\nreqvire coverage\nreqvire coverage --json\n\n# Format specification files\nreqvire format                # Preview formatting changes\nreqvire format --fix          # Apply formatting\n```\n\n### Change Analysis\n\n```bash\n# Analyze impact of changes\nreqvire change-impact --git-commit=<hash>\nreqvire change-impact --git-commit=HEAD~1 --json\n\n# Verification traces\nreqvire traces\nreqvire traces --filter-name=\".*Feature.*\"\nreqvire traces --json\n```\n## Command Usage Patterns\n\n### Dry-Run Mode\n\nMost manipulation commands support `--dry-run` to preview changes before applying them:\n\n```bash\n# Preview element removal\nreqvire rm \"Element Name\" --dry-run\n\n# Preview element move\nreqvire mv \"Element\" \"target.md\" --dry-run\n\n# Preview file move\nreqvire mv-file \"source.md\" \"target.md\" --dry-run\n\n# Preview merge operation\nreqvire merge \"Target\" \"Source\" --dry-run\n\n# Preview link creation\nreqvire link \"Element\" \"derivedFrom\" \"Parent\" --dry-run\nreqvire link \"Element\" attaching \"docs/spec.pdf\" --dry-run\n\n# Preview unlink operation\nreqvire unlink \"Element\" \"Parent\" --dry-run\n```\n\n**Best practice**: Always use `--dry-run` for destructive operations (rm, merge, mv-file) to verify changes before execution.\n\n### Common Command Flags\n\n- `--json`: Output in JSON format for programmatic processing\n- `--short`: Show minimal output (element names only, no content)\n- `--dry-run`: Preview changes without applying them\n\n### Using stdin with Heredocs\n\nWhen adding elements, use heredocs for clean multi-line input:\n\n```bash\nreqvire add requirements/File.md <<'EOF'\n### Element Name\n\nElement content here.\n\n#### Metadata\n  * type: requirement\nEOF\n```\n\nUse single quotes (`<<'EOF'`) to prevent shell variable expansion in the content.\n\n## Asset Management\n\nManage files referenced by the model (images, PDFs, design documents):\n\n```bash\n# Move asset file and update all references in the model\nreqvire mv-asset \"docs/old-diagram.png\" \"docs/diagrams/new-diagram.png\"\n\n# Remove asset file and remove all references from the model\nreqvire rm-asset \"docs/obsolete.pdf\"\n```\n\n**When to use asset commands:**\n- Reorganizing documentation files referenced in attachments\n- Renaming images or diagrams while preserving all links\n- Cleaning up obsolete design documents\n\n**Note**: Asset commands update all attachment and satisfiedBy references automatically.\n\n## Analysis Capabilities\n\n### Change Impact Analysis\n\nAnalyze how requirement changes propagate through the model:\n\n```bash\n# Analyze changes from specific git commit\nreqvire change-impact --git-commit=<hash> [--json]\n\n# Analyze changes from last commit\nreqvire change-impact --git-commit=HEAD~1\n```\n\nThe change-impact command shows:\n- Which requirements were modified\n- Which downstream elements are affected (via derivedFrom, verifiedBy)\n- Impact scope and traceability\n\nFor detailed analysis workflows, see [Explore](reference/explore.md).\n\n## Export and Serving\n\n### HTML Export\n\nExport the model as interactive HTML documentation:\n\n```bash\n# Export to specific directory\nreqvire export --output docs/output\n\n# Export to temporary directory (prints path)\nreqvire export\n```\n\nThe HTML export includes:\n- Interactive diagrams (Mermaid with clickable nodes)\n- Full model structure with navigation\n- Verification traceability views\n- Containment view with design documents\n\n### Serve HTML\n\nLaunch a local web server to browse the model:\n\n```bash\n# Start server on default port (8000)\nreqvire serve\n\n# Start server on specific port\nreqvire serve --port 8080\n\n# Start server on specific host and port\nreqvire serve --host 0.0.0.0 --port 3000\n```\n\n**Use cases:**\n- Share model documentation with stakeholders\n- Review model structure in browser\n- Navigate traceability interactively\n- Present verification coverage\n\n## Task Routing: When to Use Reference Files\n\nUse this decision table to determine which reference file to load based on your task:\n\n| Your Task | Decision Questions | Reference to Load | Quick Commands |\n|-----------|-------------------|-------------------|----------------|\n| **Quick tasks** | - Find a specific requirement?<br>- Check model health?<br>- Simple search or validation?<br>- Link/move single element? | **No reference needed**<br>Use Command Reference above | `reqvire search`<br>`reqvire validate`<br>`reqvire link` |\n| **Explore model** | - Understanding model structure?<br>- Browsing requirements?<br>- Need to answer questions about model?<br>- Analyzing traceability? | [explore.md](reference/explore.md) | Advanced search patterns,<br>model views, coverage |\n| **Add features** | - Adding new functionality?<br>- Creating requirements hierarchy?<br>- Building from scratch?<br>- MBSE workflow needed? | [AddFeature.md](reference/AddFeature.md) | Complete workflow:<br>requirements → verifications |\n| **Refactor model** | - Model is cluttered/duplicated?<br>- Reorganizing without changing intent?<br>- Fixing relations/ownership?<br>- Converting attachments? | [ConsolidateRequirements.md](reference/ConsolidateRequirements.md) | Merge, move files,<br>fix relations |\n| **Extract specs** | - Requirements have embedded details?<br>- Need to separate EARS from specs?<br>- Making requirements reusable?<br>- Requirements too long (>15 lines)? | [SpecificationsExtractionLogic.md](reference/SpecificationsExtractionLogic.md) | Extraction methodology,<br>refactoring patterns |\n| **Generate tasks** | - Creating implementation plan?<br>- Analyzing requirement changes?<br>- Working on feature branch?<br>- Need task breakdown? | [CreatingTasks.md](reference/CreatingTasks.md) | Change-impact analysis,<br>task generation |\n\n### Quick Tasks (No Reference Needed)\n\nThese common operations can be done directly without loading reference files:\n\n**Find a specific requirement:**\n```bash\nreqvire search --filter-name=\".*Auth.*\" --short\nreqvire search --filter-type=\"user-requirement\" --short\n```\n\n**Check unverified requirements:**\n```bash\nreqvire search --filter-type=\"requirement\" --not-have-relations=\"verifiedBy\" --short\n```\n\n**Validate model:**\n```bash\nreqvire validate && reqvire coverage\n```\n\n**Link two elements:**\n```bash\nreqvire link \"Child\" \"derivedFrom\" \"Parent\"\nreqvire link \"Requirement\" \"verifiedBy\" \"Verification\"\n```\n\n**Collect requirement context:**\n```bash\nreqvire collect \"Requirement Name\"\n```\n\n**Move element:**\n```bash\nreqvire mv \"Element\" \"target-file.md\"\n```\n\n## Quick Start: Common Workflows\n\nThis section provides immediate command examples for common workflows. For comprehensive workflows, use the Task Routing table above to determine which reference file to load.\n\n### I need to find a requirement\n\n```bash\n# By name pattern\nreqvire search --filter-name=\".*Authentication.*\" --short\n\n# By type\nreqvire search --filter-type=\"user-requirement\" --short\nreqvire search --filter-type=\"system-requirement\" --short\n\n# By content\nreqvire search --filter-content=\"SHALL.*validate\" --short\n\n# By relations\nreqvire search --not-have-relations=\"verifiedBy\" --short\n```\n\n### I need to add a requirement\n\n```bash\n# Add to file (use heredoc for multi-line)\nreqvire add requirements/File.md <<'EOF'\n### Requirement Name\n\nThe system shall provide the required capability.\n\n#### Metadata\n  * type: system-requirement\n\n#### Relations\n  * derivedFrom: [Parent Requirement](path.md#parent)\nEOF\n\n# Link to parent (if not added in Relations section)\nreqvire link \"Requirement Name\" \"derivedFrom\" \"Parent Requirement\"\n```\n\nFor complete feature workflows (requirements + verifications + tests), use `/reqvire:add-feature` or load [AddFeature.md](reference/AddFeature.md).\n\n### I need to validate the model\n\n```bash\n# Standard validation workflow\nreqvire validate && reqvire lint && reqvire coverage\n\n# Detailed validation\nreqvire validate --json > /tmp/validation.json\nreqvire coverage --json > /tmp/coverage.json\n```\n\n### I need to refactor the model\n\n**Merge duplicates:**\n```bash\nreqvire merge \"Primary Element\" \"Duplicate Element\" --dry-run\nreqvire merge \"Primary Element\" \"Duplicate Element\"\n```\n\n**Move elements:**\n```bash\nreqvire mv \"Element\" \"new-file.md\" --dry-run\nreqvire mv \"Element\" \"new-file.md\"\n```\n\n**Move entire file:**\n```bash\nreqvire mv-file \"old-path.md\" \"new-path.md\" --dry-run\n```\n\n**Fix relations:**\n- Use `reqvire link` and `reqvire unlink` commands (see Command Reference above)\n\n**Extract specifications:**\n- Load [SpecificationsExtractionLogic.md](reference/SpecificationsExtractionLogic.md) for methodology\n\n**Full refactoring workflow:**\n- Load [ConsolidateRequirements.md](reference/ConsolidateRequirements.md) for comprehensive guidance\n\n### I need to understand requirement context\n\n```bash\n# Get full chain with ancestors and attachments\nreqvire collect \"Requirement Name\"\nreqvire collect \"Requirement Name\" --json > /tmp/req-context.json\n\n# See model hierarchy from element\nreqvire model --from \"Requirement Name\"\n\n# Trace verifications\nreqvire traces --filter-name=\".*Requirement.*\"\n```\n\n## Validation & Quality Checklist\n\nUse this standard workflow after any change to ensure model integrity:\n\n**1. Validate structure:**\n```bash\nreqvire validate\n```\n- Checks relations, element IDs, file structure\n- Must pass before proceeding\n\n**2. Lint issues:**\n```bash\nreqvire lint              # Show all issues\nreqvire lint --fixable    # Show auto-fixable issues\nreqvire lint --auditable  # Show manual review items\nreqvire lint --fix        # Apply automatic fixes\n```\n- Auto-fixes: redundant verify relations, safe hierarchical relations\n- Manual review: multi-path convergence, complex hierarchies\n\n**3. Check coverage:**\n```bash\nreqvire coverage\nreqvire coverage --json\n```\n- Verify all leaf requirements have verifications\n- Check coverage percentage\n\n**4. Format files:**\n```bash\nreqvire format            # Preview changes\nreqvire format --fix      # Apply formatting\n```\n- Normalize markdown structure\n- Ensure consistent formatting\n\n**After major refactoring, also check:**\n- `reqvire resources` - List all referenced files (implementations, design docs)\n- `reqvire traces` - Verify verification traceability\n- `reqvire model` - Confirm hierarchy structure\n- `reqvire containment` - Check physical organization\n\n\n\n\n\n",
        "claude-plugins/skills/syseng/reference/AddFeature.md": "# Adding New Features & Requirements\n\n**Key principle**: Requirements drive everything - no implementation without requirements. Follow the MBSE workflow to ensure properly specified functionality with full traceability.\n\n**For common commands** (link, add, validate, etc.), see [SKILL.md Command Reference](../SKILL.md#command-reference) and [Quick Start Guide](../SKILL.md#quick-start-common-workflows).\n\n## MBSE Workflow\n\n```\n1. Requirements first → Define what the system shall do (never skip)\n2. Refinements       → Add specifications, constraints, behaviors as needed\n3. Verifications     → Add verification elements for leaf requirements\n4. Implementation    → Connect to code via satisfiedBy (when code exists)\n```\n\n## Step 1: Understand the Feature Scope\n\nBefore creating requirements, answer:\n- What stakeholder need does this address? (user-requirement)\n- What technical capabilities are needed? (system-requirement)\n- Are there constraints or limits to define?\n- How will this be verified?\n\n## Step 2: Create Requirements Hierarchy\n\n```\nUser Requirement (stakeholder need)\n    ↓ derivedFrom\nSystem Requirement(s) (technical implementation)\n```\n\n**Guidelines:**\n- Start with user-requirement for the stakeholder need\n- Derive system-requirements for technical details\n- Keep requirements atomic and testable\n- Use EARS patterns for clear statements\n\n### Adding Requirements\n\nCreate requirements by piping element content to the add command:\n\n```bash\n# Add user requirement to file (reads from stdin)\necho '### Feature Name\n\nThe system shall provide feature capability.\n\n#### Metadata\n  * type: user-requirement\n\n#### Relations\n  * derivedFrom: [Parent Requirement](path.md#parent)\n' | reqvire add requirements/UserStories.md\n\n# Add system requirement at specific position (0-based index)\nreqvire add requirements/System/Features.md 2 <<'EOF'\n### System Feature Implementation\n\nThe system shall implement the feature using defined algorithms.\n\n#### Metadata\n  * type: system-requirement\n\n#### Relations\n  * derivedFrom: [Feature Name](../UserStories.md#feature-name)\nEOF\n\n# Override existing element (replace by name) - useful for cleanup after merge\nreqvire add requirements/File.md --override <<'EOF'\n### Existing Element Name\n\nUpdated content with corrections.\n\n#### Metadata\n  * type: requirement\n---\nEOF\n```\n\nOnce requirements are created, establish traceability using the link command:\n\n```bash\n# Link system requirement to user requirement\nreqvire link \"System Feature Implementation\" \"derivedFrom\" \"Feature Name\"\n\n# Link parent to child (opposite direction of derivedFrom)\nreqvire link \"Feature Name\" \"derive\" \"System Feature Implementation\"\n```\n\n**Relation types**: `derivedFrom` (child → parent), `derive` (parent → child), `verifiedBy` (requirement → verification), `verify` (verification → requirement), `satisfiedBy` (requirement → implementation), `satisfy` (implementation → requirement), `trace` (non-directional traceability)\n\n## Step 3: Add Refinements (if needed)\n\nAdd refinements only when:\n- **Specifications** - Detailed definitions needed, referenced by multiple requirements\n- **Constraints** - Limits/boundaries exist (add to Constraints.md)\n- **Behaviors** - Complex state/flow logic needs documentation\n\nLink via `satisfiedBy` from the requirement that asks for the refinement.\n\n### Refinement Best Practices\n\n- **Constraints** should always be in constraint element type\n- Group constraints in single file (e.g., `Constraints.md` in requirements root)\n- Define **Behaviors** and **Specifications** as elements only if other requirements depend on them\n- Otherwise define them under `#### Behaviors` or `#### Specifications` subsection of the requirement\n\n### Adding Refinement Elements\n\nCreate refinement elements when they need to be referenced by multiple requirements:\n\n```bash\n# Add specification element\nreqvire add requirements/Specifications.md <<'EOF'\n### Data Format Specification\n\nThe data format shall follow JSON Schema version 7 with strict validation.\n\n#### Metadata\n  * type: specification\n\n#### Relations\n  * satisfy: [Data Processing Requirement](System/Processing.md#data-processing-requirement)\nEOF\n\n# Add constraint element\nreqvire add requirements/Constraints.md <<'EOF'\n### Performance Constraint\n\nAll API responses shall complete within 200ms under normal load.\n\n#### Metadata\n  * type: constraint\n\n#### Relations\n  * satisfy: [API Performance Requirement](System/API.md#api-performance-requirement)\nEOF\n\n# Add behavior element\nreqvire add requirements/Behaviors.md <<'EOF'\n### Error Recovery Behavior\n\nWhen an error occurs, the system shall log the error, notify the user, and attempt recovery.\n\n#### Metadata\n  * type: behavior\n\n#### Relations\n  * satisfy: [Error Handling Requirement](System/ErrorHandling.md#error-handling-requirement)\nEOF\n```\n\nLink refinements to requirements using relations or attachments:\n\n```bash\n# Link refinement to requirement using satisfiedBy relation (owner defines it)\nreqvire link \"Data Processing Requirement\" \"satisfiedBy\" \"Data Format Specification\"\n\n# Attach refinement element (only from requirements OUTSIDE the owner's hierarchy)\n# The refinement must first satisfy its owner requirement\nreqvire link \"Other Feature Requirement\" attaching \"Performance Constraint\"\n\n# Attach file (design document, specification document)\nreqvire link \"Architecture Requirement\" attaching \"docs/architecture.pdf\"\n\n# Link to implementation file or external URL\nreqvire link \"System Requirement\" \"satisfiedBy\" \"src/auth/login.rs\"\nreqvire link \"Compliance Requirement\" \"trace\" \"https://example.com/spec.html\"\n```\n\n**Attachment constraints:**\n- Refinements must have a `satisfy` relation (establishing an owner) before being attached\n- Only requirements OUTSIDE the owner's derivation hierarchy can attach a refinement\n- Requirements in the same hierarchy access refinements through the hierarchy, not attachments\n\n## Step 4: Add Verifications\n\n**Bottom Roll-Up Strategy:**\n- Add verification elements for **leaf requirements only**\n- Parent requirements inherit verification from children\n- Avoid redundant verify relations\n\n### Verification Types\n\nChoose appropriate type:\n- `test` - Automated or manual testing (can have `satisfiedBy` to test code)\n- `analysis` - Review, calculation, simulation\n- `inspection` - Visual examination, audit\n- `demonstration` - Showing capability works\n\n### Adding Verification\n\nCreate verification elements for leaf requirements:\n\n```bash\n# Add test verification\nreqvire add requirements/Verifications/FeatureTests.md <<'EOF'\n### Feature Test\n\nTest verifies the feature works correctly:\n1. Input validation passes\n2. Output matches expected format\n3. Error handling works\n\n#### Metadata\n  * type: test-verification\n\n#### Relations\n  * verify: [Feature Requirement](../System/Features.md#feature-requirement)\n  * satisfiedBy: [test_feature.rs](../../tests/test_feature.rs)\nEOF\n\n# Add analysis verification\nreqvire add requirements/Verifications/PerformanceAnalysis.md <<'EOF'\n### Performance Analysis\n\nAnalysis verifies system meets performance requirements through load testing.\n\n#### Metadata\n  * type: analysis-verification\n\n#### Relations\n  * verify: [Performance Requirement](../System/Performance.md#performance-requirement)\nEOF\n```\n\nLink verifications to requirements and test implementations:\n\n```bash\n# Link verification to requirement (verify relation)\nreqvire link \"Feature Test\" \"verify\" \"Feature Requirement\"\n\n# Link from requirement to verification (verifiedBy relation, opposite direction)\nreqvire link \"Feature Requirement\" \"verifiedBy\" \"Feature Test\"\n\n# Link test verification to test implementation\nreqvire link \"Feature Test\" \"satisfiedBy\" \"tests/test_feature.rs\"\n```\n\n## Step 5: Validate and Check Coverage\n\nAfter adding requirements and verifications, follow the standard validation workflow. See [SKILL.md Validation & Quality Checklist](../SKILL.md#validation--quality-checklist) for the complete procedure:\n\n1. `reqvire validate` - Check model structure\n2. `reqvire lint --fix` - Fix auto-fixable issues\n3. `reqvire coverage` - Verify all leaf requirements have verifications\n4. `reqvire format --fix` - Normalize formatting\n\nAdditionally, use `reqvire resources` to see all files referenced by the model through `satisfiedBy`, `trace` relations and attachments.\n\n## Complete Example\n\n### 1. User Requirement\n```markdown\n### User Authentication\n\nThe system shall authenticate users before granting access to protected resources.\n\n#### Metadata\n  * type: user-requirement\n```\n\n### 2. System Requirements (derived)\n```markdown\n### Password Authentication\n\nThe system shall validate user credentials against stored password hashes.\n\n#### Metadata\n  * type: system-requirement\n\n#### Relations\n  * derivedFrom: [User Authentication](../UserStories.md#user-authentication)\n  * satisfiedBy: [auth.rs](../../src/auth.rs)\n```\n\n```markdown\n### Session Management\n\nThe system shall create and manage user sessions after successful authentication.\n\n#### Metadata\n  * type: system-requirement\n\n#### Relations\n  * derivedFrom: [User Authentication](../UserStories.md#user-authentication)\n  * satisfiedBy: [Session Timeout Constraint](../Constraints.md#session-timeout)\n```\n\n### 3. Constraint\n```markdown\n### Session Timeout\n\nUser sessions shall expire after 30 minutes of inactivity.\n\n#### Metadata\n  * type: constraint\n\n#### Relations\n  * satisfy: [Session Management](../System/Auth.md#session-management)\n```\n\n### 4. Verification\n```markdown\n### Authentication Test\n\nTest verifies user authentication flow:\n1. Valid credentials grant access\n2. Invalid credentials are rejected\n3. Sessions expire correctly\n\n#### Metadata\n  * type: test-verification\n\n#### Relations\n  * verify: [Password Authentication](../System/Auth.md#password-authentication)\n  * verify: [Session Management](../System/Auth.md#session-management)\n  * satisfiedBy: [test_auth.rs](../../tests/test_auth.rs)\n```\n\n## File Organization\n\nTypical structure:\n```\nrequirements/\n├── UserStories.md           # User requirements\n├── Constraints.md           # All constraints\n├── System/\n│   ├── FeatureA.md          # System requirements for feature A\n│   └── FeatureB.md\n├── Verifications/\n│   ├── FeatureATests.md     # Verifications for feature A\n│   └── FeatureBTests.md\n└── DesignDocuments/         # Design docs (not parsed as elements)\n    └── Architecture.md\n```\n\n### Reorganizing Elements\n\nMove elements between files or reposition within files:\n\n```bash\n# Move element to different file\nreqvire mv \"Feature Requirement\" \"requirements/System/NewFile.md\"\n\n# Move element to specific position (0-based index)\nreqvire mv \"Feature Requirement\" \"requirements/System/Features.md\" 0  # Move to top\n\n# Move entire file to new location\nreqvire mv-file \"requirements/Old.md\" \"requirements/System/New.md\"\n\n# Merge file into existing file (squash - combine contents)\nreqvire mv-file --squash \"requirements/Source.md\" \"requirements/Target.md\"\n```\n\n**When to reorganize:**\n- Grouping related requirements into feature-specific files\n- Splitting large files into manageable sections\n- Consolidating scattered constraints into Constraints.md\n- Moving verifications to match requirement structure\n",
        "claude-plugins/skills/syseng/reference/ConsolidateRequirements.md": "# Model Refactoring & Optimization\n\nUse this reference when reorganizing the model structure without changing requirements intent. The goal is better organization, traceability, and maintainability.\n\n**Key principle**: The system behavior specification remains unchanged - only the model structure improves.\n\n**For common commands** (search, merge, link, validate, etc.), see [SKILL.md Command Reference](../SKILL.md#command-reference).\n\n## Refactoring Activities\n\n- Splitting mixed-type requirements (user vs system)\n- Moving elements between files for better organization\n- Adding missing relations (satisfiedBy, derivedFrom)\n- Removing redundant verify relations\n- Consolidating scattered specifications\n\n## Workflow\n\n### Step 1: Audit Current State\n\nFind elements that need attention during refactoring:\n\n```bash\n# Find specifications not linked to any requirement\nreqvire search --filter-type='specification' --not-have-relations='satisfy' --short --json\n\n# Find constraints without satisfy relations\nreqvire search --filter-type='constraint' --not-have-relations='satisfy' --short\n\n# Find requirements with attachments (candidates for conversion to relations)\nreqvire search --has-attachments --short\n\n# Find duplicate or similar requirement names\nreqvire search --filter-name=\".*Feature.*\" --short\n\n# Find elements in specific files that might need reorganization\nreqvire search --filter-file=\"requirements/System/**\" --short\n```\n\nThese findings guide the refactoring work:\n- Orphaned specifications need `satisfiedBy` relations from appropriate requirements\n- Attachments may need conversion to `satisfiedBy` relations\n- Duplicate names suggest potential merge candidates\n\n### Step 2: Find Requirements Asking for Specifications\n\nSearch for patterns like:\n- \"following clearly defined specifications\"\n- \"adhering to precondition rules\"\n- \"shall support distinct states\"\n- \"shall implement constraints\"\n- \"shall enforce standardized policies\"\n\nThese requirements should have `satisfiedBy` relations to the specifications they ask for.\n\n### Step 3: Convert Attachments to satisfiedBy Where Appropriate\n\nFor each specification attachment, ask:\n- Does this requirement *define* this specification? → Use `satisfiedBy`\n- Does this requirement *reference* or *depend on* this specification? → Keep as `Attachment`\n\nConvert attachments to relations using link and unlink commands:\n\n```bash\n# Remove attachment from requirement\nreqvire unlink \"API Authorization Specification\" \"Authorization System Specification\"\n\n# Add satisfiedBy relation instead\nreqvire link \"API Authorization Specification\" \"satisfiedBy\" \"Authorization System Specification\"\n\n# Or add satisfy relation from opposite direction\nreqvire link \"Authorization System Specification\" \"satisfy\" \"API Authorization Specification\"\n```\n\n**When to keep attachments:**\n- Requirement references but doesn't define the specification\n- Specification is defined by a different requirement\n- The attaching requirement is OUTSIDE the owner's derivation hierarchy\n- The attachment is a design document or external file (not an element)\n\n**Attachment constraints:**\n- Refinements must have a `satisfy` relation first (establishing an owner)\n- Only requirements outside the owner's hierarchy can attach a refinement\n- Requirements in the same hierarchy cannot attach - they access through the hierarchy\n\n### Step 4: Consolidate Constraints\n\nFind a root requirement that asks for constraints to be defined. Add `satisfiedBy` relations to all constraint elements using the link command:\n\n```bash\n# Link constraint to requirement that defines it\nreqvire link \"System Constraints Requirement\" \"satisfiedBy\" \"Performance Constraint\"\nreqvire link \"System Constraints Requirement\" \"satisfiedBy\" \"Security Constraint\"\n\n# Or link from constraint to requirement\nreqvire link \"Performance Constraint\" \"satisfy\" \"System Constraints Requirement\"\n```\n\nWhen you find duplicate constraints, merge them:\n\n```bash\n# Preview merge to see what will happen\nreqvire merge \"Primary Constraint\" \"Duplicate Constraint\" --dry-run\n\n# Execute merge if preview looks correct\nreqvire merge \"Primary Constraint\" \"Duplicate Constraint\"\n```\n\n### Step 5: Remove Obsolete Elements\n\nAfter consolidation, remove elements that are no longer needed:\n\n```bash\n# Remove deprecated or duplicate element\nreqvire rm \"Old Requirement Name\"\n\n# Move element to better location before removing\nreqvire mv \"Element Name\" \"requirements/Archive.md\"\n```\n\n**Important**: Delete cleanly - don't leave \"DEPRECATED\" markers. Use git history to track what was removed and why.\n\n### Step 6: Validate After Each Change\n\nAfter each refactoring step, follow the standard validation workflow. See [SKILL.md Validation & Quality Checklist](../SKILL.md#validation--quality-checklist) for the complete procedure.\n\nQuick validation: `reqvire validate && reqvire lint --fix && reqvire coverage`\n\n\n## Identifying Missing Relations\n\nLook for specification elements with empty relations. For each:\n\n1. Find which requirement asks for this specification to be defined\n2. Change the attachment to a `satisfiedBy` relation on that requirement\n3. Keep attachments on other requirements that just reference (don't define) the specification\n\n## Merging Duplicate Requirements\n\nWhen you find overlapping requirements, use `reqvire merge`:\n\n```bash\n# Preview the merge\nreqvire merge \"Primary Requirement\" \"Duplicate Requirement\" --dry-run\n\n# Execute the merge\nreqvire merge \"Primary Requirement\" \"Duplicate Requirement\"\n\n# Merge multiple sources at once\nreqvire merge \"Main Feature\" \"Feature Part A\" \"Feature Part B\"\n```\n\nThe merge command:\n1. Consolidates content from duplicate into primary's Details section\n2. Merges all relations (verifiedBy, derivedFrom, etc.) with deduplication\n3. Updates all references pointing to duplicate to point to primary\n4. Deletes the duplicate element\n\n**Type compatibility:**\n- Requirements merge with requirements (all subtypes compatible)\n- Verifications merge with verifications\n- Refinements (constraint, behavior, specification) merge with each other\n\n**When to merge vs when to link:**\n- **Merge**: Elements express the same capability (duplicates)\n- **Link (derivedFrom)**: Elements have hierarchical relationship (parent/child)\n- **Link (trace)**: Elements are related but represent distinct capabilities\n\n**Post-merge cleanup**: If the merged result needs content restructuring (removing \"Merged Details\" artifacts), use `/reqvire:consolidate` to read, fix, and override with clean content.\n\n## When to Split Requirements (using derivedFrom)\n\n**1. Type separation** - Don't mix requirement types:\n- User requirements (stakeholder needs) should not contain system requirements (technical details)\n- Split when a requirement mixes \"what users need\" with \"how the system implements it\"\n\n**2. Change impact & containment:**\n- Scope isolation - Changes shouldn't require re-verification of unrelated aspects\n- Independent verification - Each child can be verified separately\n- Different ownership - Parts owned by different teams\n- Risk isolation - Separate high-risk from stable parts\n\n**3. Granularity:**\n- Atomic testability - Each requirement maps to clear pass/fail verification\n- Single responsibility - One requirement = one clear purpose\n- Stop splitting when further decomposition adds overhead without value\n\n## Example: Before and After\n\n### Before (Attachment):\n```markdown\n### API Authorization Specification\n\nThe system shall implement API Access Authorization following clearly defined specifications.\n\n#### Metadata\n  * type: user-requirement\n\n#### Attachments\n  * [Authorization System Specification](../Specifications/AuthSpecifications.md#authorization-system-specification)\n```\n\n### After (satisfiedBy):\n```markdown\n### API Authorization Specification\n\nThe system shall implement API Access Authorization following clearly defined specifications.\n\n#### Metadata\n  * type: user-requirement\n\n#### Relations\n  * satisfiedBy: [Authorization System Specification](../Specifications/AuthSpecifications.md#authorization-system-specification)\n```\n\nReferencing requirement (keeps attachment):\n```markdown\n### Add IP to Whitelist\n\nThe system shall allow adding IPs to whitelist.\n\n#### Attachments\n  * [Environment Limits](../Specifications/Constraints.md#environment-limits)\n```\n\n## Final Formatting\n\nAfter completing all refactoring changes, apply formatting to ensure consistency:\n\n```bash\n# Preview formatting changes (dry-run by default)\nreqvire format\n\n# Apply formatting fixes\nreqvire format --fix\n\n# Apply formatting with full relation expansion (includes auto-generated inverse relations)\nreqvire format --fix --with-full-relations\n```\n\nThe format command ensures:\n- Consistent markdown structure\n- Proper element separator lines (`---`)\n- Correct subsection ordering (Metadata, Relations, Details, Attachments)\n- Clean whitespace and indentation\n\n## Git Philosophy\n\n**IMPORTANT**: When removing or changing requirements:\n- **DELETE** deprecated requirements completely\n- **REMOVE** broken relations\n- **USE** git history to track changes (commit messages explain rationale)\n- **NEVER** keep \"DEPRECATED\" notes or \"Previous behavior\" documentation\n- Clean specifications are more valuable than inline deprecation notes\n",
        "claude-plugins/skills/syseng/reference/CreatingTasks.md": "# Creating Implementation Tasks from Requirements\n\nThis workflow bridges the gap between requirements and implementation by analyzing what changed and generating comprehensive task lists.\n\n**Key principle**: Every implementation task maintains traceability to requirements, implementations, and tests.\n\n**For common commands** (change-impact, collect, search, validate), see [SKILL.md Command Reference](../SKILL.md#command-reference). For validation workflow, see [SKILL.md Validation & Quality Checklist](../SKILL.md#validation--quality-checklist).\n\n## When to Use This Workflow\n\n- Generating implementation plans from requirement changes\n- Understanding what requirements changed on a feature branch\n- Creating task breakdowns for developers\n- Planning implementation work with full traceability\n- Analyzing change impact before implementing\n\n## Core Workflow\n\n### Step 1: Analyze Change Impact\n\nUnderstand how changes to requirements propagate through the model:\n\n```bash\n# Run change impact analysis comparing to base branch\nBASE_COMMIT=$(git merge-base main HEAD)\nreqvire change-impact --git-commit=$BASE_COMMIT\n\n# Save to JSON for programmatic analysis\nreqvire change-impact --git-commit=$BASE_COMMIT --json > /tmp/impact.json\n\n# Compare against specific commit\nreqvire change-impact --git-commit=<commit-hash>\n\n# Compare against previous commit\nreqvire change-impact --git-commit=HEAD~1\n```\n\nThe change-impact command identifies:\n- `added_elements[]` - New requirements/verifications\n- `modified_elements[]` - Changed requirements/verifications\n- `affected_elements[]` - Elements impacted by changes (via derivedFrom, verifiedBy)\n\n**Change Propagation Rules:**\n- **Parent → Child**: Parent changes propagate to all derived children\n- **Requirement → Verification**: Requirement changes invalidate verifications\n- **Requirement → Implementation**: May need implementation updates\n- **Verification changes**: Generally don't propagate upward\n\n### Step 2: Gather Full Requirement Context\n\nFor each changed requirement, collect complete context:\n\n```bash\n# Get full requirement chain with ancestors and attachments\nreqvire collect \"<requirement-name>\" --json > /tmp/req_<requirement-id>.json\n\n# Also save human-readable format for reference\nreqvire collect \"<requirement-name>\" > /tmp/req_context_<requirement-id>.md\n\n# Get direct requirement details\nreqvire search --filter-id=\"<requirement-id>\" --json\n```\n\n**Why use `reqvire collect` for task generation:**\n- Gathers complete requirement chain via `derivedFrom` relations\n- Shows parent requirements (the \"why\" context)\n- Includes all specifications and design documents\n- Captures constraints and validation rules\n- Provides full implementation context in one command\n- Saves to `/tmp` for developer reference during implementation\n\n**What collect provides:**\n- All ancestor requirement content\n- Attached markdown files (read as content)\n- Attached refinement elements (specifications, constraints, behaviors)\n- Source citations for traceability\n\n### Step 3: Identify Verification and Test Paths\n\nFor each requirement, identify what needs to be tested:\n\n```bash\n# Get verifications for a requirement\nreqvire traces --filter-id=\"<requirement-id>\" --json\n\n# Get test file paths from verification\nreqvire search --filter-id=\"<verification-id>\" --json\n```\n\nExtract:\n- `verifiedBy` relations → which verifications to review\n- `satisfiedBy` relations on verifications → which test files to run\n- `satisfiedBy` relations on requirements → which code to update\n\n### Step 4: Generate Task Plan\n\nCreate a TodoWrite-formatted task plan with full traceability.\n\n**For new requirements:**\n\n```markdown\n☐ Implement \"{Requirement Name}\" ({REQ-ID})\n  Context: [2-3 sentence summary from collected chain]\n  Purpose: [Why - from parent requirement]\n  Implementation: [Key specs/API endpoints from collected data]\n  ⚠️ IMPORTANT: Read full requirement - this is only a summary!\n\n  ☐ Review full requirement context: /tmp/req_context_<req-id>.md\n  ☐ Review requirement: [link to git blob]\n  ☐ Implement functionality per specifications\n  ☐ Run tests: {test paths from verifiedBy → satisfiedBy}\n  ☐ Add satisfiedBy relation: reqvire link \"{REQ-ID}\" \"satisfiedBy\" \"path/to/implementation\"\n  ☐ Validate model: reqvire validate\n```\n\n**For modified requirements:**\n\n```markdown\n☐ Update \"{Requirement Name}\" ({REQ-ID})\n  Context: [What changed - from collected chain]\n  Impact: [Affected specs/constraints from collected data]\n  ⚠️ IMPORTANT: Read full requirement - this is only a summary!\n\n  ☐ Review full requirement context: /tmp/req_context_<req-id>.md\n  ☐ Review changes: [link to git blob]\n  ☐ Review code: {satisfiedBy paths from requirement}\n  ☐ Update implementation\n  ☐ Run tests: {test paths from verifiedBy → satisfiedBy}\n  ☐ Validate model: reqvire validate\n```\n\n### Step 5: Generate Git Blob Links\n\nCreate stable links to exact requirement versions:\n\n```bash\n# Get repository URL\nREPO_URL=$(git remote get-url origin | sed 's/\\.git$//' | sed 's/git@github.com:/https:\\/\\/github.com\\//')\n\n# Generate blob link\nBASE_COMMIT=$(git merge-base main HEAD)\nBLOB_URL=\"${REPO_URL}/blob/${BASE_COMMIT}/${file_path}#${element-anchor}\"\n```\n\nThese links ensure developers review the exact requirement version from the base commit.\n\n## Task Plan Structure\n\nA complete task plan follows this format:\n\n```markdown\n# Implementation Task Plan\n\n**Base**: {base_branch}@{base_commit}\n**Feature**: {current_branch}\n\n## Summary\n- New requirements: X\n- Modified requirements: Y\n- Tests to run: Z\n\n## Phase 1: New Requirements\n\n☐ Implement \"{New Requirement 1}\" (REQ-ID-1)\n  [Task details as shown above]\n\n☐ Implement \"{New Requirement 2}\" (REQ-ID-2)\n  [Task details as shown above]\n\n## Phase 2: Modified Requirements\n\n☐ Update \"{Modified Requirement 1}\" (REQ-ID-3)\n  [Task details as shown above]\n\n## Phase 3: Affected Verifications\n\n☐ Review verifications for \"{Requirement Name}\"\n  ☐ Run test: {test-path-1}\n  ☐ Run test: {test-path-2}\n  ☐ Update verification if needed\n\n## Reference Documents\n\nFull requirement context available in `/tmp/`:\n- `/tmp/req_context_req-id-1.md` - Full context for {Requirement Name 1}\n- `/tmp/req_context_req-id-2.md` - Full context for {Requirement Name 2}\n\nEach context document shows:\n- Complete requirement chain (derivedFrom)\n- Parent requirements and purpose\n- Specifications and implementation details\n- Attached design documents\n- Constraints and validation rules\n```\n\n## Model Exploration Commands\n\n**CRITICAL: Use reqvire commands to understand requirements - DO NOT read specification files directly!**\n\nWhen analyzing requirements for task generation:\n\n| To Understand This | Use This Command |\n|--------------------|------------------|\n| What requirements changed | `reqvire change-impact --git-commit=<hash> --json` |\n| **Full requirement context** | `reqvire collect \"<name>\" --json > /tmp/req_<id>.json` |\n| Requirement direct content | `reqvire search --filter-id=\"<id>\" --json` |\n| What verifies a requirement | `reqvire traces --filter-id=\"<id>\" --json` |\n| Which tests to run | Extract `satisfiedBy` from verification via `reqvire search` |\n| Implementation status | Check `satisfiedBy` relations in requirement |\n| Requirement hierarchy | `reqvire collect \"<name>\"` shows complete derivedFrom chain |\n\n**Why use commands instead of reading files:**\n- Automatic relation following\n- Structured JSON output for parsing\n- Already validated and parsed\n- Includes computed fields (verification status, etc.)\n- Much more efficient than manual file reading\n\n## Task Plan Principles\n\n- **Traceability First**: Every task maintains requirement → implementation → test links\n- **Repository-Agnostic**: No assumptions about codebase unless specified in requirements\n- **Explicit Tasks**: One requirement = One top-level task with all sub-steps\n- **Test-Driven**: Always include tests in implementation workflow\n- **Read Requirements**: Summaries are context only - full requirements are mandatory reading\n- **Track Progress**: TodoWrite format enables real-time progress tracking\n- **Use Commands**: Always query model via reqvire commands, not file reading\n\n## Best Practices\n\n- **Always read requirements**: Summaries are NOT sufficient for implementation\n- **Run tests**: Verify implementation before marking tasks complete\n- **Maintain traceability**: Always add/update satisfiedBy relations after implementation\n- **One requirement = One task**: Don't combine multiple requirements\n- **Explicit tests**: List every test file that needs to run\n- **Repository-agnostic**: Don't assume technology stack unless in requirements\n- **Link to source**: Every requirement needs a blob link\n- **Track progress**: Use TodoWrite checkboxes throughout implementation\n- **Save context**: Keep `/tmp/req_context_*.md` files for developer reference\n\n## Complete Example\n\n```bash\n# 1. Detect base branch and get base commit\nCURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\nBASE_BRANCH=\"main\"\nBASE_COMMIT=$(git merge-base $BASE_BRANCH HEAD)\n\n# 2. Run change impact analysis\nreqvire change-impact --git-commit=$BASE_COMMIT --json > /tmp/impact.json\n\n# 3. For each changed requirement, gather context\nreqvire collect \"Authentication Feature\" --json > /tmp/req_auth_feature.json\nreqvire collect \"Authentication Feature\" > /tmp/req_context_auth_feature.md\n\n# 4. Get requirement details\nreqvire search --filter-id=\"requirements/Auth.md#authentication-feature\" --json\n\n# 5. Get verification and test paths\nreqvire traces --filter-id=\"requirements/Auth.md#authentication-feature\" --json\nreqvire search --filter-id=\"requirements/Verifications/AuthTests.md#auth-test\" --json\n\n# 6. Generate git blob URL\nREPO_URL=$(git remote get-url origin | sed 's/\\.git$//' | sed 's/git@github.com:/https:\\/\\/github.com\\//')\nBLOB_URL=\"${REPO_URL}/blob/${BASE_COMMIT}/requirements/Auth.md#authentication-feature\"\n\n# 7. Create task plan (manual or automated)\n```\n\n**Resulting task:**\n\n```markdown\n☐ Implement \"Authentication Feature\" (requirements/Auth.md#authentication-feature)\n  Context: System shall authenticate users using JWT tokens with refresh\n  capabilities. Derived from \"User Security\" requirement to protect sensitive\n  user data. Includes password hashing specification and session constraints.\n  Purpose: Enable secure user authentication for protected resources\n  Implementation: JWT token generation, password bcrypt hashing, session management\n  ⚠️ IMPORTANT: Read full requirement - this is only a summary!\n\n  ☐ Review full requirement context: /tmp/req_context_auth_feature.md\n  ☐ Review requirement: https://github.com/org/repo/blob/abc123/requirements/Auth.md#authentication-feature\n  ☐ Implement JWT token generation per specification\n  ☐ Implement password hashing using bcrypt\n  ☐ Implement session management with timeout constraints\n  ☐ Run tests: tests/auth/test_authentication.rs\n  ☐ Run tests: tests/auth/test_session.rs\n  ☐ Add satisfiedBy relation: reqvire link \"Authentication Feature\" \"satisfiedBy\" \"src/auth/jwt.rs\"\n  ☐ Validate model: reqvire validate\n```\n\n## Integration with Other References\n\nAfter creating the task plan:\n- **For implementation**: Follow the task plan with TodoWrite tracking\n- **For requirement clarification**: See [Explore](explore.md) for model exploration\n- **For adding new requirements**: See [Add Feature](AddFeature.md)\n- **For refactoring requirements**: See [Consolidate Requirements](ConsolidateRequirements.md)\n- **For verification**: Run tests and validate model after each implementation\n\n## Using Slash Commands\n\nThe syseng skill provides slash commands that automate this workflow:\n\n- `/reqvire:analyze-impact [commit-hash]` - Analyze requirement changes and their impact\n- `/reqvire:generate-tasks [base-commit]` - Generate complete task plan from changes\n\nThese commands follow the workflow described above and automatically:\n1. Detect base branch\n2. Run change-impact analysis\n3. Collect requirement context\n4. Generate TodoWrite task plan\n5. Save reference documents to `/tmp`\n6. Create git blob links\n\n**When to use slash commands vs manual workflow:**\n- **Use slash commands**: Quick task generation for feature branches\n- **Use manual workflow**: Custom analysis, learning the process, non-standard cases\n",
        "claude-plugins/skills/syseng/reference/SpecificationsExtractionLogic.md": "# Specifications Extraction Logic\n\n**For common commands and validation workflow**, see [SKILL.md Command Reference](../SKILL.md#command-reference) and [Validation & Quality Checklist](../SKILL.md#validation--quality-checklist).\n\n## Purpose\n\nThis document describes the logic and methodology for refactoring requirements to separate EARS statements (what/why) from technical specifications (how), following MBSE best practices.\n\n## Problem Statement\n\nRequirements with embedded technical specifications suffer from:\n- **Reduced Clarity**: User needs are obscured by implementation details\n- **Poor Reusability**: Technical specs can't be referenced by multiple requirements\n- **Maintenance Burden**: Changing implementation details requires editing requirements\n- **Reduced Traceability**: Ownership relationships are unclear between requirements and specifications\n\n## Solution: Separation of Concerns\n\nExtract technical specifications from requirement Details sections into separate specification elements, creating:\n- **Concise Requirements**: EARS-style statements focused on user value (under 15 lines)\n - Main body has one more general statement and all other must be written in '#### Details' subsection\n- **Reusable Specifications**: Technical details in standalone elements\n- **Clear Ownership**: `satisfiedBy` relations show which requirement owns the specification\n- **Cross-References**: Attachment relations provide supporting context without ownership\n\n## Refactoring Methodology\n\n### Phase 1: Identification\n\n**Candidates for Refactoring:**\n- Requirements containing technical implementation details\n- Requirements with algorithm descriptions\n- Requirements with detailed format specifications\n- Requirements with ordering rules or processing workflows\n\n**NOT Candidates:**\n- Elements already typed as `specification` or `constraints` (refinement elements)\n- Requirements where Details add essential context without implementation details like success criteria and such\n\n**Examples of hardcoded limits to extract as constraints:**\n\n*Web App:*\n- \"Session expires after 30 minutes of inactivity\"\n- \"Maximum file upload size: 10 MB\"\n- \"Password must be 8-128 characters\"\n\n*API:*\n- \"Rate limit: 100 requests per minute\"\n- \"Maximum payload size: 1 MB\"\n- \"Token expiration: 24 hours\"\n\n*Database:*\n- \"Connection pool maximum: 20 connections\"\n- \"Query timeout: 30 seconds\"\n\n### Phase 2: Analysis\n\nFor each candidate requirement:\n\n1. **Identify Embedded Specifications**: Look for technical content describing HOW the system implements the requirement\n2. **Extract Technical Content**: Separate implementation details from the user need\n3. **Determine Specification Granularity**: Decide if content forms one specification or multiple related specifications\n4. **Identify Cross-References**: Find other requirements that would benefit from referencing these specifications\n\n### Phase 3: Extraction\n\n**Creating the Specification Element:**\n\n```markdown\n### Specification Name\n\nBrief description of what this specification defines.\n\n#### Details\n[Technical content extracted from requirement]\n\n**Section Headers** (where appropriate):\n- Use bold headers to organize complex specifications\n- Group related rules and behaviors\n- Maintain readability\n\n#### Metadata\n  * type: specification\n\n#### Relations\n  * satisfy: [Parent Requirement](path#requirement-name)\n```\n\n`  * type: specification` can be other refinement type depending on what this refinement element represents.\n\n**Reducing the Requirement:**\n\n```markdown\n### Requirement Name\n\nConcise EARS-style statement (1 sentence).\n\n#### Details\n- Other EARS statement\n- Other EARS statement\n- Or if bigger statement \n\n#### Metadata\n  * type: requirement\n\n#### Relations\n  * satisfiedBy: [Specification Name](path#specification-name)\n  [... other existing relations ...]\n```\n\n### Phase 4: Cross-Referencing\n\n**Ownership vs Reference:**\n\n- **satisfiedBy Relation**: Used by the requirement that OWNS the specification (one-to-one or one-to-many)\n- **Attachment Relation**: Used by requirements OUTSIDE the owner's derivation hierarchy\n\n**Attachment Scope Constraints:**\n\n1. Refinements must have a `satisfy` relation first (establishing an owner requirement)\n2. Only requirements OUTSIDE the owner's hierarchy can attach the refinement\n3. Requirements in the same hierarchy (ancestors or descendants of owner) CANNOT attach\n\n**Example:**\n```markdown\n# In the plan\n**Deterministic Output Specification** - Owned by `Model Reports`, attach to:\n- `Some Other Feature` - *not in Model Reports hierarchy* ✓\n  - MUST NOT ATTACH TO (in owner's hierarchy):\n     - `Model Structure and Summaries` - *child of Model Reports* ✗\n     - `Validation Report Generator` - *grandchild of Model Reports* ✗\n```\n\n### Phase 5: Validation\n\nAfter refactoring:\n1. Run `reqvire validate` - ensure no validation errors\n2. Run `reqvire format --fix` - normalize formatting\n3. Review requirement conciseness - confirm under 15 lines\n\n## Refactoring Patterns\n\n### Pattern 1: Single Specification Extraction\n\n**Before:**\n```markdown\n### Model Reports\n\nWhen requested the system shall provide deterministic model reports.\n\n#### Details\nAll reports shall produce deterministic output with consistent ordering.\n\nThe system shall ensure deterministic output by:\n1. Element Ordering: Sort by identifier\n2. Relation Ordering: Sort by type then target\n3. Section Ordering: Alphabetical\n4. File Ordering: Alphabetical\n\nThis ensures:\n- Byte-identical output on repeated runs\n- Reliable test comparison\n- Meaningful version control diffs\n\nApplies to: model summary, verification tracing, coverage, change impact, validation, linting\n```\n\n**After:**\n```markdown\n### Model Reports\n\nWhen requested the system shall provide human readable and machine readable System model reports with deterministic output and consistent ordering following clearly defined specifications.\n\n#### Relations\n  * satisfiedBy: [Deterministic Output Specification](Specifications.md#deterministic-output-specification)\n\n---\n\n### Deterministic Output Specification\n\nTechnical specification for ensuring deterministic, reproducible output.\n\n#### Details\n[All technical content moved here]\n\n#### Metadata\n  * type: specification\n\n\n```\n\n### Pattern 2: Multiple Specification Extraction\n\n**Before:**\n```markdown\n### Interactive Mermaid Diagrams\n\nSystem shall produce interactive visual representations.\n\n#### Details\n**Diagram Generation Approach:**\n- File-based generation\n- Shows all elements and relationships\n- External resources as linked boxes\n\n**Diagram Styling:**\n- Containment structure with subgraphs\n- Element type-specific CSS classes\n- Interactive highlighting on hover\n\n**Navigation and Filtering:**\n- Default shows root requirements\n- Filter from specific element using --from flag\n- Complete model structure generation\n```\n\n**After:**\n```markdown\n### Interactive Mermaid Diagrams\n\nSystem shall produce interactive visual representations enabling users to explore relations and navigate model structure following clearly defined specifications.\n\n#### Relations\n  * satisfiedBy: [Mermaid Diagram Generation Specification](...)\n  * satisfiedBy: [Mermaid Interactive Features Specification](...)\n\n---\n\n### Mermaid Diagram Generation Specification\n[Generation approach and styling content]\n\n#### Metadata\n  * type: specification\n\n\n---\n\n### Mermaid Interactive Features Specification\n[Navigation and filtering content]\n\n#### Metadata\n  * type: specification\n\n\n```\n\n## Pattern 3: Constraint Consolidation:\n\n**Before:**\n```markdown\n### Operational Constraints\n\nSystem shall implement session and rate limits\n\n#### Details\n\nSession limit will be 23 hours duration .\nRate limit will be 100 request per hour.\n```\n\n\n**After:**\n```markdown\n### Operational Constraints\n\nThe system shall implement operational constraints and rate limits.\n\n#### Metadata\n  * type: user-requirement\n\n#### Relations\n  * satisfiedBy: [Rate Limits](../Specifications/Constraints.md#rate-limits)\n  * satisfiedBy: [Session Limits](../Specifications/Constraints.md#session-limits)\n```\n\n\n## Decision Rules\n\n### When to Extract a Specification\n\nExtract when ANY of these conditions are true:\n2. Content describes HOW system implements (not WHAT or WHY)\n3. Content includes algorithms, workflows, or processing rules\n4. Content defines output formats or data structures\n5. Content describes technical constraints or ordering rules\n6. Multiple requirements could benefit from referencing (attaching) this content\n\n### When NOT to Extract\n\nKeep content in requirement when:\n1. Element is already type refirement type\n2. Details section with essential context\n3. Content describes rationale or business justification or success criteria (WHY)\n4. Content provides examples clarifying the requirement\n5. Extraction would make requirement too abstract to understand\n\n### Specification Naming\n\nSpecifications should be named:\n- **Descriptively**: Clear indication of what technical aspect they specify\n- **Consistently**: Follow existing naming patterns in the subsystem\n- **Specifically**: Not too generic (avoid \"General Specification\")\n\nExamples:\n- ✓ `Deterministic Output Specification`\n- ✓ `Diagram Relation Filtering Specification`\n- ✓ `Resources Report Format Specification`\n- ✗ `Output Specification` (too generic)\n- ✗ `Report Spec` (not descriptive enough)\n\n### Specification Content\n\nSpecifications MUST NOT use EARS statements as those are not requirements.\n\n### Attachment vs satisfiedBy\n\n**Use satisfiedBy when:**\n- Requirement OWNS the specification\n- Specification was extracted FROM this requirement\n- Requirement has primary responsibility for the technical content\n\n**Use Attachment when:**\n- Requirement REFERENCES specification for context\n- Specification owned by a requirement in a DIFFERENT derivation hierarchy\n- Specification provides supporting technical details\n- Multiple requirements (from different hierarchies) benefit from this specification\n\n**Attachment Constraint:**\n- Requirements in the same hierarchy as the owner CANNOT attach the refinement\n- They access the refinement through the hierarchy relationship instead\n- Cross-hierarchy attachments enable requirements from separate branches to reference shared specs\n\n## Quality Metrics\n\n### Success Criteria\n\nAfter refactoring, verify:\n1. **Conciseness**: All requirements have Details under 15 lines\n2. **Clarity**: Requirements focus on user value, not implementation\n3. **Reusability**: Specifications referenced by multiple requirements where appropriate\n4. **Traceability**: Clear ownership via satisfiedBy relations\n5. **Validation**: `reqvire validate` shows no errors\n7. **Formatting**: All files properly formatted\n\n### Quantitative Metrics\n\nTrack these metrics:\n- **Line Reduction**: Requirements should be reduced by 80-90%\n- **Specifications Created**: Typically 1-2 per complex requirement\n- **Cross-References**: Average 3-5 attachments per specification\n\n### Example Metrics (Phase 2)\n\n```\nSpecifications Extracted:     5\nRequirements Refactored:      4\nTotal Line Reduction:         ~179 → ~20 lines (88.8%)\nCross-Reference Attachments:  22 total\nHierarchical Attachments:     15 total\nValidation Errors:            0\n```\n\n## Common Pitfalls\n\n### Pitfall 1: Over-Extraction\n\n**Problem**: Extracting every detail creates specification explosion\n**Solution**: Merge several specifications and requirement into one.\n\n### Pitfall 2: Losing Context\n\n**Problem**: Requirement becomes too abstract after extraction\n**Solution**: Keep essential context in requirement, extract only technical implementation\n\n### Pitfall 3: Unclear Ownership\n\n**Problem**: Multiple requirements use satisfiedBy for same specification\n**Solution**: Only owner uses satisfiedBy, others use attachments\n\n### Pitfall 4: Orphaned Specifications\n\n**Problem**: Creating specifications not owned by any requirement\n**Solution**: Always create satisfiedBy relation from owner to specification\n\n### Pitfall 5: Inconsistent Granularity\n\n**Problem**: Some specifications too fine-grained, others too coarse\n**Solution**: Balance specificity - aim for cohesive, reusable technical units\n\n## Tools and Automation\n\n### Finding Refactoring Candidates (Phase 1)\n\nUse search to identify requirements that may need specification extraction:\n\n```bash\n# Find all requirements (candidates for review)\nreqvire search --filter-type=\"requirement,user-requirement\" --short\n\n# Find requirements in specific subsystem\nreqvire search --filter-type=\"requirement\" --filter-file=\"requirements/System/**\" --short\n\n# Find requirements with attachments (may need conversion to satisfiedBy)\nreqvire search --filter-type=\"requirement\" --has-attachments --short\n\n# Find refinements without satisfy relations (orphaned specifications, constraints, behaviors)\nreqvire search --filter-type=\"specification,constraint,behavior\" --not-have-relations=\"satisfy\" --short\n```\n\n### Validation Commands (Phase 5)\n\nAfter extracting specifications, validate the refactored model using the standard validation workflow. See [SKILL.md Validation & Quality Checklist](../SKILL.md#validation--quality-checklist) for the complete procedure.\n\nQuick validation: `reqvire validate && reqvire lint --fix && reqvire format --fix`\n\n### Finding Candidates (Manual Review)\n\nUse Explore agents to identify requirements with:\n- Long Details sections (grep for element length)\n- Technical keywords (algorithm, format, structure, ordering, rules)\n- Implementation-focused content\n",
        "claude-plugins/skills/syseng/reference/explore.md": "# Exploring and Understanding the Model\n\nUse this reference when you need to understand the model structure, search for requirements, or browse the specifications.\n\n**For common commands** (search, validate, lint, link, etc.), see [SKILL.md Command Reference](../SKILL.md#command-reference). This reference focuses on advanced search patterns and model exploration workflows.\n\n## Quick Model Overview\n\nStart exploring your model with these commands to understand its structure:\n\n```bash\n# Get model summary with element counts\nreqvire search --short --json | jq '.summary'\n\n# List all files with elements\nreqvire search --short --json | jq '.files[].file_path'\n\n# Check model health\nreqvire validate\nreqvire coverage\n```\n\n### Model-Centric View\n\nFor a deeper understanding of how requirements connect, use the model-centric view:\n\n```bash\n# Show all root requirements with nested relations\nreqvire model [--json]\n\n# Start from specific element to see its subtree\nreqvire model --from \"Element Name\"\n\n# Reverse traversal: start from leaf elements (verifications) and trace upward\nreqvire model --reverse\n\n# Filter by element type\nreqvire model --filter-type=\"user-requirement\"\nreqvire model --filter-type=\"test-verification\"\n\n# Combine reverse with type filter (e.g., trace verifications upward)\nreqvire model --reverse --filter-type=\"test-verification\"\n```\n\n**Element types for `--filter-type`:** user-requirement, requirement, test-verification, analysis-verification, inspection-verification, demonstration-verification, constraint, behavior, specification. For custom types: `other-TYPENAME`\n\n## Searching Elements\n\nThe search command filters elements based on various criteria:\n\n```bash\nreqvire search [--json] [--short] [--filter-*]\n```\n\nUse `--short` when analyzing model structure without needing full content. Use `--json` for programmatic processing.\n\n### Filter Options\n\n| Option | Description | Example |\n|--------|-------------|---------|\n| `--filter-file` | Filter by file glob | `--filter-file=\"requirements/**/*.md\"` |\n| `--filter-name` | Filter by element name (regex) | `--filter-name=\".*Auth.*\"` |\n| `--filter-id` | Filter by exact identifier | `--filter-id=\"requirements/File.md#element\"` |\n| `--filter-type` | Filter by element type (comma-separated, OR logic) | `--filter-type=\"user-requirement\"` or `--filter-type=\"requirement,behavior\"` |\n| `--filter-content` | Filter by content (regex) | `--filter-content=\"SHALL.*validate\"` |\n| `--filter-page-content` | Filter by file frontmatter | `--filter-page-content=\"security\"` |\n| `--have-relations` | Elements with ALL relations | `--have-relations=\"verifiedBy,satisfiedBy\"` |\n| `--not-have-relations` | Elements without ALL relations | `--not-have-relations=\"verifiedBy\"` |\n| `--has-attachments` | Elements with attachments | `--has-attachments` |\n| `--filter-attachment` | Filter by attachment pattern | `--filter-attachment=\"*.pdf\"` |\n\n**Element types for --filter-type (supports comma-separated list):** user-requirement, requirement, test-verification, analysis-verification, inspection-verification, demonstration-verification, constraint, behavior, specification. For custom types: `other-TYPENAME`\n\n### By Type\n```bash\n# Find all user requirements\nreqvire search --filter-type=\"user-requirement\" --short\n\n# Find all system requirements\nreqvire search --filter-type=\"system-requirement\" --short\n\n# Find all verifications\nreqvire search --filter-type=\"verification\" --short\n\n# Find specifications/constraints/behaviors\nreqvire search --filter-type=\"specification\" --short\nreqvire search --filter-type=\"constraint\" --short\n```\n\n### By File Location\n```bash\n# Elements in specific folder\nreqvire search --filter-file=\"requirements/System/**\" --short\n\n# Elements in specific file\nreqvire search --filter-file=\"**/UserStories.md\" --short\n```\n\n### By Name or Content\n```bash\n# Find by name pattern\nreqvire search --filter-name=\".*Authentication.*\" --short\n\n# Find by content pattern\nreqvire search --filter-content=\"SHALL.*validate\" --short\n```\n\n### By Relations\n```bash\n# Find unverified requirements\nreqvire search --filter-type=\"requirement\" --not-have-relations=\"verifiedBy\" --short\n\n# Find unsatisfied verifications (test type without implementation)\nreqvire search --filter-type=\"test-verification\" --not-have-relations=\"satisfiedBy\" --short\n\n# Find elements with specific relations\nreqvire search --have-relations=\"verifiedBy,satisfiedBy\" --short\n\n# Find specifications not linked to any requirement\nreqvire search --filter-type=\"specification\" --not-have-relations=\"satisfy\" --short\n```\n\n### By Attachments\n```bash\n# Find elements with attachments\nreqvire search --has-attachments --short\n\n# Find elements with specific attachment type\nreqvire search --filter-attachment=\"*.pdf\" --short\nreqvire search --filter-attachment=\"**/DesignDocuments/**\" --short\n```\n\n## Understanding Traceability\n\nTo understand how verifications trace to requirements, use the traces command:\n\n```bash\n# Show verification traces (upward from verifications to root requirements)\nreqvire traces [--json] [--filter-*]\n\n# Filter by specific element patterns\nreqvire traces --filter-name=\".*Auth.*\"\nreqvire traces --filter-type=\"test-verification\"\n\n# Generate with GitHub blob links for stable references\nreqvire traces --links-with-blobs\n\n# Generate relative links from specific folder\nreqvire traces --from-folder=\"docs/specs\"\n\n# See verification coverage report\nreqvire coverage [--json]\n\n# See all files referenced by model (implementations, design docs)\nreqvire resources\n```\n\n## Understanding Element Details\n\nWhen you find an element of interest:\n1. Read the full element content (not just --short output)\n2. Check for **attachments** - they contain critical details\n3. Follow relations to understand context:\n   - `derivedFrom` → parent requirements (why this exists)\n   - `satisfiedBy` → implementations (how it's fulfilled)\n   - `verifiedBy` → verifications (how it's tested)\n\nTo gather complete context for a requirement, use the collect command:\n\n```bash\n# Get full requirement chain with all ancestor content and attachments\nreqvire collect \"<requirement-name>\" [--json]\n\n# Example: collect all context for a feature\nreqvire collect \"Feature Requirement\"\n\n# JSON format for programmatic use\nreqvire collect \"System Requirement\" --json\n```\n\nThe collect command traverses `derivedFrom` relations upward and includes:\n- All ancestor requirement content\n- Attached markdown files (read as content)\n- Attached refinement elements (specifications, constraints, behaviors)\n- Source citations for traceability\n\n**When to use collect:**\n- Before implementing a requirement - get full specification context\n- When analyzing impact of changes - understand complete requirement chain\n- When creating tasks from requirements - gather all related specifications\n- When reviewing requirements - see full derivation hierarchy with sources\n\n## Containment View\n\nView the physical organization of the model (folders → files → elements):\n\n```bash\n# See full containment structure\nreqvire containment\n\n# Compact view without element details\nreqvire containment --short\n\n# JSON format for programmatic analysis\nreqvire containment --json\n```\n\n## Common Analysis Patterns\n\n### Find gaps in verification\n```bash\n# Unverified leaf requirements\nreqvire search --filter-type=\"requirement\" --not-have-relations=\"verifiedBy\" --short\n\n# Check coverage percentage\nreqvire coverage --json | jq '.summary'\n```\n\n### Find orphaned elements\n```bash\n# Specifications not satisfying any requirement\nreqvire search --filter-type=\"specification\" --not-have-relations=\"satisfy\" --short --json\n\n# Verifications not verifying any requirement\nreqvire search --filter-type=\"verification\" --not-have-relations=\"verify\" --short\n```\n\n### Find unsatisfied test verifications\n```bash\n# Test verifications without implementation (satisfiedBy)\nreqvire search --filter-type=\"test-verification\" --not-have-relations=\"satisfiedBy\" --short\n```\n\n### Understand a feature area\n```bash\n# Start from user requirement, follow derivations\nreqvire model --from \"Feature Name\"\n\n# See all elements in feature's folder\nreqvire search --filter-file=\"**/FeatureName/**\" --short\n```\n\n### Quick model health check\n```bash\n# Validate model and check coverage summary\nreqvire validate && reqvire coverage --json | jq '.summary'\n```\n"
      },
      "plugins": [
        {
          "version": "1.5.0",
          "name": "reqvire",
          "description": "Expert MBSE engineer for system models, specifications and architectures. Use when exploring, updating and refactoring requirements, specifications and system model, adding features, managing verifications and creating tasks from introduced changes in requirements and system model.",
          "author": {
            "name": "Ilija Ljubicic",
            "email": "ilijaljubicic@users.noreply.github.com"
          },
          "repository": "https://github.com/reqvire-org/reqvire",
          "homepage": "https://www.reqvire.org",
          "license": "Apache-2.0",
          "keywords": [
            "mbse",
            "requirements",
            "specifications",
            "context",
            "systems-engineering",
            "verification",
            "traceability",
            "rust"
          ],
          "commands": [
            "./commands/setup.md",
            "./commands/add-feature.md",
            "./commands/analyze-model.md",
            "./commands/lint-model.md",
            "./commands/add-requirement.md",
            "./commands/consolidate.md",
            "./commands/mv-file.md",
            "./commands/add-verification.md",
            "./commands/containment.md",
            "./commands/mv.md",
            "./commands/analyze-coverage.md",
            "./commands/find-redundant-verifications.md",
            "./commands/rename-element.md",
            "./commands/analyze-impact.md",
            "./commands/collect.md",
            "./commands/generate-tasks.md",
            "./commands/rm.md",
            "./commands/link.md",
            "./commands/unlink.md"
          ],
          "skills": [
            "./skills/syseng/"
          ],
          "source": "./claude-plugins",
          "strict": false,
          "categories": [
            "context",
            "mbse",
            "requirements",
            "rust",
            "specifications",
            "systems-engineering",
            "traceability",
            "verification"
          ],
          "install_commands": [
            "/plugin marketplace add reqvire-org/reqvire",
            "/plugin install reqvire@reqvire-org-marketplace"
          ]
        }
      ]
    }
  ]
}