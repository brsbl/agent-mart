{
  "author": {
    "id": "whit3rabbit",
    "display_name": "whit3rabbit",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/12357518?u=7b772347aef2f2aba55d071f29b30d0c90d3a42c&v=4",
    "url": "https://github.com/whit3rabbit",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 0,
      "total_skills": 2,
      "total_stars": 1,
      "total_forks": 2
    }
  },
  "marketplaces": [
    {
      "name": "whit3rabbit-claude-zig-skill",
      "version": null,
      "description": "Zig programming skills for Claude Code - comprehensive language support and async I/O patterns",
      "owner_info": {
        "name": "whit3rabbit",
        "url": "https://github.com/whit3rabbit"
      },
      "keywords": [],
      "repo_full_name": "whit3rabbit/claude-zig-skill",
      "repo_url": "https://github.com/whit3rabbit/claude-zig-skill",
      "repo_description": "Zig skill for Claude Code",
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 2,
        "pushed_at": "2025-12-16T00:33:39Z",
        "created_at": "2025-11-22T13:59:59Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 691
        },
        {
          "path": "zig-async-skill",
          "type": "tree",
          "size": null
        },
        {
          "path": "zig-async-skill/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "zig-async-skill/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 566
        },
        {
          "path": "zig-async-skill/README.md",
          "type": "blob",
          "size": 7952
        },
        {
          "path": "zig-async-skill/SKILL.md",
          "type": "blob",
          "size": 7868
        },
        {
          "path": "zig-programming",
          "type": "tree",
          "size": null
        },
        {
          "path": "zig-programming/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "zig-programming/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 654
        },
        {
          "path": "zig-programming/README.md",
          "type": "blob",
          "size": 9598
        },
        {
          "path": "zig-programming/SKILL.md",
          "type": "blob",
          "size": 13523
        },
        {
          "path": "zig-programming/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "zig-programming/examples/build_example",
          "type": "tree",
          "size": null
        },
        {
          "path": "zig-programming/examples/build_example/README.md",
          "type": "blob",
          "size": 3720
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"whit3rabbit-claude-zig-skill\",\n  \"description\": \"Zig programming skills for Claude Code - comprehensive language support and async I/O patterns\",\n  \"owner\": {\n    \"name\": \"whit3rabbit\",\n    \"url\": \"https://github.com/whit3rabbit\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"zig-programming\",\n      \"source\": \"./zig-programming\",\n      \"description\": \"Comprehensive Zig programming expertise with 223 recipes, multi-version docs (0.2.0-0.15.2+), templates, and examples\"\n    },\n    {\n      \"name\": \"zig-async\",\n      \"source\": \"./zig-async-skill\",\n      \"description\": \"Zig async I/O programming for version 0.16+ with io_uring integration and concurrent task patterns\"\n    }\n  ]\n}\n",
        "zig-async-skill/.claude-plugin/plugin.json": "{\n  \"name\": \"zig-async\",\n  \"description\": \"Zig async I/O programming expertise for version 0.16+. Covers io_uring integration, async/await patterns, concurrent task management, cancellation, and the new I/O model replacing the removed async/suspend/resume.\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"whit3rabbit\",\n    \"url\": \"https://github.com/whit3rabbit\"\n  },\n  \"repository\": \"https://github.com/whit3rabbit/claude-zig-skill\",\n  \"keywords\": [\n    \"zig\",\n    \"async\",\n    \"io_uring\",\n    \"concurrency\",\n    \"async-io\",\n    \"0.16\"\n  ],\n  \"license\": \"MIT\"\n}\n",
        "zig-async-skill/README.md": "# Zig Async I/O Skill (0.16.0+)\n\nA comprehensive Claude skill for Zig's new async I/O design planned for version 0.16.0.\n\n## Overview\n\nThis skill provides expertise in Zig's redesigned async I/O system based on the `std.Io` interface. Unlike the old async/await (removed in 0.11), the new design **decouples concurrency expression from execution models**, allowing code to work optimally across synchronous, multi-threaded, and event-driven contexts.\n\n## Key Concepts\n\n**Critical Distinction: Asynchrony ≠ Concurrency**\n- **Async** (`io.async()`): Operations *can* proceed out-of-order\n- **Concurrent** (`io.concurrent()`): Operations *must* proceed simultaneously\n\n## What's Included\n\n### References (2 files)\n- `async-overview.md` - Complete design philosophy and rationale\n- `async-vs-concurrent.md` - Critical distinction explained with examples\n\n### Examples (3 complete programs)\n- `basic_async.zig` - Simple async operations with io.async()\n- `concurrent_tasks.zig` - Producer-consumer patterns with io.concurrent()\n- `cancellation.zig` - Proper task cancellation and resource cleanup\n\n### Templates (1 comprehensive template)\n- `async-function.zig` - Multiple async function patterns and best practices\n\n## Quick Start\n\n1. **Load the skill** in Claude Code:\n   ```\n   Copy zig-async-io directory to ~/.claude/skills/\n   ```\n\n2. **Start using async patterns**:\n   ```zig\n   const std = @import(\"std\");\n\n   fn processFiles(io: *std.Io, data: []const u8) !void {\n       // Spawn async operations\n       var fut_a = io.async(saveFile, .{io, data, \"a.txt\"});\n       var fut_b = io.async(saveFile, .{io, data, \"b.txt\"});\n\n       // Await results\n       try fut_a.await(io);\n       try fut_b.await(io);\n   }\n   ```\n\n## Design Philosophy\n\nThe new async I/O follows these principles:\n\n1. **No function coloring** - Same code works in sync and async contexts\n2. **Runtime polymorphism** - Choose execution model at runtime\n3. **Zero overhead for sync** - Blocking I/O maps directly to syscalls\n4. **Explicit dependencies** - `concurrent()` makes parallelism requirements clear\n5. **Progressive enhancement** - Start with blocking, upgrade to async later\n\n## Core API\n\n```zig\nconst Io = struct {\n    // Spawn async work (may execute immediately or be scheduled)\n    fn async(self: *Io, func: anytype, args: anytype) Future\n\n    // Spawn concurrent work (requires parallelism)\n    fn concurrent(self: *Io, func: anytype, args: anytype) !Future\n\n    // Message passing primitive\n    fn Queue(comptime T: type) type\n};\n\nconst Future = struct {\n    // Wait for result (idempotent)\n    fn await(self: *Future, io: *Io) !T\n\n    // Cancel and retrieve result (idempotent)\n    fn cancel(self: *Future, io: *Io) !T\n};\n```\n\n## I/O Implementations\n\n1. **Blocking I/O** - Standard syscalls, zero overhead\n2. **Thread Pool** (`std.Io.Threaded`) - Multiplexes across OS threads\n3. **Event Loop** - io_uring/kqueue with green threads (future)\n4. **Stackless Coroutines** - State machine rewriting (future)\n\n## When to Use What\n\n### Use `io.async()` for:\n- Independent operations that can run in any order\n- Optional parallelism\n- Code that should work with blocking I/O\n\n### Use `io.concurrent()` for:\n- Producer-consumer patterns\n- Bidirectional communication\n- Operations that MUST run simultaneously\n\n## Common Patterns\n\n### Pattern 1: Parallel File Operations\n```zig\nvar fut_a = io.async(saveFile, .{io, data, \"a.txt\"});\nvar fut_b = io.async(saveFile, .{io, data, \"b.txt\"});\ntry fut_a.await(io);\ntry fut_b.await(io);\n```\n\n### Pattern 2: Resource Cleanup with Defer\n```zig\nvar future = io.async(operation, .{io});\ndefer if (future.cancel(io)) |result| {\n    cleanup(result);\n} else |_| {};\n\ntry future.await(io);\n```\n\n### Pattern 3: Producer-Consumer\n```zig\nvar queue = io.Queue(Task).init();\n\nvar prod = try io.concurrent(producer, .{io, &queue});\nvar cons = try io.concurrent(consumer, .{io, &queue});\n\ntry prod.await(io);\ntry cons.await(io);\n```\n\n## Version Information\n\n**Target Version**: Zig 0.16.0 (unreleased)\n**Status**: Implementation in progress, API subject to change\n\nBased on:\n- Loris Cro's blog post: \"Zig's New Async I/O\"\n- Andrew Kelley's post: \"Zig's New Async I/O (Text Version)\"\n\n## Migration from Old Async\n\n**Old (pre-0.11)**:\n```zig\nvar frame_a = async saveFile(data, \"a.txt\");\ntry await frame_a;\n```\n\n**New (0.16.0+)**:\n```zig\nvar fut_a = io.async(saveFile, .{io, data, \"a.txt\"});\ntry fut_a.await(io);\n```\n\n## Best Practices\n\n1. **Pass Io explicitly** - Like allocators, pass as parameter not global\n2. **Default to async** - Use `io.async()` unless concurrent truly needed\n3. **Always handle cancellation** - Use defer pattern for cleanup\n4. **Test with blocking I/O first** - Reveals dependency issues early\n5. **Understand async ≠ concurrent** - Critical for correct code\n\n## Examples Included\n\n### basic_async.zig\nDemonstrates:\n- Sequential and parallel async operations\n- Error handling in async code\n- Cleanup with defer\n- Chaining async operations\n- Working with different I/O implementations\n\n### concurrent_tasks.zig\nDemonstrates:\n- Producer-consumer patterns\n- Multiple producers/consumers\n- Worker pool pattern\n- Bidirectional communication\n- Io.Queue for message passing\n\n### cancellation.zig\nDemonstrates:\n- Basic cancellation with defer\n- Resource cleanup on cancellation\n- Timeout patterns\n- Idempotent cancel/await\n- Graceful shutdown\n- Error path cancellation\n\n## References\n\n### async-overview.md (100+ lines)\nComplete design philosophy covering:\n- Problems with old async\n- The new Io interface design\n- Design goals and rationale\n- Comparison with other approaches\n- Future enhancements\n\n### async-vs-concurrent.md (200+ lines)\nDeep dive into the critical distinction:\n- Definition and examples\n- Decision matrix\n- Common mistakes\n- Testing strategies\n- Real-world examples\n\n## Using the Skill\n\nWhen you activate this skill in Claude Code, ask questions like:\n\n- \"How do I write async functions in Zig 0.16?\"\n- \"What's the difference between async and concurrent?\"\n- \"Show me a producer-consumer pattern\"\n- \"How do I handle cancellation properly?\"\n- \"How do I migrate from old async to new async?\"\n\nThe skill provides context-aware assistance based on your needs.\n\n## Contributing\n\nThis skill is based on publicly available blog posts about Zig 0.16.0's planned async design. As the implementation evolves, this skill will be updated to reflect the actual API.\n\n## License\n\nThis skill is provided as-is for educational purposes. Zig and its documentation are subject to their own licenses.\n\n## Additional Resources\n\n- [Zig's New Async I/O - Loris Cro](https://kristoff.it/blog/zig-new-async-io/)\n- [Zig's New Async I/O (Text) - Andrew Kelley](https://andrewkelley.me/post/zig-new-async-io-text-version.html)\n- [Zig GitHub Discussions](https://github.com/ziglang/zig/discussions)\n\n## Status\n\n⚠️ **Pre-release**: This skill targets Zig 0.16.0 which is not yet released. API details may change.\n\nThe skill is ready to use for:\n- Learning the new async design\n- Understanding async/concurrent distinction\n- Preparing for 0.16.0 release\n- Writing forward-compatible async patterns\n\n## File Structure\n\n```\nzig-async-skill/\n├── SKILL.md                      # Main skill file (200 lines)\n├── README.md                     # This file\n├── references/\n│   ├── async-overview.md         # Design philosophy (150 lines)\n│   └── async-vs-concurrent.md    # Critical distinction (250 lines)\n├── examples/\n│   ├── basic_async.zig          # Basic async patterns (230 lines)\n│   ├── concurrent_tasks.zig     # Concurrent patterns (280 lines)\n│   └── cancellation.zig         # Cancellation patterns (300 lines)\n└── assets/\n    └── templates/\n        └── async-function.zig    # Function templates (280 lines)\n```\n\n**Total**: ~1,700 lines of documentation and code examples\n\n---\n\nBuilt with insights from the Zig community and core team blog posts.\n",
        "zig-async-skill/SKILL.md": "---\nname: zig-async-io\ndescription: >\n  Zig 0.16.0 async I/O programming with the new std.Io interface. Covers async/concurrent\n  primitives, Future handling, cancellation patterns, and I/O implementation strategies.\n  Use when working with Zig 0.16.0+ async code, event loops, concurrent tasks, or non-blocking I/O.\n---\n\n# Zig Async I/O Skill (0.16.0+)\n\n## Overview\n\nZig 0.16.0 introduces a redesigned async I/O system based on the `std.Io` interface. Unlike the old async/await (removed in 0.11), the new design **decouples concurrency expression from execution models**, allowing code to work optimally across synchronous, multi-threaded, and event-driven contexts.\n\n**Critical Concept**: **Asynchrony ≠ Concurrency**\n- `async`: Operations *can* proceed out-of-order (sequential awaiting is valid)\n- `concurrent`: Operations *must* proceed simultaneously (requires parallelism)\n\n## Table of Contents\n\n- [Bundled Resources](#bundled-resources)\n- [Core Concepts](#core-concepts)\n- [Workflows](#workflows)\n- [Common Patterns](#common-patterns)\n\n## Bundled Resources\n\n### References\n\n**Fundamentals**:\n- `references/async-overview.md` - New async I/O design philosophy\n- `references/io-interface.md` - std.Io interface and primitives\n- `references/async-vs-concurrent.md` - Critical distinction explained\n\n**Patterns**:\n- `references/future-handling.md` - Future.await() and Future.cancel()\n- `references/resource-management.md` - Defer patterns for async resources\n- `references/io-implementations.md` - Blocking, ThreadPool, EventLoop, Stackless\n\n**Advanced**:\n- `references/message-passing.md` - Io.Queue for synchronization\n- `references/vectorized-io.md` - sendFile() and drain() operations\n- `references/migration-guide.md` - From old async or sync code\n\n### Examples\n\nComplete async I/O demonstrations:\n- `examples/basic_async.zig` - Simple async operations with io.async()\n- `examples/concurrent_tasks.zig` - True concurrency with io.concurrent()\n- `examples/file_operations.zig` - Async file I/O patterns\n- `examples/http_server.zig` - Async HTTP server with event loop\n- `examples/producer_consumer.zig` - Message passing with Io.Queue\n- `examples/cancellation.zig` - Proper task cancellation patterns\n\n### Templates\n\nStarting points for async code:\n- `assets/templates/async-function.zig` - Async function template\n- `assets/templates/async-server.zig` - Async server template\n- `assets/templates/async-client.zig` - Async client template\n- `assets/templates/threaded-io.zig` - Thread pool I/O setup\n\n## Core Concepts\n\n### The std.Io Interface\n\n```zig\nconst Io = struct {\n    /// Spawn async work (may execute immediately or be scheduled)\n    fn async(self: *Io, func: anytype, args: anytype) Future\n\n    /// Spawn concurrent work (fails if parallelism unavailable)\n    fn concurrent(self: *Io, func: anytype, args: anytype) !Future\n\n    /// Message passing primitive\n    fn Queue(comptime T: type) type\n};\n```\n\n### Future Operations\n\n```zig\nconst Future = struct {\n    /// Wait for result (idempotent)\n    fn await(self: *Future, io: *Io) !T\n\n    /// Cancel and retrieve result (idempotent)\n    fn cancel(self: *Future, io: *Io) !T\n};\n```\n\n### I/O Implementations\n\n1. **Blocking I/O** - Standard syscalls, zero overhead\n2. **Thread Pool** - `std.Io.Threaded` multiplexes across OS threads\n3. **Event Loop** - `io_uring`/`kqueue` with green threads (future)\n4. **Stackless Coroutines** - State machine rewriting (future)\n\n## Workflows\n\n### Writing Async Code\n\n1. **Accept Io parameter** - Functions take `io: *std.Io` like allocators\n2. **Spawn async work** - Use `io.async()` for potentially concurrent operations\n3. **Await results** - Call `future.await(io)` when needed\n4. **Handle cancellation** - Use `defer future.cancel(io)` for cleanup\n5. **Choose concurrent carefully** - Only use `io.concurrent()` when simultaneous execution required\n\n### Async vs Concurrent Decision\n\n**Use `io.async()` when:**\n- Operations can proceed in any order\n- Sequential awaiting is acceptable\n- Want to work with blocking I/O implementations\n\n**Use `io.concurrent()` when:**\n- Operations MUST run simultaneously\n- Solving producer-consumer deadlocks\n- Require true parallelism\n\n### Resource Management Pattern\n\n```zig\nvar future = io.async(operation, .{io, args});\ndefer if (future.cancel(io)) |result| {\n    cleanup(result);\n} else |_| {};\n\n// Use future...\ntry future.await(io);\n```\n\nThis single pattern handles both success and failure cases.\n\n## Common Patterns\n\n### Pattern 1: Parallel File Operations\n\n```zig\nfn saveFiles(io: *std.Io, data: []const u8) !void {\n    var fut_a = io.async(saveFile, .{io, data, \"a.txt\"});\n    var fut_b = io.async(saveFile, .{io, data, \"b.txt\"});\n\n    try fut_a.await(io);\n    try fut_b.await(io);\n}\n```\n\n### Pattern 2: Producer-Consumer with Queue\n\n```zig\nvar queue = io.Queue(Task).init();\n\n// Producer\nvar producer = try io.concurrent(produce, .{io, &queue});\n\n// Consumer\nvar consumer = try io.concurrent(consume, .{io, &queue});\n\ntry producer.await(io);\ntry consumer.await(io);\n```\n\n### Pattern 3: Cancellation on Timeout\n\n```zig\nvar work = io.async(longOperation, .{io});\nvar timeout = io.async(sleep, .{io, 5000});\n\nconst result = io.race(&.{work, timeout});\nif (result == 1) { // timeout won\n    _ = work.cancel(io) catch {};\n    return error.Timeout;\n}\n```\n\n### Pattern 4: Passing Io Like Allocator\n\n```zig\npub fn processData(io: *std.Io, allocator: Allocator, data: []const u8) !void {\n    // Use io just like allocator\n    var future = io.async(helper, .{io, allocator, data});\n    try future.await(io);\n}\n```\n\n## Key Differences from Old Async\n\n**Old Model (0.10.x and earlier)**:\n- `async` and `await` keywords\n- Stackless coroutines baked into language\n- Execution model virality\n- Removed in 0.11 for redesign\n\n**New Model (0.16.0+)**:\n- `io.async()` and `future.await(io)` methods\n- Execution model as runtime parameter\n- No function coloring\n- Works with synchronous code\n\n## Migration Guide\n\n**From synchronous code:**\n```zig\n// Before (sync)\ntry saveFile(data, \"a.txt\");\ntry saveFile(data, \"b.txt\");\n\n// After (async)\nvar fut_a = io.async(saveFile, .{io, data, \"a.txt\"});\nvar fut_b = io.async(saveFile, .{io, data, \"b.txt\"});\ntry fut_a.await(io);\ntry fut_b.await(io);\n```\n\n**From old async/await:**\n```zig\n// Before (old async - removed)\nvar frame_a = async saveFile(data, \"a.txt\");\nvar frame_b = async saveFile(data, \"b.txt\");\ntry await frame_a;\ntry await frame_b;\n\n// After (new async)\nvar fut_a = io.async(saveFile, .{io, data, \"a.txt\"});\nvar fut_b = io.async(saveFile, .{io, data, \"b.txt\"});\ntry fut_a.await(io);\ntry fut_b.await(io);\n```\n\n## Best Practices\n\n1. **Pass Io explicitly** - Like allocators, pass as parameter not global\n2. **Default to async** - Use `io.async()` unless concurrent truly needed\n3. **Always handle cancellation** - Use defer pattern for resource cleanup\n4. **Understand async ≠ concurrent** - Async allows out-of-order, concurrent requires simultaneous\n5. **Test with multiple implementations** - Verify code works with Blocking and ThreadPool\n6. **Use Queue for synchronization** - Io.Queue handles producer-consumer patterns\n7. **Avoid blocking in async** - Don't call blocking syscalls directly in async functions\n8. **Leverage idempotency** - await and cancel can be called multiple times safely\n\n## Version Information\n\n**Minimum Zig Version**: 0.16.0 (unreleased as of writing)\n\nThis skill targets the new async I/O design planned for Zig 0.16.0 based on:\n- Loris Cro's blog post: \"Zig's New Async I/O\"\n- Andrew Kelley's post: \"Zig's New Async I/O (Text Version)\"\n\n**Status**: Implementation in progress, API subject to change\n\n## Additional Resources\n\nLoad references for deep dives:\n- `references/async-overview.md` - Complete design philosophy\n- `references/io-implementations.md` - Implementation strategies\n- `references/message-passing.md` - Advanced synchronization\n",
        "zig-programming/.claude-plugin/plugin.json": "{\n  \"name\": \"zig-programming\",\n  \"description\": \"Comprehensive Zig programming expertise with 223 tested recipes from BBQ Cookbook, multi-version documentation (0.2.0 through 0.15.2+), code templates, and practical examples. Includes automatic version detection and version-specific guidance.\",\n  \"version\": \"1.1.0\",\n  \"author\": {\n    \"name\": \"whit3rabbit\",\n    \"url\": \"https://github.com/whit3rabbit\"\n  },\n  \"repository\": \"https://github.com/whit3rabbit/claude-zig-skill\",\n  \"keywords\": [\n    \"zig\",\n    \"programming\",\n    \"language\",\n    \"recipes\",\n    \"reference\",\n    \"templates\",\n    \"build-system\",\n    \"memory-management\"\n  ],\n  \"license\": \"MIT\"\n}",
        "zig-programming/README.md": "# Zig Programming Skill for Claude\n\nComprehensive Zig programming language expertise for Claude, including syntax, standard library, build system, memory management, error handling, and C interoperability.\n\n## Directory Structure\n\nThis directory is the **Zig programming skill** - both source and distribution:\n\n- `zig-programming/` (this directory) - Skill root\n  - `SKILL.md` - Main skill instructions\n  - `references/` - Consolidated documentation (version-specific)\n  - `assets/templates/` - Zig code templates\n  - `examples/` - Example Zig programs\n  - `scripts/` - Runtime scripts (distributed with skill)\n  - `build/` - Build scripts for generating and updating the skill\n  - `.temp/` - Temporary build artifacts (auto-cleaned, gitignored)\n\n**For users**: Install this directory or use `zig-programming.zip`\n**For developers**: Build scripts are in `build/` subdirectory\n\n## Features\n\n- Complete Zig language reference documentation\n- Version detection and multi-version support (0.2.0 through master)\n- Code templates for common tasks\n- Practical examples with full source code\n- Build system and C interop guidance\n- Progressive disclosure for efficient context usage\n\n## Installation\n\n### For Claude Code (Git Installation)\n\n1. Clone this repository or navigate to the zig-programming directory:\n\n```bash\ncd /path/to/zig-docs/zig-programming\n```\n\n2. Create a symlink to your Claude Code skills directory:\n\n```bash\n# On macOS/Linux\nln -s \"$(pwd)/skill\" ~/.claude/skills/zig-programming\n\n# On Windows (run as Administrator)\nmklink /D \"%USERPROFILE%\\.claude\\skills\\zig-programming\" \"%CD%\\skill\"\n```\n\n3. Verify installation:\n\n```bash\nls -la ~/.claude/skills/zig-programming\n# Should show the symlink pointing to your zig-programming directory\n```\n\n4. Restart Claude Code if it's running.\n\n### For Claude Desktop (Zip Installation)\n\n1. Download the packaged skill:\n   - Use the pre-built `zig-programming.zip` file from this repository\n\n2. Locate your Claude skills directory:\n   - **macOS/Linux**: `~/.claude/skills/`\n   - **Windows**: `%USERPROFILE%\\.claude\\skills\\`\n\n3. Extract the zip file:\n\n```bash\n# On macOS/Linux\nunzip zig-programming.zip -d ~/.claude/skills/\n\n# On Windows (PowerShell)\nExpand-Archive -Path zig-programming.zip -DestinationPath \"$env:USERPROFILE\\.claude\\skills\\\"\n```\n\n4. Verify the skill structure:\n\n```bash\nls -la ~/.claude/skills/zig-programming/\n# Should contain: SKILL.md, references/, assets/, examples/, scripts/\n```\n\n5. Restart Claude Desktop.\n\n## Usage\n\nThe skill activates automatically when:\n- Working with Zig code (.zig files)\n- Asking about Zig concepts\n- Debugging Zig compilation errors\n- Building Zig applications\n\n### Example Queries\n\n**Learning Zig**:\n- \"Explain Zig's allocator pattern\"\n- \"How do I handle errors in Zig?\"\n- \"Show me how comptime works\"\n\n**Writing Code**:\n- \"Create a CLI application with argument parsing\"\n- \"Write a function that reads a file with proper error handling\"\n- \"Generate a build.zig for a library project\"\n\n**Debugging**:\n- \"Why am I getting 'expected type X, found Y'?\"\n- \"Help me fix this allocator lifetime issue\"\n- \"Explain this comptime error\"\n\n**Version-Specific**:\n- \"I'm using Zig 0.13, how do I iterate with index?\"\n- \"What changed in the build system from 0.10 to 0.11?\"\n- \"Show me the modern for loop syntax\"\n\n## Version Support\n\nThe skill supports the following Zig versions:\n- Current stable: 0.15.2 (default)\n- Recent versions: 0.14.1, 0.13.0, 0.12.1, 0.11.0\n- Legacy versions: 0.10.1, 0.9.1, 0.8.1, 0.7.1, 0.6.0, 0.3.0, 0.2.0\n- Development: master\n\nThe skill automatically detects your Zig version using:\n1. `zig version` command output\n2. build.zig.zon minimum_zig_version field\n3. build.zig API pattern analysis\n4. Source code syntax markers\n\nYou can also explicitly specify your version in conversation or in your project's CLAUDE.md file.\n\n## Included Resources\n\n### References\n- **Fundamentals**: Core language, control flow, functions, errors\n- **Data & Memory**: Arrays, structs, enums, pointers, allocators\n- **Advanced**: Comptime, patterns, testing, build system\n- **Ecosystem**: Standard library, C interop, version differences\n\n### Templates\n- Basic program with allocator\n- Build configuration (build.zig)\n- Test file structure\n- CLI application\n- Library/module structure\n- C interop module\n\n### Examples\n- String manipulation\n- Memory management patterns\n- Error handling\n- C FFI\n- Compile-time programming\n- Multi-file projects\n\n### Scripts\n- **build_references.py** - Unified build pipeline (recommended)\n- **get_references.py** - Version-aware reference path resolver\n- **detect_version.py** - Zig version detection\n- consolidator.py - Consolidate docs into themes\n- pattern_extractor.py - Extract common patterns\n- code_generator.py - Generate Zig code from specs\n- And more - see `build/README.md`\n\n## Skill Structure\n\n```\nzig-programming/\n├── SKILL.md                    # Main skill instructions\n├── references/                 # Version-specific documentation\n│   ├── v0.15.2/               # References for Zig 0.15.2 (19 files)\n│   │   ├── core-language.md\n│   │   ├── control-flow.md\n│   │   ├── functions-errors.md\n│   │   ├── data-structures.md\n│   │   ├── memory-management.md\n│   │   ├── comptime.md\n│   │   ├── patterns.md\n│   │   ├── idioms.md\n│   │   ├── stdlib-builtins.md\n│   │   ├── build-system.md\n│   │   ├── c-interop.md\n│   │   ├── testing-quality.md\n│   │   ├── quick-reference.md\n│   │   └── [6 more files]\n│   ├── latest -> v0.15.2      # Symlink to current stable\n│   └── version-differences.md # Migration guides (shared)\n├── assets/\n│   └── templates/             # 6+ Zig code templates\n│       ├── basic-program.zig\n│       ├── build.zig\n│       ├── test.zig\n│       └── cross-version/\n│           └── build-adaptive.zig  # Cross-version build (0.11+)\n├── examples/                  # 6+ complete examples\n├── scripts/                   # Runtime scripts (distributed)\n│   ├── get_references.py      # Version-aware reference loader\n│   ├── detect_version.py      # Version detection\n│   └── [other runtime scripts]\n└── build/                     # Build scripts (development only)\n    ├── build_references.py    # ⭐ Unified build pipeline\n    ├── consolidator.py        # Merge docs into themes\n    ├── package_skill.py       # Create distribution zip\n    └── [other build tools]\n```\n\n## Updating the Skill\n\n### From Git Repository\n\nIf you installed via symlink:\n\n```bash\ncd /path/to/zig-docs\ngit pull origin main\n```\n\nThe symlink automatically reflects the updates. Restart Claude Code.\n\n### From Zip File\n\n1. Download the latest zig-programming.zip\n2. Remove the old skill:\n\n```bash\nrm -rf ~/.claude/skills/zig-programming\n```\n\n3. Extract the new version:\n\n```bash\nunzip zig-programming.zip -d ~/.claude/skills/\n```\n\n4. Restart Claude Desktop.\n\n## Troubleshooting\n\n### Skill Not Activating\n\n**Check installation**:\n```bash\nls -la ~/.claude/skills/zig-programming/SKILL.md\n```\n\nIf the file doesn't exist, reinstall the skill.\n\n**Check SKILL.md format**:\n- File must have YAML frontmatter with `name` and `description`\n- Must be valid markdown\n\n**Restart Claude**:\n- Close and reopen Claude Code or Claude Desktop\n\n### Version Detection Not Working\n\n**Manual specification**:\nAdd to your project's CLAUDE.md:\n```markdown\n# CLAUDE.md\nThis project targets Zig 0.15.2\n```\n\n**Run detection script**:\n```bash\ncd ~/.claude/skills/zig-programming/scripts\npython detect_version.py --verbose\n```\n\n### Templates Not Found\n\n**Check directory structure**:\n```bash\nls -la ~/.claude/skills/zig-programming/assets/templates/\n```\n\nShould contain 6 .zig files.\n\n### References Not Loading\n\n**Check file permissions**:\n```bash\nchmod -R 644 ~/.claude/skills/zig-programming/references/*.md\n```\n\n## Contributing\n\nThis skill is part of the zig-docs project. To contribute:\n\n1. Fork the repository\n2. Make your changes\n3. Test the skill thoroughly\n4. Submit a pull request\n\n### Building/Updating the Skill\n\n**For updating documentation to a new Zig version (recommended):**\n\n```bash\ncd zig-programming\npython build/build_references.py --version 0.16.0\n```\n\nThis unified pipeline automatically:\n1. Downloads and converts HTML documentation to markdown\n2. Consolidates into themed references\n3. Cleans up temporary files\n\n**For packaging the skill for distribution:**\n\n```bash\ncd zig-programming\npython build/package_skill.py .\n```\n\nThis validates and repackages the skill into `zig-programming.zip`.\n\n**For manual workflow (advanced):**\n\nSee `build/README.md` for detailed documentation of all available scripts.\n\n## Project Links\n\n- Repository: https://github.com/yourusername/zig-docs\n- Zig Official Documentation: https://ziglang.org/documentation/\n- Zig Repository: https://github.com/ziglang/zig\n\n## License\n\nThis skill is based on official Zig documentation and follows the Zig project's licensing terms.\n\n## Version History\n\n- **1.0.0** - Initial release\n  - Support for Zig 0.2.0 through master (13 versions)\n  - 19 reference files with progressive disclosure\n  - 6 templates, 6 examples\n  - Automatic version detection\n  - Optimized for context efficiency (no content duplication)\n\n## Support\n\nFor issues, questions, or feedback:\n- Open an issue in the GitHub repository\n- Check the troubleshooting section above\n- Review the CLAUDE.md file for project-specific guidance\n",
        "zig-programming/SKILL.md": "---\nname: zig-programming\ndescription: >\n  Provides comprehensive Zig programming language expertise including syntax, standard library,\n  build system, memory management, error handling, and C interoperability. Use this skill when\n  working with Zig code, learning Zig concepts, debugging compilation errors, or building\n  Zig applications across multiple versions (0.2.0 through master).\n---\n\n# Zig Programming Language Skill\n\nThis skill provides expertise in Zig, a general-purpose programming language focused on robustness, optimality, and maintainability. The skill includes version-specific documentation (0.2.0 through master), automatic version detection, code templates, and comprehensive reference materials organized for progressive disclosure.\n\n## Table of Contents\n\n- [Bundled Resources](#bundled-resources)\n  - [References](#references-progressive-loading-guide) - Progressive disclosure documentation\n  - [Recipes](#recipes-cookbook) - 223 tested recipes organized by topic\n  - [Templates](#templates) - Starting points for common tasks\n  - [Examples](#examples) - Practical code samples\n  - [Scripts](#scripts) - Automation tools\n- [Workflows](#workflows)\n- [Version Awareness](#version-awareness)\n- [Best Practices](#best-practices)\n\n## Bundled Resources\n\n### References - Progressive Loading Guide\n\n**Important:** References are version-specific. Use `scripts/get_references.py` to get the correct reference path for the detected Zig version, or load from `references/latest/` (symlink to current stable: 0.15.2).\n\nLoad documentation progressively based on task complexity. Use this decision tree:\n\n**New to Zig?** Start with fundamentals in order:\n1. `references/latest/core-language.md` → Basic syntax, types, operators\n2. `references/latest/control-flow.md` → If, while, for, switch\n3. `references/latest/functions-errors.md` → Functions and error handling\n4. `references/latest/quick-reference.md` → Syntax quick lookup\n\n**Solving specific problems?** Jump directly to:\n- **Error handling** → `latest/functions-errors.md` + `latest/patterns-error-testing.md`\n- **Memory/allocators** → `latest/memory-management.md` + `latest/patterns-memory-comptime.md`\n- **Data structures** → `latest/arrays-slices.md`, `latest/structs-methods.md`, `latest/enums-unions.md`, `latest/pointers-references.md`\n- **Struct/array/enum patterns** → `latest/patterns-data-structures.md`\n- **Stdlib lookup** → grep `latest/stdlib-builtins.md` (large file, 68KB)\n- **C interop** → `latest/c-interop.md` + `latest/patterns-integration.md`\n- **Build system** → `latest/build-system.md` + `latest/patterns-integration.md`\n\n**Advanced topics** (after mastering fundamentals):\n- `references/latest/comptime.md` - Compile-time execution and generics\n- `references/latest/patterns-memory-comptime.md` - Advanced memory and comptime patterns\n- `references/latest/testing-quality.md` - Testing framework and best practices\n\n**Version migration** → `references/version-differences.md` (shared across versions, comprehensive migration guides)\n\n**Using version-specific references:**\n```bash\n# Get reference path for detected version\npython scripts/get_references.py\n# Output: references/v0.15.2\n\n# With specific version\npython scripts/get_references.py --version 0.13.0\n# Output: references/v0.15.2 (with fallback warning)\n\n# JSON output for programmatic use\npython scripts/get_references.py --json\n```\n\n### Recipes - Cookbook\n\nThe skill includes **223 tested recipes** from the Zig BBQ Cookbook, organized by topic. All recipes include complete, compilable code verified against Zig 0.15.2.\n\n**Finding recipes by topic:**\n- `recipes/fundamentals.md` - Philosophy, basics (19 recipes)\n- `recipes/data-structures.md` - Arrays, hashmaps, sets (20 recipes)\n- `recipes/strings-text.md` - String processing (14 recipes)\n- `recipes/memory-allocators.md` - Allocator patterns (6 recipes)\n- `recipes/comptime-metaprogramming.md` - Compile-time (24 recipes)\n- `recipes/structs-objects.md` - Structs, unions (22 recipes)\n- `recipes/functions.md` - Function patterns (11 recipes)\n- `recipes/files-io.md` - File operations (19 recipes)\n- `recipes/networking.md` - HTTP, sockets (18 recipes)\n- `recipes/concurrency.md` - Threading, atomics (8 recipes)\n- `recipes/build-system.md` - Build.zig, modules (18 recipes)\n- `recipes/testing-debugging.md` - Testing (14 recipes)\n- `recipes/c-interop.md` - C FFI (7 recipes)\n- `recipes/data-encoding.md` - JSON, CSV, XML (9 recipes)\n- `recipes/iterators.md` - Iterator patterns (8 recipes)\n- `recipes/webassembly.md` - WASM targets (6 recipes)\n\n**Querying recipes programmatically:**\n```bash\n# List all topics with counts\npython scripts/query_recipes.py --list-topics\n\n# Find recipes by topic\npython scripts/query_recipes.py --topic memory-allocators\n\n# Find recipes by tag\npython scripts/query_recipes.py --tag hashmap\n\n# Search by keyword\npython scripts/query_recipes.py --search \"error handling\"\n\n# Get specific recipe details\npython scripts/query_recipes.py --recipe 1.1\n\n# Filter by difficulty\npython scripts/query_recipes.py --difficulty beginner\n\n# JSON output for programmatic use\npython scripts/query_recipes.py --topic data-structures --json\n```\n\n**Recipe format:** Each recipe includes Problem, Solution, Discussion sections plus full tested code.\n\n**When to use recipes vs references:**\n- **Recipes**: \"How do I...\" questions, practical tasks, working code examples\n- **References**: \"What is...\" questions, API lookup, comprehensive documentation\n\n### Templates\n\nCopy and customize these starting points:\n- `assets/templates/basic-program.zig` - Basic program with allocator\n- `assets/templates/build.zig` - Build configuration\n- `assets/templates/test.zig` - Test file structure\n- `assets/templates/cli-application.zig` - CLI app with arg parsing\n- `assets/templates/library-module.zig` - Library/module structure\n- `assets/templates/c-interop-module.zig` - C interop module\n\n### Examples\n\nComplete, runnable code demonstrating patterns:\n- `examples/string_manipulation.zig` - String processing\n- `examples/memory_management.zig` - Allocator patterns\n- `examples/error_handling.zig` - Error handling\n- `examples/c_interop.zig` - C FFI\n- `examples/comptime_example.zig` - Compile-time programming\n- `examples/build_example/` - Multi-file project\n\n### Scripts\n\nUse these Python automation tools for version management, recipe queries, and code generation:\n\n**Version Detection & Reference Loading:**\n- `scripts/get_references.py` - Detect user's Zig version and return correct reference path (use this first)\n- `scripts/detect_version.py` - Standalone version detection with confidence levels\n\n**Recipe Queries:**\n- `scripts/query_recipes.py` - Search and filter recipes by topic, tag, difficulty, or keyword\n\n**Code Generation:**\n- `scripts/code_generator.py` - Generate Zig code from JSON specifications\n\n**When to execute vs reference:**\n- **Execute** `get_references.py` at the start of any Zig task to determine the correct reference path\n- **Execute** `query_recipes.py` when searching for practical code examples or solutions\n- **Reference** other scripts only when the user explicitly requests code generation or version management tasks\n- Most scripts are for skill maintenance, not routine usage\n\nSee `scripts/README.md` for complete script documentation.\n\n## Workflows\n\n### Writing New Code\n\n1. **Start from template** - Copy appropriate template from `assets/templates/`\n2. **Check version** - Default to Zig 0.15.2 unless specified\n3. **Handle errors explicitly** - Use `try`, `catch`, or `errdefer`\n4. **Pass allocators** - Never use global state, pass allocators as parameters\n5. **Add tests immediately** - Write `test` blocks alongside implementation\n6. **Document public APIs** - Use `///` doc comments for exported functions\n\n### Debugging Compilation Errors\n\n**Zig-specific gotchas:**\n- **Comptime type resolution** → Use `@TypeOf()` inspection or add explicit casts\n- **Allocator lifetime issues** → Verify `defer` cleanup order and `errdefer` on error paths\n- **Optional unwrapping** → Use `.?` only when certain; prefer `orelse` or `if` unwrap for safety\n\n**Debug tools:** `std.debug.print()` for inspection, `-Doptimize=Debug` for stack traces, `zig test` to isolate issues\n\n### Explaining Concepts\n\nTo teach Zig concepts effectively:\n1. **Load relevant reference** - Start with the appropriate reference file for the topic\n2. **Show runnable code** - Use complete examples from `examples/` directory\n3. **Highlight uniqueness** - Emphasize Zig's distinguishing features (explicit allocators, comptime, no hidden control flow)\n4. **Reference stdlib** - Point to specific standard library functions when applicable\n\n## Version Awareness\n\n**Default to Zig 0.15.2** unless user specifies otherwise or detection determines a different version.\n\n### Version Detection Workflow\n\nAt the start of any Zig task, determine the user's version using this workflow:\n\n**1. Check for explicit specification:**\n- User stated version in current conversation (\"I'm using Zig 0.13\")\n- CLAUDE.md project file contains Zig version specification\n- `build.zig.zon` has `minimum_zig_version` field\n\n**2. Automated detection (recommended):**\n```bash\n# Run get_references.py to detect version and get correct reference path\npython scripts/get_references.py --json\n```\nThis script:\n- Runs `scripts/detect_version.py` to analyze the project\n- Attempts `zig version` command (most reliable)\n- Scans `build.zig` and `.zig` files for version markers\n- Returns reference path and version info with confidence level\n- Handles fallbacks automatically (e.g., 0.14.1 → use 0.15.2 refs)\n\n**3. Manual detection (if automated fails):**\n- Scan `build.zig` for API patterns:\n  - `b.path(...)` → 0.11+\n  - `std.Build` → 0.11+\n  - `b.addExecutable(.{...})` → 0.11+\n  - `b.addExecutable(\"name\", \"file\")` → pre-0.11\n- Check `.zig` files for syntax markers:\n  - `for (items, 0..) |item, i|` → 0.13+\n  - `async`/`await` keywords → 0.9-0.10 (removed in 0.11)\n- Load `references/version-differences.md` for full detection markers\n\n**4. Ask user if ambiguous:**\n- \"I detected you might be using Zig 0.13+ based on your build.zig. Can you confirm your version?\"\n- Offer common versions: 0.15.2 (stable), 0.14.1, 0.13.0, master (development)\n\n**5. Default to 0.15.2:**\n- Use current stable if no detection succeeds\n- Inform user: \"Assuming Zig 0.15.2. Let me know if you're using a different version.\"\n\n### Loading Version-Specific References\n\n**After detecting version:**\n1. Use `scripts/get_references.py` to determine correct reference path\n2. Load references from that version directory (e.g., `references/v0.15.2/`)\n3. Always load `references/version-differences.md` (shared file) for migration guidance\n\n**Example workflow:**\n```bash\n# Detect version and get reference path\nREF_PATH=$(python scripts/get_references.py)\n# REF_PATH is now \"references/v0.15.2\" or \"references/latest\"\n\n# Load version-specific documentation\ncat $REF_PATH/core-language.md\ncat $REF_PATH/build-system.md\n\n# Version differences is shared across all versions\ncat references/version-differences.md\n```\n\n**Handling fallbacks:**\n- If exact version not available (e.g., 0.14.1), script returns closest match (0.15.2) with warning\n- Warnings indicate major differences (e.g., \"for loop syntax differs from 0.13+\")\n- Always check fallback warnings to understand version compatibility\n\n### Critical Breaking Changes\n\nBe aware of these major version differences when writing code:\n\n- **0.11+**: Async/await removed, new build.zig API (`std.Build`, `b.path()`)\n- **0.13+**: Modern for loop syntax (`for (items, 0..) |item, i|`)\n- **0.12-**: Different for loop syntax (manual index variables)\n- **Pre-0.11**: Legacy build API (`std.build.Builder`), different error sets\n\n**See `references/version-differences.md` for:**\n- Detailed migration guides (0.10→0.11, 0.12→0.13, 0.13→0.15)\n- Error message translations\n- Before/after code examples\n- Breaking changes catalog\n\n### Handling Different Versions\n\n**When user specifies or detection determines a different version:**\n1. Run `scripts/get_references.py --version <VERSION>` to get correct reference path\n2. Load `references/version-differences.md` for migration details\n3. Use version-specific references from the returned path\n4. Adapt code patterns to the user's version\n5. Flag deprecated features if using older version\n6. Recommend modern alternatives when possible\n\n**Best practice for cross-version code:**\n- Prefer feature detection over version checks: `@hasDecl(std, \"Build\")` instead of `if (version >= 0.11)`\n- See `references/latest/patterns-integration.md` for `@hasDecl`/`@hasField` examples\n- Document target version in code comments: `// Target Zig Version: 0.15.2`\n- For cross-version templates, see `assets/templates/cross-version/`\n\n## Best Practices\n\nCore Zig idioms:\n\n1. **Explicit error handling** - Use `try`, `catch`, or error unions; never ignore errors\n2. **Defer cleanup** - Use `defer` for cleanup, `errdefer` for error-path cleanup\n3. **Pass allocators** - Never use global state; pass allocators explicitly as parameters\n4. **Leverage comptime** - Use compile-time execution for generic programming\n5. **Write tests inline** - Use `test \"description\" {}` blocks alongside implementation\n6. **Document public APIs** - Add `///` doc comments for exported functions\n7. **Handle optionals explicitly** - Use `orelse`, `.?`, or `if` unwrapping\n8. **No hidden control flow** - Zig has no hidden allocations, exceptions, or async",
        "zig-programming/examples/build_example/README.md": "# Multi-File Zig Project Example\n\nThis example demonstrates a complete multi-file Zig project with:\n- Module organization\n- Build system configuration\n- Cross-module imports\n- Comprehensive testing\n- Library creation\n\n## Project Structure\n\n```\nbuild_example/\n├── build.zig              # Build configuration\n├── README.md              # This file\n└── src/\n    ├── main.zig           # Main entry point\n    ├── math_utils.zig     # Math operations module\n    └── string_utils.zig   # String operations module\n```\n\n## Modules\n\n### math_utils.zig\nProvides mathematical operations:\n- Basic arithmetic (add, subtract, multiply, divide)\n- Factorial calculation\n- Prime number checking\n- Greatest common divisor (GCD)\n\n### string_utils.zig\nProvides string operations:\n- Character counting\n- Prefix/suffix checking\n- Case conversion (upper/lower)\n- String reversal\n- Trimming whitespace\n- Numeric and palindrome checking\n\n### main.zig\nDemonstrates using both modules together with practical examples.\n\n## Building and Running\n\n### Build the executable\n```bash\nzig build\n```\n\n### Build and run\n```bash\nzig build run\n```\n\n### Run all tests\n```bash\nzig build test\n```\n\n### Build the math library\n```bash\nzig build lib\n```\n\n## Build System Features\n\nThe `build.zig` file demonstrates:\n\n1. **Executable creation** - Compiles src/main.zig into an executable\n2. **Test targets** - Creates test executables for each module\n3. **Library creation** - Builds a static library from math_utils\n4. **Custom build steps** - Defines `run`, `test`, and `lib` steps\n5. **Target and optimization** - Configurable cross-compilation and optimization\n\n## Key Concepts Demonstrated\n\n### Module Imports\n```zig\nconst math = @import(\"math_utils.zig\");\nconst strings = @import(\"string_utils.zig\");\n```\n\n### Public API Design\nAll public functions use `pub fn` to export them to other modules.\n\n### Testing Strategy\n- Each module has its own unit tests\n- Main module includes integration tests\n- All tests run with `zig build test`\n\n### Memory Management\nFunctions that allocate memory:\n- Accept an `Allocator` parameter\n- Caller is responsible for freeing\n- Use `defer` for cleanup\n\n### Error Handling\nFunctions that can fail return error unions (`!T`).\n\n## Learning Path\n\n1. **Start with modules** - Read `math_utils.zig` and `string_utils.zig`\n2. **Understand imports** - See how `main.zig` imports and uses modules\n3. **Study build.zig** - Learn build system configuration\n4. **Run tests** - Execute `zig build test` to see testing in action\n5. **Modify and extend** - Add new functions or modules\n\n## Common Patterns\n\n### Creating a new module\n\n1. Create a new .zig file in `src/`\n2. Define public functions with `pub fn`\n3. Import in main.zig: `const mymod = @import(\"mymod.zig\");`\n4. Add test target in build.zig\n\n### Adding tests\n\n```zig\nconst testing = std.testing;\n\ntest \"description\" {\n    try testing.expectEqual(expected, actual);\n}\n```\n\n### Exporting functionality\n\n```zig\npub fn myFunction(param: Type) ReturnType {\n    // Implementation\n}\n```\n\n## Output Example\n\nWhen you run `zig build run`, you'll see:\n\n```\n=== Multi-File Zig Project Example ===\n\n=== Math Utilities ===\n5 + 3 = 8\n5 - 3 = 2\n5 * 3 = 15\n15 / 3 = 5\nFactorial of 5 = 120\nIs 17 prime? true\nGCD of 12 and 18 = 6\n\n=== String Utilities ===\nTest string: 'Hello, Zig!'\nCount of 'l': 2\nStarts with 'Hello': true\nEnds with 'Zig!': true\nUppercase: HELLO, ZIG!\nLowercase: hello, zig!\nReversed: !giZ ,olleH\n...\n```\n\n## Next Steps\n\n- Add more modules for different functionality\n- Implement a CLI with argument parsing\n- Create a library that can be used by other projects\n- Add benchmarks for performance testing\n- Integrate with external C libraries\n"
      },
      "plugins": [
        {
          "name": "zig-programming",
          "source": "./zig-programming",
          "description": "Comprehensive Zig programming expertise with 223 recipes, multi-version docs (0.2.0-0.15.2+), templates, and examples",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add whit3rabbit/claude-zig-skill",
            "/plugin install zig-programming@whit3rabbit-claude-zig-skill"
          ]
        },
        {
          "name": "zig-async",
          "source": "./zig-async-skill",
          "description": "Zig async I/O programming for version 0.16+ with io_uring integration and concurrent task patterns",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add whit3rabbit/claude-zig-skill",
            "/plugin install zig-async@whit3rabbit-claude-zig-skill"
          ]
        }
      ]
    }
  ]
}