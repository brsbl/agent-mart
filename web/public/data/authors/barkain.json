{
  "author": {
    "id": "barkain",
    "display_name": "Nadav Barkai",
    "avatar_url": "https://avatars.githubusercontent.com/u/15982465?u=c7d363b31578b9364b98d06c908ef537bddc3bd6&v=4"
  },
  "marketplaces": [
    {
      "name": "barkain-plugins",
      "version": null,
      "description": "Delegation system with workflow orchestration, specialized agents, and parallel execution for Claude Code",
      "repo_full_name": "barkain/claude-code-workflow-orchestration",
      "repo_url": "https://github.com/barkain/claude-code-workflow-orchestration",
      "repo_description": null,
      "signals": {
        "stars": 21,
        "forks": 4,
        "pushed_at": "2026-02-14T21:27:30Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"barkain-plugins\",\n  \"owner\": {\n    \"name\": \"Nadav Barkai\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"workflow-orchestrator\",\n      \"source\": \"./\",\n      \"description\": \"Delegation system with workflow orchestration, specialized agents, and parallel execution for Claude Code\",\n      \"version\": \"1.10.0\",\n      \"author\": {\n        \"name\": \"Nadav Barkai\"\n      },\n      \"repository\": \"https://github.com/barkain/claude-code-workflow-orchestration\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"delegation\", \"workflow\", \"orchestration\", \"agents\"],\n      \"category\": \"productivity\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"workflow-orchestrator\",\n  \"version\": \"1.10.0\",\n  \"description\": \"Delegation system with workflow orchestration, specialized agents, and parallel execution for Claude Code\",\n  \"author\": {\n    \"name\": \"Nadav Barkai\"\n  },\n  \"repository\": \"https://github.com/barkain/claude-code-workflow-orchestration\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"delegation\", \"workflow\", \"orchestration\", \"agents\"],\n  \"outputStyles\": \"./output-styles/\",\n  \"hooks\": \"./hooks/plugin-hooks.json\"\n}\n",
        "README.md": "# Claude Code Workflow Orchestration System\n\nA hook-based framework for Claude Code that enforces task delegation to specialized agents, enabling structured workflows and expert-level task handling through intelligent orchestration.\n\nSee the delegation system in action:\n\n<img src=\"./assets/workflow-demo.gif\" alt=\"Workflow Demo\" width=\"800\">\n\n## üÜï What's New\n\nü§ù **Agent Teams Integration** ‚Äî Native dual-mode execution: workflows automatically select between isolated subagents and collaborative Agent Teams (via `TeamCreate` + `Task(team_name=...)` + `SendMessage`) based on task complexity scoring. Teammates communicate in real-time, share task lists, and self-coordinate. Enable with `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`.\n\n‚ö° **Statusline Performance** ‚Äî Cold start optimized from ~28s to <0.1s through merged API calls and non-blocking background cache refresh.\n\n## Overview\n\nThis system uses Claude Code's hook mechanism to create a delegation-enforced workflow architecture that routes tasks to specialized agents for expert-level execution.\n\n### Key Features\n\n- **Enforced Delegation** - PreToolUse hooks block direct tool usage, forcing delegation to specialized agents\n- **8 Specialized Agents** - Each agent has domain expertise (code cleanup, testing, architecture, DevOps, etc.)\n- **Native Plan Mode** - Built-in plan mode (EnterPlanMode/ExitPlanMode) handles planning, agent selection, and execution orchestration\n- **Intelligent Multi-Step Workflows** - Sequential execution for dependent phases, parallel for independent phases\n- **Dual-Mode Execution** - Isolated subagent sessions (default) or collaborative Agent Teams with real-time inter-agent communication (experimental)\n- **Agent Teams Integration** - Native `TeamCreate` + `Task(team_name=...)` + `SendMessage` for peer-to-peer collaboration, shared task lists, and coordinated multi-agent workflows\n- **Tasks API Integration** - Native task tracking via TaskCreate, TaskUpdate, TaskList, TaskGet with structured metadata\n- **Structured Task Metadata** - Wave assignments, phase IDs, agent assignments, and dependencies encoded in task metadata\n- **Async Hook Support** - Non-blocking background tasks for reminders and cleanup operations\n- **Stateful Session Management** - Fresh delegation enforcement per user message with session registry\n- **Smart Dependency Analysis** - Automatically analyzes phase dependencies to determine optimal execution mode\n- **Parallel Execution Support** - Executes independent phases concurrently with automatic wave synchronization\n- **Visualization & Debugging** - Comprehensive logging and debug tools for understanding delegation decisions\n\n### Execution Model\n\nThe system uses a two-stage execution pipeline:\n\n**Stage 0: Planning & Analysis (native plan mode)**\n- Analyzes task complexity (single-step vs multi-step)\n- Decomposes complex tasks into atomic phases\n- Performs dependency analysis to determine execution mode\n- Assigns specialized agents via keyword matching\n- Creates wave assignments for parallel/sequential execution\n- Creates tasks via TaskCreate with structured metadata\n\n**Stage 1: Execution**\n- **Single-Step Tasks:** Hook blocks tools ‚Üí Delegates to specialized agent ‚Üí Agent executes ‚Üí Results returned\n- **Multi-Step Workflows:**\n  - **Subagent mode (default):** Isolated parallel Task instances per wave. Agents return `DONE|{path}`. Context-efficient, optimal for most workflows.\n  - **Team mode (experimental):** Native Agent Teams via `TeamCreate` + `Task(team_name=...)`. Teammates share context, communicate via `SendMessage`, and self-coordinate through shared task lists. Requires `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`.\n- Results consolidated and summary provided\n\n**Execution Mode Selection:** Plan mode calculates a `team_mode_score` to choose between subagent mode (isolated, context-efficient) and team mode (collaborative, real-time communication). For subagent mode, it further selects sequential (context preservation, dependencies) or parallel (time savings, independence) based on phase dependency analysis.\n\n\n## Quick Start\n\n### Prerequisites\n\n#### macOS / Linux\n- uv: https://docs.astral.sh/uv/getting-started/installation/\n```bash\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n```\n\n- bun: https://bun.com/docs/installation\n```bash\ncurl -fsSL https://bun.com/install | bash\n```\n\n- jq: JSON processor for parallel workflow state tracking.\n```bash\n# macOS\nbrew install jq\n# Linux\nsudo apt install jq\n```\n\n#### Windows\n\n**Python 3.12+** is required. All hooks use cross-platform Python scripts.\n\n- Python: https://www.python.org/downloads/\n  - During installation, ensure \"Add Python to PATH\" is checked\n  - Verify installation: `python --version`\n\n- uv: https://docs.astral.sh/uv/getting-started/installation/\n```powershell\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n```\n\n- bun: https://bun.sh/docs/installation\n```powershell\npowershell -c \"irm bun.sh/install.ps1 | iex\"\n```\n\n- jq (optional, for advanced parallel workflow features):\n```powershell\n# Using Chocolatey\nchoco install jq\n# Or download from https://jqlang.github.io/jq/download/\n```\n\n**Note:** The hook system uses Python scripts for cross-platform compatibility. Ensure `python` is available in your PATH.\n\n## Installation\n\nThis project provides a comprehensive delegation system for Claude Code with multi-agent orchestration. Choose your preferred installation method:\n\n### üîå Plugin Installation (Recommended)\n\nThe easiest way to install is via Claude Code's plugin system:\n\n```bash\n# Add the marketplace\nclaude plugin marketplace add barkain/claude-code-workflow-orchestration\n\n# Install the plugin\nclaude plugin install workflow-orchestrator@barkain-plugins  # user-level\n# or\nclaude plugin install workflow-orchestrator@barkain-plugins --scope project  # project-level\n```\n\n**Benefits:**\n- Automatic setup and configuration\n- Easy updates via plugin manager\n- No manual file copying required\n\n**Optional Settings:**\n- Run `/workflow-orchestrator:add-statusline` after installation to enable workflow status display\n- The plugin includes a `technical-adaptive` output style optimized for workflow orchestration. To select it, configure `outputStyle` in your Claude Code settings (project or user level)\n\n**Note:** Changing the output style requires restarting your Claude Code session for the change to take effect.\n\n### üî® Manual Installation\n\nFor development or custom configurations:\n\n```bash\n# Clone the repository\ngit clone https://github.com/barkain/claude-code-workflow-orchestration.git\n```\n\n#### Project-Specific Installation (Recommended)\n\nFor project-isolated configurations or version-controlled delegation setups:\n\n```bash\ncd path/to/project\npath/to/repo/install.sh  # follow the installation instructions\n```\n\n**Windows users:** The `install.sh` script requires bash (Git Bash or WSL). For Windows, we recommend using the **Plugin Installation** method above, which works natively on all platforms.\n\n## Example Usage - Multi-Step Workflow\n\nOnce installed, the delegation hook is automatically active. Simply use Claude Code normally (Opus 4.5 is preferred):\n\n```bash\n# Multi-step workflow - enable orchestration for context passing\nclaude\n```\nand then prompt claude with:\n```text\n> create a simple calculator app with basic math operations.\n  add a nice UI and use NextJS/Tailwind to build this out.\n  the backend should be implemented in python as a modern uv project.\n  add verification steps after each phase.\n  add ralph loop as a final verification step\n```\n\n**What happens:**\n1. First, the main agent enters native plan mode (EnterPlanMode) to:\n   - Analyze task complexity (single-step vs multi-step)\n   - Decompose into atomic subtasks\n   - Assign specialized agents via keyword matching\n   - Create wave assignments for parallel/sequential execution\n   - Create tasks via TaskCreate and generate the execution plan\n\n   ![img_delegate.png](assets/img_delegate.png)\n\n2. Once plan mode completes (ExitPlanMode), a task dependency graph is rendered and the user request is decomposed into parallel atomic subtasks:\n\n    ![img_dependancy_graph.png](assets/img_dependancy_graph.png)\n\n3. Then, the sequential workflow with parallel subtasks can be initiated:\n   - wave 0:\n\n   ![img_wave0.png](assets/img_wave0.png)\n\n   - wave 1:\n\n   ![img_wave1.png](assets/img_wave1.png)\n\n4. Claude's native todo list is also getting updated in each step:\n\n    ![img_toto_list.png](assets/img_todo_list.png)\n\n### Emergency Bypass\n\nTemporarily disable delegation enforcement if needed:\n\n```bash\n# From terminal (before starting Claude Code)\nexport DELEGATION_HOOK_DISABLE=1\n\n# From within a Claude Code session (interactive toggle)\n/bypass\n```\n\nThe `/bypass` command allows toggling delegation enforcement on/off from within a Claude Code session without restarting.\n\n## Environment Variables\n\nThe system supports several environment variables for configuration and debugging:\n\n**Tasks API Configuration:**\n```bash\nCLAUDE_CODE_ENABLE_TASKS=true              # Enable Tasks API (default: true)\nCLAUDE_CODE_TASK_LIST_ID=list_id           # Share task list across sessions\nCLAUDE_CODE_DISABLE_BACKGROUND_TASKS=1     # Disable async background tasks\n```\n\n**Agent Teams (Experimental):**\n```bash\nCLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1     # Enable Agent Teams dual-mode execution\n```\n\n**Debug & Control:**\n```bash\nDEBUG_DELEGATION_HOOK=1                    # Enable hook debug logging\nDELEGATION_HOOK_DISABLE=1                  # Emergency bypass (disable enforcement)\nCLAUDE_MAX_CONCURRENT=8                    # Max parallel agents per batch (default 8)\nCHECK_RUFF=0                               # Skip Ruff validation in PostToolUse\nCHECK_PYRIGHT=0                            # Skip Pyright validation in PostToolUse\nCLAUDE_SKIP_PYTHON_VALIDATION=1            # Skip all Python validation\n```\n\nSee [Environment Variables](./docs/environment-variables.md) for detailed configuration.\n\n## Setup Details\n\n### Hook Configuration\n\nThe `plugin-hooks.json` configures the delegation enforcement hooks using cross-platform Python scripts:\n\n```json\n{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [{\"type\": \"command\", \"command\": \"uv run --no-project --script \\\"${CLAUDE_PLUGIN_ROOT}/hooks/PreToolUse/require_delegation.py\\\"\"}]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [{\"type\": \"command\", \"command\": \"uv run --no-project --script \\\"${CLAUDE_PLUGIN_ROOT}/hooks/UserPromptSubmit/clear-delegation-sessions.py\\\"\"}]\n      }\n    ]\n  }\n}\n```\n\n**Note:** All hooks use `uv run --no-project --script` for cross-platform compatibility (Windows, macOS, Linux). The `--no-project` flag allows execution without requiring a pyproject.toml, and `--script` directly runs Python scripts using uv's managed interpreter.\n\n**PreToolUse Hook**: Intercepts every tool call and enforces delegation policy\n**UserPromptSubmit Hook**: Clears delegation state between user prompts to ensure fresh enforcement\n**SessionStart Hook**: Automatically appends workflow_orchestrator system prompt for seamless multi-step workflow detection\n\n### workflow_orchestrator Requirements\n\nMulti-step workflow orchestration requires the workflow_orchestrator system prompt to be appended:\n\n**Automatic (via SessionStart hook):**\n```json\n{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"append_system_prompt\",\n            \"path\": \"system-prompts/workflow_orchestrator.md\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**What this enables:**\n- Multi-step task detection via pattern matching\n- Dependency analysis for execution mode selection\n- Context passing between workflow phases\n- Tasks API integration for progress tracking\n- Wave synchronization for parallel execution\n\n\n## Core Components\n\n### 1. Delegation Hook (`hooks/PreToolUse/require_delegation.py`)\n\nBlocks most tools and forces delegation to specialized agents. Cross-platform Python implementation.\n\n**Allowed tools:**\n- `AskUserQuestion` - Ask users for clarification\n- `TaskCreate`, `TaskUpdate`, `TaskList`, `TaskGet` - Track task progress with structured metadata\n- `Skill`, `SlashCommand` - Execute slash commands (including `/delegate`)\n- `Task`, `SubagentTask`, `AgentTask` - Spawn subagents\n\n**Note:** `TaskOutput` is prohibited to prevent context exhaustion. Agents write to `$CLAUDE_SCRATCHPAD_DIR` and return `DONE|{path}` only.\n\n**All other tools are blocked** and show:\n```\nüö´ Tool blocked by delegation policy\n‚úÖ REQUIRED: Use /delegate command immediately\n```\n\n### 2. Specialized Agents (`agents/`)\n\n8 specialized agents for different task types:\n\n- **tech-lead-architect** - Solution design, architecture, research\n- **codebase-context-analyzer** - Code exploration, architecture analysis\n- **task-completion-verifier** - Validation, testing, quality assurance\n- **code-cleanup-optimizer** - Refactoring, technical debt reduction\n- **code-reviewer** - Code review for best practices\n- **devops-experience-architect** - Infrastructure, deployment, CI/CD\n- **documentation-expert** - Documentation creation and maintenance\n- **dependency-manager** - Dependency management and updates\n\n**Note:** The `delegation-orchestrator` agent has been deprecated. Its orchestration and routing functionality is now provided by native plan mode (EnterPlanMode/ExitPlanMode), which handles both planning and execution orchestration directly within the main agent.\n\n### 3. Breadth Reader Skill (`skills/breadth-reader/`)\n\nFor read-only breadth tasks (explore, review, summarize), the `breadth-reader` skill provides optimized handling:\n\n```bash\n/breadth-reader explore ~/dev/project/\n```\n\n- Runs in forked context (isolated from main agent)\n- Claude auto-optimizes parallelism internally\n- Returns summary only to main agent\n- No orchestration overhead\n\n### 4. Delegation Command (`commands/delegate.md`)\n\nThe `/delegate` command provides intelligent task delegation with integrated planning:\n\n```bash\n/delegate <task description>\n```\n\n**How it works:**\n1. Enters native plan mode (EnterPlanMode) for unified planning and orchestration\n2. Plan mode analyzes task complexity and decomposes into phases\n3. Performs dependency analysis to determine execution mode (sequential or parallel)\n4. Assigns specialized agents via keyword matching (>=2 match threshold)\n5. Creates wave assignments and execution plan\n6. Creates task list via TaskCreate\n7. Exits plan mode (ExitPlanMode) and executes phases as directed by the plan\n\n### 5. Workflow Orchestration System Prompt (`system-prompts/workflow_orchestrator.md`)\n\nEnables multi-step workflow detection and preparation for complex tasks. Works in conjunction with native plan mode (EnterPlanMode/ExitPlanMode).\n\n**Activate via:**\nSimply start a Claude code session\n```bash\nclaude\n```\n\n**Multi-step detection patterns:**\n- Sequential connectors: \"and then\", \"after that\", \"next\"\n- Compound indicators: \"with [noun]\", \"including [noun]\"\n- Multiple verbs: \"create X and test Y\"\n\n**Unified Planning & Execution:**\nNative plan mode (EnterPlanMode/ExitPlanMode) handles both planning and execution orchestration:\n\n1. **Task Decomposition** - Breaks complex tasks into atomic phases\n2. **Dependency Analysis** - Analyzes phase dependencies to determine optimal execution mode\n3. **Intelligent Execution Mode Selection** - Chooses between sequential and parallel execution\n4. **Sequential Execution** - Dependent phases execute one at a time with context passing\n5. **Parallel Execution** - Independent phases execute concurrently in waves\n6. **Progress Tracking** - Tasks API maintains visible task list throughout\n7. **State Management** - Wave synchronization ensures proper completion order\n\n**Execution mode decision logic:**\n- **Sequential:** When phases have data dependencies, file conflicts, or state conflicts requiring ordered execution\n- **Parallel:** When phases are independent with no data dependencies, enabling time-efficient concurrent execution\n- **Conservative fallback:** Sequential is chosen when dependencies are uncertain\n\n**Complete workflow process:**\n1. User submits multi-step task (detected by workflow_orchestrator patterns)\n2. Native plan mode entered (EnterPlanMode) to decompose and plan execution\n3. Task list created via TaskCreate with all phases\n4. Phase dependencies analyzed to determine execution mode\n5. **Sequential Mode:** Phases execute one at a time with context passing\n6. **Parallel Mode:** Independent phases grouped into waves and executed concurrently\n7. Wave synchronization ensures proper completion order\n8. Results consolidated with absolute file paths and summary provided\n\n## Agent Teams (Experimental)\n\nThe framework supports a second execution mode that uses Claude Code's native Agent Teams feature for real-time inter-agent collaboration. When enabled, agents can communicate with each other via `SendMessage`, share task lists, and self-coordinate -- rather than running as isolated subagents.\n\n### Enabling Agent Teams\n\nSet the environment variable before starting Claude Code:\n\n```bash\nexport CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1\n```\n\nNo other configuration is required. Plan mode automatically evaluates whether a given task benefits from team-based execution.\n\n### How Mode Selection Works\n\nDuring planning, plan mode calculates a `team_mode_score` based on task characteristics:\n\n| Factor                                | Points | Condition                                              |\n|---------------------------------------|--------|--------------------------------------------------------|\n| Phase count > 8                       | +2     | Large workflows benefit from coordination               |\n| Tier 3 complexity                     | +2     | Complex tasks need real-time collaboration              |\n| Cross-phase data flow                 | +3     | Phases that share data benefit from messaging           |\n| Review-fix cycles                     | +3     | Iterative feedback loops need communication             |\n| Iterative refinement                  | +2     | Back-and-forth patterns suit team mode                  |\n| User keyword (\"collaborate\", \"team\")  | +5     | Explicit user intent                                    |\n| Breadth task                          | -5     | Simple exploration is better as subagents               |\n| Phase count <= 3                      | -3     | Small workflows don't need team overhead                |\n\nA score of **5 or higher** (with `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`) triggers team mode. Otherwise, subagent mode is used.\n\n### Subagent Mode vs Team Mode\n\n| Aspect            | Subagent Mode (default)                 | Team Mode (experimental)                    |\n|-------------------|-----------------------------------------|---------------------------------------------|\n| Execution         | Isolated `Task(...)` per phase          | `Task(team_name=...)` per phase             |\n| Communication     | None (agents are isolated)              | `SendMessage` for peer-to-peer messaging    |\n| Task list         | Framework-managed via TaskCreate/Update | Shared task list, teammates self-claim     |\n| Coordination      | Main agent orchestrates waves           | Teammates self-coordinate                   |\n| Context sharing   | Via output files (`DONE\\|{path}`)       | Shared context + messaging                  |\n| Best for          | Most workflows, context-efficient       | Complex collaborative tasks, review cycles  |\n\nThe key difference is **one parameter**: `Task(team_name=\"x\")` makes a teammate; `Task()` makes an isolated subagent.\n\n### Two Team Workflow Patterns\n\n**Simple team** -- a single AGENT TEAM phase with multiple teammates exploring in parallel. Used for multi-perspective exploration tasks.\n\n```text\n> explore the authentication system from different angles\n```\n\nThis creates one team phase where each teammate explores a different perspective (e.g., security, performance, architecture), then results are synthesized.\n\n**Complex team** -- multiple individual phases across waves, all executed as teammates with `Task(team_name=...)`. Used for collaborative implementation tasks.\n\n```text\n> implement the payment service. tasks should be collaborative\n```\n\nAll phases run as teammates sharing context and messaging, even though each has a distinct assignment.\n\n### Example Prompts That Trigger Team Mode\n\n```text\n> explore the codebase from different angles\n> design the API with a team of specialists\n> implement the feature collaboratively\n> use a team to review and refactor the auth module\n> brainstorm together on the CLI design\n```\n\n### User Approval\n\nBefore creating a team, the framework presents the team plan and asks for confirmation:\n- Team name, execution mode, number of phases, wave structure\n- If declined, execution falls back to subagent mode automatically\n\n### State Files\n\nTeam mode creates two additional state files (automatically cleaned up on completion or next user prompt):\n\n| File                               | Purpose                                                              |\n|------------------------------------|----------------------------------------------------------------------|\n| `.claude/state/team_mode_active`   | Signals hooks that team mode is active                               |\n| `.claude/state/team_config.json`   | Active team configuration (name, teammates, role mappings)           |\n\n### Known Limitations\n\n| Limitation                      | Details                                                      |\n|---------------------------------|--------------------------------------------------------------|\n| No session resumption           | `/resume` and `/rewind` don't restore teammates              |\n| Task status can lag             | Teammates may fail to mark tasks completed                   |\n| Shutdown can be slow            | Teammates finish current request before stopping             |\n| One team per session            | Cannot create multiple teams in one session                  |\n| No nested teams                 | Teammates cannot spawn their own teams                       |\n| Lead is fixed                   | Cannot promote a teammate or transfer leadership             |\n| Permissions set at spawn        | Teammates inherit lead's permission mode                     |\n| Split panes need tmux/iTerm2    | Not supported in VS Code terminal or Windows Terminal        |\n\n## Contributing\n\nWe welcome contributions to the Claude Code Workflow Orchestration System! Whether you're fixing bugs, adding features, or improving documentation, your help is appreciated.\n\n### Reporting Issues\n\nFound a bug or have a feature request? Please open a GitHub Issue with:\n- Clear description of the issue or feature request\n- Steps to reproduce (for bugs)\n- Expected vs. actual behavior\n- Your environment (Windows/macOS/Linux, Claude Code version, Python version, etc.)\n- The used claude code model\n- Relevant logs or screenshots if applicable\n\n### Submitting Pull Requests\n\n1. **Fork the repository** and create a feature branch:\n   ```bash\n   git checkout -b feature/your-feature-name\n   ```\n\n2. **Make your changes** following our code style guidelines (see below)\n\n3. **Run quality checks (if applicable)** before submitting:\n   ```bash\n   # Format code\n   uvx ruff format .\n\n   # Lint code\n   uvx ruff check --no-fix .\n\n   # Type checking\n   uvx pyright .\n\n   # Run tests\n   uv run pytest\n   ```\n   All checks must pass before submission.\n\n4. **Commit with clear messages:**\n   ```bash\n   git commit -m \"feat: description of your changes\"\n   ```\n   Use conventional commit format: `feat:`, `fix:`, `docs:`, `refactor:`, etc.\n\n5. **Push to your fork** and **submit a Pull Request** to the main branch with a clear description of changes\n\n### Python Code Style Expectations\n\n- **Python 3.12+** with modern syntax (e.g., `list[str]`, `str | None`)\n- **Type hints** on all functions and variables\n- **No print statements** - use structured logging with logger calls\n- **Comprehensive docstrings** with examples for public APIs\n- **Clear variable and function names** that reflect intent\n- Automatic enforcement via Ruff (formatting), Pyright (types), and Pytest (tests)\n\nAlways run quality checks locally before submitting to catch issues early.\n\n### We Value\n\n- Clear, well-documented code\n- Tests for new functionality\n- Documentation updates for new features\n- Constructive feedback and collaboration\n- Diverse perspectives and creative solutions\n\nThank you for contributing to making Claude Code workflows even better!\n"
      },
      "plugins": [
        {
          "name": "workflow-orchestrator",
          "source": "./",
          "description": "Delegation system with workflow orchestration, specialized agents, and parallel execution for Claude Code",
          "version": "1.10.0",
          "author": {
            "name": "Nadav Barkai"
          },
          "repository": "https://github.com/barkain/claude-code-workflow-orchestration",
          "license": "MIT",
          "keywords": [
            "delegation",
            "workflow",
            "orchestration",
            "agents"
          ],
          "category": "productivity",
          "categories": [
            "agents",
            "delegation",
            "orchestration",
            "productivity",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add barkain/claude-code-workflow-orchestration",
            "/plugin install workflow-orchestrator@barkain-plugins"
          ]
        }
      ]
    }
  ]
}