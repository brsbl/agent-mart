{
  "author": {
    "id": "thoo",
    "display_name": "Thein Oo",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/6972290?u=2d5ae33ab64cf729ffbfc44a930e364142faaf60&v=4",
    "url": "https://github.com/thoo",
    "bio": "MLE",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "my-agent-skills",
      "version": null,
      "description": "Custom Claude Code skills and plugins",
      "owner_info": {
        "name": "Thein"
      },
      "keywords": [],
      "repo_full_name": "thoo/agent-skills",
      "repo_url": "https://github.com/thoo/agent-skills",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-09T04:51:10Z",
        "created_at": "2026-01-09T04:44:26Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 438
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 871
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/python-code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/python-code-review/SKILL.md",
          "type": "blob",
          "size": 3575
        },
        {
          "path": "skills/python-code-review/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/python-code-review/references/best-practices.md",
          "type": "blob",
          "size": 49265
        },
        {
          "path": "skills/python-code-review/references/checklist.md",
          "type": "blob",
          "size": 22836
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"my-agent-skills\",\n  \"owner\": {\n    \"name\": \"Thein\"\n  },\n  \"metadata\": {\n    \"description\": \"Custom Claude Code skills and plugins\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"python-code-review\",\n      \"description\": \"Review Python code changes in merge requests and pull requests\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/python-code-review\"\n      ]\n    }\n  ]\n}\n",
        "README.md": "# My Agent Skills\n\nA Claude Code plugin marketplace containing custom skills.\n\n## Available Skills\n\n| Skill | Description |\n|-------|-------------|\n| `python-code-review` | Review Python code changes in merge requests and pull requests |\n\n## Installation\n\n### Add the Marketplace\n\n```\n/plugin marketplace add thoo/agent-skills\n```\n\n### Install a Skill\n\n```\n/plugin install python-code-review@my-agent-skills\n```\n\n## Usage\n\nOnce installed, use the skill by running:\n\n```\n/python-code-review\n```\n\nOr trigger it naturally by asking Claude to review Python code, check a PR, or do a code review.\n\n## Validation\n\nYou can validate skills using the [agentskills](https://github.com/agentskills/agentskills) reference library:\n\n```bash\nuvx --from \"git+https://github.com/agentskills/agentskills.git#subdirectory=skills-ref\" skills-ref validate path/to/skill\n```\n\n## License\n\nMIT\n",
        "skills/python-code-review/SKILL.md": "---\nname: python-code-review\ndescription: Review Python code changes in merge requests and pull requests. Use when asked to review Python code, MR/PR reviews, code quality checks, or when phrases like \"review this code\", \"check this PR\", \"review my changes\", \"review mr on this branch\", \"review MR\", \"review PR\", \"PR reivew\", \"MR review\" or \"code review\" are mentioned for Python files.\n---\n\n# Python Code Review\n\nReview Python code changes systematically using established best practices and checklists.\n\n## Review Workflow\n\n### 1. Gather Context\n\n```bash\n# Get the diff to review\ngit diff main...HEAD\n\n# Or for a specific PR\ngh pr diff <pr-number>\n```\n\n### 2. Run Automated Checks First\n\nBefore manual review, verify automated tools pass:\n\n```bash\nruff check .                    # Linting\nruff format --check .           # Formatting\nmypy src/                       # Type checking\npytest tests/ -v                # Tests\n```\n\n### 3. Systematic Code Review\n\nReview each file in the diff, checking these categories in order:\n\n**Security (Critical)**\n- No SQL string formatting (use parameterized queries)\n- No `eval()`/`exec()` with user input\n- No hardcoded secrets\n- Inputs validated at boundaries\n- No path traversal vulnerabilities\n\n**Correctness**\n- Logic handles edge cases (empty, None, boundaries)\n- Error handling is specific (no bare `except:`)\n- Exception chains preserved (`raise ... from e`)\n- No mutable default arguments\n- Types are correct and complete\n\n**Design**\n- Functions do one thing (<30 lines)\n- Classes follow single responsibility\n- No code duplication (DRY)\n- Appropriate data structures used\n- No premature optimization\n\n**Style**\n- Naming is clear and consistent (snake_case, PascalCase)\n- No magic numbers/strings\n- Docstrings on public API\n- No commented-out code\n\n### 4. Provide Feedback\n\nStructure feedback by severity:\n\n1. **Blockers** - Must fix before merge (security, bugs, breaking changes)\n2. **Suggestions** - Should consider (design, performance, readability)\n3. **Nits** - Minor style issues (optional to fix)\n\n## Red Flags to Catch\n\n| Pattern | Issue |\n|---------|-------|\n| `except:` or `except Exception:` | Catches too much, hides bugs |\n| `def foo(items=[])` | Mutable default argument bug |\n| `f\"SELECT * FROM {table}\"` | SQL injection |\n| `eval(user_input)` | Code injection |\n| `password = \"secret123\"` | Hardcoded secret |\n| No type hints on public functions | Harder to maintain |\n| Functions >50 lines | Likely doing too much |\n| `# TODO` without ticket | Tech debt without tracking |\n\n## Common Patterns to Suggest\n\n```python\n# Instead of bare except\ntry:\n    process()\nexcept:  # Bad\n    pass\n\n# Use specific exceptions\ntry:\n    process()\nexcept ValueError as e:\n    logger.exception(\"Processing failed\")\n    raise\n\n# Instead of mutable defaults\ndef add_item(item, items=[]):  # Bad\n    items.append(item)\n\n# Use None pattern\ndef add_item(item, items: list | None = None) -> list:\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\n# Instead of verbose loops\nresult = []\nfor x in data:\n    if x.valid:\n        result.append(x.value)\n\n# Use comprehensions\nresult = [x.value for x in data if x.valid]\n```\n\n## Reference Guides\n\nFor detailed guidelines, consult:\n\n- **[Checklist](references/checklist.md)** - Complete review checklist with checkboxes\n- **[Best Practices](references/best-practices.md)** - Comprehensive Python best practices\n\nUse these references when:\n- Explaining why something should change\n- Providing examples of better patterns\n- Checking specific categories in depth\n",
        "skills/python-code-review/references/best-practices.md": "# Python Best Practices Guide (2025-2026)\n\nA comprehensive guide to writing clean, maintainable, and professional Python code.\n\n---\n\n## Table of Contents\n\n1. [Code Style and Formatting (PEP 8)](#1-code-style-and-formatting-pep-8)\n2. [Naming Conventions](#2-naming-conventions)\n3. [Type Hints and Static Typing](#3-type-hints-and-static-typing)\n4. [Project Structure](#4-project-structure)\n5. [Dependency Management](#5-dependency-management)\n6. [Error Handling](#6-error-handling)\n7. [Logging](#7-logging)\n8. [Testing](#8-testing)\n9. [Documentation](#9-documentation)\n10. [Async Programming](#10-async-programming)\n11. [Performance Optimization](#11-performance-optimization)\n12. [Security Best Practices](#12-security-best-practices)\n13. [Modern Python Features](#13-modern-python-features)\n14. [Code Quality Tools](#14-code-quality-tools)\n15. [Design Patterns and Principles](#15-design-patterns-and-principles)\n\n---\n\n## 1. Code Style and Formatting (PEP 8)\n\nPEP 8 is the official style guide for Python code. Following these conventions ensures consistency and readability.\n\n### Indentation\n\nUse 4 spaces per indentation level. Never mix tabs and spaces.\n\n```python\n# Good\ndef calculate_total(items):\n    total = 0\n    for item in items:\n        total += item.price\n    return total\n\n# Bad - using 2 spaces or tabs\ndef calculate_total(items):\n  total = 0\n  for item in items:\n    total += item.price\n  return total\n```\n\n### Line Length\n\n- Limit lines to 79 characters for code\n- Limit lines to 72 characters for docstrings and comments\n- Use implicit line continuation inside parentheses, brackets, and braces\n\n```python\n# Good - implicit continuation\nresult = some_function(\n    argument_one,\n    argument_two,\n    argument_three,\n)\n\n# Good - breaking long strings\nmessage = (\n    \"This is a very long message that needs to be \"\n    \"split across multiple lines for readability.\"\n)\n\n# Avoid - backslash continuation (use only when necessary)\nresult = some_very_long_variable_name + \\\n         another_very_long_variable_name\n```\n\n### Blank Lines\n\n- Two blank lines around top-level function and class definitions\n- One blank line around method definitions inside a class\n- Use blank lines sparingly inside functions to indicate logical sections\n\n```python\nimport os\n\n\nclass MyClass:\n    \"\"\"A sample class.\"\"\"\n\n    def __init__(self):\n        self.value = 0\n\n    def increment(self):\n        self.value += 1\n\n\ndef standalone_function():\n    \"\"\"A standalone function.\"\"\"\n    pass\n```\n\n### Imports\n\nImports should be on separate lines and grouped in the following order:\n1. Standard library imports\n2. Related third-party imports\n3. Local application/library specific imports\n\n```python\n# Good\nimport os\nimport sys\nfrom pathlib import Path\n\nimport httpx\nimport pydantic\nfrom fastapi import FastAPI\n\nfrom myproject.config import settings\nfrom myproject.utils import helpers\n\n# Bad - multiple imports on one line (except from imports)\nimport os, sys, json\n```\n\n### Whitespace\n\n```python\n# Good\nspam(ham[1], {eggs: 2})\nx = 1\ny = 2\nlong_variable = 3\n\ndef complex(real, imag=0.0):\n    return magic(r=real, i=imag)\n\n# Bad\nspam( ham[ 1 ], { eggs: 2 } )\nx             = 1\ny             = 2\nlong_variable = 3\n\ndef complex(real, imag = 0.0):\n    return magic(r = real, i = imag)\n```\n\n### String Quotes\n\nPick either single or double quotes and be consistent. Use the other to avoid escaping.\n\n```python\n# Consistent - pick one style\nname = \"Alice\"\nmessage = \"Hello, World!\"\n\n# Use other quote to avoid escaping\nsql = \"SELECT * FROM users WHERE name = 'Alice'\"\nhtml = '<div class=\"container\">Content</div>'\n\n# Triple double quotes for docstrings (PEP 257)\ndef my_function():\n    \"\"\"This is a docstring.\"\"\"\n    pass\n```\n\n---\n\n## 2. Naming Conventions\n\n### Variables and Functions\n\nUse `snake_case` for variables, functions, and methods.\n\n```python\n# Good\nuser_name = \"alice\"\ntotal_count = 42\nis_valid = True\n\ndef calculate_average(numbers):\n    return sum(numbers) / len(numbers)\n\ndef get_user_by_id(user_id):\n    pass\n\n# Bad\nuserName = \"alice\"  # camelCase\nTotalCount = 42     # PascalCase\nIsValid = True      # PascalCase\n```\n\n### Classes\n\nUse `PascalCase` (CapWords) for class names.\n\n```python\n# Good\nclass UserAccount:\n    pass\n\nclass HTTPRequestHandler:\n    pass\n\nclass XMLParser:\n    pass\n\n# Bad\nclass user_account:\n    pass\n\nclass httpRequestHandler:\n    pass\n```\n\n### Constants\n\nUse `UPPER_SNAKE_CASE` for constants.\n\n```python\n# Good\nMAX_CONNECTIONS = 100\nDEFAULT_TIMEOUT = 30\nAPI_BASE_URL = \"https://api.example.com\"\n\n# Bad\nmaxConnections = 100\ndefault_timeout = 30\n```\n\n### Private and Protected\n\nUse leading underscores to indicate visibility.\n\n```python\nclass MyClass:\n    def __init__(self):\n        self.public_attr = 1        # Public\n        self._protected_attr = 2    # Protected (convention)\n        self.__private_attr = 3     # Private (name mangling)\n\n    def public_method(self):\n        pass\n\n    def _protected_method(self):\n        \"\"\"Internal use, but accessible.\"\"\"\n        pass\n\n    def __private_method(self):\n        \"\"\"Name mangled to _MyClass__private_method.\"\"\"\n        pass\n```\n\n### Special Names to Avoid\n\n```python\n# Avoid these single-character names (look like numbers)\nl = 1  # lowercase L looks like 1\nO = 0  # uppercase O looks like 0\nI = 1  # uppercase I looks like 1\n\n# Better alternatives\nlength = 1\noutput = 0\nindex = 1\n```\n\n### Module and Package Names\n\nUse short, all-lowercase names. Underscores can be used if it improves readability.\n\n```python\n# Good module names\nmymodule.py\nmy_module.py\nutils.py\nhelpers.py\n\n# Good package names\nmypackage/\nmy_package/\n```\n\n---\n\n## 3. Type Hints and Static Typing\n\nType hints improve code readability, enable better IDE support, and catch bugs early.\n\n### Basic Type Hints\n\n```python\n# Variables\nname: str = \"Alice\"\nage: int = 30\nprice: float = 19.99\nis_active: bool = True\n\n# Functions\ndef greet(name: str) -> str:\n    return f\"Hello, {name}!\"\n\ndef add(a: int, b: int) -> int:\n    return a + b\n\ndef process_data(data: bytes) -> None:\n    # Function returns None\n    print(data)\n```\n\n### Collection Types (Python 3.9+)\n\n```python\n# Use built-in generics (Python 3.9+)\nnames: list[str] = [\"Alice\", \"Bob\"]\nscores: dict[str, int] = {\"Alice\": 100, \"Bob\": 85}\ncoordinates: tuple[float, float] = (1.0, 2.0)\nunique_ids: set[int] = {1, 2, 3}\n\n# Variable-length tuples\nvalues: tuple[int, ...] = (1, 2, 3, 4, 5)\n\n# Nested collections\nmatrix: list[list[int]] = [[1, 2], [3, 4]]\nuser_data: dict[str, list[str]] = {\"roles\": [\"admin\", \"user\"]}\n```\n\n### Optional and Union Types (Python 3.10+)\n\n```python\n# Python 3.10+ syntax (preferred)\ndef find_user(user_id: int) -> User | None:\n    \"\"\"Returns User or None if not found.\"\"\"\n    pass\n\ndef process(value: int | str | float) -> str:\n    \"\"\"Accepts int, str, or float.\"\"\"\n    return str(value)\n\n# For Python 3.9 and earlier\nfrom typing import Optional, Union\n\ndef find_user(user_id: int) -> Optional[User]:\n    pass\n\ndef process(value: Union[int, str, float]) -> str:\n    return str(value)\n```\n\n### Type Aliases\n\n```python\n# Simple type aliases\nUserId = int\nUsername = str\nCoordinates = tuple[float, float]\n\n# Complex type aliases\nUserDict = dict[str, str | int | None]\nCallback = Callable[[int, str], bool]\nJSONValue = str | int | float | bool | None | list[\"JSONValue\"] | dict[str, \"JSONValue\"]\n\n# Using TypeAlias (Python 3.10+)\nfrom typing import TypeAlias\n\nVector: TypeAlias = list[float]\nMatrix: TypeAlias = list[Vector]\n```\n\n### Callable Types\n\n```python\nfrom collections.abc import Callable\n\n# Function that takes int and str, returns bool\ndef register_callback(callback: Callable[[int, str], bool]) -> None:\n    pass\n\n# Function that takes any args and returns None\ndef log_call(func: Callable[..., None]) -> None:\n    pass\n\n# Async callable\nfrom collections.abc import Awaitable\n\nAsyncCallback = Callable[[str], Awaitable[int]]\n```\n\n### Generic Types\n\n```python\nfrom typing import TypeVar, Generic\n\nT = TypeVar(\"T\")\nK = TypeVar(\"K\")\nV = TypeVar(\"V\")\n\nclass Stack(Generic[T]):\n    def __init__(self) -> None:\n        self._items: list[T] = []\n\n    def push(self, item: T) -> None:\n        self._items.append(item)\n\n    def pop(self) -> T:\n        return self._items.pop()\n\n# Constrained TypeVar\nNumber = TypeVar(\"Number\", int, float)\n\ndef add_numbers(a: Number, b: Number) -> Number:\n    return a + b\n\n# Bound TypeVar\nfrom typing import Comparable\n\nSortable = TypeVar(\"Sortable\", bound=Comparable)\n```\n\n### Protocol (Structural Subtyping)\n\n```python\nfrom typing import Protocol\n\nclass Drawable(Protocol):\n    def draw(self) -> None: ...\n\nclass Circle:\n    def draw(self) -> None:\n        print(\"Drawing circle\")\n\nclass Square:\n    def draw(self) -> None:\n        print(\"Drawing square\")\n\ndef render(shape: Drawable) -> None:\n    shape.draw()\n\n# Both Circle and Square are valid Drawable without explicit inheritance\nrender(Circle())\nrender(Square())\n```\n\n### TypedDict\n\n```python\nfrom typing import TypedDict, Required, NotRequired\n\nclass UserDict(TypedDict):\n    name: str\n    age: int\n    email: str | None\n\n# With optional fields (Python 3.11+)\nclass ConfigDict(TypedDict, total=False):\n    debug: bool\n    log_level: str\n\n# Mixed required and optional\nclass RequestDict(TypedDict):\n    method: Required[str]\n    url: Required[str]\n    headers: NotRequired[dict[str, str]]\n    body: NotRequired[bytes]\n```\n\n### Self Type (Python 3.11+)\n\n```python\nfrom typing import Self\n\nclass Builder:\n    def __init__(self) -> None:\n        self.value = 0\n\n    def set_value(self, value: int) -> Self:\n        self.value = value\n        return self\n\n    def clone(self) -> Self:\n        new = type(self)()\n        new.value = self.value\n        return new\n```\n\n### Best Practices for Type Hints\n\n```python\n# 1. Start with public API, then expand\n# 2. Use abstract types for parameters, concrete for returns\nfrom collections.abc import Sequence, Mapping, Iterable\n\ndef process_items(items: Sequence[int]) -> list[int]:  # Accept any sequence\n    return [x * 2 for x in items]\n\n# 3. Use | None instead of Optional (Python 3.10+)\ndef get_user(id: int) -> User | None:\n    pass\n\n# 4. Avoid Any when possible, but use it when truly needed\nfrom typing import Any\n\ndef deserialize(data: bytes) -> Any:\n    pass\n\n# 5. Use TypeGuard for type narrowing\nfrom typing import TypeGuard\n\ndef is_str_list(val: list[object]) -> TypeGuard[list[str]]:\n    return all(isinstance(x, str) for x in val)\n\n# 6. Use Final for constants\nfrom typing import Final\n\nMAX_SIZE: Final = 100\n```\n\n---\n\n## 4. Project Structure\n\n### Standard Python Package Structure\n\n```\nmy_project/\n├── src/\n│   └── my_package/\n│       ├── __init__.py\n│       ├── __main__.py      # Entry point for python -m my_package\n│       ├── core/\n│       │   ├── __init__.py\n│       │   ├── models.py\n│       │   └── services.py\n│       ├── api/\n│       │   ├── __init__.py\n│       │   ├── routes.py\n│       │   └── middleware.py\n│       ├── utils/\n│       │   ├── __init__.py\n│       │   └── helpers.py\n│       └── config.py\n├── tests/\n│   ├── __init__.py\n│   ├── conftest.py          # Pytest fixtures\n│   ├── test_core/\n│   │   ├── __init__.py\n│   │   └── test_models.py\n│   └── test_api/\n│       ├── __init__.py\n│       └── test_routes.py\n├── docs/\n│   ├── conf.py              # Sphinx config\n│   └── index.rst\n├── scripts/\n│   └── seed_data.py\n├── .gitignore\n├── .pre-commit-config.yaml\n├── pyproject.toml\n├── README.md\n└── LICENSE\n```\n\n### The `src` Layout\n\nThe `src` layout prevents accidentally importing from the local directory instead of the installed package.\n\n```python\n# With src layout, you MUST install the package to import it\n# This catches import errors early\n\n# pyproject.toml\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n```\n\n### `__init__.py` Best Practices\n\n```python\n# src/my_package/__init__.py\n\n# Define public API\nfrom my_package.core.models import User, Product\nfrom my_package.core.services import UserService\n\n# Version\n__version__ = \"1.0.0\"\n\n# Control what's exported with __all__\n__all__ = [\n    \"User\",\n    \"Product\",\n    \"UserService\",\n    \"__version__\",\n]\n```\n\n### `__main__.py` for CLI Entry Points\n\n```python\n# src/my_package/__main__.py\n\"\"\"Entry point for python -m my_package.\"\"\"\n\nfrom my_package.cli import main\n\nif __name__ == \"__main__\":\n    main()\n```\n\n---\n\n## 5. Dependency Management\n\n### pyproject.toml (Modern Standard)\n\n```toml\n[build-system]\nrequires = [\"setuptools>=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"my-package\"\nversion = \"1.0.0\"\ndescription = \"A sample Python package\"\nreadme = \"README.md\"\nlicense = {text = \"MIT\"}\nrequires-python = \">=3.11\"\nauthors = [\n    {name = \"Your Name\", email = \"you@example.com\"}\n]\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n]\nkeywords = [\"sample\", \"package\"]\n\ndependencies = [\n    \"httpx>=0.25.0\",\n    \"pydantic>=2.0.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.0.0\",\n    \"pytest-cov>=4.0.0\",\n    \"mypy>=1.5.0\",\n    \"ruff>=0.1.0\",\n    \"pre-commit>=3.0.0\",\n]\ndocs = [\n    \"sphinx>=7.0.0\",\n    \"sphinx-rtd-theme>=1.3.0\",\n]\n\n[project.scripts]\nmy-cli = \"my_package.cli:main\"\n\n[project.urls]\nHomepage = \"https://github.com/username/my-package\"\nDocumentation = \"https://my-package.readthedocs.io\"\nRepository = \"https://github.com/username/my-package\"\n\n# Tool configurations\n[tool.setuptools.packages.find]\nwhere = [\"src\"]\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npythonpath = [\"src\"]\naddopts = \"-ra -q --cov=my_package\"\n\n[tool.mypy]\npython_version = \"3.11\"\nstrict = true\nwarn_return_any = true\nwarn_unused_ignores = true\n\n[tool.ruff]\nline-length = 88\ntarget-version = \"py311\"\n\n[tool.ruff.lint]\nselect = [\"E\", \"F\", \"I\", \"N\", \"W\", \"UP\", \"B\", \"C4\", \"SIM\"]\nignore = []\n\n[tool.ruff.lint.isort]\nknown-first-party = [\"my_package\"]\n```\n\n### Virtual Environments\n\n```bash\n# Create virtual environment\npython -m venv .venv\n\n# Activate (Unix/macOS)\nsource .venv/bin/activate\n\n# Activate (Windows)\n.venv\\Scripts\\activate\n\n# Install in editable mode for development\npip install -e \".[dev]\"\n```\n\n### Using uv (Fast Package Manager)\n\n```bash\n# Install uv\npip install uv\n\n# Create virtual environment\nuv venv\n\n# Install dependencies\nuv pip install -e \".[dev]\"\n\n# Sync dependencies (like pip-tools)\nuv pip compile pyproject.toml -o requirements.txt\nuv pip sync requirements.txt\n```\n\n### Environment Variables\n\nUse `python-dotenv` for local development:\n\n```python\n# .env file (never commit to git!)\nDATABASE_URL=postgresql://localhost/mydb\nSECRET_KEY=your-secret-key\nDEBUG=true\n\n# config.py\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\nDATABASE_URL = os.getenv(\"DATABASE_URL\")\nSECRET_KEY = os.getenv(\"SECRET_KEY\")\nDEBUG = os.getenv(\"DEBUG\", \"false\").lower() == \"true\"\n```\n\n---\n\n## 6. Error Handling\n\n### Exception Hierarchy\n\n```python\n# Custom exception hierarchy\nclass AppError(Exception):\n    \"\"\"Base exception for application errors.\"\"\"\n    pass\n\nclass ValidationError(AppError):\n    \"\"\"Raised when validation fails.\"\"\"\n    pass\n\nclass NotFoundError(AppError):\n    \"\"\"Raised when a resource is not found.\"\"\"\n    pass\n\nclass AuthenticationError(AppError):\n    \"\"\"Raised when authentication fails.\"\"\"\n    pass\n\nclass AuthorizationError(AppError):\n    \"\"\"Raised when user lacks permissions.\"\"\"\n    pass\n```\n\n### Best Practices\n\n```python\n# 1. Catch specific exceptions\ntry:\n    user = get_user(user_id)\nexcept NotFoundError:\n    return None\nexcept DatabaseError as e:\n    logger.error(f\"Database error: {e}\")\n    raise\n\n# 2. Avoid bare except\n# Bad\ntry:\n    do_something()\nexcept:  # Catches everything including KeyboardInterrupt\n    pass\n\n# Good\ntry:\n    do_something()\nexcept Exception as e:\n    logger.exception(\"Unexpected error\")\n    raise\n\n# 3. Keep try blocks small\n# Bad\ntry:\n    user = get_user(user_id)\n    orders = get_orders(user.id)\n    total = calculate_total(orders)\n    send_email(user.email, total)\nexcept Exception as e:\n    # Which operation failed?\n    pass\n\n# Good\ntry:\n    user = get_user(user_id)\nexcept NotFoundError:\n    return None\n\ntry:\n    orders = get_orders(user.id)\nexcept DatabaseError:\n    logger.error(\"Failed to fetch orders\")\n    raise\n\n# 4. Preserve exception chain\ntry:\n    data = json.loads(raw_data)\nexcept json.JSONDecodeError as e:\n    raise ValidationError(f\"Invalid JSON: {e}\") from e\n\n# 5. Use context managers for cleanup\nwith open(\"file.txt\") as f:\n    data = f.read()\n\n# 6. Use finally for guaranteed cleanup\nresource = acquire_resource()\ntry:\n    process(resource)\nfinally:\n    release_resource(resource)\n```\n\n### Exception Groups (Python 3.11+)\n\n```python\n# Handle multiple exceptions concurrently\nasync def fetch_all(urls: list[str]) -> list[Response]:\n    async with asyncio.TaskGroup() as tg:\n        tasks = [tg.create_task(fetch(url)) for url in urls]\n    return [t.result() for t in tasks]\n\n# Catch exception groups\ntry:\n    results = await fetch_all(urls)\nexcept* ConnectionError as e:\n    # Handle connection errors\n    for exc in e.exceptions:\n        logger.error(f\"Connection failed: {exc}\")\nexcept* TimeoutError as e:\n    # Handle timeouts\n    pass\n```\n\n### EAFP vs LBYL\n\nPython prefers EAFP (Easier to Ask for Forgiveness than Permission) over LBYL (Look Before You Leap).\n\n```python\n# LBYL (Less Pythonic)\nif key in dictionary:\n    value = dictionary[key]\nelse:\n    value = default\n\n# EAFP (More Pythonic)\ntry:\n    value = dictionary[key]\nexcept KeyError:\n    value = default\n\n# Even better - use dict methods\nvalue = dictionary.get(key, default)\n\n# LBYL (Less Pythonic)\nif hasattr(obj, 'method'):\n    obj.method()\n\n# EAFP (More Pythonic)\ntry:\n    obj.method()\nexcept AttributeError:\n    pass\n```\n\n---\n\n## 7. Logging\n\n### Basic Setup\n\n```python\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    datefmt=\"%Y-%m-%d %H:%M:%S\",\n)\n\n# Get logger for module\nlogger = logging.getLogger(__name__)\n\ndef process_data(data):\n    logger.info(\"Processing data started\")\n    logger.debug(f\"Data size: {len(data)}\")\n\n    try:\n        result = transform(data)\n        logger.info(\"Processing completed successfully\")\n        return result\n    except Exception:\n        logger.exception(\"Processing failed\")  # Includes traceback\n        raise\n```\n\n### Production Logging Configuration\n\n```python\nimport logging.config\n\nLOGGING_CONFIG = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"formatters\": {\n        \"standard\": {\n            \"format\": \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        },\n        \"json\": {\n            \"class\": \"pythonjsonlogger.jsonlogger.JsonFormatter\",\n            \"format\": \"%(asctime)s %(name)s %(levelname)s %(message)s\"\n        },\n    },\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"level\": \"DEBUG\",\n            \"formatter\": \"standard\",\n            \"stream\": \"ext://sys.stdout\",\n        },\n        \"file\": {\n            \"class\": \"logging.handlers.RotatingFileHandler\",\n            \"level\": \"INFO\",\n            \"formatter\": \"json\",\n            \"filename\": \"app.log\",\n            \"maxBytes\": 10485760,  # 10MB\n            \"backupCount\": 5,\n        },\n    },\n    \"loggers\": {\n        \"\": {  # Root logger\n            \"handlers\": [\"console\", \"file\"],\n            \"level\": \"INFO\",\n            \"propagate\": True,\n        },\n        \"my_package\": {\n            \"handlers\": [\"console\", \"file\"],\n            \"level\": \"DEBUG\",\n            \"propagate\": False,\n        },\n    },\n}\n\nlogging.config.dictConfig(LOGGING_CONFIG)\n```\n\n### Structured Logging with structlog\n\n```python\nimport structlog\n\n# Configure structlog\nstructlog.configure(\n    processors=[\n        structlog.stdlib.filter_by_level,\n        structlog.stdlib.add_logger_name,\n        structlog.stdlib.add_log_level,\n        structlog.stdlib.PositionalArgumentsFormatter(),\n        structlog.processors.TimeStamper(fmt=\"iso\"),\n        structlog.processors.StackInfoRenderer(),\n        structlog.processors.format_exc_info,\n        structlog.processors.UnicodeDecoder(),\n        structlog.processors.JSONRenderer(),\n    ],\n    wrapper_class=structlog.stdlib.BoundLogger,\n    context_class=dict,\n    logger_factory=structlog.stdlib.LoggerFactory(),\n    cache_logger_on_first_use=True,\n)\n\nlogger = structlog.get_logger()\n\n# Structured logging with context\nlogger.info(\n    \"user_login\",\n    user_id=123,\n    ip_address=\"192.168.1.1\",\n    success=True,\n)\n```\n\n### Logging Best Practices\n\n```python\n# 1. Use appropriate log levels\nlogger.debug(\"Detailed debugging information\")\nlogger.info(\"General operational information\")\nlogger.warning(\"Warning about potential issues\")\nlogger.error(\"Error that needs attention\")\nlogger.critical(\"Critical error, application may crash\")\n\n# 2. Use lazy formatting (not f-strings for expensive operations)\n# Bad - string always formatted\nlogger.debug(f\"Processing {expensive_operation()}\")\n\n# Good - only formatted if debug is enabled\nlogger.debug(\"Processing %s\", expensive_operation())\n\n# 3. Include context\nlogger.info(\n    \"Order processed\",\n    extra={\n        \"order_id\": order.id,\n        \"user_id\": user.id,\n        \"total\": order.total,\n    }\n)\n\n# 4. Use exception() for errors with traceback\ntry:\n    process()\nexcept Exception:\n    logger.exception(\"Processing failed\")  # Automatically includes traceback\n\n# 5. Don't log sensitive data\n# Bad\nlogger.info(f\"User login: {username}, password: {password}\")\n\n# Good\nlogger.info(f\"User login: {username}\")\n```\n\n---\n\n## 8. Testing\n\n### pytest Basics\n\n```python\n# tests/test_calculator.py\nimport pytest\nfrom my_package.calculator import add, divide\n\ndef test_add_positive_numbers():\n    assert add(2, 3) == 5\n\ndef test_add_negative_numbers():\n    assert add(-1, -1) == -2\n\ndef test_divide_by_zero():\n    with pytest.raises(ZeroDivisionError):\n        divide(1, 0)\n\ndef test_divide_float_result():\n    result = divide(5, 2)\n    assert result == pytest.approx(2.5)\n```\n\n### Fixtures\n\n```python\n# tests/conftest.py\nimport pytest\nfrom my_package.database import Database\nfrom my_package.models import User\n\n@pytest.fixture\ndef db():\n    \"\"\"Create a test database.\"\"\"\n    database = Database(\":memory:\")\n    database.create_tables()\n    yield database\n    database.close()\n\n@pytest.fixture\ndef sample_user(db):\n    \"\"\"Create a sample user.\"\"\"\n    user = User(name=\"Test User\", email=\"test@example.com\")\n    db.save(user)\n    return user\n\n# Using fixtures\ndef test_user_creation(db, sample_user):\n    retrieved = db.get_user(sample_user.id)\n    assert retrieved.name == \"Test User\"\n```\n\n### Parametrized Tests\n\n```python\nimport pytest\n\n@pytest.mark.parametrize(\"input,expected\", [\n    (\"hello\", \"HELLO\"),\n    (\"world\", \"WORLD\"),\n    (\"Python\", \"PYTHON\"),\n    (\"\", \"\"),\n])\ndef test_uppercase(input, expected):\n    assert input.upper() == expected\n\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (1, 2, 3),\n    (0, 0, 0),\n    (-1, 1, 0),\n    (100, 200, 300),\n])\ndef test_add(a, b, expected):\n    assert add(a, b) == expected\n```\n\n### Mocking\n\n```python\nfrom unittest.mock import Mock, patch, AsyncMock\nimport pytest\n\n# Mocking a function\ndef test_send_email():\n    with patch(\"my_package.email.smtp_send\") as mock_send:\n        mock_send.return_value = True\n        result = send_welcome_email(\"user@example.com\")\n        assert result is True\n        mock_send.assert_called_once_with(\n            to=\"user@example.com\",\n            subject=\"Welcome!\",\n        )\n\n# Mocking a class\ndef test_api_client():\n    mock_response = Mock()\n    mock_response.status_code = 200\n    mock_response.json.return_value = {\"data\": \"test\"}\n\n    with patch(\"my_package.api.httpx.get\", return_value=mock_response):\n        result = fetch_data()\n        assert result == {\"data\": \"test\"}\n\n# Async mocking\n@pytest.mark.asyncio\nasync def test_async_fetch():\n    with patch(\"my_package.api.aiohttp.get\", new_callable=AsyncMock) as mock:\n        mock.return_value.json = AsyncMock(return_value={\"key\": \"value\"})\n        result = await async_fetch_data()\n        assert result == {\"key\": \"value\"}\n```\n\n### Test Organization\n\n```python\n# Group related tests in classes\nclass TestUserService:\n    \"\"\"Tests for UserService.\"\"\"\n\n    def test_create_user(self, db):\n        service = UserService(db)\n        user = service.create(\"Alice\", \"alice@example.com\")\n        assert user.id is not None\n        assert user.name == \"Alice\"\n\n    def test_create_user_duplicate_email(self, db, sample_user):\n        service = UserService(db)\n        with pytest.raises(DuplicateEmailError):\n            service.create(\"Bob\", sample_user.email)\n\n    def test_delete_user(self, db, sample_user):\n        service = UserService(db)\n        service.delete(sample_user.id)\n        assert db.get_user(sample_user.id) is None\n```\n\n### Async Testing\n\n```python\nimport pytest\n\n@pytest.mark.asyncio\nasync def test_async_fetch():\n    result = await fetch_data(\"https://api.example.com\")\n    assert result[\"status\"] == \"ok\"\n\n@pytest.mark.asyncio\nasync def test_async_context_manager():\n    async with DatabaseConnection() as conn:\n        result = await conn.execute(\"SELECT 1\")\n        assert result == 1\n```\n\n### Coverage Configuration\n\n```toml\n# pyproject.toml\n[tool.coverage.run]\nsource = [\"src\"]\nbranch = true\nomit = [\"*/tests/*\", \"*/__main__.py\"]\n\n[tool.coverage.report]\nexclude_lines = [\n    \"pragma: no cover\",\n    \"def __repr__\",\n    \"raise NotImplementedError\",\n    \"if TYPE_CHECKING:\",\n]\nfail_under = 80\n```\n\n---\n\n## 9. Documentation\n\n### Docstring Formats\n\n```python\n# Google Style (recommended)\ndef fetch_data(url: str, timeout: int = 30) -> dict:\n    \"\"\"Fetch data from a URL.\n\n    Retrieves JSON data from the specified URL with configurable timeout.\n\n    Args:\n        url: The URL to fetch data from.\n        timeout: Request timeout in seconds. Defaults to 30.\n\n    Returns:\n        A dictionary containing the response data.\n\n    Raises:\n        ConnectionError: If the connection fails.\n        TimeoutError: If the request times out.\n\n    Example:\n        >>> data = fetch_data(\"https://api.example.com/data\")\n        >>> print(data[\"status\"])\n        'ok'\n    \"\"\"\n    pass\n\n# NumPy Style\ndef calculate_statistics(data: list[float]) -> tuple[float, float, float]:\n    \"\"\"\n    Calculate basic statistics for a dataset.\n\n    Parameters\n    ----------\n    data : list[float]\n        A list of numerical values.\n\n    Returns\n    -------\n    tuple[float, float, float]\n        A tuple containing (mean, median, std_dev).\n\n    Examples\n    --------\n    >>> calculate_statistics([1, 2, 3, 4, 5])\n    (3.0, 3.0, 1.4142135623730951)\n    \"\"\"\n    pass\n```\n\n### Class Documentation\n\n```python\nclass UserService:\n    \"\"\"Service for managing user operations.\n\n    This service provides methods for creating, updating, and deleting\n    users in the system. It handles validation and persistence.\n\n    Attributes:\n        db: Database connection instance.\n        cache: Optional cache backend for performance.\n\n    Example:\n        >>> service = UserService(database)\n        >>> user = service.create(\"Alice\", \"alice@example.com\")\n        >>> print(user.id)\n        1\n    \"\"\"\n\n    def __init__(self, db: Database, cache: Cache | None = None) -> None:\n        \"\"\"Initialize the UserService.\n\n        Args:\n            db: Database connection to use.\n            cache: Optional cache backend. If not provided, caching is disabled.\n        \"\"\"\n        self.db = db\n        self.cache = cache\n```\n\n### Module Documentation\n\n```python\n\"\"\"User management module.\n\nThis module provides classes and functions for managing users in the\napplication. It includes user creation, authentication, and profile\nmanagement.\n\nTypical usage example:\n\n    from my_package.users import UserService, User\n\n    service = UserService(database)\n    user = service.create(\"Alice\", \"alice@example.com\")\n\n    if service.authenticate(user, \"password\"):\n        print(\"Authenticated!\")\n\nClasses:\n    User: Represents a user in the system.\n    UserService: Service for user operations.\n\nFunctions:\n    hash_password: Securely hash a password.\n    verify_password: Verify a password against a hash.\n\"\"\"\n```\n\n---\n\n## 10. Async Programming\n\n### asyncio Basics\n\n```python\nimport asyncio\n\nasync def fetch_data(url: str) -> dict:\n    \"\"\"Fetch data from URL asynchronously.\"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        return response.json()\n\nasync def main():\n    # Run single coroutine\n    data = await fetch_data(\"https://api.example.com/data\")\n    print(data)\n\n# Entry point\nasyncio.run(main())\n```\n\n### Concurrent Execution\n\n```python\nimport asyncio\n\nasync def fetch_all(urls: list[str]) -> list[dict]:\n    \"\"\"Fetch multiple URLs concurrently.\"\"\"\n    async with httpx.AsyncClient() as client:\n        tasks = [client.get(url) for url in urls]\n        responses = await asyncio.gather(*tasks)\n        return [r.json() for r in responses]\n\n# With error handling\nasync def fetch_all_safe(urls: list[str]) -> list[dict | None]:\n    \"\"\"Fetch URLs, returning None for failures.\"\"\"\n    async with httpx.AsyncClient() as client:\n        tasks = [client.get(url) for url in urls]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        return [\n            r.json() if not isinstance(r, Exception) else None\n            for r in results\n        ]\n```\n\n### Task Groups (Python 3.11+)\n\n```python\nimport asyncio\n\nasync def process_batch(items: list[str]) -> list[Result]:\n    \"\"\"Process items with automatic cancellation on error.\"\"\"\n    async with asyncio.TaskGroup() as tg:\n        tasks = [tg.create_task(process_item(item)) for item in items]\n    return [task.result() for task in tasks]\n\n# If any task fails, all others are cancelled automatically\n```\n\n### Async Context Managers\n\n```python\nclass AsyncDatabaseConnection:\n    \"\"\"Async database connection with context manager.\"\"\"\n\n    async def __aenter__(self) -> \"AsyncDatabaseConnection\":\n        self.conn = await asyncpg.connect(DATABASE_URL)\n        return self\n\n    async def __aexit__(self, exc_type, exc_val, exc_tb) -> None:\n        await self.conn.close()\n\n    async def execute(self, query: str) -> list:\n        return await self.conn.fetch(query)\n\n# Usage\nasync with AsyncDatabaseConnection() as db:\n    users = await db.execute(\"SELECT * FROM users\")\n```\n\n### Async Generators\n\n```python\nasync def fetch_pages(url: str) -> AsyncIterator[dict]:\n    \"\"\"Fetch paginated data lazily.\"\"\"\n    page = 1\n    async with httpx.AsyncClient() as client:\n        while True:\n            response = await client.get(f\"{url}?page={page}\")\n            data = response.json()\n            if not data[\"items\"]:\n                break\n            yield data\n            page += 1\n\n# Usage\nasync for page in fetch_pages(\"https://api.example.com/items\"):\n    process_page(page)\n```\n\n### Async Best Practices\n\n```python\n# 1. Use asyncio.run() as entry point\nasync def main():\n    await do_work()\n\nasyncio.run(main())\n\n# 2. Don't block the event loop\n# Bad\nasync def bad_example():\n    time.sleep(1)  # Blocks!\n\n# Good\nasync def good_example():\n    await asyncio.sleep(1)\n\n# 3. Use run_in_executor for CPU-bound work\nasync def process_image(image_data: bytes) -> bytes:\n    loop = asyncio.get_event_loop()\n    result = await loop.run_in_executor(\n        None,  # Default executor\n        cpu_intensive_resize,\n        image_data,\n    )\n    return result\n\n# 4. Use semaphores to limit concurrency\nasync def fetch_with_limit(urls: list[str], max_concurrent: int = 10):\n    semaphore = asyncio.Semaphore(max_concurrent)\n\n    async def fetch_one(url: str):\n        async with semaphore:\n            async with httpx.AsyncClient() as client:\n                return await client.get(url)\n\n    return await asyncio.gather(*[fetch_one(url) for url in urls])\n\n# 5. Handle cancellation gracefully\nasync def cancellable_task():\n    try:\n        while True:\n            await do_work()\n            await asyncio.sleep(1)\n    except asyncio.CancelledError:\n        await cleanup()\n        raise\n```\n\n---\n\n## 11. Performance Optimization\n\n### Profiling\n\n```python\nimport cProfile\nimport pstats\n\n# Profile a function\ndef profile_function():\n    profiler = cProfile.Profile()\n    profiler.enable()\n\n    # Code to profile\n    result = expensive_operation()\n\n    profiler.disable()\n    stats = pstats.Stats(profiler)\n    stats.sort_stats(\"cumulative\")\n    stats.print_stats(10)  # Top 10 functions\n\n# Line profiler (install: pip install line_profiler)\n# Add @profile decorator and run: kernprof -l -v script.py\n@profile\ndef slow_function():\n    result = []\n    for i in range(10000):\n        result.append(i ** 2)\n    return result\n```\n\n### Memory Optimization\n\n```python\n# 1. Use generators for large datasets\n# Bad - loads everything into memory\ndef get_all_lines(filename: str) -> list[str]:\n    with open(filename) as f:\n        return f.readlines()\n\n# Good - yields one line at a time\ndef get_all_lines(filename: str) -> Iterator[str]:\n    with open(filename) as f:\n        for line in f:\n            yield line\n\n# 2. Use __slots__ for memory-efficient classes\nclass Point:\n    __slots__ = (\"x\", \"y\")\n\n    def __init__(self, x: float, y: float):\n        self.x = x\n        self.y = y\n\n# 3. Use appropriate data structures\nfrom collections import deque\n\n# deque for fast append/pop from both ends\nqueue = deque(maxlen=1000)\n\n# set for O(1) membership testing\nseen = set()\nif item not in seen:\n    seen.add(item)\n```\n\n### Common Optimizations\n\n```python\n# 1. List comprehensions vs loops\n# Slower\nresult = []\nfor i in range(1000):\n    result.append(i ** 2)\n\n# Faster\nresult = [i ** 2 for i in range(1000)]\n\n# 2. Local variables vs global\n# Slower\ndef slow():\n    for _ in range(1000):\n        x = global_var + 1\n\n# Faster\ndef fast():\n    local_var = global_var\n    for _ in range(1000):\n        x = local_var + 1\n\n# 3. String concatenation\n# Slower\nresult = \"\"\nfor s in strings:\n    result += s\n\n# Faster\nresult = \"\".join(strings)\n\n# 4. Use built-in functions\n# Slower\ntotal = 0\nfor x in numbers:\n    total += x\n\n# Faster\ntotal = sum(numbers)\n\n# 5. Avoid repeated attribute lookups\n# Slower\nfor item in items:\n    self.container.data.append(item)\n\n# Faster\nappend = self.container.data.append\nfor item in items:\n    append(item)\n```\n\n### Caching\n\n```python\nfrom functools import lru_cache, cache\n\n# LRU cache with size limit\n@lru_cache(maxsize=128)\ndef fibonacci(n: int) -> int:\n    if n < 2:\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n\n# Unlimited cache (Python 3.9+)\n@cache\ndef expensive_computation(x: int) -> int:\n    return x ** 100\n\n# Clear cache\nfibonacci.cache_clear()\n\n# Cache info\nprint(fibonacci.cache_info())\n```\n\n---\n\n## 12. Security Best Practices\n\n### Input Validation\n\n```python\nfrom pydantic import BaseModel, EmailStr, Field, validator\n\nclass UserCreate(BaseModel):\n    \"\"\"Validated user creation request.\"\"\"\n\n    username: str = Field(..., min_length=3, max_length=50)\n    email: EmailStr\n    password: str = Field(..., min_length=8)\n\n    @validator(\"username\")\n    def username_alphanumeric(cls, v):\n        if not v.isalnum():\n            raise ValueError(\"Username must be alphanumeric\")\n        return v\n\n    @validator(\"password\")\n    def password_strength(cls, v):\n        if not any(c.isupper() for c in v):\n            raise ValueError(\"Password must contain uppercase\")\n        if not any(c.isdigit() for c in v):\n            raise ValueError(\"Password must contain digit\")\n        return v\n```\n\n### SQL Injection Prevention\n\n```python\n# Bad - SQL injection vulnerability\ndef get_user_bad(username: str):\n    query = f\"SELECT * FROM users WHERE username = '{username}'\"\n    cursor.execute(query)\n\n# Good - parameterized query\ndef get_user_good(username: str):\n    query = \"SELECT * FROM users WHERE username = %s\"\n    cursor.execute(query, (username,))\n\n# Good - ORM (SQLAlchemy)\ndef get_user_orm(username: str):\n    return session.query(User).filter(User.username == username).first()\n```\n\n### Password Handling\n\n```python\nimport hashlib\nimport secrets\n\n# Use dedicated library (recommended)\nfrom passlib.context import CryptContext\n\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\ndef hash_password(password: str) -> str:\n    return pwd_context.hash(password)\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n# Generate secure tokens\ndef generate_token(length: int = 32) -> str:\n    return secrets.token_urlsafe(length)\n\ndef generate_api_key() -> str:\n    return secrets.token_hex(32)\n```\n\n### Secrets Management\n\n```python\nimport os\nfrom dotenv import load_dotenv\n\n# Never hardcode secrets\n# Bad\nAPI_KEY = \"sk-1234567890abcdef\"\n\n# Good - environment variables\nload_dotenv()\nAPI_KEY = os.environ[\"API_KEY\"]\n\n# Good - with validation\ndef get_required_env(name: str) -> str:\n    value = os.environ.get(name)\n    if not value:\n        raise EnvironmentError(f\"Required environment variable {name} not set\")\n    return value\n\nDATABASE_URL = get_required_env(\"DATABASE_URL\")\n```\n\n### Path Traversal Prevention\n\n```python\nfrom pathlib import Path\n\ndef safe_file_read(base_dir: str, filename: str) -> str:\n    \"\"\"Safely read a file, preventing path traversal.\"\"\"\n    base = Path(base_dir).resolve()\n    file_path = (base / filename).resolve()\n\n    # Ensure the resolved path is within base directory\n    if not str(file_path).startswith(str(base)):\n        raise ValueError(\"Invalid file path\")\n\n    return file_path.read_text()\n```\n\n---\n\n## 13. Modern Python Features\n\n### Pattern Matching (Python 3.10+)\n\n```python\ndef process_command(command: dict) -> str:\n    match command:\n        case {\"action\": \"create\", \"name\": name}:\n            return f\"Creating {name}\"\n        case {\"action\": \"delete\", \"id\": id_}:\n            return f\"Deleting {id_}\"\n        case {\"action\": \"update\", \"id\": id_, \"data\": data}:\n            return f\"Updating {id_} with {data}\"\n        case _:\n            return \"Unknown command\"\n\n# With guards\ndef categorize_number(n: int) -> str:\n    match n:\n        case _ if n < 0:\n            return \"negative\"\n        case 0:\n            return \"zero\"\n        case _ if n % 2 == 0:\n            return \"positive even\"\n        case _:\n            return \"positive odd\"\n\n# Matching classes\nclass Point:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\ndef describe_point(point: Point) -> str:\n    match point:\n        case Point(x=0, y=0):\n            return \"origin\"\n        case Point(x=0, y=y):\n            return f\"on y-axis at {y}\"\n        case Point(x=x, y=0):\n            return f\"on x-axis at {x}\"\n        case Point(x=x, y=y):\n            return f\"at ({x}, {y})\"\n```\n\n### Walrus Operator (Python 3.8+)\n\n```python\n# Assign and use in one expression\nif (n := len(data)) > 10:\n    print(f\"List is too long ({n} elements)\")\n\n# In comprehensions\nresults = [y for x in data if (y := expensive_computation(x)) > 0]\n\n# In while loops\nwhile (line := file.readline()):\n    process(line)\n```\n\n### Data Classes\n\n```python\nfrom dataclasses import dataclass, field\nfrom typing import ClassVar\n\n@dataclass\nclass Product:\n    name: str\n    price: float\n    quantity: int = 0\n    tags: list[str] = field(default_factory=list)\n\n    # Class variable (not an instance field)\n    currency: ClassVar[str] = \"USD\"\n\n    def total_value(self) -> float:\n        return self.price * self.quantity\n\n# Frozen (immutable) dataclass\n@dataclass(frozen=True)\nclass Point:\n    x: float\n    y: float\n\n# With slots for memory efficiency\n@dataclass(slots=True)\nclass User:\n    name: str\n    email: str\n```\n\n### f-strings and Advanced Formatting\n\n```python\nname = \"Alice\"\nvalue = 123.456789\n\n# Basic\nprint(f\"Hello, {name}!\")\n\n# Expressions\nprint(f\"Sum: {1 + 2}\")\n\n# Formatting\nprint(f\"Value: {value:.2f}\")  # 123.46\nprint(f\"Padded: {name:>10}\")  # \"     Alice\"\nprint(f\"Binary: {42:b}\")      # \"101010\"\nprint(f\"Hex: {255:x}\")        # \"ff\"\n\n# Debug mode (Python 3.8+)\nx = 10\nprint(f\"{x=}\")  # \"x=10\"\nprint(f\"{x=:.2f}\")  # \"x=10.00\"\n\n# Nested expressions\nprint(f\"{'left':<10} {'right':>10}\")\n```\n\n### Context Variables (Python 3.7+)\n\n```python\nfrom contextvars import ContextVar\n\n# Define context variable\nrequest_id: ContextVar[str] = ContextVar(\"request_id\", default=\"unknown\")\n\nasync def handle_request(req_id: str):\n    token = request_id.set(req_id)\n    try:\n        await process_request()\n    finally:\n        request_id.reset(token)\n\nasync def process_request():\n    # Access context variable from anywhere in the call stack\n    print(f\"Processing request {request_id.get()}\")\n```\n\n---\n\n## 14. Code Quality Tools\n\n### Ruff (Fast Linter and Formatter)\n\n```toml\n# pyproject.toml\n[tool.ruff]\nline-length = 88\ntarget-version = \"py311\"\n\n[tool.ruff.lint]\nselect = [\n    \"E\",    # pycodestyle errors\n    \"F\",    # pyflakes\n    \"I\",    # isort\n    \"N\",    # pep8-naming\n    \"W\",    # pycodestyle warnings\n    \"UP\",   # pyupgrade\n    \"B\",    # flake8-bugbear\n    \"C4\",   # flake8-comprehensions\n    \"SIM\",  # flake8-simplify\n    \"ARG\",  # flake8-unused-arguments\n    \"PTH\",  # flake8-use-pathlib\n]\nignore = [\"E501\"]  # Line too long (handled by formatter)\n\n[tool.ruff.lint.isort]\nknown-first-party = [\"my_package\"]\n\n[tool.ruff.format]\nquote-style = \"double\"\nindent-style = \"space\"\n```\n\n### mypy (Type Checker)\n\n```toml\n# pyproject.toml\n[tool.mypy]\npython_version = \"3.11\"\nstrict = true\nwarn_return_any = true\nwarn_unused_ignores = true\ndisallow_untyped_defs = true\ndisallow_incomplete_defs = true\ncheck_untyped_defs = true\nno_implicit_optional = true\n\n[[tool.mypy.overrides]]\nmodule = \"tests.*\"\ndisallow_untyped_defs = false\n```\n\n### Pre-commit Configuration\n\n```yaml\n# .pre-commit-config.yaml\nrepos:\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.1.6\n    hooks:\n      - id: ruff\n        args: [--fix]\n      - id: ruff-format\n\n  - repo: https://github.com/pre-commit/mirrors-mypy\n    rev: v1.7.0\n    hooks:\n      - id: mypy\n        additional_dependencies:\n          - types-requests\n          - pydantic\n\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v4.5.0\n    hooks:\n      - id: trailing-whitespace\n      - id: end-of-file-fixer\n      - id: check-yaml\n      - id: check-added-large-files\n      - id: check-merge-conflict\n```\n\n### Install and Run\n\n```bash\n# Install pre-commit\npip install pre-commit\n\n# Install hooks\npre-commit install\n\n# Run manually\npre-commit run --all-files\n\n# Run specific hook\nruff check .\nruff format .\nmypy src/\n```\n\n---\n\n## 15. Design Patterns and Principles\n\n### SOLID Principles\n\n```python\n# Single Responsibility Principle\n# Bad - class does too much\nclass UserManager:\n    def create_user(self, data): ...\n    def send_email(self, user): ...\n    def generate_report(self, users): ...\n\n# Good - separate responsibilities\nclass UserService:\n    def create_user(self, data): ...\n\nclass EmailService:\n    def send_email(self, recipient, message): ...\n\nclass ReportGenerator:\n    def generate(self, data): ...\n\n\n# Open/Closed Principle\n# Open for extension, closed for modification\nfrom abc import ABC, abstractmethod\n\nclass PaymentProcessor(ABC):\n    @abstractmethod\n    def process(self, amount: float) -> bool: ...\n\nclass CreditCardProcessor(PaymentProcessor):\n    def process(self, amount: float) -> bool:\n        # Credit card logic\n        return True\n\nclass PayPalProcessor(PaymentProcessor):\n    def process(self, amount: float) -> bool:\n        # PayPal logic\n        return True\n\n\n# Dependency Inversion Principle\n# Depend on abstractions, not concretions\nclass OrderService:\n    def __init__(self, payment_processor: PaymentProcessor):\n        self.payment_processor = payment_processor\n\n    def checkout(self, order: Order) -> bool:\n        return self.payment_processor.process(order.total)\n\n# Inject dependency\nservice = OrderService(CreditCardProcessor())\n```\n\n### Factory Pattern\n\n```python\nfrom abc import ABC, abstractmethod\n\nclass Document(ABC):\n    @abstractmethod\n    def render(self) -> str: ...\n\nclass PDFDocument(Document):\n    def render(self) -> str:\n        return \"PDF content\"\n\nclass HTMLDocument(Document):\n    def render(self) -> str:\n        return \"<html>content</html>\"\n\nclass DocumentFactory:\n    @staticmethod\n    def create(doc_type: str) -> Document:\n        match doc_type:\n            case \"pdf\":\n                return PDFDocument()\n            case \"html\":\n                return HTMLDocument()\n            case _:\n                raise ValueError(f\"Unknown document type: {doc_type}\")\n\n# Usage\ndoc = DocumentFactory.create(\"pdf\")\n```\n\n### Repository Pattern\n\n```python\nfrom abc import ABC, abstractmethod\nfrom typing import Generic, TypeVar\n\nT = TypeVar(\"T\")\n\nclass Repository(ABC, Generic[T]):\n    @abstractmethod\n    def get(self, id: int) -> T | None: ...\n\n    @abstractmethod\n    def get_all(self) -> list[T]: ...\n\n    @abstractmethod\n    def add(self, entity: T) -> T: ...\n\n    @abstractmethod\n    def update(self, entity: T) -> T: ...\n\n    @abstractmethod\n    def delete(self, id: int) -> None: ...\n\nclass UserRepository(Repository[User]):\n    def __init__(self, session: Session):\n        self.session = session\n\n    def get(self, id: int) -> User | None:\n        return self.session.query(User).get(id)\n\n    def get_all(self) -> list[User]:\n        return self.session.query(User).all()\n\n    def add(self, user: User) -> User:\n        self.session.add(user)\n        self.session.commit()\n        return user\n\n    def update(self, user: User) -> User:\n        self.session.merge(user)\n        self.session.commit()\n        return user\n\n    def delete(self, id: int) -> None:\n        user = self.get(id)\n        if user:\n            self.session.delete(user)\n            self.session.commit()\n```\n\n### Decorator Pattern\n\n```python\nfrom functools import wraps\nimport time\n\ndef retry(max_attempts: int = 3, delay: float = 1.0):\n    \"\"\"Retry decorator with exponential backoff.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1:\n                        time.sleep(delay * (2 ** attempt))\n            raise last_exception\n        return wrapper\n    return decorator\n\n@retry(max_attempts=3, delay=0.5)\ndef fetch_data(url: str) -> dict:\n    # May fail, will be retried\n    return httpx.get(url).json()\n```\n\n### Context Manager Pattern\n\n```python\nfrom contextlib import contextmanager\nfrom typing import Generator\n\n@contextmanager\ndef timed_operation(name: str) -> Generator[None, None, None]:\n    \"\"\"Context manager for timing operations.\"\"\"\n    start = time.perf_counter()\n    try:\n        yield\n    finally:\n        elapsed = time.perf_counter() - start\n        print(f\"{name} took {elapsed:.3f} seconds\")\n\n# Usage\nwith timed_operation(\"data processing\"):\n    process_large_dataset()\n\n# Class-based context manager\nclass DatabaseTransaction:\n    def __init__(self, connection):\n        self.connection = connection\n\n    def __enter__(self):\n        self.connection.begin()\n        return self.connection\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if exc_type is None:\n            self.connection.commit()\n        else:\n            self.connection.rollback()\n        return False  # Don't suppress exceptions\n```\n\n---\n\n## Quick Reference\n\n### Must-Have Tools\n\n| Tool | Purpose | Command |\n|------|---------|---------|\n| ruff | Linting + Formatting | `ruff check . && ruff format .` |\n| mypy | Type checking | `mypy src/` |\n| pytest | Testing | `pytest tests/` |\n| pre-commit | Git hooks | `pre-commit run --all-files` |\n\n### Project Checklist\n\n- [ ] `pyproject.toml` configured\n- [ ] Virtual environment set up\n- [ ] Pre-commit hooks installed\n- [ ] Type hints on public API\n- [ ] Docstrings on public modules/classes/functions\n- [ ] Tests with good coverage\n- [ ] Logging configured\n- [ ] Environment variables for secrets\n- [ ] CI/CD pipeline configured\n\n### Common Commands\n\n```bash\n# Setup\npython -m venv .venv\nsource .venv/bin/activate\npip install -e \".[dev]\"\npre-commit install\n\n# Development\nruff check . --fix\nruff format .\nmypy src/\npytest tests/ -v --cov\n\n# Build\npython -m build\ntwine check dist/*\n```\n\n---\n\n## References\n\n- [PEP 8 – Style Guide for Python Code](https://peps.python.org/pep-0008/)\n- [PEP 257 – Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 484 – Type Hints](https://peps.python.org/pep-0484/)\n- [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)\n- [Python Packaging User Guide](https://packaging.python.org/)\n- [Real Python Tutorials](https://realpython.com/)\n- [mypy Documentation](https://mypy.readthedocs.io/)\n- [pytest Documentation](https://docs.pytest.org/)\n",
        "skills/python-code-review/references/checklist.md": "# Python Code Review Checklist\n\nA comprehensive checklist for conducting effective Python code reviews. Use this guide to ensure code quality, maintainability, security, and performance.\n\n---\n\n## Table of Contents\n\n1. [Style and Formatting](#1-style-and-formatting)\n2. [Naming Conventions](#2-naming-conventions)\n3. [Function and Method Design](#3-function-and-method-design)\n4. [Class and Object Design](#4-class-and-object-design)\n5. [Error Handling](#5-error-handling)\n6. [Security](#6-security)\n7. [Performance](#7-performance)\n8. [Testing](#8-testing)\n9. [Documentation](#9-documentation)\n10. [Code Organization](#10-code-organization)\n11. [Dependencies](#11-dependencies)\n12. [Pre-Production Cleanup](#12-pre-production-cleanup)\n\n---\n\n## 1. Style and Formatting\n\nConsistent formatting improves readability and reduces cognitive load for team members.\n\n### Automated Checks\n\n- [ ] **Linter passes** - Code passes `ruff`, `flake8`, or `pylint` without errors\n- [ ] **Formatter applied** - Code is formatted with `black`, `ruff format`, or similar\n- [ ] **Import sorting** - Imports are sorted (standard library, third-party, local)\n- [ ] **Type checker passes** - No `mypy` or `pyright` errors\n\n### Manual Checks\n\n- [ ] **Line length** - Lines are under 88-120 characters (project standard)\n- [ ] **Blank lines** - Appropriate spacing between functions/classes (2 lines top-level, 1 line methods)\n- [ ] **Indentation** - Consistent 4-space indentation throughout\n- [ ] **No trailing whitespace** - Lines don't end with unnecessary spaces\n- [ ] **File ends with newline** - All files end with a single newline\n\n### Common Issues to Flag\n\n```python\n# Bad: Inconsistent spacing\ndef foo( x,y ):\n    return x+y\n\n# Good: Consistent spacing\ndef foo(x, y):\n    return x + y\n\n# Bad: Multiple statements on one line\nif condition: do_something(); do_another()\n\n# Good: Separate lines\nif condition:\n    do_something()\n    do_another()\n```\n\n---\n\n## 2. Naming Conventions\n\nClear, descriptive names make code self-documenting and easier to maintain.\n\n### Checklist\n\n- [ ] **Variables use snake_case** - `user_count`, `is_valid`, `max_retries`\n- [ ] **Functions use snake_case** - `calculate_total()`, `get_user_by_id()`\n- [ ] **Classes use PascalCase** - `UserAccount`, `HTTPClient`, `XMLParser`\n- [ ] **Constants use UPPER_SNAKE_CASE** - `MAX_CONNECTIONS`, `DEFAULT_TIMEOUT`\n- [ ] **Private members use leading underscore** - `_internal_method()`, `_cache`\n- [ ] **No single-letter names** (except loop counters `i`, `j`, `k`)\n- [ ] **No ambiguous abbreviations** - `usr` → `user`, `cnt` → `count`\n- [ ] **Boolean variables are questions** - `is_active`, `has_permission`, `can_edit`\n\n### Naming Quality Questions\n\n- [ ] Can you understand what this variable holds without reading surrounding code?\n- [ ] Does the function name describe what it does (verb + noun)?\n- [ ] Are similar concepts named consistently throughout the codebase?\n- [ ] Would a new team member understand these names?\n\n### Examples\n\n```python\n# Bad: Unclear names\ndef proc(d):\n    r = []\n    for x in d:\n        if x.s == 1:\n            r.append(x)\n    return r\n\n# Good: Descriptive names\ndef get_active_users(users: list[User]) -> list[User]:\n    active_users = []\n    for user in users:\n        if user.status == UserStatus.ACTIVE:\n            active_users.append(user)\n    return active_users\n\n# Better: Using comprehension\ndef get_active_users(users: list[User]) -> list[User]:\n    return [user for user in users if user.status == UserStatus.ACTIVE]\n```\n\n---\n\n## 3. Function and Method Design\n\nSmall, single-purpose functions are easier to understand, test, and maintain.\n\n### Single Responsibility\n\n- [ ] **Does one thing** - Function has a single, clear purpose\n- [ ] **Fits on one screen** - Generally under 20-30 lines\n- [ ] **Single level of abstraction** - Doesn't mix high-level and low-level operations\n- [ ] **No side effects** (unless clearly documented)\n- [ ] **Returns consistent types** - Doesn't return different types conditionally\n\n### Parameters\n\n- [ ] **Few parameters** - Ideally 3 or fewer; consider a dataclass for more\n- [ ] **No boolean flags** - Prefer separate functions over `do_thing(full=True)`\n- [ ] **Sensible defaults** - Default values are safe and commonly used\n- [ ] **Type hints present** - All parameters and return types annotated\n- [ ] ] **No mutable default arguments** - Don't use `def foo(items=[])`\n\n### Common Issues\n\n```python\n# Bad: Mutable default argument\ndef add_item(item, items=[]):  # Bug: list is shared!\n    items.append(item)\n    return items\n\n# Good: Use None and create new list\ndef add_item(item, items: list | None = None) -> list:\n    if items is None:\n        items = []\n    items.append(item)\n    return items\n\n# Bad: Boolean flag creating two functions in one\ndef get_users(include_inactive=False):\n    if include_inactive:\n        return db.query(User).all()\n    return db.query(User).filter(User.active == True).all()\n\n# Good: Separate, clear functions\ndef get_all_users() -> list[User]:\n    return db.query(User).all()\n\ndef get_active_users() -> list[User]:\n    return db.query(User).filter(User.active == True).all()\n```\n\n### Loop Alternatives\n\n- [ ] **Consider list comprehensions** - More Pythonic for simple transformations\n- [ ] **Consider generator expressions** - For memory-efficient iteration\n- [ ] **Consider built-in functions** - `map()`, `filter()`, `sum()`, `any()`, `all()`\n- [ ] **Avoid nested loops** - Extract to separate functions when deep\n\n```python\n# Bad: Verbose loop\nresult = []\nfor item in items:\n    if item.is_valid:\n        result.append(item.value)\n\n# Good: List comprehension\nresult = [item.value for item in items if item.is_valid]\n\n# Bad: Nested loop for checking\nfound = False\nfor item in items:\n    if item.matches(criteria):\n        found = True\n        break\n\n# Good: Use any()\nfound = any(item.matches(criteria) for item in items)\n```\n\n---\n\n## 4. Class and Object Design\n\n### Design Principles\n\n- [ ] **Single Responsibility** - Class has one reason to change\n- [ ] **Proper encapsulation** - Implementation details are private\n- [ ] **Favor composition over inheritance** - Use has-a, not is-a when appropriate\n- [ ] **Design patterns used correctly** - Singleton, Factory, etc. implemented properly\n- [ ] **Dataclasses for data containers** - Use `@dataclass` for DTOs and value objects\n\n### Immutability\n\n- [ ] **Prefer immutable types** - Easier to reason about, fewer bugs\n- [ ] **Use frozen dataclasses** - `@dataclass(frozen=True)` for value objects\n- [ ] **Avoid modifying input parameters** - Create new objects instead\n- [ ] **Use tuples over lists** when data shouldn't change\n\n```python\n# Bad: Mutable class with side effects\nclass Config:\n    def __init__(self):\n        self.settings = {}\n\n    def load(self, path):\n        self.settings = load_file(path)  # Mutates state\n\n# Good: Immutable configuration\n@dataclass(frozen=True)\nclass Config:\n    database_url: str\n    debug: bool\n    max_connections: int\n\n    @classmethod\n    def from_file(cls, path: str) -> \"Config\":\n        data = load_file(path)\n        return cls(**data)\n```\n\n### Class Checklist\n\n- [ ] **`__init__` only initializes** - No complex logic in constructor\n- [ ] **`__repr__` defined** - For debugging (auto with dataclass)\n- [ ] **`__eq__` defined if needed** - For comparison (auto with dataclass)\n- [ ] **No god objects** - Classes shouldn't do everything\n- [ ] **Interfaces are small** - Prefer many small interfaces to one large\n\n---\n\n## 5. Error Handling\n\n### Exception Handling\n\n- [ ] **Specific exceptions caught** - Never bare `except:` or `except Exception:`\n- [ ] **Exceptions not silenced** - Don't catch and ignore without logging\n- [ ] **Custom exceptions defined** - For domain-specific errors\n- [ ] **Exception chain preserved** - Use `raise ... from e`\n- [ ] **Try blocks are small** - Only wrap code that might fail\n- [ ] **Finally for cleanup** - Or use context managers\n\n### Common Issues\n\n```python\n# Bad: Bare except silences everything\ntry:\n    process_data()\nexcept:\n    pass\n\n# Bad: Catching too broad, losing information\ntry:\n    user = get_user(user_id)\n    orders = get_orders(user.id)\nexcept Exception as e:\n    return None  # Which operation failed?\n\n# Good: Specific handling with context\ntry:\n    user = get_user(user_id)\nexcept UserNotFoundError:\n    logger.warning(f\"User {user_id} not found\")\n    return None\nexcept DatabaseError as e:\n    logger.exception(\"Database error fetching user\")\n    raise ServiceUnavailableError(\"Database unavailable\") from e\n```\n\n### Error Messages\n\n- [ ] **Actionable messages** - Tell user/developer what to do\n- [ ] **Include context** - What values caused the error?\n- [ ] **No sensitive data** - Don't expose passwords, tokens in errors\n- [ ] **Consistent format** - Similar errors formatted similarly\n\n```python\n# Bad: Unhelpful error\nraise ValueError(\"Invalid input\")\n\n# Good: Actionable with context\nraise ValueError(\n    f\"Invalid email format: '{email}'. \"\n    f\"Expected format: user@domain.com\"\n)\n```\n\n---\n\n## 6. Security\n\n### Input Validation\n\n- [ ] **All external inputs validated** - User input, API responses, file contents\n- [ ] **Type checking** - Verify types before processing\n- [ ] **Range checking** - Numbers within expected bounds\n- [ ] **Format validation** - Emails, URLs, dates properly formatted\n- [ ] **Length limits** - Strings and collections have max sizes\n\n### SQL and Injection\n\n- [ ] **No string formatting in SQL** - Use parameterized queries only\n- [ ] **ORM used correctly** - No raw SQL concatenation\n- [ ] **Input sanitized** - Even with ORM, validate inputs\n\n```python\n# CRITICAL: SQL Injection vulnerability\nquery = f\"SELECT * FROM users WHERE id = {user_id}\"  # NEVER DO THIS\n\n# Safe: Parameterized query\ncursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))\n\n# Safe: ORM\nuser = session.query(User).filter(User.id == user_id).first()\n```\n\n### Secrets and Sensitive Data\n\n- [ ] **No hardcoded secrets** - Use environment variables\n- [ ] **Secrets not logged** - Check log statements don't expose credentials\n- [ ] **Secrets not in URLs** - API keys not in query strings\n- [ ] **`.env` in `.gitignore`** - Environment files not committed\n- [ ] **Passwords properly hashed** - Using bcrypt, argon2, or similar\n\n### Path Traversal\n\n- [ ] **User paths validated** - Prevent `../` attacks\n- [ ] **Paths resolved and checked** - Verify within allowed directory\n\n```python\n# Bad: Path traversal vulnerability\ndef read_file(filename):\n    return open(f\"/data/{filename}\").read()  # User could pass \"../etc/passwd\"\n\n# Good: Validate path\ndef read_file(filename: str) -> str:\n    base = Path(\"/data\").resolve()\n    file_path = (base / filename).resolve()\n    if not str(file_path).startswith(str(base)):\n        raise ValueError(\"Invalid file path\")\n    return file_path.read_text()\n```\n\n### Other Security Checks\n\n- [ ] **No `eval()` or `exec()`** - Especially with user input\n- [ ] **No `pickle` with untrusted data** - Use JSON instead\n- [ ] **HTTPS for external calls** - No HTTP for sensitive data\n- [ ] **Rate limiting considered** - For public endpoints\n- [ ] **Authentication checked** - Protected resources require auth\n\n---\n\n## 7. Performance\n\n### Algorithmic Efficiency\n\n- [ ] **Appropriate data structures** - Set for membership, dict for lookup\n- [ ] **No unnecessary iterations** - Don't loop multiple times when once suffices\n- [ ] **Early returns** - Exit loops/functions when result is known\n- [ ] **Lazy evaluation** - Use generators for large datasets\n\n### Common Performance Issues\n\n```python\n# Bad: O(n) lookup in list\nif user_id in user_list:  # Scans entire list\n    process(user_id)\n\n# Good: O(1) lookup in set\nuser_set = set(user_list)\nif user_id in user_set:  # Constant time\n    process(user_id)\n\n# Bad: Loading entire file into memory\ndata = open(\"huge_file.txt\").read()\nfor line in data.split(\"\\n\"):\n    process(line)\n\n# Good: Streaming line by line\nwith open(\"huge_file.txt\") as f:\n    for line in f:\n        process(line)\n\n# Bad: Repeated string concatenation\nresult = \"\"\nfor item in items:\n    result += str(item)  # Creates new string each time\n\n# Good: Join once\nresult = \"\".join(str(item) for item in items)\n```\n\n### Database Queries\n\n- [ ] **N+1 queries avoided** - Use eager loading or batch queries\n- [ ] **Indexes used** - Queries use indexed columns\n- [ ] **Pagination implemented** - Large result sets paginated\n- [ ] **Connections pooled** - Not creating new connections per request\n\n### Caching\n\n- [ ] **Appropriate caching** - Expensive operations cached when beneficial\n- [ ] **Cache invalidation** - Cache is cleared when data changes\n- [ ] **TTL set** - Cached data expires appropriately\n\n```python\nfrom functools import lru_cache\n\n# Good: Cache expensive computation\n@lru_cache(maxsize=128)\ndef get_user_permissions(user_id: int) -> set[str]:\n    # Expensive database query\n    return fetch_permissions_from_db(user_id)\n```\n\n---\n\n## 8. Testing\n\n### Test Coverage\n\n- [ ] **Happy path tested** - Normal usage works\n- [ ] **Edge cases tested** - Empty inputs, boundaries, nulls\n- [ ] **Error cases tested** - Expected exceptions raised\n- [ ] **Integration points tested** - External services mocked appropriately\n\n### Test Quality\n\n- [ ] **Tests are independent** - No shared mutable state\n- [ ] **Tests are deterministic** - Same result every time\n- [ ] **Test names describe behavior** - `test_user_creation_with_invalid_email_raises_error`\n- [ ] **One assertion focus** - Each test verifies one behavior\n- [ ] **Fixtures used appropriately** - Shared setup in fixtures\n\n### Test Checklist\n\n```python\n# Good test structure\nclass TestUserService:\n    \"\"\"Tests for UserService.\"\"\"\n\n    def test_create_user_with_valid_data_succeeds(self, db):\n        \"\"\"Creating a user with valid data should succeed.\"\"\"\n        service = UserService(db)\n        user = service.create(name=\"Alice\", email=\"alice@example.com\")\n\n        assert user.id is not None\n        assert user.name == \"Alice\"\n        assert user.email == \"alice@example.com\"\n\n    def test_create_user_with_duplicate_email_raises_error(self, db, existing_user):\n        \"\"\"Creating a user with existing email should raise DuplicateEmailError.\"\"\"\n        service = UserService(db)\n\n        with pytest.raises(DuplicateEmailError) as exc_info:\n            service.create(name=\"Bob\", email=existing_user.email)\n\n        assert \"already exists\" in str(exc_info.value)\n\n    def test_create_user_with_empty_name_raises_validation_error(self, db):\n        \"\"\"Creating a user with empty name should raise ValidationError.\"\"\"\n        service = UserService(db)\n\n        with pytest.raises(ValidationError):\n            service.create(name=\"\", email=\"test@example.com\")\n```\n\n### What Should Be Tested?\n\n- [ ] Public API methods\n- [ ] Business logic and calculations\n- [ ] Data transformations\n- [ ] Error handling paths\n- [ ] Edge cases (empty, null, max values)\n- [ ] Integration with external services (mocked)\n\n---\n\n## 9. Documentation\n\n### Docstrings\n\n- [ ] **Public functions documented** - Args, returns, raises\n- [ ] **Public classes documented** - Purpose and usage\n- [ ] **Modules have docstrings** - Overview at top of file\n- [ ] **Complex logic explained** - Why, not just what\n- [ ] **Examples included** - For non-obvious usage\n\n### Docstring Quality\n\n```python\n# Bad: Useless docstring\ndef process(data):\n    \"\"\"Process the data.\"\"\"\n    pass\n\n# Good: Informative docstring\ndef process_transaction(\n    transaction: Transaction,\n    validate: bool = True,\n) -> TransactionResult:\n    \"\"\"Process a financial transaction and update account balances.\n\n    Validates the transaction, checks sufficient funds, applies the\n    transaction to source and destination accounts, and records\n    the transaction in the audit log.\n\n    Args:\n        transaction: The transaction to process.\n        validate: Whether to validate before processing. Set to False\n            only for internal transfers that are pre-validated.\n\n    Returns:\n        TransactionResult containing the updated balances and\n        confirmation number.\n\n    Raises:\n        InsufficientFundsError: If source account lacks funds.\n        InvalidTransactionError: If validation fails.\n        AccountLockedError: If either account is locked.\n\n    Example:\n        >>> txn = Transaction(from_account=123, to_account=456, amount=100)\n        >>> result = process_transaction(txn)\n        >>> print(result.confirmation_number)\n        'TXN-2024-001234'\n    \"\"\"\n```\n\n### Comments\n\n- [ ] **No obvious comments** - Don't explain what code does literally\n- [ ] **Why comments present** - Explain non-obvious decisions\n- [ ] **TODO/FIXME with context** - Include ticket numbers or deadlines\n- [ ] **No commented-out code** - Delete it; use version control\n\n```python\n# Bad: Obvious comment\n# Increment counter by 1\ncounter += 1\n\n# Good: Explains why\n# Use exponential backoff to avoid overwhelming the server\n# during recovery after an outage\ndelay = base_delay * (2 ** attempt)\n\n# Good: TODO with context\n# TODO(JIRA-123): Replace with batch API once available\nfor item in items:\n    api.process_single(item)\n```\n\n---\n\n## 10. Code Organization\n\n### Imports\n\n- [ ] **Absolute imports preferred** - `from mypackage.module import func`\n- [ ] **No wildcard imports** - Don't use `from module import *`\n- [ ] **Imports at top of file** - Not inside functions (except for circular deps)\n- [ ] **No unused imports** - Remove imports that aren't used\n- [ ] **Grouped correctly** - stdlib, third-party, local (with blank lines)\n\n```python\n# Good: Properly organized imports\nimport os\nimport sys\nfrom pathlib import Path\n\nimport httpx\nfrom pydantic import BaseModel\n\nfrom mypackage.config import settings\nfrom mypackage.utils import helpers\n```\n\n### Module Structure\n\n- [ ] **One class per file** (for large classes) or related classes grouped\n- [ ] **Logical grouping** - Related functionality in same module\n- [ ] **No circular imports** - Restructure if present\n- [ ] **`__all__` defined** - Explicit public API in modules\n\n### DRY (Don't Repeat Yourself)\n\n- [ ] **No duplicated code** - Extract common logic to functions\n- [ ] **Utilities extracted** - Reusable code in utils modules\n- [ ] **Built-ins used** - Don't reimplement standard library\n- [ ] **Third-party considered** - Use maintained packages for common needs\n\n```python\n# Bad: Duplicated logic\ndef process_user(user):\n    if not user.email or \"@\" not in user.email:\n        raise ValueError(\"Invalid email\")\n    # ... process\n\ndef process_admin(admin):\n    if not admin.email or \"@\" not in admin.email:\n        raise ValueError(\"Invalid email\")\n    # ... process\n\n# Good: Extracted validation\ndef validate_email(email: str) -> None:\n    if not email or \"@\" not in email:\n        raise ValueError(f\"Invalid email: {email}\")\n\ndef process_user(user):\n    validate_email(user.email)\n    # ... process\n\ndef process_admin(admin):\n    validate_email(admin.email)\n    # ... process\n```\n\n---\n\n## 11. Dependencies\n\n### Dependency Management\n\n- [ ] **Dependencies pinned** - Exact versions in lock file\n- [ ] **Minimal dependencies** - Only add what's necessary\n- [ ] **Maintained packages** - No abandoned/unmaintained deps\n- [ ] **Security vulnerabilities checked** - Run `pip-audit` or similar\n- [ ] **License compatible** - Dependencies have compatible licenses\n\n### Upgrading Dependencies\n\n- [ ] **Changelog reviewed** - Check for breaking changes\n- [ ] **Tests pass** - After upgrade, all tests still pass\n- [ ] **Gradual upgrades** - Don't upgrade everything at once\n- [ ] **Major versions careful** - Plan and test major version bumps\n\n### Import Best Practices\n\n- [ ] **No version-specific hacks** - Use proper version constraints\n- [ ] **Optional dependencies handled** - Try/except for optional imports\n- [ ] **Import errors graceful** - Clear message if dependency missing\n\n```python\n# Good: Optional dependency handling\ntry:\n    import pandas as pd\n    HAS_PANDAS = True\nexcept ImportError:\n    HAS_PANDAS = False\n    pd = None\n\ndef export_to_dataframe(data):\n    if not HAS_PANDAS:\n        raise ImportError(\n            \"pandas is required for this feature. \"\n            \"Install with: pip install mypackage[pandas]\"\n        )\n    return pd.DataFrame(data)\n```\n\n---\n\n## 12. Pre-Production Cleanup\n\n### Remove Before Merging\n\n- [ ] **No debug statements** - Remove `print()`, `breakpoint()`, `pdb`\n- [ ] **No commented-out code** - Delete unused code\n- [ ] **No TODO for this PR** - Complete or convert to tickets\n- [ ] **No temporary files** - Remove test files, scratch code\n- [ ] **No hardcoded values** - URLs, IDs should be configurable\n\n### Verify Before Merging\n\n- [ ] **All tests pass** - CI is green\n- [ ] **No merge conflicts** - Rebased on main\n- [ ] **Commit messages clean** - Descriptive, follows conventions\n- [ ] **PR description complete** - Explains what and why\n- [ ] **No secrets committed** - Check for API keys, passwords\n\n### Final Checks\n\n```python\n# Remove these before production:\nprint(\"DEBUG:\", some_value)  # Remove\nbreakpoint()  # Remove\nimport pdb; pdb.set_trace()  # Remove\n\n# # Old implementation  # Remove commented code\n# def old_function():\n#     pass\n\n# TODO: Fix this later  # Convert to ticket or fix now\n\nAPI_KEY = \"sk-1234567890\"  # NEVER commit secrets\n```\n\n---\n\n## Quick Reference Card\n\n### Before Starting Review\n\n1. Pull the branch and run tests locally\n2. Run linter: `ruff check .`\n3. Run type checker: `mypy src/`\n4. Read the PR description\n\n### During Review\n\nAsk yourself:\n- Would I understand this code in 6 months?\n- Is this the simplest solution?\n- Are there obvious bugs or edge cases?\n- Is it secure?\n- Is it tested?\n\n### Red Flags to Watch For\n\n| Issue | Why It's Bad |\n|-------|--------------|\n| Bare `except:` | Hides bugs, catches KeyboardInterrupt |\n| Mutable default args | Shared state between calls |\n| `eval()`/`exec()` | Security vulnerability |\n| SQL string formatting | Injection vulnerability |\n| No type hints | Harder to maintain |\n| Magic numbers | Unclear meaning |\n| God functions (>50 lines) | Hard to test and maintain |\n| No tests | Can't verify behavior |\n\n### Approve When\n\n- [ ] Code is correct and handles edge cases\n- [ ] Code is readable and maintainable\n- [ ] Tests cover important paths\n- [ ] No security issues\n- [ ] Follows project conventions\n- [ ] Documentation is adequate\n\n---\n\n## References\n\n- [JetBrains Python Code Review Checklist](https://www.jetbrains.com/pages/static-code-analysis-guide/python-code-review-checklist/)\n- [PEP 8 – Style Guide for Python Code](https://peps.python.org/pep-0008/)\n- [Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)\n- [OWASP Python Security](https://cheatsheetseries.owasp.org/cheatsheets/Python_Security_Cheat_Sheet.html)\n- [Real Python Code Quality](https://realpython.com/python-code-quality/)\n"
      },
      "plugins": [
        {
          "name": "python-code-review",
          "description": "Review Python code changes in merge requests and pull requests",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/python-code-review"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add thoo/agent-skills",
            "/plugin install python-code-review@my-agent-skills"
          ]
        }
      ]
    }
  ]
}