{
  "author": {
    "id": "sancodeee",
    "display_name": "sen wang",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/98593798?u=cb6c0f4c3503e8e82accdd6ff2132dcc2a8f39cf&v=4",
    "url": "https://github.com/sancodeee",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 3,
      "total_commands": 3,
      "total_skills": 3,
      "total_stars": 0,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "sen-claude-hub",
      "version": null,
      "description": "Some plugin repositories related to Claude code",
      "owner_info": {
        "name": "sen",
        "url": "https://github.com/sancodeee"
      },
      "keywords": [],
      "repo_full_name": "sancodeee/sen-claude-hub",
      "repo_url": "https://github.com/sancodeee/sen-claude-hub",
      "repo_description": "Some plugin repositories related to Claude code",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 1,
        "pushed_at": "2026-01-26T09:39:57Z",
        "created_at": "2026-01-24T14:57:45Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1026
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/fintorq-code-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/fintorq-code-style/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/fintorq-code-style/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 223
        },
        {
          "path": "plugins/fintorq-code-style/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/fintorq-code-style/commands/fintorq-code-style-invoke.md",
          "type": "blob",
          "size": 1145
        },
        {
          "path": "plugins/fintorq-code-style/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/fintorq-code-style/skills/fintorq-code-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/fintorq-code-style/skills/fintorq-code-style/SKILL.md",
          "type": "blob",
          "size": 41277
        },
        {
          "path": "plugins/global-java-code-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/global-java-code-style/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/global-java-code-style/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 259
        },
        {
          "path": "plugins/global-java-code-style/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/global-java-code-style/commands/global-java-code-style-invoke.md",
          "type": "blob",
          "size": 2083
        },
        {
          "path": "plugins/global-java-code-style/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/global-java-code-style/skills/global-java-code-style",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/global-java-code-style/skills/global-java-code-style/SKILL.md",
          "type": "blob",
          "size": 70488
        },
        {
          "path": "plugins/global-java-code-style/skills/global-java-code-style/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/global-java-code-style/skills/global-java-code-style/references/examples.md",
          "type": "blob",
          "size": 13569
        },
        {
          "path": "plugins/mcp-faster-caller",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mcp-faster-caller/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mcp-faster-caller/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 226
        },
        {
          "path": "plugins/mcp-faster-caller/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mcp-faster-caller/commands/mcp-faster-caller-invoke.md",
          "type": "blob",
          "size": 598
        },
        {
          "path": "plugins/mcp-faster-caller/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mcp-faster-caller/skills/mcp-faster-caller",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mcp-faster-caller/skills/mcp-faster-caller/SKILL.md",
          "type": "blob",
          "size": 1829
        },
        {
          "path": "plugins/mcp-faster-caller/skills/mcp-faster-caller/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/mcp-faster-caller/skills/mcp-faster-caller/references/README.md",
          "type": "blob",
          "size": 1647
        },
        {
          "path": "plugins/mcp-faster-caller/skills/mcp-faster-caller/references/configuration.md",
          "type": "blob",
          "size": 5543
        },
        {
          "path": "plugins/mcp-faster-caller/skills/mcp-faster-caller/references/mcp_aliases.md",
          "type": "blob",
          "size": 7546
        },
        {
          "path": "plugins/mcp-faster-caller/skills/mcp-faster-caller/references/troubleshooting.md",
          "type": "blob",
          "size": 2059
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"sen-claude-hub\",\n  \"owner\": {\n    \"name\": \"sen\",\n    \"url\": \"https://github.com/sancodeee\"\n  },\n  \"metadata\": {\n    \"description\": \"Some plugin repositories related to Claude code\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"mcp-faster-caller\",\n      \"source\": \"./plugins/mcp-faster-caller\",\n      \"description\": \"Optimize the MCP call process. When it comes to MCP call operations, it is highly recommended to use this plugin.\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"name\": \"global-java-code-style\",\n      \"source\": \"./plugins/global-java-code-style\",\n      \"description\": \"Provide standard guidelines for Java coding style, project structure, annotation specifications, exception handling, testing standards, etc.\",\n      \"version\": \"1.0.0\"\n    },\n    {\n      \"name\": \"fintorq-code-style\",\n      \"source\": \"./plugins/fintorq-code-style\",\n      \"description\": \"Official code style and development standards for Fintorq project. MUST be followed for all code generation.\",\n      \"version\": \"1.0.0\"\n    }\n  ]\n}",
        "plugins/fintorq-code-style/.claude-plugin/plugin.json": "{\n  \"name\": \"fintorq-code-style\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Official code style and development standards for Fintorq project. MUST be followed for all code generation.\",\n  \"author\": {\n    \"name\": \"sen\"\n  }\n}\n",
        "plugins/fintorq-code-style/commands/fintorq-code-style-invoke.md": "---\nname: fintorq-code-style:invoke\ndescription: Immediately call the fintorq-code-style skill to apply Fintorq code style specifications, perform checks and fixes on the current code or the code specified by the user.\n---\n\n你现在必须**立即且强制**调用已安装的 **fintorq-code-style** 这个 skill 来处理用户当前的需求。\n\n核心指令：\n1. 不要自己尝试编写或猜测代码风格规则。\n2. 直接使用 fintorq-code-style skill 的完整能力，包括但不限于：\n    - 分析当前文件/选中的代码块\n    - 应用 Fintorq 特定的代码风格（命名、缩进、注释、结构等）\n    - 进行 lint 检查、建议修复、自动格式化\n    - 如果需要，生成 diff 或直接修改代码\n3. 如果用户提供了具体文件、代码片段或目录，优先针对它们执行。\n4. skill 执行后，根据结果继续回复用户，包括展示修改建议、diff、解释变更原因。\n5. 如果当前上下文没有明显代码，询问用户要应用到哪个文件/项目。\n\n现在开始：调用 fintorq-code-style skill，并基于它的输出完整响应用户的最新消息。",
        "plugins/fintorq-code-style/skills/fintorq-code-style/SKILL.md": "---\nname: fintorq-code-style\ndescription: Official code style and development standards for the Fintorq project. MUST be followed for all Java code generation.\nuser-invocable: true\n---\n\n# Fintorq Code Style & Standards\n\nThis skill provides the official coding standards and development guidelines for the Fintorq project. All generated code must adhere to these rules.\n\n## 1. Tech Stack & Environment\n\n| Component | Specification |\n|-----------|---------------|\n| **Java Version** | Java 17 |\n| **Framework** | Spring Boot 3.x |\n| **ORM** | MyBatis-Plus (NOT JPA/Hibernate) |\n| **Build Tool** | Gradle (Multi-module) |\n| **Utils** | Lombok (Heavy usage), Hutool |\n| **Logging** | SLF4J |\n| **API Doc** | Knife4j/OpenAPI 3 |\n| **Security** | Spring Security + JWT |\n\n## 2. Project Structure & Package Organization\n\n### Module Organization\n```\ncom.fintorq.*\n├── {module}center/        # 模块名 (loancenter, usercenter, cmcenter 等)\n│   ├── controller/        # 控制器\n│   ├── service/           # 服务接口\n│   ├── service/impl/      # 服务实现\n│   ├── mapper/            # 数据访问\n│   ├── entity/            # 实体类 (PO)\n│   │   ├── po/            # 持久化对象\n│   │   ├── dto/           # 数据传输对象\n│   │   ├── vo/            # 视图对象\n│   │   ├── req/           # 请求对象\n│   │   └── resp/          # 响应对象\n│   └── constants/         # 常量定义\n```\n\n### Module Name Conventions\n| 模块 | Package Name |\n|------|--------------|\n| 贷款模块 | `loancenter` |\n| 用户模块 | `usercenter` |\n| 通用模块 | `cmcenter` |\n| 合作伙伴模块 | `partnercenter` |\n\n## 3. Naming Conventions\n\n### Class Naming\n| 类型 | 命名规范 | 示例 |\n|------|----------|------|\n| Controller | `{Name}Controller` | `LoanQuoteLeadController` |\n| Service Interface | `I{Name}Service` | `ILoanQuoteLeadService` |\n| Service Implementation | `{Name}ServiceImpl` | `LoanQuoteLeadServiceImpl` |\n| Mapper | `{Name}Mapper` | `LoanQuoteLeadMapper` |\n| Entity/PO | `{Name}` | `LoanQuoteLead` |\n| DTO | `{Name}DTO` | `DashboardDTO` |\n| VO | `{Name}VO` | `LoanQuoteLeadVO` |\n| Req | `{Name}Req` | `LoanQuoteLeadListReq` |\n| Resp | `{Name}Resp` | `DashboardResp` |\n| Config | `{Name}Config` | `ThreadPoolConfig` |\n| Enum | `{Name}Enum` | `LoanQuoteLeadStatusEnum` |\n\n### Method/Variable Naming\n| 类型 | 规范 | 示例 |\n|------|------|------|\n| Methods | lowerCamelCase | `getUserById`, `saveLoanQuoteLead` |\n| Variables | lowerCamelCase | `userId`, `loanQuoteLead` |\n| Constants | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT`, `DEFAULT_PAGE_SIZE` |\n| Boolean Methods | Prefix with `is`, `has`, `can` | `isValid()`, `hasPermission()` |\n\n## 4. Architectural Layers & Class Types\n\n### 4.1 Controller Layer\n\n**职责**: 处理 HTTP 请求，参数验证，调用 Service 层，返回响应\n\n**必需注解**:\n```java\n@Slf4j\n@Tag(name = \"模块名称\", description = \"模块描述\")\n@RestController\n@RequestMapping(\"/path\")  // lowerCamelCase\n@RequiredArgsConstructor(onConstructor = @__(@Autowired))\npublic class ExampleController {\n\n    private final IExampleService exampleService;\n}\n```\n\n**权限控制**:\n```java\n@PreAuthorize(\"hasAuthority('permission.code')\")\n```\n\n**返回类型**:\n- 有数据: `Result<T>`\n- 无数据: `void` (直接写入 response)\n- 分页: `Result<CommonPageResp<T>>`\n\n**完整示例**:\n```java\n@Slf4j\n@Tag(name = \"贷款报价线索管理模块\", description = \"贷款报价前端信息管理相关接口\")\n@RestController\n@RequestMapping(\"/loanQuoteLead\")\n@RequiredArgsConstructor(onConstructor = @__(@Autowired))\npublic class LoanQuoteLeadController {\n\n    private final ILoanQuoteLeadService loanQuoteLeadService;\n\n    /**\n     * 分页查询贷款报价线索列表\n     *\n     * @param req 查询条件\n     * @return 分页结果\n     */\n    @PostMapping(\"/getLoanQuoteLeadList\")\n    @Operation(summary = \"分页查询贷款报价线索列表\")\n    @PreAuthorize(\"hasAuthority('worklist.read')\")\n    public Result<CommonPageResp<LoanQuoteLeadListResp>> getLoanQuoteLeadList(\n            @Parameter(description = \"查询条件\", required = true)\n            @Valid @RequestBody LoanQuoteLeadListReq req) {\n\n        log.info(\"查询贷款报价线索列表，操作人：{}，查询条件：{}\",\n                RequestContext.getUserId(), req);\n\n        IPage<LoanQuoteLeadVO> voPage = loanQuoteLeadService.getLoanQuoteLeadList(req);\n        IPage<LoanQuoteLeadListResp> respPage = voPage.convert(LoanQuoteLeadListResp::toResp);\n        CommonPageResp<LoanQuoteLeadListResp> result = CommonPageResp.toCommonPageResp(respPage);\n\n        return Result.success(result);\n    }\n}\n```\n\n### 4.2 Service Layer\n\n**接口定义**:\n```java\npublic interface ILoanQuoteLeadService extends IService<LoanQuoteLead> {\n    SaveOrUpdateLoanQuoteLeadVO saveOrUpdateLoanQuoteLead(SaveOrUpdateLoanQuoteLeadDTO dto);\n    IPage<LoanQuoteLeadVO> getLoanQuoteLeadList(LoanQuoteLeadListReq req);\n}\n```\n\n**实现类**:\n```java\n@Slf4j\n@Service\n@RequiredArgsConstructor\npublic class LoanQuoteLeadServiceImpl extends ServiceImpl<LoanQuoteLeadMapper, LoanQuoteLead>\n        implements ILoanQuoteLeadService {\n\n    private final ILoanQuoteLeadNoteService loanQuoteLeadNoteService;\n\n    @Value(\"${sla.default}\")\n    private int slaHours;\n\n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public SaveOrUpdateLoanQuoteLeadVO saveOrUpdateLoanQuoteLead(\n            @NotNull SaveOrUpdateLoanQuoteLeadDTO dto) {\n        // 业务逻辑\n    }\n}\n```\n\n**依赖注入规范**:\n- 使用 `@RequiredArgsConstructor` (Lombok)\n- 不使用 `onConstructor = @__(@Autowired)` (Service 层可省略)\n- 注入字段使用 `private final`\n\n### 4.3 Mapper Layer\n\n**接口定义**:\n```java\n@Mapper\npublic interface LoanQuoteLeadMapper extends BaseMapper<LoanQuoteLead> {\n\n    IPage<LoanQuoteLeadDbVO> getLoanQuoteLeadPage(Page<LoanQuoteLeadDbVO> page,\n                                                     @Param(\"dto\") LoanQuoteLeadListDBDTO dto);\n}\n```\n\n**XML 映射文件位置**: `src/main/resources/mapper/{module}/`\n\n### 4.4 Entity/PO Layer\n\n**实体类规范**:\n```java\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\n@TableName(\"t_loan_quote_lead\")\npublic class LoanQuoteLead extends BaseCommonPO {\n\n    @TableId(type = IdType.AUTO)\n    private Long id;\n\n    @TableField(\"mobile\")\n    private String mobile;\n\n    @TableField(\"organization_code\")\n    private String organizationCode;\n\n    // BaseCommonPO 包含: createTime, updateTime, createBy, updateBy, deleteFlag\n}\n```\n\n**字段规范**:\n- 使用 `@TableName` 指定表名\n- 使用 `@TableId(type = IdType.AUTO)` 主键\n- 使用 `@TableField` 映射数据库字段\n- 继承 `BaseCommonPO` 获取通用字段\n\n### 4.5 Data Transfer Objects (Req/DTO/VO/Resp)\n\n**对象职责划分**:\n\n| 类型 | 职责 | 示例 |\n|------|------|------|\n| **Req** | 接收前端请求参数 | `LoanQuoteLeadListReq` |\n| **DTO** | Service 层内部数据传输 | `DashboardDTO` |\n| **VO** | Service 层返回给 Controller | `LoanQuoteLeadVO` |\n| **Resp** | 返回给前端 | `DashboardResp` |\n\n**示例**:\n```java\n// Req - 接收请求参数\n@Data\npublic class LoanQuoteLeadListReq {\n    @NotNull(message = \"页码不能为空\")\n    private Integer current;\n\n    @NotNull(message = \"页大小不能为空\")\n    private Integer size;\n\n    private String searchText;\n    private Integer timeRangeFilter;\n}\n\n// DTO - 内部数据传输\n@Data\npublic class DashboardDTO {\n    private String timePeriod;\n}\n\n// VO - Service 层返回\n@Data\npublic class LoanQuoteLeadVO {\n    private Long id;\n    private String mobile;\n    private Integer status;\n}\n\n// Resp - 返回给前端\n@Data\npublic class DashboardResp {\n    private Integer naf;\n    private BigDecimal potentialSales;\n}\n```\n\n### 4.6 【强制】分层架构数据类型约束\n\n**严格遵循各层的数据类型规范，确保清晰的职责边界和数据流向**。\n\n#### 4.6.1 Controller 层约束\n\n**方法入参类型**：\n- ✅ 允许：基本类型参数（`Long id`, `String code` 等）\n- ✅ 允许：**Req** 对象\n- ❌ 禁止：DTO、VO、DbVO、Resp 对象\n\n**方法返回值类型**：\n- ✅ 允许：基本类型参数\n- ✅ 允许：**Resp** 对象（通过 `Result<Resp>` 包装）\n- ❌ 禁止：DTO、VO、DbVO、Req 对象\n\n**示例**：\n```java\n// ✅ 正确 - 使用 Req 入参，Resp 返回值\n@PostMapping(\"/getLoanQuoteLeadList\")\npublic Result<CommonPageResp<LoanQuoteLeadListResp>> getLoanQuoteLeadList(\n        @Valid @RequestBody LoanQuoteLeadListReq req) {\n    IPage<LoanQuoteLeadVO> voPage = loanQuoteLeadService.getLoanQuoteLeadList(req);\n    IPage<LoanQuoteLeadListResp> respPage = voPage.convert(LoanQuoteLeadListResp::toResp);\n    return Result.success(CommonPageResp.toCommonPageResp(respPage));\n}\n\n// ❌ 错误 - Controller 不应直接返回 VO\npublic Result<IPage<LoanQuoteLeadVO>> getLoanQuoteLeadList(LoanQuoteLeadListReq req) {\n    return Result.success(loanQuoteLeadService.getLoanQuoteLeadList(req));\n}\n\n// ❌ 错误 - Controller 不应接收 DTO\npublic Result<Resp> method(Dto dto) {\n    // ...\n}\n```\n\n#### 4.6.2 Service 层约束\n\n**方法入参类型**：\n- ✅ 允许：基本类型参数\n- ✅ 允许：**DTO** 对象、**Req** 对象\n- ❌ 禁止：VO、DbVO、Resp 对象\n\n**方法返回值类型**：\n- ✅ 允许：基本类型参数\n- ✅ 允许：**VO** 对象\n- ❌ 禁止：DTO、DbVO、Resp、Req 对象\n\n**示例**：\n```java\n// ✅ 正确 - 使用 DTO 入参，VO 返回值\npublic interface ILoanQuoteLeadService extends IService<LoanQuoteLead> {\n    SaveOrUpdateLoanQuoteLeadVO saveOrUpdateLoanQuoteLead(SaveOrUpdateLoanQuoteLeadDTO dto);\n    IPage<LoanQuoteLeadVO> getLoanQuoteLeadList(LoanQuoteLeadListReq req);\n}\n\n// ❌ 错误 - Service 不应返回 DTO\npublic SaveOrUpdateLoanQuoteLeadDTO saveOrUpdateLoanQuoteLead(SaveOrUpdateLoanQuoteLeadDTO dto) {\n    // ...\n}\n\n// ❌ 错误 - Service 不应直接返回 DbVO\npublic IPage<LoanQuoteLeadDbVO> getLoanQuoteLeadPage(LoanQuoteLeadListReq req) {\n    // ...\n}\n```\n\n#### 4.6.3 Mapper 层约束\n\n**方法入参类型**：\n- ✅ 允许：基本类型参数\n- ✅ 允许：**DTO** 对象（需加 `@Param(\"dto\")` 注解）\n- ❌ 禁止：Req、VO、DbVO、Resp 对象\n\n**方法返回值类型**：\n- ✅ 允许：基本类型参数\n- ✅ 允许：**DbVO** 对象\n- ❌ 禁止：DTO、VO、Resp、Req 对象\n\n**示例**：\n```java\n// ✅ 正确 - 使用 DTO 入参，DbVO 返回值\n@Mapper\npublic interface LoanQuoteLeadMapper extends BaseMapper<LoanQuoteLead> {\n    IPage<LoanQuoteLeadDbVO> getLoanQuoteLeadPage(Page<LoanQuoteLeadDbVO> page,\n                                                   @Param(\"dto\") LoanQuoteLeadListDBDTO dto);\n}\n\n// ❌ 错误 - Mapper 不应返回 VO\nIPage<LoanQuoteLeadVO> getLoanQuoteLeadPage(Page<LoanQuoteLeadVO> page,\n                                            @Param(\"dto\") LoanQuoteLeadListDBDTO dto);\n\n// ❌ 错误 - Mapper 不应接收 Req\nIPage<LoanQuoteLeadDbVO> getLoanQuoteLeadPage(Page<LoanQuoteLeadDbVO> page,\n                                              @Param(\"req\") LoanQuoteLeadListReq req);\n```\n\n#### 4.6.4 数据流向图\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                        数据流向                                  │\n├─────────────────────────────────────────────────────────────────┤\n│                                                                 │\n│  Frontend                                                       │\n│     │                                                           │\n│     │ ① Req                                                     │\n│     ▼                                                           │\n│  ┌─────────────┐                                               │\n│  │ Controller  │                                               │\n│  │  ─────────  │   ② DTO/Req                                   │\n│  │     │       │ ───────────────────────┐                       │\n│  └─────────────┘                       │                       │\n│       │                                 │                       │\n│       │ ③ VO                            ▼                       │\n│  ┌─────────────┐   ┌─────────────┐   ┌─────────────┐          │\n│  │   (convert) │   │   Service   │   │   Mapper    │          │\n│  │  ─────────  │   │  ─────────  │   │  ─────────  │          │\n│  │      │      │   │     │       │   │     │       │          │\n│  │      │      │   └─────────────┘   └─────────────┘          │\n│  │      │      │         │                 │                   │\n│  │      │      │         │ ④ DTO           │ ⑤ DbVO            │\n│  │      │      │         │ ─────────────── │ ───────────────┐  │\n│  │      ▼      │         │                 │                │  │\n│  │  ┌───────┐  │         │                 ▼                ▼  │\n│  │  │ Resp  │  │         │           ┌─────────────┐   ┌─────────────┐\n│  │  └───────┘  │         │           │  Database   │   │  Database   │\n│  │             │         │           └─────────────┘   └─────────────┘\n│  └─────────────┘         │\n│       │                 │\n│       │ ⑥ Resp                                                     │\n│       ▼                                                           │\n│  Frontend                                                       │\n│                                                                 │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n**数据类型用途说明**：\n\n| 类型 | 使用场景 | 可出现层次 |\n|------|----------|-----------|\n| **Req** | 接收前端请求参数 | Controller → Service |\n| **Resp** | 返回数据给前端 | Controller |\n| **DTO** | Service 层内部数据传输 | Service ↔ Mapper |\n| **VO** | Service 层业务数据封装 | Service → Controller |\n| **DbVO** | 数据库查询结果封装 | Mapper → Service |\n\n## 5. Dependency Injection & Configuration\n\n### 5.1 依赖注入方式\n\n**推荐方式**: `@RequiredArgsConstructor`\n```java\n@Service\n@RequiredArgsConstructor\npublic class ExampleServiceImpl {\n\n    private final IExampleService exampleService;\n    private final IOrgFacadeService orgFacadeService;\n}\n```\n\n**Controller 层**: 可添加 `onConstructor = @__(@Autowired)`\n```java\n@RequiredArgsConstructor(onConstructor = @__(@Autowired))\n```\n\n### 5.2 配置类规范\n\n**命名**: `{Name}Config`\n\n**示例**:\n```java\n@Configuration\n@EnableDataPermission\npublic class MybatisPlusConfig {\n\n    @Bean\n    public MybatisPlusInterceptor mybatisPlusInterceptor() {\n        // 配置\n    }\n}\n```\n\n## 6. API Design Standards\n\n### 6.1 REST API 路径设计\n\n**规范**:\n- 使用 lowerCamelCase (小驼峰)\n- 名词复数表示资源集合\n- 使用 HTTP 方法语义\n\n**示例**:\n```\nPOST   /api/loanQuoteLead/getLoanQuoteLeadList\nPOST   /api/loanQuoteLead/saveOrUpdate\nPOST   /api/loanQuoteLead/addNote\nPOST   /api/loanQuoteLead/export\n```\n\n### 6.2 输入验证与安全\n\n**对所有外部输入进行严格验证和清洗**:\n\n```java\n@Data\npublic class LoanQuoteLeadListReq {\n    @NotNull(message = \"页码不能为空\")\n    @Min(value = 1, message = \"页码必须大于0\")\n    private Integer current;\n\n    @NotNull(message = \"页大小不能为空\")\n    @Min(value = 1, message = \"页大小必须大于0\")\n    @Max(value = 100, message = \"页大小不能超过100\")\n    private Integer size;\n\n    @Pattern(regexp = \"^$|^[A-Za-z0-9]+$\", message = \"搜索文本只能包含字母和数字\")\n    private String searchText;\n}\n```\n\n**安全原则**:\n- 使用 `@Valid` 或 `@Validated` 触发验证\n- 使用 `@PreAuthorize` 进行权限控制\n- 防止 SQL 注入：使用 MyBatis-Plus 参数绑定\n- 防止 XSS：对用户输入进行编码\n- 敏感数据（密码、密钥）不在日志中明文输出\n\n**敏感数据日志安全**:\n```java\n// ❌ 错误 - 密码明文输出\nlog.info(\"User login: username={}, password={}\", username, password);\n\n// ✅ 正确 - 不记录敏感信息\nlog.info(\"User login attempt: username={}\", username);\n\n// ✅ 正确 - 脱敏处理\nlog.info(\"User login: username={}, password=****\", username);\n```\n\n### 6.3 权限控制\n\n**使用 `@PreAuthorize` 注解**:\n```java\n@PreAuthorize(\"hasAuthority('worklist.read')\")\n@PreAuthorize(\"hasAuthority('worklist.write')\")\n@PreAuthorize(\"hasAuthority('dashboard')\")\n@PreAuthorize(\"hasAuthority('report')\")\n```\n\n**权限码位置**: `com.fintorq.common.core.enums.auth.PermissionCodeEnum`\n\n### 6.4 Swagger 文档注解\n\n```java\n@Tag(name = \"模块名称\", description = \"模块描述\")\n@Operation(summary = \"接口摘要\", description = \"详细描述\")\n@Parameter(description = \"参数描述\", required = true)\n```\n\n## 7. Data Access Standards\n\n### 7.1 MyBatis-Plus 使用规范\n\n**基础 CRUD**: 使用 `IService` 和 `ServiceImpl` 提供的方法\n```java\n// 查询单个\nLoanQuoteLead lead = this.getById(leadId);\n\n// 查询列表\nList<LoanQuoteLead> leads = this.list();\n\n// 保存\nboolean success = this.save(loanQuoteLead);\n\n// 更新\nboolean success = this.updateById(loanQuoteLead);\n\n// 删除\nboolean success = this.removeById(leadId);\n```\n\n**复杂查询**: 自定义 Mapper 方法\n```java\n// Mapper\nIPage<LoanQuoteLeadDbVO> getLoanQuoteLeadPage(Page<LoanQuoteLeadDbVO> page,\n                                               @Param(\"dto\") LoanQuoteLeadListDBDTO dto);\n\n// Service\nPage<LoanQuoteLeadDbVO> page = new Page<>(req.getCurrent(), req.getSize());\nIPage<LoanQuoteLeadDbVO> result = baseMapper.getLoanQuoteLeadPage(page, dbDto);\n```\n\n### 7.2 枚举规范\n\n**实现 `IEnum<T>` 接口**:\n```java\npublic enum LoanQuoteLeadStatusEnum implements IEnum<Integer> {\n\n    NEW(1, \"New\"),\n    CONTACTED(2, \"Contacted\"),\n    IN_PROGRESS(3, \"In Progress\"),\n    COMPLETED(4, \"Completed\"),\n    LOST(5, \"Lost\");\n\n    private final Integer id;\n    private final String name;\n\n    LoanQuoteLeadStatusEnum(Integer id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    @Override\n    public Integer getId() {\n        return this.id;\n    }\n\n    @Override\n    public String getName() {\n        return this.name;\n    }\n\n    public static LoanQuoteLeadStatusEnum toEnum(int id) {\n        return Arrays.stream(values())\n                .filter(e -> e.getId().equals(id))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public static String getNameById(Integer id) {\n        if (id == null) {\n            return null;\n        }\n        LoanQuoteLeadStatusEnum statusEnum = toEnum(id);\n        return statusEnum != null ? statusEnum.getName() : null;\n    }\n}\n```\n\n### 7.3 数据权限\n\n**使用 `@EnableDataPermission` 注解启用数据权限**:\n```java\n@EnableDataPermission\nIPage<LoanQuoteLeadDbVO> getLoanQuoteLeadPage(Page<LoanQuoteLeadDbVO> page,\n                                               @Param(\"dto\") LoanQuoteLeadListDBDTO dto);\n```\n\n**组织权限隔离**: 在查询 DTO 中设置 `organizationCode`\n```java\ndbDto.setOrganizationCode(RequestContext.getCurrentUserOrgCode());\n```\n\n## 8. Exception Handling & Response Format\n\n### 8.1 异常码体系\n\n**位置**: `com.fintorq.common.core.enums.ExceptionCodeEnum`\n\n**分类**:\n- **2xx**: 成功状态码\n- **3xx**: 重定向状态码\n- **4xx**: 客户端错误状态码\n- **5xx**: 服务器错误状态码\n  - `5001xx`: 通用请求参数、业务数据异常\n  - `5003xx`: common service error\n  - `5005xx`: loan service error\n\n**常用异常码**:\n```java\nSUCCESS(200, \"OK\")\nPARAM_MISS(500101, \"Request param is missing\")\nPARAM_ERROR(500102, \"Request param error\")\nDATA_NOT_EXIST(500103, \"Data does not exist\")\nDATA_ALREADY_EXISTS(500104, \"Data already exists\")\nSERVER_ERROR(500, \"Internal server error\")\n```\n\n### 8.2 异常抛出\n\n**使用 `BusinessException`**:\n```java\nthrow new BusinessException(ExceptionCodeEnum.PARAM_MISS, \"Organization code cannot be empty!\");\nthrow new BusinessException(ExceptionCodeEnum.DATA_NOT_EXIST,\n        String.format(\"Organization not found for code: %s\", orgCode));\n```\n\n### 8.3 统一响应格式\n\n**成功响应**:\n```java\nreturn Result.success(data);\n```\n\n**分页响应**:\n```java\nCommonPageResp<T> result = CommonPageResp.toCommonPageResp(page);\nreturn Result.success(result);\n```\n\n**无返回值**:\n```java\npublic void exportData(@Valid @RequestBody ExportReq req, HttpServletResponse response) {\n    // 直接写入 response\n}\n```\n\n## 9. Coding Standards\n\n### 9.1 空值处理\n\n**尽量避免返回 `null`**:\n- 对于可能为空的返回值，使用 `Optional<T>` 明确表达（Java 8+）\n- 方法参数若不允许 `null`，使用 `Objects.requireNonNull` 检查\n\n```java\n// ✅ 推荐 - 使用 Optional\npublic Optional<User> findUserById(Long id) {\n    User user = userMapper.selectById(id);\n    return Optional.ofNullable(user);\n}\n\n// ✅ 推荐 - 参数非空检查\npublic void setName(String name) {\n    this.name = Objects.requireNonNull(name, \"name 不能为空\");\n}\n\n// ✅ 推荐 - 集合返回空集合而非 null\npublic List<LoanQuoteLead> getLeadsByStatus(Integer status) {\n    List<LoanQuoteLead> leads = baseMapper.selectList(\n        new QueryWrapper<LoanQuoteLead>().eq(\"status\", status)\n    );\n    return CollUtil.isEmpty(leads) ? Collections.emptyList() : leads;\n}\n\n// ❌ 避免 - 返回 null\npublic List<LoanQuoteLead> getLeadsByStatus(Integer status) {\n    List<LoanQuoteLead> leads = baseMapper.selectList(...);\n    return leads.isEmpty() ? null : leads;  // 不推荐\n}\n```\n\n### 9.2 线程安全\n\n**优先设计无状态或不可变的类**，这样可天然支持并发。\n\n**对于共享可变状态，必须使用合适的并发控制**:\n\n```java\n// ✅ 推荐 - 无状态 Service（天然线程安全）\n@Service\n@RequiredArgsConstructor\npublic class LoanQuoteLeadServiceImpl {\n    // 只有 final 字段，无共享可变状态\n    private final LoanQuoteLeadMapper mapper;\n}\n\n// ✅ 推荐 - 使用线程安全集合\n@Component\npublic class CacheManager {\n    private final ConcurrentHashMap<String, Object> cache = new ConcurrentHashMap<>();\n}\n\n// ✅ 推荐 - 使用原子类\n@Component\npublic class CounterService {\n    private final AtomicLong counter = new AtomicLong(0);\n\n    public long increment() {\n        return counter.incrementAndGet();\n    }\n}\n\n// ✅ 推荐 - 使用 volatile 保证可见性\n@Component\npublic class ConfigHolder {\n    private volatile String configValue;\n\n    public void updateConfig(String value) {\n        this.configValue = value;\n    }\n}\n\n// ⚠️ 谨慎使用 - synchronized 方法\n@Component\npublic class LegacySyncService {\n    private final Object lock = new Object();\n\n    public void criticalSection() {\n        synchronized (lock) {\n            // 临界区代码\n        }\n    }\n}\n```\n\n### 9.3 异常安全与资源管理\n\n**使用 try-with-resources 管理可关闭资源**:\n\n```java\n// ✅ 推荐 - try-with-resources\npublic void processFile(String path) {\n    try (BufferedReader reader = new BufferedReader(new FileReader(path))) {\n        // 处理文件\n    } catch (IOException e) {\n        log.error(\"Failed to process file: {}\", path, e);\n        throw new BusinessException(ExceptionCodeEnum.SERVER_ERROR, \"文件处理失败\");\n    }\n}\n\n// ❌ 避免 - 手动关闭资源\npublic void processFile(String path) {\n    BufferedReader reader = null;\n    try {\n        reader = new BufferedReader(new FileReader(path));\n        // 处理文件\n    } catch (IOException e) {\n        // ...\n    } finally {\n        if (reader != null) {\n            try {\n                reader.close();  // 容易遗漏\n            } catch (IOException e) {\n                // ...\n            }\n        }\n    }\n}\n```\n\n**确保异常时资源不会泄露**:\n\n```java\n// ✅ 正确 - 异常时资源自动释放\n@Transactional(rollbackFor = Exception.class)\npublic void processWithJdbc(DataSource dataSource) {\n    try (Connection conn = dataSource.getConnection();\n         PreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM t_table\")) {\n        // 处理数据库操作\n    } catch (SQLException e) {\n        log.error(\"Database error\", e);\n        throw new BusinessException(ExceptionCodeEnum.SERVER_ERROR, \"数据库操作失败\");\n    }\n}\n```\n\n### 9.4 注释规范\n\n**类级别 Javadoc**:\n```java\n/**\n * 贷款报价线索服务实现类\n *\n * @author ratio\n * @since 2025/11/26\n */\n```\n\n**方法级别 Javadoc**:\n```java\n/**\n * 发送已提交的邮件\n *\n * @param dto 包含贷款报价线索数据的 DTO对象\n */\nprivate void sendSubmittedEmail(SaveOrUpdateLoanQuoteLeadDTO dto, LoanQuoteLead loanQuoteLead) {\n    // 实现\n}\n```\n\n**字段注释**:\n```java\n/**\n * SLA超时时间（小时）\n * 从配置文件读取，支持动态调整\n */\n@Value(\"${sla.default}\")\nprivate int slaHours;\n```\n\n### 9.5 健壮原则\n\n**编写健壮的代码**，对边界值和异常输入要有明确处理逻辑：\n\n```java\n// ✅ 推荐 - 边界值检查\npublic void setPageSize(int pageSize) {\n    if (pageSize < 1 || pageSize > 1000) {\n        throw new IllegalArgumentException(\n            String.format(\"页大小必须在 1-1000 之间，当前值: %d\", pageSize)\n        );\n    }\n    this.pageSize = pageSize;\n}\n\n// ✅ 推荐 - 对外部数据进行验证\npublic void processExternalData(ExternalDataDto dto) {\n    if (dto == null) {\n        throw new BusinessException(ExceptionCodeEnum.PARAM_MISS, \"外部数据不能为空\");\n    }\n\n    // 验证关键字段\n    if (StrUtil.isBlank(dto.getId())) {\n        throw new BusinessException(ExceptionCodeEnum.PARAM_ERROR, \"ID 不能为空\");\n    }\n\n    // 安全处理集合\n    List<String> items = dto.getItems() != null ? dto.getItems() : Collections.emptyList();\n\n    // 继续处理...\n}\n\n// ✅ 推荐 - 使用默认值而非 null\npublic String getConfigValue(String key) {\n    String value = configService.get(key);\n    return StrUtil.blankToDefault(value, \"default\");\n}\n```\n\n### 9.6 注释规范\n\n| 类型 | 是否必须写 Javadoc | 说明 |\n|------|-------------------|------|\n| **IService 接口** | ✅ 必须 | 所有 public 方法必须写 Javadoc |\n| **Mapper 接口** | ✅ 必须 | 所有方法必须写 Javadoc |\n| **ServiceImpl 实现类** | ⚠️ 条件必须 | 见下方详细规则 |\n| **Controller 类** | ✅ 必须 | 所有 public 方法必须写 Javadoc |\n| **私有方法** | ✅ 必须 | 实现类中的私有方法必须写 Javadoc |\n\n**ServiceImpl Javadoc 规则**:\n```java\npublic class LoanQuoteLeadServiceImpl implements ILoanQuoteLeadService {\n\n    // ✅ 不需要写 Javadoc - 接口已有定义\n    @Override\n    public SaveOrUpdateLoanQuoteLeadVO saveOrUpdateLoanQuoteLead(SaveOrUpdateLoanQuoteLeadDTO dto) {\n        // 实现\n    }\n\n    // ✅ 必须写 Javadoc - 这是私有方法，接口中没有定义\n    /**\n     * 发送已提交的邮件\n     *\n     * @param dto 包含贷款报价线索数据的 DTO对象\n     * @param loanQuoteLead 贷款报价线索实体\n     */\n    private void sendSubmittedEmail(SaveOrUpdateLoanQuoteLeadDTO dto, LoanQuoteLead loanQuoteLead) {\n        // 实现\n    }\n\n    // ✅ 必须写 Javadoc - 这是 protected 方法，接口中没有定义\n    /**\n     * 构建经销商邮件模板变量\n     *\n     * @param dto 贷款报价线索 DTO\n     * @param orgFacadeVO 组织信息\n     * @return 模板变量 Map\n     */\n    protected Map<String, String> buildDealerEmailTemplateVariables(\n            SaveOrUpdateLoanQuoteLeadDTO dto, OrgFacadeVO orgFacadeVO) {\n        // 实现\n    }\n}\n```\n\n**IService/Mapper 接口示例**:\n```java\n/**\n * 贷款报价线索服务接口\n *\n * @author ratio\n * @since 2025/11/26\n */\npublic interface ILoanQuoteLeadService extends IService<LoanQuoteLead> {\n\n    /**\n     * 保存或更新贷款报价线索\n     *\n     * @param dto 贷款报价线索数据传输对象\n     * @return 保存或更新后的视图对象\n     */\n    SaveOrUpdateLoanQuoteLeadVO saveOrUpdateLoanQuoteLead(SaveOrUpdateLoanQuoteLeadDTO dto);\n\n    /**\n     * 分页查询贷款报价线索列表\n     *\n     * @param req 查询请求参数\n     * @return 分页结果\n     */\n    IPage<LoanQuoteLeadVO> getLoanQuoteLeadList(LoanQuoteLeadListReq req);\n}\n```\n\n### 9.7 日志规范\n\n**使用 `@Slf4j` 注解**:\n```java\n@Slf4j\npublic class ExampleService {\n    // 使用 log\n}\n```\n\n**日志格式**:\n```java\n// Info 级别 - 记录关键操作\nlog.info(\"查询贷款报价线索列表，操作人：{}，查询条件：{}\",\n        RequestContext.getUserId(), req);\n\nlog.info(\"查询贷款报价线索列表完成，返回{}条记录，当前页：{}，每页大小：{}，总记录数：{}\",\n        result.getList().size(), result.getPageNum(), result.getPageSize(), result.getTotal());\n\n// Warn 级别 - 记录警告\nlog.warn(\"Loan quote lead not found for update: id={}\", dto.getId());\n\n// Error 级别 - 记录错误\nlog.error(\"Failed to save loan quote lead: id={}\", dto.getId());\nlog.error(\"Failed to send dealer notice email for lead id {} and organization {}: {}\",\n        dto.getId(), organizationCode, e.getMessage(), e);\n```\n\n**日志占位符**: 使用 `{}` 而非字符串拼接\n\n### 9.8 工具类使用\n\n**Hutool 工具类**:\n```java\n// 字符串工具\nStrUtil.isEmpty(str)\nStrUtil.isNotBlank(str)\nStrUtil.blankToDefault(str, defaultValue)\n\n// Bean 工具\nBeanUtil.copyProperties(source, target)\n\n// 集合工具\nCollUtil.isNotEmpty(list)\n```\n\n**时间处理**:\n```java\n// 使用 java.time API\nInstant.now()\nLocalDateTime.now()\nDate.from(instant)\n```\n\n## 11. Testing Standards\n\n### 11.1 测试类命名\n\n**命名规范**: `{ClassName}Test`\n\n**示例**:\n```java\nclass QuotationServiceImplSimpleTest {\n    // 测试方法\n}\n```\n\n### 11.2 测试注解\n\n```java\n@ExtendWith(MockitoExtension.class)  // JUnit 5 + Mockito\n@DisplayName(\"测试描述\")\n```\n\n### 11.3 Mock 规范\n\n```java\n@Mock\nprivate QuotationMapper quotationMapper;\n\n@Mock\nprivate IApplicationService applicationService;\n\n@InjectMocks\n@Spy\nprivate QuotationServiceImpl quotationService;\n```\n\n**静态方法 Mock**:\n```java\ntry (MockedStatic<RequestContext> mockedRequestContext = mockStatic(RequestContext.class)) {\n    mockedRequestContext.when(RequestContext::getUserId).thenReturn(1001L);\n    // 测试逻辑\n}\n```\n\n### 11.4 测试方法命名\n\n**推荐格式**: `{methodName}_{scenario}_{expectedResult}`\n\n**示例**:\n```java\n@Test\n@DisplayName(\"批量创建quotation - 基本功能测试\")\nvoid testBatchCreateQuotations_BasicFunctionality() {\n    // Given\n    // When\n    // Then\n}\n\n@Test\n@DisplayName(\"批量创建quotation - 空列表测试\")\nvoid testBatchCreateQuotations_EmptyList() {\n    // 测试\n}\n\n@Test\n@DisplayName(\"批量创建quotation - null列表测试\")\nvoid testBatchCreateQuotations_NullList() {\n    // 测试\n}\n```\n\n### 11.5 断言规范\n\n```java\n// 使用 JUnit 5 Assertions\nassertNotNull(result);\nassertEquals(1, result.size());\nassertTrue(result.containsKey(\"PEPPER\"));\n\n// 异常断言\nBusinessException exception = assertThrows(BusinessException.class, () -> {\n    quotationService.selectQuotation(applicationId, quotationId);\n});\nassertEquals(\"Application does not exist or has been deleted\", exception.getMessage());\n```\n\n## 12. Common Patterns\n\n### 12.1 分页查询模式\n\n```java\n@Override\npublic IPage<LoanQuoteLeadVO> getLoanQuoteLeadList(LoanQuoteLeadListReq req) {\n    // 1. 转换查询条件\n    LoanQuoteLeadListDBDTO dbDto = convertToDBDTO(req);\n\n    // 2. 创建分页对象\n    Page<LoanQuoteLeadDbVO> page = new Page<>(req.getCurrent(), req.getSize());\n\n    // 3. 执行查询\n    IPage<LoanQuoteLeadDbVO> dbResult = baseMapper.getLoanQuoteLeadPage(page, dbDto);\n\n    // 4. 转换为 VO\n    return new Page<>(req.getCurrent(), req.getSize(), dbResult.getTotal()) {\n        {\n            setRecords(dbResult.getRecords().stream()\n                    .map(this::convertToVO)\n                    .collect(Collectors.toList()));\n        }\n    };\n}\n```\n\n### 12.2 保存/更新模式\n\n```java\n@Override\npublic SaveOrUpdateLoanQuoteLeadVO saveOrUpdateLoanQuoteLead(SaveOrUpdateLoanQuoteLeadDTO dto) {\n    if (dto.getId() != null) {\n        // 更新现有记录\n        LoanQuoteLead entity = this.getById(dto.getId());\n        if (entity == null) {\n            throw new BusinessException(ExceptionCodeEnum.DATA_NOT_EXIST);\n        }\n        BeanUtil.copyProperties(dto, entity);\n        this.updateById(entity);\n        return new SaveOrUpdateLoanQuoteLeadVO(entity);\n    } else {\n        // 创建新记录\n        LoanQuoteLead entity = new LoanQuoteLead();\n        BeanUtil.copyProperties(dto, entity);\n        entity.setCreateTime(new Date());\n        this.save(entity);\n        return new SaveOrUpdateLoanQuoteLeadVO(entity);\n    }\n}\n```\n\n### 12.3 异步操作模式\n\n```java\n// 异步发送邮件\nCompletableFuture.runAsync(() -> sendThankNoticeEmailToCUser(dto),\n        threadPoolManager.getEmailSendThreadPoolExecutor()\n).exceptionally(throwable -> {\n    log.error(\"Failed to send email for mobile: {}\", dto.getMobile(), throwable);\n    return null;\n});\n```\n\n## 13. Important Notes\n\n### 13.1 禁止事项\n\n- **NO JPA Annotations**: 不使用 `javax.persistence` 或 `jakarta.persistence` 注解\n- **NO `@Autowired` on fields**: 不使用字段注入\n- **NO `System.out/err`**: 使用日志框架\n- **NO raw types**: 使用泛型\n- **NO deprecated Date**: 使用 `java.time` API\n\n### 13.2 时区处理\n\n- 数据库时间存储: UTC\n- 客户端时区: 通过 `RequestContext.getTimeZone()` 获取\n- 时间转换: 使用 `ZoneOffset.UTC`\n\n### 13.3 敏感数据过滤\n\n根据用户权限和数据状态动态过滤敏感字段（如 overdue 订单的姓名、邮箱、电话）。\n\n```java\nprivate boolean hasViewOverdueSensitiveDataPermission() {\n    return RequestContext.hasAuthority(PermissionCodeEnum.VIEW_OVERDUE_LEAD.getName());\n}\n```\n\n## 14. AI 代码生成指引\n\n本章节为 AI 代码生成提供指导原则，确保生成的代码具有高质量、可维护性和可扩展性。\n\n### 14.1 可读性与清晰性\n\n**优先考虑代码的清晰和可读性**：\n\n```java\n// ✅ 推荐 - 清晰直观\npublic List<LoanQuoteLead> getActiveLeads() {\n    return baseMapper.selectList(\n        new QueryWrapper<LoanQuoteLead>().eq(\"status\", Status.ACTIVE)\n    );\n}\n\n// ❌ 避免 - 过度\"巧妙\"但晦涩\npublic List<LoanQuoteLead> getActiveLeads() {\n    return Stream.of(baseMapper.selectList(null))\n        .filter(l -> Status.ACTIVE.equals(l.getStatus()))\n        .collect(Collectors.toList());\n}\n```\n\n**生成的代码要自解释**：\n- 使用有意义的变量名和方法名\n- 避免单字母变量名（除循环变量 i、j 等）\n- 命名要准确反映其用途\n\n### 14.2 单一职责原则\n\n**函数、方法和类应尽量职责单一，功能内聚**：\n\n```java\n// ✅ 推荐 - 单一职责\n@Service\n@RequiredArgsConstructor\npublic class LoanQuoteLeadServiceImpl {\n\n    public SaveOrUpdateLoanQuoteLeadVO saveOrUpdate(SaveOrUpdateLoanQuoteLeadDTO dto) {\n        validateDto(dto);           // 验证\n        LoanQuoteLead entity = convertToEntity(dto);  // 转换\n        saveEntity(entity);          // 保存\n        sendNotification(entity);    // 通知\n        return convertToVO(entity);\n    }\n\n    private void validateDto(SaveOrUpdateLoanQuoteLeadDTO dto) {\n        // 验证逻辑\n    }\n\n    private LoanQuoteLead convertToEntity(SaveOrUpdateLoanQuoteLeadDTO dto) {\n        // 转换逻辑\n    }\n\n    private void sendNotification(LoanQuoteLead entity) {\n        // 通知逻辑\n    }\n}\n\n// ❌ 避免 - 一个方法做太多事情\npublic SaveOrUpdateLoanQuoteLeadVO saveOrUpdate(SaveOrUpdateLoanQuoteLeadDTO dto) {\n    // 100+ 行代码，包含验证、转换、保存、通知等多种职责\n}\n```\n\n### 14.3 避免重复与简单优先\n\n**遵循 DRY（Don't Repeat Yourself）原则**：\n\n```java\n// ✅ 推荐 - 提取公共方法\nprivate void applyCommonFilters(QueryWrapper<LoanQuoteLead> wrapper, SearchReq req) {\n    if (StrUtil.isNotBlank(req.getMobile())) {\n        wrapper.like(\"mobile\", req.getMobile());\n    }\n    if (StrUtil.isNotBlank(req.getOrganizationCode())) {\n        wrapper.eq(\"organization_code\", req.getOrganizationCode());\n    }\n}\n\n// ❌ 避免 - 重复代码\npublic List<LoanQuoteLead> search1(SearchReq req) {\n    QueryWrapper<LoanQuoteLead> wrapper = new QueryWrapper<>();\n    if (StrUtil.isNotBlank(req.getMobile())) {\n        wrapper.like(\"mobile\", req.getMobile());\n    }\n    // ...\n}\n\npublic List<LoanQuoteLead> search2(SearchReq req) {\n    QueryWrapper<LoanQuoteLead> wrapper = new QueryWrapper<>();\n    if (StrUtil.isNotBlank(req.getMobile())) {\n        wrapper.like(\"mobile\", req.getMobile());\n    }\n    // ...\n}\n```\n\n**保持代码简单直接（KISS 原则）**：\n- 满足需求的前提下选用简单可维护的方案\n- 不必追求过度抽象或极致优化，除非明确必要\n\n### 14.4 可维护性和扩展性\n\n**鼓励使用接口和抽象来解耦模块**：\n\n```java\n// ✅ 推荐 - 面向接口编程\n@Service\n@RequiredArgsConstructor\npublic class LoanQuoteLeadServiceImpl implements ILoanQuoteLeadService {\n\n    private final LoanQuoteLeadMapper mapper;          // 接口注入\n    private final INotificationService notificationService;  // 接口注入\n}\n\n// ❌ 避免 - 紧耦合设计\n@Service\npublic class LoanQuoteLeadServiceImpl {\n\n    private LoanQuoteLeadMapper mapper = new LoanQuoteLeadMapper();  // 硬编码创建\n}\n```\n\n**遵循 SOLID 等设计原则**：\n- **S**ingle Responsibility：单一职责\n- **O**pen/Closed：对扩展开放，对修改封闭\n- **L**iskov Substitution：里氏替换\n- **I**nterface Segregation：接口隔离\n- **D**ependency Inversion：依赖倒置\n\n### 14.5 错误处理与日志\n\n**生成具有意义的错误信息**：\n\n```java\n// ✅ 推荐 - 具体的错误信息\nif (StrUtil.isBlank(dto.getMobile())) {\n    throw new BusinessException(\n        ExceptionCodeEnum.PARAM_ERROR,\n        \"手机号不能为空\"\n    );\n}\n\nif (!isValidMobile(dto.getMobile())) {\n    throw new BusinessException(\n        ExceptionCodeEnum.PARAM_ERROR,\n        String.format(\"手机号格式不正确: %s\", dto.getMobile())\n    );\n}\n\n// ❌ 避免 - 模糊的错误信息\nif (StrUtil.isBlank(dto.getMobile())) {\n    throw new BusinessException(ExceptionCodeEnum.PARAM_ERROR, \"参数错误\");\n}\n```\n\n**避免吞掉异常**：\n\n```java\n// ✅ 推荐 - 记录并重新抛出\ntry {\n    sendEmail(dto);\n} catch (EmailException e) {\n    log.error(\"Failed to send email for mobile: {}\", dto.getMobile(), e);\n    throw new BusinessException(ExceptionCodeEnum.SERVER_ERROR, \"邮件发送失败\", e);\n}\n\n// ❌ 避免 - 吞掉异常\ntry {\n    sendEmail(dto);\n} catch (Exception e) {\n    // 静默忽略\n}\n```\n\n### 14.6 注释与文档\n\n**为生成的代码添加适当注释**：\n\n```java\n/**\n * 分页查询贷款报价线索列表\n *\n * <p>支持按手机号、状态、时间范围等条件过滤</p>\n *\n * @param req 查询请求参数，包含分页信息和过滤条件\n * @return 分页结果，包含符合条件的线索列表\n * @throws BusinessException 当查询参数无效时抛出\n */\n@Override\npublic IPage<LoanQuoteLeadVO> getLoanQuoteLeadList(LoanQuoteLeadListReq req) {\n    // 实现逻辑\n}\n```\n\n**TODO 注释使用**：\n- 标记需要后续检查或优化的代码\n- 说明 TODO 的具体原因和期望的改进方向\n\n```java\n// TODO: 考虑使用缓存优化频繁查询的性能\n// TODO: 当前的同步邮件发送可能影响响应时间，后续改为异步\npublic SaveOrUpdateLoanQuoteLeadVO saveOrUpdate(SaveOrUpdateLoanQuoteLeadDTO dto) {\n    // 实现\n}\n```\n\n**注释应解释\"为什么\"而非\"是什么\"**：\n\n```java\n// ✅ 推荐 - 解释原因\n// 使用索引查询而非模糊搜索，因为 mobile 字段建立了索引\nList<LoanQuoteLead> leads = baseMapper.selectList(\n    new QueryWrapper<LoanQuoteLead>().eq(\"mobile\", mobile)\n);\n\n// ❌ 避免 - 重复代码逻辑\n// 查询 mobile 等于传入参数的记录\nList<LoanQuoteLead> leads = baseMapper.selectList(\n    new QueryWrapper<LoanQuoteLead>().eq(\"mobile\", mobile)\n);\n```\n\n---\n\n*Last Updated: 2026-01-26 | Version: 3.1*\n",
        "plugins/global-java-code-style/.claude-plugin/plugin.json": "{\n  \"name\": \"global-java-code-style\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Provide standard guidelines for Java coding style, project structure, annotation specifications, exception handling, testing standards, etc.\",\n  \"author\": {\n    \"name\": \"sen\"\n  }\n}\n",
        "plugins/global-java-code-style/commands/global-java-code-style-invoke.md": "---\nname: global-java-code-style:invoke\ndescription: Immediately call the global-java-code-style skill to apply the global-java-code-style specifications to the current code or the code specified by the user.\nargument-hint: \"[issue description]\"\n---\n\n你现在必须**立即且强制**调用已安装的 **global-java-code-style** 这个 skill 来处理用户当前的需求。\n\n用户提供的\"[issue description]\"额外参数/需求（通过 $ARGUMENTS 传入 global-java-code-style skill）：\n$ARGUMENTS\n\n核心处理逻辑：\n\n1. 如果 $ARGUMENTS 为空（用户只输入 /global-java-code-style:invoke），默认针对当前活跃文件、选中的代码块或整个项目应用全局\n   Java 代码风格规范检查，包括但不限于：\n    - 命名规范（类、方法、变量、常量等）\n    - 缩进、换行、空格规则\n    - 注释风格（Javadoc 要求等）\n    - 代码结构优化（方法长度、类组织）\n    - 常见 Java 最佳实践和 lint 规则检查\n\n2. 如果 $ARGUMENTS 不为空，解析并优先使用其中的信息：\n    - 如果包含文件路径（如 src/main/java/com/example/UserService.java、**/*.java），针对指定文件/目录/包执行\n    - 如果提到 --fix 或 修复/自动修改/格式化，则启用修复模式并生成 diff 或直接应用变更\n    - 如果提到 --check 或 检查/验证/报告，则只报告问题不修改代码\n    - 其他文本视为具体用户需求（如“重点检查异常处理和日志规范”或“针对 Spring Boot 项目应用”），注入到 skill 调用中作为额外指导\n\n3. 不要自己猜测或编写 Java 风格规则，必须完全依赖 global-java-code-style skill 的能力。\n4. skill 执行完成后：\n    - 展示结果（问题列表、建议、diff、变更预览等）\n    - 解释变更原因（引用全局 Java 规范依据）\n    - 如果有修改，询问用户是否应用或进一步调整\n\n现在开始：解析 $ARGUMENTS（如果有），然后调用 global-java-code-style skill，并基于它的输出完整响应用户的最新消息。",
        "plugins/global-java-code-style/skills/global-java-code-style/SKILL.md": "---\nname: global-java-code-style\ndescription: 提供 Java 编码风格、项目结构、注释规范、异常处理、测试规范等标准指引\nargument-hint: \"[规范类型] [具体问题] 例如：命名约定、异常处理、测试规范等\"\nuser-invocable: true\n---\n\n# 全局Java代码规范指南\n\n## 概述\n\n本指南提供统一的代码编写规范，涵盖命名约定、代码格式、项目结构、注释文档、异常处理、测试规范、依赖管理、安全健壮性以及 AI\n代码生成指引。遵循这些规范有助于提升代码质量、可读性和可维护性。\n\n---\n\n## 命名约定\n\n### 类和接口\n\n- 【强制】使用**大驼峰命名法**（`UpperCamelCase`）\n- 【强制】类名应为名词，接口名可为名词或形容词\n- 【强制】抽象类使用 `Abstract` 或 `Base` 开头\n- 【强制】异常类使用 `Exception` 结尾\n- 【强制】测试类以它要测试的类名开始加 `Test` 结尾\n- 【强制】禁止以下划线或美元符号开始/结束命名\n\n**示例：**\n\n```java\n// 正例\npublic class UserService {\n}\n\npublic interface Serializable {\n}\n\npublic abstract class AbstractUserService {\n}\n\npublic class CustomException extends Exception {\n}\n\npublic class UserServiceTest {\n}\n\n// 反例\npublic class _UserService {\n}\n\npublic class UserService$ {\n}\n\npublic class userService {\n}\n```\n\n### 方法和变量\n\n- 【强制】使用**小驼峰命名法**（`lowerCamelCase`）\n- 【强制】方法名应为动词短语\n- 【强制】禁止以下划线或美元符号开始/结束\n- 【强制】POJO 中布尔变量不加 `is` 前缀（否则部分框架解析会出错）\n\n**示例：**\n\n```java\n// 正例\npublic void calculateTotal() {\n}\n\nprivate String userName;\nprivate boolean success; // 不使用 isSuccess\n\n// 反例\npublic void Calculate_Total() {\n}\n\nprivate String _userName;\nprivate boolean isSuccess; // POJO 中禁止\n```\n\n### 数组定义\n\n- 【强制】数组定义：`String[] args` 而非 `String args[]`\n\n**示例：**\n\n```java\n// 正例\nString[] args;\nint[] numbers;\n\n// 反例\nString args[];\nint numbers[];\n```\n\n### 常量\n\n- 【强制】使用**全大写加下划线**（`UPPER_SNAKE_CASE`）\n- 【强制】long 赋值使用大写 `L`（非小写 `l`）\n- 【强制】浮点数后缀统一大写 `D` 或 `F`\n\n**示例：**\n\n```java\n// 正例\npublic static final long MAX_RETRY_COUNT = 100L;\npublic static final double DEFAULT_RATE = 3.14D;\npublic static final float PI = 3.14F;\n\n// 反例\npublic static final long MAX_RETRY_COUNT = 100l; // 小写 l 容易与 1 混淆\npublic static final float PI = 3.14f; // 应使用大写 F\n```\n\n### 包名\n\n- 【强制】包名使用小写，单数形式\n- 【强制】点分隔符间只有一个自然语义单词\n- 【强制】禁止下划线、美元符号等特殊字符\n- 【强制】杜绝不规范的缩写\n\n**示例：**\n\n```java\n// 正例\ncom.example.project.service\ncom.alibaba.cloud.nacos\n\n// 反例\ncom.example.project.serviceImpl  // Impl 应为独立单词\ncom.example.project.user_service // 禁止下划线\ncom.example.project.userService  // service 应为小写\n```\n\n### 命名通用规范\n\n- 【强制】禁止拼音与英文混合\n- 【强制】禁止中文命名\n- 【强制】杜绝不规范的英文缩写\n- 【推荐】使用完整单词，保持清晰易懂\n\n---\n\n## 常量定义规范\n\n### 魔法值\n\n- 【强制】不允许魔法值（即未经定义的常量）直接出现在代码中\n\n**示例：**\n\n```java\n// 反例\nif(status ==1){\n        // ...\n        }\n\n// 正例\npublic static final int STATUS_ACTIVE = 1;\nif(status ==STATUS_ACTIVE){\n        // ...\n        }\n```\n\n### 常量组织\n\n- 【推荐】按功能归类维护常量，而非一个庞大的常量类\n- 【推荐】五层复用层次：\n    1. 跨应用共享常量：放置在二方库中（如 `commons-module`）\n    2. 应用内共享常量：放置在内部模块（如 `core-module`）\n    3. 子工程内共享：放置在 `constants` 包\n    4. 包内共享：放在当前包的 `constants` 子包\n    5. 类内共享：放在类的 `private static final`\n\n**示例：**\n\n```java\n// 跨应用共享（二方库）\n// commons-module/src/main/java/com/example/commons/constants/SystemConstants.java\npublic static final String DEFAULT_CHARSET = \"UTF-8\";\n\n// 应用内共享\n// core-module/src/main/java/com/example/core/constants/BusinessConstants.java\npublic static final int ORDER_STATUS_PENDING = 0;\n\n// 类内使用\nprivate static final int MAX_RETRY_TIMES = 3;\n```\n\n### 枚举使用\n\n- 【推荐】固定范围变化用 `enum`，不要用常量\n\n**示例：**\n\n```java\n// 正例 - 使用枚举\npublic enum OrderStatus {\n    PENDING(0, \"待支付\"),\n    PAID(1, \"已支付\"),\n    SHIPPED(2, \"已发货\"),\n    COMPLETED(3, \"已完成\");\n\n    private final int code;\n    private final String desc;\n\n    OrderStatus(int code, String desc) {\n        this.code = code;\n        this.desc = desc;\n    }\n}\n\n// 反例 - 使用常量\npublic static final int ORDER_STATUS_PENDING = 0;\npublic static final int ORDER_STATUS_PAID = 1;\n```\n\n### 变量与常量\n\n- 【强制】只读变量（`final` 修饰）命名全部大写\n- 【强制】非只读变量使用小驼峰\n\n---\n\n## 代码格式\n\n### 缩进\n\n- 【强制】采用 **4 个空格**缩进，禁用 Tab\n- 【强制】IDE 编码设置为 UTF-8，换行符设置为 Unix 格式（LF）\n\n### 大括号（K&R 风格）\n\n- 【强制】左大括号前加空格\n- 【强制】空大括号写成 `{}`，无需换行空格\n- 【强制】非空大括号：左括号不换行，右括号换行\n\n**示例：**\n\n```java\n// 正例\nif(condition){\n        // 语句\n        }else{\n        // 语句\n        }\n\npublic void method() {\n}\n\n// 反例\nif(condition)\n        {\n        // 语句\n        }\n```\n\n### 空格规则\n\n- 【强制】左小括号右边无空格，右小括号左边无空格\n- 【强制】`if`/`for`/`while` 等保留字与括号间加空格\n- 【强制】所有二目、三目运算符左右加空格\n- 【强制】方法参数逗号后加空格\n- 【强制】注释双斜线与内容间仅一个空格\n- 【强制】类型强制转换：右括号与值间无空格\n\n**示例：**\n\n```java\n// 正例\nif(a ==b){}\nint sum = a + b;\nString result = (condition) ? \"yes\" : \"no\";\n\nmethod(a, b, c);\n\n// 注释内容\nint value = (int) (amount * 100);\n\n// 反例\nif(a ==b){}                  // if 后缺少空格\nint sum = a + b;                   // 运算符缺少空格\n\nmethod(a, b, c);                 // 逗号后缺少空格\n\n//  注释内容                   // 双斜线后多个空格\nint value = (int) (amount * 100);  // 括号多余空格\n```\n\n### 行长度与换行\n\n- 【强制】单行字符不超过 **120 个**\n- 【推荐】单个方法不超过 **80 行**\n- 【推荐】不同逻辑、语义、业务间插入空行分隔\n\n### 组织结构\n\n- 【强制】成员之间用空行分隔\n- 【强制】相关成员可额外加空格分组\n- 【强制】重载方法放在一起\n\n---\n\n## OOP 规约\n\n### 方法调用\n\n- 【强制】避免通过对象访问静态变量或方法\n- 【强制】覆写方法必须加 `@Override` 注解\n- 【强制】外部调用的接口不允许修改方法签名\n- 【强制】不能使用过时的类或方法（`@Deprecated`）\n\n**示例：**\n\n```java\n// 反例 - 通过对象访问静态方法\nUser user = new User();\nuser.\n\nstaticMethod();\n\n// 正例\nUser.\n\nstaticMethod();\n\n// 正例 - 覆写方法加注解\n@Override\npublic String toString() {\n    return \"User{name=\" + name + \"}\";\n}\n```\n\n### 可变参数\n\n- 【强制】相同参数类型和业务含义才能使用可变参数\n- 【强制】可变参数必须放在参数列表最后\n\n**示例：**\n\n```java\n// 正例\npublic void method(String... args) {\n}\n\n// 反例 - 可变参数不在最后\npublic void method(String... args, int count) {\n}\n```\n\n### equals 与 hashCode\n\n- 【强制】`equals` 方法用常量或确定有值的对象调用\n- 【强制】整型包装类比较使用 `equals`，而非 `==`\n- 【强制】只要覆写 `equals`，就必须覆写 `hashCode`\n- 【强制】POJO 类必须写 `toString` 方法\n\n**示例：**\n\n```java\n// 反例 - equals 可能抛出 NPE\nif(user.equals(currentUser)){}\n\n// 正例\n        if(currentUser.\n\nequals(user)){}\n// 或\n        if(Objects.\n\nequals(user, currentUser)){}\n\n// 反例 - 整型包装类用 == 比较\nInteger a = 100;\nInteger b = 100;\nif(a ==b){}  // -128~127 之间才相等\n\n// 正例\n        if(a.\n\nequals(b)){}\n\n// 正例 - 同时覆写 hashCode\n@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    User user = (User) o;\n    return Objects.equals(id, user.id);\n}\n\n@Override\npublic int hashCode() {\n    return Objects.hash(id);\n}\n```\n\n### 数值计算\n\n- 【强制】货币金额使用最小货币单位整型存储\n- 【强制】浮点数等值判断使用 `BigDecimal`\n- 【强制】`BigDecimal` 等值比较用 `compareTo()` 而非 `equals()`\n\n**示例：**\n\n```java\n// 正例 - 金额用最小单位（分）存储\nprivate Long amount;  // 单位：分\n\n// 反例 - 浮点数直接比较\nif(0.1+0.2==0.3){}  // false\n\n// 正例\nBigDecimal a = new BigDecimal(\"0.1\");\nBigDecimal b = new BigDecimal(\"0.2\");\nBigDecimal sum = a.add(b);\nif(sum.\n\ncompareTo(new BigDecimal(\"0.3\"))==0){}\n\n// 反例 - BigDecimal equals 比较（会考虑精度）\n        if(new\n\nBigDecimal(\"0.1\").\n\nequals(new BigDecimal(\"0.10\"))){}  // false\n\n// 正例\n        if(new\n\nBigDecimal(\"0.1\").\n\ncompareTo(new BigDecimal(\"0.10\"))==0){}  // true\n```\n\n---\n\n## 日期时间处理规范\n\n### 年份格式化\n\n- 【强制】年份格式化使用 `yyyy` 表示当天所在的年，**禁止使用 `YYYY`**\n- 【强制】`YYYY` 表示\"week in which year\"，可能导致跨年错误\n\n**示例：**\n\n```java\n// 反例 - YYYY 表示\"week in which year\"，可能导致跨年错误\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"YYYY-MM-dd\");\n// 2024年12月31日（周二）可能会被格式化为 2025-12-31\n\n// 正例 - yyyy 表示当天所在的年\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n```\n\n### 日期计算\n\n- 【强制】禁止写死一年为365天，应使用 `plusYears(1)`\n- 【推荐】使用 Java 8+ 日期 API（`LocalDateTime`、`ZonedDateTime`）\n- 【强制】避免使用 `Date`、`SimpleDateFormat`（线程不安全）\n\n**示例：**\n\n```java\n// 反例 - 写死365天，未考虑闰年\nint days = 365;\nLocalDate nextYear = today.plusDays(days);\n\n// 正例 - 使用 plusYears 自动处理闰年\nLocalDate nextYear = today.plusYears(1);\n\n// 反例 - SimpleDateFormat 线程不安全\nprivate static final SimpleDateFormat FORMAT = new SimpleDateFormat(\"yyyy-MM-dd\");\n\n// 正例 - DateTimeFormatter 线程安全\nprivate static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n```\n\n### 时区处理\n\n- 【推荐】明确指定时区，避免使用系统默认时区\n- 【推荐】统一时区：UTC 或 GMT+8\n\n**示例：**\n\n```java\n// 正例 - 明确指定时区\nZonedDateTime utcTime = ZonedDateTime.now(ZoneId.of(\"UTC\"));\nZonedDateTime beijingTime = ZonedDateTime.now(ZoneId.of(\"Asia/Shanghai\"));\n\n// 反例 - 使用系统默认时区，可能在不同环境表现不一致\nLocalDateTime.\n\nnow();\n```\n\n### 前后端时间格式统一\n\n- 【推荐】统一格式：`yyyy-MM-dd HH:mm:ss`\n- 【推荐】不推荐使用时间戳（可读性差）\n- 【推荐】前端传入时间需包含时区信息\n\n**示例：**\n\n```java\n// 正例 - 统一的时间格式\npublic class OrderDTO {\n    @JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\", timezone = \"GMT+8\")\n    private LocalDateTime createTime;\n}\n\n// 反例 - 使用时间戳，可读性差\npublic class OrderDTO {\n    private Long createTime;  // 毫秒时间戳\n}\n```\n\n---\n\n## 集合处理规范\n\n### 集合判空\n\n- 【强制】判断集合是否为空使用 `isEmpty()` 而非 `size() == 0`\n- 【强制】判断集合是否非空时，先判断是否为 `null`\n\n**示例：**\n\n```java\n// 正例\nif(CollectionUtils.isEmpty(list)){}\n        if(list !=null&&!list.\n\nisEmpty()){}\n\n// 反例\n        if(list.\n\nsize() ==0){}  // 若 list 为 null 会抛出 NPE\n```\n\n### 类型转换\n\n- 【强制】`ArrayList` 的 `subList` 结果不可强转成 `ArrayList`\n- 【强制】`subList` 是原集合的视图，对原集合增删会导致 `ConcurrentModificationException`\n- 【强制】`Collections.sort` 返回泛型 `List` 不可转成 `ArrayList`\n\n**示例：**\n\n```java\n// 反例\nList<String> list = new ArrayList<>();\nList<String> subList = list.subList(0, 5);\nArrayList<String> arrayList = (ArrayList<String>) subList;  // ClassCastException\n\n// 正例 - 创建新集合\nList<String> subList = list.subList(0, 5);\nList<String> newList = new ArrayList<>(subList);\n\n// 反例 - subList 后修改原集合\nList<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\nList<String> subList = list.subList(0, 2);\nlist.\n\nadd(\"d\");  // 修改原集合\nsubList.\n\nget(0); // ConcurrentModificationException\n```\n\n### foreach 循环操作\n\n- 【强制】禁止在 `foreach` 循环中对集合进行 `add`/`remove` 操作\n- 【强制】使用 `Iterator` 的 `remove()` 方法或 Java 8+ 的 `removeIf()`\n\n**示例：**\n\n```java\n// 反例 - foreach 中 remove 会抛出 ConcurrentModificationException\nList<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\nfor(\nString item :list){\n        if(\"a\".\n\nequals(item)){\n        list.\n\nremove(item);  // ConcurrentModificationException\n    }\n            }\n\n// 正例 - 使用 Iterator\nIterator<String> iterator = list.iterator();\nwhile(iterator.\n\nhasNext()){\nString item = iterator.next();\n    if(\"a\".\n\nequals(item)){\n        iterator.\n\nremove();\n    }\n            }\n\n// 正例 - 使用 removeIf（Java 8+）\n            list.\n\nremoveIf(\"a\"::equals);\n```\n\n### Arrays.asList 限制\n\n- 【强制】`Arrays.asList()` 返回的是固定大小的列表，不支持 `add`/`remove`\n- 【强制】对基本类型数组使用 `Arrays.asList()` 时注意返回值\n\n**示例：**\n\n```java\n// 反例 - Arrays.asList 返回的列表不可增删\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");\nlist.\n\nadd(\"d\");  // UnsupportedOperationException\n\n// 正例 - 包装成可变列表\nList<String> list = new ArrayList<>(Arrays.asList(\"a\", \"b\", \"c\"));\nlist.\n\nadd(\"d\");\n\n// 反例 - 基本类型数组\nint[] arr = {1, 2, 3};\nList<int[]> list = Arrays.asList(arr);  // 只有一个元素，类型是 int[]\n\n// 正例 - 使用包装类型数组\nInteger[] arr = {1, 2, 3};\nList<Integer> list = Arrays.asList(arr);  // 三个元素\n```\n\n### Map 遍历\n\n- 【强制】使用 `entrySet` 遍历 `Map` 类而不是 `keySet`\n- 【推荐】JDK 8+ 使用 `forEach` 方法遍历\n\n**示例：**\n\n```java\n// 反例 - 使用 keySet 需要两次查找\nfor(String key :map.\n\nkeySet()){\nString value = map.get(key);  // 额外的 get 操作\n}\n\n// 正例 - 使用 entrySet 只需一次遍历\n        for(\nMap.Entry<String, String> entry :map.\n\nentrySet()){\nString key = entry.getKey();\nString value = entry.getValue();\n}\n\n// 正例 - JDK 8+ forEach\n        map.\n\nforEach((key, value) ->{\n        // 处理逻辑\n        });\n```\n\n### 集合初始化\n\n- 【强制】集合初始化时指定容量，避免扩容开销\n- 【推荐】HashMap 初始容量计算：`expectedSize / 0.75 + 1`\n\n**示例：**\n\n```java\n// 正例 - 预估容量\nint expectedSize = 100;\nMap<String, String> map = new HashMap<>((int) (expectedSize / 0.75 + 1));\nList<String> list = new ArrayList<>(expectedSize);\n\n// 反例\nList<String> list = new ArrayList<>();  // 默认容量 10，可能多次扩容\nMap<String, String> map = new HashMap<>();  // 默认容量 16\n```\n\n### 泛型通配符\n\n- 【推荐】`<? extends T>` 用于消费集合元素（只读），`<? super T>` 用于生产集合元素（只写）\n- 【推荐】遵循 PECS 原则：Producer Extends, Consumer Super\n\n**示例：**\n\n```java\n// 正例 - 只读取，使用 extends\npublic void printAll(List<? extends Number> list) {\n    for (Number n : list) {\n        System.out.println(n);\n    }\n}\n\n// 正例 - 只写入，使用 super\npublic void addNumbers(List<? super Integer> list) {\n    list.add(1);\n    list.add(2);\n}\n\n// 正例 - 复制方法\npublic static <T> void copy(List<? super T> dest, List<? extends T> src) {\n    for (T item : src) {\n        dest.add(item);\n    }\n}\n```\n\n### 集合转数组\n\n- 【强制】使用 `toArray(T[] array)` 方法，传入类型完全一致、长度为 0 的空数组\n\n**示例：**\n\n```java\n// 正例\nList<String> list = new ArrayList<>();\nString[] array = list.toArray(new String[0]);\n\n// 反例 - 无参 toArray 返回 Object[]\nObject[] array = list.toArray();  // 类型不安全\n```\n\n---\n\n## 并发处理规范\n\n### 单例模式\n\n- 【强制】获取单例需保证线程安全\n\n**示例：**\n\n```java\n// 正例 - 双重检查锁\npublic class Singleton {\n    private static volatile Singleton instance;\n\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n// 正例 - 静态内部类（推荐）\npublic class Singleton {\n    private Singleton() {\n    }\n\n    public static Singleton getInstance() {\n        return Holder.INSTANCE;\n    }\n\n    private static class Holder {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n}\n\n// 正例 - 枚举单例（最佳实践）\npublic enum Singleton {\n    INSTANCE;\n\n    public void doSomething() {\n        // 业务逻辑\n    }\n}\n```\n\n### 线程池创建\n\n- 【强制】线程池不允许使用 `Executors` 创建\n- 【强制】使用 `ThreadPoolExecutor` 自定义创建\n- 【强制】自定义线程工厂，设置有意义的线程名\n\n**示例：**\n\n```java\n// 反例 - 允许请求队列长度为 Integer.MAX_VALUE，可能导致 OOM\nExecutorService executor = Executors.newFixedThreadPool(10);\nExecutorService executor = Executors.newCachedThreadPool();  // 最大线程数为 Integer.MAX_VALUE\n\n// 正例 - 自定义线程池\nThreadPoolExecutor executor = new ThreadPoolExecutor(\n        5,                          // 核心线程数\n        10,                         // 最大线程数\n        60L,                        // 空闲存活时间\n        TimeUnit.SECONDS,\n        new LinkedBlockingQueue<>(1000),  // 有界队列\n        new ThreadFactoryBuilder()\n                .setNameFormat(\"order-pool-%d\")  // 有意义的线程名\n                .setUncaughtExceptionHandler((t, e) ->\n                        logger.error(\"Thread {} error\", t.getName(), e))\n                .build(),\n        new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略\n);\n```\n\n### ThreadLocal 使用\n\n- 【强制】使用 `ThreadLocal` 后必须手动 `remove()`，防止内存泄漏\n- 【强制】在线程池场景下尤其重要，线程复用会导致数据残留\n\n**示例：**\n\n```java\n// 正例 - 使用完毕后手动清理\nprivate static final ThreadLocal<UserContext> USER_CONTEXT = new ThreadLocal<>();\n\npublic void process() {\n    try {\n        USER_CONTEXT.set(new UserContext());\n        // 业务逻辑\n        doSomething();\n    } finally {\n        USER_CONTEXT.remove();  // 必须清理，防止内存泄漏\n    }\n}\n\n// 正例 - 使用 InheritableThreadLocal 传递上下文（父子线程）\nprivate static final InheritableThreadLocal<String> TRACE_ID = new InheritableThreadLocal<>();\n\n// 反例 - 使用后不清理\npublic void process() {\n    USER_CONTEXT.set(new UserContext());\n    doSomething();\n    // 没有 remove，线程池复用时数据残留\n}\n```\n\n### 锁使用规范\n\n- 【强制】加锁必须保证 `unlock()` 在 `finally` 块中执行\n- 【推荐】优先使用 `tryLock(timeout)` 而非无限等待的 `lock()`\n- 【强制】多个资源加锁时，注意加锁顺序，防止死锁\n\n**示例：**\n\n```java\n// 正例 - finally 中释放锁\nprivate final ReentrantLock lock = new ReentrantLock();\n\npublic void update() {\n    lock.lock();\n    try {\n        // 临界区代码\n    } finally {\n        lock.unlock();  // 必须在 finally 中释放\n    }\n}\n\n// 正例 - 使用 tryLock 带超时\npublic boolean updateWithTimeout() {\n    try {\n        if (lock.tryLock(5, TimeUnit.SECONDS)) {\n            try {\n                // 临界区代码\n                return true;\n            } finally {\n                lock.unlock();\n            }\n        } else {\n            logger.warn(\"获取锁超时\");\n            return false;\n        }\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n        return false;\n    }\n}\n\n// 反例 - 可能导致死锁\n// 线程1: lockA -> lockB\n// 线程2: lockB -> lockA\n```\n\n### volatile 使用\n\n- 【强制】`volatile` 只保证可见性和有序性，不保证原子性\n- 【强制】复合操作（如 `i++`）仍需使用 `synchronized` 或 `AtomicInteger`\n\n**示例：**\n\n```java\n// 正例 - volatile 用于状态标识\nprivate volatile boolean running = true;\n\npublic void stop() {\n    running = false;  // 其他线程立即可见\n}\n\npublic void run() {\n    while (running) {\n        // 业务逻辑\n    }\n}\n\n// 反例 - volatile 不保证原子性\nprivate volatile int count = 0;\n\npublic void increment() {\n    count++;  // 非原子操作，不安全\n}\n\n// 正例 - 使用 AtomicInteger\nprivate final AtomicInteger count = new AtomicInteger(0);\n\npublic void increment() {\n    count.incrementAndGet();\n}\n```\n\n### 日期格式化\n\n- 【强制】`SimpleDateFormat` 是线程不安全的\n- 【强制】使用 `DateTimeFormatter`（Java 8+）或 `Joda-Time`\n\n**示例：**\n\n```java\n// 反例 - SimpleDateFormat 线程不安全\nprivate static final SimpleDateFormat FORMAT = new SimpleDateFormat(\"yyyy-MM-dd\");\n\n// 正例 - DateTimeFormatter 线程安全\nprivate static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n```\n\n### 随机数生成\n\n- 【强制】避免 `Random` 实例被多线程使用\n- 【强制】使用 `ThreadLocalRandom`\n\n**示例：**\n\n```java\n// 反例\nprivate static final Random RANDOM = new Random();\n\n// 正例\nint randomValue = ThreadLocalRandom.current().nextInt(min, max);\n```\n\n### 并发集合\n\n- 【强制】高并发时 `HashMap` 可能死循环，使用 `ConcurrentHashMap`\n- 【强制】`ConcurrentHashMap` 的 `get`/`put` 是原子的，但组合操作不是\n\n**示例：**\n\n```java\n// 反例 - 高并发下可能死循环\nMap<String, String> map = new HashMap<>();\n\n// 正例\nConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();\n\n// 反例 - 组合操作非原子\nif(!map.\n\ncontainsKey(key)){  // 检查\n        map.\n\nput(key, value);       // 放入，两步非原子\n}\n\n// 正例 - 使用原子方法\n        map.\n\nputIfAbsent(key, value);\nmap.\n\ncomputeIfAbsent(key, k ->\n\ncreateValue());\n```\n\n### CountDownLatch 和 Semaphore\n\n- 【推荐】`CountDownLatch` 用于等待多个线程完成\n- 【推荐】`Semaphore` 用于控制并发数量\n\n**示例：**\n\n```java\n// CountDownLatch 示例\nCountDownLatch latch = new CountDownLatch(3);\n\nfor(\nint i = 0;\ni< 3;i++){\n        executor.\n\nsubmit(() ->{\n        try{\n        // 执行任务\n        }finally{\n        latch.\n\ncountDown();\n        }\n                });\n                }\n\n                latch.\n\nawait(10,TimeUnit.SECONDS);  // 等待所有任务完成\n\n// Semaphore 限流示例\nSemaphore semaphore = new Semaphore(10);  // 最多10个并发\n\npublic void process() {\n    try {\n        semaphore.acquire();\n        // 执行任务\n    } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n    } finally {\n        semaphore.release();\n    }\n}\n```\n\n---\n\n## 控制语句规范\n\n### switch 语句\n\n- 【强制】每个 `case` 需要使用 `break`/`continue`/`return` 或注释说明\n- 【强制】必须包含 `default` 分支，即使什么也不做\n- 【强制】`default` 分支放在最后\n\n**示例：**\n\n```java\n// 正例\nswitch(status){\n        case PENDING:\n\nhandlePending();\n        break;\n                case PROCESSING:\n\nhandleProcessing();\n        break;\n                case COMPLETED:\n        // fall through - 故意穿透\n        case CLOSED:\n\nhandleClose();\n        break;\ndefault:\n        throw new\n\nIllegalArgumentException(\"Unknown status: \"+status);\n}\n\n// 反例 - 缺少 break，导致意外 fallthrough\n        switch(status){\n        case PENDING:\n\nhandlePending();\n    case PROCESSING:  // 会意外执行到这里\n\nhandleProcessing();\n        break;\n                }\n\n// 反例 - 缺少 default\n                switch(status){\n        case PENDING:\n\nhandlePending();\n        break;\n                }\n```\n\n### 大括号使用\n\n- 【强制】`if`/`else`/`for`/`while`/`do` 必须使用大括号，即使只有一行\n\n**示例：**\n\n```java\n// 正例\nif(condition){\n\ndoSomething();\n}\n\n// 反例 - 不使用大括号\n        if(condition)\n\ndoSomething();\n```\n\n### 条件表达式\n\n- 【推荐】不要在条件表达式复杂时使用 `?:` 简化\n- 【强制】三目运算符注意类型转换，避免自动拆箱导致 NPE\n\n**示例：**\n\n```java\n// 正例 - 简单条件\nint max = (a > b) ? a : b;\n\n// 反例 - 复杂条件，应使用 if-else\nString result = (a > b && c < d || e == f) ? complexCalculation() : anotherCalculation();\n\n// 正例 - 复杂条件使用 if-else\nString result;\nif(a >b &&c<d ||e ==f){\nresult =\n\ncomplexCalculation();\n}else{\nresult =\n\nanotherCalculation();\n}\n\n// 反例 - 自动拆箱导致 NPE\nInteger a = 1;\nInteger b = null;\nInteger c = condition ? a : b;  // b 为 null 时可能 NPE\n\n// 正例 - 避免空指针\nInteger c = condition ? a : (b != null ? b : 0);\n```\n\n### 避免取反逻辑\n\n- 【推荐】尽量使用正向逻辑，避免使用取反操作\n```java\n!\n```\n\n**示例：**\n\n```java\n// 反例 - 取反逻辑\nif(!isNotValid()){}\n\n// 正例 - 正向逻辑\n        if(\n\nisValid()){}\n\n// 反例 - 双重取反\n        if(!!flag){}\n```\n\n### 条件判断顺序\n\n- 【推荐】将较大概率成立的条件放在前面\n- 【推荐】将简单的条件放在前面（短路评估）\n\n**示例：**\n\n```java\n// 正例 - 简单条件在前，利用短路\nif(flag &&\n\nexpensiveCheck()){}\n\n// 反例 - 复杂条件在前\n        if(\n\nexpensiveCheck() &&flag){}\n```\n\n### null 判断优化\n\n- 【推荐】使用 `Objects.isNull()` 或 `Objects.nonNull()` 代替 `== null`\n- 【推荐】使用 `Optional` 避免多层 null 检查\n\n**示例：**\n\n```java\n// 正例 - 使用 Objects 工具类\nif(Objects.isNull(user)){}\n        if(Objects.\n\nnonNull(user)){}\n\n// 正例 - 使用 Optional 链式调用\nString cityName = Optional.ofNullable(user)\n        .map(User::getAddress)\n        .map(Address::getCity)\n        .map(City::getName)\n        .orElse(\"Unknown\");\n\n// 反例 - 多层 null 检查\nString cityName = \"Unknown\";\nif(user !=null){\nAddress address = user.getAddress();\n    if(address !=null){\nCity city = address.getCity();\n        if(city !=null){\ncityName =city.\n\ngetName();\n        }\n                }\n                }\n```\n\n---\n\n## 前后端规范\n\n### 接口返回数据结构\n\n- 【强制】统一响应结构，包含 `code`、`message`、`data`、`timestamp`\n\n**示例：**\n\n```java\n// 正例 - 统一的响应结构\npublic class ApiResponse<T> {\n    /**\n     * 响应码。\n     */\n    private Integer code;\n\n    /**\n     * 响应消息。\n     */\n    private String message;\n\n    /**\n     * 响应数据。\n     */\n    private T data;\n\n    /**\n     * 响应时间戳。\n     */\n    private Long timestamp;\n\n    public static <T> ApiResponse<T> success(T data) {\n        ApiResponse<T> response = new ApiResponse<>();\n        response.setCode(200);\n        response.setMessage(\"success\");\n        response.setData(data);\n        response.setTimestamp(System.currentTimeMillis());\n        return response;\n    }\n\n    public static <T> ApiResponse<T> error(Integer code, String message) {\n        ApiResponse<T> response = new ApiResponse<>();\n        response.setCode(code);\n        response.setMessage(message);\n        response.setTimestamp(System.currentTimeMillis());\n        return response;\n    }\n}\n```\n\n### RESTful API 设计\n\n- 【推荐】使用 HTTP 动词：GET、POST、PUT、DELETE\n- 【推荐】资源命名使用名词复数：`/users`、`/orders`\n- 【推荐】版本控制：`/api/v1/users`\n\n**示例：**\n\n```java\n// 正例 - RESTful 风格\nGET    /api/v1/users          #获取用户列表\nGET    /api/v1/users/{id}     #获取指定用户\nPOST   /api/v1/users          #创建用户\nPUT    /api/v1/users/{id}     #更新用户\nDELETE /api/v1/users/{id}     #删除用户\n\n// 反例 - 非RESTful风格\nGET    /api/v1/getUserList\nPOST   /api/v1/createUser\nPOST   /api/v1/deleteUserById\n```\n\n### 接口参数验证\n\n- 【强制】使用 JSR-303/JSR-380 注解进行参数验证\n- 【推荐】自定义验证注解处理复杂业务规则\n\n**示例：**\n\n```java\n// 正例 - 使用验证注解\npublic class CreateUserRequest {\n    @NotBlank(message = \"用户名不能为空\")\n    @Size(min = 2, max = 20, message = \"用户名长度2-20字符\")\n    private String username;\n\n    @NotBlank(message = \"邮箱不能为空\")\n    @Email(message = \"邮箱格式不正确\")\n    private String email;\n\n    @NotNull(message = \"年龄不能为空\")\n    @Min(value = 18, message = \"年龄必须大于18岁\")\n    private Integer age;\n}\n\n@PostMapping(\"/users\")\npublic ApiResponse<User> createUser(@Valid @RequestBody CreateUserRequest request) {\n    // ...\n}\n```\n\n### 分页参数规范\n\n- 【推荐】统一使用 `page`（页码，从1开始）和 `size`（每页数量）\n- 【推荐】设置默认值和最大值限制\n\n**示例：**\n\n```java\n// 正例 - 统一分页参数\n@GetMapping(\"/users\")\npublic ApiResponse<PageResult<User>> getUsers(\n        @RequestParam(defaultValue = \"1\") Integer page,\n        @RequestParam(defaultValue = \"10\") Integer size\n) {\n    // 限制最大每页数量\n    if (size > 100) {\n        size = 100;\n    }\n    // ...\n}\n```\n\n### 错误码规范\n\n- 【推荐】使用统一的错误码枚举\n- 【推荐】错误码格式：`模块号(2位) + 业务号(3位) + 错误类型(1位)`\n\n**示例：**\n\n```java\n// 正例 - 统一错误码\npublic enum ErrorCode {\n    // 用户模块 01\n    USER_NOT_FOUND(01001, \"用户不存在\"),\n    USER_ALREADY_EXISTS(01002, \"用户已存在\"),\n    USER_PASSWORD_ERROR(01003, \"密码错误\"),\n\n    // 订单模块 02\n    ORDER_NOT_FOUND(02001, \"订单不存在\"),\n    ORDER_STATUS_ERROR(02002, \"订单状态错误\");\n\n    private final Integer code;\n    private final String message;\n\n    ErrorCode(Integer code, String message) {\n        this.code = code;\n        this.message = message;\n    }\n}\n```\n\n### 接口文档\n\n- 【推荐】使用 Swagger/OpenAPI 生成接口文档\n- 【强制】必须包含参数说明、返回值说明、错误码说明\n\n**示例：**\n\n```java\n// 正例 - Swagger 注解\n@RestController\n@RequestMapping(\"/api/v1/users\")\n@Tag(name = \"用户管理\", description = \"用户相关接口\")\npublic class UserController {\n\n    @Operation(summary = \"获取用户列表\", description = \"分页获取用户列表\")\n    @Parameters({\n            @Parameter(name = \"page\", description = \"页码，从1开始\"),\n            @Parameter(name = \"size\", description = \"每页数量\")\n    })\n    @GetMapping\n    public ApiResponse<PageResult<User>> getUsers(\n            @RequestParam(defaultValue = \"1\") Integer page,\n            @RequestParam(defaultValue = \"10\") Integer size\n    ) {\n        // ...\n    }\n}\n```\n\n### 前后端时间格式\n\n- 【推荐】后端返回统一格式：`yyyy-MM-dd HH:mm:ss`\n- 【推荐】前端传入同上格式\n- 【推荐】时区统一为 UTC 或 GMT+8\n\n---\n\n## 项目结构标准\n\n### 标准目录布局\n\n```\nproject-root/\n├── src/\n│   ├── main/\n│   │   ├── java/           # 应用源码\n│   │   └── resources/      # 资源文件\n│   └── test/\n│       ├── java/           # 单元测试\n│       └── resources/      # 测试资源\n├── pom.xml / build.gradle  # 构建文件\n├── README.md\n└── LICENSE.txt\n```\n\n### 应用分层\n\n- 【推荐】推荐的分层结构：Controller → Service → Manager → DAO\n- 【强制】上层依赖下层，下层不得反向依赖\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    Controller 层                        │\n│    负责请求转发、参数校验、响应封装                        │\n└──────────────────────────┬──────────────────────────────┘\n                           ▼\n┌─────────────────────────────────────────────────────────┐\n│                    Service 层                           │\n│    核心业务逻辑、事务控制                                 │\n└──────────────────────────┬──────────────────────────────┘\n                           ▼\n┌─────────────────────────────────────────────────────────┐\n│                    Manager 层 (可选)                     │\n│    通用业务处理：                                        │\n│    - 对第三方平台封装（支付、短信、OSS 等）                │\n│    - 对 Service 层通用能力的下沉                         │\n│    - 与 DAO 层交互，对多个 DAO 的组合复用                 │\n└──────────────────────────┬──────────────────────────────┘\n                           ▼\n┌─────────────────────────────────────────────────────────┐\n│                    DAO 层                               │\n│    数据访问层：与数据库交互                               │\n└─────────────────────────────────────────────────────────┘\n```\n\n### 领域模型命名\n\n- 【强制】各层使用不同的领域模型，禁止跨层传递\n\n| 模型    | 全称                   | 用途       | 所在层            |\n|-------|----------------------|----------|----------------|\n| DO    | Data Object          | 数据库表映射对象 | DAO 层          |\n| DTO   | Data Transfer Object | 数据传输对象   | Service 层输入/输出 |\n| VO    | View Object          | 视图对象，展示层 | Controller 层输出 |\n| BO    | Business Object      | 业务对象     | Service 层内部    |\n| Query | Query Object         | 查询条件封装   | 各层输入           |\n\n**示例：**\n\n```java\n// DO - 数据库映射\n@TableName(\"t_user\")\npublic class UserDO {\n    private Long id;\n    private String userName;\n    private String password;  // 敏感字段\n    private LocalDateTime createTime;\n}\n\n// DTO - 服务层传输\npublic class UserDTO {\n    private Long id;\n    private String userName;\n    private String email;\n    // 不包含敏感字段\n}\n\n// VO - 视图展示\npublic class UserVO {\n    private Long id;\n    private String userName;\n    private String displayName;\n    private String avatarUrl;\n}\n\n// Query - 查询条件\npublic class UserQuery {\n    private String keyword;\n    private Integer status;\n    private LocalDate startDate;\n    private LocalDate endDate;\n    private Integer page;\n    private Integer size;\n}\n```\n\n### 包与模块\n\n- 【强制】包结构反映模块/功能划分\n- 【强制】避免包之间循环依赖\n- 【推荐】常见分包方式：`controller`、`service`、`manager`、`dao`/`mapper`、`model`、`config`\n- 【推荐】多模块项目在根构建文件中定义子模块\n\n**标准包结构：**\n\n```\ncom.example.project/\n├── controller/          # 控制器层\n│   └── UserController.java\n├── service/             # 服务层\n│   ├── UserService.java\n│   └── impl/\n│       └── UserServiceImpl.java\n├── manager/             # 通用业务层（可选）\n│   └── ThirdPartyPayManager.java\n├── dao/                 # 数据访问层\n│   └── UserMapper.java\n├── model/               # 领域模型\n│   ├── entity/          # DO\n│   │   └── UserDO.java\n│   ├── dto/             # DTO\n│   │   └── UserDTO.java\n│   ├── vo/              # VO\n│   │   └── UserVO.java\n│   └── query/           # 查询对象\n│       └── UserQuery.java\n├── config/              # 配置类\n│   └── WebConfig.java\n├── common/              # 公共组件\n│   ├── exception/       # 异常定义\n│   ├── constants/       # 常量定义\n│   └── utils/           # 工具类\n└── Application.java     # 启动类\n```\n\n### 类文件管理\n\n- 【强制】一个 `.java` 文件只包含一个 `public` 类\n- 【强制】公共类名与文件名一致\n- 【推荐】内部类可写在同一文件中\n\n---\n\n## 注释与文档要求\n\n### Javadoc 规范\n\n- 【强制】类、类属性、类方法必须使用 Javadoc 格式 `/** */`，不得使用 `// xxx`\n- 【强制】所有公有类、构造方法、方法和字段必须使用 Javadoc\n- 【强制】抽象方法必须添加注释\n- 【强制】所有类添加创建者和创建日期\n- 【强制】每个非 `void` 方法必须有 `@return` 标签\n- 【强制】每个参数使用 `@param` 标签\n- 【强制】可能抛出的异常使用 `@throws` 说明\n\n**示例：**\n\n```java\n/**\n * 用户服务实现类。\n *\n * @author 张三\n * @since 2024-01-01\n */\npublic class UserServiceImpl implements UserService {\n\n    /**\n     * 用户仓储。\n     */\n    private final UserRepository userRepository;\n\n    /**\n     * 计算两个数字的和。\n     *\n     * @param a 第一个加数\n     * @param b 第二个加数\n     * @return 两个数字的和\n     * @throws IllegalArgumentException 如果参数为 null\n     */\n    public int add(Integer a, Integer b) {\n        // ...\n    }\n\n    /**\n     * 处理订单（抽象方法必须注释）。\n     *\n     * @param orderId 订单ID\n     */\n    public abstract void processOrder(String orderId);\n}\n```\n\n### 注释风格\n\n- 【推荐】使用 `/* */` 注释说明\"为什么\"，`//` 注释说明\"做什么\"\n- 【推荐】多行注释使用 `/* */`，单行注释使用 `//`\n- 【强制】注释双斜线与内容间仅一个空格\n\n**示例：**\n\n```java\n/*\n * 这里使用 HashMap 而非 TreeMap，是因为：\n * 1. 不需要排序功能\n * 2. HashMap 的查询性能 O(1) 更优\n */\nMap<String, String> cache = new HashMap<>();\n\n// 检查用户是否存在\nboolean exists = userMapper.selectById(userId) != null;\n```\n\n### 注释内容\n\n- 【强制】解释\"为什么\"而非\"做什么\"\n- 【强制】复杂算法、业务规则需详细说明\n- 【强制】保持注释与代码同步\n- 【强制】禁止保留无用的注释代码块\n- 【推荐】使用英语或团队约定的统一语言\n\n### 特殊标记注释\n\n- 【强制】待办事项使用 `TODO` 标记，格式：`// TODO: [描述] - [负责人] [日期]`\n- 【强制】已知缺陷使用 `FIXME` 标记，格式：`// FIXME: [描述] - [负责人] [日期]`\n- 【推荐】定期清理 TODO 和 FIXME 标记\n\n**示例：**\n\n```java\n// TODO: 增加缓存支持 - 张三 2024-01-15\npublic User getUserById(Long id) {\n    return userMapper.selectById(id);\n}\n\n// FIXME: 并发场景下可能有问题，需要加锁 - 李四 2024-01-20\npublic void updateCounter() {\n    counter++;\n}\n\n// XXX: 这里的实现有性能问题，后续需要优化\npublic List<User> getAllUsers() {\n    return userMapper.selectAll();\n}\n```\n\n### 本地注释规范\n\n- 【推荐】参考项目中现有代码的注释风格\n- 【推荐】保持与项目本地注释规范一致\n\n---\n\n## 错误与异常处理\n\n### 异常抛出\n\n- 【强制】检测到错误时抛出异常，**不返回错误码**\n- 【强制】抛出具体的异常类型（`IllegalArgumentException`、`IOException` 等）\n- 【推荐】必要时自定义异常类\n\n**示例：**\n\n```java\n// 正例\npublic void divide(int a, int b) {\n    if (b == 0) {\n        throw new IllegalArgumentException(\"除数不能为零\");\n    }\n}\n\n// 反例\npublic int divide(int a, int b) {\n    if (b == 0) {\n        return -1;  // 不应返回错误码\n    }\n}\n```\n\n### 预检查 vs 异常捕获\n\n- 【强制】`RuntimeException` 不应通过 `catch` 方式处理，应提前检查\n- 【推荐】对于可预见的异常条件，使用前置检查\n\n**示例：**\n\n```java\n// 反例 - 捕获 NullPointerException\ntry{\n        user.getName();\n}catch(\nNullPointerException e){\n        // ...\n        }\n\n// 正例 - 前置检查\n        if(user !=null){\n        user.\n\ngetName();\n}\n```\n\n### 异常捕获规则\n\n- 【强制】不要捕获 `Exception` 或 `Throwable`\n- 【强制】`catch` 分清稳定代码（不会/极少出错）和非稳定代码\n- 【强制】区分异常类型，分别处理\n- 【强制】不要空捕获异常\n\n**示例：**\n\n```java\n// 反例 - 捕获所有异常\ntry{\n        // ...\n        }catch(Exception e){\n        // 吞掉异常\n        }\n\n// 正例 - 区分异常类型\n        try{\n        // 可能抛出 IOException 的代码\n        }catch(\nFileNotFoundException e){\n        logger.\n\nerror(\"文件不存在: {}\",e.getMessage(),e);\n        throw new\n\nBusinessException(\"文件配置错误\",e);\n}catch(\nIOException e){\n        logger.\n\nerror(\"IO 异常: {}\",e.getMessage(),e);\n        throw new\n\nBusinessException(\"文件读取失败\",e);\n}\n```\n\n### 分层异常处理\n\n- 【参考】DAO 层捕获异常并抛出业务异常\n\n**示例：**\n\n```java\n// DAO 层\npublic User findById(Long id) {\n    try {\n        return userMapper.selectById(id);\n    } catch (Exception e) {\n        logger.error(\"查询用户失败, id={}\", id, e);\n        throw new DAOException(\"查询用户失败\", e);\n    }\n}\n\n// Service 层\npublic User getUser(Long id) {\n    try {\n        return userDao.findById(id);\n    } catch (DAOException e) {\n        logger.error(\"获取用户失败, id={}\", id, e);\n        throw new ServiceException(\"获取用户失败\", e);\n    }\n}\n```\n\n### 资源管理\n\n- 【强制】使用 try-with-resources 关闭资源\n- 【推荐】确保所有 `Closeable` 资源正确关闭\n\n**示例：**\n\n```java\n// 正例 - try-with-resources\ntry(InputStream is = new FileInputStream(file);\nBufferedReader reader = new BufferedReader(new InputStreamReader(is))){\n        // ...\n        }\n\n// 反例 - 手动关闭可能泄漏\nInputStream is = null;\ntry{\nis =new\n\nFileInputStream(file);\n// ...\n}finally{\n        if(is !=null){\n        is.\n\nclose();  // 可能抛出异常导致资源未关闭\n    }\n            }\n```\n\n---\n\n## 日志规约\n\n### 日志框架\n\n- 【强制】不可直接使用 Log4j/Logback API，应使用 SLF4J\n- 【强制】Logger 声明：`private static final Logger logger = LoggerFactory.getLogger(Test.class);`\n\n**示例：**\n\n```java\n// 正例\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class UserService {\n    private static final Logger logger = LoggerFactory.getLogger(UserService.class);\n}\n\n// 反例 - 直接使用 Log4j\nimport org.apache.log4j.Logger;\nprivate static final Logger logger = Logger.getLogger(UserService.class);\n```\n\n### 日志输出\n\n- 【强制】使用 `{}` 占位符而非字符串拼接\n- 【强制】debug 日志调用前判断：`if (logger.isDebugEnabled())`\n- 【推荐】日志中避免使用 `toString()` 序列化整个对象\n\n**示例：**\n\n```java\n// 正例 - 使用占位符\nlogger.info(\"用户登录成功, userId={}, userName={}\",user.getId(),user.\n\ngetName());\n\n// 反例 - 字符串拼接\n        logger.\n\ninfo(\"用户登录成功, userId=\"+user.getId() +\", userName=\"+user.\n\ngetName());\n\n// 正例 - debug 判断\n        if(logger.\n\nisDebugEnabled()){\n        logger.\n\ndebug(\"详细信息: {}\",expensiveOperation());\n        }\n\n// 反例 - 直接输出对象（可能产生大量日志）\n        logger.\n\ninfo(\"用户信息: {}\",user);  // 可能输出大量字段\n```\n\n### 日志级别使用\n\n- 【参考】`ERROR`：系统错误、异常，需要紧急处理\n- 【参考】`WARN`：预期外但可恢复的情况，需要关注\n- 【参考】`INFO`：关键业务流程、重要状态变化\n- 【参考】`DEBUG`：调试信息，问题排查\n\n**示例：**\n\n```java\n// ERROR - 系统异常，需要紧急处理\nlogger.error(\"支付处理失败, orderId={}, error={}\",orderId, e.getMessage(),e);\n\n// WARN - 预期外但可恢复\n        logger.\n\nwarn(\"库存不足, skuId={}, 当前库存={}, 需求数量={}\",skuId, stock, quantity);\n\n// INFO - 关键业务流程\nlogger.\n\ninfo(\"订单创建成功, orderId={}, userId={}, amount={}\",orderId, userId, amount);\n\n// DEBUG - 调试信息\nlogger.\n\ndebug(\"进入方法 processOrder, orderId={}\",orderId);\n```\n\n### 异常日志\n\n- 【强制】记录异常时包含堆栈信息\n\n**示例：**\n\n```java\n// 正例\ntry{\n        // ...\n        }catch(Exception e){\n        logger.\n\nerror(\"操作失败, userId={}\",userId, e);  // e 会输出堆栈\n}\n\n// 反例 - 只输出消息，没有堆栈\n        try{\n        // ...\n        }catch(\nException e){\n        logger.\n\nerror(\"操作失败, userId={}, error={}\",userId, e.getMessage());\n        }\n```\n\n### 禁止事项\n\n- 【强制】禁止使用 `System.out` 或 `System.err` 输出日志\n- 【强制】禁止在生产环境打印大量 debug 日志\n- 【强制】禁止在日志中输出敏感信息（密码、密钥等）\n\n---\n\n## MySQL 数据库规范\n\n### 建表规约\n\n- 【强制】表名使用小写字母+下划线，长度不超过32字符\n- 【强制】禁止使用 MySQL 保留字作为表名\n- 【强制】字段名使用小写字母+下划线\n- 【强制】布尔类型字段使用 `is_xxx` 命名\n- 【强制】主键字段统一使用 `id`\n- 【强制】字符集：`utf8mb4`，排序规则：`utf8mb4_general_ci` 或 `utf8mb4_unicode_ci`\n\n**示例：**\n\n```sql\n-- 正例 - 标准建表语句\nCREATE TABLE `t_user`\n(\n    `id`          BIGINT       NOT NULL AUTO_INCREMENT COMMENT '主键',\n    `user_name`   VARCHAR(50)  NOT NULL COMMENT '用户名',\n    `email`       VARCHAR(100) NOT NULL COMMENT '邮箱',\n    `is_active`   TINYINT(1) NOT NULL DEFAULT 1 COMMENT '是否激活',\n    `create_time` DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    `update_time` DATETIME     NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',\n    PRIMARY KEY (`id`),\n    UNIQUE KEY `uk_email` (`email`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';\n\n-- 反例 - 表名使用大写、缺少注释、字符集错误\nCREATE TABLE User\n(\n    ID       BIGINT      NOT NULL AUTO_INCREMENT,\n    UserName VARCHAR(50) NOT NULL,\n    PRIMARY KEY (ID)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n### 字段规约\n\n- 【强制】必选字段：`id`、`create_time`、`update_time`\n- 【推荐】`create_time` 使用 `DEFAULT CURRENT_TIMESTAMP`\n- 【推荐】`update_time` 使用 `ON UPDATE CURRENT_TIMESTAMP`\n- 【强制】小数类型使用 `DECIMAL`\n- 【强制】存储字符串使用 `VARCHAR`、`CHAR`，避免使用 `TEXT`\n\n**示例：**\n\n```sql\n-- 正例 - 金额使用 DECIMAL\n`amount`\nDECIMAL(10, 2) NOT NULL COMMENT '金额'\n\n-- 反例 - 金额使用 DOUBLE（精度丢失）\n`amount` DOUBLE NOT NULL COMMENT '金额'\n\n-- 正例 - 枚举使用 TINYINT\n`status` TINYINT NOT NULL DEFAULT 0 COMMENT '状态：0-待支付，1-已支付'\n\n-- 反例 - 枚举使用 VARCHAR\n`status` VARCHAR(20) NOT NULL COMMENT '状态'\n```\n\n### 索引规约\n\n- 【强制】主键使用 `BIGINT` 自增，**禁止使用 UUID** 作为主键\n- 【强制】业务唯一字段必须建立唯一索引，命名格式：`uk_字段名`\n- 【强制】区分度高的字段建立普通索引，命名格式：`idx_字段名`\n- 【推荐】联合索引字段数不超过5个\n- 【推荐】遵循最左前缀原则\n- 【推荐】避免冗余索引\n\n**示例：**\n\n```sql\n-- 正例 - 索引命名规范\nPRIMARY KEY (`id`),\nUNIQUE KEY `uk_email` (`email`),\nKEY `idx_user_name` (`user_name`),\nKEY `idx_create_time_status` (`create_time`, `status`);\n\n-- 反例 - 使用 UUID 作为主键\n`id`\nVARCHAR(36) NOT NULL COMMENT '主键'\n\n-- 反例 - 冗余索引\nKEY `idx_a_b` (`a`, `b`),\nKEY `idx_a` (`a`);  -- 冗余，已被 idx_a_b 覆盖\n```\n\n### SQL 语句规约\n\n- 【强制】禁止使用 `SELECT *`，必须明确指定字段\n- 【强制】超过三个表禁止 JOIN，需拆分为多次查询\n- 【强制】`IN` 操作元素数量控制在 1000 以内\n- 【推荐】分页查询优化，大偏移量使用游标或延迟关联\n- 【强制】禁止在 WHERE 条件中对字段进行函数操作（导致索引失效）\n- 【推荐】避免 `OR` 连接条件，使用 `UNION ALL` 代替\n- 【强制】使用 `count(*)` 或 `count(1)` 统计行数，避免 `count(列名)`\n\n**示例：**\n\n```sql\n-- 反例 - SELECT *\nSELECT *\nFROM t_user\nWHERE id = 1;\n\n-- 正例 - 明确指定字段\nSELECT id, user_name, email\nFROM t_user\nWHERE id = 1;\n\n-- 反例 - 超过 3 表 JOIN\nSELECT *\nFROM t_order o\n         JOIN t_user u ON o.user_id = u.id\n         JOIN t_product p ON o.product_id = p.id\n         JOIN t_category c ON p.category_id = c.id\n         JOIN t_brand b ON p.brand_id = b.id;\n\n-- 正例 - 拆分查询\nSELECT id, user_id, product_id\nFROM t_order\nWHERE id = 1;\n-- 再单独查询用户和商品信息\n\n-- 反例 - 大偏移量性能差\nSELECT *\nFROM t_user LIMIT 1000000, 10;\n\n-- 正例 - 使用游标分页\nSELECT *\nFROM t_user\nWHERE id > 1000000 LIMIT 10;\n\n-- 反例 - WHERE 中对字段使用函数（索引失效）\nWHERE DATE(create_time) = '2024-01-01'\n\n-- 正例 - 范围查询（可使用索引）\nWHERE create_time >= '2024-01-01 00:00:00'\n  AND create_time < '2024-01-02 00:00:00'\n\n-- 反例 - count(列名) 会忽略 NULL 值\nSELECT count(email)\nFROM t_user;\n\n-- 正例 - count(*) 统计所有行\nSELECT count(*)\nFROM t_user;\n```\n\n### ORM 映射规约（MyBatis）\n\n- 【强制】使用 `#{}` 预编译，禁止使用 `${}` 传递用户输入\n- 【推荐】复杂查询必须使用 ResultMap\n- 【推荐】避免使用自动映射\n\n**示例：**\n\n```xml\n<!-- 正例 - 使用 #{} 预编译 -->\n<select id=\"getUserById\" resultType=\"User\">\n    SELECT id, user_name, email\n    FROM t_user\n    WHERE id = #{id}\n</select>\n\n        <!-- 反例 - 使用 ${} 字符串拼接，SQL 注入风险 -->\n<select id=\"getUserById\" resultType=\"User\">\nSELECT id, user_name, email\nFROM t_user\nWHERE id = ${id}\n</select>\n\n        <!-- 正例 - 使用 ResultMap -->\n<resultMap id=\"UserResultMap\" type=\"User\">\n<id property=\"id\" column=\"id\"/>\n<result property=\"userName\" column=\"user_name\"/>\n<result property=\"email\" column=\"email\"/>\n</resultMap>\n\n<select id=\"getUserWithOrders\" resultMap=\"UserResultMap\">\nSELECT u.id, u.user_name, u.email, o.id as order_id\nFROM t_user u\nLEFT JOIN t_order o ON u.id = o.user_id\nWHERE u.id = #{userId}\n</select>\n```\n\n### 事务规约\n\n- 【强制】事务粒度要小，避免大事务\n- 【推荐】事务方法命名以 `tx` 开头（如 `txCreateOrder`）\n- 【强制】查询操作不使用事务\n\n**示例：**\n\n```java\n// 正例 - 事务方法命名清晰\n@Transactional(rollbackFor = Exception.class)\npublic void txCreateOrder(Order order) {\n    // 创建订单\n    // 扣减库存\n    // 创建支付记录\n}\n\n// 反例 - 查询使用事务\n@Transactional(readOnly = true)\npublic Order getOrderById(Long id) {\n    return orderMapper.selectById(id);\n}\n```\n\n---\n\n## 测试规范\n\n### 基本原则\n\n- 【强制】单元测试必须遵循 **AIR 原则**：\n    - **A**utomatic（自动化）：测试必须全自动执行，无需人工干预\n    - **I**ndependent（独立性）：测试之间相互独立，不依赖执行顺序\n    - **R**epeatable（可重复）：任何环境下运行结果一致\n\n- 【强制】单元测试必须遵循 **BCDE 原则**：\n    - **B**order（边界）：测试边界值和极端情况\n    - **C**orrect（正确）：测试正确输入的预期输出\n    - **D**esign（设计）：按照设计文档编写测试\n    - **E**rror（错误）：测试异常输入和错误路径\n\n### 禁止事项\n\n- 【强制】禁止使用 `System.out` 输出人工验证，必须使用断言\n- 【强制】禁止在测试中使用 `Thread.sleep()` 模拟等待\n- 【强制】禁止测试代码依赖外部资源（网络、数据库等）\n\n**示例：**\n\n```java\n// 反例 - 使用 System.out 人工验证\n@Test\nvoid test() {\n    String result = service.process();\n    System.out.println(result);  // 需要人工查看\n}\n\n// 正例 - 使用断言自动验证\n@Test\nvoid test() {\n    String result = service.process();\n    assertEquals(\"expected\", result);\n}\n```\n\n### 测试目录\n\n- 单元测试放在 `src/test/java`\n- 目录结构与主代码保持一致\n- 每个被测类对应一个测试类\n\n### 测试框架\n\n- 推荐 **JUnit 5**\n- 测试类名以被测类名加 `Test` 结尾\n- 测试方法使用 `@Test` 注解\n\n### 测试命名\n\n- 【推荐】使用具有可读性的方法名\n- 【推荐】命名风格：`givenX_whenY_thenZ` 或 `should_Y_when_X`\n- 【推荐】使用 `@DisplayName` 提供中文描述\n\n**示例：**\n\n```java\n\n@Test\n@DisplayName(\"给定有效用户ID，当查询用户时，返回正确的用户对象\")\nvoid givenValidUserId_whenFindById_thenReturnUser() {\n    // Given\n    Long userId = 1L;\n    User expectedUser = new User(userId, \"张三\");\n    when(mockRepository.findById(userId)).thenReturn(Optional.of(expectedUser));\n\n    // When\n    User actualUser = userService.getUserById(userId);\n\n    // Then\n    assertNotNull(actualUser);\n    assertEquals(\"张三\", actualUser.getName());\n    verify(mockRepository).findById(userId);\n}\n\n@Test\n@DisplayName(\"给定无效用户ID，当查询用户时，抛出异常\")\nvoid givenInvalidUserId_whenFindById_thenThrowException() {\n    // Given\n    Long userId = -1L;\n\n    // When & Then\n    assertThrows(IllegalArgumentException.class, () -> {\n        userService.getUserById(userId);\n    });\n}\n```\n\n### 覆盖率与范围\n\n- 【推荐】目标覆盖率：**70%～80%** 以上\n- 【强制】核心业务逻辑覆盖率不低于 **80%**\n- 【推荐】重点测试复杂逻辑、输入验证、异常分支\n- 【推荐】关注极端值和无效输入\n\n### 隔离与独立性\n\n- 【强制】单元测试应相互独立，可并行执行\n- 【强制】使用 Mock 框架（如 Mockito）模拟外部依赖\n- 【强制】避免测试间相互影响\n- 【推荐】每个测试方法测试一个场景\n\n**示例：**\n\n```java\n\n@ExtendWith(MockitoExtension.class)\nclass UserServiceTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    @BeforeEach\n    void setUp() {\n        // 每个测试前重置状态\n    }\n\n    @AfterEach\n    void tearDown() {\n        // 每个测试后清理资源\n    }\n}\n```\n\n### 测试数据管理\n\n- 【推荐】使用 `@BeforeEach` 准备测试数据\n- 【推荐】使用 `@AfterEach` 清理测试数据\n- 【强制】数据库测试使用事务回滚\n\n**示例：**\n\n```java\n\n@SpringBootTest\n@Transactional  // 测试完成后自动回滚\nclass UserRepositoryTest {\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Test\n    void saveUser_shouldPersist() {\n        User user = new User(\"test@example.com\");\n        userRepository.save(user);\n        assertNotNull(user.getId());\n    }\n    // 事务回滚，不会影响数据库\n}\n```\n\n### 参数化测试\n\n- 【推荐】使用 JUnit 5 的 `@ParameterizedTest` 减少重复代码\n\n**示例：**\n\n```java\n\n@ParameterizedTest\n@ValueSource(strings = {\"\", \" \", \"  \"})\n@DisplayName(\"空白字符串应该验证失败\")\nvoid validate_shouldFail_whenBlankString(String input) {\n    assertFalse(validator.isValid(input));\n}\n\n@ParameterizedTest\n@CsvSource({\n        \"1, 2, 3\",\n        \"0, 0, 0\",\n        \"-1, 1, 0\"\n})\n@DisplayName(\"加法运算测试\")\nvoid add_shouldReturnCorrectSum(int a, int b, int expected) {\n    assertEquals(expected, calculator.add(a, b));\n}\n```\n\n---\n\n## 依赖管理\n\n### 构建工具\n\n- 使用 Maven 或 Gradle\n- 所有依赖显式声明版本号\n\n### Maven 依赖管理\n\n- 使用 `<dependencyManagement>` 或 **BOM** 集中管理版本\n- 各模块引入依赖时可省略版本号\n- 统一升级版本，避免冲突\n\n### 版本策略\n\n- 遵循 **语义化版本**（SemVer）：`MAJOR.MINOR.PATCH`\n- MAJOR：向后不兼容的更改\n- MINOR：向后兼容的新功能\n- PATCH：缺陷修复\n- 使用 Git 标签（如 `v1.2.3`）标注发布版本\n\n### 依赖更新\n\n- 定期检查并更新第三方依赖\n- 使用 Maven Versions Plugin、Dependabot 等工具\n- 避免使用已知有安全漏洞的版本\n\n---\n\n## 安全与健壮性建议\n\n### 权限校验\n\n- 【强制】用户敏感数据操作必须进行**水平越权**校验\n- 【强制】验证当前用户只能操作自己的数据\n\n**示例：**\n\n```java\n// 正例 - 水平越权校验\npublic Order getOrder(Long orderId) {\n    Order order = orderMapper.selectById(orderId);\n    if (order == null) {\n        throw new NotFoundException(\"订单不存在\");\n    }\n\n    // 校验当前用户是否有权限访问该订单\n    Long currentUserId = SecurityContext.getCurrentUserId();\n    if (!order.getUserId().equals(currentUserId)) {\n        throw new ForbiddenException(\"无权访问该订单\");\n    }\n\n    return order;\n}\n\n// 反例 - 没有越权校验\npublic Order getOrder(Long orderId) {\n    return orderMapper.selectById(orderId);  // 任何人都可以查看任意订单\n}\n```\n\n### 敏感数据脱敏\n\n- 【强制】手机号、身份证、银行卡等敏感信息禁止明文展示\n- 【强制】日志中禁止输出敏感数据\n\n**示例：**\n\n```java\n// 正例 - 敏感数据脱敏\npublic class DesensitizeUtils {\n\n    /**\n     * 手机号脱敏：138****8888\n     */\n    public static String maskPhone(String phone) {\n        if (phone == null || phone.length() < 11) {\n            return phone;\n        }\n        return phone.substring(0, 3) + \"****\" + phone.substring(7);\n    }\n\n    /**\n     * 身份证脱敏：110***********1234\n     */\n    public static String maskIdCard(String idCard) {\n        if (idCard == null || idCard.length() < 18) {\n            return idCard;\n        }\n        return idCard.substring(0, 3) + \"***********\" + idCard.substring(14);\n    }\n\n    /**\n     * 邮箱脱敏：t***@example.com\n     */\n    public static String maskEmail(String email) {\n        if (email == null || !email.contains(\"@\")) {\n            return email;\n        }\n        int atIndex = email.indexOf(\"@\");\n        if (atIndex <= 1) {\n            return email;\n        }\n        return email.charAt(0) + \"***\" + email.substring(atIndex);\n    }\n}\n\n// 反例 - 日志输出敏感信息\nlogger.\n\ninfo(\"用户注册成功, phone={}, idCard={}\",phone, idCard);\n\n// 正例 - 日志脱敏\nlogger.\n\ninfo(\"用户注册成功, phone={}, idCard={}\",\n     DesensitizeUtils.maskPhone(phone), \n    DesensitizeUtils.\n\nmaskIdCard(idCard));\n```\n\n### 输入验证\n\n- 【强制】对所有外部输入进行严格验证和清洗\n- 【强制】防止 SQL 注入、XSS 等攻击\n- 【强制】敏感数据安全存储，不在日志中明文输出\n\n**示例：**\n\n```java\n// 正例 - 参数校验\npublic void createUser(@Valid CreateUserRequest request) {\n    // 使用 JSR-303 注解自动校验\n}\n\n// 正例 - 手动校验\npublic void updateUser(Long userId, String name) {\n    Objects.requireNonNull(userId, \"userId 不能为空\");\n    if (userId <= 0) {\n        throw new IllegalArgumentException(\"userId 必须大于 0\");\n    }\n    if (StringUtils.isBlank(name)) {\n        throw new IllegalArgumentException(\"name 不能为空\");\n    }\n    // 防止 XSS：对输入进行转义\n    name = HtmlUtils.htmlEscape(name);\n}\n```\n\n### 密码存储\n\n- 【强制】密码必须使用强哈希算法存储（如 BCrypt、Argon2）\n- 【强制】禁止明文存储密码\n- 【强制】禁止使用 MD5、SHA1 等弱哈希\n\n**示例：**\n\n```java\n// 正例 - 使用 BCrypt\n@Service\npublic class PasswordService {\n    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();\n\n    public String encryptPassword(String rawPassword) {\n        return encoder.encode(rawPassword);\n    }\n\n    public boolean matches(String rawPassword, String encodedPassword) {\n        return encoder.matches(rawPassword, encodedPassword);\n    }\n}\n\n// 反例 - 使用 MD5\nString password = DigestUtils.md5Hex(rawPassword);  // 不安全\n```\n\n### Web 安全防护\n\n- 【强制】表单和 AJAX 提交必须执行 **CSRF** 安全验证\n- 【强制】URL 外部重定向传入的目标地址必须执行**白名单过滤**\n- 【强制】关键业务（支付、下单、短信）必须实现**防重放**机制（如 nonce、token、验证码）\n\n**示例：**\n\n```java\n// 正例 - 重定向白名单校验\npublic void redirect(String url, HttpServletResponse response) throws IOException {\n    if (!isValidUrl(url)) {\n        throw new IllegalArgumentException(\"非法重定向地址\");\n    }\n    response.sendRedirect(url);\n}\n\nprivate boolean isValidUrl(String url) {\n    // 校验域名是否在白名单内\n    return DomainWhitelist.contains(extractDomain(url));\n}\n```\n\n### 空值处理\n\n```java\npublic void setName(String name) {\n    this.name = Objects.requireNonNull(name, \"name 不能为空\");\n}\n```\n\n- 【推荐】尽量避免返回 `null`\n- 【推荐】使用 `Optional<T>` 明确表达可能为空的返回值\n- 【强制】使用 `Objects.requireNonNull` 检查参数\n\n### 线程安全\n\n- 【推荐】优先设计无状态或不可变的类\n- 【强制】共享可变状态使用合适的并发控制：\n    - `synchronized`\n    - 显式锁\n    - `volatile`\n    - `java.util.concurrent` 原子类/线程安全集合\n- 【强制】避免竞态条件\n\n### 异常安全\n\n- 【强制】使用 try-with-resources 管理可关闭资源\n- 【强制】确保文件、网络连接等及时释放\n- 【强制】捕获异常时保证资源不泄露\n\n### 健壮原则\n\n- 【强制】对边界值和异常输入有明确处理逻辑\n- 【强制】永远不要假设数据正确无误\n- 【强制】做合理的错误检查\n\n---\n\n## 设计规约\n\n### 设计评审要求\n\n- 【强制】存储方案和底层数据结构设计需要获得评审一致通过\n- 【强制】设计评审必须沉淀为设计文档\n- 【推荐】评审内容包括：存储介质选型、表结构设计、存取性能评估、扩展性考虑\n\n### UML 建模规约\n\n- 【强制】业务对象状态超过 **3 个**，必须使用**状态图**表达，明确触发条件\n- 【强制】功能调用链路涉及对象超过 **3 个**，必须使用**时序图**表达\n- 【强制】模型类超过 **5 个**且存在复杂依赖关系，必须使用**类图**表达\n- 【强制】涉及 User 超过一类且 UseCase 超过 5 个，必须使用**用例图**\n\n**示例：**\n\n```mermaid\n// 状态图示例 (Mermaid)\nstateDiagram-v2\n    [*] --> PENDING\n    PENDING --> PAID : 支付成功\n    PENDING --> CLOSED : 超时未付\n    PAID --> SHIPPED : 发货\n    SHIPPED --> COMPLETED : 确认收货\n    CLOSED --> [*]\n    COMPLETED --> [*]\n```\n\n### 设计原则（SOLID）\n\n- 【推荐】单一职责原则（SRP）：一个类只负责一个职责\n- 【推荐】开闭原则（OCP）：对扩展开放，对修改关闭\n- 【推荐】里氏替换原则（LSP）：子类可以替换父类\n- 【推荐】接口隔离原则（ISP）：使用多个小接口而非一个大接口\n- 【推荐】依赖倒置原则（DIP）：依赖抽象而非具体实现\n\n**示例：**\n\n```java\n// 正例 - 单一职责\npublic class UserService {\n    public void createUser(User user) {\n    }\n\n    public User getUserById(Long id) {\n    }\n}\n\npublic class OrderService {\n    public void createOrder(Order order) {\n    }\n\n    public Order getOrderById(Long id) {\n    }\n}\n\n// 反例 - 一个类负责多个职责\npublic class UserService {\n    public void createUser(User user) {\n    }\n\n    public void createOrder(Order order) {\n    }\n\n    public void sendEmail(Email email) {\n    }\n}\n\n// 正例 - 依赖倒置（依赖接口）\npublic class OrderService {\n    private final PaymentService paymentService;  // 接口\n\n    public OrderService(PaymentService paymentService) {\n        this.paymentService = paymentService;\n    }\n}\n\n// 反例 - 依赖具体实现\npublic class OrderService {\n    private final AlipayServiceImpl paymentService;  // 具体实现\n}\n```\n\n### 设计模式使用\n\n- 【推荐】单例模式：确保线程安全（双重检查锁、静态内部类、枚举）\n- 【推荐】工厂模式：创建复杂对象\n- 【推荐】策略模式：消除大量 if-else\n- 【推荐】模板方法模式：定义算法骨架\n- 【推荐】代理模式：AOP、RPC\n\n**示例：**\n\n```java\n// 正例 - 策略模式消除 if-else\npublic interface PaymentStrategy {\n    void pay(PaymentRequest request);\n}\n\npublic class AlipayStrategy implements PaymentStrategy {\n    @Override\n    public void pay(PaymentRequest request) {\n        // 支付宝支付逻辑\n    }\n}\n\npublic class WechatPayStrategy implements PaymentStrategy {\n    @Override\n    public void pay(PaymentRequest request) {\n        // 微信支付逻辑\n    }\n}\n\n// 使用策略\npublic class PaymentService {\n    private final Map<String, PaymentStrategy> strategyMap;\n\n    public void pay(String paymentType, PaymentRequest request) {\n        PaymentStrategy strategy = strategyMap.get(paymentType);\n        strategy.pay(request);\n    }\n}\n\n// 反例 - 大量 if-else\npublic void pay(String paymentType, PaymentRequest request) {\n    if (\"alipay\".equals(paymentType)) {\n        // 支付宝支付逻辑\n    } else if (\"wechat\".equals(paymentType)) {\n        // 微信支付逻辑\n    } else if (\"unionpay\".equals(paymentType)) {\n        // 银联支付逻辑\n    }\n    // ...\n}\n```\n\n### 缓存设计规约\n\n- 【推荐】缓存数据需设置过期时间\n- 【推荐】缓存 Key 使用统一前缀，便于管理\n- 【推荐】缓存更新策略：先更新数据库，再删除缓存\n- 【推荐】缓存穿透：对不存在的 Key 也缓存空值\n- 【推荐】缓存雪崩：过期时间加随机值\n\n**示例：**\n\n```java\n// 正例 - 缓存 Key 统一前缀\npublic class CacheKeyConstants {\n    public static final String USER_PREFIX = \"user:\";\n    public static final String ORDER_PREFIX = \"order:\";\n\n    public static String userKey(Long userId) {\n        return USER_PREFIX + userId;\n    }\n}\n\n// 正例 - 先更新数据库，再删除缓存\npublic void updateUser(User user) {\n    userMapper.updateById(user);\n    redisTemplate.delete(CacheKeyConstants.userKey(user.getId()));\n}\n\n// 正例 - 缓存空值防止穿透\npublic User getUserById(Long userId) {\n    String key = CacheKeyConstants.userKey(userId);\n    User user = redisTemplate.opsForValue().get(key);\n    if (user != null) {\n        return user;\n    }\n\n    user = userMapper.selectById(userId);\n    if (user != null) {\n        redisTemplate.opsForValue().set(key, user, 30, TimeUnit.MINUTES);\n    } else {\n        // 缓存空值，防止穿透\n        redisTemplate.opsForValue().set(key, NULL_USER, 5, TimeUnit.MINUTES);\n    }\n    return user;\n}\n```\n\n### 接口设计规约\n\n- 【推荐】接口返回值不要包含业务逻辑判断的标识，使用 HTTP 状态码\n- 【推荐】接口幂等性：GET、PUT、DELETE 操作应保证幂等\n- 【推荐】避免接口过度设计，不要为了扩展而扩展\n\n**示例：**\n\n```java\n// 正例 - 使用 HTTP 状态码\n@DeleteMapping(\"/users/{id}\")\npublic ResponseEntity<Void> deleteUser(@PathVariable Long id) {\n    userService.deleteUser(id);\n    return ResponseEntity.noContent().build();  // 204 No Content\n}\n\n// 反例 - 返回值包含业务标识\n@DeleteMapping(\"/users/{id}\")\npublic ApiResponse<Boolean> deleteUser(@PathVariable Long id) {\n    boolean success = userService.deleteUser(id);\n    return ApiResponse.success(success);\n}\n```\n\n### 存储方案选型\n\n- 【推荐】MySQL：结构化数据、事务支持、复杂查询\n- 【推荐】Redis：缓存、分布式锁、计数器\n- 【推荐】MongoDB：非结构化数据、文档存储\n- 【推荐】Elasticsearch：全文搜索、日志分析\n\n---\n\n## AI 代码生成指引\n\n### 可读性与清晰性\n\n- 优先考虑代码清晰和可读性\n- 避免过度\"巧妙\"而晦涩难懂的写法\n- 代码要**自解释**，命名有描述性\n\n### 单一职责\n\n- 函数、方法和类职责单一（**SRP**）\n- 复杂功能拆分为多个小模块\n- 相关逻辑组织在一起\n\n### 避免重复与简单优先\n\n- 遵循 **DRY**（不要重复自己）\n- 保持代码简单直接（**KISS** 原则）\n- 不必追求过度抽象或极致优化\n\n### 可维护性和扩展性\n\n- 使用接口和抽象解耦模块\n- 便于未来扩展和单元测试\n- 避免紧耦合设计\n- 遵循 **SOLID** 设计原则\n\n### 错误处理与日志\n\n- 遵循异常处理规范\n- 生成有意义的错误信息\n- 避免吞掉异常\n- 必要时添加日志输出\n\n### 注释与文档\n\n- 加入适当注释和文档模板\n- 解释\"为什么\"选择该实现\n- 使用 TODO 注释标记待完成工作\n\n---\n\n## 使用示例\n\n调用本 skill 时可以指定具体规范类型：\n\n```\n请按照 Java 命名约定编写这个类\n检查这段代码的异常处理是否符合规范\n帮我写符合规范的 Javadoc 注释\n这个方法的命名符合 Java 规范吗\n```\n\n或直接描述需求，会自动应用相应规范。\n\n---\n\n## 代码规范示例参考\n\n- [Java 代码规范示例](references/examples.md)\n\n---\n\n## 规范级别说明\n\n本规范中使用以下级别标识：\n\n- **【强制】**：必须遵守，否则可能导致严重问题\n- **【推荐】**：建议遵守，提升代码质量和可维护性\n- **【参考】**：供参考的最佳实践，可根据实际情况调整\n",
        "plugins/global-java-code-style/skills/global-java-code-style/references/examples.md": "# 代码规范示例\n\n本文档提供代码规范的实际示例，作为 SKILL.md 的补充参考。\n\n## 1. 命名约定示例\n\n```java\n// 类名 - 大驼峰\npublic class UserService { }\npublic interface Serializable { }\n\n// 方法名 - 小驼峰\npublic void calculateTotal() { }\npublic String getUserName() { }\n\n// 变量名 - 小驼峰\nprivate int maxCount;\nprivate String userEmail;\n\n// 常量 - 全大写下划线\npublic static final int MAX_RETRY_COUNT = 3;\npublic static final String DEFAULT_TIMEOUT = \"30s\";\n\n// 包名 - 全小写\npackage com.example.project.service;\n```\n\n## 2. 代码格式示例\n\n### K&R 大括号风格\n\n```java\n// if-else\nif (condition) {\n    // 语句\n} else if (anotherCondition) {\n    // 语句\n} else {\n    // 语句\n}\n\n// for 循环\nfor (int i = 0; i < max; i++) {\n    // 语句\n}\n\n// while 循环\nwhile (condition) {\n    // 语句\n}\n\n// try-catch-finally\ntry {\n    // 可能抛出异常的代码\n} catch (IllegalArgumentException e) {\n    // 处理异常\n} finally {\n    // 清理资源\n}\n```\n\n### 空格使用\n\n```java\n// 关键字后的空格\nif (isValid) { }\nfor (int i = 0; i < 10; i++) { }\nwhile (running) { }\n\n// 运算符两侧的空格\nint result = a + b;\nboolean check = x > y && z < w;\n\n// 逗号后的空格\nmethod(a, b, c);\nint[] arr = {1, 2, 3};\n```\n\n### 类成员组织\n\n```java\npublic class Example {\n    // 1. 常量\n    public static final int CONSTANT = 100;\n\n    // 2. 静态字段\n    private static int staticField;\n\n    // 3. 实例字段\n    private String instanceField;\n\n\n    // 4. 构造方法\n    public Example() {\n    }\n\n    // 5. 静态方法\n    public static void staticMethod() {\n    }\n\n    // 6. 实例方法（重载方法放在一起）\n    public void process(String input) {\n    }\n\n    public void process(String input, int count) {\n    }\n\n    // 7. getter/setter\n    public String getInstanceField() {\n        return instanceField;\n    }\n}\n```\n\n## 3. Javadoc 注释示例\n\n```java\n/**\n * 用户服务类，负责用户相关的业务逻辑处理。\n *\n * <p>主要功能包括用户注册、登录、信息查询等。\n *\n * @author 张三\n * @version 1.0\n * @since 2024-01-01\n */\npublic class UserService {\n\n    /**\n     * 默认构造方法。\n     */\n    public UserService() {\n    }\n\n    /**\n     * 根据用户 ID 查询用户信息。\n     *\n     * @param userId 用户 ID，不能为 null\n     * @return 用户对象，如果不存在返回 null\n     * @throws IllegalArgumentException 如果 userId 为 null 或小于等于 0\n     */\n    public User findById(Long userId) {\n        if (userId == null || userId <= 0) {\n            throw new IllegalArgumentException(\"userId 不能为 null 或小于等于 0\");\n        }\n        // 实现逻辑\n        return null;\n    }\n\n    /**\n     * 验证用户登录凭证。\n     *\n     * @param username 用户名\n     * @param password 密码\n     * @return 验证成功返回 true，否则返回 false\n     */\n    public boolean authenticate(String username, String password) {\n        // 实现逻辑\n        return false;\n    }\n}\n```\n\n## 4. 异常处理示例\n\n### 正确的异常抛出\n\n```java\n// 快速失败 - 在方法开始时检查\npublic void processAmount(BigDecimal amount) {\n    Objects.requireNonNull(amount, \"amount 不能为 null\");\n\n    if (amount.compareTo(BigDecimal.ZERO) < 0) {\n        throw new IllegalArgumentException(\"金额不能为负数\");\n    }\n\n    // 业务逻辑\n}\n\n// 抛出具体异常类型\npublic void readFile(String path) throws IOException {\n    if (path == null || path.trim().isEmpty()) {\n        throw new IllegalArgumentException(\"文件路径不能为空\");\n    }\n\n    File file = new File(path);\n    if (!file.exists()) {\n        throw new FileNotFoundException(\"文件不存在: \" + path);\n    }\n\n    // 读取逻辑\n}\n```\n\n### 正确的异常捕获和日志记录\n\n```java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class PaymentService {\n    private static final Logger logger = LoggerFactory.getLogger(PaymentService.class);\n\n    /**\n     * 处理支付。\n     *\n     * @param request 支付请求\n     * @return 支付结果\n     * @throws PaymentException 支付失败时抛出\n     */\n    public PaymentResult processPayment(PaymentRequest request) throws PaymentException {\n        try {\n            // 支付处理逻辑\n            return doProcess(request);\n        } catch (InsufficientBalanceException e) {\n            logger.warn(\"支付失败: 账户余额不足, userId={}, amount={}\",\n                request.getUserId(), request.getAmount());\n            throw new PaymentException(\"账户余额不足\", e);\n        } catch (PaymentGatewayException e) {\n            logger.error(\"支付网关错误: userId={}, amount={}, error={}\",\n                request.getUserId(), request.getAmount(), e.getMessage(), e);\n            throw new PaymentException(\"支付服务暂时不可用，请稍后重试\", e);\n        }\n    }\n}\n```\n\n### 使用 try-with-resources\n\n```java\n// 正确的资源管理\npublic String readFileContent(String path) throws IOException {\n    StringBuilder content = new StringBuilder();\n\n    // try-with-resources 自动关闭资源\n    try (BufferedReader reader = new BufferedReader(new FileReader(path))) {\n        String line;\n        while ((line = reader.readLine()) != null) {\n            content.append(line).append(\"\\n\");\n        }\n    }\n\n    return content.toString();\n}\n\n// 多资源管理\npublic void copyFile(String source, String target) throws IOException {\n    try (InputStream in = new FileInputStream(source);\n         OutputStream out = new FileOutputStream(target)) {\n\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = in.read(buffer)) != -1) {\n            out.write(buffer, 0, bytesRead);\n        }\n    }\n}\n```\n\n## 5. 空值处理示例\n\n### 使用 Optional\n\n```java\nimport java.util.Optional;\n\npublic class UserRepository {\n\n    /**\n     * 根据邮箱查找用户。\n     *\n     * @param email 用户邮箱\n     * @return Optional 包含用户对象，如果不存在返回空 Optional\n     */\n    public Optional<User> findByEmail(String email) {\n        Objects.requireNonNull(email, \"email 不能为 null\");\n\n        User user = database.queryByEmail(email);\n        return Optional.ofNullable(user);\n    }\n\n    /**\n     * 获取用户显示名称。\n     *\n     * @param email 用户邮箱\n     * @return 显示名称，如果用户不存在返回 \"未知用户\"\n     */\n    public String getDisplayName(String email) {\n        return findByEmail(email)\n            .map(User::getNickname)\n            .orElse(\"未知用户\");\n    }\n}\n```\n\n### 参数校验\n\n```java\nimport java.util.Objects;\n\npublic class UserService {\n\n    public void updateUser(Long userId, String name, String email) {\n        // 参数校验\n        Objects.requireNonNull(userId, \"userId 不能为 null\");\n        Objects.requireNonNull(name, \"name 不能为 null\");\n\n        if (userId <= 0) {\n            throw new IllegalArgumentException(\"userId 必须大于 0\");\n        }\n\n        if (name.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"name 不能为空字符串\");\n        }\n\n        // 业务逻辑\n    }\n}\n```\n\n## 6. 测试规范示例\n\n```java\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.BeforeEach;\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n@DisplayName(\"UserService 单元测试\")\nclass UserServiceTest {\n\n    private UserService userService;\n    private UserRepository mockRepository;\n\n    @BeforeEach\n    void setUp() {\n        mockRepository = mock(UserRepository.class);\n        userService = new UserService(mockRepository);\n    }\n\n    @Test\n    @DisplayName(\"给定有效用户ID，当查询用户时，返回正确的用户对象\")\n    void givenValidUserId_whenFindById_thenReturnUser() {\n        // Given\n        Long userId = 1L;\n        User expectedUser = new User(userId, \"张三\");\n        when(mockRepository.findById(userId)).thenReturn(Optional.of(expectedUser));\n\n        // When\n        User actualUser = userService.getUserById(userId);\n\n        // Then\n        assertNotNull(actualUser);\n        assertEquals(\"张三\", actualUser.getName());\n        verify(mockRepository).findById(userId);\n    }\n\n    @Test\n    @DisplayName(\"给定无效用户ID，当查询用户时，抛出异常\")\n    void givenInvalidUserId_whenFindById_thenThrowException() {\n        // Given\n        Long userId = -1L;\n\n        // When & Then\n        assertThrows(IllegalArgumentException.class, () -> {\n            userService.getUserById(userId);\n        });\n    }\n\n    @Test\n    @DisplayName(\"给定用户不存在，当查询用户时，返回null\")\n    void givenNonExistentUserId_whenFindById_thenReturnNull() {\n        // Given\n        Long userId = 999L;\n        when(mockRepository.findById(userId)).thenReturn(Optional.empty());\n\n        // When\n        User result = userService.getUserById(userId);\n\n        // Then\n        assertNull(result);\n    }\n}\n```\n\n## 7. 线程安全示例\n\n### 不可变类（天然线程安全）\n\n```java\n/**\n * 不可变配置类，线程安全。\n */\npublic final class ImmutableConfig {\n    private final String host;\n    private final int port;\n    private final boolean enabled;\n\n    public ImmutableConfig(String host, int port, boolean enabled) {\n        this.host = Objects.requireNonNull(host, \"host 不能为 null\");\n        this.port = port;\n        this.enabled = enabled;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public boolean isEnabled() {\n        return enabled;\n    }\n\n    // 不提供 setter 方法\n}\n```\n\n### 线程安全的计数器\n\n```java\nimport java.util.concurrent.atomic.AtomicLong;\n\n/**\n * 线程安全的计数器。\n */\npublic class Counter {\n    private final AtomicLong count = new AtomicLong(0);\n\n    /**\n     * 增加计数。\n     *\n     * @return 增加后的值\n     */\n    public long increment() {\n        return count.incrementAndGet();\n    }\n\n    /**\n     * 获取当前计数。\n     *\n     * @return 当前值\n     */\n    public long get() {\n        return count.get();\n    }\n}\n```\n\n### 使用 synchronized 的示例\n\n```java\n/**\n * 简单的线程安全缓存。\n */\npublic class SimpleCache<K, V> {\n    private final Map<K, V> cache = new HashMap<>();\n\n    /**\n     * 获取缓存值。\n     */\n    public synchronized V get(K key) {\n        return cache.get(key);\n    }\n\n    /**\n     * 放入缓存。\n     */\n    public synchronized void put(K key, V value) {\n        cache.put(key, value);\n    }\n\n    /**\n     * 清空缓存。\n     */\n    public synchronized void clear() {\n        cache.clear();\n    }\n}\n```\n\n## 8. Maven 依赖管理示例\n\n### 在父 POM 中使用 BOM\n\n```xml\n<!-- 父 POM -->\n<dependencyManagement>\n    <dependencies>\n        <!-- Spring Boot BOM -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-dependencies</artifactId>\n            <version>3.2.0</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n\n        <!-- 其他统一版本的依赖 -->\n        <dependency>\n            <groupId>org.apache.commons</groupId>\n            <artifactId>commons-lang3</artifactId>\n            <version>3.14.0</version>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n\n### 在子模块中引入依赖（无需指定版本）\n\n```xml\n<!-- 子模块 POM -->\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n        <!-- 版本由父 POM 的 dependencyManagement 统一管理 -->\n    </dependency>\n\n    <dependency>\n        <groupId>org.apache.commons</groupId>\n        <artifactId>commons-lang3</artifactId>\n        <!-- 版本由父 POM 的 dependencyManagement 统一管理 -->\n    </dependency>\n</dependencies>\n```\n\n## 9. 输入验证示例\n\n```java\nimport java.util.regex.Pattern;\n\n/**\n * 邮箱验证工具类。\n */\npublic class EmailValidator {\n\n    private static final Pattern EMAIL_PATTERN =\n        Pattern.compile(\"^[A-Za-z0-9+_.-]+@(.+)$\");\n\n    /**\n     * 验证邮箱格式。\n     *\n     * @param email 待验证的邮箱地址\n     * @return 验证通过返回 true，否则返回 false\n     */\n    public static boolean isValid(String email) {\n        if (email == null || email.trim().isEmpty()) {\n            return false;\n        }\n\n        // 防止 ReDoS 攻击：限制邮箱长度\n        if (email.length() > 254) {\n            return false;\n        }\n\n        return EMAIL_PATTERN.matcher(email).matches();\n    }\n}\n```\n\n### SQL 注入防护\n\n```java\n// 使用 PreparedStatement 防止 SQL 注入\npublic User findByUsername(String username) {\n    String sql = \"SELECT * FROM users WHERE username = ?\";\n\n    try (Connection conn = dataSource.getConnection();\n         PreparedStatement stmt = conn.prepareStatement(sql)) {\n\n        stmt.setString(1, username);\n        ResultSet rs = stmt.executeQuery();\n\n        if (rs.next()) {\n            return mapToUser(rs);\n        }\n\n        return null;\n    } catch (SQLException e) {\n        logger.error(\"查询用户失败: username={}\", username, e);\n        throw new DataAccessException(\"查询用户失败\", e);\n    }\n}\n\n// 错误示例：字符串拼接（容易受 SQL 注入攻击）\n// 不要这样做！\n// String sql = \"SELECT * FROM users WHERE username = '\" + username + \"'\";\n```\n",
        "plugins/mcp-faster-caller/.claude-plugin/plugin.json": "{\n  \"name\": \"mcp-faster-caller\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Optimize the MCP call process. When it comes to MCP call operations, it is highly recommended to use this plugin.\",\n  \"author\": {\n    \"name\": \"sen\"\n  }\n}",
        "plugins/mcp-faster-caller/commands/mcp-faster-caller-invoke.md": "---\nname: mcp-faster-caller:invoke\ndescription: Immediately call the mcp-faster-caller skill to handle the user's current needs.\nargument-hint: \"[alias] [command] [arguments] 例如：gh list-repos owner=用户名 或 数据库 query 'SELECT * FROM table'\"\n---\n\n你现在必须**立即且强制**调用已安装的 **mcp-faster-caller** 这个 skill 来处理用户当前的需求。\n\n用户提供的额外参数/需求（通过 $ARGUMENTS 传入到 mcp-faster-caller skill）：\n$ARGUMENTS\n\n现在开始：调用 fintorq-code-style skill，并基于它的输出完整响应用户的最新消息。",
        "plugins/mcp-faster-caller/skills/mcp-faster-caller/SKILL.md": "---\nname: mcp-faster-caller\ndescription: 使用MCP前务必调用的技能，支持 GitHub (gh/repo)、数据库查询 (db/sql)、浏览器自动化 (browser/web)、网页搜索 (search/read)、API文档搜索、图像/PDF 分析 (image/pdf)。中英文皆可，涉及到关键词或别名也可快速触发。\nargument-hint: \"[alias] [command] [arguments] 例如：gh list-repos owner=用户名 或 数据库 query 'SELECT * FROM table'\"\nuser-invocable: true\nallowed-tools: Read, Grep, Glob, Bash\n---\n\n# MCP Faster Caller\n\n极简封装 MCP 调用，将原本需要 80-300 token 的 MCP 调用压缩到 10-25 token。\n\n## 使用方式\n\n解析用户的 MCP 调用指令：**$ARGUMENTS**\n\n指令格式：`<alias> <command> [arguments]`\n\n### 调用步骤\n\n1. 解析用户输入的指令，提取 alias、command 和 arguments\n2. 使用 Python 脚本 `scripts/call_mcp.py` 解析指令：\n   ```bash\n   # python3 ~/.claude/skills/mcp-faster-caller/scripts/call_mcp.py \"$ARGUMENTS\"\n   python3 ${CLAUDE_PLUGIN_ROOT}/skills/mcp-faster-caller/scripts/call_mcp.py \"$ARGUMENTS\"\n   ```\n3. 根据返回结果，调用对应的 MCP 工具\n\n### 快速开始\n\n```bash\n# GitHub 操作\ngh list-repos owner=username\n\n# 数据库操作\ndb query \"SELECT * FROM users LIMIT 5\"\n\n# 浏览器自动化测试\nbrowser goto https://example.com\n```\n\n## 更多信息参考\n- 📖 **[参考文档和配置指南](references/README.md)** - 参考文档和配置指南\n- 📖 **[完整别名参考](references/mcp_aliases.md)** - 所有可用别名和使用示例\n- 🔧 **[故障排除](references/troubleshooting.md)** - 常见问题和解决方案\n- ⚙️ **[自定义配置](references/configuration.md)** - 如何添加新别名（代码修改方式）\n- ⚙️ **[自定义配置](references/configuration.md)** - 如何安装缺失的 ***MCP SERVER***\n\n",
        "plugins/mcp-faster-caller/skills/mcp-faster-caller/references/README.md": "# MCP Faster Caller - 参考文档\n\n这个目录包含 MCP Faster Caller 技能的所有参考文档和配置指南。\n\n**版本**: v2.2\n\n## 📚 文档列表\n\n### [mcp_aliases.md](mcp_aliases.md)\n完整的 MCP 别名映射表和使用示例，涵盖所有支持的服务器类型：\n- GitHub 操作\n- 数据库查询\n- 浏览器自动化\n- 网页搜索和读取\n- 图像分析\n- API 文档查询\n\n### [troubleshooting.md](troubleshooting.md)\n故障排除指南，包含：\n- 常见问题及解决方案\n- 调试技巧\n- 性能优化建议\n- 获取帮助的途径\n\n### [configuration.md](configuration.md)\n自定义配置指南，包括：\n- 如何添加新别名\n- MCP Server 集成安装方法\n- 权限配置\n- 高级配置选项\n\n## 🚀 快速开始\n\n1. **查看可用别名**: 参考 [mcp_aliases.md](mcp_aliases.md)\n2. **使用技能**: 在 Claude Code 中输入 `/mcp-faster-caller alias command [args]`\n3. **遇到问题**: 查看 [troubleshooting.md](troubleshooting.md)\n4. **自定义配置**: 参考 [configuration.md](configuration.md)\n\n## 📖 使用示例\n\n```bash\n# GitHub 操作\n/mcp-faster-caller gh list-repos owner=username\n\n# 数据库查询\n/mcp-faster-caller db query \"SELECT * FROM users LIMIT 5\"\n\n# 浏览器自动化\n/mcp-faster-caller browser goto https://example.com\n```\n\n## 🔧 维护说明\n\n- `mcp_aliases.md`: 与 `scripts/call_mcp.py` 中的 `MCP_MAP` 保持同步\n- `configuration.md`: 更新以反映新的服务器集成\n- `troubleshooting.md`: 根据用户反馈添加常见问题\n\n## 📞 获取帮助\n\n如果文档中没有找到答案，请查看主目录的 `SKILL.md` 或在 Claude Code 中寻求帮助。\n",
        "plugins/mcp-faster-caller/skills/mcp-faster-caller/references/configuration.md": "# 自定义配置指南\n\n**版本**: v2.2\n\n## 添加新别名\n\n### 步骤\n\n1. **编辑 Python 映射字典**\n\n   打开 `scripts/call_mcp.py`，在 `MCP_MAP` 字典中添加新的映射：\n\n   ```python\n   MCP_MAP: Dict[str, str] = {\n       # ... 现有映射 ...\n       \"your-alias\": \"your-mcp-server-name\",\n       \"your-chinese-alias\": \"your-mcp-server-name\",  # 支持中文别名\n   }\n   ```\n\n2. **更新别名文档**\n\n   编辑 `references/mcp_aliases.md`，在对应分类中添加新行：\n\n   ```markdown\n   | your-alias | your-mcp-server-name | 描述命令 |\n   | your-chinese-alias | your-mcp-server-name | 描述命令 |\n   ```\n\n3. **重新加载 Skill**\n\n    - 方法一：在 Claude Code 中输入 `/reload`\n    - 方法二：重启 Claude Code\n\n### 命名规范\n\n- 使用小写字母\n- 多词别名用连字符分隔：`web-reader`\n- 保持简洁但具描述性\n- 考虑添加常用同义词作为额外别名\n- 支持中文别名，提供更好的本地化体验\n\n## MCP Server 集成\n\n### 常用 Server 类型\n\n| Server 类型   | 描述            | 配置要点                   |\n|-------------|---------------|------------------------|\n| GitHub      | GitHub API 集成 | 需要 GitHub Token        |\n| Database    | 数据库连接         | 需要连接字符串                |\n| Browser     | 浏览器自动化        | 需要 Playwright/Chromium |\n| Search      | 网页搜索          | 需要搜索 API 密钥            |\n| File System | 文件系统操作        | 本地文件权限                 |\n\n### MCP Server 配置示例\n\n#### GitHub Server\n\n```bash\nclaude mcp add --transport http github --scope user https://api.githubcopilot.com/mcp -H \"Authorization: Bearer YOUR_API_KEY\"\n```\n\n##### Github API_KEY获取\n\n- 从官网获取API_KEY: https://github.com/settings/personal-access-tokens/new\n\n#### MySQL Database\n\n```bash\nclaude mcp add mysql_blog_db \\\n-e MYSQL_HOST=\"$YOUR_MYSQL_HOST\" \\\n-e MYSQL_PORT=\"$YOUR_MYSQL_PORT\" \\\n-e MYSQL_USER=\"$YOUR_MYSQL_USER\" \\\n-e MYSQL_PASS=\"$YOUR_MYSQL_PASS\" \\\n-e MYSQL_DB=\"$DB_NAME\" \\\n-e MYSQL_ENABLE_LOGGING=\"true\" \\\n-e ALLOW_INSERT_OPERATION=\"false\" \\\n-e ALLOW_UPDATE_OPERATION=\"false\" \\\n-e ALLOW_DELETE_OPERATION=\"false\" \\\n-- node $(npm root -g)/@benborla29/mcp-server-mysql/dist/index.js\n```\n\n#### Chrome devtools MCP\n\n```bash\nclaude mcp add chrome-devtools -- npx chrome-devtools-mcp@latest\n```\n\n#### Playwright MCP\n\n```bash\nclaude mcp add playwright npx @playwright/mcp@latest\n```\n\n#### Context7 MCP\n\n```bash\nclaude mcp add context7 -- npx -y @upstash/context7-mcp --api-key YOUR_API_KEY\n```\n\n##### Context7 API Keys获取方式\n\n- 从官网获取API_KEY: https://context7.com/dashboard\n\n#### Pdf-reader MCP\n\n```bash\nclaude mcp add pdf-reader -- npx @sylphx/pdf-reader-mcp\n```\n\n#### Web-reader MCP\n\n```bash\nclaude mcp add -s user -t http web-reader https://open.bigmodel.cn/api/mcp/web_reader/mcp --header \"Authorization: Bearer your_api_key\"\n```\n\n##### 获取Web-search-prime API_KEY方式\n\n- 从官网获取API_KEY: https://bigmodel.cn/usercenter/proj-mgmt/apikeys\n\n#### Web-search-prime MCP\n\n```bash\nclaude mcp add -s user -t http web-search-prime https://open.bigmodel.cn/api/mcp/web_search_prime/mcp --header \"Authorization: Bearer your_api_key\"\n```\n\n##### 获取Zread API_KEY方式\n\n- 从官网获取API_KEY: https://bigmodel.cn/usercenter/proj-mgmt/apikeys\n\n#### Zai-mcp-server MCP\n\n```bash\nclaude mcp add -s user zai-mcp-server --env Z_AI_API_KEY=your_api_key -- npx -y \"@z_ai/mcp-server\"\n```\n\n##### 获取Zread API_KEY方式\n\n- 从官网获取API_KEY: https://bigmodel.cn/usercenter/proj-mgmt/apikeys\n\n#### Zread MCP\n\n```bash\nclaude mcp add -s user -t http zread https://open.bigmodel.cn/api/mcp/zread/mcp --header \"Authorization: Bearer your_api_key\"\n```\n\n##### 获取Zread API_KEY方式\n\n- 从官网获取API_KEY: https://bigmodel.cn/usercenter/proj-mgmt/apikeys\n\n## 权限配置\n\n### 技能权限\n\n编辑 `.claude/settings.local.json` 来控制技能的工具权限：\n\n```json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Bash(tree:*)\",\n      \"Bash(python3 scripts/call_mcp.py:*)\",\n      \"Bash(chmod:*)\"\n    ]\n  }\n}\n```\n\n### MCP Server 权限\n\n某些 MCP Server 可能需要额外的权限配置，请参考各 Server 的文档。\n\n## 环境变量配置\n\n可以通过环境变量自定义行为：\n\n- `MCP_FAST_CALLER_DEBUG=1`: 启用调试模式\n\n## 最佳实践\n\n1. **测试新别名**: 添加新别名后，先在命令行测试解析脚本\n2. **文档同步**: 确保 `MCP_MAP` 字典和文档始终同步\n3. **权限最小化**: 只授予必要的工具权限\n4. **错误处理**: 为新集成添加适当的错误处理\n5. **性能监控**: 监控 token 使用量和响应时间\n6. **双语支持**: 为重要功能同时提供中文和英文别名\n\n## 扩展开发\n\n### 添加新的 Server 类型\n\n1. 实现 Server 适配器\n2. 在 `MCP_MAP` 中注册别名\n3. 更新文档\n4. 添加测试用例\n\n### 自定义解析逻辑\n\n修改 `parse_mcp_call()` 函数来支持更复杂的指令格式。\n\n## 版本升级说明\n\n### v2.2 更新内容\n\n- **高性能优化**: 移除配置文件加载，提升启动速度\n- **双语别名映射**: 支持中英文双语别名，提供更好的用户体验\n- **代码化配置**: 通过直接修改 `MCP_MAP` 字典进行配置\n- **简化架构**: 移除不必要的文件系统操作\n\n### 从旧版本升级\n\n如果您之前使用过配置文件，请：\n\n1. 将配置文件中的别名手动添加到 `scripts/call_mcp.py` 的 `MCP_MAP` 字典中\n2. 更新相关文档\n3. 删除不再使用的配置文件\n",
        "plugins/mcp-faster-caller/skills/mcp-faster-caller/references/mcp_aliases.md": "# MCP 别名参考文档\n\n本文档提供完整的 MCP 别名映射表和使用说明，配合 `scripts/call_mcp.py` 中的 `MCP_MAP` 字典使用。\n\n**版本**: v2.2\n\n## 完整别名映射表\n\n### 代码仓库 (GitHub & 代码仓库)\n\n| 别名 | MCP Server | 典型命令 |\n|------|------------|----------|\n| `gh` | github | list-repos, search-code, prs, issues |\n| `github` | github | list-repos, search-code, prs, issues |\n| `gitlab` | zread | read_file, get_repo_structure |\n| `gitee` | zread | read_file, get_repo_structure |\n| `repo` | zread | read_file, get_repo_structure |\n| `repository` | zread | read_file, get_repo_structure |\n| `开源仓库` | zread | read_file, get_repo_structure |\n| `代码仓库` | zread | read_file, get_repo_structure |\n\n**示例：**\n```\ngh list-repos owner=username\ngh search-code query=\"function_name\" language=python\ngh prs state=open sort=updated\ngh issues labels=bug state=open\n```\n\n### 数据库 (Database)\n\n| 别名 | MCP Server | 典型命令 |\n|------|------------|----------|\n| `db` | mysql | query, execute, schema |\n| `database` | mysql | query, execute, schema |\n| `sql` | mysql | query, execute, schema |\n| `mysql` | mysql | query, execute, schema |\n| `查库` | mysql | query, execute, schema |\n| `查询数据库` | mysql | query, execute, schema |\n| `数据库` | mysql | query, execute, schema |\n\n**示例：**\n```\ndb query \"SELECT * FROM users LIMIT 10\"\ndb schema users\ndb execute \"CREATE TABLE test (id INT)\"\n```\n\n### 浏览器自动化 (Browser)\n\n| 别名 | MCP Server | 典型命令 |\n|------|------------|----------|\n| `browser` | playwright | goto, screenshot, click, type |\n| `web` | playwright | goto, screenshot, click, type |\n| `web page` | playwright | goto, screenshot, click, type |\n| `chrome` | chrome-devtools | navigate, screenshot, click |\n| `firefox` | playwright | goto, screenshot, click, type |\n| `edge` | playwright | goto, screenshot, click, type |\n| `safari` | playwright | goto, screenshot, click, type |\n| `浏览器` | playwright | goto, screenshot, click, type |\n| `浏览器测试` | playwright | goto, screenshot, click, type |\n| `谷歌浏览器` | chrome-devtools | navigate, screenshot, click |\n| `谷歌浏览器测试` | chrome-devtools | navigate, screenshot, click |\n\n**示例：**\n```\nbrowser goto https://example.com\nbrowser screenshot\nbrowser click #submit-btn\nbrowser type #search \"keyword\"\n```\n\n### 搜索工具 (Search)\n\n| 别名 | MCP Server | 典型命令 |\n|------|------------|----------|\n| `search` | web-search-prime | query (with num, location params) |\n| `搜索` | web-search-prime | query (with num, location params) |\n\n**示例：**\n```\nsearch \"latest AI news\" num=10\nsearch \"Claude Code docs\" location=us\n```\n\n### 网页读取 (Web Reader)\n\n| 别名 | MCP Server | 典型命令 |\n|------|------------|----------|\n| `read web` | web-reader | url (with timeout, format params) |\n| `web-reader` | web-reader | url (with timeout, format params) |\n| `web reader` | web-reader | url (with timeout, format params) |\n| `网页读取` | web-reader | url (with timeout, format params) |\n| `读取网页` | web-reader | url (with timeout, format params) |\n\n**示例：**\n```\nread web https://example.com timeout=30 return_format=markdown\nweb-reader https://docs.claude.com no_cache=true\n```\n\n### 图像分析 (Image Analysis)\n\n| 别名 | MCP Server | 典型命令 |\n|------|------------|----------|\n| `picture` | zai-mcp-server | analyze_image, ui_to_artifact |\n| `image` | zai-mcp-server | analyze_image, ui_to_artifact |\n| `photo` | zai-mcp-server | analyze_image, ui_to_artifact |\n| `illustration` | zai-mcp-server | analyze_image, ui_to_artifact |\n| `查看图片` | zai-mcp-server | analyze_image, ui_to_artifact |\n| `图片` | zai-mcp-server | analyze_image, ui_to_artifact |\n| `图像` | zai-mcp-server | analyze_image, ui_to_artifact |\n| `视觉` | zai-mcp-server | analyze_image, ui_to_artifact |\n\n**示例：**\n```\nimage analyze image_source=/path/to/image.png prompt=\"Describe this\"\npicture ui_to_artifact output_type=code\n```\n\n### API 文档 (API Documentation)\n\n| 别名 | MCP Server | 典型命令 |\n|------|------------|----------|\n| `API docs` | context7 | resolve-library-id, query-docs |\n| `API documentation` | context7 | resolve-library-id, query-docs |\n| `API` | context7 | resolve-library-id, query-docs |\n| `API文档` | context7 | resolve-library-id, query-docs |\n\n**示例：**\n```\nAPI docs react \"How to use useEffect\"\nAPI resolve-library-id \"express\"\n```\n\n### PDF 读取 (PDF Reader)\n\n| 别名 | MCP Server | 典型命令 |\n|------|------------|----------|\n| `pdf` | pdf-reader | read_pdf |\n| `pdf-reader` | pdf-reader | read_pdf |\n| `pdf reader` | pdf-reader | read_pdf |\n| `读取pdf` | pdf-reader | read_pdf |\n| `pdf读取` | pdf-reader | read_pdf |\n| `pdf解析` | pdf-reader | read_pdf |\n| `解析pdf` | pdf-reader | read_pdf |\n\n**示例：**\n```\npdf read_pdf sources=[{\"path\": \"/path/to/document.pdf\"}] include_full_text=true\npdf read_pdf sources=[{\"url\": \"https://example.com/document.pdf\", \"pages\": \"1-5\"}] include_images=true\n```\n\n## 添加新别名\n\n### 步骤\n\n1. **更新 Python 映射字典**\n\n   编辑 `scripts/call_mcp.py`，在 `MCP_MAP` 字典中添加：\n\n   ```python\n   MCP_MAP: Dict[str, str] = {\n       # ... 现有映射 ...\n       \"your-alias\": \"your-mcp-server-name\",\n   }\n   ```\n\n2. **更新本文档**\n\n   在上述表格对应分类中添加新行，或创建新的分类表格。\n\n3. **重新加载 Skill**\n\n   - 方式一：在 Claude Code 中输入 `/reload`\n   - 方式二：重启 Claude Code\n\n### 命名规范\n\n- 使用小写字母\n- 多词别名用连字符分隔：`web-reader`\n- 保持简洁但具描述性\n- 考虑添加常用同义词作为额外别名\n- 支持中文别名（v2.2+）\n\n## MCP Server 名称参考\n\n以下是一些常见的 MCP Server 名称，供配置时参考：\n\n| Server Name | 描述 |\n|-------------|------|\n| `github` | GitHub API |\n| `gitlab` | GitLab 集成 |\n| `gitee` | Gitee 集成 |\n| `mysql` | MySQL 数据库 |\n| `postgres` | PostgreSQL 数据库 |\n| `sqlite` | SQLite 数据库 |\n| `playwright` | 浏览器自动化 (Playwright) |\n| `chrome-devtools` | Chrome DevTools Protocol |\n| `web-search-prime` | 网页搜索 |\n| `web-reader` | 网页内容提取 |\n| `zai-mcp-server` | 图像/视频分析 |\n| `zread` | Git 仓库文件读取 |\n| `context7` | API 文档查询 |\n| `supabase` | Supabase 集成 |\n\n## 调试技巧\n\n### 测试别名解析\n\n```bash\n# 测试单个别名\npython3 ~/.claude/skills/mcp-faster-caller/scripts/call_mcp.py \"gh list-repos owner=username\"\n\n# 查看所有可用别名\npython3 -c \"import sys; sys.path.insert(0, '~/.claude/skills/mcp-faster-caller/scripts'); from call_mcp import MCP_MAP; print('\\\\n'.join(sorted(MCP_MAP.keys())))\"\n```\n\n### 验证 MCP Server 连接\n\n在 Claude Code 中运行：\n```\n/请问当前配置了哪些 MCP servers？\n```\n\n或检查 MCP 配置文件（通常在 `~/.claude/mcp_config.json` 或类似位置）。\n\n## 常见问题\n\n**Q: 为什么某个别名不工作？**\n\nA: 检查以下几点：\n1. 别名是否在 `MCP_MAP` 中定义\n2. 对应的 MCP Server 是否已安装并配置\n3. Server 名称是否拼写正确\n\n**Q: 如何查看某个 MCP Server 支持哪些命令？**\n\nA: 在 Claude Code 中询问：\n```\n/mcp-faster-caller [server-name] help\n```\n\n或查阅该 MCP Server 的官方文档。\n\n**Q: 可以使用中文别名吗？**\n\nA: 是的！v2.2 版本开始全面支持中文别名，为中文用户提供更好的体验。所有重要功能都提供了中英文双语映射。\n",
        "plugins/mcp-faster-caller/skills/mcp-faster-caller/references/troubleshooting.md": "# 故障排除指南\n\n## 常见问题\n\n### Skill 未触发\n**问题**: Skill 未被 Claude 调用或无法通过 `/mcp-faster-caller` 命令触发\n\n**解决方案**:\n- 确认路径：`~/.claude/skills/mcp-faster-caller/SKILL.md`\n- 检查文件权限和目录结构\n- 运行 `/reload` 重新加载技能\n- 重启 Claude Code\n\n### 脚本报错\n**问题**: 执行 Python 脚本时出现错误\n\n**解决方案**:\n- 检查 `python3` 是否可用: `python3 --version`\n- 确认脚本有执行权限: `chmod +x scripts/call_mcp.py`\n- 验证脚本路径是否正确\n\n### 未知 alias\n**问题**: 使用别名时提示\"未知 alias\"\n\n**解决方案**:\n- 查看 `MCP_MAP` 字典中的可用别名\n- 检查别名拼写是否正确（大小写敏感）\n- 添加新的别名映射（见[自定义配置](configuration.md)）\n\n### MCP Server 未配置\n**问题**: 提示找不到对应的 MCP Server\n\n**解决方案**:\n- 检查 MCP 配置文件（通常在 `~/.claude/mcp_config.json`）\n- 确认服务器已正确安装和配置\n- 验证服务器名称是否与 `MCP_MAP` 中的匹配\n\n## 调试方式\n\n### 测试别名解析\n```bash\n# 直接测试解析脚本\npython3 ~/.claude/skills/mcp-faster-caller/scripts/call_mcp.py \"gh list-repos owner=username\"\n\n# 查看所有可用别名\npython3 -c \"import sys; sys.path.insert(0, '~/.claude/skills/mcp-faster-caller/scripts'); from call_mcp import MCP_MAP; print('\\n'.join(sorted(MCP_MAP.keys())))\"\n```\n\n### 验证 MCP Server 连接\n在 Claude Code 中运行：\n```\n/mcp-faster-caller gh help\n```\n\n或检查 MCP 配置文件。\n\n### 日志查看\n如果仍有问题，可以查看 Claude Code 的日志输出获取更多调试信息。\n\n## 性能优化\n\n- **Token 节省**: 本技能将典型 MCP 调用从 80-300 token 压缩到 10-25 token\n- **响应速度**: 通过预解析减少 Claude 的推理时间\n- **内存使用**: 脚本轻量化，不占用过多资源\n\n## 获取帮助\n\n如果问题仍然存在：\n1. 提供完整的错误信息\n2. 说明使用的指令和期望结果\n3. 提及您的操作系统和 Python 版本"
      },
      "plugins": [
        {
          "name": "mcp-faster-caller",
          "source": "./plugins/mcp-faster-caller",
          "description": "Optimize the MCP call process. When it comes to MCP call operations, it is highly recommended to use this plugin.",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add sancodeee/sen-claude-hub",
            "/plugin install mcp-faster-caller@sen-claude-hub"
          ]
        },
        {
          "name": "global-java-code-style",
          "source": "./plugins/global-java-code-style",
          "description": "Provide standard guidelines for Java coding style, project structure, annotation specifications, exception handling, testing standards, etc.",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add sancodeee/sen-claude-hub",
            "/plugin install global-java-code-style@sen-claude-hub"
          ]
        },
        {
          "name": "fintorq-code-style",
          "source": "./plugins/fintorq-code-style",
          "description": "Official code style and development standards for Fintorq project. MUST be followed for all code generation.",
          "version": "1.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add sancodeee/sen-claude-hub",
            "/plugin install fintorq-code-style@sen-claude-hub"
          ]
        }
      ]
    }
  ]
}