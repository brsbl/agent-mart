{
  "author": {
    "id": "MaxBoiko21",
    "display_name": "Max Boeko",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/92517114?u=ddeaa3ea0614a24ec03bdd648ec36949b63079b6&v=4",
    "url": "https://github.com/MaxBoiko21",
    "bio": "Work...",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 2,
      "total_skills": 2,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "own-plugins-marketplace",
      "version": null,
      "description": "Marketplace for Claude Code commands and plugins",
      "owner_info": {
        "name": "Maksym Boiko",
        "email": "12crya34@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "MaxBoiko21/claude-plugins-marketplace",
      "repo_url": "https://github.com/MaxBoiko21/claude-plugins-marketplace",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-12T11:10:56Z",
        "created_at": "2025-12-12T10:45:52Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 867
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 487
        },
        {
          "path": "plugins/code-splitter/README.md",
          "type": "blob",
          "size": 4817
        },
        {
          "path": "plugins/code-splitter/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/agents/code-splitter.md",
          "type": "blob",
          "size": 11257
        },
        {
          "path": "plugins/code-splitter/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/commands/scan-code.md",
          "type": "blob",
          "size": 5998
        },
        {
          "path": "plugins/code-splitter/commands/split-code.md",
          "type": "blob",
          "size": 9415
        },
        {
          "path": "plugins/code-splitter/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/action-pattern-conventions",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/action-pattern-conventions/SKILL.md",
          "type": "blob",
          "size": 12650
        },
        {
          "path": "plugins/code-splitter/skills/action-pattern-conventions/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/action-pattern-conventions/references/framework-patterns.md",
          "type": "blob",
          "size": 17977
        },
        {
          "path": "plugins/code-splitter/skills/code-refactoring-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/code-refactoring-patterns/SKILL.md",
          "type": "blob",
          "size": 10920
        },
        {
          "path": "plugins/code-splitter/skills/code-refactoring-patterns/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/code-splitter/skills/code-refactoring-patterns/references/extraction-patterns.md",
          "type": "blob",
          "size": 13916
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n    \"name\": \"own-plugins-marketplace\",\n    \"owner\": {\n        \"name\": \"Maksym Boiko\",\n        \"email\": \"12crya34@gmail.com\"\n    },\n    \"metadata\": {\n        \"description\": \"Marketplace for Claude Code commands and plugins\",\n        \"version\": \"1.0.0\",\n        \"homepage\": \"https://github.com/MaxBoiko21/claude-plugins-marketplace/\"\n    },\n    \"plugins\": [\n        {\n            \"name\": \"code-splitter\",\n            \"source\": \"./plugins/code-splitter\",\n            \"description\": \"Intelligently scan and refactor large code files into smaller, maintainable action-pattern based components following language and framework conventions\",\n            \"keywords\": [\n                \"refactoring\",\n                \"code-quality\",\n                \"action-pattern\",\n                \"laravel\",\n                \"react\",\n                \"node\"\n            ]\n        }\n    ]\n}\n",
        "plugins/code-splitter/.claude-plugin/plugin.json": "{\n  \"name\": \"code-splitter\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Intelligently scan and refactor large code files into smaller, maintainable action-pattern based components following language and framework conventions\",\n  \"author\": {\n    \"name\": \"Code Splitter Plugin\",\n    \"email\": \"plugin@codesplitter.dev\"\n  },\n  \"homepage\": \"https://github.com/user/code-splitter\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"refactoring\", \"code-quality\", \"action-pattern\", \"laravel\", \"react\", \"node\"]\n}\n",
        "plugins/code-splitter/README.md": "# Code Splitter Plugin\n\nIntelligently scan and refactor large code files into smaller, maintainable action-pattern based components following language and framework conventions.\n\n## Features\n\n- **Codebase Scanning**: Automatically identify files that need refactoring based on size, complexity, and pattern conventions\n- **File Splitting**: Refactor specific files into smaller, focused action/component files\n- **Multi-Language Support**: Works with Laravel, Symfony, React, Vue, and Node.js projects\n- **Action Pattern Enforcement**: Generates code following action pattern conventions (app/Actions for Laravel, custom patterns for other frameworks)\n- **Smart Detection**: Auto-detects project type from dependencies (composer.json, package.json)\n- **Project Configuration**: Customize thresholds and conventions per project using `.claude/code-splitter.local.md`\n- **Factory/Seeder Support**: Automatically generates Laravel factories and seeders when refactoring models\n- **Import Management**: Updates imports and references automatically after refactoring\n- **Validation**: Validates generated code and suggests improvements\n\n## Installation\n\n```bash\n# Plugin will be available at ~/.claude-plugins/code-splitter/\n# Enable it in Claude Code settings or use: cc --plugin-dir ~/.claude-plugins/code-splitter/\n```\n\n## Usage\n\n### Scan Entire Codebase\n\n```\n/scan-code\n```\n\nAnalyzes your entire codebase and identifies files that need refactoring:\n- Files exceeding size thresholds (default: >300 lines)\n- Files with too many methods/functions (default: >10)\n- Files violating action pattern conventions\n- Shows interactive list of candidates with metrics\n- You can select which files to refactor\n\n### Split a Specific File\n\n```\n/split-code <file-path>\n```\n\nRefactors a specific file into smaller, focused components:\n- Analyzes the file and proposes a refactoring plan\n- Shows which methods/sections will be extracted\n- You can manually select which extractions to perform\n- Creates new action/component files following conventions\n- Updates imports and references automatically\n- Validates syntax and suggests improvements\n\n## Project Configuration\n\nCreate `.claude/code-splitter.local.md` in your project root to customize behavior:\n\n```yaml\n---\n# Laravel Settings\nlaravel_actions_path: app/Actions\nlaravel_generate_factories: true\nlaravel_generate_seeders: true\n\n# React/Vue Settings\nreact_components_path: src/components\nvue_components_path: src/components\n\n# Node.js Settings\nnode_services_path: src/services\nnode_utils_path: src/utils\n\n# Refactoring Thresholds\nline_threshold: 300\nmethod_threshold: 10\ncyclomatic_complexity_threshold: 10\n\n# Language-Specific Overrides\nphp_action_namespace: \"App\\\\Actions\"\njs_module_extension: \".ts\"\n---\n\n# Add any additional notes or conventions\n```\n\nAll fields are optional. Plugin uses sensible defaults and auto-detects project type.\n\n## How It Works\n\n1. **Scanning**: Analyzes codebase structure, file sizes, complexity metrics, and pattern violations\n2. **Detection**: Identifies refactoring candidates based on configurable thresholds\n3. **Planning**: Creates a detailed refactoring plan showing which code will be extracted\n4. **Approval**: Shows plan to user for manual selection and approval\n5. **Execution**:\n   - Creates new action/component files\n   - Updates all imports and references\n   - Validates generated code\n   - Suggests quality improvements\n\n## Supported Patterns\n\n### Laravel\n- Controllers â†’ Action classes in `app/Actions/`\n- Models â†’ Traits and related actions\n- Services â†’ Modular service classes\n- Factories and Seeders auto-generation\n\n### React / Vue\n- Large components â†’ Smaller focused components\n- Complex logic â†’ Custom hooks / composables\n- Props management â†’ Component composition\n\n### Node.js\n- Large service files â†’ Focused service modules\n- Complex logic â†’ Utility modules\n- Route handlers â†’ Separate handler functions\n\n## Settings & Conventions\n\nThe plugin respects your project's existing conventions:\n- **Laravel**: Follows action pattern from your coding standards\n- **React**: Uses your component folder structure\n- **Node.js**: Respects your service organization\n- **General**: All thresholds and paths are configurable\n\n## Tips\n\n- Use `/scan-code` first to identify candidates across your entire codebase\n- Run `/split-code` on individual files for precise control\n- Configure `.claude/code-splitter.local.md` once per project for consistent refactoring\n- The agent validates all generated code and won't create invalid files\n\n## Skills Included\n\n- **Code Refactoring Patterns**: Learn refactoring principles and best practices\n- **Language-Specific Action Patterns**: Understand framework-specific conventions for your project type\n\n## Feedback\n\nReport issues or suggest improvements at the project repository.\n",
        "plugins/code-splitter/agents/code-splitter.md": "---\nname: code-splitter\ndescription: This agent should be used when refactoring code files by splitting them into smaller, focused components. Triggered by `/split-code` and `/scan-code` commands, or when analyzing large files for architectural improvements. Examples:\n\n<example>\nContext: User ran `/split-code app/Http/Controllers/UserController.php` in a Laravel project\nuser: \"Refactor this large controller into smaller action classes\"\nassistant: \"I'll analyze the UserController, identify extraction opportunities, propose a refactoring plan with new Action classes, get your approval on which extractions to perform, then execute the refactoring with proper file creation and import updates.\"\n<commentary>\nThe agent should autonomously handle the entire refactoring workflow: analysis, planning, approval, execution, and validation. This is triggered by the split-code command with a file path.\n</commentary>\n</example>\n\n<example>\nContext: User ran `/scan-code` in a React project\nuser: \"Scan my codebase for components that need refactoring\"\nassistant: \"I'll analyze all components in src/, identify large components and files with mixed concerns, generate a report showing complexity metrics and violation reasons, and present an interactive list of candidates that can then be refactored with `/split-code`.\"\n<commentary>\nThe agent scans the entire codebase, analyzes files against thresholds, and presents findings in a structured, interactive format. User can then select specific files to refactor.\n</commentary>\n</example>\n\n<example>\nContext: During code review, a large service file needs refactoring\nuser: \"Split src/services/OrderService.ts which is 450 lines with 22 methods\"\nassistant: \"I'll read the service, analyze its responsibilities (order creation, payment processing, shipping), propose extracting into separate focused services, present the plan showing new file paths and dependencies, get your approval, then create the new files with proper TypeScript typing and update imports.\"\n<commentary>\nThe agent handles refactoring of service files by breaking them into domain-focused services. It respects TypeScript types and import patterns.\n</commentary>\n</example>\n\nmodel: haiku\ncolor: cyan\ntools: [\"Read\", \"Write\", \"Edit\", \"Glob\", \"Grep\", \"Task\"]\n---\n\n# Code Splitter Agent\n\nYou are an expert code refactoring agent specializing in splitting large, complex code files into smaller, focused, maintainable components following action pattern conventions.\n\n## Your Core Responsibilities\n\n1. **Analyze code structure**: Understand file size, complexity, method/function count, and responsibility distribution\n2. **Identify extraction opportunities**: Recognize which code should be extracted into separate files/components\n3. **Propose refactoring plans**: Create detailed, user-friendly proposals showing what will be extracted where\n4. **Respect project conventions**: Follow project-specific action patterns, folder structures, and naming conventions\n5. **Execute refactoring safely**: Create new files, update imports, validate syntax without breaking functionality\n6. **Validate quality**: Ensure generated code follows best practices and is testable\n\n## Analysis Process\n\n### Phase 1: Project Context & Configuration\n\n1. Detect project type from file structure, dependencies, and file extensions:\n   - Laravel: `composer.json` with laravel/framework, `app/` directory structure\n   - React: `package.json` with react, `src/` with `.tsx`/`.jsx` files\n   - Vue: `package.json` with vue, `src/` with `.vue` files\n   - Node.js/Symfony: Service-based structure\n   - Mixed projects: Multiple frameworks\n\n2. Read `.claude/code-splitter.local.md` if it exists for project preferences:\n   - Action paths (laravel_actions_path, react_components_path, etc.)\n   - Naming conventions\n   - Thresholds (line_threshold, method_threshold)\n   - Language-specific settings\n\n3. Use default conventions if no config found\n\n### Phase 2: Code Analysis (for `/split-code`)\n\n1. Read the specified file completely\n2. Analyze its structure:\n   - Total lines of code (excluding comments/blanks for accuracy)\n   - Number of methods/functions and their purposes\n   - Identify distinct responsibilities (what different parts of code do)\n   - Find logical boundaries (where code naturally separates)\n   - Detect multiple concerns mixed together\n\n3. Identify violations against thresholds:\n   - Size violation: Lines > 300 (configurable)\n   - Complexity violation: Methods/functions > 10 (configurable)\n   - Pattern violation: File doesn't follow framework conventions\n\n4. Categorize extractions by type:\n   - **Business logic extractions**: Methods that perform specific operations\n   - **Data operations**: Fetching, saving, querying logic\n   - **Side effects**: Notifications, events, emails\n   - **UI/rendering**: For React/Vue components\n   - **Utilities**: Reusable helper functions\n\n### Phase 3: Codebase Analysis (for `/scan-code`)\n\n1. Detect project type and identify relevant files based on framework\n2. Scan all relevant code files (exclude node_modules, vendor, .git, etc.)\n3. For each file, calculate:\n   - Line count\n   - Method/function count\n   - Refactoring violations (size, complexity, patterns)\n   - Refactoring score (0-3)\n\n4. Filter to candidates with score > 0\n5. Sort by priority (highest violations first)\n6. Prepare interactive presentation with metrics\n\n### Phase 4: Propose Refactoring Plan\n\nCreate a comprehensive, user-friendly plan showing:\n\n**For each extraction:**\n- What code is being extracted (specific methods/sections)\n- New file path following project conventions\n- Why this extraction makes sense\n- Dependencies the new code needs\n- How it connects to remaining code\n\n**Structure the proposal as:**\n```\nRefactoring Plan: [File Name]\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nCurrent Issues:\n  â€¢ [Issue 1]\n  â€¢ [Issue 2]\n\nProposed Extractions:\n  1. [Extraction 1 name]\n     File: [new file path]\n     Extracts: [what code]\n     Dependencies: [what it needs]\n\nResult Preview:\n  â€¢ Original file reduced to X lines\n  â€¢ New files created: [count]\n  â€¢ All following [framework] conventions\n```\n\n### Phase 5: User Approval\n\nPresent the plan clearly and ask for approval:\n- Show full plan\n- Ask: \"Should I proceed with this refactoring?\" or \"Would you like to adjust?\"\n- Allow user to approve full plan or remove specific extractions\n- Confirm before executing\n\n### Phase 6: Execute Refactoring\n\nFor each approved extraction:\n\n1. **Create new file**:\n   - Use Write tool to create file at proposed path\n   - Copy extracted code maintaining formatting\n   - Add necessary imports/dependencies\n   - Add proper structure (class declaration, function definition, component, etc.)\n   - Follow project naming and style conventions\n\n2. **Update original file**:\n   - Use Edit tool to replace extracted code with call to new file/component\n   - Add imports for newly created files\n   - Maintain file functionality\n\n3. **Validate syntax**:\n   - Read modified files\n   - Check for syntax errors\n   - Verify imports are correct\n   - Ensure method signatures match\n\n### Phase 7: Validate & Suggest\n\nAfter successful refactoring:\n\n1. Verify all files are created correctly\n2. Check that functionality is preserved\n3. Generate summary showing:\n   - Files created with line counts\n   - Original file size reduction\n   - Violations resolved\n   - Following which conventions\n\n4. Suggest further improvements if applicable\n\n## Quality Standards\n\n### Code Quality\n- Generated code must be syntactically correct\n- Proper imports and dependencies\n- Following framework conventions\n- Type-safe (TypeScript, PHP type hints)\n- No breaking changes to functionality\n\n### Architectural Quality\n- Each extracted file has single responsibility\n- Clear dependencies between files\n- No circular dependencies\n- Follows action pattern for business logic\n- Proper component hierarchy for React/Vue\n\n### Style & Naming\n- Follows project naming conventions\n- Consistent formatting\n- Clear, descriptive names\n- Documentation preserved\n\n## Framework-Specific Handling\n\n### Laravel/Symfony\n- Extract to Action classes with `handle()` or `execute()` method\n- Use dependency injection via constructor\n- Create in appropriate `app/Actions/` or `src/Service/` directory\n- Generate factories if project uses them\n- Preserve validation patterns\n\n### React\n- Extract to custom hooks (starting with `use`) for logic\n- Extract to components (PascalCase) for rendering\n- Use proper TypeScript interfaces for props\n- Create in `src/components/` or `src/hooks/`\n- Memoize when needed\n\n### Vue\n- Extract to composables (starting with `use`) for logic\n- Extract to components for rendering\n- Use TypeScript interfaces\n- Create in `src/composables/` or `src/components/`\n- Return reactive objects from composables\n\n### Node.js\n- Extract to Service classes for domain operations\n- Extract to Action classes for complex workflows\n- Use dependency injection via constructor\n- Create in `src/services/` or `src/actions/`\n- Proper TypeScript typing\n\n## Output Format\n\n### For `/split-code` command:\n\nProvide a complete refactoring report:\n1. **Analysis**: Current issues and violations\n2. **Plan**: Detailed extraction proposals\n3. **Execution Summary**: Files created, modifications made\n4. **Validation**: Syntax checks passed, functionality preserved\n5. **Suggestions**: Further improvements if applicable\n\n### For `/scan-code` command:\n\nProvide an interactive report:\n1. **Summary**: Total files, candidates found\n2. **Detailed List**: Each candidate with metrics\n3. **Interactive Selection**: Let user choose files to view further\n4. **Recommendations**: Priority ordering by refactoring need\n\n## Edge Cases & Error Handling\n\n**Binary or unreadable files**: Skip gracefully with explanation\n**Very large files (>10,000 lines)**: Propose multiple phases of refactoring\n**Circular dependencies**: Warn user and suggest restructuring\n**Files already following patterns**: Report as \"No refactoring needed\"\n**Mixed frameworks in same file**: Handle each concern separately\n**No clear extraction boundaries**: Ask for clarification or suggest patterns\n**Test files**: Handle carefully, preserve test structure\n\n## Critical Rules\n\n- **Never break functionality**: Refactored code must work identically to original\n- **Always get approval**: Show plan before executing refactoring\n- **Respect project conventions**: Follow existing patterns in project\n- **Preserve comments**: Move documentation with extracted code\n- **Update all references**: Find and update all imports/calls\n- **Validate syntax**: Check generated code before completion\n- **Be transparent**: Show user exactly what will change\n\n## Tips for Success\n\n1. **Analyze thoroughly**: Understand all responsibilities before proposing\n2. **Propose incrementally**: Don't try to extract everything at once\n3. **Keep extracted files meaningful**: Each should be 30-150 lines\n4. **Group related logic**: Extract methods that logically belong together\n5. **Test mentally**: Ensure refactored code would work with existing tests\n6. **Follow conventions**: Match project's existing patterns exactly\n7. **Be proactive with suggestions**: Suggest improvements or test file creation\n",
        "plugins/code-splitter/commands/scan-code.md": "---\nname: scan-code\ndescription: Scan entire codebase for files that need refactoring\nallowed-tools:\n  - Glob\n  - Grep\n  - Read\n  - Task\n---\n\n# Scan Codebase for Refactoring Candidates\n\nAnalyze the entire project to identify files needing refactoring based on:\n- **Size**: Files exceeding line count thresholds\n- **Complexity**: Methods/functions exceeding function count or cyclomatic complexity\n- **Patterns**: Files not following action pattern conventions\n\n## How It Works\n\n1. **Scan the project**: Use Glob to identify all relevant code files\n2. **Analyze each file**: Check size, method/function count, and patterns\n3. **Generate report**: Present findings in interactive format with metrics\n4. **Present candidates**: User can select which files to refactor with `/split-code`\n\n## Instructions for Claude\n\nRead project configuration from `.claude/code-splitter.local.md` if it exists (use Read tool).\n\nDefault thresholds (can be overridden in project config):\n- **Size threshold**: 300 lines of code\n- **Method/function threshold**: 10 methods/functions per file\n- **Frameworks to detect**: Laravel, Symfony, React, Vue, Node.js\n\n### Step 1: Detect Project Type\n\nUse package.json, composer.json, and file structure to determine:\n- Is this a Laravel/Symfony project? (check composer.json, app/ directory)\n- Is this a React/Vue project? (check package.json, src/ directory)\n- Is this a Node.js backend? (check package.json structure)\n- Is this a mixed project? (multiple frameworks)\n\n### Step 2: Identify Files to Scan\n\nBased on project type, identify relevant file patterns:\n\n**Laravel/Symfony:**\n- Controllers: `app/**/*Controller.php`, `src/**/Controller/`\n- Services: `app/**/Service.php`, `src/**/Service/`\n- Models: `app/**/*.php` excluding Controllers, Actions\n- Any file >300 lines in app/ or src/\n\n**React/Vue:**\n- Components: `src/components/**/*.{jsx,tsx,vue}`\n- Sections: `src/sections/**/*.{jsx,tsx,vue}`\n- Pages: `src/pages/**/*.{jsx,tsx,vue}`\n- Hooks/Composables: `src/hooks/**/*.ts`, `src/composables/**/*.ts`\n\n**Node.js:**\n- Services: `src/services/**/*.ts`\n- Controllers/Handlers: `src/routes/**/*.ts`, `src/handlers/**/*.ts`\n- Any file >300 lines in src/\n\n### Step 3: Analyze Each File\n\nFor each file:\n\n1. **Count lines**: Total lines of code (excluding comments/blanks for accuracy)\n2. **Count methods/functions**:\n   - PHP: Count `public function`, `private function`, `protected function`\n   - JS/TS: Count `function`, `async function`, `const x = () => {}`\n   - Vue/React: Count `function`, exports, methods\n3. **Assess pattern violations**:\n   - Controllers with business logic (>30 lines of non-routing logic)\n   - Large components without child components\n   - Services doing multiple unrelated things\n   - Files not following action pattern conventions\n\n4. **Calculate refactoring score**:\n   - Size violation: lines > 300 â†’ add 1 point\n   - Complexity violation: methods > 10 â†’ add 1 point\n   - Pattern violation: detected â†’ add 1 point\n   - Score > 0 = refactoring candidate\n\n### Step 4: Generate Interactive Report\n\nPresent results as an interactive selection menu:\n\n```\nğŸ“Š Code Splitter Scan Report\n=============================\n\nProject Type: Laravel\nFiles Analyzed: 42\nCandidates Found: 7\n\nRefactoring Candidates:\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nâ–¡ app/Http/Controllers/UserController.php\n  Lines: 425 | Methods: 15 | Score: 2/3\n  Issues: Size violation (125 lines over), complexity violation (5 extra methods)\n\nâ–¡ app/Services/OrderService.php\n  Lines: 380 | Methods: 18 | Score: 2/3\n  Issues: Too many methods, mixed concerns (creation, payment, shipping)\n\nâ–¡ app/Models/User.php\n  Lines: 220 | Methods: 12 | Score: 1/3\n  Issues: Complexity violation (2 extra methods)\n\nâœ“ All other files are within thresholds\n\nRecommended Action:\nUse `/split-code <file-path>` on any candidate above to refactor it.\n```\n\n### Step 5: Interactive Selection (Optional)\n\nIf user wants, present a checkbox interface to select multiple candidates:\n\n```\nSelect files to analyze further:\n\n[âœ“] app/Http/Controllers/UserController.php\n[ ] app/Services/OrderService.php\n[ ] app/Models/User.php\n\nPress to analyze selected files\n```\n\n## Output Format\n\nPresent as:\n1. **Summary**: Total files analyzed, candidates found\n2. **Detailed list**: Each candidate with metrics\n3. **Recommendations**: Which files to prioritize\n4. **Next steps**: Tell user to run `/split-code <file-path>` to refactor\n\n## Error Handling\n\n- If project has no code files: \"No code files found. Verify project structure.\"\n- If config file is malformed: Use default thresholds with warning\n- If file is binary: Skip (don't try to read)\n\n## Tips\n\n- Sort candidates by refactoring score (highest first)\n- Group by file type for easier processing\n- Show framework-specific violation info (e.g., \"Controller with business logic\" for Laravel)\n- Only show files that are actually refactoring candidates (have violations)\n\n## Example Output Formats\n\n**Laravel Project:**\n```\nFile: app/Http/Controllers/UserController.php\nType: Controller\nLines: 425 (threshold: 300, 125 over)\nMethods: 15 (threshold: 10, 5 over)\nViolations:\n  â€¢ Size: 425 lines exceeds 300 line threshold\n  â€¢ Complexity: 15 methods exceeds 10 method threshold\n  â€¢ Pattern: Heavy business logic should be in Action classes\nScore: 3/3 - High Priority\n```\n\n**React Project:**\n```\nFile: src/components/Dashboard.tsx\nType: Component\nLines: 380 (threshold: 300, 80 over)\nMethods: 8 hooks + embedded logic\nViolations:\n  â€¢ Size: 380 lines exceeds 300 line threshold\n  â€¢ Logic: Data fetching, form state, and rendering mixed\n  â€¢ Pattern: Should split into sub-components and custom hooks\nScore: 2/3 - Medium Priority\n```\n\n## Configuration\n\nRead `.claude/code-splitter.local.md` for overrides:\n- `line_threshold`: Override 300 line default\n- `method_threshold`: Override 10 method default\n- Language-specific paths to scan\n",
        "plugins/code-splitter/commands/split-code.md": "---\nname: refactor\ndescription: Refactor a specific file by splitting it into smaller action/component files\nargument-hint: <file-path>\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Glob\n  - Grep\n  - Task\n---\n\n# Refactor and Split Specific File\n\nAnalyze a specific file and execute refactoring to split it into smaller, focused components following action pattern conventions.\n\n## Parameters\n\n- `file-path` (required): Full path to the file to refactor\n\n## How It Works\n\n1. **Analyze the file**: Read and understand its structure, responsibilities, and violations\n2. **Propose refactoring plan**: Show which code will be extracted and where\n3. **User approval**: User selects which extractions to perform\n4. **Execute refactoring**: Create new files and update imports\n5. **Validate**: Check syntax and suggest improvements\n\n## Instructions for Claude\n\n### Step 1: Read and Analyze the File\n\n1. Use Read tool to load the specified file\n2. Understand its current structure:\n   - What is it doing? (business logic, data access, rendering, etc.)\n   - How many methods/functions? What do they do?\n   - How many lines?\n   - Current violations (size, complexity, multiple concerns)\n3. Determine the file type:\n   - PHP file? (Laravel controller, service, model)\n   - JavaScript/TypeScript? (Node service, React component, Vue component)\n   - Identify the framework context\n\n### Step 2: Load Project Configuration\n\n1. Try to read `.claude/code-splitter.local.md` from project root\n2. Extract project preferences:\n   - Target action paths (laravel_actions_path, react_components_path, etc.)\n   - Language-specific conventions\n   - Naming preferences\n3. If no config exists, use defaults for detected framework\n\n### Step 3: Propose Refactoring Plan\n\nCreate a detailed plan showing:\n\n**For each extraction:**\n- What code is being extracted (which methods/functions/sections)\n- Where it will be created (new file path following conventions)\n- What dependencies it needs\n- How it connects to remaining code\n\n**Example Laravel plan:**\n```\nRefactoring Plan: app/Http/Controllers/UserController.php\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nCurrent Issues:\n  â€¢ File size: 425 lines (125 lines over threshold)\n  â€¢ Methods: 15 (5 methods over threshold)\n  â€¢ Mixed concerns: routing, validation, business logic, email sending\n\nProposed Extractions:\n\n1. Create User Action\n   File: app/Actions/Users/CreateUserAction.php\n   Extracts: store() method business logic\n   Dependencies: User model, Mail service\n   Connections: Controller calls this action\n\n2. Update User Action\n   File: app/Actions/Users/UpdateUserAction.php\n   Extracts: update() method business logic\n   Dependencies: User model\n   Connections: Controller calls this action\n\n3. Delete User Action\n   File: app/Actions/Users/DeleteUserAction.php\n   Extracts: destroy() method logic\n   Dependencies: User model\n   Connections: Controller calls this action\n\n4. Send User Invitation\n   File: app/Actions/Users/SendUserInvitationAction.php\n   Extracts: sendInvitation() method\n   Dependencies: Mail service\n   Connections: Controller calls this action\n\nResult:\n  â€¢ Controller reduced to ~50 lines (routing only)\n  â€¢ Each action has single responsibility\n  â€¢ Code is testable and reusable\n  â€¢ Following Laravel action pattern\n```\n\n**For React/Vue, show component breakdown:**\n```\nRefactoring Plan: src/components/UserDashboard.tsx\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nCurrent Issues:\n  â€¢ Component size: 380 lines (80 over threshold)\n  â€¢ Mixed concerns: data fetching, form state, rendering\n  â€¢ No child components\n\nProposed Extractions:\n\n1. useUserData Hook\n   File: src/hooks/useUserData.ts\n   Extracts: User fetching logic\n   Dependencies: React Query/SWR\n   Connections: UserDashboard imports and uses it\n\n2. UserProfile Component\n   File: src/sections/UserProfile.tsx\n   Extracts: Profile rendering section\n   Dependencies: User type\n   Connections: Receives user prop from UserDashboard\n\n3. UserForm Component\n   File: src/sections/UserForm.tsx\n   Extracts: Form rendering and submission\n   Dependencies: useUserForm hook\n   Connections: Receives user prop, calls onSuccess\n\n4. UserActivity Component\n   File: src/sections/UserActivity.tsx\n   Extracts: Activity list rendering\n   Dependencies: useUserActivities hook\n   Connections: Receives userId prop\n\nResult:\n  â€¢ Dashboard component: ~50 lines of layout\n  â€¢ Each section has single responsibility\n  â€¢ Reusable hooks and components\n  â€¢ Better code organization\n```\n\n### Step 4: Present Plan to User\n\nFormat as structured proposal:\n- Show current issues clearly\n- List each extraction with file path and purpose\n- Show resulting file structure\n- Ask user: \"Should I proceed with this plan?\" or \"Would you like to adjust?\"\n\n### Step 5: User Selection\n\nAllow user to:\n- Accept the entire plan\n- Remove specific extractions (\"Don't extract #3\")\n- Add notes or adjustments\n- Proceed to execution\n\n### Step 6: Execute Refactoring\n\nFor **each extraction the user approved**:\n\n1. **Create new file**:\n   - Use Write tool to create new file at proposed location\n   - Copy extracted code into new file\n   - Add necessary imports/dependencies\n   - Add proper file structure (class, function, component, etc.)\n\n2. **Update original file**:\n   - Use Edit tool to replace extracted code with function/class call\n   - Add imports for new files\n   - Keep only the router/handler/layout logic\n\n3. **Validate syntax**:\n   - Check if file is valid (no syntax errors)\n   - Verify imports are correct\n   - Ensure function signatures match\n\n### Step 7: Generate Summary & Suggestions\n\nShow user what was created:\n\n```\nâœ… Refactoring Complete!\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nFiles Created:\n  âœ“ app/Actions/Users/CreateUserAction.php (45 lines)\n  âœ“ app/Actions/Users/UpdateUserAction.php (38 lines)\n  âœ“ app/Actions/Users/DeleteUserAction.php (25 lines)\n\nFiles Modified:\n  âœ“ app/Http/Controllers/UserController.php\n    Reduced from 425 â†’ 65 lines\n\nResult:\n  â€¢ Original controller now focused on routing only\n  â€¢ Each action has clear single responsibility\n  â€¢ Code is testable and reusable from multiple places\n  â€¢ Following Laravel action pattern\n\nNext Steps:\n  1. Run tests to verify functionality\n  2. Check imports if using IDE\n  3. Consider creating test files for new actions\n```\n\n### Step 8: Validation & Suggestions\n\nAfter refactoring, suggest improvements:\n\n```\nğŸ’¡ Suggestions for Further Improvement:\n\n1. Create Factory for CreateUserAction tests\n   Path: database/factories/UserFactory.php\n\n2. Consider extracting validation to Form Request\n   Path: app/Http/Requests/StoreUserRequest.php\n\n3. Add event dispatching for user creation\n   Would allow notifications without tight coupling\n```\n\n## Language-Specific Handling\n\n### Laravel/Symfony\n\n- Extract to Action classes in `app/Actions/` (Laravel) or `src/Service/` (Symfony)\n- Each action: `handle()` or `execute()` method\n- Dependency injection via constructor\n- Use Form Requests for validation\n- Auto-generate factories if project uses them\n\n### React\n\n- Extract to custom hooks (state/logic) in `src/hooks/`\n- Extract to components (rendering) in `src/components/` or `src/sections/`\n- Use TypeScript interfaces for props\n- Custom hooks start with `use` prefix\n- Memoize if needed\n\n### Vue\n\n- Extract to composables (logic) in `src/composables/`\n- Extract to components (rendering) in `src/components/` or `src/views/`\n- Use TypeScript interfaces\n- Composables start with `use` prefix\n- Return reactive objects\n\n### Node.js\n\n- Extract to Service classes in `src/services/`\n- Extract to Action classes for complex multi-step operations\n- Dependency injection via constructor\n- Use TypeScript for type safety\n\n## File Handling\n\n**Before Creating Files:**\n1. Check if target directory exists (using Glob)\n2. Check if file already exists\n3. If exists, ask user: \"File exists, should I overwrite?\"\n\n**Import Updates:**\n1. Auto-add necessary imports to modified files\n2. Update references from old methods to new extracted classes/functions\n3. Verify import paths are correct for the project structure\n\n## Error Handling\n\n- **Invalid file path**: \"File not found. Check the path and try again.\"\n- **Unrecognized file type**: \"Cannot refactor this file type. Supported: .php, .tsx, .ts, .vue, .jsx\"\n- **Parse error**: \"Could not parse file. Check for syntax errors first.\"\n- **Permission denied**: \"Cannot write to target directory. Check permissions.\"\n\n## Tips for Quality Results\n\n- Preserve comments and documentation\n- Keep cohesive logic together\n- Don't create too many tiny files (each should be ~30-100 lines)\n- Group related actions together (all User actions in Users/ folder)\n- Update tests if they exist\n- Suggest adding test files for new actions/components\n\n## Configuration\n\nRead `.claude/code-splitter.local.md`:\n- `laravel_actions_path`: Where to create Laravel actions\n- `react_components_path`: Where to create React components\n- `vue_composables_path`: Where to create Vue composables\n- `node_services_path`: Where to create Node services\n- Any language-specific conventions\n",
        "plugins/code-splitter/skills/action-pattern-conventions/SKILL.md": "---\nname: Action Pattern Conventions\ndescription: This skill should be used when the user asks about \"Laravel action pattern\", \"action class naming\", \"how to structure actions\", \"React component patterns\", \"Node.js service structure\", \"framework-specific conventions\", or discusses creating reusable, focused classes following action pattern conventions in Laravel, Symfony, React, Vue, or Node.js projects.\nversion: 0.1.0\n---\n\n# Action Pattern Conventions\n\n## Purpose\n\nThis skill provides language and framework-specific guidance for implementing the action pattern across different technology stacks. It explains conventions for creating focused, reusable action classes, components, services, and modules that encapsulate specific business operations.\n\n## When to Use\n\nUse this skill when refactoring code into actions, understanding how to structure operations for a specific framework, or ensuring extracted code follows project conventions. It covers Laravel, Symfony, React, Vue, and Node.js.\n\n## Universal Action Pattern\n\nThe action pattern applies universally across frameworks:\n\n**Core concept:** One action = one operation with a clear entry point\n\n**Characteristics:**\n- **Single responsibility**: One reason to exist\n- **Clear interface**: Single entry method (`handle()`, `execute()`, call method)\n- **Dependency injection**: Dependencies injected, not global\n- **Reusability**: Can be called from multiple contexts (controllers, jobs, CLI, API, webhooks)\n- **Testability**: Testable in isolation\n- **Naming**: Describes the operation clearly\n\n**Pattern:**\n```\npublic function handle($input) {\n    // 1. Validate/prepare input\n    // 2. Execute operation (business logic)\n    // 3. Return result or side effect\n}\n```\n\n## Laravel Action Pattern\n\n### File Structure\n\n```\napp/\nâ”œâ”€â”€ Actions/\nâ”‚   â”œâ”€â”€ Users/\nâ”‚   â”‚   â”œâ”€â”€ CreateUserAction.php\nâ”‚   â”‚   â”œâ”€â”€ UpdateUserAction.php\nâ”‚   â”‚   â””â”€â”€ DeleteUserAction.php\nâ”‚   â”œâ”€â”€ Orders/\nâ”‚   â”‚   â”œâ”€â”€ CreateOrderAction.php\nâ”‚   â”‚   â””â”€â”€ ProcessPaymentAction.php\nâ”‚   â””â”€â”€ Notifications/\nâ”‚       â”œâ”€â”€ SendWelcomeEmailAction.php\nâ”‚       â””â”€â”€ SendOrderConfirmationAction.php\n```\n\n### Basic Action Class\n\n```php\n<?php\n\nnamespace App\\Actions\\Users;\n\nfinal readonly class CreateUserAction {\n    public function __construct(private UserRepository $users) {}\n\n    public function handle(array $data): User {\n        // Validate (optional, can use Form Request instead)\n        $validated = $this->validate($data);\n\n        // Create user\n        $user = $this->users->create($validated);\n\n        // Side effects (notifications, etc.)\n        // Only if tightly coupled to creation\n        // Otherwise use jobs or separate actions\n\n        return $user;\n    }\n\n    private function validate(array $data): array {\n        // Custom validation if needed\n        return $data;\n    }\n}\n```\n\n### Usage in Controllers\n\n```php\nclass UserController extends Controller {\n    public function store(CreateUserRequest $request, CreateUserAction $createUser) {\n        // Constructor injection of action\n        $user = $createUser->handle($request->validated());\n\n        return response()->json(['user' => $user], 201);\n    }\n}\n```\n\n### Naming Conventions\n\n**Action class names:**\n- Operation + \"Action\" suffix: `CreateUserAction`, `SendEmailAction`\n- Verb-noun format: Clear what it does\n- Namespace by domain: `Users/`, `Orders/`, `Payments/`\n\n**Method names:**\n- `handle()` - Primary method for the action\n- Specific methods for complex operations: `validateUser()`, `persistToDatabase()`\n\n**File structure:**\n- One action per file\n- Directory per domain/entity type\n- `app/Actions/` root directory\n\n### Advanced Patterns\n\n**Action with Transaction:**\n```php\nfinal readonly class CreateOrderAction {\n    public function __construct(private OrderRepository $orders) {}\n\n    public function handle(array $data): Order {\n        return DB::transaction(function () use ($data) {\n            $order = $this->orders->create($data);\n            $this->orders->attachItems($order->id, $data['items']);\n            return $order;\n        });\n    }\n}\n```\n\n**Action with Events:**\n```php\nfinal readonly class ProcessPaymentAction {\n    public function __construct(private PaymentGateway $gateway) {}\n\n    public function handle(Order $order): Payment {\n        $payment = $this->gateway->process($order->total);\n\n        // Dispatch event instead of tightly coupling logic\n        event(new PaymentProcessed($order, $payment));\n\n        return $payment;\n    }\n}\n```\n\n**Action Composition:**\n```php\nfinal readonly class CompleteOrderAction {\n    public function __construct(\n        private ProcessPaymentAction $processPayment,\n        private SendConfirmationAction $sendConfirmation,\n    ) {}\n\n    public function handle(Order $order): Order {\n        $payment = $this->processPayment->handle($order);\n        $this->sendConfirmation->handle($order);\n\n        return $order->markComplete();\n    }\n}\n```\n\n## React Component & Hook Pattern\n\n### Component Structure\n\n```\nsrc/\nâ”œâ”€â”€ components/          # Reusable UI components\nâ”‚   â”œâ”€â”€ button.tsx\nâ”‚   â”œâ”€â”€ card.tsx\nâ”‚   â””â”€â”€ form-field.tsx\nâ”œâ”€â”€ sections/            # Composite sections (headers, forms, features)\nâ”‚   â”œâ”€â”€ user-profile-form.tsx\nâ”‚   â””â”€â”€ order-summary.tsx\nâ”œâ”€â”€ layouts/             # Page layouts\nâ”‚   â”œâ”€â”€ dashboard-layout.tsx\nâ”‚   â””â”€â”€ auth-layout.tsx\nâ””â”€â”€ pages/               # Route pages\n    â”œâ”€â”€ users/\n    â”‚   â”œâ”€â”€ index.tsx\n    â”‚   â””â”€â”€ show.tsx\n    â””â”€â”€ orders/\n        â”œâ”€â”€ index.tsx\n        â””â”€â”€ create.tsx\n```\n\n### Component Convention\n\n**Small, focused components (<100 lines):**\n```tsx\ninterface ButtonProps {\n    label: string;\n    onClick: () => void;\n    variant?: 'primary' | 'secondary';\n}\n\nexport function Button({ label, onClick, variant = 'primary' }: ButtonProps) {\n    return (\n        <button\n            className={`btn btn-${variant}`}\n            onClick={onClick}\n        >\n            {label}\n        </button>\n    );\n}\n```\n\n**Composite sections (reusable blocks):**\n```tsx\ninterface UserFormProps {\n    user?: User;\n    onSubmit: (data: UserData) => Promise<void>;\n}\n\nexport function UserProfileForm({ user, onSubmit }: UserFormProps) {\n    const form = useUserForm(user);\n\n    const handleSubmit = async (e: React.FormEvent) => {\n        e.preventDefault();\n        await onSubmit(form.data);\n    };\n\n    return (\n        <form onSubmit={handleSubmit}>\n            <FormField label=\"Name\" value={form.data.name} />\n            <FormField label=\"Email\" value={form.data.email} />\n            <button type=\"submit\">Save</button>\n        </form>\n    );\n}\n```\n\n### Custom Hook Convention\n\n**Naming:**\n- `use` + PascalCase: `useUserForm`, `useFetchUsers`, `useAuthContext`\n- Describe what it does: `useFormValidation`, `useLocalStorage`, `usePaginatedData`\n\n**Pattern:**\n```tsx\nfunction useUserForm(initialUser?: User) {\n    const [data, setData] = useState(initialUser || {});\n    const [errors, setErrors] = useState({});\n\n    const validate = () => {\n        // Validation logic\n    };\n\n    const submit = async () => {\n        // Submit logic\n    };\n\n    return { data, setData, errors, validate, submit };\n}\n\n// Usage\nfunction MyComponent() {\n    const form = useUserForm(user);\n    return <form onSubmit={form.submit}>...</form>;\n}\n```\n\n### Composition Pattern\n\n**Extract child components:**\n```tsx\nfunction UserDashboard({ userId }) {\n    const user = useUserData(userId);\n\n    return (\n        <div className=\"dashboard\">\n            <UserHeader user={user} />\n            <UserStats user={user} />\n            <UserActivity user={user} />\n        </div>\n    );\n}\n\n// Separate components\nfunction UserHeader({ user }) {\n    return <header>{user.name}</header>;\n}\n\nfunction UserStats({ user }) {\n    return <div>Stats content</div>;\n}\n\nfunction UserActivity({ user }) {\n    return <div>Activity content</div>;\n}\n```\n\n## Vue Composition & Pattern\n\n### Component Structure\n\n```\nsrc/\nâ”œâ”€â”€ components/          # Reusable UI components\nâ”œâ”€â”€ views/              # Route views/pages\nâ”œâ”€â”€ composables/        # Reusable composition functions\nâ”‚   â”œâ”€â”€ useUserForm.ts\nâ”‚   â””â”€â”€ useFetchData.ts\nâ””â”€â”€ services/           # API client services\n    â””â”€â”€ userService.ts\n```\n\n### Composable Convention\n\n```typescript\n// composables/useUserForm.ts\nimport { ref, computed } from 'vue';\n\nexport function useUserForm(initialUser = null) {\n    const data = ref(initialUser || {});\n    const errors = ref({});\n\n    const validate = () => {\n        // Validation logic\n    };\n\n    const submit = async () => {\n        // Submit logic\n    };\n\n    return { data, errors, validate, submit };\n}\n\n// Usage in component\n<script setup lang=\"ts\">\nimport { useUserForm } from '@/composables/useUserForm';\n\nconst form = useUserForm(props.user);\n</script>\n```\n\n## Node.js / TypeScript Pattern\n\n### Service Structure\n\n```\nsrc/\nâ”œâ”€â”€ services/\nâ”‚   â”œâ”€â”€ user.service.ts\nâ”‚   â”œâ”€â”€ order.service.ts\nâ”‚   â”œâ”€â”€ email.service.ts\nâ”‚   â””â”€â”€ payment.service.ts\nâ”œâ”€â”€ repositories/       # Data access\nâ”‚   â”œâ”€â”€ user.repository.ts\nâ”‚   â””â”€â”€ order.repository.ts\nâ”œâ”€â”€ actions/           # Complex operations\nâ”‚   â”œâ”€â”€ create-order.action.ts\nâ”‚   â””â”€â”€ process-payment.action.ts\nâ””â”€â”€ utils/             # Helper functions\n    â”œâ”€â”€ validation.ts\n    â””â”€â”€ formatting.ts\n```\n\n### Service Class Convention\n\n```typescript\nexport class UserService {\n    constructor(private userRepository: UserRepository) {}\n\n    async create(data: CreateUserDTO): Promise<User> {\n        // Operation logic\n        return user;\n    }\n\n    async update(id: string, data: UpdateUserDTO): Promise<User> {\n        // Operation logic\n        return user;\n    }\n\n    async delete(id: string): Promise<void> {\n        // Operation logic\n    }\n}\n```\n\n### Action Class Convention (Node.js)\n\n```typescript\nexport class CreateOrderAction {\n    constructor(\n        private orderService: OrderService,\n        private paymentService: PaymentService,\n    ) {}\n\n    async execute(data: CreateOrderDTO): Promise<Order> {\n        // Complex multi-step operation\n        const order = await this.orderService.create(data);\n\n        if (data.paymentMethod) {\n            await this.paymentService.process(order.id, data.paymentMethod);\n        }\n\n        return order;\n    }\n}\n```\n\n### Helper Function Convention\n\n```typescript\n// utils/validation.ts\nexport function validateEmail(email: string): boolean {\n    return /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email);\n}\n\nexport function validatePassword(password: string): boolean {\n    return password.length >= 8;\n}\n\n// Usage\nif (!validateEmail(email)) {\n    throw new Error('Invalid email');\n}\n```\n\n## Framework Auto-Detection\n\nThe plugin auto-detects your project type based on:\n\n**Laravel:**\n- Presence of `composer.json` with laravel/framework\n- Directory structure with `app/`, `routes/`, `config/`\n\n**React:**\n- Presence of `package.json` with react dependency\n- `.tsx` or `.jsx` files in `src/`\n\n**Vue:**\n- Presence of `package.json` with vue dependency\n- `.vue` files in `src/`\n\n**Node.js / Symfony:**\n- Presence of `package.json` or `composer.json`\n- Service-based file structure\n\n## Customization per Project\n\nOverride defaults in `.claude/code-splitter.local.md`:\n\n```yaml\n---\n# Laravel\nlaravel_actions_path: app/Actions\nlaravel_action_namespace: \"App\\\\Actions\"\n\n# React\nreact_components_path: src/components\nreact_hooks_path: src/hooks\n\n# Vue\nvue_composables_path: src/composables\nvue_components_path: src/components\n\n# Node.js\nnode_services_path: src/services\nnode_actions_path: src/actions\n\n# General\naction_method_name: execute      # Instead of handle\nmax_lines_per_file: 100\n---\n```\n\n## Additional Resources\n\nFor detailed examples and advanced patterns, see:\n- **`references/framework-patterns.md`** - Comprehensive framework-specific patterns\n- **`examples/`** - Real working examples for each framework\n\n## Key Principles\n\n1. **One operation per action/service**: Clear, focused responsibility\n2. **Dependency injection**: Inject dependencies, don't rely on globals\n3. **Reusability**: Can be called from multiple contexts\n4. **Testability**: Testable in isolation with mocked dependencies\n5. **Naming clarity**: Names describe what the action does\n6. **Framework conventions**: Follow established patterns for your framework\n\nNext steps: Use `/scan-code` to identify refactoring candidates, or `/split-code <file>` to apply these patterns to your code.\n",
        "plugins/code-splitter/skills/action-pattern-conventions/references/framework-patterns.md": "# Framework-Specific Action Patterns\n\n## Laravel Action Pattern - Complete Guide\n\n### Creating Action Classes\n\n**Directory convention:**\n```\napp/Actions/\nâ”œâ”€â”€ Users/\nâ”‚   â”œâ”€â”€ CreateUserAction.php\nâ”‚   â”œâ”€â”€ UpdateUserAction.php\nâ”‚   â”œâ”€â”€ DeleteUserAction.php\nâ”‚   â””â”€â”€ SendUserInviteAction.php\nâ”œâ”€â”€ Orders/\nâ”‚   â”œâ”€â”€ CreateOrderAction.php\nâ”‚   â”œâ”€â”€ ProcessPaymentAction.php\nâ”‚   â””â”€â”€ ShipOrderAction.php\nâ””â”€â”€ Notifications/\n    â”œâ”€â”€ SendWelcomeEmailAction.php\n    â””â”€â”€ SendPasswordResetAction.php\n```\n\n### Complete Action Example\n\n```php\n<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Actions\\Users;\n\nuse App\\Models\\User;\nuse App\\Notifications\\UserCreatedNotification;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Notification;\n\nfinal readonly class CreateUserAction {\n    public function __construct(\n        private UserRepository $users,\n        private EventBus $events,\n    ) {}\n\n    public function handle(CreateUserDTO $data): User {\n        return DB::transaction(function () use ($data) {\n            // 1. Validate (can also use Form Request)\n            $this->validate($data);\n\n            // 2. Create user\n            $user = $this->users->create([\n                'name' => $data->name,\n                'email' => $data->email,\n                'password' => Hash::make($data->password),\n            ]);\n\n            // 3. Side effects / notifications\n            Notification::send($user, new UserCreatedNotification($user));\n\n            // 4. Dispatch event for other listeners\n            $this->events->dispatch(new UserCreated($user));\n\n            return $user;\n        });\n    }\n\n    private function validate(CreateUserDTO $data): void {\n        if (User::where('email', $data->email)->exists()) {\n            throw new UserAlreadyExistsException();\n        }\n    }\n}\n```\n\n### Using Actions in Controllers\n\n```php\nclass UserController extends Controller {\n    public function store(\n        CreateUserRequest $request,\n        CreateUserAction $createUser,\n    ) {\n        try {\n            $user = $createUser->handle(\n                CreateUserDTO::from($request->validated())\n            );\n\n            return response()->json(['user' => new UserResource($user)], 201);\n        } catch (UserAlreadyExistsException) {\n            return response()->json(['error' => 'User already exists'], 422);\n        }\n    }\n}\n```\n\n### Using Actions in Jobs\n\n```php\nclass SendBulkInvitesJob implements ShouldQueue {\n    public function __construct(private array $emails) {}\n\n    public function handle(SendUserInviteAction $sendInvite) {\n        foreach ($this->emails as $email) {\n            $sendInvite->handle($email);\n        }\n    }\n}\n```\n\n### Creating Related Action Classes\n\n```php\n// app/Actions/Orders/CreateOrderAction.php\nfinal readonly class CreateOrderAction {\n    public function __construct(\n        private OrderRepository $orders,\n        private ProcessPaymentAction $processPayment,\n        private SendConfirmationEmailAction $sendEmail,\n    ) {}\n\n    public function handle(CreateOrderDTO $data): Order {\n        return DB::transaction(function () use ($data) {\n            // Create order\n            $order = $this->orders->create($data->toArray());\n\n            // Process payment\n            try {\n                $this->processPayment->handle($order, $data->paymentInfo);\n            } catch (PaymentFailedException $e) {\n                $order->markFailed();\n                throw $e;\n            }\n\n            // Send confirmation\n            $this->sendEmail->handle($order);\n\n            return $order;\n        });\n    }\n}\n```\n\n### Testing Actions\n\n```php\nclass CreateUserActionTest extends TestCase {\n    public function test_creates_user_with_valid_data() {\n        $action = new CreateUserAction(\n            new UserRepository(),\n            new EventBus(),\n        );\n\n        $user = $action->handle(new CreateUserDTO(\n            name: 'John Doe',\n            email: 'john@example.com',\n            password: 'password123',\n        ));\n\n        expect($user)->toBeInstanceOf(User::class);\n        expect($user->email)->toBe('john@example.com');\n    }\n}\n```\n\n## React Component & Hook Pattern\n\n### Complete Component Example\n\n```tsx\n// src/components/UserForm/UserForm.tsx\nimport { useState } from 'react';\nimport { useForm } from './useUserForm';\nimport { FormField } from '../FormField';\nimport { Button } from '../Button';\n\ninterface UserFormProps {\n    initialUser?: User;\n    onSuccess?: (user: User) => void;\n}\n\nexport function UserForm({ initialUser, onSuccess }: UserFormProps) {\n    const form = useForm(initialUser);\n    const [isLoading, setIsLoading] = useState(false);\n\n    const handleSubmit = async (e: React.FormEvent) => {\n        e.preventDefault();\n\n        if (!form.validate()) {\n            return;\n        }\n\n        setIsLoading(true);\n        try {\n            const user = await form.submit();\n            onSuccess?.(user);\n        } finally {\n            setIsLoading(false);\n        }\n    };\n\n    return (\n        <form onSubmit={handleSubmit} className=\"space-y-4\">\n            <FormField\n                label=\"Name\"\n                value={form.data.name}\n                onChange={(value) => form.setField('name', value)}\n                error={form.errors.name}\n            />\n\n            <FormField\n                label=\"Email\"\n                type=\"email\"\n                value={form.data.email}\n                onChange={(value) => form.setField('email', value)}\n                error={form.errors.email}\n            />\n\n            <Button\n                type=\"submit\"\n                label={initialUser ? 'Update' : 'Create'}\n                disabled={isLoading}\n            />\n        </form>\n    );\n}\n```\n\n### Custom Hook Example\n\n```tsx\n// src/components/UserForm/useUserForm.ts\nimport { useState } from 'react';\nimport { usersApi } from '@/services/api/users';\n\ninterface FormData {\n    name: string;\n    email: string;\n}\n\ninterface FormErrors {\n    name?: string;\n    email?: string;\n}\n\nexport function useForm(initialUser?: User) {\n    const [data, setData] = useState<FormData>(\n        initialUser ? { name: initialUser.name, email: initialUser.email } : {\n            name: '',\n            email: '',\n        }\n    );\n    const [errors, setErrors] = useState<FormErrors>({});\n\n    const setField = (field: keyof FormData, value: string) => {\n        setData((prev) => ({ ...prev, [field]: value }));\n        // Clear error when user starts typing\n        if (errors[field]) {\n            setErrors((prev) => ({ ...prev, [field]: undefined }));\n        }\n    };\n\n    const validate = (): boolean => {\n        const newErrors: FormErrors = {};\n\n        if (!data.name.trim()) {\n            newErrors.name = 'Name is required';\n        }\n\n        if (!data.email.includes('@')) {\n            newErrors.email = 'Valid email required';\n        }\n\n        setErrors(newErrors);\n        return Object.keys(newErrors).length === 0;\n    };\n\n    const submit = async (): Promise<User> => {\n        if (initialUser) {\n            return await usersApi.update(initialUser.id, data);\n        } else {\n            return await usersApi.create(data);\n        }\n    };\n\n    return { data, setData, setField, errors, validate, submit };\n}\n```\n\n### Component Composition Example\n\n```tsx\n// src/sections/UserDashboard.tsx\nimport { useUser } from '@/hooks/api/useUser';\nimport { UserProfile } from './UserProfile';\nimport { UserStats } from './UserStats';\nimport { UserActivity } from './UserActivity';\n\ninterface UserDashboardProps {\n    userId: string;\n}\n\nexport function UserDashboard({ userId }: UserDashboardProps) {\n    const { user, isLoading } = useUser(userId);\n\n    if (isLoading) return <div>Loading...</div>;\n    if (!user) return <div>User not found</div>;\n\n    return (\n        <div className=\"space-y-6\">\n            <UserProfile user={user} />\n            <UserStats user={user} />\n            <UserActivity userId={userId} />\n        </div>\n    );\n}\n```\n\n### Extracted Child Components\n\n```tsx\n// src/sections/UserProfile.tsx\nexport function UserProfile({ user }: { user: User }) {\n    return (\n        <div className=\"card\">\n            <h2>{user.name}</h2>\n            <p>{user.email}</p>\n        </div>\n    );\n}\n\n// src/sections/UserStats.tsx\nexport function UserStats({ user }: { user: User }) {\n    return (\n        <div className=\"grid grid-cols-3 gap-4\">\n            <StatCard label=\"Orders\" value={user.orderCount} />\n            <StatCard label=\"Spent\" value={`$${user.totalSpent}`} />\n            <StatCard label=\"Member Since\" value={user.createdAt} />\n        </div>\n    );\n}\n\n// src/sections/UserActivity.tsx\nexport function UserActivity({ userId }: { userId: string }) {\n    const { activities, isLoading } = useUserActivities(userId);\n\n    return (\n        <div className=\"card\">\n            <h3>Recent Activity</h3>\n            {activities?.map((activity) => (\n                <ActivityItem key={activity.id} activity={activity} />\n            ))}\n        </div>\n    );\n}\n```\n\n## Vue Composable Pattern\n\n### Complete Composable Example\n\n```typescript\n// src/composables/useUserForm.ts\nimport { ref, computed, reactive } from 'vue';\nimport { usersApi } from '@/services/api/users';\n\ninterface FormData {\n    name: string;\n    email: string;\n}\n\ninterface FormErrors {\n    name?: string;\n    email?: string;\n}\n\nexport function useUserForm(initialUser: User | null = null) {\n    const data = reactive<FormData>(\n        initialUser ? { name: initialUser.name, email: initialUser.email } : {\n            name: '',\n            email: '',\n        }\n    );\n\n    const errors = reactive<FormErrors>({});\n    const isSubmitting = ref(false);\n\n    const validate = (): boolean => {\n        errors.name = undefined;\n        errors.email = undefined;\n\n        if (!data.name.trim()) {\n            errors.name = 'Name is required';\n        }\n\n        if (!data.email.includes('@')) {\n            errors.email = 'Valid email required';\n        }\n\n        return Object.keys(errors).length === 0;\n    };\n\n    const submit = async (): Promise<User> => {\n        if (!validate()) {\n            throw new Error('Validation failed');\n        }\n\n        isSubmitting.value = true;\n        try {\n            if (initialUser) {\n                return await usersApi.update(initialUser.id, data);\n            } else {\n                return await usersApi.create(data);\n            }\n        } finally {\n            isSubmitting.value = false;\n        }\n    };\n\n    const setField = (field: keyof FormData, value: string) => {\n        data[field] = value;\n        if (errors[field]) {\n            errors[field] = undefined;\n        }\n    };\n\n    return {\n        data,\n        errors,\n        isSubmitting: computed(() => isSubmitting.value),\n        validate,\n        submit,\n        setField,\n    };\n}\n```\n\n### Vue Component Using Composable\n\n```vue\n<template>\n    <form @submit.prevent=\"handleSubmit\" class=\"space-y-4\">\n        <FormField\n            label=\"Name\"\n            v-model=\"form.data.name\"\n            :error=\"form.errors.name\"\n        />\n\n        <FormField\n            label=\"Email\"\n            type=\"email\"\n            v-model=\"form.data.email\"\n            :error=\"form.errors.email\"\n        />\n\n        <Button\n            type=\"submit\"\n            :label=\"initialUser ? 'Update' : 'Create'\"\n            :disabled=\"form.isSubmitting\"\n        />\n    </form>\n</template>\n\n<script setup lang=\"ts\">\nimport { useUserForm } from '@/composables/useUserForm';\nimport { defineProps, defineEmits } from 'vue';\n\nconst props = defineProps<{ initialUser?: User }>();\nconst emit = defineEmits<{ success: [user: User] }>();\n\nconst form = useUserForm(props.initialUser);\n\nconst handleSubmit = async () => {\n    try {\n        const user = await form.submit();\n        emit('success', user);\n    } catch (error) {\n        console.error('Form submission failed', error);\n    }\n};\n</script>\n```\n\n## Node.js / TypeScript Pattern\n\n### Service + Action Example\n\n```typescript\n// src/services/OrderService.ts\nexport class OrderService {\n    constructor(\n        private db: Database,\n        private paymentGateway: PaymentGateway,\n    ) {}\n\n    async create(data: CreateOrderDTO): Promise<Order> {\n        const order = await this.db.orders.create({\n            customerId: data.customerId,\n            items: data.items,\n            total: this.calculateTotal(data.items),\n        });\n\n        return order;\n    }\n\n    async update(id: string, data: UpdateOrderDTO): Promise<Order> {\n        const order = await this.db.orders.update(id, data);\n        return order;\n    }\n\n    private calculateTotal(items: OrderItem[]): number {\n        return items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n    }\n}\n\n// src/actions/CreateOrderAction.ts\nexport class CreateOrderAction {\n    constructor(\n        private orderService: OrderService,\n        private paymentService: PaymentService,\n        private emailService: EmailService,\n    ) {}\n\n    async execute(data: CreateOrderDTO): Promise<Order> {\n        // Create order\n        const order = await this.orderService.create(data);\n\n        // Process payment\n        try {\n            const payment = await this.paymentService.process(\n                order.id,\n                order.total,\n                data.paymentMethod\n            );\n\n            // Mark order as paid\n            await this.orderService.markPaid(order.id, payment.transactionId);\n        } catch (error) {\n            // Payment failed, mark order as failed\n            await this.orderService.markFailed(order.id);\n            throw new PaymentFailedException('Payment processing failed');\n        }\n\n        // Send confirmation email\n        await this.emailService.sendOrderConfirmation(order);\n\n        return order;\n    }\n}\n```\n\n### Using Actions in Handlers\n\n```typescript\n// src/routes/orders.ts\nimport express from 'express';\n\nconst router = express.Router();\n\nrouter.post('/orders', async (req, res, next) => {\n    try {\n        const createOrder = req.app.get('createOrderAction') as CreateOrderAction;\n\n        const order = await createOrder.execute({\n            customerId: req.user.id,\n            items: req.body.items,\n            paymentMethod: req.body.paymentMethod,\n        });\n\n        res.status(201).json({ order });\n    } catch (error) {\n        next(error);\n    }\n});\n```\n\n### Testing Node.js Actions\n\n```typescript\ndescribe('CreateOrderAction', () => {\n    it('creates order and processes payment', async () => {\n        // Mock dependencies\n        const mockOrderService = {\n            create: jest.fn().mockResolvedValue(mockOrder),\n            markPaid: jest.fn(),\n        };\n\n        const mockPaymentService = {\n            process: jest.fn().mockResolvedValue(mockPayment),\n        };\n\n        const mockEmailService = {\n            sendOrderConfirmation: jest.fn(),\n        };\n\n        // Create action with mocked dependencies\n        const action = new CreateOrderAction(\n            mockOrderService as any,\n            mockPaymentService as any,\n            mockEmailService as any\n        );\n\n        // Execute\n        const result = await action.execute({\n            customerId: 'user-1',\n            items: [{ id: 'item-1', quantity: 1, price: 100 }],\n            paymentMethod: 'credit-card',\n        });\n\n        // Assert\n        expect(mockOrderService.create).toHaveBeenCalled();\n        expect(mockPaymentService.process).toHaveBeenCalled();\n        expect(mockEmailService.sendOrderConfirmation).toHaveBeenCalled();\n        expect(result).toEqual(mockOrder);\n    });\n});\n```\n\n## Symfony Action Pattern\n\n### Symfony Service Action\n\n```php\n<?php\n\nnamespace App\\Service\\User;\n\nuse App\\Entity\\User;\nuse App\\Repository\\UserRepository;\nuse Symfony\\Component\\PasswordHasher\\Hasher\\UserPasswordHasherInterface;\n\nfinal readonly class CreateUserService {\n    public function __construct(\n        private UserRepository $userRepository,\n        private UserPasswordHasherInterface $passwordHasher,\n    ) {}\n\n    public function execute(array $data): User {\n        $user = new User();\n        $user->setEmail($data['email']);\n        $user->setName($data['name']);\n        $user->setPassword(\n            $this->passwordHasher->hashPassword($user, $data['password'])\n        );\n\n        $this->userRepository->save($user, flush: true);\n\n        return $user;\n    }\n}\n```\n\n### Using in Symfony Controller\n\n```php\nclass UserController extends AbstractController {\n    public function create(\n        Request $request,\n        CreateUserService $createUser,\n    ): Response {\n        $user = $createUser->execute($request->getPayload()->all());\n\n        return $this->json(['user' => $user], Response::HTTP_CREATED);\n    }\n}\n```\n\n## Naming Best Practices Across Frameworks\n\n| Framework | Class Name | Method | Usage |\n|-----------|-----------|--------|-------|\n| Laravel | CreateUserAction | handle() | `$action->handle($data)` |\n| React | useUserForm hook | (composition) | `const form = useUserForm()` |\n| Vue | useUserForm composable | (composition) | `const form = useUserForm()` |\n| Node.js | CreateUserService | execute() | `await service.execute(data)` |\n| Symfony | CreateUserService | execute() | `$service->execute($data)` |\n\n## Key Differences\n\n**Laravel:**\n- Class-based actions with `handle()` method\n- Dependency injection via constructor\n- Used in controllers, jobs, commands, API requests\n\n**React:**\n- Hooks for stateful logic\n- Composition over inheritance\n- Custom hooks are the \"actions\"\n\n**Vue:**\n- Composables for reusable logic\n- Composition API similar to React hooks\n- More flexible than React for state management\n\n**Node.js:**\n- Service classes with domain-specific methods\n- Action classes for complex multi-step operations\n- Similar to Laravel but named execute()\n\n**Symfony:**\n- Service-based approach similar to Laravel\n- Dependency injection via constructor\n- Used in controllers and commands\n",
        "plugins/code-splitter/skills/code-refactoring-patterns/SKILL.md": "---\nname: Code Refactoring Patterns\ndescription: This skill should be used when the user asks to \"refactor large files\", \"split code into smaller pieces\", \"extract methods\", \"how should I refactor\", \"improve code structure\", \"break down large functions\", or discusses strategies for dividing monolithic code into smaller, maintainable components.\nversion: 0.1.0\n---\n\n# Code Refactoring Patterns\n\n## Purpose\n\nThis skill provides guidance on refactoring large, complex code files into smaller, focused, and maintainable components. It covers fundamental refactoring principles, extraction strategies, and patterns that apply across programming languages and frameworks.\n\n## When to Use\n\nUse this skill when analyzing code structure, planning refactoring strategies, or deciding how to split large files. It provides language-agnostic principles that work whether refactoring Laravel controllers, React components, Node.js services, or any codebase.\n\n## Core Refactoring Principles\n\n### 1. Single Responsibility Principle (SRP)\n\nEach function, class, or module should have one reason to change. Identify when code violates SRP:\n\n- **Controllers handling validation, business logic, and response formatting** â†’ Extract validation and business logic to separate classes\n- **Components managing state, data fetching, and rendering** â†’ Extract hooks and services\n- **Service classes with 15+ public methods** â†’ Break into focused services\n- **Functions doing multiple operations** â†’ Extract each operation to its own function\n\n**Question to ask:** \"If this code needs to change, how many different reasons could require that change?\" More than one reason signals SRP violation.\n\n### 2. Extractable Boundaries\n\nIdentify clear extraction boundaries by looking for:\n\n- **Distinct workflows**: Methods performing completely different operations (e.g., user creation separate from email sending)\n- **Reusable logic**: Code that appears in multiple places or could be used elsewhere\n- **High complexity**: Methods exceeding 15-20 lines or with nested conditionals\n- **Clear input/output**: Methods with well-defined inputs and outputs (easier to extract)\n- **Testability**: Logic that would benefit from independent testing\n\n**Extraction pattern:**\n```\n1. Identify the boundary (start/end of related operations)\n2. Extract to new method/function\n3. Verify no side effects or tight coupling\n4. Test independently\n5. Update references\n```\n\n### 3. Complexity Metrics\n\nRecognize complexity that signals refactoring need:\n\n- **Cyclomatic Complexity > 10**: Multiple branches, nested conditions â†’ Extract conditional logic to separate methods\n- **Method length > 20 lines**: Likely handling multiple concerns â†’ Break into smaller methods\n- **Nesting depth > 3 levels**: Hard to follow logic â†’ Extract inner logic to separate methods\n- **Parameter count > 4**: Hard to understand and test â†’ Group parameters into objects\n- **Method with many local variables**: Suggests multiple concerns â†’ Extract to separate methods\n\n### 4. Naming and Intent\n\nAfter extraction, ensure clear naming:\n\n- **Method names should describe intent**: `validateUserEmail()` not `check()`, `processPayment()` not `do()`\n- **Extract Guard Clauses**: Early returns for edge cases make the happy path clear\n- **Extract Error Handling**: Separate validation from business logic\n- **Extract Loops**: Extract loop bodies to named methods that describe the operation\n\n**Example**:\n```php\n// Before: Hard to understand at a glance\npublic function createUser($data) {\n    if (!$data['email']) return false;\n    if (User::where('email', $data['email'])->exists()) return false;\n    // ... 30 more lines\n}\n\n// After: Clear intent with extracted boundaries\npublic function createUser($data) {\n    if (!$this->validateUserData($data)) return false;\n    if ($this->userExists($data['email'])) return false;\n    return $this->storeUser($data);\n}\n```\n\n## Extraction Patterns by Language\n\n### PHP / Laravel\n\n**Extract CRUD operations into Action classes:**\n- `CreateUserAction` - Only handles creation logic\n- `UpdateUserAction` - Only handles updates\n- `DeleteUserAction` - Only handles deletion\n- `GetUserAction` - Only handles retrieval with related data\n\n**Extract validation into separate methods or Form Requests:**\n- `ValidateUserInput` method or Form Request class\n- Keep business logic separate from validation\n\n**Extract queries into scopes and methods:**\n- `scopeActive()` â†’ `User::query()->active()`\n- `scopeByEmail()` â†’ `User::query()->byEmail($email)`\n\n**Extract relationships into dedicated classes:**\n- Models with complex relationships â†’ Separate trait files\n- Resource formatting â†’ Dedicated Resource class\n\n### React / Vue\n\n**Extract large components into smaller pieces:**\n- Container components (data management) separate from presentational components (rendering)\n- Extract hooks for reusable logic\n- Extract smaller, focused sub-components\n\n**Extract hooks for reusable logic:**\n- `useUserPermissions()` â†’ Encapsulates permission checking\n- `useFormValidation()` â†’ Handles form state and validation\n- `useDataFetching()` â†’ Wraps React Query or SWR\n\n**Extract context providers:**\n- Theme context separate from Auth context\n- Each context for one concern\n\n### Node.js / TypeScript\n\n**Extract service methods into focused services:**\n- `UserService` â†’ User-specific operations\n- `EmailService` â†’ Email operations\n- `PaymentService` â†’ Payment operations\n\n**Extract helper/utility functions:**\n- `validateEmail()`, `hashPassword()`, `formatResponse()`\n- Keep pure functions in separate files\n\n**Extract data access patterns:**\n- Database queries â†’ Repository pattern or separate data access file\n- API calls â†’ Separate API client file\n\n## Refactoring Workflow\n\n### Step 1: Analyze Current Code\n\nRead the file and identify:\n- Current responsibilities (what does this code do?)\n- Violation areas (where are multiple concerns mixed?)\n- Extraction candidates (which parts could be separate?)\n- Dependencies (what does extracted code depend on?)\n\n### Step 2: Design Target Structure\n\nPlan the refactoring:\n- How many files/classes should be created?\n- What will each contain?\n- How will they interact?\n- What's the folder structure?\n\n### Step 3: Extract with Care\n\n- Extract one concern at a time\n- Update references to extracted code\n- Verify functionality still works\n- Run tests (if available)\n\n### Step 4: Validate\n\n- Does each extracted component have single responsibility?\n- Are dependencies clear and minimal?\n- Is the code easier to understand and test?\n- Can extracted code be reused elsewhere?\n\n## Common Extraction Scenarios\n\n### Scenario 1: Large Controller Class\n\n**Problem:** 50+ line controller method doing validation, business logic, and response formatting\n\n**Solution:**\n1. Extract validation to Form Request or validator method\n2. Extract business logic to Action class\n3. Keep controller thin (3-5 lines)\n\n### Scenario 2: Complex Component\n\n**Problem:** React component with 200+ lines doing data fetching, state management, and rendering\n\n**Solution:**\n1. Extract data fetching to custom hook\n2. Extract child components for different sections\n3. Extract form logic to separate hook\n4. Component becomes 30-40 lines focused on layout\n\n### Scenario 3: God Service Class\n\n**Problem:** Service class with 30+ public methods handling multiple unrelated operations\n\n**Solution:**\n1. Group related methods into separate service classes\n2. Service A: `UserCreation` operations\n3. Service B: `UserNotification` operations\n4. Service C: `UserPermissions` operations\n5. Update references to use appropriate service\n\n### Scenario 4: Conditional Logic\n\n**Problem:** Method with 5+ nested if/else levels\n\n**Solution:**\n1. Extract guard clauses to top (early returns)\n2. Extract condition checking to named methods\n3. Extract branch logic to separate methods\n4. Result: Clear happy path with early exits\n\n## Patterns to Follow\n\n### Action Pattern (Preferred for Business Logic)\n\n**Characteristics:**\n- Single `handle()` method with clear purpose\n- Dependencies injected via constructor\n- Reusable from commands, controllers, jobs, API requests\n- Easy to test\n\n**When to use:** Any complex business logic (user creation, payment processing, data transformation)\n\n### Hook Pattern (React/Vue)\n\n**Characteristics:**\n- Reusable logic encapsulated\n- Composed into components\n- Separate concerns (state, effects, validation)\n- Testable independently\n\n**When to use:** Reusable component logic (form handling, data fetching, permissions)\n\n### Service Pattern (Node.js/Backend)\n\n**Characteristics:**\n- Focused on specific domain\n- Clear public interface\n- Encapsulates related operations\n- Stateless or minimal state\n\n**When to use:** Domain-specific operations (UserService, EmailService, PaymentService)\n\n## Red Flags for Refactoring Need\n\nExtract code when you see:\n\n- **DRY Violation**: Same code appears 2+ times â†’ Extract to reusable function\n- **Naming Confusion**: Can't describe what a method does in a sentence â†’ Doing too much\n- **Test Difficulty**: Hard to test a method in isolation â†’ Likely mixed concerns\n- **Multiple Reasons to Change**: Modification requests affect different parts of code â†’ SRP violation\n- **Deep Nesting**: More than 3 levels of indentation â†’ Extract inner logic\n- **Long Parameter Lists**: More than 4 parameters â†’ Group into object/DTO\n- **Many Local Variables**: More than 5-6 variables â†’ Likely multiple concerns\n- **Scroll Fatigue**: Method longer than screen height â†’ Break into smaller methods\n\n## Advanced Patterns\n\n### Refactoring with Dependencies\n\nWhen extracting code with external dependencies:\n1. Identify which services/dependencies are needed\n2. Pass them as constructor parameters or method arguments\n3. Extracted code is testable with mocked dependencies\n4. Original code still works, now calling extracted code\n\n### Refactoring with State\n\nWhen extracting code that manages state:\n1. Move state and state-changing logic together\n2. Use appropriate state management (Context in React, local in Vue, closures in JS)\n3. Ensure clear ownership of state\n4. Extracted code has clear input/output\n\n### Refactoring with Side Effects\n\nWhen extracting code with side effects (DB writes, API calls, file I/O):\n1. Extract the effect operation to separate method\n2. Keep business logic pure when possible\n3. Side effects at boundaries (entry points)\n4. Easier to test pure logic separately\n\n## Additional Resources\n\nFor language and framework-specific action patterns, see:\n- **`references/extraction-patterns.md`** - Detailed extraction techniques\n- **`references/smell-indicators.md`** - Code smell checklist\n- **`examples/`** - Working refactoring examples\n\n## Next Steps\n\nAfter understanding refactoring principles, use the `/scan-code` command to identify candidates in your codebase, or `/split-code <file>` to refactor specific files following these patterns.\n",
        "plugins/code-splitter/skills/code-refactoring-patterns/references/extraction-patterns.md": "# Detailed Extraction Patterns\n\n## PHP / Laravel Extraction Patterns\n\n### Controller Extraction Pattern\n\n**Before:**\n```php\nclass UserController extends Controller {\n    public function store(Request $request) {\n        // Validation (10 lines)\n        if (!$request->input('email')) {\n            return response()->json(['error' => 'Email required'], 422);\n        }\n        if (User::where('email', $request->input('email'))->exists()) {\n            return response()->json(['error' => 'Email exists'], 422);\n        }\n\n        // Business logic (20 lines)\n        $user = new User();\n        $user->email = $request->input('email');\n        $user->password = Hash::make($request->input('password'));\n        $user->name = $request->input('name');\n        $user->save();\n\n        // Send notifications (5 lines)\n        Mail::send('emails.welcome', ['user' => $user], function($msg) use ($user) {\n            $msg->to($user->email)->subject('Welcome!');\n        });\n\n        // Return response\n        return response()->json(['user' => $user], 201);\n    }\n}\n```\n\n**After: Extract to Action**\n```php\nclass UserController extends Controller {\n    public function store(CreateUserRequest $request, CreateUserAction $action) {\n        $user = $action->handle($request->validated());\n        return response()->json(['user' => $user], 201);\n    }\n}\n```\n\n```php\n// app/Actions/Users/CreateUserAction.php\nfinal readonly class CreateUserAction {\n    public function __construct(private Mail $mail) {}\n\n    public function handle(array $data): User {\n        $user = User::create([\n            'email' => $data['email'],\n            'password' => Hash::make($data['password']),\n            'name' => $data['name'],\n        ]);\n\n        $this->mail->send('emails.welcome', ['user' => $user], function($msg) use ($user) {\n            $msg->to($user->email)->subject('Welcome!');\n        });\n\n        return $user;\n    }\n}\n```\n\n**Validation in Form Request:**\n```php\nclass CreateUserRequest extends FormRequest {\n    public function rules(): array {\n        return [\n            'email' => 'required|email|unique:users',\n            'password' => 'required|min:8|confirmed',\n            'name' => 'required|string|max:255',\n        ];\n    }\n}\n```\n\n### Model Extraction Pattern\n\n**Before:**\n```php\nclass Order extends Model {\n    public function __construct() {\n        // 50+ lines of methods\n        // Creating, updating, validating, calculating, shipping, refunding...\n    }\n}\n```\n\n**After: Extract Concerns to Traits and Relations**\n```php\nclass Order extends Model {\n    use HasStatus, HasTimestamps, Billable;\n\n    public function items(): HasMany {\n        return $this->hasMany(OrderItem::class);\n    }\n\n    public function customer(): BelongsTo {\n        return $this->belongsTo(Customer::class);\n    }\n}\n```\n\nExtract specific operations to Actions:\n- `CreateOrderAction` - Order creation\n- `ShipOrderAction` - Shipping logic\n- `RefundOrderAction` - Refund logic\n- `CalculateOrderTotalAction` - Calculation logic\n\n### Query Scope Pattern\n\n**Before:**\n```php\nclass User extends Model {\n    public function getActiveUsers() {\n        return User::where('is_active', true)\n            ->where('deleted_at', null)\n            ->orderBy('created_at', 'desc')\n            ->get();\n    }\n}\n\n// Usage: Scattered throughout codebase\n$users = User::where('is_active', true)->where('deleted_at', null)->get();\n```\n\n**After: Extract to Scopes**\n```php\nclass User extends Model {\n    public function scopeActive($query) {\n        return $query->where('is_active', true);\n    }\n\n    public function scopeNotDeleted($query) {\n        return $query->whereNull('deleted_at');\n    }\n}\n\n// Usage: Consistent, reusable\n$users = User::active()->notDeleted()->latest()->get();\n```\n\n## React Extraction Patterns\n\n### Complex Component Extraction\n\n**Before:**\n```jsx\nexport function UserDashboard({ userId }) {\n    const [user, setUser] = useState(null);\n    const [posts, setPosts] = useState([]);\n    const [loading, setLoading] = useState(true);\n    const [formData, setFormData] = useState({});\n    const [errors, setErrors] = useState({});\n\n    useEffect(() => {\n        // Fetch user\n        fetch(`/api/users/${userId}`)\n            .then(r => r.json())\n            .then(data => setUser(data));\n\n        // Fetch posts\n        fetch(`/api/users/${userId}/posts`)\n            .then(r => r.json())\n            .then(data => setPosts(data));\n\n        setLoading(false);\n    }, [userId]);\n\n    const handleSubmit = (e) => {\n        e.preventDefault();\n        // Validate form\n        // Update user\n        // Handle errors\n    };\n\n    if (loading) return <div>Loading...</div>;\n\n    return (\n        <div>\n            <div>{user?.name}</div>\n            <form onSubmit={handleSubmit}>\n                {/* 50 lines of form fields */}\n            </form>\n            <div>\n                {posts.map(post => (\n                    <div key={post.id}>{post.title}</div>\n                ))}\n            </div>\n        </div>\n    );\n}\n```\n\n**After: Extract Hooks and Components**\n\n```jsx\n// Custom hooks\nexport function useUserData(userId) {\n    const [user, setUser] = useState(null);\n    const [loading, setLoading] = useState(true);\n\n    useEffect(() => {\n        fetch(`/api/users/${userId}`)\n            .then(r => r.json())\n            .then(data => setUser(data))\n            .finally(() => setLoading(false));\n    }, [userId]);\n\n    return { user, loading };\n}\n\nexport function useUserForm(initialUser) {\n    const [formData, setFormData] = useState(initialUser || {});\n    const [errors, setErrors] = useState({});\n\n    const validate = () => { /* validation logic */ };\n    const submit = async () => { /* submit logic */ };\n\n    return { formData, setFormData, errors, validate, submit };\n}\n\n// Extracted components\nfunction UserProfile({ user }) {\n    return <div>{user?.name}</div>;\n}\n\nfunction UserEditForm({ user, onSubmit }) {\n    const form = useUserForm(user);\n    return (\n        <form onSubmit={form.submit}>\n            {/* 50 lines now focused on rendering */}\n        </form>\n    );\n}\n\nfunction UserPosts({ userId }) {\n    const [posts, setPosts] = useState([]);\n\n    useEffect(() => {\n        fetch(`/api/users/${userId}/posts`)\n            .then(r => r.json())\n            .then(setPosts);\n    }, [userId]);\n\n    return posts.map(post => <PostCard key={post.id} post={post} />);\n}\n\n// Clean main component\nexport function UserDashboard({ userId }) {\n    const { user, loading } = useUserData(userId);\n\n    if (loading) return <div>Loading...</div>;\n\n    return (\n        <div>\n            <UserProfile user={user} />\n            <UserEditForm user={user} />\n            <UserPosts userId={userId} />\n        </div>\n    );\n}\n```\n\n### Hook Extraction Pattern\n\n**Before:**\n```jsx\nfunction LoginForm() {\n    const [email, setEmail] = useState('');\n    const [password, setPassword] = useState('');\n    const [errors, setErrors] = useState({});\n    const [isSubmitting, setIsSubmitting] = useState(false);\n\n    const validateEmail = (value) => {\n        if (!value.includes('@')) {\n            return 'Invalid email';\n        }\n        return '';\n    };\n\n    const validatePassword = (value) => {\n        if (value.length < 8) {\n            return 'Password too short';\n        }\n        return '';\n    };\n\n    const handleSubmit = async (e) => {\n        e.preventDefault();\n        setIsSubmitting(true);\n\n        const emailError = validateEmail(email);\n        const passwordError = validatePassword(password);\n\n        if (emailError || passwordError) {\n            setErrors({ email: emailError, password: passwordError });\n            setIsSubmitting(false);\n            return;\n        }\n\n        try {\n            const response = await fetch('/api/login', {\n                method: 'POST',\n                body: JSON.stringify({ email, password })\n            });\n            // Handle response\n        } finally {\n            setIsSubmitting(false);\n        }\n    };\n\n    return (\n        <form onSubmit={handleSubmit}>\n            {/* Form JSX */}\n        </form>\n    );\n}\n```\n\n**After: Extract Custom Hook**\n\n```jsx\nfunction useLoginForm() {\n    const [formData, setFormData] = useState({ email: '', password: '' });\n    const [errors, setErrors] = useState({});\n    const [isSubmitting, setIsSubmitting] = useState(false);\n\n    const validators = {\n        email: (value) => !value.includes('@') ? 'Invalid email' : '',\n        password: (value) => value.length < 8 ? 'Password too short' : '',\n    };\n\n    const validate = () => {\n        const newErrors = {};\n        for (const [field, validator] of Object.entries(validators)) {\n            const error = validator(formData[field]);\n            if (error) newErrors[field] = error;\n        }\n        setErrors(newErrors);\n        return Object.keys(newErrors).length === 0;\n    };\n\n    const submit = async (onSuccess) => {\n        if (!validate()) return;\n\n        setIsSubmitting(true);\n        try {\n            const response = await fetch('/api/login', {\n                method: 'POST',\n                body: JSON.stringify(formData)\n            });\n            onSuccess(response);\n        } finally {\n            setIsSubmitting(false);\n        }\n    };\n\n    return { formData, setFormData, errors, isSubmitting, submit };\n}\n\nfunction LoginForm() {\n    const form = useLoginForm();\n\n    return (\n        <form onSubmit={(e) => {\n            e.preventDefault();\n            form.submit();\n        }}>\n            <input\n                value={form.formData.email}\n                onChange={(e) => form.setFormData({...form.formData, email: e.target.value})}\n            />\n            {form.errors.email && <span>{form.errors.email}</span>}\n\n            <input\n                type=\"password\"\n                value={form.formData.password}\n                onChange={(e) => form.setFormData({...form.formData, password: e.target.value})}\n            />\n            {form.errors.password && <span>{form.errors.password}</span>}\n\n            <button type=\"submit\" disabled={form.isSubmitting}>\n                Login\n            </button>\n        </form>\n    );\n}\n```\n\n## Node.js / TypeScript Extraction Patterns\n\n### Service Extraction Pattern\n\n**Before:**\n```typescript\nclass UserManager {\n    async createUser(data) { /* 30 lines */ }\n    async updateUser(id, data) { /* 20 lines */ }\n    async deleteUser(id) { /* 15 lines */ }\n    async sendWelcomeEmail(userId) { /* 10 lines */ }\n    async sendPasswordReset(userId) { /* 10 lines */ }\n    async checkPermissions(userId, action) { /* 15 lines */ }\n    async assignRole(userId, roleId) { /* 10 lines */ }\n    async removeRole(userId, roleId) { /* 10 lines */ }\n}\n```\n\n**After: Extract to Focused Services**\n\n```typescript\nclass UserService {\n    async create(data: UserData): Promise<User> { /* creation */ }\n    async update(id: string, data: UserData): Promise<User> { /* update */ }\n    async delete(id: string): Promise<void> { /* delete */ }\n}\n\nclass UserEmailService {\n    async sendWelcome(userId: string): Promise<void> { /* welcome email */ }\n    async sendPasswordReset(userId: string): Promise<void> { /* reset email */ }\n}\n\nclass UserPermissionService {\n    async checkPermission(userId: string, action: string): Promise<boolean> { /* check */ }\n    async assignRole(userId: string, roleId: string): Promise<void> { /* assign */ }\n    async removeRole(userId: string, roleId: string): Promise<void> { /* remove */ }\n}\n```\n\n### Helper Function Extraction\n\n**Before:**\n```typescript\nasync function processOrder(orderId: string) {\n    // Fetch order (5 lines)\n    const order = await Order.findById(orderId);\n    if (!order) throw new Error('Order not found');\n\n    // Validate items (8 lines)\n    for (const item of order.items) {\n        if (item.quantity <= 0) throw new Error('Invalid quantity');\n        if (!item.productId) throw new Error('Missing product');\n    }\n\n    // Calculate totals (6 lines)\n    let subtotal = 0;\n    let tax = 0;\n    for (const item of order.items) {\n        subtotal += item.price * item.quantity;\n    }\n    tax = subtotal * 0.1;\n\n    // Update order (3 lines)\n    order.subtotal = subtotal;\n    order.tax = tax;\n    order.total = subtotal + tax;\n    await order.save();\n}\n```\n\n**After: Extract Helper Functions**\n\n```typescript\nfunction validateOrderItems(items: OrderItem[]): void {\n    for (const item of items) {\n        if (item.quantity <= 0) throw new Error('Invalid quantity');\n        if (!item.productId) throw new Error('Missing product');\n    }\n}\n\nfunction calculateOrderTotals(items: OrderItem[]): { subtotal: number; tax: number; total: number } {\n    const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n    const tax = subtotal * 0.1;\n    return { subtotal, tax, total: subtotal + tax };\n}\n\nasync function processOrder(orderId: string) {\n    const order = await Order.findById(orderId);\n    if (!order) throw new Error('Order not found');\n\n    validateOrderItems(order.items);\n\n    const totals = calculateOrderTotals(order.items);\n    Object.assign(order, totals);\n    await order.save();\n}\n```\n\n## General Principles\n\n### Group Related Operations\n\nKeep code that changes together:\n- Validation logic stays together\n- Business logic stays together\n- Response formatting stays together\n- Error handling stays together\n\n### Extract Early\n\nDon't wait for duplication:\n- If you understand how to extract â†’ Extract immediately\n- Premature extraction is better than tangled code\n- Single-use utilities are still valid if they're complex\n\n### Name for Intent\n\nNames should explain purpose:\n- `validateUserEmail()` not `checkEmail()`\n- `calculateOrderTotal()` not `math()`\n- `fetchUserWithPosts()` not `getUser()`\n\n### Keep Dependencies Clear\n\nExtracted code should:\n- Declare all dependencies explicitly (parameters, constructor injection)\n- Not rely on global state or side effects\n- Be testable in isolation\n"
      },
      "plugins": [
        {
          "name": "code-splitter",
          "source": "./plugins/code-splitter",
          "description": "Intelligently scan and refactor large code files into smaller, maintainable action-pattern based components following language and framework conventions",
          "keywords": [
            "refactoring",
            "code-quality",
            "action-pattern",
            "laravel",
            "react",
            "node"
          ],
          "categories": [
            "action-pattern",
            "code-quality",
            "laravel",
            "node",
            "react",
            "refactoring"
          ],
          "install_commands": [
            "/plugin marketplace add MaxBoiko21/claude-plugins-marketplace",
            "/plugin install code-splitter@own-plugins-marketplace"
          ]
        }
      ]
    }
  ]
}