{
  "author": {
    "id": "GigaFyde",
    "display_name": "Laurant Marijnissen",
    "avatar_url": "https://avatars.githubusercontent.com/u/8044811?u=0fc9b00f3e7af7bcbd03b405dee844ba4b1efca1&v=4"
  },
  "marketplaces": [
    {
      "name": "project-orchestrator",
      "version": null,
      "description": "Ship multi-service features without losing context. Orchestrates parallel agent teams from brainstorming with multi-perspective design through wave-based implementation and dual-model code review — all coordinated via living design docs.",
      "repo_full_name": "GigaFyde/project-orchestrator",
      "repo_url": "https://github.com/GigaFyde/project-orchestrator",
      "repo_description": "Full-lifecycle project orchestration plugin for Claude Code",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-16T20:27:55Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"project-orchestrator\",\n  \"owner\": {\n    \"name\": \"gigafyde\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"project-orchestrator\",\n      \"version\": \"1.5.4\",\n      \"source\": \"./\",\n      \"description\": \"Ship multi-service features without losing context. Orchestrates parallel agent teams from brainstorming with multi-perspective design through wave-based implementation and dual-model code review — all coordinated via living design docs.\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"project-orchestrator\",\n  \"version\": \"1.5.4\",\n  \"description\": \"Ship multi-service features without losing context. Orchestrates parallel agent teams from brainstorming with multi-perspective design through wave-based implementation and dual-model code review — all coordinated via living design docs.\",\n  \"author\": {\n    \"name\": \"GigaFyde\"\n  },\n  \"keywords\": [\"orchestration\", \"teams\", \"parallel-agents\", \"code-review\", \"design-docs\", \"multi-service\"]\n}\n",
        "README.md": "# project-orchestrator\n\nFull-lifecycle project orchestration plugin for Claude Code. Turns feature ideas into designs and implementations using parallel teams, two-stage review, and living state documents.\n\n## Why?\n\nInspired by [obra's superpowers](https://github.com/obra/superpowers) and [GSD](https://github.com/gsd-build/get-shit-done), this plugin is my own take on structured AI-driven development. It adds multi-service orchestration, parallel agent teams, dual-model code review, and living design documents that survive context clears — giving you a repeatable workflow from idea to merged PR.\n\n## Installation\n\n### Via Marketplace (Recommended)\n\nRun this inside Claude Code to add the marketplace and install the plugin:\n\n```\n/plugin marketplace add gigafyde/gigafyde-claude-plugins\n/plugin install project-orchestrator@gigafyde-claude-plugins\n```\n\n### Direct Installation\n\nAlternatively, install directly from the plugin repository:\n\n```\n/plugin install gigafyde/project-orchestrator\n```\n\nBoth methods work identically. The marketplace approach provides a central discovery point for multiple plugins.\n\n(Optional) Create `.project-orchestrator/project.yml` in your project to customize behavior — see [Project Config](#project-config) below. The plugin works without any config using sensible defaults.\n\n**Recommended:** Add `.project-orchestrator/` to your `.gitignore` — it contains session-specific state (active plan tracker, scope files, review analytics, agent memory) that shouldn't be committed.\n\n## Quick Start\n\n1. **Set up your project** — ask Claude to generate a config for you:\n\n```\nGenerate a .project-orchestrator/project.yml config for this project\n```\n\nClaude will analyze your repo structure and create an appropriate config. This step is optional — the plugin works without config using sensible defaults.\n\n2. **Brainstorm a feature:**\n\n```\n/project:brainstorm Add user authentication with JWT tokens\n```\n\nClaude explores your codebase, asks clarifying questions, and produces a design document in `docs/plans/` with implementation tasks, dependencies, and a wave plan.\n\n3. **Review the design** (optional, but highly recommended):\n\n```\n/project:review-design\n```\n\nRuns a two-stage design review: spec completeness and feasibility. In practice, this regularly catches ambiguities and edge cases that should be clarified before agents start working — and with LLMs, clearer instructions mean less drift. Fixing a vague spec is far cheaper than course-correcting multiple agents mid-implementation.\n\n4. **Implement:**\n\n```\n/project:implement\n```\n\nSpawns parallel agents that each pick up a task, implement it, run tests, commit, and report back. Independent tasks run simultaneously in waves.\n\n5. **Review, verify, and finish:**\n\n```\n/project:review\n/project:verify\n/project:finish\n```\n\nTwo-stage code review (spec compliance + quality), evidence-based verification, then merge or PR.\n\n## Commands\n\n| Command | Purpose |\n|---------|---------|\n| `/project:brainstorm` | Design phase — brainstorm and create a design document |\n| `/project:implement` | Implementation phase — spawn parallel workers from a design doc |\n| `/project:review` | Two-stage review — spec compliance + code quality |\n| `/project:review-design` | Review a design doc before implementation |\n| `/project:verify` | Evidence-based verification before claiming completion |\n| `/project:finish` | Branch finishing — merge, PR, or keep |\n| `/project:progress` | Check feature status and suggest next steps |\n| `/project:changelog` | Add standardized changelog entries |\n\n## Project Config\n\nCreate `.project-orchestrator/project.yml` in your project root. All fields are optional — the plugin uses sensible defaults when config is missing.\n\n### Full Schema\n\n```yaml\n# .project-orchestrator/project.yml\nname: my-project\n\n# Repo structure\nstructure: polyrepo          # polyrepo | monorepo (default: monorepo)\nplans_dir: docs/plans        # where design docs live (default: docs/plans)\nplans_structure: standard    # standard (subdirs: completed/backlog/ideas + INDEX.md) | flat (default: flat)\n\n# Architecture docs (optional — skills use these for context)\narchitecture_docs:\n  agent: docs/ARCHITECTURE-AGENT.md\n  human: docs/ARCHITECTURE.md\n  domain: docs/DOMAIN-GUIDE.md\n\n# Services (for multi-service projects)\nservices:\n  - name: api\n    path: api/\n    branch: main             # default: main\n    remote: true             # has git remote? (default: true)\n    test: ./gradlew test     # test command (auto-detected if omitted)\n    changelog: api/CHANGELOG.md  # changelog path (skip if omitted)\n    auto_deploy: true        # warn before push? (default: false)\n  - name: frontend\n    path: frontend/\n    branch: main\n    remote: true\n    test: pnpm test\n    changelog: frontend/CHANGELOG.md\n    auto_deploy: true\n\n# Implementation behavior\nimplementation:\n  auto_review: true          # --no-review flag overrides (default: true)\n  max_parallel: 3            # max parallel implementer agents (default: 3)\n\n# Model assignments per role\nmodels:\n  explorer: sonnet           # default: sonnet (read-only exploration)\n  implementer: opus          # default: opus (code generation)\n\n# Review configuration\nreview:\n  strategy: parallel         # parallel | single (default: parallel)\n  parallel_models: [haiku, sonnet]  # 2 models for parallel review (default: [haiku, sonnet])\n  single_model: opus         # model for single review (default: opus)\n\n  # Review System v2\n  speculative_quality: true  # run quality in parallel with spec on first review (default: true)\n  max_fix_iterations: 2      # max fix attempts before human escalation (default: 2, valid: 1-5)\n  fix_timeout_turns: 10      # max agent turns per fix attempt (default: 10, valid: 5-30)\n  auto_approve: false        # auto-approve high-confidence passes (default: false)\n  auto_reject: false         # auto-send-to-implementer high-confidence failures (default: false)\n\n# Brainstorm behavior\nbrainstorm:\n  default_depth: medium      # shallow | medium | deep (default: medium)\n  team_threshold: 3          # auto-team when >= N services (default: 3)\n  designer_perspectives: [simplicity, scalability]  # default perspectives\n  perspective_docs:          # optional: map perspective names to doc files\n    # reactive-safety: path/to/doc.md\n```\n\n### Config Validation\n\n| Condition | Behavior |\n|-----------|----------|\n| Missing `.project-orchestrator/project.yml` | Defaults: monorepo, single service at root, auto-detect test command |\n| Malformed YAML | Hard error — fix config before proceeding |\n| Missing referenced file (architecture doc, plans dir) | Warn once, skip that step. Auto-create `plans_dir` on first brainstorm |\n| Invalid service path | Error when that service is targeted by a task |\n| Missing `test` for a service | Auto-detect from package.json / build.gradle / Makefile, or skip tests |\n| Missing `changelog` for a service | Skip changelog step for that service |\n| Missing `branch` for a service | Default to `main` |\n| Missing `remote` for a service | Default to `true` |\n| `review.parallel_models` not exactly 2 entries | Error: \"parallel_models requires exactly 2 models (e.g., [haiku, sonnet])\" |\n| `review.strategy` not `parallel` or `single` | Error: \"review.strategy must be 'parallel' or 'single'\" |\n| `brainstorm.default_depth` not `shallow`/`medium`/`deep` | Error: \"brainstorm.default_depth must be 'shallow', 'medium', or 'deep'\" |\n| `models.*` not `opus`/`sonnet`/`haiku` | Error: \"Model must be 'opus', 'sonnet', or 'haiku'\" |\n| `review.max_fix_iterations` not 1-5 | Error: \"max_fix_iterations must be 1-5\" |\n| `review.fix_timeout_turns` not 5-30 | Error: \"fix_timeout_turns must be 5-30\" |\n| `brainstorm.perspective_docs` key not in `designer_perspectives` | Warning (not error): key will be ignored |\n\n### Defaults\n\n| Key | Default | Rationale |\n|-----|---------|-----------|\n| `implementation.auto_review` | `true` | Review by default |\n| `implementation.max_parallel` | `3` | Reasonable parallelism |\n| `models.explorer` | `sonnet` | Read-only, cost-effective |\n| `models.implementer` | `opus` | Code generation needs highest quality |\n| `review.strategy` | `parallel` | Model diversity catches more bugs |\n| `review.parallel_models` | `[haiku, sonnet]` | Fast + thorough combination |\n| `review.single_model` | `opus` | Best single model for reviews |\n| `review.speculative_quality` | `true` | Saves one review cycle on passing tasks |\n| `review.max_fix_iterations` | `2` | Enough for quick fixes, escalates real issues |\n| `review.fix_timeout_turns` | `10` | Prevents infinite agent loops |\n| `review.auto_approve` | `false` | Conservative — human reviews all until confidence builds |\n| `review.auto_reject` | `false` | Conservative — human confirms before sending back |\n| `brainstorm.default_depth` | `medium` | Safe middle ground |\n| `brainstorm.team_threshold` | `3` | Teams for 3+ services |\n| `brainstorm.designer_perspectives` | `[simplicity, scalability]` | Balanced design trade-offs |\n| `brainstorm.perspective_docs` | `{}` (empty) | Optional doc injection |\n\n### No Config (Zero-Config Mode)\n\nWithout `project.yml`, the plugin assumes:\n- **Structure:** monorepo, single service at root\n- **Plans dir:** `docs/plans/`, flat structure\n- **Architecture docs:** none (skills skip context loading)\n- **Test command:** auto-detected from package.json / build.gradle / Makefile\n- **Changelog:** none (skip changelog step)\n\n## Plugin Hooks\n\nThe plugin ships 3 opt-in hooks that improve orchestration quality during `/project:implement` sessions. **No hooks fire unless explicitly enabled** — missing config, missing dependencies (`jq`), or missing environment variables all result in silent no-ops.\n\n### Configuration\n\nEnable hooks in `.project-orchestrator/project.yml`:\n\n```yaml\n# .project-orchestrator/project.yml\nhooks:\n  stop_guard: true              # default: false\n  session_context: true         # default: false\n  precompact_state: true        # default: false\n```\n\n| Key | Values | Default |\n|-----|--------|---------|\n| `hooks.stop_guard` | `true`, `false` | `false` |\n| `hooks.session_context` | `true`, `false` | `false` |\n| `hooks.precompact_state` | `true`, `false` | `false` |\n\n### Shipped Hooks\n\n#### Stop — Prevent Premature Session End\n\nBlocks the lead agent from stopping while implementation tasks are still in-progress or pending. On second stop attempt, allows it with a warning that running implementers will continue without coordination.\n\n- **When to enable:** Recommended for long-running parallel implementations where accidental stops are costly.\n\n#### SessionStart — Auto-Load Context After `/clear`\n\nAfter `/clear` or session resume, injects a summary of the active implementation: plan name, task progress, worktree paths, and blocked/escalated tasks. Fires on `clear` and `resume` only (not `compact` — PreCompact handles that).\n\n- **When to enable:** Recommended if you use `/clear` during implementation sessions.\n\n#### PreCompact — Preserve State Across Compaction\n\nBefore automatic context compaction, injects orchestration state (plan, team, progress) so the summarizer preserves it. Complements SessionStart — one handles `/clear`, the other handles compaction.\n\n- **When to enable:** Recommended for large implementations that may trigger context compaction.\n\n### Performance\n\n| Hook | Overhead |\n|------|----------|\n| Stop guard | <1s |\n| SessionStart context | <1s |\n| PreCompact state | <1s |\n\nAll hooks are lightweight — total overhead is negligible.\n\n### Scope Protection (Example)\n\nThe plugin includes a reference implementation for file-scope enforcement via PreToolUse hooks. This is shipped as a **template** in [`examples/hooks/scope-protection/`](examples/hooks/scope-protection/), not as a built-in hook — scope management varies across projects.\n\nSee the example README for setup instructions, scope file format, and `hooks.json` snippet.\n\n## MCP Integration (Optional)\n\nThis plugin optionally integrates with Model Context Protocol (MCP) tools for enhanced state management and coordination. **All MCP features have graceful fallbacks** — the plugin works 100% without MCP installed.\n\n### What MCP Provides\n\nWhen MCP tools are available, the plugin gains additional capabilities:\n\n- **State persistence** — design doc tracking, active plan state, and team coordination survive context clears\n- **Cross-agent coordination** — implementer agents can share state through structured MCP calls\n- **Scope management** — automatic scope file creation for permission hook integration\n- **Branch tracking** — worktree lifecycle management for parallel implementation isolation\n\n### MCP Tool Categories\n\nThe plugin references these MCP tool categories (from Dev-MCP or compatible servers):\n\n- **State management** — `get_active_plan()`, `set_active_plan()`, `update_task_status()`\n- **Activity logging** — `log_activity()` for implementation progress tracking\n- **Scope management** — `create_scope()`, `delete_scope()` for auto-approve hook integration\n- **Branch tracking** — `track_branch()`, `untrack_branch()` for worktree coordination\n\n### Graceful Fallbacks\n\nWhen MCP tools are not available, the plugin uses file-based alternatives:\n\n- **State** → stored in `.project-orchestrator/state.json`\n- **Activity logs** → not persisted (ephemeral in-context only)\n- **Scopes** → manual creation or skipped\n- **Branch tracking** → manual worktree management\n\nNo functionality is lost — MCP simply enhances the experience with better state persistence and coordination.\n\n## Agents\n\n| Agent | Purpose | Model |\n|-------|---------|-------|\n| `implementer` | Implements tasks from design docs | `config.models.implementer` (default: opus) |\n| `explorer` | Read-only codebase exploration | `config.models.explorer` (default: sonnet) |\n| `spec-reviewer` | Reviews implementation against task spec | Per `config.review.strategy` |\n| `quality-reviewer` | Reviews code quality after spec passes | Per `config.review.strategy` |\n\n## Lifecycle Flow\n\n```\n/project:brainstorm → design doc created\n    ↓\n/project:review-design → (optional) spec completeness + feasibility review\n    ↓\n/project:implement → parallel workers, optional auto-review\n    ↓\n/project:review → two-stage review (spec + quality)\n    ↓\n/project:verify → evidence-based verification\n    ↓\n/project:finish → merge/PR/keep\n    ↓\n/project:changelog → standardized entries\n```\n\n## Review System v2\n\nThe review system includes speculative parallel execution, confidence-based auto-decisions, a fix iteration loop, review memory, and analytics tracking.\n\n### Speculative Parallel Review\n\nOn the **first review** of each task, all reviewers run in parallel to save wall-clock time:\n\n```\nParallel strategy (4 reviewers):\n  Spec-reviewer (haiku)     ─┐\n  Spec-reviewer (sonnet)    ─┤ All 4 in parallel\n  Quality-reviewer (haiku)  ─┤\n  Quality-reviewer (sonnet) ─┘\n\nSingle strategy (2 reviewers):\n  Spec-reviewer (opus)      ─┐ Both in parallel\n  Quality-reviewer (opus)   ─┘\n```\n\nAfter all complete, findings are merged:\n1. Merge spec findings (across models) and decide spec verdict\n2. If spec **passes** -- merge quality findings and decide overall verdict\n3. If spec **fails** -- discard quality results (they reviewed against a non-compliant implementation)\n\nQuality results are \"speculative\" because most tasks pass spec review. The cost of discarding quality results on spec failure is negligible compared to the time saved.\n\nOn **fix iterations** (2nd+ review), spec runs first (sequential), then quality only if spec passes. No speculative quality run on retries.\n\nControl this with `review.speculative_quality` (default: `true`). Set to `false` to always run spec before quality sequentially.\n\n### Confidence Scoring and Auto-Decisions\n\nEach review result is assigned a confidence level based on model agreement:\n\n| Scenario | Confidence | Auto-Action |\n|----------|------------|-------------|\n| Both models PASS (spec+quality), zero findings | Very High (1.0) | Auto-approve |\n| Both models PASS, minor-only findings | High (0.85) | Auto-approve with notes |\n| Both models FAIL, agreed critical issues | High (0.9) | Auto-reject to fix loop |\n| One model PASS, one FAIL | Low (0.4) | Human decides |\n| Both FAIL but disagree on which issues | Medium (0.6) | Human decides |\n| Stronger model found critical issue alone | Medium (0.7) | Human decides |\n\nAuto-decisions are controlled by two independent config keys:\n- `review.auto_approve: true` -- auto-approve when both models pass with no critical/important findings\n- `review.auto_reject: true` -- auto-send to implementer when both models agree on critical issues\n\nBoth default to `false` (conservative). When disabled, all results are presented to the human for decision.\n\n### Fix Iteration Loop\n\nWhen a review finds critical issues, the task enters a fix loop:\n\n1. Review findings are sent to the implementer with specific file:line references\n2. Implementer fixes the issues (bounded by `review.fix_timeout_turns` agent turns)\n3. Task is re-reviewed (spec-only first, then quality if spec passes)\n4. If the task passes, it is marked reviewed\n5. If it fails again, repeat up to `review.max_fix_iterations` times\n6. If max iterations reached, **escalate to human** -- implementation pauses for that task and dependent tasks are not started\n\n**Task status values during the fix loop:**\n- `review-fix-{N}` -- currently in fix iteration N (e.g., `review-fix-1`)\n- `escalated` -- failed review after max fix attempts, waiting for human intervention\n\nMinor-only findings (no critical or important issues) do not block -- the task is approved with notes.\n\n### Review Memory\n\nReviewers maintain structured memory that improves review quality over time. Memory is stored per-service at `.project-orchestrator/agent-memory/{type}/`:\n\n```\nMEMORY.md                    # index + cross-review patterns\nreviews/\n  {date}-{slug}.md           # per-review findings\nservice-patterns/\n  {service}.md               # per-service issue patterns\n```\n\n**Per-service pattern files** track:\n- **Common issues** -- recurring patterns with frequency, severity, and examples\n- **Service-specific rules** -- conventions learned from past reviews (e.g., \"uses reactive patterns, always check schedulers\")\n- **False positives** -- patterns that look like issues but are valid per project conventions\n\n**How memory is used:**\n1. Before reviewing, the reviewer reads service patterns for the target service\n2. Known issue patterns are weighted higher (looked for first)\n3. Known false positives are skipped\n4. After reviewing, patterns are updated with new findings\n\n**Memory pruning:** Patterns not seen in 30+ days are moved to an archive section to keep active memory focused.\n\n### Review Analytics\n\nReview results are tracked in `.project-orchestrator/review-analytics.json` at the project root. This file is append-only and records:\n\n```json\n{\n  \"reviews\": [\n    {\n      \"date\": \"2026-02-14\",\n      \"feature\": \"core-standardization\",\n      \"task\": 2,\n      \"service\": \"my-api\",\n      \"strategy\": \"parallel\",\n      \"models\": [\"haiku\", \"sonnet\"],\n      \"stage\": \"spec\",\n      \"haiku_verdict\": \"fail\",\n      \"sonnet_verdict\": \"fail\",\n      \"agreed_count\": 1,\n      \"haiku_only_count\": 0,\n      \"sonnet_only_count\": 2,\n      \"confidence\": 0.9,\n      \"auto_decision\": \"auto_reject\",\n      \"human_override\": null,\n      \"fix_iterations\": 1,\n      \"final_verdict\": \"pass\",\n      \"findings\": [...]\n    }\n  ],\n  \"summary\": {\n    \"total_reviews\": 12,\n    \"auto_approved\": 8,\n    \"auto_rejected\": 2,\n    \"human_decided\": 2,\n    \"avg_fix_iterations\": 0.5,\n    \"model_accuracy\": {\n      \"haiku\": { \"true_positive\": 15, \"false_positive\": 3, \"missed\": 5 },\n      \"sonnet\": { \"true_positive\": 20, \"false_positive\": 1, \"missed\": 2 }\n    },\n    \"by_service\": {\n      \"my-api\": { \"reviews\": 6, \"common_issues\": [\"missing error handling\"] }\n    }\n  }\n}\n```\n\n**Analytics are updated:**\n- After each review merge -- append review entry with findings\n- After fix loop completes -- update `fix_iterations` and `final_verdict`\n- After human override -- update `human_override` field\n- Summary counters are recalculated on each append\n\n**Using analytics for tuning:**\n- High `model_accuracy.{model}.false_positive` -- consider switching models or strategy\n- High `avg_fix_iterations` -- reviewers may be too strict, or specs need more detail\n- High `common_issues` for a service -- add patterns to that service's CLAUDE.md\n\nThe `/project:progress` command includes an analytics summary when the analytics file exists.\n\n## License\n\nThis project is licensed under the MIT License. See [LICENSE](LICENSE) for details.\n"
      },
      "plugins": [
        {
          "name": "project-orchestrator",
          "version": "1.5.4",
          "source": "./",
          "description": "Ship multi-service features without losing context. Orchestrates parallel agent teams from brainstorming with multi-perspective design through wave-based implementation and dual-model code review — all coordinated via living design docs.",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GigaFyde/project-orchestrator",
            "/plugin install project-orchestrator@project-orchestrator"
          ]
        }
      ]
    }
  ]
}