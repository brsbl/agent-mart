{
  "author": {
    "id": "udecode",
    "display_name": "Udecode",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/66228141?v=4",
    "url": "https://github.com/udecode",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 9,
      "total_commands": 5,
      "total_skills": 8,
      "total_stars": 1126,
      "total_forks": 83
    }
  },
  "marketplaces": [
    {
      "name": "dotai",
      "version": null,
      "description": "Claude Code plugins for AI-powered development workflows",
      "owner_info": {
        "name": "udecode",
        "email": "zbeyens@udecode.dev"
      },
      "keywords": [],
      "repo_full_name": "udecode/dotai",
      "repo_url": "https://github.com/udecode/dotai",
      "repo_description": "Context manager for all agents",
      "homepage": "",
      "signals": {
        "stars": 1126,
        "forks": 83,
        "pushed_at": "2026-01-21T23:48:08Z",
        "created_at": "2024-09-05T23:16:54Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1977
        },
        {
          "path": ".claude-plugin/plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/codex",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/codex/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/codex/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 139
        },
        {
          "path": ".claude-plugin/plugins/codex/.mcp.json",
          "type": "blob",
          "size": 551
        },
        {
          "path": ".claude-plugin/plugins/codex/README.md",
          "type": "blob",
          "size": 1804
        },
        {
          "path": ".claude-plugin/plugins/debug",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 315
        },
        {
          "path": ".claude-plugin/plugins/debug/README.md",
          "type": "blob",
          "size": 4644
        },
        {
          "path": ".claude-plugin/plugins/debug/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/skills/debug",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/skills/debug/SKILL.md",
          "type": "blob",
          "size": 11178
        },
        {
          "path": ".claude-plugin/plugins/debug/skills/trace",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/skills/trace/SKILL.md",
          "type": "blob",
          "size": 5918
        },
        {
          "path": ".claude-plugin/plugins/dig",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dig/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dig/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 260
        },
        {
          "path": ".claude-plugin/plugins/dig/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dig/skills/dig",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dig/skills/dig/SKILL.md",
          "type": "blob",
          "size": 1966
        },
        {
          "path": ".claude-plugin/plugins/dotai",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dotai/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dotai/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 365
        },
        {
          "path": ".claude-plugin/plugins/dotai/README.md",
          "type": "blob",
          "size": 4476
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/create-app-design.md",
          "type": "blob",
          "size": 10323
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/create-tech-stack.md",
          "type": "blob",
          "size": 8994
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/install.md",
          "type": "blob",
          "size": 446
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/update-app-design.md",
          "type": "blob",
          "size": 8976
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/update-tech-stack.md",
          "type": "blob",
          "size": 8530
        },
        {
          "path": ".claude-plugin/plugins/git",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 285
        },
        {
          "path": ".claude-plugin/plugins/git/README.md",
          "type": "blob",
          "size": 6796
        },
        {
          "path": ".claude-plugin/plugins/git/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/skills/create-pr",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/skills/create-pr/SKILL.md",
          "type": "blob",
          "size": 4831
        },
        {
          "path": ".claude-plugin/plugins/git/skills/draft-pr",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/skills/draft-pr/SKILL.md",
          "type": "blob",
          "size": 7023
        },
        {
          "path": ".claude-plugin/plugins/git/skills/review-pr",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/skills/review-pr/SKILL.md",
          "type": "blob",
          "size": 7747
        },
        {
          "path": ".claude-plugin/plugins/learn",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/learn/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/learn/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 164
        },
        {
          "path": ".claude-plugin/plugins/learn/README.md",
          "type": "blob",
          "size": 3716
        },
        {
          "path": ".claude-plugin/plugins/learn/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn/SKILL.md",
          "type": "blob",
          "size": 15551
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn/examples/nextjs-server-side-error-debugging.mdc",
          "type": "blob",
          "size": 4680
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn/examples/prisma-connection-pool-exhaustion.mdc",
          "type": "blob",
          "size": 5756
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn/examples/typescript-circular-dependency.mdc",
          "type": "blob",
          "size": 5218
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn/resources",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn/resources/research-references.md",
          "type": "blob",
          "size": 7642
        },
        {
          "path": ".claude-plugin/plugins/learn/skills/learn/resources/skill-template.mdc",
          "type": "blob",
          "size": 1735
        },
        {
          "path": ".claude-plugin/plugins/media",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/media/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/media/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 149
        },
        {
          "path": ".claude-plugin/plugins/media/README.md",
          "type": "blob",
          "size": 2699
        },
        {
          "path": ".claude-plugin/plugins/media/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/media/hooks/hooks.json",
          "type": "blob",
          "size": 1067
        },
        {
          "path": ".claude-plugin/plugins/media/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/media/scripts/get-env.js",
          "type": "blob",
          "size": 1160
        },
        {
          "path": ".claude-plugin/plugins/notification",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/notification/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/notification/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 206
        },
        {
          "path": ".claude-plugin/plugins/notification/README.md",
          "type": "blob",
          "size": 1690
        },
        {
          "path": ".claude-plugin/plugins/notification/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/notification/hooks/hooks.json",
          "type": "blob",
          "size": 1412
        },
        {
          "path": ".claude-plugin/plugins/test",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 318
        },
        {
          "path": ".claude-plugin/plugins/test/README.md",
          "type": "blob",
          "size": 4571
        },
        {
          "path": ".claude-plugin/plugins/test/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/skills/tdd",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/skills/tdd/SKILL.md",
          "type": "blob",
          "size": 12522
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"dotai\",\n  \"owner\": {\n    \"name\": \"udecode\",\n    \"email\": \"zbeyens@udecode.dev\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugins for AI-powered development workflows\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"dotai\",\n      \"source\": \"./.claude-plugin/plugins/dotai\",\n      \"description\": \"Complete development toolkit - documentation, PRDs, debugging, PR workflows, and planning\"\n    },\n    {\n      \"name\": \"notification\",\n      \"source\": \"./.claude-plugin/plugins/notification\",\n      \"description\": \"macOS notifications for Claude Code events\"\n    },\n    {\n      \"name\": \"media\",\n      \"source\": \"./.claude-plugin/plugins/media\",\n      \"description\": \"Auto-play/pause media on prompt submit/stop\"\n    },\n    {\n      \"name\": \"codex\",\n      \"source\": \"./.claude-plugin/plugins/codex\",\n      \"description\": \"MCP servers for Codex integration\"\n    },\n    {\n      \"name\": \"debug\",\n      \"source\": \"./.claude-plugin/plugins/debug\",\n      \"description\": \"Systematic debugging and root cause analysis framework - four-phase investigation process ensuring understanding before fixes\"\n    },\n    {\n      \"name\": \"test\",\n      \"source\": \"./.claude-plugin/plugins/test\",\n      \"description\": \"Test-driven development workflow for writing tests before implementation - red-green-refactor cycle with deterministic unit tests\"\n    },\n    {\n      \"name\": \"learn\",\n      \"source\": \"./.claude-plugin/plugins/learn\",\n      \"description\": \"Continuous learning system - extracts reusable knowledge from work sessions into Claude Code skills\"\n    },\n    {\n      \"name\": \"git\",\n      \"source\": \"./.claude-plugin/plugins/git\",\n      \"description\": \"Git and GitHub workflow automation - streamlined PR creation, draft management, and code review workflows\"\n    },\n    {\n      \"name\": \"dig\",\n      \"source\": \"./.claude-plugin/plugins/dig\",\n      \"description\": \"Dig into library source code - clone and explore repos to answer API questions\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugins/codex/.claude-plugin/plugin.json": "{\n  \"name\": \"codex\",\n  \"version\": \"0.1.0\",\n  \"description\": \"MCP servers for Codex integration\",\n  \"author\": {\n    \"name\": \"zbeyens\"\n  }\n}\n",
        ".claude-plugin/plugins/codex/.mcp.json": "{\n  \"mcpServers\": {\n    \"gpt\": {\n      \"type\": \"stdio\",\n      \"command\": \"codex\",\n      \"args\": [\n        \"-s\",\n        \"danger-full-access\",\n        \"-m\",\n        \"gpt-5\",\n        \"-c\",\n        \"model_reasoning_effort=high\",\n        \"mcp-server\"\n      ],\n      \"env\": {}\n    },\n    \"codex\": {\n      \"type\": \"stdio\",\n      \"command\": \"codex\",\n      \"args\": [\n        \"-s\",\n        \"danger-full-access\",\n        \"-m\",\n        \"gpt-5-codex\",\n        \"-c\",\n        \"model_reasoning_effort=high\",\n        \"mcp-server\"\n      ],\n      \"env\": {}\n    }\n  }\n}\n",
        ".claude-plugin/plugins/codex/README.md": "# codex Plugin\n\nMCP servers for Codex integration with Claude Code.\n\n## Overview\n\nThis plugin provides MCP (Model Context Protocol) servers that enable Claude Code to invoke Codex for complex tasks. This allows you to leverage different AI models within your Claude Code workflow.\n\n## Installation\n\n```bash\n/plugin install codex@dotai\n```\n\nThen restart Claude Code.\n\n## Features\n\n### GPT MCP Server\n\nProvides access to GPT-5 with high reasoning effort for general-purpose tasks:\n\n```bash\nmcp__gpt__codex\n```\n\n### Codex MCP Server\n\nProvides access to GPT-5-Codex with high reasoning effort for coding tasks:\n\n```bash\nmcp__codex__codex\n```\n\n## Prerequisites\n\nYou must have the `codex` CLI tool installed and configured:\n\n```bash\n# Install codex\nnpm install -g @openai/codex-cli\n```\n\n## Usage\n\nOnce the plugin is installed and Claude Code is restarted, the MCP servers will be available as tools in Claude Code's toolkit. Claude will automatically use these servers when appropriate for complex tasks.\n\n### Example Use Cases\n\n- **GPT Server**: General problem-solving, analysis, research\n- **Codex Server**: Code generation, debugging, refactoring\n\n## Configuration\n\nThe plugin uses the following default configuration:\n\n- **Model**: `gpt-5` (GPT) / `gpt-5-codex` (Codex)\n- **Reasoning Effort**: `high`\n- **Protocol**: stdio (standard input/output)\n\nThese settings are optimized for quality output and can be modified in [.mcp.json](./.mcp.json) if needed.\n\n## Troubleshooting\n\n**MCP servers not appearing:**\n\n- Ensure codex CLI is installed: `which codex`\n- Verify API key is configured: `codex config list`\n- Restart Claude Code after installation\n\n**Permission errors:**\n\n- Make sure codex is executable: `chmod +x $(which codex)`\n- Check that your OpenAI API key has proper permissions\n\n## License\n\nMIT\n",
        ".claude-plugin/plugins/debug/.claude-plugin/plugin.json": "{\n  \"name\": \"debug\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Systematic debugging and root cause analysis framework - four-phase investigation process ensuring understanding before fixes\",\n  \"author\": {\n    \"name\": \"zbeyens\"\n  },\n  \"keywords\": [\"debugging\", \"root-cause\", \"investigation\", \"systematic\", \"tracing\"]\n}",
        ".claude-plugin/plugins/debug/README.md": "# Debug Plugin\n\n> Systematic debugging and root cause analysis framework\n\n## Overview\n\nThe Debug plugin provides battle-tested debugging methodologies that prevent random fixes and ensure understanding before attempting solutions. It enforces a disciplined four-phase approach to finding and fixing root causes.\n\n## Features\n\n### üîç Systematic Debugging\n\nFour-phase framework ensuring understanding before fixes:\n\n- **Root Cause Investigation** - Read errors, reproduce, gather evidence\n- **Pattern Analysis** - Compare working vs broken, understand dependencies\n- **Hypothesis Testing** - Scientific method, minimal changes, verify\n- **Implementation** - Fix root cause not symptom, appropriate testing\n\n### üîÑ Root Cause Tracing\n\nTrace bugs backward through call stack to find original trigger:\n\n- **Backward tracing** - Follow data flow up the call chain\n- **Stack instrumentation** - Add logging to identify failure points\n- **Defense-in-depth** - Add validation at multiple layers\n- **Never fix symptoms** - Always trace to source\n\n## Installation\n\n```bash\n/plugin install debug@dotai\n# restart claude\n```\n\n## Skills\n\n### debug\n\n**When to use:** Any bug, test failure, or unexpected behavior\n\n**Triggers:** Error messages, test failures, unexpected behavior, performance issues\n\n**The Four Phases:**\n1. **Root Cause Investigation** - BEFORE attempting ANY fix\n2. **Pattern Analysis** - Find working examples, compare\n3. **Hypothesis Testing** - Scientific method, one change at a time\n4. **Implementation** - Fix root cause, appropriate testing\n\n**Iron Law:** NO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST\n\n### trace\n\n**When to use:** Errors occur deep in execution, need to trace back to trigger\n\n**Triggers:** Deep stack traces, unclear data origin, git init in wrong dir\n\n**Process:**\n1. Observe the symptom\n2. Find immediate cause\n3. Ask: What called this?\n4. Keep tracing up\n5. Find original trigger\n6. Fix at source + defense-in-depth\n\n## Common Anti-Patterns to Avoid\n\n‚ùå **\"Quick fix for now, investigate later\"**\n‚úÖ Systematic investigation is faster than thrashing\n\n‚ùå **\"Just try changing X and see if it works\"**\n‚úÖ Form hypothesis, test minimally, verify\n\n‚ùå **\"Add multiple changes, run tests\"**\n‚úÖ One variable at a time\n\n‚ùå **\"I see the problem, let me fix it\"**\n‚úÖ Seeing symptoms ‚â† understanding root cause\n\n‚ùå **\"One more fix attempt\" (after 2+ failures)**\n‚úÖ 3+ failures = architectural problem\n\n## When to Stop and Reassess\n\n**If 3+ fixes failed:**\n- Each fix reveals new problem in different place\n- Fixes require massive refactoring\n- Each fix creates new symptoms elsewhere\n\n**STOP and question fundamentals:**\n- Is this pattern fundamentally sound?\n- Should we refactor architecture vs continue fixing?\n- Discuss with human partner before more fixes\n\n## Real-World Impact\n\nFrom debugging sessions:\n- **Systematic approach:** 15-30 minutes to fix\n- **Random fixes:** 2-3 hours of thrashing\n- **First-time fix rate:** 95% vs 40%\n- **New bugs introduced:** Near zero vs common\n\n## Integration\n\nWorks seamlessly with other dotai plugins:\n\n- **test** - Write appropriate tests based on complexity\n- **git** - Integrate with PR workflows\n\n## Best Practices\n\n1. **Always complete Phase 1** - No fixes without understanding\n2. **Add instrumentation** - Log at component boundaries\n3. **Trace backwards** - From symptom to source\n4. **Test minimally** - One change at a time\n5. **Question architecture** - After 3 failed fixes\n6. **Defense-in-depth** - Add validation at multiple layers\n\n## Debugging Checklist\n\nBefore proposing ANY fix:\n- [ ] Read error messages completely\n- [ ] Can reproduce consistently?\n- [ ] Checked recent changes?\n- [ ] Added instrumentation if multi-component?\n- [ ] Traced data flow to source?\n- [ ] Found working example to compare?\n- [ ] Formed single hypothesis?\n- [ ] Will test with minimal change?\n\n## Examples\n\n### Multi-Layer System Debugging\n\n```bash\n# Layer 1: Workflow\necho \"=== Secrets available in workflow: ===\"\necho \"IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}\"\n\n# Layer 2: Build script\necho \"=== Env vars in build script: ===\"\nenv | grep IDENTITY || echo \"IDENTITY not in environment\"\n\n# Layer 3: Signing script\necho \"=== Keychain state: ===\"\nsecurity list-keychains\nsecurity find-identity -v\n```\n\n### Stack Trace Instrumentation\n\n```typescript\nasync function problematicOperation(directory: string) {\n  const stack = new Error().stack;\n  console.error(\"DEBUG operation:\", {\n    directory,\n    cwd: process.cwd(),\n    nodeEnv: process.env.NODE_ENV,\n    stack,\n  });\n\n  // Operation that's failing\n  await execFileAsync(\"git\", [\"init\"], { cwd: directory });\n}\n```",
        ".claude-plugin/plugins/debug/skills/debug/SKILL.md": "---\nname: debug\ndescription: Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes - four-phase framework (root cause investigation, pattern analysis, hypothesis testing, implementation) that ensures understanding before attempting solutions\n---\n\n# Systematic Debugging\n\n## Overview\n\nRandom fixes waste time and create new bugs. Quick patches mask underlying issues.\n\n**Core principle:** ALWAYS find root cause before attempting fixes. Symptom fixes are failure.\n\n**Violating the letter of this process is violating the spirit of debugging.**\n\n## The Iron Law\n\n```\nNO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST\n```\n\nIf you haven't completed Phase 1, you cannot propose fixes.\n\n## When to Use\n\nUse for ANY technical issue:\n\n- Test failures\n- Bugs in production\n- Unexpected behavior\n- Performance problems\n- Build failures\n- Integration issues\n\n**Use this ESPECIALLY when:**\n\n- Under time pressure (emergencies make guessing tempting)\n- \"Just one quick fix\" seems obvious\n- You've already tried multiple fixes\n- Previous fix didn't work\n- You don't fully understand the issue\n\n**Don't skip when:**\n\n- Issue seems simple (simple bugs have root causes too)\n- You're in a hurry (rushing guarantees rework)\n- Manager wants it fixed NOW (systematic is faster than thrashing)\n\n## The Four Phases\n\nYou MUST complete each phase before proceeding to the next.\n\n### Phase 1: Root Cause Investigation\n\n**BEFORE attempting ANY fix:**\n\n1. **Read Error Messages Carefully**\n\n   - Don't skip past errors or warnings\n   - They often contain the exact solution\n   - Read stack traces completely\n   - Note line numbers, file paths, error codes\n\n2. **Reproduce Consistently**\n\n   - Can you trigger it reliably?\n   - What are the exact steps?\n   - Does it happen every time?\n   - If not reproducible ‚Üí gather more data, don't guess\n\n3. **Check Recent Changes**\n\n   - What changed that could cause this?\n   - Git diff, recent commits\n   - New dependencies, config changes\n   - Environmental differences\n\n4. **Gather Evidence in Multi-Component Systems**\n\n   **WHEN system has multiple components (CI ‚Üí build ‚Üí signing, API ‚Üí service ‚Üí database):**\n\n   **BEFORE proposing fixes, add diagnostic instrumentation:**\n\n   ```\n   For EACH component boundary:\n     - Log what data enters component\n     - Log what data exits component\n     - Verify environment/config propagation\n     - Check state at each layer\n\n   Run once to gather evidence showing WHERE it breaks\n   THEN analyze evidence to identify failing component\n   THEN investigate that specific component\n   ```\n\n   **Example (multi-layer system):**\n\n   ```bash\n   # Layer 1: Workflow\n   echo \"=== Secrets available in workflow: ===\"\n   echo \"IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}\"\n\n   # Layer 2: Build script\n   echo \"=== Env vars in build script: ===\"\n   env | grep IDENTITY || echo \"IDENTITY not in environment\"\n\n   # Layer 3: Signing script\n   echo \"=== Keychain state: ===\"\n   security list-keychains\n   security find-identity -v\n\n   # Layer 4: Actual signing\n   codesign --sign \"$IDENTITY\" --verbose=4 \"$APP\"\n   ```\n\n   **This reveals:** Which layer fails (secrets ‚Üí workflow ‚úì, workflow ‚Üí build ‚úó)\n\n5. **Trace Data Flow**\n\n   **WHEN error is deep in call stack:**\n\n   **REQUIRED SUB-SKILL:** Use trace skill for backward tracing technique\n\n   **Quick version:**\n\n   - Where does bad value originate?\n   - What called this with bad value?\n   - Keep tracing up until you find the source\n   - Fix at source, not at symptom\n\n### Phase 2: Pattern Analysis\n\n**Find the pattern before fixing:**\n\n1. **Find Working Examples**\n\n   - Locate similar working code in same codebase\n   - What works that's similar to what's broken?\n\n2. **Compare Against References**\n\n   - If implementing pattern, read reference implementation COMPLETELY\n   - Don't skim - read every line\n   - Understand the pattern fully before applying\n\n3. **Identify Differences**\n\n   - What's different between working and broken?\n   - List every difference, however small\n   - Don't assume \"that can't matter\"\n\n4. **Understand Dependencies**\n   - What other components does this need?\n   - What settings, config, environment?\n   - What assumptions does it make?\n\n### Phase 3: Hypothesis and Testing\n\n**Scientific method:**\n\n1. **Form Single Hypothesis**\n\n   - State clearly: \"I think X is the root cause because Y\"\n   - Write it down\n   - Be specific, not vague\n\n2. **Test Minimally**\n\n   - Make the SMALLEST possible change to test hypothesis\n   - One variable at a time\n   - Don't fix multiple things at once\n\n3. **Verify Before Continuing**\n\n   - Did it work? Yes ‚Üí Phase 4\n   - Didn't work? Form NEW hypothesis\n   - DON'T add more fixes on top\n\n4. **When You Don't Know**\n   - Say \"I don't understand X\"\n   - Don't pretend to know\n   - Ask for help\n   - Research more\n\n### Phase 4: Implementation\n\n**Fix the root cause, not the symptom:**\n\n1. **Decide on Testing Strategy**\n\n   **Auto-decide based on complexity:**\n\n   - **Write test for**: Complex algorithms, business logic, data transformations where bugs are likely\n   - **Skip test for**: UI components, React hooks, simple CRUD, straightforward mappings, anything you're 100% certain is correct\n   - **Test type**: Only deterministic unit tests - no integration tests, no complex mocking, no async complexity\n\n   **If writing test:**\n\n   - Simplest possible reproduction\n   - Automated test that fails before fix\n   - Verify logic, not implementation details\n\n   **If skipping test:**\n\n   - Verify fix with typecheck/lint\n   - Manual verification for UI changes\n   - Code review confidence that fix is correct\n\n2. **Implement Single Fix**\n\n   - Address the root cause identified\n   - ONE change at a time\n   - No \"while I'm here\" improvements\n   - No bundled refactoring\n\n3. **Verify Fix**\n\n   **If test was written:**\n\n   - Test passes now?\n   - No other tests broken?\n\n   **If no test:**\n\n   - Typecheck passes?\n   - Lint clean?\n   - Manual verification confirms fix?\n\n   **Always check:**\n\n   - Issue actually resolved?\n   - No regressions in related functionality?\n\n4. **If Fix Doesn't Work**\n\n   - STOP\n   - Count: How many fixes have you tried?\n   - If < 3: Return to Phase 1, re-analyze with new information\n   - **If ‚â• 3: STOP and question the architecture (step 5 below)**\n   - DON'T attempt Fix #4 without architectural discussion\n\n5. **If 3+ Fixes Failed: Question Architecture**\n\n   **Pattern indicating architectural problem:**\n\n   - Each fix reveals new shared state/coupling/problem in different place\n   - Fixes require \"massive refactoring\" to implement\n   - Each fix creates new symptoms elsewhere\n\n   **STOP and question fundamentals:**\n\n   - Is this pattern fundamentally sound?\n   - Are we \"sticking with it through sheer inertia\"?\n   - Should we refactor architecture vs. continue fixing symptoms?\n\n   **Discuss with your human partner before attempting more fixes**\n\n   This is NOT a failed hypothesis - this is a wrong architecture.\n\n## Red Flags - STOP and Follow Process\n\nIf you catch yourself thinking:\n\n- \"Quick fix for now, investigate later\"\n- \"Just try changing X and see if it works\"\n- \"Add multiple changes, run tests\"\n- \"It's probably X, let me fix that\"\n- \"I don't fully understand but this might work\"\n- \"Pattern says X but I'll adapt it differently\"\n- \"Here are the main problems: [lists fixes without investigation]\"\n- Proposing solutions before tracing data flow\n- **\"One more fix attempt\" (when already tried 2+)**\n- **Each fix reveals new problem in different place**\n- **Writing tests for UI components when you're certain the fix is correct**\n\n**ALL of these mean: STOP. Return to Phase 1.**\n\n**If 3+ fixes failed:** Question the architecture (see Phase 4.5)\n\n## your human partner's Signals You're Doing It Wrong\n\n**Watch for these redirections:**\n\n- \"Is that not happening?\" - You assumed without verifying\n- \"Will it show us...?\" - You should have added evidence gathering\n- \"Stop guessing\" - You're proposing fixes without understanding\n- \"Ultrathink this\" - Question fundamentals, not just symptoms\n- \"We're stuck?\" (frustrated) - Your approach isn't working\n\n**When you see these:** STOP. Return to Phase 1.\n\n## Common Rationalizations\n\n| Excuse                                       | Reality                                                                       |\n| -------------------------------------------- | ----------------------------------------------------------------------------- |\n| \"Issue is simple, don't need process\"        | Simple issues have root causes too. Process is fast for simple bugs.          |\n| \"Emergency, no time for process\"             | Systematic debugging is FASTER than guess-and-check thrashing.                |\n| \"Just try this first, then investigate\"      | First fix sets the pattern. Do it right from the start.                       |\n| \"Multiple fixes at once saves time\"          | Can't isolate what worked. Causes new bugs.                                   |\n| \"Reference too long, I'll adapt the pattern\" | Partial understanding guarantees bugs. Read it completely.                    |\n| \"I see the problem, let me fix it\"           | Seeing symptoms ‚â† understanding root cause.                                   |\n| \"One more fix attempt\" (after 2+ failures)   | 3+ failures = architectural problem. Question pattern, don't fix again.       |\n| \"UI fix doesn't need tests\"                  | Correct! UI components verified via typecheck/manual testing, not unit tests. |\n\n## Quick Reference\n\n| Phase                 | Key Activities                                         | Success Criteria            |\n| --------------------- | ------------------------------------------------------ | --------------------------- |\n| **1. Root Cause**     | Read errors, reproduce, check changes, gather evidence | Understand WHAT and WHY     |\n| **2. Pattern**        | Find working examples, compare                         | Identify differences        |\n| **3. Hypothesis**     | Form theory, test minimally                            | Confirmed or new hypothesis |\n| **4. Implementation** | Create test, fix, verify                               | Bug resolved, tests pass    |\n\n## When Process Reveals \"No Root Cause\"\n\nIf systematic investigation reveals issue is truly environmental, timing-dependent, or external:\n\n1. You've completed the process\n2. Document what you investigated\n3. Implement appropriate handling (retry, timeout, error message)\n4. Add monitoring/logging for future investigation\n\n**But:** 95% of \"no root cause\" cases are incomplete investigation.\n\n## Integration with Other Skills\n\n**This skill requires using:**\n\n- **trace** - REQUIRED when error is deep in call stack (see Phase 1, Step 5)\n\n**Testing skills (when needed):**\n\n- **tdd** (if available) - Use when fixing complex business logic that needs test coverage\n- Skip for UI components, simple CRUD, or anything verifiable via typecheck/manual testing\n\n## Real-World Impact\n\nFrom debugging sessions:\n\n- Systematic approach: 15-30 minutes to fix\n- Random fixes approach: 2-3 hours of thrashing\n- First-time fix rate: 95% vs 40%\n- New bugs introduced: Near zero vs common\n",
        ".claude-plugin/plugins/debug/skills/trace/SKILL.md": "---\nname: trace\ndescription: Use when errors occur deep in execution and you need to trace back to find the original trigger - systematically traces bugs backward through call stack, adding instrumentation when needed, to identify source of invalid data or incorrect behavior\n---\n\n# Trace\n\n## Overview\n\nBugs often manifest deep in the call stack (git init in wrong directory, file created in wrong location, database opened with wrong path). Your instinct is to fix where the error appears, but that's treating a symptom.\n\n**Core principle:** Trace backward through the call chain until you find the original trigger, then fix at the source.\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Bug appears deep in stack?\" [shape=diamond];\n    \"Can trace backwards?\" [shape=diamond];\n    \"Fix at symptom point\" [shape=box];\n    \"Trace to original trigger\" [shape=box];\n    \"BETTER: Also add defense-in-depth\" [shape=box];\n\n    \"Bug appears deep in stack?\" -> \"Can trace backwards?\" [label=\"yes\"];\n    \"Can trace backwards?\" -> \"Trace to original trigger\" [label=\"yes\"];\n    \"Can trace backwards?\" -> \"Fix at symptom point\" [label=\"no - dead end\"];\n    \"Trace to original trigger\" -> \"BETTER: Also add defense-in-depth\";\n}\n```\n\n**Use when:**\n\n- Error happens deep in execution (not at entry point)\n- Stack trace shows long call chain\n- Unclear where invalid data originated\n- Need to find which test/code triggers the problem\n\n## The Tracing Process\n\n### 1. Observe the Symptom\n\n```\nError: git init failed in /Users/jesse/project/packages/core\n```\n\n### 2. Find Immediate Cause\n\n**What code directly causes this?**\n\n```typescript\nawait execFileAsync(\"git\", [\"init\"], { cwd: projectDir });\n```\n\n### 3. Ask: What Called This?\n\n```typescript\nWorktreeManager.createSessionWorktree(projectDir, sessionId)\n  ‚Üí called by Session.initializeWorkspace()\n  ‚Üí called by Session.create()\n  ‚Üí called by test at Project.create()\n```\n\n### 4. Keep Tracing Up\n\n**What value was passed?**\n\n- `projectDir = ''` (empty string!)\n- Empty string as `cwd` resolves to `process.cwd()`\n- That's the source code directory!\n\n### 5. Find Original Trigger\n\n**Where did empty string come from?**\n\n```typescript\nconst context = setupCoreTest(); // Returns { tempDir: '' }\nProject.create(\"name\", context.tempDir); // Accessed before beforeEach!\n```\n\n## Adding Stack Traces\n\nWhen you can't trace manually, add instrumentation:\n\n```typescript\n// Before the problematic operation\nasync function gitInit(directory: string) {\n  const stack = new Error().stack;\n  console.error(\"DEBUG git init:\", {\n    directory,\n    cwd: process.cwd(),\n    nodeEnv: process.env.NODE_ENV,\n    stack,\n  });\n\n  await execFileAsync(\"git\", [\"init\"], { cwd: directory });\n}\n```\n\n**Critical:** Use `console.error()` in tests (not logger - may not show)\n\n**Run and capture:**\n\n```bash\nnpm test 2>&1 | grep 'DEBUG git init'\n```\n\n**Analyze stack traces:**\n\n- Look for test file names\n- Find the line number triggering the call\n- Identify the pattern (same test? same parameter?)\n\n## Real Example: Empty projectDir\n\n**Symptom:** `.git` created in `packages/core/` (source code)\n\n**Trace chain:**\n\n1. `git init` runs in `process.cwd()` ‚Üê empty cwd parameter\n2. WorktreeManager called with empty projectDir\n3. Session.create() passed empty string\n4. Test accessed `context.tempDir` before beforeEach\n5. setupCoreTest() returns `{ tempDir: '' }` initially\n\n**Root cause:** Top-level variable initialization accessing empty value\n\n**Fix:** Made tempDir a getter that throws if accessed before beforeEach\n\n**Also added defense-in-depth:**\n\n- Layer 1: Project.create() validates directory\n- Layer 2: WorkspaceManager validates not empty\n- Layer 3: NODE_ENV guard refuses git init outside tmpdir\n- Layer 4: Stack trace logging before git init\n\n## Verification Strategy After Fix\n\n**Auto-decide on testing based on complexity:**\n\n**Write deterministic unit test for:**\n\n- Complex algorithms or business logic\n- Data transformations where bugs are likely\n- Critical paths that could break silently\n\n**Skip test for:**\n\n- UI components or React hooks\n- Simple CRUD operations\n- Straightforward mappings\n- Anything you're 100% certain is correct\n\n**If no test:**\n\n- Verify with typecheck/lint\n- Manual verification for UI changes\n- Code review confidence\n\n**Only deterministic unit tests** - no integration tests, no complex mocking, no async complexity.\n\n## Key Principle\n\n```dot\ndigraph principle {\n    \"Found immediate cause\" [shape=ellipse];\n    \"Can trace one level up?\" [shape=diamond];\n    \"Trace backwards\" [shape=box];\n    \"Is this the source?\" [shape=diamond];\n    \"Fix at source\" [shape=box];\n    \"Add validation at each layer\" [shape=box];\n    \"Bug impossible\" [shape=doublecircle];\n    \"NEVER fix just the symptom\" [shape=octagon, style=filled, fillcolor=red, fontcolor=white];\n\n    \"Found immediate cause\" -> \"Can trace one level up?\";\n    \"Can trace one level up?\" -> \"Trace backwards\" [label=\"yes\"];\n    \"Can trace one level up?\" -> \"NEVER fix just the symptom\" [label=\"no\"];\n    \"Trace backwards\" -> \"Is this the source?\";\n    \"Is this the source?\" -> \"Trace backwards\" [label=\"no - keeps going\"];\n    \"Is this the source?\" -> \"Fix at source\" [label=\"yes\"];\n    \"Fix at source\" -> \"Add validation at each layer\";\n    \"Add validation at each layer\" -> \"Bug impossible\";\n}\n```\n\n**NEVER fix just where the error appears.** Trace back to find the original trigger.\n\n## Stack Trace Tips\n\n**In tests:** Use `console.error()` not logger - logger may be suppressed\n**Before operation:** Log before the dangerous operation, not after it fails\n**Include context:** Directory, cwd, environment variables, timestamps\n**Capture stack:** `new Error().stack` shows complete call chain\n\n## Real-World Impact\n\nFrom debugging session (2025-10-03):\n\n- Found root cause through 5-level trace\n- Fixed at source (getter validation)\n- Added 4 layers of defense\n- 1847 tests passed, zero pollution\n",
        ".claude-plugin/plugins/dig/.claude-plugin/plugin.json": "{\n  \"name\": \"dig\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Dig into library source code - clone and explore repos to answer API questions\",\n  \"author\": {\n    \"name\": \"zbeyens\"\n  },\n  \"keywords\": [\"documentation\", \"library\", \"api\", \"source-code\", \"research\"]\n}\n",
        ".claude-plugin/plugins/dig/skills/dig/SKILL.md": "---\nname: dig\ndescription: Look up documentation and source code for libraries and packages. Use when the user asks a question about a library, needs to understand a library's API, or when you need information about a library that you don't know about. Triggers on questions like \"How do I use X library?\", \"What's the API for Y?\", \"Show me how Z library handles this\", or when encountering unfamiliar library usage.\n---\n\n# Dig\n\nLook up library documentation by finding and exploring the library's source code repository.\n\n## Workflow\n\n### 1. Check for Local Availability\n\nFirst, check if the library source code already exists locally:\n\n```bash\n# Check common locations\nls /tmp/cc-repos/{library-name} 2>/dev/null\n```\n\nIf the library exists locally, skip to step 3.\n\n### 2. Clone the Repository\n\nIf not available locally, find and clone the repository:\n\n1. Search for the library's GitHub repository (most libraries are on GitHub)\n2. Clone into the standard location:\n\n```bash\nmkdir -p /tmp/cc-repos\ngit clone https://github.com/{owner}/{repo}.git /tmp/cc-repos/{repo-name}\n```\n\n**Common repository patterns:**\n\n- npm packages: Check `package.json` homepage or repository field, or search `https://github.com/{package-name}`\n- Python packages: Check PyPI page for \"Homepage\" or \"Source\" links\n- Go packages: The import path often is the repository URL\n- Rust crates: Check crates.io for repository link\n\n### 3. Research the Repository\n\nLaunch a Research agent (using the Task tool with `subagent_type=\"Explore\"`) to traverse the repository and answer the question.\n\nExample prompt for the agent:\n\n```\nExplore the repository at /tmp/cc-repos/{repo-name} to answer: {user's question}\n\nFocus on:\n- README and documentation files\n- Source code structure\n- API exports and public interfaces\n- Examples and tests for usage patterns\n```\n\n### 4. Synthesize and Answer\n\nUse the research findings to provide a clear, accurate answer to the user's question about the library.\n",
        ".claude-plugin/plugins/dotai/.claude-plugin/plugin.json": "{\n  \"name\": \"dotai\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Complete development toolkit - documentation, PRDs, design docs, debugging, PR workflows, and planning\",\n  \"author\": {\n    \"name\": \"zbeyens\"\n  },\n  \"keywords\": [\"documentation\", \"prd\", \"design\", \"tech-stack\", \"cursor-rules\", \"snippets\", \"workflow\", \"development\", \"debugging\", \"pr\", \"git\", \"planning\"]\n}\n",
        ".claude-plugin/plugins/dotai/README.md": "# Docs Plugin\n\nComplete development toolkit for software projects. Combines documentation generation (design docs, tech stack) with development workflows (PRs, planning).\n\n## Features\n\n### üé® Design Documentation\n\n- **App design generation** - Comprehensive application design documents\n- **Design updates** - Keep design docs in sync with codebase evolution\n\n### üîß Technical Documentation\n\n- **Tech stack generation** - Document your entire technical stack\n- **Stack updates** - Track dependency changes and technical evolution\n\n### üìã Cursor Rules\n\n- **Rule creation** - Generate Cursor rule files with proper structure\n- **Rule updates** - Maintain rules based on codebase evolution\n\n### üìÅ Project Structure\n\n- **Feature documentation** - Comprehensive feature docs with code exploration\n- **Structure updates** - Keep project structure documentation current\n\n### üîß Error Fixing\n\n- **Quick fixes** - Fix errors from bash output\n\n### üîÄ Git & PR Workflows\n\n- **PR creation** - Full pull request workflow with reviews\n- **Draft PRs** - Quick draft PR creation without overhead\n\n### üß† Planning\n\n- **Implementation planning** - Structured planning before coding\n- **Log monitoring** - Quick access to logs\n\n## Installation\n\nRun `/docs:install` to install prerequisites, or manually:\n\n```bash\nnpx shadcn@latest add https://raw.githubusercontent.com/udecode/dotai/main/registry/main.json\n```\n\n## Commands\n\n### Design Documentation Commands\n\n#### `/create-app-design`\n\nGenerate a comprehensive Application Design Document with interactive Q&A, project stage assessment.\n\n```\n/create-app-design\n```\n\n#### `/update-app-design`\n\nUpdate existing app design document to reflect codebase changes and project evolution.\n\n```\n/update-app-design\n```\n\n### Tech Stack Commands\n\n#### `/create-tech-stack`\n\nGenerate comprehensive technical stack documentation with exact versions, configurations, and architecture patterns.\n\n```\n/create-tech-stack\n```\n\n#### `/update-tech-stack`\n\nUpdate tech stack documentation based on dependency changes and technical evolution.\n\n```\n/update-tech-stack\n```\n\n### Cursor Rules Commands\n\n#### `/create-rule`\n\nCreate a new Cursor rule file with proper structure, conventions, and real codebase examples.\n\n```\n/create-rule component naming conventions\n```\n\n#### `/update-rule`\n\nUpdate existing Cursor rules based on new patterns or codebase evolution.\n\n```\n/update-rule\n```\n\n### Project Structure Commands\n\n#### `/create-doc`\n\nEnter \"Documentation Mode\" to generate comprehensive feature documentation with code exploration and pattern analysis.\n\n```\n/create-doc authentication feature\n```\n\n### Git & PR Commands\n\n#### `/pr`\n\nCreate pull request with full workflow and code review.\n\n```\n/pr\n```\n\n**Features:** Comprehensive PR description, test plan, code review process, Claude Code attribution\n\n#### `/draft-pr`\n\nCreate draft pull requests quickly without review overhead.\n\n```\n/draft-pr\n```\n\n**Best for:** WIP, quick sharing, early feedback\n\n### Planning Commands\n\n#### `/how`\n\nImplementation planning prompt - align on approach before coding.\n\n```\n/how\n```\n\n**Prompts for:** Clear understanding, step-by-step plan, file changes, potential issues, success criteria\n\n**Critical:** Waits for approval before implementation\n\n## Documentation Workflow\n\n```bash\n# 1. Project Setup\n/create-app-design\n/create-tech-stack\n\n# 2. Update Docs\n/update-app-design\n/update-tech-stack\n```\n\n**Output:** `.claude/rules/` contains 1-app-design-document.mdc, 2-tech-stack.mdc\n\n## Best Practices\n\n- Create design docs early, update after major changes\n- Generate tech stack docs after initial setup, update when dependencies change\n- Keep design docs business-focused (avoid implementation details)\n- Document the \"why\" not just the \"what\"\n\n## Troubleshooting\n\n**Commands Not Appearing:** Restart Claude Code, verify with `/help`\n\n## Version History\n\n### 4.0.0\n\n- Removed ctx plugin in favor of ruler\n\n### 3.0.0\n\n- Moved PRD workflows to separate plugin\n- Moved debugging workflows to debug plugin\n- Streamlined to core documentation commands\n- Focus on design docs, tech stack, and PR workflows\n\n### 2.0.0\n\n- Merged dev plugin into docs\n- 19 total commands\n- Added debugging workflows\n- Added PR creation workflows\n- Added planning commands\n- Moved context management to ctx plugin\n\n### 1.0.0\n\n- Initial release\n- 13 documentation commands\n- PRD workflows\n- App design and tech stack management\n- Cursor rules and snippets\n\n## License\n\nMIT\n\n## Author\n\nzbeyens\n",
        ".claude-plugin/plugins/dotai/commands/create-app-design.md": "---\nallowed-tools: Read, Glob, Grep, Write, MultiEdit, TodoWrite\ndescription: Generate comprehensive app design document with project stage assessment\n---\n\n# Generate Application Design Document\n\n**User Request:** $ARGUMENTS\n\n## Context\n\n- Project root: !`pwd`\n- Package.json: @package.json\n- Existing design docs: !`ls -la .claude/rules/ 2>/dev/null || echo \"No .claude/rules directory yet\"`\n\n## Goal\n\nCreate a comprehensive Application Design Document based on deep codebase analysis and user input. The document provides a high-level overview of the application's architecture, core features, user experience, and business logic while remaining technology-agnostic and focused on the \"what\" rather than the \"how\".\n\n## Process\n\n### 1. Initial Analysis\n\n- Analyze project structure and existing codebase\n- Review package.json for project name and dependencies\n- Check for existing documentation in .claude/rules/\n- Identify key application features and patterns\n- **Think deeply** about the application's purpose and architecture\n\n### 2. Codebase Deep Dive\n\n**Think harder about the application's architecture and business logic.**\n\nAnalyze the codebase to understand:\n\n- **Application Structure:** Main modules, features, and components\n- **User Flows:** Authentication, navigation, key user journeys\n- **Data Models:** Conceptual relationships and entities\n- **Business Logic:** Core rules, workflows, and processes\n- **Integrations:** External services and APIs\n- **Security Patterns:** Authentication and authorization approaches\n\n_Extended thinking helps identify non-obvious patterns, understand complex business rules from code, and make strategic decisions about what aspects are most important to document._\n\n### 3. Interactive Q&A Session\n\n**CRITICAL:** Ask project stage question FIRST, then 4-7 additional questions:\n\n- Use lettered/numbered options for easy response\n- Focus on business goals and user needs\n- Gather context for proper documentation\n\n### 4. Update Project Configuration\n\nBased on project stage response:\n\n- Update `.claude/rules/3-project-status.mdc` with current stage\n- Set appropriate DO/DON'T priorities for the stage\n- Document stage-specific development guidelines in the Cursor rule\n\n### 5. Generate Document\n\nCreate comprehensive app design document following the standard structure\n\n### 6. Save and Organize\n\n- Create `.claude/rules/` directory if needed\n- Save as `1-app-design-document.mdc`\n- Suggest next steps (tech stack doc, PRD, etc.)\n\n## Required Questions Template\n\n### üéØ CRITICAL: Project Stage Assessment (Ask First!)\n\n**1. What stage is your application currently in?**\n\na) **Pre-MVP** - Building initial version, not deployed to production yet  \n b) **MVP** - Basic version deployed and live with early users  \n c) **Production** - Mature application with established user base  \n d) **Enterprise** - Large scale deployment, multiple teams involved\n\n**2. Based on your selected stage, here are the development priorities:**\n\n- **Pre-MVP Priorities:**\n\n  - ‚úÖ DO: Core functionality, security basics, input validation, working features\n  - ‚ùå DON'T: Unit tests, performance optimization, accessibility polish, perfect code\n  - üöÄ Focus: Ship fast with security, iterate based on feedback\n\n- **MVP Priorities:**\n\n  - ‚úÖ DO: Critical path testing, basic monitoring, user feedback loops\n  - ‚ùå DON'T: Comprehensive test coverage, advanced patterns, premature optimization\n  - üöÄ Focus: Stability for early users, rapid iteration\n\n- **Production Priorities:**\n\n  - ‚úÖ DO: Testing, monitoring, performance, accessibility, documentation\n  - ‚ùå DON'T: Skip security reviews, ignore technical debt\n  - üöÄ Focus: Reliability, scalability, user experience\n\n- **Enterprise Priorities:**\n  - ‚úÖ DO: Comprehensive testing, security audits, team coordination, compliance\n  - ‚ùå DON'T: Skip documentation, ignore code standards\n  - üöÄ Focus: Team efficiency, maintainability, compliance\n\n### üìã Context-Specific Questions (Ask 4-7 based on analysis)\n\n**3. Application Purpose & Users**\n\n- What is the primary problem your application solves?\n- Who are your target users and what are their main goals?\n\n**4. Unique Value Proposition**\n\n- What makes your application unique compared to existing solutions?\n- What's your competitive advantage?\n\n**5. User Roles & Permissions**\n\n- What different types of users interact with your system?\n- Examples: end users, admins, moderators, content creators, viewers\n\n**6. Core User Journeys**\n\n- What are the 2-3 most critical user flows?\n- Example: Sign up ‚Üí Create content ‚Üí Share ‚Üí Get feedback\n\n**7. Business Model & Growth**\n\n- How does this application generate value?\n- Options: SaaS subscription, marketplace, freemium, advertising, one-time purchase\n\n**8. Integration Ecosystem**\n\n- What external services must you integrate with?\n- Examples: payment processors, email services, analytics, social platforms\n\n**9. Scale & Performance Goals**\n\n- What scale are you planning for in the next 12 months?\n- Users: dozens, hundreds, thousands, millions?\n- Geographic: local, national, global?\n\n**10. Success Metrics**\n\n- How will you measure if your application is successful?\n- Examples: user retention, revenue, engagement, conversion rates\n\n## Document Structure\n\nThe generated document must follow this high-level structure:\n\n### **Introduction**\n\n- Application overview and purpose\n- Target audience and user base\n- Core value proposition\n- Business context and goals\n\n### **Core Features**\n\n- **Feature Category 1:** (e.g., User Management)\n  - Purpose and user benefit\n  - Key functionalities\n  - User experience considerations\n- **Feature Category 2:** (e.g., Content Creation)\n  - Purpose and user benefit\n  - Key functionalities\n  - User experience considerations\n- **[Additional feature categories as needed]**\n\n### **User Experience**\n\n- User personas and roles\n- Key user journeys and flows\n- Interface design principles\n- Accessibility and usability considerations\n\n### **System Architecture**\n\n- High-level system components\n- Data flow and relationships\n- Integration points and external services\n- Security and privacy approach\n\n### **Business Logic**\n\n- Core business rules and processes\n- Data models and relationships (conceptual)\n- Workflow and state management\n- Validation and business constraints\n\n### **Future Considerations**\n\n- Planned enhancements and features\n- Scalability considerations\n- Potential integrations\n- Long-term vision and roadmap\n\n## Target Audience\n\nThe document should be accessible to:\n\n- **Business stakeholders** who need to understand the application's purpose and capabilities\n- **Product managers** planning features and roadmaps\n- **Designers** creating user interfaces and experiences\n- **New developers** joining the project who need a high-level understanding\n- **Technical leaders** making architectural decisions\n\nThe language should be clear, business-focused, and avoid technical implementation details.\n\n## Writing Principles\n\n### DO:\n\n- **Business Focus:** Describe WHAT the application does, not HOW\n- **User Value:** Emphasize benefits and outcomes for users\n- **Clear Language:** Write for non-technical stakeholders\n- **Visual Thinking:** Use diagrams and flows where helpful\n- **Future Ready:** Consider growth and evolution paths\n\n### DON'T:\n\n- **Technical Details:** No code snippets or implementation specifics\n- **Technology Stack:** Save for 2-tech-stack.mdc document\n- **Database Schemas:** Keep data models conceptual\n- **API Specifications:** Focus on capabilities, not endpoints\n- **Performance Metrics:** Describe goals, not technical benchmarks\n\n## Output\n\n- **Format:** Markdown (`.mdc`)\n- **Location:** `.claude/rules/`\n- **Filename:** `1-app-design-document.mdc`\n\n## Execution Steps\n\n### 1. Start with Analysis\n\n- Use Read, Glob, and Grep to explore the codebase\n- Identify key features and patterns\n- Look for existing documentation\n- **Use extended thinking:** \"Think deeply about this codebase's architecture, business purpose, and how different components work together to serve users\"\n\n### 2. Interactive Q&A\n\n- **MUST ASK PROJECT STAGE FIRST**\n- Present questions with numbered/lettered options\n- Wait for user responses before proceeding\n\n### 3. Update Project Status in Cursor Rule\n\nUpdate `.claude/rules/3-project-status.mdc` with the project stage information:\n\n```markdown\n---\ndescription: Project status and stage-specific development guidelines\nglobs:\nalwaysApply: true\n---\n\n# Project Status Guidelines\n\n## Current Project Stage: [Stage Name]\n\n**Stage**: [Pre-MVP | MVP | Production | Enterprise]\n\n### DO Care About (Current Stage Priorities)\n\n[Stage-specific DO priorities from template below]\n\n### DO NOT Care About (Skip for Velocity)\n\n[Stage-specific DON'T priorities from template below]\n\n### Development Approach\n\n[Stage-specific development focus]\n\n## Stage-Based Development Guidelines\n\n[Keep existing stage categories and guidelines from the original file]\n```\n\n**Stage-Specific Content:**\n\n- **Pre-MVP**:\n\n  - ‚úÖ DO: Core functionality, security basics, input validation, working features\n  - ‚ùå DON'T: Unit tests, performance optimization, accessibility polish, perfect code\n  - üöÄ Focus: Ship fast with security, iterate based on feedback\n\n- **MVP**:\n\n  - ‚úÖ DO: Critical path testing, basic monitoring, user feedback loops\n  - ‚ùå DON'T: Comprehensive test coverage, advanced patterns, premature optimization\n  - üöÄ Focus: Stability for early users, rapid iteration\n\n- **Production**:\n\n  - ‚úÖ DO: Testing, monitoring, performance, accessibility, documentation\n  - ‚ùå DON'T: Skip security reviews, ignore technical debt\n  - üöÄ Focus: Reliability, scalability, user experience\n\n- **Enterprise**:\n  - ‚úÖ DO: Comprehensive testing, security audits, team coordination, compliance\n  - ‚ùå DON'T: Skip documentation, ignore code standards\n  - üöÄ Focus: Team efficiency, maintainability, compliance\n\n### 4. Generate Document\n\n- Follow the standard structure\n- Tailor content to project stage\n- Keep language accessible\n\n### 5. Save and Next Steps\n\n- Create directories: `mkdir -p .claude/docs .claude/rules`\n- Save design document: `.claude/rules/1-app-design-document.mdc`\n- Update Claude rule: `.claude/rules/3-project-status.mdc`\n- Suggest: \"Would you like me to create a technical stack document next?\"\n",
        ".claude-plugin/plugins/dotai/commands/create-tech-stack.md": "---\nallowed-tools: Read, Glob, Grep, Write, MultiEdit, TodoWrite, Bash\ndescription: Generate comprehensive technical stack documentation from codebase analysis\n---\n\n# Generate Tech Stack Documentation\n\n**User Request:** $ARGUMENTS\n\n## Context\n\n- Project root: !`pwd`\n- Package.json: @package.json\n- Node version: !`node --version 2>/dev/null || echo \"Node.js not found\"`\n- TypeScript config: @tsconfig.json\n- Database schema: !`ls -la prisma/schema.prisma 2>/dev/null || echo \"No Prisma schema found\"`\n- Existing docs: !`ls -la .claude/rules/*.md 2>/dev/null || echo \"No docs yet\"`\n\n## Goal\n\nCreate comprehensive Tech Stack Documentation based on deep codebase analysis. Document all technologies, frameworks, libraries, development tools, deployment strategies, and implementation patterns with specific versions and configurations.\n\n## Process\n\n### 1. Automated Technical Discovery\n\n- Parse package.json for all dependencies\n- Analyze configuration files (tsconfig, vite.config, next.config, etc.)\n- Detect database setup (Prisma, Drizzle, TypeORM, etc.)\n- Identify testing frameworks and tools\n- Scan for CI/CD configurations\n- Check deployment configurations\n\n### 2. Deep Code Analysis\n\nExamine codebase for:\n\n- **Architecture Patterns:** Monorepo structure, module organization\n- **Framework Usage:** Next.js app router vs pages, API routes\n- **State Management:** Zustand, Redux, Context API patterns\n- **Styling Approach:** Tailwind, CSS modules, styled-components\n- **Type Safety:** TypeScript strictness, validation libraries\n- **API Design:** REST, GraphQL, tRPC implementation\n- **Authentication:** Auth libraries and session management\n- **Testing Strategy:** Unit, integration, E2E test patterns\n\n### 3. Interactive Technical Q&A\n\nAsk 4-6 deployment and infrastructure questions:\n\n- Use numbered/lettered options\n- Focus on non-discoverable information\n- Gather hosting, monitoring, and workflow details\n\n### 4. Generate Comprehensive Documentation\n\nCreate detailed tech stack document with:\n\n- Specific version numbers\n- Configuration examples\n- Command references\n- Architecture diagrams (when applicable)\n\n### 5. Save and Organize\n\n- Create `.claude/rules/` if needed\n- Save as `2-tech-stack.mdc`\n\n## Technical Questions Template\n\n### üöÄ Deployment & Infrastructure\n\n**1. Where is your application currently deployed?**\n\na) **Vercel** - Next.js optimized hosting  \n b) **AWS** - EC2, Lambda, or containerized  \n c) **Railway/Render** - Modern PaaS providers  \n d) **Self-hosted** - VPS or on-premise  \n e) **Other** - Please specify  \n f) **Not deployed yet** - Still in development\n\n**2. How is your database hosted?**\n\na) **Managed service** (Supabase, PlanetScale, Neon, etc.)  \n b) **Cloud provider** (AWS RDS, Google Cloud SQL, etc.)  \n c) **Self-hosted** (Docker, VPS, etc.)  \n d) **Local only** - No production database yet\n\n### üìä Monitoring & Operations\n\n**3. What observability tools do you use?**\n\na) **Error tracking:** Sentry, Rollbar, Bugsnag  \n b) **Analytics:** Vercel Analytics, Google Analytics, Plausible  \n c) **Monitoring:** Datadog, New Relic, custom solution  \n d) **Logging:** CloudWatch, LogTail, custom logs  \n e) **None yet** - Planning to add later\n\n### üë• Development Workflow\n\n**4. What's your Git workflow?**\n\na) **Feature branches** with PR reviews  \n b) **Trunk-based** development  \n c) **GitFlow** with release branches  \n d) **Direct to main** (solo project)\n\n**5. How do you manage environments?**\n\na) **Multiple deployments** (dev, staging, prod)  \n b) **Preview deployments** for PRs  \n c) **Single production** environment  \n d) **Local development** only\n\n### üîê Additional Services\n\n**6. Which external services do you integrate with?**\n\n- [ ] Payment processing (Stripe, PayPal)\n- [ ] Email service (SendGrid, Resend, AWS SES)\n- [ ] File storage (S3, Cloudinary, UploadThing)\n- [ ] Authentication (Auth0, Clerk, Supabase Auth)\n- [ ] Search (Algolia, Elasticsearch)\n- [ ] Other APIs (please specify)\n\n## Document Structure\n\nThe generated document must follow this technical structure:\n\n### **Overview**\n\n- Brief description of the application's technical nature\n- Technology stack summary\n- Architecture approach (monolith, microservices, etc.)\n\n### **Programming Language & Runtime**\n\n- Primary programming language and version\n- Runtime environment and version\n- Type system and language features used\n\n### **Frontend**\n\n- UI Framework/Library and version\n- Styling approach and frameworks\n- Component libraries and design systems\n- State management solutions\n- Build tools and bundlers\n- Browser support and compatibility\n\n### **Backend**\n\n- Backend framework and architecture\n- API design (REST, GraphQL, tRPC, etc.)\n- Authentication and authorization\n- Middleware and security\n- File handling and uploads\n\n### **Database & Storage**\n\n- Database type and version\n- ORM/Query builder\n- Schema management and migrations\n- Caching solutions\n- File storage solutions\n- Data backup and recovery\n\n### **Development Tools & Workflow**\n\n- Package manager\n- Code formatting and linting\n- Type checking and compilation\n- Testing frameworks and strategies\n- Development server and hot reload\n- Version control workflow\n\n### **Deployment & Infrastructure**\n\n- Hosting platform and services\n- Build and deployment pipeline\n- Environment configuration\n- Domain and DNS management\n- SSL/TLS and security\n- Monitoring and logging\n\n### **External Integrations**\n\n- Third-party APIs and services\n- Payment processing\n- Email services\n- Analytics and tracking\n- Error monitoring\n- Performance monitoring\n\n### **Quality Assurance & Testing**\n\n- Testing strategy and frameworks\n- Code coverage tools\n- End-to-end testing\n- Performance testing\n- Security testing\n- Code review process\n\n### **Schemas & Data Models**\n\n- Database schema (if applicable)\n- API schemas and validation\n- Type definitions and interfaces\n- Data relationships and constraints\n\n## Target Audience\n\nThe document should serve:\n\n- **Developers** joining the project who need technical onboarding\n- **DevOps engineers** setting up infrastructure and deployment\n- **Technical architects** evaluating or improving the tech stack\n- **Security teams** understanding the technical landscape\n- **Future maintainers** who need to understand technical decisions\n\nThe language should be technical, precise, and include specific version numbers and configuration details.\n\n## Documentation Principles\n\n### DO Include:\n\n- **Exact Versions:** Lock file versions, not just ranges\n- **Configuration Examples:** Actual config snippets from the project\n- **Command Reference:** All npm scripts and their purposes\n- **Setup Instructions:** Step-by-step for new developers\n- **Architecture Decisions:** Why specific technologies were chosen\n- **Integration Details:** How services connect and communicate\n\n### DON'T Include:\n\n- **Generic Descriptions:** Avoid Wikipedia-style explanations\n- **Outdated Information:** Only document what's actually used\n- **Wishful Thinking:** Document current state, not future plans\n- **Sensitive Data:** No API keys, secrets, or credentials\n- **Redundant Info:** Link to official docs instead of copying\n\n## Output\n\n- **Format:** Markdown (`.mdc`)\n- **Location:** `.claude/rules/`\n- **Filename:** `2-tech-stack.mdc`\n\n## Execution Steps\n\n### 1. Automated Analysis Phase\n\n```bash\n# Extract key technical information\n- Read package.json and lock files\n- Scan for configuration files\n- Detect framework patterns\n- Identify database setup\n- Find test configurations\n```\n\n### 2. Manual Discovery Phase\n\n- Read key source files to understand architecture\n- Check for API route patterns\n- Analyze authentication implementation\n- Review deployment configurations\n\n### 3. Interactive Q&A\n\n- Present deployment and infrastructure questions\n- Use checkboxes for multi-select options\n- Wait for user responses\n\n### 4. Document Generation\n\n- Start with discovered information\n- Incorporate user responses\n- Add specific configuration examples\n- Include all npm scripts with descriptions\n\n### 5. Save and Update\n\n```bash\n# Create directory and save\nmkdir -p .claude/docs\n# Save to .claude/rules/2-tech-stack.mdc\n```\n\n### 6. Next Steps\n\n- Recommend: \"Should I create an app design document to complement this technical documentation?\"\n\n## Example Usage\n\n```bash\n# Basic usage\n/project:create-tech-stack\n\n# With specific focus\n/project:create-tech-stack Focus on deployment and CI/CD setup\n```\n\n## Sample Output Structure\n\n```markdown\n# Tech Stack Documentation\n\n## Overview\n\n- **Framework:** Next.js 14.2.5 (App Router)\n- **Language:** TypeScript 5.5.3\n- **Database:** PostgreSQL with Prisma ORM\n- **Deployment:** Vercel with preview deployments\n\n## Commands Reference\n\n### Development\n\n- `pnpm dev` - Start Next.js dev server on port 3000\n- `pnpm build` - Build production bundle\n- `pnpm typecheck` - Run tsc --noEmit\n\n### Database\n\n- `pnpm db:generate` - Generate Prisma client\n- `pnpm db:push` - Push schema changes to database\n\n# ... continue with full documentation\n```\n",
        ".claude-plugin/plugins/dotai/commands/install.md": "---\ndescription: Install all dotai registry items in one command\nallowed-tools: Bash\n---\n\nInstall all dotai registry items (dotai, prompt) in one command:\n\n```bash\nnpx shadcn@latest add https://raw.githubusercontent.com/udecode/dotai/main/registry/all.json\n```\n\nAfter installation, add ruler postinstall to your `package.json` to auto-generate agent instructions:\n\n```json\n{\n  \"scripts\": {\n    \"postinstall\": \"npx skiller@latest apply\"\n  }\n}\n```\n",
        ".claude-plugin/plugins/dotai/commands/update-app-design.md": "---\nallowed-tools: Read, Glob, Grep, Write, MultiEdit, TodoWrite, Bash\ndescription: Update existing app design document based on codebase changes and project evolution\n---\n\n# Sync Application Design Document\n\n**User Request:** $ARGUMENTS\n\n## Context\n\n- Project root: !`pwd`\n- Package.json: @package.json\n- Current design doc: @.claude/rules/1-app-design-document.mdc\n- Last modified: !`stat -f \"%Sm\" .claude/rules/1-app-design-document.mdc 2>/dev/null || echo \"No existing document\"`\n\n## Goal\n\nUpdate the existing Application Design Document to reflect current codebase state, new features, changed priorities, and project evolution. Maintain consistency with the original document while incorporating new information.\n\n## Process\n\n### 1. Document Analysis\n\n- Read and understand the existing 1-app-design-document.mdc\n- Establish baseline understanding of documented features\n- Note the document's structure and tone\n- Identify areas that may need updates\n\n### 2. Codebase Change Detection\n\n**Think deeply about what has changed in the codebase since the document was last updated.**\n\nAnalyze for:\n\n- **New Features:** Components, modules, or capabilities added\n- **Modified Flows:** Changes to user journeys or business logic\n- **Removed Features:** Deprecated or deleted functionality\n- **Architecture Evolution:** New patterns, services, or integrations\n- **Scale Changes:** Growth in complexity or user base\n- **Security Updates:** New authentication/authorization patterns\n\n_Extended thinking helps identify subtle changes, understand how new features integrate with existing ones, and recognize patterns that indicate architectural evolution._\n\n### 3. Interactive Update Session\n\n**CRITICAL:** Ask project stage question FIRST to assess if priorities have changed:\n\n- Use lettered/numbered options for easy response\n- Focus on what has changed and why\n- Gather context for accurate updates\n\n### 4. Update Project Configuration\n\nIf project stage or priorities have changed:\n\n- Update `.claude/rules/3-project-status.mdc`\n- Adjust DO/DON'T lists for new priorities\n- Document any stage transitions\n\n### 5. Sync Document\n\nUpdate the document incrementally:\n\n- Preserve accurate existing content\n- Add new sections only when necessary\n- Update outdated information\n- Maintain consistent tone and structure\n\n### 6. Save Updated Document\n\n- Backup suggestion if major changes\n- Overwrite existing 1-app-design-document.mdc\n- Note what was updated\n\n## Required Questions Template\n\n### üéØ CRITICAL: Project Evolution Assessment (Ask First!)\n\n**1. Has your project stage evolved since the last update?**\n\na) **Same Stage** - Still in [current stage], just adding features  \nb) **Stage Evolution** - Moved from [current] to next stage  \nc) **Major Pivot** - Significant change in direction or purpose  \nd) **Help Me Assess** - Let's review current state together\n\n**2. Have your development priorities changed?**\n\nBased on your current stage, are these still your priorities?\n\n[Show current DO/DON'T lists from `.claude/rules/3-project-status.mdc`]\n\na) **Same Priorities** - These still reflect our focus  \nb) **Adjusted Priorities** - Some changes needed (please specify)  \nc) **New Focus Areas** - Different priorities based on learnings  \nd) **Stage-Based Change** - Priorities changed due to stage evolution\n\n### üìä Change Identification Questions\n\n**3. What major features have been added?**\n\nPlease describe any significant new capabilities, modules, or user-facing features added since the last update.\n\n**4. Have any core user flows changed?**\n\na) **Authentication/Authorization** - Login, permissions, security  \nb) **Main User Journey** - Primary application workflow  \nc) **Data Management** - How users create/edit/delete data  \nd) **Integration Points** - External service connections  \ne) **None/Minor Only** - No significant flow changes\n\n**5. What has been removed or deprecated?**\n\nList any features, integrations, or capabilities that have been removed or are being phased out.\n\n**6. Have you integrated new external services?**\n\na) **Payment Processing** - Stripe, PayPal, etc.  \nb) **Communication** - Email, SMS, notifications  \nc) **Analytics/Monitoring** - Tracking, logging services  \nd) **AI/ML Services** - LLMs, image processing, etc.  \ne) **Other** - Please specify  \nf) **None** - No new integrations\n\n### üöÄ Future Direction Questions\n\n**7. How has user feedback influenced changes?**\n\nDescribe any significant pivots or adjustments made based on user feedback or usage patterns.\n\n**8. What are your updated success metrics?**\n\nHave your KPIs or success measurements changed? Current focus:\n\n- User growth targets?\n- Revenue goals?\n- Engagement metrics?\n- Performance benchmarks?\n\n**9. What's the next major milestone?**\n\na) **Feature Release** - Specific new capability  \nb) **Scale Milestone** - User/revenue target  \nc) **Technical Goal** - Performance, security, architecture  \nd) **Business Goal** - Partnerships, funding, market expansion\n\n## Update Strategy\n\n### Incremental Updates\n\n- **Preserve:** Keep accurate existing content\n- **Enhance:** Add new information to existing sections\n- **Replace:** Update outdated or incorrect information\n- **Remove:** Mark deprecated features appropriately\n\n### Change Documentation\n\n- **New Features:** Add to relevant feature categories\n- **Modified Flows:** Update user journey descriptions\n- **Architecture Changes:** Reflect in system architecture section\n- **Business Evolution:** Update goals and success metrics\n\n### Consistency Maintenance\n\n- Keep the same professional, accessible tone\n- Maintain technology-agnostic descriptions\n- Focus on WHAT not HOW\n- Preserve document structure\n\n## Document Update Areas\n\n### Always Review:\n\n1. **Introduction**\n\n   - Update if purpose or audience has shifted\n   - Reflect any pivot in value proposition\n\n2. **Core Features**\n\n   - Add new feature categories if needed\n   - Update existing features with enhancements\n   - Mark removed features as deprecated\n\n3. **User Experience**\n\n   - Update user journeys with new flows\n   - Add new user personas if applicable\n   - Reflect UI/UX improvements\n\n4. **System Architecture**\n\n   - Add new integrations\n   - Update data flow diagrams\n   - Reflect new security patterns\n\n5. **Business Logic**\n\n   - Update rules and workflows\n   - Reflect new validation requirements\n   - Document new business constraints\n\n6. **Future Considerations**\n   - Update roadmap based on progress\n   - Add new planned features\n   - Reflect lessons learned\n\n## Execution Steps\n\n### 1. Start with Analysis\n\n```bash\n# Check when document was last updated\nstat -f \"%Sm\" .claude/rules/1-app-design-document.mdc\n\n# Review recent commits for feature changes\ngit log --oneline --since=\"30 days ago\" | head -20\n```\n\n**Think deeply about:** \"What has fundamentally changed in this application? How have new features altered the original vision? What patterns indicate architectural evolution?\"\n\n### 2. Interactive Q&A\n\n- **MUST ASK PROJECT STAGE FIRST**\n- Present all questions clearly\n- Wait for complete responses\n\n### 3. Update Project Status (if needed)\n\nIf stage or priorities changed, update both:\n\n```markdown\n# In `.claude/rules/3-project-status.mdc`\n\n## Project Status\n\n**Current Stage**: [New Stage]\n\n### DO Care About (Production-Ready Foundation)\n\n[Updated priorities]\n\n### DO NOT Care About (Skip for Velocity)\n\n[Updated items to skip]\n```\n\n### 4. Sync Document\n\n- Make targeted updates\n- Preserve document quality\n- Add version note if helpful:\n\n```markdown\n<!-- Last updated: [date] - Major changes: [summary] -->\n```\n\n### 5. Save and Backup\n\n```bash\n# Optional: Create backup\ncp .claude/rules/1-app-design-document.mdc .claude/rules/1-app-design-document.backup.mdc\n\n# Save updated document\n# Overwrite .claude/rules/1-app-design-document.mdc\n```\n\n## Key Principles\n\n### DO:\n\n- **Preserve Quality:** Maintain document's professional tone\n- **Incremental Updates:** Don't rewrite unnecessarily\n- **Clear Changes:** Make updates obvious and well-integrated\n- **User Focus:** Keep emphasis on user value\n- **Stage Awareness:** Align with current project maturity\n\n### DON'T:\n\n- **Complete Rewrite:** Unless fundamentally pivoted\n- **Technical Details:** Maintain high-level focus\n- **Break Structure:** Keep established organization\n- **Lose History:** Preserve context of major decisions\n- **Skip Analysis:** Always understand current state first\n\n## Output\n\n- **Format:** Markdown (`.mdc`)\n- **Location:** `.claude/rules/`\n- **Filename:** `1-app-design-document.mdc` (overwrites)\n- **Backup:** Suggest if major changes\n\n## Final Checklist\n\n1. ‚úÖ Read existing document completely\n2. ‚úÖ Analyze codebase changes thoroughly\n3. ‚úÖ Ask project stage question FIRST\n4. ‚úÖ Update `.claude/rules/3-project-status.mdc` if stage/priorities changed\n5. ‚úÖ Make incremental, targeted updates\n6. ‚úÖ Preserve document quality and tone\n7. ‚úÖ Suggest backup for major changes\n8. ‚úÖ Consider 2-tech-stack.mdc updates if needed\n",
        ".claude-plugin/plugins/dotai/commands/update-tech-stack.md": "---\nallowed-tools: Read, Glob, Grep, Write, MultiEdit, TodoWrite, Bash\ndescription: Update tech stack documentation based on dependency changes and technical evolution\n---\n\n# Update Tech Stack Documentation\n\n**User Request:** $ARGUMENTS\n\n## Context\n\n- Project root: !`pwd`\n- Package.json: @package.json\n- Current tech doc: @.claude/rules/2-tech-stack.mdc\n- Last modified: !`stat -f \"%Sm\" .claude/rules/2-tech-stack.mdc 2>/dev/null || echo \"No existing document\"`\n- Recent package changes: !`git diff HEAD~10 HEAD -- package.json 2>/dev/null | grep -E \"^[+-]\" | head -20 || echo \"No recent changes\"`\n\n## Goal\n\nUpdate the existing Tech Stack Documentation to reflect current technical state, dependency changes, new tools adoption, and infrastructure evolution. Maintain technical accuracy while documenting all changes.\n\n## Process\n\n### 1. Document Analysis\n\n- Read existing 2-tech-stack.mdc thoroughly\n- Note documented versions and configurations\n- Understand current technical baseline\n- Identify sections that may need updates\n\n### 2. Technical Change Detection\n\n**Think deeply about technical evolution in the codebase.**\n\nAnalyze for:\n\n- **Dependency Changes:** New packages, version updates, removals\n- **Framework Evolution:** Major version upgrades, breaking changes\n- **Tool Adoption:** New dev tools, linters, formatters, testing frameworks\n- **Infrastructure Shifts:** Deployment, hosting, monitoring changes\n- **Database Evolution:** Schema changes, new ORMs, migrations\n- **Integration Updates:** New APIs, services, authentication providers\n\n_Extended thinking helps identify cascading dependency updates, understand version compatibility issues, and recognize architectural implications of technical changes._\n\n### 3. Automated Comparison\n\n```bash\n# Compare current vs documented dependencies\n# Check for version mismatches\n# Identify new configuration files\n# Detect new tool configurations\n```\n\n### 4. Interactive Technical Q&A\n\nAsk targeted questions about:\n\n- Non-discoverable infrastructure changes\n- Deployment and hosting updates\n- New external service integrations\n- Workflow and process changes\n\n### 5. Update Documentation\n\nUpdate incrementally:\n\n- Preserve accurate technical information\n- Update version numbers precisely\n- Add new sections for major additions\n- Mark deprecated technologies\n\n### 6. Save and Verify\n\n- Suggest backup for major changes\n- Verify all versions are accurate\n\n## Technical Questions Template\n\n### üîÑ Version Updates & Dependencies\n\n**1. Which major dependencies have been updated?**\n\nReview your recent dependency changes:\n\na) **Framework upgrades** (Next.js, React, etc.) with breaking changes  \nb) **Tool updates** (TypeScript, ESLint, etc.) requiring config changes  \nc) **New dependencies** added for features or development  \nd) **Removed packages** that are no longer needed  \ne) **All of the above** - Major technical overhaul\n\n**2. Have you changed your package manager or Node version?**\n\na) **Same setup** - No changes to tooling  \nb) **Node upgrade** - Updated Node.js version  \nc) **Package manager switch** - Changed from npm/yarn/pnpm  \nd) **Monorepo adoption** - Moved to workspace setup\n\n### üèóÔ∏è Infrastructure Evolution\n\n**3. Have your deployment or hosting arrangements changed?**\n\nCurrent deployment is documented as: [show from existing doc]\n\na) **Same platform** - Just configuration updates  \nb) **Platform migration** - Moved to different provider  \nc) **Architecture change** - Serverless, containers, etc.  \nd) **Multi-region** - Expanded geographic deployment\n\n**4. Database or storage changes?**\n\na) **Version upgrade** - Same DB, newer version  \nb) **Migration** - Switched database systems  \nc) **New caching** - Added Redis, Memcached, etc.  \nd) **Storage addition** - New file storage, CDN  \ne) **No changes** - Same setup as before\n\n### üõ†Ô∏è Development Workflow Updates\n\n**5. New development tools or practices?**\n\nSelect all that apply:\n\n- [ ] New testing framework or strategy\n- [ ] Added code quality tools (linters, formatters)\n- [ ] CI/CD pipeline changes\n- [ ] Docker/containerization adoption\n- [ ] New build tools or bundlers\n- [ ] Performance monitoring tools\n\n**6. External service integrations?**\n\nHave you added or changed:\n\na) **Payment processing** - New or updated provider  \nb) **Authentication** - Different auth service  \nc) **Email/SMS** - Communication service changes  \nd) **Monitoring** - New error tracking or analytics  \ne) **APIs** - Additional third-party integrations  \nf) **None** - Same external services\n\n### üîê Security & Compliance\n\n**7. Security tool adoption?**\n\n- [ ] Vulnerability scanning (Snyk, etc.)\n- [ ] Secret management changes\n- [ ] New authentication methods\n- [ ] Compliance tools (GDPR, etc.)\n- [ ] Security headers/policies\n- [ ] None of the above\n\n## Update Strategy\n\n### Version Precision\n\n```typescript\n// ‚ùå Outdated\n\"next\": \"^13.0.0\"\n\n// ‚úÖ Current and precise\n\"next\": \"14.2.5\"\n```\n\n### Configuration Updates\n\n- Update all config examples to match current files\n- Include new configuration options\n- Remove deprecated settings\n- Add migration notes for breaking changes\n\n### New Technology Sections\n\nWhen adding major new tools:\n\n```markdown\n### [New Tool Category]\n\n**Tool:** [Name] [Version]\n**Purpose:** [Why it was adopted]\n**Configuration:** [Key settings]\n**Integration:** [How it connects with other tools]\n```\n\n## Document Update Areas\n\n### Always Check:\n\n1. **package.json changes**\n\n   ```bash\n   # Compare all dependencies\n   # Note version changes\n   # Identify new packages\n   ```\n\n2. **Configuration files**\n\n   - tsconfig.json updates\n   - New .config files\n   - Build tool configurations\n   - Linting rule changes\n\n3. **Development scripts**\n\n   - New npm/pnpm scripts\n   - Changed command purposes\n   - Removed scripts\n\n4. **Infrastructure files**\n   - Dockerfile changes\n   - CI/CD workflows\n   - Deployment configs\n   - Environment examples\n\n### Conditional Updates:\n\n- **Architecture:** Only if fundamental changes\n- **Conventions:** Only if standards changed\n\n## Execution Steps\n\n### 1. Start with Analysis\n\n```bash\n# Check current dependencies vs documented\ndiff <(jq -r '.dependencies | keys[]' package.json | sort) \\\n     <(grep -E '^\\*\\*.*:' .claude/rules/2-tech-stack.mdc | cut -d: -f1 | sed 's/\\*//g' | sort)\n\n# Review recent dependency commits\ngit log --oneline --grep=\"dep\" --since=\"30 days ago\"\n\n# Check for new config files\nfind . -name \"*.config.*\" -newer .claude/rules/2-tech-stack.mdc 2>/dev/null\n```\n\n**Think deeply about:** \"What technical decisions drove these changes? How do version updates affect the overall architecture? What new capabilities do these tools enable?\"\n\n### 2. Interactive Q&A\n\n- Present technical questions clearly\n- Include current state from documentation\n- Wait for detailed responses\n\n### 3. Update Documentation\n\nFollow incremental approach:\n\n```markdown\n<!-- Version update example -->\n\n**Before:** React 18.2.0\n**After:** React 18.3.1 - Includes new compiler optimizations\n\n<!-- New tool example -->\n\n### Code Quality Tools\n\n**New Addition:**\n\n- **Biome:** 1.8.3 - Replaced ESLint and Prettier\n  - Faster performance (10x)\n  - Single configuration file\n  - Built-in formatting\n```\n\n### 4. Save and Backup\n\n```bash\n# Optional backup\ncp .claude/rules/2-tech-stack.mdc .claude/rules/2-tech-stack.backup.md\n\n# Save updated document\n# Overwrite .claude/rules/2-tech-stack.mdc\n```\n\n## Key Principles\n\n### DO:\n\n- **Exact Versions:** Use precise version numbers from lock files\n- **Config Accuracy:** Match actual configuration files\n- **Change Rationale:** Explain why tools were adopted/changed\n- **Migration Notes:** Document breaking changes and updates\n- **Performance Impact:** Note improvements or concerns\n\n### DON'T:\n\n- **Generic Updates:** Avoid vague version ranges\n- **Assumption:** Verify every technical detail\n- **Old Information:** Remove outdated configurations\n- **Wishful Documentation:** Only document what exists\n- **Sensitive Data:** Never include secrets or keys\n\n## Output\n\n- **Format:** Markdown (`.mdc`)\n- **Location:** `.claude/rules/`\n- **Filename:** `2-tech-stack.mdc` (overwrites)\n- **Backup:** Suggest for major changes\n\n## Final Checklist\n\n1. ‚úÖ Read existing 2-tech-stack.mdc completely\n2. ‚úÖ Analyze all dependency changes\n3. ‚úÖ Check configuration file updates\n4. ‚úÖ Review infrastructure changes\n5. ‚úÖ Ask targeted technical questions\n6. ‚úÖ Update with exact versions\n7. ‚úÖ Include configuration examples\n8. ‚úÖ Suggest backup if major changes\n9. ‚úÖ Verify technical accuracy\n",
        ".claude-plugin/plugins/git/.claude-plugin/plugin.json": "{\n  \"name\": \"git\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Git and GitHub workflow automation - streamlined PR creation, draft management, and code review workflows\",\n  \"author\": {\n    \"name\": \"zbeyens\"\n  },\n  \"keywords\": [\"git\", \"github\", \"pr\", \"pull-request\", \"review\", \"workflow\"]\n}",
        ".claude-plugin/plugins/git/README.md": "# Git Plugin\n\n> Git and GitHub workflow automation for streamlined PR management\n\n## Overview\n\nThe Git plugin provides comprehensive tools for managing Git workflows and GitHub pull requests. It streamlines the PR creation process, code review workflows, draft PR management, and standardized commit practices.\n\n## Features\n\n### üîÄ Pull Request Creation\n\nFull PR workflow with comprehensive descriptions:\n\n- **Branch management** - Conventional branch naming and switching\n- **Smart staging** - Analyze and stage changes appropriately\n- **Meaningful commits** - Conventional commit messages\n- **Update comments** - Preserve original PR description\n- **Ready for review** - PRs created in review-ready state\n\n### üìù Draft PR Management\n\nEfficient draft PR workflow without reviews:\n\n- **Work-in-progress** - Create drafts for ongoing work\n- **Progressive updates** - Keep pushing to the same draft\n- **Ready for review** - Mark as ready when complete\n- **No auto-review** - Reviews only when requested\n\n### üîç Code Review\n\nComprehensive PR review capabilities:\n\n- **Full or incremental** - Review entire PR or just latest changes\n- **Severity ratings** - Critical, Major, Minor, Suggestion classifications\n- **Constructive feedback** - Specific, actionable recommendations\n- **Review templates** - Structured review comments with clear formatting\n- **GitHub integration** - Approve, request changes, or comment only\n\n## Installation\n\n```bash\n/plugin install git@dotai\n# restart claude\n```\n\n## Skills\n\n### create-pr\n\nCreate or update PR with comprehensive descriptions and meaningful commits.\n\n**When to use:** Creating or updating pull requests with comprehensive descriptions\n\n**Triggers:** PR creation, feature complete, ready to merge\n\n**Key Features:**\n- Branch management and switching\n- Conventional commit messages\n- Update comment templates\n- PR description generation\n\n### draft-pr\n\nCreate or update draft PR without code review for work-in-progress.\n\n**When to use:** Creating work-in-progress PRs without review\n\n**Triggers:** WIP changes, early feedback needed, progressive development\n\n**Key Features:**\n- Draft PR management\n- Update comment templates\n- No automatic reviews\n- Ready for review workflow\n\n### review-pr\n\nReview pull request with comprehensive code analysis and constructive feedback.\n\n**When to use:** Reviewing pull requests with comprehensive code analysis\n\n**Triggers:** PR needs review, code quality check, post-merge review\n\n**Key Features:**\n- Full or incremental review options\n- Severity-based issue classification\n- Review checklist and principles\n- GitHub review integration\n- Structured review templates\n\n## Workflow Examples\n\n### Creating a PR\n\n```bash\n# 1. Make changes on feature branch\n# 2. Use command\ncreate-pr\n# 3. Automatically:\n#    - Stages all changes\n#    - Creates meaningful commit\n#    - Pushes to remote\n#    - Creates PR with description\n```\n\n### Reviewing a PR\n\n```bash\n# 1. Identify PR to review\n# 2. Use command\nreview-pr\n# 3. Choose review type:\n#    - Full review of entire PR\n#    - Incremental review of latest changes\n# 4. Review posts with:\n#    - Issue classification by severity\n#    - Constructive feedback\n#    - GitHub status update\n```\n\n### Creating a Draft PR\n\n```bash\n# 1. Make WIP changes\n# 2. Use command\ndraft-pr\n# 3. Automatically:\n#    - Stages changes\n#    - Commits with conventional message\n#    - Creates draft PR\n#    - No review performed\n```\n\n### Updating Existing PR\n\n```bash\n# 1. Make additional changes\n# 2. Use same command\ncreate-pr  # or draft-pr\n# 3. Automatically:\n#    - Commits new changes\n#    - Pushes to existing PR\n#    - Adds update comment\n```\n\n## Commit Message Conventions\n\nThe plugin follows conventional commit format:\n\n- `feat:` - New features\n- `fix:` - Bug fixes\n- `refactor:` - Code refactoring\n- `docs:` - Documentation changes\n- `test:` - Test additions/modifications\n- `chore:` - Maintenance tasks\n- `style:` - Formatting changes\n\n## Branch Naming Conventions\n\n- `feature/description` - New features\n- `fix/bug-description` - Bug fixes\n- `refactor/component-name` - Code refactoring\n- `docs/update-readme` - Documentation updates\n- `test/add-unit-tests` - Test additions\n\n## Review Principles\n\nWhen using review-pr, reviews follow these principles:\n\n1. **Pull existing comments** - Don't repeat feedback\n2. **Focus on new changes** - Incremental reviews when appropriate\n3. **Be constructive** - Specific, actionable feedback\n4. **Rate severity** - Critical, Major, Minor, Suggestion\n5. **Professional emoji** - ‚úÖ ‚ö†Ô∏è üö® üí° used sparingly\n\n## Update Comment Templates\n\nBoth commands use update comments to preserve original PR descriptions:\n\n### PR Update\n- Changes made\n- Impact analysis\n- Testing instructions\n- Next steps\n\n### Critical Fix\n- Issue addressed\n- Solution approach\n- Verification steps\n- Risk assessment\n\n### Feature Enhancement\n- Enhancement details\n- Technical implementation\n- User experience impact\n- Testing strategy\n\n## Best Practices\n\n1. **Single commit per push** - Due to Husky hooks\n2. **Stage all changes** - Use `git add .`\n3. **Preserve PR descriptions** - Use update comments\n4. **Clear commit messages** - Follow conventions\n5. **Branch naming** - Use standard prefixes\n6. **Draft for WIP** - Use draft-pr for ongoing work\n7. **Ready for review** - Convert draft when complete\n8. **Separate reviews** - Use review-pr for code review\n\n## GitHub CLI Integration\n\nThe plugin uses GitHub CLI (`gh`) for all GitHub operations:\n\n```bash\n# Required: GitHub CLI installed and authenticated\ngh auth status  # Check authentication\n```\n\n## Integration\n\nWorks seamlessly with other dotai plugins:\n\n- **dotai** - Use after implementing features\n- **debug** - Fix issues before creating PRs\n- **test** - Ensure tests pass before PR\n\n## Common Workflows\n\n### Feature Development\n\n```bash\n# 1. Implement feature\n# ... make changes ...\n\n# 2. Create PR\ncreate-pr\n```\n\n### Bug Fix\n\n```bash\n# 1. Debug issue\n/debug:debug\n\n# 2. Fix bug\n# ... apply fix ...\n\n# 3. Create PR\ncreate-pr\n```\n\n### Progressive Development\n\n```bash\n# 1. Start with draft\ndraft-pr\n\n# 2. Keep updating\n# ... make changes ...\ndraft-pr  # adds update\n\n# 3. Mark ready\ngh pr ready\n\n# 4. Request review\nreview-pr\n```\n\n### Code Review Workflow\n\n```bash\n# 1. Find PR to review\ngh pr list\n\n# 2. Review the PR\nreview-pr\n\n# 3. Follow up on changes\n# ... after author updates ...\nreview-pr  # incremental review\n```\n\n## Troubleshooting\n\n### PR Not Creating\n\n- Check branch: Not on main/master\n- Check auth: `gh auth status`\n- Check remote: `git remote -v`\n\n### Review Not Posting\n\n- Check PR exists: `gh pr view <number>`\n- Verify GitHub auth: `gh auth status`\n- Check PR permissions\n\n### Update Comment Missing\n\n- Check PR number: `gh pr view`\n- Verify changes pushed\n- Check comment permissions",
        ".claude-plugin/plugins/git/skills/create-pr/SKILL.md": "---\nname: create-pr\ndescription: Use when creating or updating pull requests with comprehensive descriptions and meaningful commits - streamlines PR workflow with branch management and commit best practices\n---\n\nYou are an expert Git and GitHub workflow automation specialist with deep knowledge of version control best practices and pull request management. Your primary responsibility is streamlining the pull request creation process, ensuring high-quality commits with meaningful descriptions.\n\n## Common Operations\n\n### GitHub CLI Commands Reference\n\n```bash\n# PR Management\ngh pr view                                    # View current branch PR\ngh pr list                                    # List open PRs\ngh pr view <number> --json number -q .number # Get PR number\ngh pr create --title \"\" --body \"\"            # Create new PR\ngh pr edit --body \"\"                         # Update description\ngh pr edit --add-label \"\"                    # Add labels\n\n# Git Commands\ngit branch --show-current                    # Current branch\ngit status                                   # Check changes\ngit diff                                     # View unstaged changes\ngit diff --cached                           # View staged changes\ngit diff HEAD~1..HEAD                       # Last commit diff\ngit rev-parse HEAD                          # Get commit SHA\ngit log -1 --pretty=%s                      # Last commit message\n```\n\n## Workflow\n\n### Creating/Updating Pull Requests\n\n1. **Branch Management**:\n\n   - Check current branch: `git branch --show-current`\n   - If on main/master/next, create feature branch with conventional naming\n   - Switch to new branch: `git checkout -b branch-name`\n\n2. **Analyze & Stage**:\n\n   - Review changes: `git status` and `git diff`\n   - Identify change type (feature, fix, refactor, docs, test, chore)\n   - Stage ALL changes: `git add .` (preferred due to slow Husky hooks)\n   - Verify: `git diff --cached`\n\n3. **Commit & Push**:\n\n   - **Single Commit Strategy**: Use one comprehensive commit per push due to slow Husky hooks\n   - Format: `type: brief description` (simple format preferred)\n   - Commit: `git commit -m \"type: description\"` with average git comment\n   - Push: `git push -u origin branch-name`\n\n4. **PR Management**:\n\n   - Check existing: `gh pr view`\n   - If exists: push updates, **add update comment** (preserve original description)\n   - If not: `gh pr create` with title and description\n\n## Update Comment Templates\n\nWhen updating existing PRs, use these comment templates to preserve the original description:\n\n### General PR Update Template\n\n```markdown\n## üîÑ PR Update\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Changes Made\n\n- [List specific changes in this update]\n- [Highlight any breaking changes]\n- [Note new features or fixes]\n\n### Impact\n\n- [Areas of code affected]\n- [Performance/behavior changes]\n- [Dependencies updated]\n\n### Testing\n\n- [How to test these changes]\n- [Regression testing notes]\n\n### Next Steps\n\n- [Remaining work if any]\n- [Items for review focus]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Critical Fix Update Template\n\n```markdown\n## üö® Critical Fix Applied\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Issue Addressed\n\n[Description of critical issue fixed]\n\n### Solution\n\n[Technical approach taken]\n\n### Verification Steps\n\n1. [Step to reproduce original issue]\n2. [Step to verify fix]\n3. [Regression test steps]\n\n### Risk Assessment\n\n- **Impact**: [Low/Medium/High]\n- **Scope**: [Files/features affected]\n- **Backwards Compatible**: [Yes/No - details if no]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Feature Enhancement Template\n\n```markdown\n## ‚ú® Feature Enhancement\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Enhancement Details\n\n[Description of feature improvement/addition]\n\n### Technical Implementation\n\n- [Key architectural decisions]\n- [New dependencies or patterns]\n- [Performance considerations]\n\n### User Experience Impact\n\n[How this affects end users]\n\n### Testing Strategy\n\n[Approach to testing this enhancement]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n## Example Usage Patterns\n\n### Creating PR:\n\n1. Create branch and make changes\n2. Stage, commit, push ‚Üí triggers PR creation\n3. Each subsequent push triggers update comment\n\n### Commit Message Conventions\n\n- `feat:` - New features\n- `fix:` - Bug fixes\n- `refactor:` - Code refactoring\n- `docs:` - Documentation changes\n- `test:` - Test additions/modifications\n- `chore:` - Maintenance tasks\n- `style:` - Formatting changes\n\n### Branch Naming Conventions\n\n- `feature/description` - New features\n- `fix/bug-description` - Bug fixes\n- `refactor/component-name` - Code refactoring\n- `docs/update-readme` - Documentation updates\n- `test/add-unit-tests` - Test additions",
        ".claude-plugin/plugins/git/skills/draft-pr/SKILL.md": "---\nname: draft-pr\ndescription: Use when creating or updating draft pull requests without code review - streamlines draft PR workflow with meaningful descriptions and commit messages, focusing on work-in-progress documentation\n---\n\nYou are an expert Git and GitHub workflow automation specialist focused on streamlining draft pull request creation and management. Your primary responsibility is creating high-quality draft PRs with meaningful descriptions and commit messages, without performing code reviews.\n\n## Key Behavior: Draft PR Management\n\n**FOCUS**: Create and update draft pull requests efficiently without automatic reviews. Reviews should only be performed when explicitly requested.\n\n## Common Operations\n\n### GitHub CLI Commands Reference\n\n```bash\n# PR Management\ngh pr view                                    # View current branch PR\ngh pr list                                    # List open PRs\ngh pr view <number> --json number -q .number # Get PR number\ngh pr create --draft --title \"\" --body \"\"    # Create new draft PR\ngh pr ready <number>                          # Mark PR as ready for review\ngh pr edit --body \"\"                         # Update description\ngh pr edit --add-label \"\"                    # Add labels\n\n# Git Commands\ngit branch --show-current                    # Current branch\ngit status                                   # Check changes\ngit diff                                     # View unstaged changes\ngit diff --cached                           # View staged changes\ngit diff HEAD~1..HEAD                       # Last commit diff\ngit rev-parse HEAD                          # Get commit SHA\ngit log -1 --pretty=%s                      # Last commit message\n```\n\n## Workflow: Creating/Updating Draft PRs\n\n### 1. Branch Management\n\n- Check current branch: `git branch --show-current`\n- If on main/master/next, create feature branch with conventional naming\n- Switch to new branch: `git checkout -b branch-name`\n\n### 2. Analyze & Stage Changes\n\n- Review changes: `git status` and `git diff`\n- Identify change type (feature, fix, refactor, docs, test, chore)\n- Stage ALL changes: `git add .` (preferred due to slow Husky hooks)\n- Verify: `git diff --cached`\n\n### 3. Commit & Push\n\n- **Single Commit Strategy**: Use one comprehensive commit per push due to slow Husky hooks\n- Format: `type: brief description` (simple format preferred)\n- Commit: `git commit -m \"type: description\"` with average git comment\n- Push: `git push -u origin branch-name`\n\n### 4. Draft PR Management\n\n- Check existing: `gh pr view`\n- If exists: push updates, **add update comment** (preserve original description)\n- If not: `gh pr create --draft` with comprehensive title and description\n\n## PR Description Template\n\nUse this template for creating comprehensive draft PR descriptions:\n\n```markdown\n## Summary\n\n[Brief description of what this PR accomplishes]\n\n## Changes Made\n\n- [List key changes made]\n- [Include file modifications]\n- [Highlight new features/fixes]\n\n## Technical Details\n\n- [Implementation approach]\n- [Key architectural decisions]\n- [Dependencies added/removed]\n\n## Testing\n\n- [How to test the changes]\n- [Test cases covered]\n- [Manual testing steps]\n\n## Screenshots/Demo\n\n[If applicable, include screenshots or demo links]\n\n## Checklist\n\n- [ ] Tests pass\n- [ ] Documentation updated\n- [ ] Ready for review\n\n## Notes\n\n[Any additional context, considerations, or follow-up items]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n## Update Comment Templates\n\nWhen updating existing draft PRs, use these comment templates instead of editing the original description:\n\n### New Commit Update Template\n\n```markdown\n## üìù Draft PR Update\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Changes Made\n\n- [List specific changes in this commit]\n- [Highlight new features/fixes added]\n- [Note any breaking changes]\n\n### Status\n\n- [Current implementation status]\n- [Remaining work items]\n- [Any blockers or questions]\n\n### Testing\n\n- [How to test the new changes]\n- [Updated test instructions if needed]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Feature Addition Template\n\n```markdown\n## ‚ú® Feature Added\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### New Feature\n\n[Description of the feature added]\n\n### Implementation Details\n\n- [Key technical decisions]\n- [Files modified/added]\n- [Dependencies changed]\n\n### Testing Instructions\n\n[How to test the new feature]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Bug Fix Template\n\n```markdown\n## üêõ Bug Fix Applied\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Issue Fixed\n\n[Description of the bug that was fixed]\n\n### Root Cause\n\n[What caused the issue]\n\n### Solution\n\n[How it was resolved]\n\n### Verification\n\n[How to verify the fix works]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n## Commit Message Conventions\n\nFollow conventional commit format:\n\n- `feat:` new features\n- `fix:` bug fixes\n- `refactor:` code refactoring\n- `docs:` documentation changes\n- `test:` test additions/modifications\n- `chore:` maintenance tasks\n- `style:` formatting changes\n\n## Example Usage\n\n### Creating a new draft PR:\n\n1. Make changes on feature branch\n2. Stage and commit with conventional message\n3. Push changes: `git push -u origin feature-branch`\n4. Create draft PR: `gh pr create --draft --title \"feat: add new feature\" --body \"$(cat description.md)\"`\n\n### Updating existing draft PR:\n\n1. Make additional changes\n2. Commit and push\n3. **Add update comment**: `gh pr comment <pr-number> --body \"$(cat update-comment.md)\"`\n4. Use appropriate template based on change type (feature, fix, general update)\n\n### Making PR ready for review:\n\n1. Ensure all changes are complete\n2. Run final tests\n3. Mark as ready: `gh pr ready`\n\n## Draft PR Best Practices\n\n- **Clear Titles**: Use descriptive, action-oriented titles\n- **Comprehensive Descriptions**: Include context, changes, and testing info (preserve original)\n- **Progressive Updates**: Keep pushing improvements to the same draft\n- **Update Comments**: Add comments for each significant update instead of editing description\n- **Change History**: Use update comment templates to track evolution of changes\n- **Testing Notes**: Always include how to test the changes (in comments for updates)\n- **Screenshots**: Add visuals for UI changes\n- **Dependencies**: Note any new packages or breaking changes\n- **Preserve Context**: Keep original PR description intact for reference\n\n## Branch Naming Conventions\n\n- `feature/description` - New features\n- `fix/bug-description` - Bug fixes\n- `refactor/component-name` - Code refactoring\n- `docs/update-readme` - Documentation updates\n- `test/add-unit-tests` - Test additions\n\n## Labels and Metadata\n\nCommon labels to add:\n\n- `draft` - Work in progress\n- `feature` - New functionality\n- `bug` - Bug fixes\n- `enhancement` - Improvements\n- `documentation` - Docs updates\n- `breaking-change` - Breaking changes\n\nUse `gh pr edit --add-label \"label-name\"` to add labels.",
        ".claude-plugin/plugins/git/skills/review-pr/SKILL.md": "---\nname: review-pr\ndescription: Use when reviewing pull requests with comprehensive code analysis, incremental or full review options, and constructive feedback - provides thorough code reviews with severity ratings\n---\n\nYou are an expert code reviewer with deep knowledge of software quality, best practices, and pull request management. Your primary responsibility is providing thorough, constructive code reviews that improve code quality while maintaining development velocity.\n\n## Review Principles\n\n- Pull ALL existing comments before reviewing\n- Don't repeat previously given feedback\n- Focus on new changes in incremental reviews\n- Be constructive and specific\n- Provide code examples for improvements\n- Rate issues by severity (Critical, Major, Minor, Suggestion)\n- Use professional emoji sparingly (‚úÖ, ‚ö†Ô∏è, üö®, üí°)\n- Keep review concise but thorough\n- Format with clear sections and bullet points\n\n## Review Checklist\n\n- [ ] Code correctness and functionality\n- [ ] Following project conventions and standards\n- [ ] Adequate test coverage\n- [ ] Documentation updates where needed\n- [ ] Security considerations and vulnerabilities\n- [ ] Performance implications\n- [ ] Backward compatibility\n- [ ] Clear commit messages and PR description\n- [ ] Code quality and style consistency\n- [ ] Potential issues or risks identified\n\n## GitHub CLI Commands Reference\n\n```bash\n# PR Info\ngh pr view <number>                          # View PR details\ngh pr view <number> --json number,title,body,files  # Get PR metadata\ngh pr diff <number>                          # Get full PR diff\n\n# Comments\ngh pr view <number> --comments               # View existing comments\ngh api repos/{owner}/{repo}/pulls/<number>/comments     # Get inline comments\ngh api repos/{owner}/{repo}/issues/<number>/comments    # Get issue comments\ngh pr comment <number> --body \"\"             # Post comment\n\n# Review Actions\ngh pr review <number> --approve --body \"\"    # Approve PR\ngh pr review <number> --request-changes --body \"\"       # Request changes\ngh pr review <number> --comment --body \"\"    # Comment without approval\n\n# Git Commands\ngit diff HEAD~1..HEAD                        # Last commit diff\ngit rev-parse HEAD                           # Get commit SHA\ngit log -1 --pretty=%s                      # Last commit message\ngit log --oneline -n 5                      # Recent commits\n```\n\n## Workflow\n\n### Parameters\n\n- `pr_number`: PR number to review (required)\n- `incremental`: true for reviewing only latest changes, false for full review (default: false)\n\n### Step 1: Gather Context\n\nAlways pull existing comments first to avoid duplication:\n\n```bash\n# Get PR info\ngh pr view <pr_number> --json number,title,body,files\n\n# Pull ALL comments (always do this first)\ngh pr view <pr_number> --comments\ngh api repos/{owner}/{repo}/pulls/<pr_number>/comments\n\n# Get appropriate diff\nif incremental:\n  git diff HEAD~1..HEAD  # Latest commit only\nelse:\n  gh pr diff <pr_number>  # Full PR diff\n```\n\n### Step 2: Analyze Changes\n\n- For incremental: Focus ONLY on new changes\n- For full: Consider entire PR but acknowledge existing comments\n- Check against review checklist\n- Note resolved vs new issues\n- Identify patterns and systemic issues\n\n### Step 3: Post Review\n\nUse appropriate template based on review type:\n\n#### Incremental Review Template\n\n```bash\ngh pr comment <pr_number> --body \"$(cat <<'EOF'\n## üîÑ Incremental Review - Latest Changes\n\n**Commit**: $(git rev-parse --short HEAD) - $(git log -1 --pretty=%s)\n**Scope**: [Files changed in this commit only]\n\n### ‚úÖ What's Good\n[Positive aspects of the changes]\n\n### üìù Review Findings\n\n#### üö® Critical Issues\n[Security vulnerabilities, data loss risks, breaking changes]\n\n#### ‚ö†Ô∏è Major Issues\n[Performance problems, logic errors, architectural concerns]\n\n#### üìù Minor Issues\n[Code style, missing docs, naming conventions]\n\n#### üí° Suggestions\n[Optional improvements, refactoring opportunities]\n\n### Recommendations\n[Specific next steps if any issues found]\n\n### Status\n‚úÖ Changes approved / ‚ö†Ô∏è Minor suggestions / üö® Issues to address\n\n*Reviewed: $(git rev-parse HEAD)*\nEOF\n)\"\n```\n\n#### Full Review Template\n\n```bash\ngh pr comment <pr_number> --body \"$(cat <<'EOF'\n## üîç Code Review: PR #<pr_number>\n\n### üìä Overview\n**Files Changed**: [X files]\n**Lines**: +[additions] -[deletions]\n\n[High-level summary of the PR's purpose and approach]\n\n### ‚úÖ Strengths\n[What the PR does well]\n\n### üìù Review Findings\n\n#### üö® Critical Issues\n[Security vulnerabilities, data loss risks, breaking changes]\n\n#### ‚ö†Ô∏è Major Issues\n[Performance problems, logic errors, architectural concerns]\n\n#### üìù Minor Issues\n[Code style, missing docs, naming conventions]\n\n#### üí° Suggestions\n[Optional improvements, refactoring opportunities]\n\n### üìö Documentation\n[Comments on docs, README updates, API changes]\n\n### üß™ Testing\n[Test coverage, test quality, missing test cases]\n\n### Recommendations\n1. [Specific actionable feedback]\n2. [Prioritized list of changes needed]\n\n### Status\n‚úÖ Approved / ‚ö†Ô∏è Approved with suggestions / üö® Changes requested\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\nEOF\n)\"\n```\n\n### Step 4: Update PR Status\n\nBased on review findings:\n\n```bash\n# Approve if all good\ngh pr review <pr_number> --approve --body \"LGTM! [summary]\"\n\n# Request changes if critical/major issues\ngh pr review <pr_number> --request-changes --body \"[summary of required changes]\"\n\n# Comment only for suggestions\ngh pr review <pr_number> --comment --body \"[suggestions without blocking]\"\n\n# Add labels\ngh pr edit <pr_number> --add-label \"needs-review\"\ngh pr edit <pr_number> --add-label \"approved\"\n```\n\n## Review Severity Guidelines\n\n### üö® Critical (Must Fix)\n- Security vulnerabilities\n- Data loss or corruption risks\n- Breaking API changes without migration\n- Hard crashes or infinite loops\n- Exposed secrets or credentials\n\n### ‚ö†Ô∏è Major (Should Fix)\n- Performance degradation\n- Logic errors affecting functionality\n- Missing error handling\n- Architectural violations\n- Backwards compatibility issues\n\n### üìù Minor (Consider Fixing)\n- Code style inconsistencies\n- Missing or outdated documentation\n- Unclear variable/function names\n- Missing type annotations\n- Non-optimal but working code\n\n### üí° Suggestions (Optional)\n- Refactoring opportunities\n- Alternative approaches\n- Future improvements\n- Nice-to-have features\n- Performance optimizations\n\n## Best Practices\n\n1. **Be Specific**: Point to exact lines and provide examples\n2. **Be Constructive**: Suggest solutions, not just problems\n3. **Acknowledge Good Work**: Highlight well-done aspects\n4. **Prioritize Issues**: Focus on critical/major issues first\n5. **Consider Context**: Understand project constraints and deadlines\n6. **Batch Feedback**: Group related issues together\n7. **Use Examples**: Show code snippets for suggested changes\n8. **Stay Professional**: Keep tone respectful and helpful\n\n## Example Usage Patterns\n\n### Quick Incremental Review\n\nFor reviewing just the latest commit on an existing PR:\n\n```bash\n# Review latest commit only\nincremental=true\npr_number=123\n\n# Quick focused review of new changes\ngh pr diff HEAD~1..HEAD\n# Post incremental review comment\n```\n\n### Comprehensive Full Review\n\nFor thorough review of entire PR:\n\n```bash\n# Full PR review\nincremental=false\npr_number=123\n\n# Analyze entire diff\ngh pr diff 123\n# Check test coverage\n# Review documentation\n# Post comprehensive review\n```\n\n### Review After Updates\n\nWhen PR author has addressed previous feedback:\n\n```bash\n# Check what was previously requested\ngh pr view 123 --comments\n\n# Review new commits since last review\ngit log --oneline -n 5\n\n# Verify issues are resolved\n# Post follow-up review\n```",
        ".claude-plugin/plugins/learn/.claude-plugin/plugin.json": "{\n  \"name\": \"learn\",\n  \"version\": \"3.0.0\",\n  \"description\": \"Continuous learning system - extracts reusable knowledge from work sessions into Claude Code skills\"\n}\n",
        ".claude-plugin/plugins/learn/README.md": "# Learn Plugin\n\n> Continuous learning system - extracts reusable knowledge from work sessions into Claude Code skills\n\n## Overview\n\nThe Learn plugin provides a continuous learning system that extracts reusable knowledge from work sessions and codifies it into new Claude Code skills. This enables autonomous improvement over time.\n\n## Features\n\n### Skill Extraction\n\nExtract valuable knowledge into reusable skills:\n\n- **Non-obvious Solutions** - Debugging techniques, workarounds requiring investigation\n- **Project-Specific Patterns** - Conventions and architectural decisions\n- **Tool Integration** - API usage not covered well in documentation\n- **Error Resolution** - Error messages ‚Üí root causes ‚Üí fixes\n\n### TDD-Based Extraction\n\nFollows Test-Driven Development discipline:\n\n- **RED** - Problem already encountered during work\n- **GREEN** - Write skill addressing that specific problem\n- **REFACTOR** - Verify skill clarity, iterate if needed\n\n### Claude Search Optimization (CSO)\n\nSkills are optimized for discovery:\n\n- Specific trigger conditions in descriptions\n- Keyword coverage for searchability\n- Token-efficient content\n\n## Installation\n\n```bash\n/plugin install learn@dotai\n# restart claude\n```\n\n## Skills\n\n### learn\n\nAuto-invoked skill that reviews session learnings and extracts reusable skills.\n\n**Triggers:**\n\n- `/learn` command to review session\n- \"save this as a skill\" or \"extract a skill\"\n- \"what did we learn?\"\n- After non-obvious debugging or workarounds\n\n## Skill Quality Criteria\n\nBefore extracting, verify:\n\n- **Reusable** - Helps with future tasks\n- **Non-trivial** - Requires discovery, not just docs\n- **Specific** - Exact trigger conditions and solution\n- **Verified** - Solution actually worked\n\n## Skill Types\n\n- **Technique** - Concrete method with steps (debugging patterns)\n- **Pattern** - Mental model for problem-solving\n- **Reference** - API docs, syntax guides\n- **Error Resolution** - Error ‚Üí cause ‚Üí fix mapping\n\n## Extraction Process\n\n1. **Identify** - What was non-obvious about the solution?\n2. **Research** - Search web for best practices when appropriate\n3. **Structure** - Save to `.claude/rules/[skill-name].mdc` (if `.claude/skiller.toml` exists) or `.claude/skills/[skill-name]/SKILL.md` otherwise\n4. **Optimize** - Write effective descriptions for discovery\n5. **Deploy** - Run `npx skiller@latest apply`\n\n## Skill Template\n\n```markdown\n---\nname: skill-name-with-hyphens\ndescription: |\n  Use when [specific triggering conditions]. Triggers: (1) exact symptom,\n  (2) error message, (3) scenario. [What problem this solves.]\n---\n\n# [Skill Name]\n\n## Problem\n\n[Clear description of the problem]\n\n## Context / Trigger Conditions\n\n[When should this skill be used?]\n\n## Solution\n\n[Step-by-step solution]\n\n## Verification\n\n[How to verify it worked]\n\n## Notes\n\n[Caveats, edge cases]\n\n## References\n\n[Links to documentation]\n```\n\n## Auto-Trigger Conditions\n\nInvoke after completing a task when:\n\n1. Solution required >10 min investigation\n2. Error message was misleading\n3. Found workaround through experimentation\n4. Discovered project-specific setup\n5. Tried multiple approaches before success\n\n## Integration\n\nWorks seamlessly with other dotai plugins:\n\n- **debug** - Extract debugging discoveries\n- **test** - Document testing patterns\n- **git** - Capture workflow insights\n\n## Best Practices\n\n1. **Be selective** - Not every task produces a skill\n2. **Verify first** - Only extract what actually worked\n3. **Optimize descriptions** - Include trigger conditions\n4. **Research when appropriate** - Add web sources as references\n5. **Keep skills focused** - One problem per skill\n\n## Credits\n\nInspired by [Claudeception](https://github.com/blader/Claudeception).\n",
        ".claude-plugin/plugins/learn/skills/learn/SKILL.md": "---\nname: learn\ndescription: |\n  Continuous learning system that extracts reusable knowledge from work sessions.\n  Triggers: (1) /learn command to review session learnings, (2) \"save this as a skill\"\n  or \"extract a skill from this\", (3) \"what did we learn?\", (4) After any task involving\n  non-obvious debugging, workarounds, or trial-and-error discovery. Creates new Claude Code\n  skills when valuable, reusable knowledge is identified.\nversion: 3.0.0\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Grep\n  - Glob\n  - WebSearch\n  - WebFetch\n  - Skill\n  - AskUserQuestion\n  - TodoWrite\n---\n\n# Learn\n\nA continuous learning system that extracts reusable knowledge from work sessions and\ncodifies it into new Claude Code skills. This enables autonomous improvement over time.\n\n## Core Principle: Skill Extraction\n\nWhen working on tasks, continuously evaluate whether the current work contains extractable\nknowledge worth preserving. Not every task produces a skill‚Äîbe selective about what's truly\nreusable and valuable.\n\n## TDD Mapping for Skill Extraction\n\nSkill extraction follows the same discipline as Test-Driven Development:\n\n| TDD Concept         | Skill Extraction                                   |\n| ------------------- | -------------------------------------------------- |\n| **Test case**       | The problem/failure pattern you just encountered   |\n| **Production code** | The skill document (.mdc file)                     |\n| **RED**             | You hit the problem during work (already happened) |\n| **GREEN**           | Write skill addressing that specific problem       |\n| **REFACTOR**        | Verify skill clarity, iterate if needed            |\n\nThe key insight: When extracting from a session, the RED phase already happened‚Äîyou discovered something non-obvious. Now write the skill (GREEN) and verify it (REFACTOR).\n\n## When to Extract a Skill\n\nExtract a skill when you encounter:\n\n1. **Non-obvious Solutions**: Debugging techniques, workarounds, or solutions that required\n   significant investigation and wouldn't be immediately apparent to someone facing the same\n   problem.\n\n2. **Project-Specific Patterns**: Conventions, configurations, or architectural decisions\n   specific to this codebase that aren't documented elsewhere.\n\n3. **Tool Integration Knowledge**: How to properly use a specific tool, library, or API in\n   ways that documentation doesn't cover well.\n\n4. **Error Resolution**: Specific error messages and their actual root causes/fixes,\n   especially when the error message is misleading.\n\n5. **Workflow Optimizations**: Multi-step processes that can be streamlined or patterns\n   that make common tasks more efficient.\n\n## Skill Types\n\nDifferent skill types serve different purposes:\n\n- **Technique**: Concrete method with steps to follow (debugging patterns, testing approaches)\n- **Pattern**: Mental model for problem-solving (architectural decisions, design patterns)\n- **Reference**: API docs, syntax guides, tool documentation\n- **Error Resolution**: Specific error message ‚Üí root cause ‚Üí fix mapping\n\nClassification helps determine verification approach (see Verification by Skill Type below).\n\n## Skill Quality Criteria\n\nBefore extracting, verify the knowledge meets these criteria:\n\n- **Reusable**: Will this help with future tasks? (Not just this one instance)\n- **Non-trivial**: Is this knowledge that requires discovery, not just documentation lookup?\n- **Specific**: Can you describe the exact trigger conditions and solution?\n- **Verified**: Has this solution actually worked, not just theoretically?\n\n## Extraction Process\n\n### Step 1: Identify the Knowledge\n\nAnalyze what was learned:\n\n- What was the problem or task?\n- What was non-obvious about the solution?\n- What would someone need to know to solve this faster next time?\n- What are the exact trigger conditions (error messages, symptoms, contexts)?\n\n### Step 2: Research Best Practices (When Appropriate)\n\nBefore creating the skill, search the web for current information when:\n\n**Always search for:**\n\n- Technology-specific best practices (frameworks, libraries, tools)\n- Current documentation or API changes\n- Common patterns or solutions for similar problems\n- Known gotchas or pitfalls in the problem domain\n- Alternative approaches or solutions\n\n**When to search:**\n\n- The topic involves specific technologies, frameworks, or tools\n- You're uncertain about current best practices\n- The solution might have changed after January 2025 (knowledge cutoff)\n- There might be official documentation or community standards\n- You want to verify your understanding is current\n\n**When to skip searching:**\n\n- Project-specific internal patterns unique to this codebase\n- Solutions that are clearly context-specific and wouldn't be documented\n- Generic programming concepts that are stable and well-understood\n- Time-sensitive situations where the skill needs to be created immediately\n\n**Search strategy:**\n\n```\n1. Search for official documentation: \"[technology] [feature] official docs 2026\"\n2. Search for best practices: \"[technology] [problem] best practices 2026\"\n3. Search for common issues: \"[technology] [error message] solution 2026\"\n4. Review top results and incorporate relevant information\n5. Always cite sources in a \"References\" section of the skill\n```\n\n**Example searches:**\n\n- \"Next.js getServerSideProps error handling best practices 2026\"\n- \"Claude Code skill description semantic matching 2026\"\n- \"React useEffect cleanup patterns official docs 2026\"\n\n**Integration with skill content:**\n\n- Add a \"References\" section at the end of the skill with source URLs\n- Incorporate best practices into the \"Solution\" section\n- Include warnings about deprecated patterns in the \"Notes\" section\n- Mention official recommendations where applicable\n\n### Step 3: Structure the Skill\n\nSave the skill to the appropriate location:\n- If `.claude/skiller.toml` exists: `.claude/rules/[skill-name].mdc`\n- Otherwise: `.claude/skills/[skill-name]/SKILL.md`\n\nUse MDC frontmatter:\n\n```markdown\n---\nname: skill-name-with-hyphens\ndescription: |\n  Use when [specific triggering conditions]. Triggers: (1) exact symptom,\n  (2) error message, (3) scenario. [What problem this solves, written in third person.]\n---\n\n# [Skill Name]\n\n## Problem\n\n[Clear description of the problem this skill addresses]\n\n## Context / Trigger Conditions\n\n[When should this skill be used? Include exact error messages, symptoms, or scenarios]\n\n## Solution\n\n[Step-by-step solution or knowledge to apply]\n\n## Verification\n\n[How to verify the solution worked]\n\n## Example\n\n[Concrete example of applying this skill]\n\n## Notes\n\n[Any caveats, edge cases, or related considerations]\n\n## References\n\n[Optional: Links to official documentation, articles, or resources that informed this skill]\n```\n\n### Step 4: Write Effective Descriptions\n\nThe description field is critical for skill discovery. Include:\n\n- **Specific symptoms**: Exact error messages, unexpected behaviors\n- **Context markers**: Framework names, file types, tool names\n- **Action phrases**: \"Use when...\", \"Helps with...\", \"Solves...\"\n\nExample of a good description:\n\n```\ndescription: |\n  Fix for \"ENOENT: no such file or directory\" errors when running npm scripts\n  in monorepos. Use when: (1) npm run fails with ENOENT in a workspace,\n  (2) paths work in root but not in packages, (3) symlinked dependencies\n  cause resolution failures. Covers node_modules resolution in Lerna,\n  Turborepo, and npm workspaces.\n```\n\n## Claude Search Optimization (CSO)\n\nCritical for discovery‚Äîfuture Claude needs to FIND your skill.\n\n### Description Field\n\n- **Start with \"Use when...\"** to focus on triggering conditions\n- Describe the _problem_ (race conditions, flaky tests) not language-specific symptoms\n- Write in third person (injected into system prompt)\n- Keep under 500 characters if possible\n\n### Keyword Coverage\n\nUse words Claude would search for:\n\n- **Error messages**: \"Hook timed out\", \"ENOTEMPTY\", \"race condition\"\n- **Symptoms**: \"flaky\", \"hanging\", \"zombie\", \"pollution\"\n- **Synonyms**: \"timeout/hang/freeze\", \"cleanup/teardown/afterEach\"\n- **Tools**: Actual commands, library names, file types\n\n### Token Efficiency\n\nSkills load into context. Be concise but complete.\n\n- Move heavy reference (100+ lines) to separate files\n- Use cross-references instead of repeating content\n- Don't sacrifice clarity for brevity\n\n### Step 5: Deploy\n\nAfter creating the skill, run:\n\n```bash\nnpx skiller@latest apply\n```\n\n## Retrospective Mode\n\nWhen `/learn` is invoked at the end of a session:\n\n1. **Review the Session**: Analyze the conversation history for extractable knowledge\n2. **Identify Candidates**: List potential skills with brief justifications\n3. **Prioritize**: Focus on the highest-value, most reusable knowledge\n4. **Extract**: Create skills for the top candidates (typically 1-3 per session)\n5. **Summarize**: Report what skills were created and why\n\n## Self-Reflection Prompts\n\nUse these prompts during work to identify extraction opportunities:\n\n- \"What did I just learn that wasn't obvious before starting?\"\n- \"If I faced this exact problem again, what would I wish I knew?\"\n- \"What error message or symptom led me here, and what was the actual cause?\"\n- \"Is this pattern specific to this project, or would it help in similar projects?\"\n- \"What would I tell a colleague who hits this same issue?\"\n\n## Memory Consolidation\n\nWhen extracting skills, also consider:\n\n1. **Combining Related Knowledge**: If multiple related discoveries were made, consider\n   whether they belong in one comprehensive skill or separate focused skills.\n\n2. **Updating Existing Skills**: Check if an existing skill should be updated rather than\n   creating a new one.\n\n3. **Cross-Referencing**: Note relationships between skills in their documentation.\n\n## Quality Gates\n\nBefore finalizing a skill, verify:\n\n- [ ] Description contains specific trigger conditions\n- [ ] Solution has been verified to work\n- [ ] Content is specific enough to be actionable\n- [ ] Content is general enough to be reusable\n- [ ] No sensitive information (credentials, internal URLs) is included\n- [ ] Skill doesn't duplicate existing documentation or skills\n- [ ] Web research conducted when appropriate (for technology-specific topics)\n- [ ] References section included if web sources were consulted\n- [ ] Current best practices (post-2025) incorporated when relevant\n\n## Verification by Skill Type\n\nDifferent skill types need different verification:\n\n### Technique Skills (how-to guides)\n\n- Apply to real scenario in current session\n- Does skill guide correctly?\n- Are edge cases covered?\n\n### Pattern Skills (mental models)\n\n- Does skill explain when pattern applies?\n- Are counter-examples clear (when NOT to apply)?\n\n### Reference Skills (documentation)\n\n- Is information findable?\n- Are common use cases covered?\n\n### Error Resolution Skills\n\n- Does symptom ‚Üí cause ‚Üí fix mapping hold?\n- Are related errors mentioned?\n\n## Anti-Patterns to Avoid\n\n- **Over-extraction**: Not every task deserves a skill. Mundane solutions don't need preservation.\n- **Vague descriptions**: \"Helps with React problems\" won't surface when needed.\n- **Unverified solutions**: Only extract what actually worked.\n- **Documentation duplication**: Don't recreate official docs; link to them and add what's missing.\n- **Stale knowledge**: Mark skills with versions and dates; knowledge can become outdated.\n\n## Skill Lifecycle\n\nSkills should evolve:\n\n1. **Creation**: Initial extraction with documented verification\n2. **Refinement**: Update based on additional use cases or edge cases discovered\n3. **Deprecation**: Mark as deprecated when underlying tools/patterns change\n4. **Archival**: Remove or archive skills that are no longer relevant\n\n## Example: Complete Extraction Flow\n\n**Scenario**: While debugging a Next.js app, you discover that `getServerSideProps` errors\naren't showing in the browser console because they're server-side, and the actual error is\nin the terminal.\n\n**Step 1 - Identify the Knowledge**:\n\n- Problem: Server-side errors don't appear in browser console\n- Non-obvious aspect: Expected behavior for server-side code in Next.js\n- Trigger: Generic error page with empty browser console\n\n**Step 2 - Research Best Practices**:\nSearch: \"Next.js getServerSideProps error handling best practices 2026\"\n\n- Found official docs on error handling\n- Discovered recommended patterns for try-catch in data fetching\n- Learned about error boundaries for server components\n\n**Step 3-5 - Structure and Save**:\n\n**Extraction**:\n\n```markdown\n---\ndescription: |\n  Use when debugging Next.js server-side errors. Triggers: (1) Page shows generic\n  error but browser console is empty, (2) API routes return 500 with no details,\n  (3) Server-side code fails silently. Check terminal/server logs instead of browser.\n---\n\n# Next.js Server-Side Error Debugging\n\n## Problem\n\nServer-side errors in Next.js don't appear in the browser console, making\ndebugging frustrating when you're looking in the wrong place.\n\n## Context / Trigger Conditions\n\n- Page displays \"Internal Server Error\" or custom error page\n- Browser console shows no errors\n- Using getServerSideProps, getStaticProps, or API routes\n- Error only occurs on navigation/refresh, not on client-side transitions\n\n## Solution\n\n1. Check the terminal where `npm run dev` is running‚Äîerrors appear there\n2. For production, check server logs (Vercel dashboard, CloudWatch, etc.)\n3. Add try-catch with console.error in server-side functions for clarity\n4. Use Next.js error handling: return `{ notFound: true }` or `{ redirect: {...} }`\n   instead of throwing\n\n## Verification\n\nAfter checking terminal, you should see the actual stack trace with file\nand line numbers.\n\n## Notes\n\n- This applies to all server-side code in Next.js, not just data fetching\n- In development, Next.js sometimes shows a modal with partial error info\n- The `next.config.js` option `reactStrictMode` can cause double-execution\n  that makes debugging confusing\n\n## References\n\n- [Next.js Data Fetching: getServerSideProps](https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props)\n- [Next.js Error Handling](https://nextjs.org/docs/pages/building-your-application/routing/error-handling)\n```\n\n## Integration with Workflow\n\n### Automatic Trigger Conditions\n\nInvoke this skill immediately after completing a task when ANY of these apply:\n\n1. **Non-obvious debugging**: The solution required >10 minutes of investigation and\n   wasn't found in documentation\n2. **Error resolution**: Fixed an error where the error message was misleading or the\n   root cause wasn't obvious\n3. **Workaround discovery**: Found a workaround for a tool/framework limitation that\n   required experimentation\n4. **Configuration insight**: Discovered project-specific setup that differs from\n   standard patterns\n5. **Trial-and-error success**: Tried multiple approaches before finding what worked\n\n### Explicit Invocation\n\nAlso invoke when:\n\n- User runs `/learn` to review the session\n- User says \"save this as a skill\" or similar\n- User asks \"what did we learn?\"\n\n### Self-Check After Each Task\n\nAfter completing any significant task, ask yourself:\n\n- \"Did I just spend meaningful time investigating something?\"\n- \"Would future-me benefit from having this documented?\"\n- \"Was the solution non-obvious from documentation alone?\"\n\nIf yes to any, invoke this skill immediately.\n\nRemember: The goal is continuous, autonomous improvement. Every valuable discovery\nshould have the opportunity to benefit future work sessions.\n",
        ".claude-plugin/plugins/learn/skills/learn/examples/nextjs-server-side-error-debugging.mdc": "---\nname: nextjs-server-side-error-debugging\ndescription: Use when debugging Next.js server-side errors - triggers when page shows generic error but browser console is empty, API routes return 500 with no details, or server-side code fails silently. Check terminal/server logs instead of browser.\n---\n\n# Next.js Server-Side Error Debugging\n\n## Overview\n\n**Server-side errors in Next.js don't appear in the browser console.** The actual error with full stack trace appears in the terminal where `npm run dev` is running. This is the first place to look when debugging server-side issues.\n\n## When to Use\n\n- Page displays \"Internal Server Error\" or custom error page\n- Browser console shows no errors, or only a generic fetch failure\n- Using `getServerSideProps`, `getStaticProps`, or API routes\n- Error only occurs on page refresh or direct navigation (not client-side transitions)\n- Network tab shows 500 but response body is empty or generic\n\n## Quick Reference\n\n| Symptom                      | Cause                  | Solution                              |\n| ---------------------------- | ---------------------- | ------------------------------------- |\n| Empty browser console        | Server-side error      | Check terminal                        |\n| Generic 500 error            | Server threw exception | Check terminal for stack trace        |\n| Works locally, fails in prod | Missing env vars       | Check server logs (Vercel/CloudWatch) |\n| Intermittent errors          | Timing/async issues    | Add try-catch with console.error      |\n\n## Solution\n\n### Step 1: Check the Terminal\n\nThe actual error with full stack trace appears in the terminal where `npm run dev` is running.\n\n```bash\n# If you don't see the terminal, find the process\nps aux | grep next\n# Or restart with visible output\nnpm run dev\n```\n\n### Step 2: Add Explicit Error Handling\n\nFor persistent debugging, wrap server-side code with try-catch:\n\n```typescript\nexport async function getServerSideProps(context) {\n  try {\n    const data = await fetchSomething();\n    return { props: { data } };\n  } catch (error) {\n    console.error(\"getServerSideProps error:\", error);\n    return { props: { error: error.message } };\n  }\n}\n```\n\n### Step 3: For Production Errors\n\nCheck your hosting provider's logs:\n\n- **Vercel**: Dashboard ‚Üí Project ‚Üí Logs (Functions tab)\n- **AWS**: CloudWatch Logs\n- **Netlify**: Functions tab in dashboard\n- **Self-hosted**: Check your Node.js process logs\n\n## Common Mistakes\n\n### ‚ùå Mistake #1: Looking in browser DevTools\n\n```typescript\n// Error happens here but nothing in browser console\nexport async function getServerSideProps() {\n  const data = await fetch(\"https://api.example.com/data\");\n  return { props: { data: await data.json() } };\n}\n```\n\n**Rationalization:** \"Errors should appear in the browser console like client-side errors\"\n\n**Fix:** Check the terminal where `npm run dev` is running. Server-side code runs on the server, not in the browser.\n\n### ‚ùå Mistake #2: Missing environment variables in production\n\n```typescript\n// Works locally, fails in production\nconst apiKey = process.env.API_KEY; // undefined in production\n```\n\n**Rationalization:** \"It works on my machine, must be a code bug\"\n\n**Fix:** Verify env vars are set in your hosting provider's dashboard. Local `.env` files don't deploy automatically.\n\n## Red Flags - STOP\n\nIf you catch yourself thinking:\n\n- \"The browser console is empty, so there's no error\"\n- \"This worked locally, so the code is fine\"\n- \"I'll add more console.log in the component\"\n\n**STOP. Check the server terminal first.**\n\n## Example\n\n**Scenario**: User reports page shows \"Internal Server Error\" after clicking a link.\n\n**Before** (investigation):\n\n1. Open browser DevTools ‚Üí Console: Empty\n2. Network tab shows: `GET /dashboard ‚Üí 500`\n\n**After** (check terminal):\n\n```\nError: Cannot read property 'id' of undefined\n    at getServerSideProps (/app/pages/dashboard.tsx:15:25)\n    at renderToHTML (/app/node_modules/next/dist/server/render.js:428:22)\n```\n\n**Cause found**: Database query returned `null` instead of user object.\n\n## Notes\n\n- In development, Next.js sometimes shows an error overlay, but it often has less detail than the terminal\n- `reactStrictMode: true` causes double-execution of server functions in development\n- Client-side errors (in useEffect, event handlers) DO appear in browser console\n- For API routes, errors appear in the same terminal as page errors\n\n## Verification Checklist\n\n- [ ] Checked terminal where `npm run dev` is running\n- [ ] Found actual error message with file/line number\n- [ ] Identified root cause from stack trace\n- [ ] Added try-catch for future debugging if needed\n",
        ".claude-plugin/plugins/learn/skills/learn/examples/prisma-connection-pool-exhaustion.mdc": "---\nname: prisma-connection-pool-exhaustion\ndescription: Use when encountering \"Timed out fetching a new connection from the connection pool\" or \"too many connections\" errors in serverless environments - configures Prisma connection pooling for Vercel, AWS Lambda, and similar platforms\n---\n\n# Prisma Connection Pool Exhaustion in Serverless\n\n## Overview\n\n**Serverless functions create a new Prisma client on each cold start, quickly exhausting database connection limits.** Each instance opens multiple connections (default: 5), and with many concurrent requests, you hit the database limit (often 20-100 for managed databases).\n\n## When to Use\n\n- `P2024: Timed out fetching a new connection from the connection pool`\n- PostgreSQL: `FATAL: too many connections for role \"username\"`\n- MySQL: `Too many connections`\n- Works fine locally but fails in production\n- Errors appear during traffic spikes, then resolve\n\nEnvironment indicators:\n\n- Deploying to Vercel, AWS Lambda, Netlify Functions\n- Using Prisma with PostgreSQL, MySQL, or another connection-based database\n- Database is managed (PlanetScale, Supabase, Neon, RDS)\n\n## Quick Reference\n\n| Provider    | Solution                    | Connection String Change           |\n| ----------- | --------------------------- | ---------------------------------- |\n| Supabase    | Use pooler port 6543        | `?pgbouncer=true`                  |\n| Neon        | Built-in pooling            | `?sslmode=require`                 |\n| PlanetScale | No issue (serverless MySQL) | N/A                                |\n| Self-hosted | Add PgBouncer               | External pooler                    |\n| Any         | Prisma Accelerate           | `npx prisma generate --accelerate` |\n\n## Solution\n\n### Step 1: Use Connection Pooling Service\n\n**For Supabase:**\n\n```env\n# Use the pooled connection string (port 6543, not 5432)\nDATABASE_URL=\"postgresql://user:pass@db.xxx.supabase.co:6543/postgres?pgbouncer=true\"\n```\n\n**For Neon:**\n\n```env\nDATABASE_URL=\"postgresql://user:pass@ep-xxx.us-east-2.aws.neon.tech/dbname?sslmode=require\"\n```\n\n**For Prisma Accelerate:**\n\n```bash\nnpx prisma generate --accelerate\n```\n\n### Step 2: Configure Connection Limits\n\nAdd to your connection URL:\n\n```\n?connection_limit=1&pool_timeout=20&connect_timeout=10\n```\n\n- `connection_limit=1`: One connection per serverless instance\n- `pool_timeout=20`: Wait up to 20s for available connection\n- `connect_timeout=10`: Fail fast if can't connect in 10s\n\n### Step 3: Singleton Pattern (Development)\n\nPrevent hot-reload from creating new clients:\n\n```typescript\n// lib/prisma.ts\nimport { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n```\n\n## Common Mistakes\n\n### ‚ùå Mistake #1: Using direct database URL in serverless\n\n```env\n# ‚ùå Direct connection - creates new pool per function\nDATABASE_URL=\"postgresql://user:pass@db.xxx.supabase.co:5432/postgres\"\n```\n\n**Rationalization:** \"The connection string from the dashboard should work\"\n\n**Fix:** Use pooled connection (port 6543 for Supabase):\n\n```env\n# ‚úÖ Pooled connection\nDATABASE_URL=\"postgresql://user:pass@db.xxx.supabase.co:6543/postgres?pgbouncer=true\"\n```\n\n### ‚ùå Mistake #2: No connection limit in serverless\n\n```typescript\n// ‚ùå Default pool size (5 connections per instance)\nconst prisma = new PrismaClient();\n```\n\n**Rationalization:** \"Default settings should be fine\"\n\n**Fix:** Limit to 1 connection per instance:\n\n```typescript\n// ‚úÖ Limited connections\nconst prisma = new PrismaClient({\n  datasources: {\n    db: {\n      url: process.env.DATABASE_URL + \"?connection_limit=1\",\n    },\n  },\n});\n```\n\n### ‚ùå Mistake #3: Creating new client per request\n\n```typescript\n// ‚ùå New client every request\nexport async function handler() {\n  const prisma = new PrismaClient();\n  const data = await prisma.user.findMany();\n  // Connection never closed!\n}\n```\n\n**Rationalization:** \"Fresh client for each request is cleaner\"\n\n**Fix:** Use singleton pattern:\n\n```typescript\n// ‚úÖ Reuse client\nimport { prisma } from \"@/lib/prisma\";\n\nexport async function handler() {\n  const data = await prisma.user.findMany();\n}\n```\n\n## Red Flags - STOP\n\nIf you catch yourself thinking:\n\n- \"Works locally, must be a Vercel bug\"\n- \"I'll just increase the database connection limit\"\n- \"Fresh client per request is safer\"\n\n**STOP. Configure connection pooling for serverless.**\n\n## Example\n\n**Before** (error under load):\n\n```\n[ERROR] PrismaClientKnownRequestError:\nInvalid `prisma.user.findMany()` invocation:\nTimed out fetching a new connection from the connection pool.\n```\n\n**After** (with connection pooling):\n\n```env\n# Using Supabase pooler URL\nDATABASE_URL=\"postgresql://...@db.xxx.supabase.co:6543/postgres?pgbouncer=true&connection_limit=1\"\n```\n\nDatabase connections stable at 10-15 even under heavy load.\n\n## Notes\n\n- Different managed databases have different pooling solutions‚Äîcheck provider docs\n- PlanetScale (MySQL) uses serverless architecture and doesn't have this issue\n- `connection_limit=1` is aggressive; start there and increase if you see latency\n- The singleton pattern only helps in development; in production serverless, each instance is isolated\n- Consider Prisma Accelerate for built-in caching + pooling\n\n## Verification Checklist\n\n- [ ] Using pooled connection URL (not direct database connection)\n- [ ] `connection_limit=1` added to URL\n- [ ] Singleton pattern in `lib/prisma.ts`\n- [ ] Load test: `npx autocannon -c 100 -d 30 https://your-app.com/api/test`\n- [ ] Database dashboard shows connections within limits\n- [ ] No P2024 errors in logs\n",
        ".claude-plugin/plugins/learn/skills/learn/examples/typescript-circular-dependency.mdc": "---\nname: typescript-circular-dependency\ndescription: Use when encountering \"Cannot access before initialization\", undefined imports at runtime, or tests failing inconsistently - detects and resolves circular dependencies in TypeScript modules using madge and restructuring patterns\n---\n\n# TypeScript Circular Dependency Detection and Resolution\n\n## Overview\n\n**Circular dependencies occur when module A imports from module B, which imports from module A.** TypeScript compiles successfully, but at runtime one import evaluates to `undefined` because the module hasn't finished initializing.\n\n## When to Use\n\n- `ReferenceError: Cannot access 'X' before initialization`\n- `TypeError: Cannot read properties of undefined (reading 'create')`\n- `TypeError: (0 , _service.doSomething) is not a function`\n- Import is `undefined` even though the export exists\n- Tests fail but the app works (or vice versa)\n- Adding `console.log` at the top of a file changes behavior\n\n## Quick Reference\n\n| Pattern            | Cause                                 | Solution                 |\n| ------------------ | ------------------------------------- | ------------------------ |\n| Service-to-Service | A imports B, B imports A              | Extract shared interface |\n| Type imports       | types/user ‚Üí types/order ‚Üí types/user | Use `import type`        |\n| Barrel files       | index.ts re-exports cause cycles      | Direct imports           |\n| Shared utilities   | utils ‚Üí service ‚Üí utils               | Dependency injection     |\n\n## Solution\n\n### Step 1: Detect the Cycle\n\n```bash\n# Install madge\nnpm install -g madge\n\n# Find circular dependencies\nmadge --circular --extensions ts,tsx src/\n\n# Generate visual graph\nmadge --circular --image graph.svg src/\n```\n\n### Step 2: Resolution Strategies\n\n**Strategy 1: Extract Shared Dependencies**\n\n```typescript\n// ‚ùå BEFORE: Circular\n// userService.ts\nimport { OrderService } from './orderService';\nexport class UserService { ... }\n\n// orderService.ts\nimport { UserService } from './userService';\nexport class OrderService { ... }\n```\n\n```typescript\n// ‚úÖ AFTER: Extract interface\n// types/interfaces.ts (no imports from services)\nexport interface IUserService { ... }\nexport interface IOrderService { ... }\n\n// userService.ts\nimport { IOrderService } from '../types/interfaces';\nexport class UserService implements IUserService { ... }\n```\n\n**Strategy 2: Use Type-Only Imports**\n\n```typescript\n// This doesn't create a runtime dependency\nimport type { User } from \"./userService\";\n```\n\n**Strategy 3: Fix Barrel Files**\n\n```typescript\n// ‚ùå BEFORE: Modal imports Button from index\n// components/Modal.tsx\nimport { Button } from \"./index\"; // Creates cycle\n\n// ‚úÖ AFTER: Direct import\nimport { Button } from \"./Button\";\n```\n\n### Step 3: Prevent Future Cycles\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"check:circular\": \"madge --circular --extensions ts,tsx src/\"\n  }\n}\n```\n\n## Common Mistakes\n\n### ‚ùå Mistake #1: Importing from barrel files within the same folder\n\n```typescript\n// components/Modal.tsx\nimport { Button } from \"./index\"; // index.ts exports Modal AND Button\n```\n\n**Rationalization:** \"Barrel files are cleaner for imports\"\n\n**Fix:** Use direct imports within the same folder:\n\n```typescript\nimport { Button } from \"./Button\";\n```\n\n### ‚ùå Mistake #2: Runtime imports when only types needed\n\n```typescript\n// ‚ùå Creates runtime dependency\nimport { User } from './userService';\n\nfunction processUser(user: User) { ... }\n```\n\n**Rationalization:** \"Need the User type\"\n\n**Fix:** Use type-only import:\n\n```typescript\n// ‚úÖ No runtime dependency\nimport type { User } from \"./userService\";\n```\n\n## Red Flags - STOP\n\nIf you catch yourself thinking:\n\n- \"The import works in one file but not another\"\n- \"It only breaks when I import this specific module\"\n- \"Moving the import statement changes behavior\"\n\n**STOP. You have a circular dependency. Run `madge --circular`.**\n\n## Example\n\n**Scenario**: `OrderService` is undefined when imported in `UserService`\n\n**Detection**:\n\n```bash\n$ madge --circular src/\nCircular dependencies found!\n  src/services/userService.ts ‚Üí src/services/orderService.ts ‚Üí src/services/userService.ts\n```\n\n**Fix**: Extract shared interface\n\n```typescript\n// NEW: src/types/services.ts\nexport interface IOrderService {\n  createOrder(userId: string): Promise<Order>;\n}\n\n// MODIFIED: src/services/userService.ts\nimport type { IOrderService } from '../types/services';\n\nexport class UserService {\n  constructor(private orderService: IOrderService) {}\n}\n\n// MODIFIED: src/services/orderService.ts\n// No longer imports UserService\nexport class OrderService implements IOrderService { ... }\n```\n\n## Notes\n\n- TypeScript `import type` is erased at runtime and can't cause cycles\n- Barrel files (`index.ts`) are a common source of accidental cycles\n- Jest/Vitest may handle module resolution differently than your bundler\n- The order of exports in a file can matter when there's a cycle\n\n## Verification Checklist\n\n- [ ] Run `madge --circular src/` - should report no cycles\n- [ ] Run test suite - previously undefined imports work\n- [ ] Delete `node_modules` and reinstall - app still works\n- [ ] Build for production - no runtime errors\n",
        ".claude-plugin/plugins/learn/skills/learn/resources/research-references.md": "# Research References\n\nThis document compiles the academic research that informed the design of the Learn skill.\n\n## Core Papers\n\n### Voyager: An Open-Ended Embodied Agent with Large Language Models\n\n**Authors**: Wang, Xie, Jiang, Mandlekar, Xiao, Zhu, Fan, Anandkumar  \n**Published**: May 2023  \n**URL**: https://arxiv.org/abs/2305.16291\n\n**Key Contribution**: First LLM-powered embodied lifelong learning agent with a skill library architecture.\n\n**Relevant Concepts Applied**:\n\n1. **Ever-Growing Skill Library**: Voyager maintains \"an ever-growing skill library of executable code for storing and retrieving complex behaviors.\" This inspired our approach of extracting Claude Code skills as executable knowledge packages.\n\n2. **Compositional Skills**: \"The skills developed by Voyager are temporally extended, interpretable, and compositional, which compounds the agent's abilities rapidly and alleviates catastrophic forgetting.\" Our skill structure aims for similar composability.\n\n3. **Self-Verification**: Voyager uses \"self-verification for program improvement\" before adding skills to the library. We implement similar quality gates before extraction.\n\n4. **Iterative Prompting**: The \"iterative prompting mechanism that incorporates environment feedback, execution errors\" influenced our retrospective mode design.\n\n---\n\n### CASCADE: Cumulative Agentic Skill Creation through Autonomous Development and Evolution\n\n**Authors**: [Research Team]  \n**Published**: December 2024  \n**URL**: https://arxiv.org/abs/2512.23880\n\n**Key Contribution**: Self-evolving agentic framework demonstrating the transition from \"LLM + tool use\" to \"LLM + skill acquisition.\"\n\n**Relevant Concepts Applied**:\n\n1. **Meta-Skills for Learning**: CASCADE demonstrates \"continuous learning via web search and code extraction, and self-reflection via introspection.\" Our skill is itself a meta-skill for acquiring skills.\n\n2. **Knowledge Codification**: \"CASCADE accumulates executable skills that can be shared across agents\" - this principle drives our skill extraction and storage approach.\n\n3. **Memory Consolidation**: The framework uses memory consolidation to prevent forgetting and enable reuse. Our skill library serves a similar purpose.\n\n---\n\n### SEAgent: Self-Evolving Computer Use Agent with Autonomous Learning from Experience\n\n**Authors**: Sun et al.  \n**Published**: August 2025  \n**URL**: https://arxiv.org/abs/2508.04700\n\n**Key Contribution**: Framework enabling agents to autonomously evolve through interactions with unfamiliar software.\n\n**Relevant Concepts Applied**:\n\n1. **Experiential Learning**: \"SEAgent empowers computer-use agents to autonomously master novel software environments via experiential learning, where agents explore new software, learn through iterative trial-and-error.\" Our retrospective mode captures this trial-and-error learning.\n\n2. **Learning from Failures and Successes**: \"The agent's policy is optimized through experiential learning from both failures and successes.\" We extract skills from both successful solutions and debugging processes.\n\n3. **Curriculum Generation**: SEAgent uses a \"Curriculum Generator\" for increasingly diverse tasks. Our skill descriptions enable semantic matching to surface relevant skills.\n\n---\n\n### Reflexion: Language Agents with Verbal Reinforcement Learning\n\n**Authors**: Shinn et al.  \n**Published**: March 2023  \n**URL**: https://arxiv.org/abs/2303.11366\n\n**Key Contribution**: Framework for verbal reinforcement through linguistic feedback and self-reflection.\n\n**Relevant Concepts Applied**:\n\n1. **Self-Reflection Prompts**: \"Reflexion converts feedback from the environment into linguistic feedback, also referred to as self-reflection.\" Our self-reflection prompts are directly inspired by this.\n\n2. **Memory for Future Trials**: \"These experiences (stored in long-term memory) are leveraged by the agent to rapidly improve decision-making.\" Skills serve as long-term memory.\n\n3. **Verbal Reinforcement**: Instead of scalar rewards, Reflexion uses \"nuanced feedback\" in natural language. Our skill descriptions capture this nuanced knowledge.\n\n---\n\n### EvoFSM: Controllable Self-Evolution for Deep Research with Finite State Machines\n\n**Authors**: [Research Team]  \n**Published**: 2024\n\n**Key Contribution**: Self-evolving framework with experience pools for continuous learning.\n\n**Relevant Concepts Applied**:\n\n1. **Self-Evolving Memory**: \"EvoFSM integrates a Self-Evolving Memory mechanism, which distills successful strategies and failure patterns into an Experience Pool to enable continuous learning and warm-starting for future queries.\"\n\n2. **Experience Pools**: The concept of storing strategies for later retrieval directly influenced our skill library design.\n\n---\n\n## Supporting Research\n\n### Professional Agents: Evolving LLMs into Autonomous Experts\n\n**URL**: https://arxiv.org/abs/2402.03628\n\nDescribes a framework for creating agents with specialized expertise through continuous learning. Influenced our quality criteria for what makes a skill worth extracting.\n\n### Self-Reflection in LLM Agents: Effects on Problem-Solving Performance\n\n**URL**: https://arxiv.org/abs/2405.06682\n\nEmpirical study showing self-reflection improves performance. Validated our use of reflection prompts for identifying extractable knowledge.\n\n### Building Scalable and Reliable Agentic AI Systems\n\nComprehensive survey covering memory architectures, tool use, and continuous learning in agentic AI. Provided the broader architectural context for our design.\n\n---\n\n## Claude Code Skills Documentation\n\n### Anthropic Engineering Blog: Equipping Agents for the Real World with Agent Skills\n\n**URL**: https://www.anthropic.com/engineering/equipping-agents-for-the-real-world-with-agent-skills\n\n**Key Insights**:\n\n1. **Progressive Disclosure**: \"Skills let Claude load information only as needed\" - this enables scaling to many skills without context window bloat.\n\n2. **Future Vision**: \"We hope to enable agents to create, edit, and evaluate Skills on their own, letting them codify their own patterns of behavior into reusable capabilities.\" This skill is an implementation of this vision.\n\n3. **Skill as Onboarding**: \"Building a skill for an agent is like putting together an onboarding guide for a new hire.\" Our template follows this mental model.\n\n### Claude Code Skills Documentation\n\n**URL**: https://code.claude.com/docs/en/skills\n\n**Key Insights**:\n\n1. **SKILL.md Structure**: YAML frontmatter + markdown instructions\n2. **Description Importance**: Semantic matching relies on good descriptions\n3. **Allowed Tools**: Skills can restrict or enable specific tools\n4. **Location Options**: User-level vs. project-level installation\n\n---\n\n## Design Patterns Applied\n\n### From Voyager\n- Skill library as executable code\n- Self-verification before adding to library\n- Compositional skill building\n\n### From CASCADE\n- Meta-skills for learning\n- Knowledge codification into shareable format\n- Memory consolidation\n\n### From SEAgent\n- Learning from both successes and failures\n- Experiential learning through trial-and-error\n- Progressive skill complexity\n\n### From Reflexion\n- Self-reflection prompts\n- Verbal feedback over scalar rewards\n- Long-term memory storage\n\n### From EvoFSM\n- Experience pools\n- Distilling strategies from sessions\n- Warm-starting future work\n\n---\n\n## Citation Format\n\nIf referencing this skill in academic work:\n\n```\n@misc{learn-skill,\n  title={Learn: Autonomous Skill Extraction for LLM Agents},\n  author={Claude Code},\n  year={2024},\n  note={Implements continuous learning patterns from Voyager, CASCADE, SEAgent, and Reflexion research}\n}\n```\n",
        ".claude-plugin/plugins/learn/skills/learn/resources/skill-template.mdc": "---\ndescription: Use when [specific triggering conditions] - [what problem this solves, written in third person]\n---\n\n# Skill Name\n\n## Overview\n\n**Core principle in 1-2 bold sentences.** Additional context about what this skill addresses and why it matters.\n\n## When to Use\n\n- Exact error message or symptom 1\n- Exact error message or symptom 2\n- Observable behavior or scenario\n- Environmental condition (framework, tool, platform)\n\n## Quick Reference\n\n| Pattern   | Use Case    | Example        |\n| --------- | ----------- | -------------- |\n| Pattern 1 | When to use | `code example` |\n| Pattern 2 | When to use | `code example` |\n\n## Solution\n\n### Step 1: [First Action]\n\n[Detailed instructions with code examples]\n\n```language\n// Example code\n```\n\n### Step 2: [Second Action]\n\n[Continue with clear, actionable steps]\n\n## Common Mistakes\n\n### ‚ùå Mistake #1: [Name]\n\n```language\n// Wrong approach\n```\n\n**Rationalization:** \"Why someone might do this wrong\"\n\n**Fix:**\n\n```language\n// Correct approach\n```\n\n### ‚ùå Mistake #2: [Name]\n\n```language\n// Wrong approach\n```\n\n**Rationalization:** \"Why someone might do this wrong\"\n\n**Fix:**\n\n```language\n// Correct approach\n```\n\n## Red Flags - STOP\n\nIf you catch yourself thinking:\n\n- \"Rationalization 1\"\n- \"Rationalization 2\"\n- \"Rationalization 3\"\n\n**STOP. You're about to [consequence].**\n\n## Example\n\n**Scenario**: [Concrete example of when this skill applies]\n\n**Before**:\n\n```\n[Error message or problematic code]\n```\n\n**After**:\n\n```\n[Fixed code or successful output]\n```\n\n## Notes\n\n- Caveat 1\n- Related skill or documentation link\n- Known limitation\n- When NOT to use this skill\n\n## Verification Checklist\n\n- [ ] Step 1 verified\n- [ ] Step 2 verified\n- [ ] Expected outcome achieved\n",
        ".claude-plugin/plugins/media/.claude-plugin/plugin.json": "{\n  \"name\": \"media\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Auto-play/pause media on prompt submit/stop\",\n  \"author\": {\n    \"name\": \"zbeyens\"\n  }\n}\n",
        ".claude-plugin/plugins/media/README.md": "# Media Plugin\n\nAutomatically control media playback based on Claude Code interaction:\n- **Submit**: Plays media when you submit a prompt\n- **Stop**: Pauses media when you stop Claude's response\n\n## Requirements\n\n- macOS\n- [media-control](https://github.com/autopilot/media-control) CLI tool\n\nInstall media-control:\n```bash\nbrew install media-control\n```\n\n## Installation\n\n```bash\n# Install the plugin\n/plugin install media@dotai\n\n# Or add to .claude/settings.json\n{\n  \"enabledPlugins\": {\n    \"media@dotai\": true\n  }\n}\n```\n\n## Configuration\n\n### Environment Variables\n\n**`CLAUDE_MEDIA_DISABLED`** (default: `\"false\"`)\n- `\"false\"`: Plugin is active\n- `\"true\"`: Completely disable the plugin (no play/pause on any events)\n\n**`CLAUDE_MEDIA_AUTO_START`** (default: `\"true\"`)\n- `\"true\"`: Auto-play media when submitting a prompt\n- `\"false\"`: Don't play media on prompt submit\n\n**`CLAUDE_MEDIA_AUTO_PAUSE`** (default: `\"true\"`)\n- `\"true\"`: Auto-pause media when stopping Claude's response\n- `\"false\"`: Don't pause media on stop\n\nAdd to `.claude/settings.json` or `.claude/settings.local.json` (overrides):\n```json\n{\n  \"env\": {\n    \"CLAUDE_MEDIA_DISABLED\": \"false\",\n    \"CLAUDE_MEDIA_AUTO_START\": \"true\",\n    \"CLAUDE_MEDIA_AUTO_PAUSE\": \"false\"\n  }\n}\n```\n\n**Note**: Changes take effect immediately without restarting Claude Code. Settings in `settings.local.json` override those in `settings.json`.\n\n## How It Works\n\n1. **UserPromptSubmit Hook**: Sends `media-control play` command\n2. **Stop Hook**: Sends `media-control pause` command (if AUTO_PAUSE is enabled)\n\nThe plugin works with any media player supported by macOS media controls (Spotify, Apple Music, YouTube in browsers, etc.).\n\n## Examples\n\n**Default behavior** (all features enabled):\n- Submit prompt ‚Üí Music plays\n- Stop response ‚Üí Music pauses\n\n**Only pause, no auto-start**:\n```json\n{\n  \"env\": {\n    \"CLAUDE_MEDIA_AUTO_START\": \"false\",\n    \"CLAUDE_MEDIA_AUTO_PAUSE\": \"true\"\n  }\n}\n```\n- Submit prompt ‚Üí Music keeps playing\n- Stop response ‚Üí Music pauses\n\n**Only auto-start, no pause**:\n```json\n{\n  \"env\": {\n    \"CLAUDE_MEDIA_AUTO_START\": \"true\",\n    \"CLAUDE_MEDIA_AUTO_PAUSE\": \"false\"\n  }\n}\n```\n- Submit prompt ‚Üí Music plays\n- Stop response ‚Üí Music keeps playing\n\n**Completely disable**:\n```json\n{\n  \"env\": {\n    \"CLAUDE_MEDIA_DISABLED\": \"true\"\n  }\n}\n```\n- No media control at all\n\n## Troubleshooting\n\n**Media not controlling:**\n- Ensure `media-control` is installed: `which media-control`\n- Test manually: `media-control play` / `media-control pause`\n- Check if media player is running\n\n**Plugin not loading:**\n- Restart Claude Code after installation\n- Verify plugin is enabled in settings\n- Check `.claude/settings.json` syntax\n",
        ".claude-plugin/plugins/media/hooks/hooks.json": "{\n  \"hooks\": {\n    \"UserPromptSubmit\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"DISABLED=$(node ${CLAUDE_PLUGIN_ROOT}/scripts/get-env.js CLAUDE_MEDIA_DISABLED false 2>/dev/null || echo 'false'); AUTO_START=$(node ${CLAUDE_PLUGIN_ROOT}/scripts/get-env.js CLAUDE_MEDIA_AUTO_START true 2>/dev/null || echo 'true'); if [ \\\"$DISABLED\\\" = \\\"false\\\" ] && [ \\\"$AUTO_START\\\" = \\\"true\\\" ]; then media-control play 2>/dev/null || true; fi\"\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"DISABLED=$(node ${CLAUDE_PLUGIN_ROOT}/scripts/get-env.js CLAUDE_MEDIA_DISABLED false 2>/dev/null || echo 'false'); AUTO_PAUSE=$(node ${CLAUDE_PLUGIN_ROOT}/scripts/get-env.js CLAUDE_MEDIA_AUTO_PAUSE true 2>/dev/null || echo 'true'); if [ \\\"$DISABLED\\\" = \\\"false\\\" ] && [ \\\"$AUTO_PAUSE\\\" = \\\"true\\\" ]; then media-control pause 2>/dev/null || true; fi\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        ".claude-plugin/plugins/media/scripts/get-env.js": "#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\n\n// Get the environment variable name and default value from command line args\nconst varName = process.argv[2];\nconst defaultValue = process.argv[3] || '';\n\nif (!varName) {\n  process.exit(1);\n}\n\n// Use current working directory\nconst projectDir = process.cwd();\nconst claudePath = path.join(projectDir, '.claude');\nlet env = {};\n\n// Read settings.json\ntry {\n  const settingsPath = path.join(claudePath, 'settings.json');\n  const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));\n  if (settings.env) {\n    env = { ...env, ...settings.env };\n  }\n} catch (e) {\n  // Ignore if file doesn't exist or is invalid\n}\n\n// Read settings.local.json (overrides)\ntry {\n  const localSettingsPath = path.join(claudePath, 'settings.local.json');\n  const localSettings = JSON.parse(fs.readFileSync(localSettingsPath, 'utf8'));\n  if (localSettings.env) {\n    env = { ...env, ...localSettings.env };\n  }\n} catch (e) {\n  // Ignore if file doesn't exist or is invalid\n}\n\n// Output the value\nconst finalValue = env[varName] !== undefined ? env[varName] : defaultValue;\nconsole.log(finalValue);\n",
        ".claude-plugin/plugins/notification/.claude-plugin/plugin.json": "{\n  \"name\": \"notification\",\n  \"version\": \"1.0.0\",\n  \"description\": \"macOS notifications for Claude Code events\",\n  \"author\": {\n    \"name\": \"zbeyens\"\n  },\n  \"keywords\": [\"notifications\", \"hooks\", \"macos\"]\n}\n",
        ".claude-plugin/plugins/notification/README.md": "# Notification Plugin\n\nmacOS notifications for Claude Code events.\n\n## Features\n\nDisplays native macOS notifications for:\n\n- **Stop** - Shows \"Claude finished responding\" when Claude stops\n- **PreCompact** - Shows \"Compacting conversation...\" before context compaction\n- **Notification** - (Disabled by default) Shows system notifications\n\n## Prerequisites\n\nRequires [terminal-notifier](https://github.com/julienXX/terminal-notifier) to be installed:\n\n```bash\nbrew install terminal-notifier\n```\n\n## Installation\n\n```bash\n/plugin marketplace add udecode/dotai\n/plugin install notification@dotai\n```\n\nRestart Claude Code to activate the hooks.\n\n## What You'll See\n\n- üîî **Ping sound** - When Claude finishes responding\n- üçæ **Bottle sound** - When compacting conversation history\n- üìù **Dynamic titles** - Shows the conversation summary as notification title\n\n## How It Works\n\nThe plugin uses hooks to intercept Claude Code events and displays notifications with:\n\n- **Title**: Extracted from conversation transcript summary\n- **Message**: Event-specific message\n- **Sound**: Different sounds for different events\n\n## Customization\n\nEdit `.claude-plugin/plugins/notification/hooks/hooks.json` to:\n\n- Change notification sounds (`Ping`, `Bottle`, `Glass`, `Submarine`, etc.)\n- Modify messages\n- Enable/disable specific notifications\n- Adjust matcher patterns\n\n## Troubleshooting\n\n**Notifications not appearing:**\n\n1. Check terminal-notifier is installed: `which terminal-notifier`\n2. Enable notifications for Terminal/iTerm in System Settings ‚Üí Notifications\n3. Verify plugin is enabled: `/plugin`\n\n**Want to disable:**\n\n```bash\n/plugin disable notification@dotai\n```\n\n## License\n\nMIT\n",
        ".claude-plugin/plugins/notification/hooks/hooks.json": "{\n  \"hooks\": {\n    \"Notification\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"DATA=$(cat); TRANSCRIPT=$(echo \\\"$DATA\\\" | jq -r '.transcript_path'); TITLE=$(grep -m1 '\\\"type\\\":\\\"summary\\\"' \\\"$TRANSCRIPT\\\" 2>/dev/null | jq -r '.summary' 2>/dev/null || echo \\\"Claude Code\\\"); MSG=$(echo \\\"$DATA\\\" | jq -r '.message'); terminal-notifier -message \\\"$MSG\\\" -title \\\"$TITLE\\\" -sound Ping\"\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"DATA=$(cat); TRANSCRIPT=$(echo \\\"$DATA\\\" | jq -r '.transcript_path'); TITLE=$(grep -m1 '\\\"type\\\":\\\"summary\\\"' \\\"$TRANSCRIPT\\\" 2>/dev/null | jq -r '.summary' 2>/dev/null || echo \\\"Claude Code\\\"); terminal-notifier -message \\\"Claude finished responding\\\" -title \\\"$TITLE\\\" -sound Ping\"\n          }\n        ]\n      }\n    ],\n    \"PreCompact\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"DATA=$(cat); TRANSCRIPT=$(echo \\\"$DATA\\\" | jq -r '.transcript_path'); TITLE=$(grep -m1 '\\\"type\\\":\\\"summary\\\"' \\\"$TRANSCRIPT\\\" 2>/dev/null | jq -r '.summary' 2>/dev/null || echo \\\"Claude Code\\\"); terminal-notifier -message \\\"Compacting conversation...\\\" -title \\\"$TITLE\\\" -sound Bottle\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        ".claude-plugin/plugins/test/.claude-plugin/plugin.json": "{\n  \"name\": \"test\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Test-driven development workflow for writing tests before implementation - red-green-refactor cycle with deterministic unit tests\",\n  \"author\": {\n    \"name\": \"zbeyens\"\n  },\n  \"keywords\": [\"testing\", \"tdd\", \"test-driven\", \"unit-tests\", \"red-green-refactor\"]\n}",
        ".claude-plugin/plugins/test/README.md": "# Test Plugin\n\n> Test-driven development workflow for writing tests before implementation\n\n## Overview\n\nThe Test plugin provides a disciplined TDD approach for implementing complex logic with test coverage. It enforces the red-green-refactor cycle, ensuring tests actually verify behavior by requiring failure first.\n\n## Features\n\n### üî¥üü¢‚ôªÔ∏è Red-Green-Refactor Cycle\n\nClassic TDD workflow:\n\n- **Red** - Write failing test first\n- **Green** - Write minimal code to pass\n- **Refactor** - Improve code while keeping tests green\n\n### üéØ Smart Test Strategy\n\nAutomatic decision on when to test:\n\n- **Write tests for:** Complex algorithms, business logic, data transformations\n- **Skip tests for:** UI components, simple CRUD, straightforward mappings\n- **Verification alternatives:** Typecheck, lint, manual testing\n\n## Installation\n\n```bash\n/plugin install test@dotai\n# restart claude\n```\n\n## Skills\n\n### tdd\n\n**When to use:**\n\n- User explicitly requests tests\n- Complex logic where bugs are likely\n- Business logic with edge cases\n- Data transformations\n- Critical paths that could break silently\n\n**When NOT to use:**\n\n- ‚ùå UI components (React components, hooks)\n- ‚ùå Simple CRUD operations\n- ‚ùå Straightforward mappings\n- ‚ùå Configuration files\n- ‚ùå Throwaway prototypes\n\n## The TDD Process\n\n### 1. Write Failing Test\n\n```typescript\ntest(\"calculates compound interest correctly\", () => {\n  const result = calculateCompoundInterest(1000, 0.05, 12, 2);\n  expect(result).toBe(1104.94);\n});\n```\n\nRun test ‚Üí See failure ‚Üí Confirms test is valid\n\n### 2. Write Minimal Code\n\n```typescript\nfunction calculateCompoundInterest(principal, rate, n, t) {\n  return principal * Math.pow(1 + rate / n, n * t);\n}\n```\n\nJust enough to make test pass, no more.\n\n### 3. Run Test Again\n\n```bash\nnpm test\n```\n\nTest passes ‚Üí Implementation correct\n\n### 4. Refactor (Optional)\n\nImprove code while keeping tests green:\n\n- Extract constants\n- Improve names\n- Simplify logic\n- Add edge case handling\n\n### 5. Commit\n\n```bash\ngit add .\ngit commit -m \"feat: implement compound interest calculation with tests\"\n```\n\n## Test Types\n\n**Only write deterministic unit tests:**\n\n- ‚úÖ Pure functions\n- ‚úÖ Synchronous logic\n- ‚úÖ Data transformations\n- ‚úÖ Algorithms\n\n**Avoid:**\n\n- ‚ùå Integration tests\n- ‚ùå End-to-end tests\n- ‚ùå Complex mocking\n- ‚ùå Async complexity\n- ‚ùå Database tests\n\n## Verification Without Tests\n\nWhen skipping tests (UI, simple CRUD):\n\n```bash\n# TypeScript verification\nnpm run typecheck\n\n# Linting\nnpm run lint\n\n# Manual testing for UI\n# Code review for confidence\n```\n\n## Core Principle\n\n> If you didn't watch the test fail, you don't know if it tests the right thing.\n\n**The rule:** NO CODE WITHOUT A FAILING TEST FIRST (when using TDD)\n\n## Common Mistakes\n\n‚ùå **Writing implementation first**\n‚úÖ Test first, always\n\n‚ùå **Not watching test fail**\n‚úÖ Red phase is mandatory\n\n‚ùå **Over-engineering initial solution**\n‚úÖ Minimal code to pass\n\n‚ùå **Testing implementation details**\n‚úÖ Test behavior, not internals\n\n‚ùå **Writing tests for everything**\n‚úÖ Only complex logic needs tests\n\n## Integration\n\nWorks seamlessly with other dotai plugins:\n\n- **debug** - Use debug skill when tests fail\n- **git** - Integrate with PR workflows\n\n## Best Practices\n\n1. **Test behavior, not implementation** - Black box testing\n2. **One assertion per test** - Clear failure messages\n3. **Descriptive test names** - Document intent\n4. **AAA pattern** - Arrange, Act, Assert\n5. **Keep tests simple** - No logic in tests\n6. **Fast tests only** - Milliseconds not seconds\n\n## Examples\n\n### Complex Algorithm (Needs Test)\n\n```typescript\n// 1. Write failing test\ntest(\"fibonacci returns correct sequence\", () => {\n  expect(fibonacci(0)).toBe(0);\n  expect(fibonacci(1)).toBe(1);\n  expect(fibonacci(5)).toBe(5);\n  expect(fibonacci(10)).toBe(55);\n});\n\n// 2. See test fail\n// Error: fibonacci is not defined\n\n// 3. Write minimal implementation\nfunction fibonacci(n: number): number {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n// 4. Test passes ‚úÖ\n```\n\n### Simple CRUD (Skip Test)\n\n```typescript\n// No test needed - verify with typecheck\nasync function getUser(id: string) {\n  return db.users.findById(id);\n}\n\n// Verification: npm run typecheck\n```\n\n## Real-World Impact\n\n- **Bug prevention:** Catches issues before deployment\n- **Documentation:** Tests document expected behavior\n- **Refactoring confidence:** Change code without fear\n- **Design improvement:** TDD drives better API design\n- **Time saved:** Less debugging, fewer regressions\n",
        ".claude-plugin/plugins/test/skills/tdd/SKILL.md": "---\nname: tdd\ndescription: Use when implementing complex logic that needs test coverage - write the test first, watch it fail, write minimal code to pass; ensures tests actually verify behavior by requiring failure first; NOT for UI components, simple CRUD, or straightforward code\n---\n\n# Test-Driven Development (TDD)\n\n## Overview\n\nWrite the test first. Watch it fail. Write minimal code to pass.\n\n**Core principle:** If you didn't watch the test fail, you don't know if it tests the right thing.\n\n**When to use:** Only for complex logic where bugs are likely, or when user explicitly requests tests.\n\n## When to Use\n\n**Use TDD when:**\n\n1. **User explicitly requests tests**\n2. **Complex logic where bugs are likely:**\n   - Complex algorithms\n   - Business logic with edge cases\n   - Data transformations\n   - Critical paths that could break silently\n\n**Skip TDD for:**\n\n- ‚ùå UI components (React components, hooks)\n- ‚ùå Simple CRUD operations\n- ‚ùå Straightforward mappings\n- ‚ùå Anything you're 100% certain is correct\n- ‚ùå Throwaway prototypes\n- ‚ùå Configuration files\n\n**Verification alternatives when skipping:**\n\n- Typecheck with `npm run typecheck`\n- Lint with `npm run lint`\n- Manual testing for UI changes\n- Code review confidence\n\n## The Rule (When Using TDD)\n\n```\nWHEN WRITING TESTS: NO CODE WITHOUT A FAILING TEST FIRST\n```\n\n**When you've decided to use TDD** (complex logic, user request):\n\nWrite code before the test? Delete it. Start over.\n\n**No exceptions when using TDD:**\n\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n\nImplement fresh from tests. Period.\n\n**When NOT using TDD** (UI, simple code):\n\n- Write code directly\n- Verify with typecheck/lint\n- Skip the test\n\n## Red-Green-Refactor\n\n```dot\ndigraph tdd_cycle {\n    rankdir=LR;\n    red [label=\"RED\\nWrite failing test\", shape=box, style=filled, fillcolor=\"#ffcccc\"];\n    verify_red [label=\"Verify fails\\ncorrectly\", shape=diamond];\n    green [label=\"GREEN\\nMinimal code\", shape=box, style=filled, fillcolor=\"#ccffcc\"];\n    verify_green [label=\"Verify passes\\nAll green\", shape=diamond];\n    refactor [label=\"REFACTOR\\nClean up\", shape=box, style=filled, fillcolor=\"#ccccff\"];\n    next [label=\"Next\", shape=ellipse];\n\n    red -> verify_red;\n    verify_red -> green [label=\"yes\"];\n    verify_red -> red [label=\"wrong\\nfailure\"];\n    green -> verify_green;\n    verify_green -> refactor [label=\"yes\"];\n    verify_green -> green [label=\"no\"];\n    refactor -> verify_green [label=\"stay\\ngreen\"];\n    verify_green -> next;\n    next -> red;\n}\n```\n\n### RED - Write Failing Test\n\nWrite one minimal test showing what should happen.\n\n<Good>\n```typescript\ntest('retries failed operations 3 times', async () => {\n  let attempts = 0;\n  const operation = () => {\n    attempts++;\n    if (attempts < 3) throw new Error('fail');\n    return 'success';\n  };\n\nconst result = await retryOperation(operation);\n\nexpect(result).toBe('success');\nexpect(attempts).toBe(3);\n});\n\n````\nClear name, tests real behavior, one thing\n</Good>\n\n<Bad>\n```typescript\ntest('retry works', async () => {\n  const mock = jest.fn()\n    .mockRejectedValueOnce(new Error())\n    .mockRejectedValueOnce(new Error())\n    .mockResolvedValueOnce('success');\n  await retryOperation(mock);\n  expect(mock).toHaveBeenCalledTimes(3);\n});\n````\n\nVague name, tests mock not code\n</Bad>\n\n**Requirements:**\n\n- One behavior\n- Clear name\n- Real code (no mocks unless unavoidable)\n\n### Verify RED - Watch It Fail\n\n**MANDATORY. Never skip.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n\n- Test fails (not errors)\n- Failure message is expected\n- Fails because feature missing (not typos)\n\n**Test passes?** You're testing existing behavior. Fix test.\n\n**Test errors?** Fix error, re-run until it fails correctly.\n\n### GREEN - Minimal Code\n\nWrite simplest code to pass the test.\n\n<Good>\n```typescript\nasync function retryOperation<T>(fn: () => Promise<T>): Promise<T> {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await fn();\n    } catch (e) {\n      if (i === 2) throw e;\n    }\n  }\n  throw new Error('unreachable');\n}\n```\nJust enough to pass\n</Good>\n\n<Bad>\n```typescript\nasync function retryOperation<T>(\n  fn: () => Promise<T>,\n  options?: {\n    maxRetries?: number;\n    backoff?: 'linear' | 'exponential';\n    onRetry?: (attempt: number) => void;\n  }\n): Promise<T> {\n  // YAGNI\n}\n```\nOver-engineered\n</Bad>\n\nDon't add features, refactor other code, or \"improve\" beyond the test.\n\n### Verify GREEN - Watch It Pass\n\n**MANDATORY.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n\n- Test passes\n- Other tests still pass\n- Output pristine (no errors, warnings)\n\n**Test fails?** Fix code, not test.\n\n**Other tests fail?** Fix now.\n\n### REFACTOR - Clean Up\n\nAfter green only:\n\n- Remove duplication\n- Improve names\n- Extract helpers\n\nKeep tests green. Don't add behavior.\n\n### Repeat\n\nNext failing test for next feature.\n\n## Good Tests\n\n| Quality          | Good                                | Bad                                                 |\n| ---------------- | ----------------------------------- | --------------------------------------------------- |\n| **Minimal**      | One thing. \"and\" in name? Split it. | `test('validates email and domain and whitespace')` |\n| **Clear**        | Name describes behavior             | `test('test1')`                                     |\n| **Shows intent** | Demonstrates desired API            | Obscures what code should do                        |\n\n## Why Order Matters\n\n**\"I'll write tests after to verify it works\"**\n\nTests written after code pass immediately. Passing immediately proves nothing:\n\n- Might test wrong thing\n- Might test implementation, not behavior\n- Might miss edge cases you forgot\n- You never saw it catch the bug\n\nTest-first forces you to see the test fail, proving it actually tests something.\n\n**\"I already manually tested all the edge cases\"**\n\nManual testing is ad-hoc. You think you tested everything but:\n\n- No record of what you tested\n- Can't re-run when code changes\n- Easy to forget cases under pressure\n- \"It worked when I tried it\" ‚â† comprehensive\n\nAutomated tests are systematic. They run the same way every time.\n\n**\"Deleting X hours of work is wasteful\"**\n\nSunk cost fallacy. The time is already gone. Your choice now:\n\n- Delete and rewrite with TDD (X more hours, high confidence)\n- Keep it and add tests after (30 min, low confidence, likely bugs)\n\nThe \"waste\" is keeping code you can't trust. Working code without real tests is technical debt.\n\n**\"TDD is dogmatic, being pragmatic means adapting\"**\n\nTDD IS pragmatic:\n\n- Finds bugs before commit (faster than debugging after)\n- Prevents regressions (tests catch breaks immediately)\n- Documents behavior (tests show how to use code)\n- Enables refactoring (change freely, tests catch breaks)\n\n\"Pragmatic\" shortcuts = debugging in production = slower.\n\n**\"Tests after achieve the same goals - it's spirit not ritual\"**\n\nNo. Tests-after answer \"What does this do?\" Tests-first answer \"What should this do?\"\n\nTests-after are biased by your implementation. You test what you built, not what's required. You verify remembered edge cases, not discovered ones.\n\nTests-first force edge case discovery before implementing. Tests-after verify you remembered everything (you didn't).\n\n30 minutes of tests after ‚â† TDD. You get coverage, lose proof tests work.\n\n## Common Rationalizations (When TDD Applies)\n\n**Valid reasons to skip TDD:**\n| Reason | Reality |\n| ----------------------------- | ------------------------------------------------------------- |\n| \"This is a UI component\" | ‚úÖ Correct! Verify with typecheck/manual testing, skip tests. |\n| \"Simple CRUD, 100% confident\" | ‚úÖ Correct! Verify with typecheck/lint, skip tests. |\n| \"Straightforward mapping\" | ‚úÖ Correct! If truly simple, skip tests. |\n\n**Invalid rationalizations (for complex logic):**\n| Excuse | Reality |\n| -------------------------------------- | ----------------------------------------------------------------------- |\n| \"Too simple to test\" | If it's complex logic, test it. If truly simple, skip is fine. |\n| \"I'll test after\" | Tests passing immediately prove nothing. |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n| \"Already manually tested\" | Ad-hoc ‚â† systematic. No record, can't re-run. |\n| \"Deleting X hours is wasteful\" | Sunk cost fallacy. Keeping unverified code is technical debt. |\n| \"Keep as reference, write tests first\" | You'll adapt it. That's testing after. Delete means delete. |\n| \"Need to explore first\" | Fine. Throw away exploration, start with TDD. |\n| \"Test hard = design unclear\" | Listen to test. Hard to test = hard to use. |\n| \"TDD will slow me down\" | TDD faster than debugging. Pragmatic = test-first. |\n| \"Manual test faster\" | Manual doesn't prove edge cases. You'll re-test every change. |\n\n## Red Flags - When Using TDD\n\n**These only apply when you've decided to use TDD** (complex logic, user request):\n\n- Code before test\n- Test after implementation\n- Test passes immediately\n- Can't explain why test failed\n- Tests added \"later\"\n- \"Keep as reference\" or \"adapt existing code\"\n- \"Already spent X hours, deleting is wasteful\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n\n**Valid decision to skip TDD:**\n\n- ‚úÖ \"This is a UI component\" - Skip TDD, verify with typecheck\n- ‚úÖ \"Simple CRUD, 100% confident\" - Skip TDD, verify with lint\n- ‚úÖ \"Straightforward code\" - Skip TDD if truly simple\n\n## Example: Bug Fix\n\n**Bug:** Empty email accepted\n\n**RED**\n\n```typescript\ntest(\"rejects empty email\", async () => {\n  const result = await submitForm({ email: \"\" });\n  expect(result.error).toBe(\"Email required\");\n});\n```\n\n**Verify RED**\n\n```bash\n$ npm test\nFAIL: expected 'Email required', got undefined\n```\n\n**GREEN**\n\n```typescript\nfunction submitForm(data: FormData) {\n  if (!data.email?.trim()) {\n    return { error: \"Email required\" };\n  }\n  // ...\n}\n```\n\n**Verify GREEN**\n\n```bash\n$ npm test\nPASS\n```\n\n**REFACTOR**\nExtract validation for multiple fields if needed.\n\n## Verification Checklist\n\n**If using TDD** (complex logic, user request):\n\n- [ ] Every new complex function has a test\n- [ ] Watched each test fail before implementing\n- [ ] Each test failed for expected reason (feature missing, not typo)\n- [ ] Wrote minimal code to pass each test\n- [ ] All tests pass\n- [ ] Output pristine (no errors, warnings)\n- [ ] Tests use real code (mocks only if unavoidable)\n- [ ] Edge cases and errors covered\n\nCan't check all boxes? You skipped TDD. Start over.\n\n**If NOT using TDD** (UI, simple code):\n\n- [ ] Code is straightforward and you're 100% confident\n- [ ] `npm run typecheck` passes\n- [ ] `npm run lint` passes\n- [ ] Manual testing confirms UI works as expected\n- [ ] No complex business logic that needs test coverage\n\n## When Stuck\n\n| Problem                | Solution                                                             |\n| ---------------------- | -------------------------------------------------------------------- |\n| Don't know how to test | Write wished-for API. Write assertion first. Ask your human partner. |\n| Test too complicated   | Design too complicated. Simplify interface.                          |\n| Must mock everything   | Code too coupled. Use dependency injection.                          |\n| Test setup huge        | Extract helpers. Still complex? Simplify design.                     |\n\n## Debugging Integration\n\n**Bug in complex logic?**\nWrite failing test reproducing it. Follow TDD cycle. Test proves fix and prevents regression.\n\n**Bug in UI component or simple code?**\nFix directly. Verify with typecheck/lint/manual testing.\n\n**Decision criteria:**\n\n- Complex algorithm/business logic ‚Üí Write test\n- UI component/straightforward fix ‚Üí Skip test\n\n## Final Rules\n\n**When to use TDD:**\n\n1. **User explicitly requests tests**\n2. **Complex logic where bugs are likely** (algorithms, business logic, data transformations)\n\n**When to skip TDD:**\n\n- UI components (React components, hooks)\n- Simple CRUD operations\n- Straightforward mappings\n- Anything you're 100% certain is correct\n\n**If using TDD:**\n\n```\nProduction code ‚Üí test exists and failed first\nOtherwise ‚Üí not TDD\n```\n\n**If skipping TDD:**\n\n```\nProduction code ‚Üí typecheck + lint pass\nManual verification for UI changes\nCode review confidence\n```\n\n**Only deterministic unit tests** - no integration tests, no complex mocking, no async complexity.\n"
      },
      "plugins": [
        {
          "name": "dotai",
          "source": "./.claude-plugin/plugins/dotai",
          "description": "Complete development toolkit - documentation, PRDs, debugging, PR workflows, and planning",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install dotai@dotai"
          ]
        },
        {
          "name": "notification",
          "source": "./.claude-plugin/plugins/notification",
          "description": "macOS notifications for Claude Code events",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install notification@dotai"
          ]
        },
        {
          "name": "media",
          "source": "./.claude-plugin/plugins/media",
          "description": "Auto-play/pause media on prompt submit/stop",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install media@dotai"
          ]
        },
        {
          "name": "codex",
          "source": "./.claude-plugin/plugins/codex",
          "description": "MCP servers for Codex integration",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install codex@dotai"
          ]
        },
        {
          "name": "debug",
          "source": "./.claude-plugin/plugins/debug",
          "description": "Systematic debugging and root cause analysis framework - four-phase investigation process ensuring understanding before fixes",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install debug@dotai"
          ]
        },
        {
          "name": "test",
          "source": "./.claude-plugin/plugins/test",
          "description": "Test-driven development workflow for writing tests before implementation - red-green-refactor cycle with deterministic unit tests",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install test@dotai"
          ]
        },
        {
          "name": "learn",
          "source": "./.claude-plugin/plugins/learn",
          "description": "Continuous learning system - extracts reusable knowledge from work sessions into Claude Code skills",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install learn@dotai"
          ]
        },
        {
          "name": "git",
          "source": "./.claude-plugin/plugins/git",
          "description": "Git and GitHub workflow automation - streamlined PR creation, draft management, and code review workflows",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install git@dotai"
          ]
        },
        {
          "name": "dig",
          "source": "./.claude-plugin/plugins/dig",
          "description": "Dig into library source code - clone and explore repos to answer API questions",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add udecode/dotai",
            "/plugin install dig@dotai"
          ]
        }
      ]
    }
  ]
}