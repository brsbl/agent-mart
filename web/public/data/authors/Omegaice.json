{
  "author": {
    "id": "Omegaice",
    "display_name": "James",
    "avatar_url": "https://avatars.githubusercontent.com/u/950526?v=4"
  },
  "marketplaces": [
    {
      "name": "git-lines",
      "version": null,
      "description": "Line-level git staging for LLMs and automation",
      "repo_full_name": "Omegaice/git-lines",
      "repo_url": "https://github.com/Omegaice/git-lines",
      "repo_description": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-11-26T13:42:52Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"git-lines\",\n  \"owner\": {\n    \"name\": \"Omegaice\",\n    \"url\": \"https://github.com/Omegaice\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"git-lines\",\n      \"description\": \"Line-level git staging for LLMs and automation\",\n      \"source\": \"./\",\n      \"version\": \"0.1.0\",\n      \"keywords\": [\"git\", \"staging\", \"commits\"]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"git-lines\",\n  \"description\": \"Line-level git staging for LLMs and automation\",\n  \"version\": \"0.2.0\",\n  \"author\": {\n    \"name\": \"Omegaice\",\n    \"url\": \"https://github.com/Omegaice\"\n  },\n  \"repository\": \"https://github.com/Omegaice/git-lines\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"git\", \"staging\", \"commits\", \"line-level\"]\n}\n",
        "README.md": "# git-lines\n\nNon-interactive line-level git staging tool for LLMs and automation.\n\n## Overview\n\n`git-lines` enables programmatic, line-level staging of git changes. It fills the gap left by `git add -p`, which requires interactive input and cannot be used by LLMs or automation tools.\n\nWhen an LLM or automated system makes changes to code, those changes are often semantically distinct but physically interleaved in the same file. `git-lines` allows these systems to autonomously organize changes into clean, semantic commits without human intervention.\n\n## The Problem\n\nGit's interactive staging (`git add -p`) operates at the hunk level and requires a human at a terminal. This creates a limitation for LLMs:\n\n- ✅ LLMs can write code\n- ✅ LLMs can run `git commit`\n- ❌ LLMs cannot use `git add -p` (interactive/TUI)\n\nResult: LLMs can only stage entire files with `git add <file>`, losing the ability to create focused, semantic commits when multiple unrelated changes exist in the same file.\n\n## The Solution\n\n`git-lines` provides a non-interactive CLI for line-level staging:\n\n```bash\n# 1. View changes with line numbers\ngit-lines diff\n\n# 2. Stage specific lines by number\ngit-lines stage flake.nix:137,142\ngit-lines stage config.nix:10..15\ngit-lines stage zsh.nix:-20,-21\n\n# 3. Commit as usual\ngit commit -m \"Add new dependencies\"\n```\n\nThis workflow is fully scriptable and requires no human interaction.\n\n## Example: Semantic Commits from Mixed Changes\n\nConsider these changes in one file:\n\n```bash\n$ git-lines diff vscode/default.nix\nvscode/default.nix:\n  +40:        # Allow Stylix to override terminal font\n  +41:        \"terminal.integrated.fontFamily\" = lib.mkDefault \"monospace\";\n  +42:        \"direnv.restart.automatic\" = true;\n```\n\nGit sees this as one atomic hunk. But semantically it's two features:\n- Lines 40-41: Theme configuration (related to Stylix)\n- Line 42: Direnv settings (unrelated)\n\nWith `git-lines`, an LLM can create two focused commits:\n\n```bash\n# Commit 1: Theme changes\ngit-lines stage vscode/default.nix:40..41\ngit commit -m \"feat: add Stylix font override for terminal\"\n\n# Commit 2: Direnv changes\ngit-lines stage vscode/default.nix:42\ngit commit -m \"feat: enable automatic direnv restart\"\n```\n\nEach commit is self-contained and semantically coherent.\n\n## Installation\n\n### From crates.io\n\n```bash\ncargo install git-lines\n```\n\n### From source\n\n```bash\ngit clone https://github.com/Omegaice/git-lines\ncd git-lines\ncargo install --path .\n```\n\n### Shell Completions\n\n```bash\n# Bash\ngit-lines completions bash > ~/.local/share/bash-completion/completions/git-lines\n\n# Zsh\ngit-lines completions zsh > ~/.zfunc/_git-lines\n\n# Fish\ngit-lines completions fish > ~/.config/fish/completions/git-lines.fish\n```\n\n## Usage\n\n### Basic Workflow\n\n```bash\n# 1. Make changes to files (manually or via LLM)\n# 2. View unstaged changes with line numbers\ngit-lines diff\n\n# 3. Stage specific lines\ngit-lines stage file.nix:10,15,20\n\n# 4. Create commit\ngit commit -m \"Your commit message\"\n```\n\n### Line Reference Syntax\n\n```bash\n# Single addition (new line 137)\ngit-lines stage flake.nix:137\n\n# Range of additions (lines 10-15 inclusive)\ngit-lines stage config.nix:10..15\n\n# Single deletion (old line 20)\ngit-lines stage zsh.nix:-20\n\n# Range of deletions\ngit-lines stage file.nix:-10..-15\n\n# Multiple selections (comma-separated)\ngit-lines stage config.nix:10,15,20\n\n# Mixed operations\ngit-lines stage gtk.nix:-10,-11,12\n\n# Multiple files in one command\ngit-lines stage flake.nix:137 gtk.nix:12 zsh.nix:-15\n```\n\n### Advanced Examples\n\n**Splitting changes within a single hunk:**\n\n```bash\n$ git-lines diff config.nix\nconfig.nix:\n  +10:    feature_a_enabled = true;\n  +11:    feature_a_timeout = 30;\n  +12:    feature_b_enabled = true;\n\n# Stage only feature A\n$ git-lines stage config.nix:10,11\n$ git commit -m \"Enable feature A with 30s timeout\"\n\n# Later, stage feature B\n$ git-lines stage config.nix:12\n$ git commit -m \"Enable feature B\"\n```\n\n**Staging from multiple non-contiguous hunks:**\n\n```bash\n$ git-lines diff flake.nix\nflake.nix:\n  +7:       determinate.url = \"github:DeterminateSystems/determinate\";\n\n  +137:       debug = true;\n\n  +142:         ./flake-modules/home-manager.nix\n\n# Stage lines from different hunks that are semantically related\n$ git-lines stage flake.nix:7,142\n$ git commit -m \"Add determinate and home-manager modules\"\n```\n\n**Selective staging from mixed additions and deletions:**\n\n```bash\n$ git-lines diff gtk.nix\ngtk.nix:\n  -10:    gtk.theme.name = \"Adwaita\";\n  -11:    gtk.iconTheme.name = \"Papirus\";\n  +10:    # Theme managed by Stylix\n  +11:    gtk.iconTheme.name = \"Papirus-Dark\";\n  +12:    gtk.cursorTheme.size = 24;\n\n# Stage only the cursor size addition, ignore theme changes\n$ git-lines stage gtk.nix:12\n$ git commit -m \"Set cursor size to 24\"\n```\n\n## When to Use\n\n### Use `git-lines` when:\n- Multiple unrelated changes exist in the same file\n- You need programmatic/scriptable staging (LLM workflows)\n- Changes need to be organized into semantic commits\n- `git add -p` hunks are too coarse\n\n### Use regular `git add` when:\n- Staging entire files\n- All changes in a file are semantically related\n- Changes are already separated by file boundaries\n\n**Philosophy**: `git-lines` is a companion to git, not a replacement. Use it only when line-level precision is needed.\n\n## How It Works\n\n1. **Parse references**: `file.nix:10,15,-20` → structured line selections\n2. **Fetch git diff**: Run `git diff -U0` to get changes with zero context\n3. **Filter lines**: Extract only the requested lines from the diff\n4. **Apply patch**: Feed the filtered patch to `git apply --cached`\n\nLine numbers are always based on the output of `git-lines diff`, which shows the current state of unstaged changes.\n\n## Use Cases\n\n### LLM Coding Assistants\n- Claude Code (Anthropic)\n- GitHub Copilot\n- Cursor\n- Aider\n- Custom LLM automation\n\nLLMs can now create clean commit history autonomously without human intervention for staging.\n\n### Human Workflows\n- Code review: Stage reviewer suggestions one at a time\n- Incremental refactoring: Separate style changes from logic changes\n- Bug fixes: Commit discovered bugs separately from feature work\n- Any scenario requiring scriptable line-level staging\n\n## Design Principles\n\n- **Non-interactive by design**: No prompts, no TUI, pure CLI\n- **Minimal dependencies**: Only clap and error_set at runtime\n- **Git-native**: Uses `git diff` and `git apply`, not libgit2\n- **Line-level precision**: Finer granularity than hunks\n- **Automation-first**: Built for programmatic use\n\n## Limitations\n\n- Requires `git` in PATH (uses CLI git commands)\n- Works only on unstaged changes\n- Line numbers are from `git diff` output (shift after partial staging)\n- Does not handle interactive rebase or patch editing\n\n## License\n\nMIT\n\n## Contributing\n\nIssues and pull requests welcome at [github.com/Omegaice/git-lines](https://github.com/Omegaice/git-lines)\n\n## Documentation\n\nFull API documentation: [docs.rs/git-lines](https://docs.rs/git-lines)\n\n---\n\nBuilt to solve the line-level staging gap in LLM and automation workflows.\n"
      },
      "plugins": [
        {
          "name": "git-lines",
          "description": "Line-level git staging for LLMs and automation",
          "source": "./",
          "version": "0.1.0",
          "keywords": [
            "git",
            "staging",
            "commits"
          ],
          "categories": [
            "commits",
            "git",
            "staging"
          ],
          "install_commands": [
            "/plugin marketplace add Omegaice/git-lines",
            "/plugin install git-lines@git-lines"
          ]
        }
      ]
    }
  ]
}