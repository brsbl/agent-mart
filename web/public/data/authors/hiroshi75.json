{
  "author": {
    "id": "hiroshi75",
    "display_name": "Hiroshi75",
    "avatar_url": "https://avatars.githubusercontent.com/u/29772157?v=4"
  },
  "marketplaces": [
    {
      "name": "hiroshi75",
      "version": null,
      "description": "English version of plan-parallel-dev-plugin. Skill for creating parallel development plans with multiple developers using git worktree, dependency analysis, critical path calculation, and timeline creation.",
      "repo_full_name": "hiroshi75/ccplugins",
      "repo_url": "https://github.com/hiroshi75/ccplugins",
      "repo_description": null,
      "signals": {
        "stars": 3,
        "forks": 0,
        "pushed_at": "2026-01-16T15:03:27Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"hiroshi75\",\n  \"owner\": {\n    \"name\": \"Hiroshi Ayukawa\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"parallel-dev-plugin\",\n      \"source\": \"./parallel-dev-plugin\",\n      \"description\": \"English version of plan-parallel-dev-plugin. Skill for creating parallel development plans with multiple developers using git worktree, dependency analysis, critical path calculation, and timeline creation.\"\n    }\n  ]\n}\n",
        "README.md": "# Claude Code Plugins\n\nA collection of plugins for Claude Code.\n\n## Available Plugins\n\n| Plugin | Description |\n|--------|-------------|\n| **[parallel-dev-plugin](parallel-dev-plugin/)** | Turn one Claude into a development team. Orchestrates multiple Claude instances working in parallel with automatic coordination and merging. |\n\n## Installation\n\n```bash\n/plugin marketplace add hiroshi75/ccplugins\n/plugin install <plugin-name>@hiroshi75\n```\n\n## Author\n\nHiroshi Ayukawa\n\n## License\n\nMIT\n",
        "parallel-dev-plugin/README.md": "# parallel-dev-plugin\n\n**Turn one Claude into a development team.**\n\nRun 5 features in parallel. Merge automatically. Ship faster.\n\n---\n\n## The Problem\n\nYou have 10 tasks to complete. With traditional development:\n\n- You work on them **one by one**\n- Context switching kills productivity\n- A single blocker stalls everything\n- \"I'll review your PR tomorrow\" delays compound\n\nWhat if you could run them all **at the same time**?\n\n---\n\n## The Solution\n\nThis plugin orchestrates **multiple Claude instances** working in parallel, each in its own git worktree, with automatic coordination and merging.\n\n```\nYou: \"Build user auth, payment integration, and admin dashboard in parallel\"\n\nClaude: Creates 3 worktrees, launches 3 worker instances,\n        coordinates dependencies, merges completed work automatically\n```\n\n### Key Features\n\n| Feature                     | What it does                                                    |\n| --------------------------- | --------------------------------------------------------------- |\n| **Task Decomposition**      | Breaks features into parallelizable units                       |\n| **Dependency Analysis**     | Calculates critical path, identifies blockers                   |\n| **Worktree Isolation**      | Each task gets its own git worktree                             |\n| **Environment Setup**       | Copies `.env`, assigns unique ports per worktree (no conflicts) |\n| **Auto-Merge Coordination** | Handles merge order and conflicts                               |\n\n---\n\n## Design Philosophy\n\n### AI-First, No PRs\n\nThis plugin deliberately **skips pull requests**.\n\nTraditional PRs are designed for human review cycles:\n\n- Create PR → Wait for review → Address comments → Wait again → Merge\n\nBut when AI handles everything, this overhead becomes waste.\n\n**Our approach:**\n\n- Worker Claude completes implementation → Creates a `.done` file (a simple text file signaling completion)\n- Merge Coordinator detects the file → Runs tests → Merges directly to integration branch\n- Issues? Creates a new task, not a review thread\n\nThis enables **continuous integration at AI speed** — no human bottlenecks in the loop.\n\n> Human oversight happens at the planning stage (approving the task breakdown) and the final stage (reviewing the integrated result), not at every merge.\n\n### Full-Power Workers, Not Limited Subagents\n\nClaude Code's built-in Task tool has a critical limitation: **subagents cannot spawn their own subagents**. This creates a shallow execution tree where complex tasks must be handled by a single agent.\n\nThis plugin takes a different approach:\n\n```\nRegular subagent:        This plugin:\n\nParent                   Merge Coordinator\n  └── Subagent ✗           └── Worker (full Claude Code)\n        └── (blocked)            ├── Subagent A\n                                 ├── Subagent B\n                                 └── Subagent C\n```\n\nEach worker is a **full Claude Code instance** launched via tmux, not a subagent. This means:\n\n- **Workers can use the Task tool** to spawn their own subagents\n- **Parallel exploration within each task** — search, analyze, implement simultaneously\n- **No depth limits** — workers have the same capabilities as the parent\n- **Full tool access** — every worker can use all available MCP tools and skills\n\nThe result: each parallel task gets the full power of Claude Code, not a watered-down subprocess.\n\n---\n\n## Quick Start\n\n### 1. Install the plugin\n\n```bash\n# Clone to your Claude Code plugins directory\ngit clone https://github.com/yourrepo/parallel-dev-plugin ~/.claude/plugins/parallel-dev-plugin\n```\n\n### 2. Launch Claude Code inside tmux\n\nWorkers are spawned as new tmux windows, so you must start from within tmux:\n\n```bash\ntmux new -s dev\ncd your-project\nclaude\n```\n\n### 3. Start parallel development\n\n**Option A: MVP Build Mode** (build a complete product from scratch)\n\n```\n\"Build an MVP with user authentication, payment processing, and notification system\"\n```\n\n**Option B: Quick task mode** (for immediate tasks)\n\n```\n\"Fix the login bug and add logout button in parallel\"\n```\n\n### 4. Watch it work\n\nClaude will:\n\n1. Decompose tasks and analyze dependencies\n2. Create worktrees for each task\n3. Launch worker instances via tmux\n4. Monitor completion signals\n5. Merge in correct order\n6. Report final status\n\n---\n\n## How It Works\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                    Merge Coordinator                        │\n│  (monitors .done signals, manages merge order, runs tests)  │\n└─────────────────────┬───────────────────────────────────────┘\n                      │\n        ┌─────────────┼─────────────┐\n        ▼             ▼             ▼\n   ┌─────────┐   ┌─────────┐   ┌─────────┐\n   │Worker 1 │   │Worker 2 │   │Worker 3 │\n   │(auth)   │   │(payment)│   │(admin)  │\n   └────┬────┘   └────┬────┘   └────┬────┘\n        │             │             │\n   worktree/        worktree/          worktree/\n   feat-auth/       feat-payment/      feat-admin/\n```\n\n**Worker Claude**: Focuses only on implementation. No commits, no pushes — just code.\n\n**Merge Coordinator**: Handles all git operations, testing, and integration.\n\n---\n\n## Usage Modes\n\n### Mode A: MVP Build Mode\n\nFor building a complete product from scratch to working MVP in one shot.\n\n**Trigger phrases:**\n\n- \"Build an MVP with these features\"\n- \"Create a parallel development plan for this project\"\n- \"Develop the entire system from scratch\"\n\n**What happens:**\n\n1. Requirements analysis and architecture design\n2. Task decomposition with dependency mapping\n3. Critical path calculation for optimal parallelism\n4. Worktree and branch setup for all tasks\n5. Worker launch, coordination, and automatic merging\n6. Integrated MVP ready for review\n\n### Mode B: Quick Task Mode\n\nFor immediate bug fixes or small features.\n\n**Trigger phrases:**\n\n- \"Fix X and Y in parallel\"\n- \"Add these tasks to parallel development\"\n- \"Run these with worktree\"\n\n**What happens:**\n\n1. Instant worktree creation\n2. Minimal task instruction generation\n3. Worker launch\n4. Merge on completion\n\n---\n\n## Directory Structure\n\n```\nyour-project/\n├── src/                        # Your existing source code\n│   └── ...\n├── package.json                # Your existing config files\n├── ...                         # (other project files)\n│\n├── .parallel-dev/              # Git-tracked planning docs\n│   ├── PLAN.md                 # Overall development plan\n│   ├── README.md               # Progress dashboard\n│   ├── merge-coordinator.md    # Coordinator instructions\n│   └── tasks/\n│       ├── auth-system.md      # Task: Authentication\n│       ├── payment-api.md      # Task: Payment\n│       └── admin-panel.md      # Task: Admin\n│\n├── .parallel-dev-signals/      # Gitignored, file-based signals\n│   └── auth-system.done        # Simple text file: \"I'm done, here's what I did\"\n│\n├── .parallel-dev-issues/       # Gitignored issue reports\n│   └── payment-api.md          # Issue requiring attention\n│\n└── worktree/                   # Gitignored worktrees\n    ├── feat-auth-system/       # Full copy of project + isolated branch\n    │   ├── src/\n    │   ├── package.json\n    │   ├── .env                # Copied from parent\n    │   ├── .env.local          # Unique ports for this worktree\n    │   └── ...\n    ├── feat-payment-api/\n    └── feat-admin-panel/\n```\n\n---\n\n## When to Use This\n\n**Good fit:**\n\n- Multiple independent features to build\n- Bug fixes that don't conflict\n- Refactoring across different modules\n- Any work that can be parallelized\n\n**Not ideal for:**\n\n- Highly interdependent changes to the same files\n- Tasks requiring extensive human deliberation\n- Single, focused changes (just use regular Claude)\n\n---\n\n## FAQ\n\n**Q: What if two workers edit the same file?**  \nA: The merge coordinator handles conflicts.\n\n**Q: How many workers can run in parallel?**  \nA: Practically 3-5 works well. More workers = more coordination overhead.\n\n**Q: Can I intervene during parallel development?**  \nA: Yes. Check `.parallel-dev/README.md` for status. Stop workers with `tmux kill-window -t <task-name>`.\n\n**Q: What about code review?**  \nA: Review the integrated result on the integration branch. The AI handles task-level verification.\n\n---\n\n## License\n\nMIT\n\n---\n\n## See Also\n\n- [SKILL.md](skills/plan-parallel-dev/SKILL.md) — Detailed skill specification\n- [Worktree Guide](skills/plan-parallel-dev/references/worktree-guide.md) — Git worktree deep dive\n- [Quick Mode Guide](skills/plan-parallel-dev/references/quick-mode-guide.md) — Mode B details\n"
      },
      "plugins": [
        {
          "name": "parallel-dev-plugin",
          "source": "./parallel-dev-plugin",
          "description": "English version of plan-parallel-dev-plugin. Skill for creating parallel development plans with multiple developers using git worktree, dependency analysis, critical path calculation, and timeline creation.",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hiroshi75/ccplugins",
            "/plugin install parallel-dev-plugin@hiroshi75"
          ]
        }
      ]
    },
    {
      "name": "langgraph-architect",
      "version": null,
      "description": "LangGraph development accelerator - Architecture patterns, parallel module development, and data-driven optimization for building AI agents",
      "repo_full_name": "hiroshi75/langgraph-architect",
      "repo_url": "https://github.com/hiroshi75/langgraph-architect",
      "repo_description": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-01T12:57:35Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"langgraph-architect\",\n  \"owner\": {\n    \"name\": \"Hiroshi Ayukawa\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"langgraph-architect\",\n      \"description\": \"LangGraph development accelerator - Architecture patterns, parallel module development, and data-driven optimization for building AI agents\",\n      \"source\": \"./langgraph-architect\"\n    }\n  ]\n}\n",
        "README.md": "# LangGraph Architect Plugin\n\n**Build LangGraph agents faster. Optimize them systematically.**\n\nA Claude Code plugin that provides architecture patterns, parallel development workflows, and data-driven optimization for LangGraph applications.\n\n![LangGraph Architect in Action](./img/main_ss.gif)\n\n```\n# Install\n/plugin marketplace add hiroshi75/langgraph-architect\n/plugin install langgraph-architect@langgraph-architect\n```\n\n## What You Get\n\n### 1. Instant LangGraph Expertise\n\nClaude automatically provides architecture guidance when you work with LangGraph:\n\n```\nBuild a Gemini+grounding deep-research agent that runs on the CLI using LangGraph.\n```\n\n40+ documentation files covering:\n\n- Core concepts (State, Node, Edge)\n- 6 architecture patterns (Routing, Agent, Parallelization, etc.)\n- Memory management (Checkpointer, Store, Persistence)\n- Tool integration and advanced features\n- Model ID references for Claude, Gemini, and OpenAI\n\n### 2. Parallel Development with Subagents\n\nBreak complex graphs into modules. Build them simultaneously.\n\n```\nYour request: \"Build a chatbot with intent analysis and RAG search\"\n\nClaude decomposes → spawns parallel agents:\n  ├─ langgraph-engineer 1: Intent module (analyze → classify → route)\n  └─ langgraph-engineer 2: RAG module (retrieve → rerank → generate)\n\nBoth run in parallel → integrate into complete graph\n```\n\n### 3. Prompt-Level Optimization (fine-tune)\n\nThe `fine-tune` skill optimizes your LangGraph prompts without changing graph structure. It activates automatically when Claude detects optimization needs, or invoke manually by `/fine-tune`.\n\n```bash\n/fine-tune Fine-Tuning objective: Increase concreteness.\nRevise the base prompt so that the generated reports become more concrete and technical, not abstract or generic. Require the model to use specific components, data flows, algorithms, failure modes, and examples.\nUse an LLM-based evaluator to assess “concreteness,” and place the evaluation script under eval/. Use that evaluator during tuning.\n```\n\n**Auto-activation triggers:**\n\n- \"improve accuracy\", \"reduce cost\", \"optimize prompts\"\n- \"the output is not good enough\", \"responses are inconsistent\"\n\n**4-Phase Workflow:**\n\n```\nPhase 1: Baseline    → Measure current accuracy, latency, cost\nPhase 2: Analysis    → Identify underperforming nodes and patterns\nPhase 3: Optimize    → Apply techniques (few-shot, CoT, constraints)\nPhase 4: Validate    → Statistical validation (3-5 runs) and apply\n```\n\n**Typical gains:** Accuracy +10-20%, Cost -20-60%\n\n### 4. Architecture-Level Optimization (arch-tune)\n\nThe `/arch-tune` command explores multiple graph structure improvements in parallel:\n\n```bash\n/arch-tune \"Improve latency to under 2.0s and accuracy to 90%\"\n```\n\nWhat happens:\n\n1. **Analyze** current graph and generate 3-5 improvement proposals\n2. **Implement** each proposal in isolated git worktrees (parallel)\n3. **Optimize** prompts and parameters for each variant (parallel)\n4. **Compare** results with statistical validation\n5. **Merge** the winner with your approval\n\n**Typical gains:** Latency -20-50%, Accuracy +10-30%\n\n## Skills\n\n| Skill                 | Purpose                                                        |\n| --------------------- | -------------------------------------------------------------- |\n| `langgraph-architect` | Architecture patterns and implementation guidance              |\n| `fine-tune`           | Iterative prompt optimization without changing graph structure |\n| `arch-analysis`       | Analyze bottlenecks and generate improvement proposals         |\n\n## Agents\n\n| Agent                 | Role                                               |\n| --------------------- | -------------------------------------------------- |\n| `langgraph-engineer`  | Implements complete functional modules (2-5 nodes) |\n| `langgraph-tuner`     | Executes optimization workflow with evaluation     |\n| `proposal-comparator` | Compares results and recommends best option        |\n| `merge-coordinator`   | Handles user approval and git operations           |\n\n## Commands\n\n| Command      | Description                                          |\n| ------------ | ---------------------------------------------------- |\n| `/arch-tune` | Full optimization pipeline with parallel exploration |\n\n## Quick Examples\n\n### Get Architecture Guidance\n\nJust start coding. Claude provides patterns automatically.\n\n```python\n# Working on a RAG agent? Claude suggests:\n# - retrieve → rerank → generate pattern\n# - Checkpointer for conversation memory\n# - Subgraph for modular RAG logic\n```\n\n### Optimize an Existing Graph\n\n```bash\n# Prompt-level optimization (no structure changes). It can be auto-triggered or manual by `/fine-tune`.\n/fine-tune \"Increase accuracy by 15%\"\n```\n\n```bash\n# Architecture-level optimization (structure changes)\n/arch-tune \"Reduce latency by 30%\"\n```\n\n### Build Modules in Parallel\n\nFor complex applications, Claude spawns multiple `langgraph-engineer` agents:\n\n```\nTask: Customer support bot with routing, RAG, and escalation\n\nParallel execution:\n├─ Agent 1: Intent routing module\n├─ Agent 2: RAG search module\n└─ Agent 3: Human escalation module\n\nResult: Complete implementation in ~20 min instead of ~60 min\n```\n\n## How arch-tune Works\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│  Phase 1: Analysis (arch-analysis skill)                        │\n│  - Measure baseline performance                                 │\n│  - Analyze graph structure                                      │\n│  - Generate 3-5 improvement proposals                           │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│  Phase 2: Implementation (parallel langgraph-engineers)         │\n│                                                                 │\n│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │\n│  │ Proposal 1   │  │ Proposal 2   │  │ Proposal 3   │          │\n│  │ (worktree)   │  │ (worktree)   │  │ (worktree)   │          │\n│  └──────────────┘  └──────────────┘  └──────────────┘          │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│  Phase 3: Optimization (parallel langgraph-tuners)              │\n│  - Run fine-tune skill on each variant                          │\n│  - Evaluate with statistical validation (3-5 runs)              │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│  Phase 4: Comparison (proposal-comparator)                      │\n│  - Calculate goal achievement scores                            │\n│  - Risk-adjusted ranking                                        │\n│  - Clear recommendation with rationale                          │\n└─────────────────────────────────────────────────────────────────┘\n                              ↓\n┌─────────────────────────────────────────────────────────────────┐\n│  Phase 5: Merge (merge-coordinator)                             │\n│  - Present results to user                                      │\n│  - Merge selected proposal                                      │\n│  - Clean up worktrees and branches                              │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Requirements\n\n- Claude Code CLI\n- Git (for arch-tune worktree operations)\n- Python environment with LangGraph installed\n\n## File Structure\n\n```\n.claude-plugin/\n├── plugin.json\n\nskills/\n├── langgraph-architect/      # 40+ documentation files\n│   ├── SKILL.md\n│   ├── 01_core_concepts_*.md\n│   ├── 02_graph_architecture_*.md\n│   ├── 03_memory_management_*.md\n│   ├── 04_tool_integration_*.md\n│   ├── 05_advanced_features_*.md\n│   ├── 06_llm_model_ids*.md\n│   └── example_*.md\n├── fine-tune/             # Prompt optimization skill\n│   ├── SKILL.md\n│   ├── workflow*.md\n│   ├── evaluation*.md\n│   └── prompt_*.md\n└── arch-analysis/         # Architecture analysis skill\n    └── SKILL.md\n\nagents/\n├── langgraph-engineer.md  # Module implementation specialist\n├── langgraph-tuner.md     # Optimization execution specialist\n├── proposal-comparator.md # Results comparison specialist\n└── merge-coordinator.md   # Merge and cleanup coordinator\n\ncommands/\n└── arch-tune.md           # Full optimization pipeline\n```\n\n## License\n\nMIT\n\n## Links\n\n- [LangGraph Official Documentation](https://docs.langchain.com/oss/python/langgraph/overview)\n- [LangGraph GitHub](https://github.com/langchain-ai/langgraph)\n"
      },
      "plugins": [
        {
          "name": "langgraph-architect",
          "description": "LangGraph development accelerator - Architecture patterns, parallel module development, and data-driven optimization for building AI agents",
          "source": "./langgraph-architect",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add hiroshi75/langgraph-architect",
            "/plugin install langgraph-architect@langgraph-architect"
          ]
        }
      ]
    }
  ]
}