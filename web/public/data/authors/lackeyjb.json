{
  "author": {
    "id": "lackeyjb",
    "display_name": "Bryan Lackey",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/9823496?u=98d21cc2da7551bbce1543b9f5a6e015dd50ef5a&v=4",
    "url": "https://github.com/lackeyjb",
    "bio": null,
    "stats": {
      "total_marketplaces": 2,
      "total_plugins": 2,
      "total_commands": 11,
      "total_skills": 6,
      "total_stars": 1528,
      "total_forks": 85
    }
  },
  "marketplaces": [
    {
      "name": "playwright-skill",
      "version": null,
      "description": "Playwright browser automation skill for Claude Code",
      "owner_info": {
        "name": "lackeyjb",
        "email": "github@lackeyjb"
      },
      "keywords": [],
      "repo_full_name": "lackeyjb/playwright-skill",
      "repo_url": "https://github.com/lackeyjb/playwright-skill",
      "repo_description": "Claude Code Skill for browser automation with Playwright. Model-invoked - Claude autonomously writes and executes custom automation for testing and validation.",
      "homepage": "",
      "signals": {
        "stars": 1518,
        "forks": 85,
        "pushed_at": "2025-12-19T16:23:38Z",
        "created_at": "2025-10-19T21:33:51Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1094
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 577
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 8587
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/playwright-skill",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/playwright-skill/API_REFERENCE.md",
          "type": "blob",
          "size": 16366
        },
        {
          "path": "skills/playwright-skill/SKILL.md",
          "type": "blob",
          "size": 13930
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"playwright-skill\",\n  \"owner\": {\n    \"name\": \"lackeyjb\",\n    \"email\": \"github@lackeyjb\"\n  },\n  \"metadata\": {\n    \"description\": \"Playwright browser automation skill for Claude Code\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"playwright-skill\",\n      \"source\": \"./\",\n      \"description\": \"Claude Code Skill for general-purpose browser automation with Playwright. Claude autonomously writes and executes custom automation for testing pages, validating UX, and any browser task.\",\n      \"version\": \"4.1.0\",\n      \"author\": {\n        \"name\": \"lackeyjb\"\n      },\n      \"homepage\": \"https://github.com/lackeyjb/playwright-skill\",\n      \"repository\": \"https://github.com/lackeyjb/playwright-skill\",\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"claude-skill\",\n        \"claude-code\",\n        \"playwright\",\n        \"browser-automation\",\n        \"testing\",\n        \"e2e\",\n        \"web-testing\",\n        \"automation\",\n        \"model-invoked\"\n      ],\n      \"category\": \"testing\",\n      \"tags\": [\"browser\", \"automation\", \"playwright\", \"testing\", \"e2e\"]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"playwright-skill\",\n  \"version\": \"4.1.0\",\n  \"description\": \"Claude Code Skill for general-purpose browser automation with Playwright. Auto-detects dev servers, writes clean test scripts to /tmp, and autonomously handles any browser automation task.\",\n  \"author\": {\n    \"name\": \"lackeyjb\"\n  },\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/lackeyjb/playwright-skill\",\n  \"keywords\": [\n    \"claude-skill\",\n    \"claude-code\",\n    \"playwright\",\n    \"browser-automation\",\n    \"testing\",\n    \"e2e\",\n    \"web-testing\",\n    \"automation\",\n    \"model-invoked\"\n  ]\n}\n",
        "README.md": "# Playwright Skill for Claude Code\n\n**General-purpose browser automation as a Claude Skill**\n\nA [Claude Skill](https://www.anthropic.com/blog/skills) that enables Claude to write and execute any Playwright automation on-the-fly - from simple page tests to complex multi-step flows. Packaged as a [Claude Code Plugin](https://docs.claude.com/en/docs/claude-code/plugins) for easy installation and distribution.\n\nClaude autonomously decides when to use this skill based on your browser automation needs, loading only the minimal information required for your specific task.\n\nMade using Claude Code.\n\n## Features\n\n- **Any Automation Task** - Claude writes custom code for your specific request, not limited to pre-built scripts\n- **Visible Browser by Default** - See automation in real-time with `headless: false`\n- **Zero Module Resolution Errors** - Universal executor ensures proper module access\n- **Progressive Disclosure** - Concise SKILL.md with full API reference loaded only when needed\n- **Safe Cleanup** - Smart temp file management without race conditions\n- **Comprehensive Helpers** - Optional utility functions for common tasks\n\n## Installation\n\nThis repository is structured as a [Claude Code Plugin](https://docs.claude.com/en/docs/claude-code/plugins) containing a skill. You can install it as either a **plugin** (recommended) or extract it as a **standalone skill**.\n\n### Understanding the Structure\n\nThis repository uses the plugin format with a nested structure:\n\n```\nplaywright-skill/              # Plugin root\nâ”œâ”€â”€ .claude-plugin/           # Plugin metadata\nâ””â”€â”€ skills/\n    â””â”€â”€ playwright-skill/     # The actual skill\n        â””â”€â”€ SKILL.md\n```\n\nClaude Code expects skills to be directly in folders under `.claude/skills/`, so manual installation requires extracting the nested skill folder.\n\n---\n\n### Option 1: Plugin Installation (Recommended)\n\nInstall via Claude Code's plugin system for automatic updates and team distribution:\n\n```bash\n# Add this repository as a marketplace\n/plugin marketplace add lackeyjb/playwright-skill\n\n# Install the plugin\n/plugin install playwright-skill@playwright-skill\n\n# Navigate to the skill directory and run setup\ncd ~/.claude/plugins/marketplaces/playwright-skill/skills/playwright-skill\nnpm run setup\n```\n\nVerify installation by running `/help` to confirm the skill is available.\n\n---\n\n### Option 2: Standalone Skill Installation\n\nTo install as a standalone skill (without the plugin system), extract only the skill folder:\n\n**Global Installation (Available Everywhere):**\n\n```bash\n# Clone to a temporary location\ngit clone https://github.com/lackeyjb/playwright-skill.git /tmp/playwright-skill-temp\n\n# Copy only the skill folder to your global skills directory\nmkdir -p ~/.claude/skills\ncp -r /tmp/playwright-skill-temp/skills/playwright-skill ~/.claude/skills/\n\n# Navigate to the skill and run setup\ncd ~/.claude/skills/playwright-skill\nnpm run setup\n\n# Clean up temporary files\nrm -rf /tmp/playwright-skill-temp\n```\n\n**Project-Specific Installation:**\n\n```bash\n# Clone to a temporary location\ngit clone https://github.com/lackeyjb/playwright-skill.git /tmp/playwright-skill-temp\n\n# Copy only the skill folder to your project\nmkdir -p .claude/skills\ncp -r /tmp/playwright-skill-temp/skills/playwright-skill .claude/skills/\n\n# Navigate to the skill and run setup\ncd .claude/skills/playwright-skill\nnpm run setup\n\n# Clean up temporary files\nrm -rf /tmp/playwright-skill-temp\n```\n\n**Why this structure?** The plugin format requires the `skills/` directory for organizing multiple skills within a plugin. When installing as a standalone skill, you only need the inner `skills/playwright-skill/` folder contents.\n\n---\n\n### Option 3: Download Release\n\n1. Download and extract the latest release from [GitHub Releases](https://github.com/lackeyjb/playwright-skill/releases)\n2. Copy only the `skills/playwright-skill/` folder to:\n   - Global: `~/.claude/skills/playwright-skill`\n   - Project: `/path/to/your/project/.claude/skills/playwright-skill`\n3. Navigate to the skill directory and run setup:\n   ```bash\n   cd ~/.claude/skills/playwright-skill  # or your project path\n   npm run setup\n   ```\n\n---\n\n### Verify Installation\n\nRun `/help` to confirm the skill is loaded, then ask Claude to perform a simple browser task like \"Test if google.com loads\".\n\n## Quick Start\n\nAfter installation, simply ask Claude to test or automate any browser task. Claude will write custom Playwright code, execute it, and return results with screenshots and console output.\n\n## Usage Examples\n\n### Test Any Page\n\n```\n\"Test the homepage\"\n\"Check if the contact form works\"\n\"Verify the signup flow\"\n```\n\n### Visual Testing\n\n```\n\"Take screenshots of the dashboard in mobile and desktop\"\n\"Test responsive design across different viewports\"\n```\n\n### Interaction Testing\n\n```\n\"Fill out the registration form and submit it\"\n\"Click through the main navigation\"\n\"Test the search functionality\"\n```\n\n### Validation\n\n```\n\"Check for broken links\"\n\"Verify all images load\"\n\"Test form validation\"\n```\n\n## How It Works\n\n1. Describe what you want to test or automate\n2. Claude writes custom Playwright code for the task\n3. The universal executor (run.js) runs it with proper module resolution\n4. Browser opens (visible by default) and automation executes\n5. Results are displayed with console output and screenshots\n\n## Configuration\n\nDefault settings:\n\n- **Headless:** `false` (browser visible unless explicitly requested otherwise)\n- **Slow Motion:** `100ms` for visibility\n- **Timeout:** `30s`\n- **Screenshots:** Saved to `/tmp/`\n\n## Project Structure\n\n```\nplaywright-skill/\nâ”œâ”€â”€ .claude-plugin/\nâ”‚   â”œâ”€â”€ plugin.json          # Plugin metadata for distribution\nâ”‚   â””â”€â”€ marketplace.json     # Marketplace configuration\nâ”œâ”€â”€ skills/\nâ”‚   â””â”€â”€ playwright-skill/    # The actual skill (Claude discovers this)\nâ”‚       â”œâ”€â”€ SKILL.md         # What Claude reads\nâ”‚       â”œâ”€â”€ run.js           # Universal executor (proper module resolution)\nâ”‚       â”œâ”€â”€ package.json     # Dependencies & setup scripts\nâ”‚       â””â”€â”€ lib/\nâ”‚           â””â”€â”€ helpers.js   # Optional utility functions\nâ”‚       â””â”€â”€ API_REFERENCE.md # Full Playwright API reference\nâ”œâ”€â”€ README.md                # This file - user documentation\nâ”œâ”€â”€ CONTRIBUTING.md          # Contribution guidelines\nâ””â”€â”€ LICENSE                  # MIT License\n```\n\n## Advanced Usage\n\nClaude will automatically load `API_REFERENCE.md` when needed for comprehensive documentation on selectors, network interception, authentication, visual regression testing, mobile emulation, performance testing, and debugging.\n\n## Dependencies\n\n- Node.js\n- Playwright (installed via `npm run setup`)\n- Chromium (installed via `npm run setup`)\n\n## Troubleshooting\n\n**Playwright not installed?**\nNavigate to the skill directory and run `npm run setup`.\n\n**Module not found errors?**\nEnsure automation runs via `run.js`, which handles module resolution.\n\n**Browser doesn't open?**\nVerify `headless: false` is set. The skill defaults to visible browser unless headless mode is requested.\n\n**Install all browsers?**\nRun `npm run install-all-browsers` from the skill directory.\n\n## What is a Skill?\n\n[Agent Skills](https://agentskills.io) are folders of instructions, scripts, and resources that agents can discover and use to do things more accurately and efficiently. When you ask Claude to test a webpage or automate browser interactions, Claude discovers this skill, loads the necessary instructions, executes custom Playwright code, and returns results with screenshots and console output.\n\nThis Playwright skill implements the [open Agent Skills specification](https://agentskills.io), making it compatible across agent platforms.\n\n## Contributing\n\nContributions are welcome. Fork the repository, create a feature branch, make your changes, and submit a pull request. See [CONTRIBUTING.md](CONTRIBUTING.md) for details.\n\n## Learn More\n\n- [Agent Skills Specification](https://agentskills.io) - Open specification for agent skills\n- [Claude Code Skills Documentation](https://docs.claude.com/en/docs/claude-code/skills)\n- [Claude Code Plugins Documentation](https://docs.claude.com/en/docs/claude-code/plugins)\n- [Plugin Marketplaces](https://docs.claude.com/en/docs/claude-code/plugin-marketplaces)\n- [API_REFERENCE.md](skills/playwright-skill/API_REFERENCE.md) - Full Playwright documentation\n- [GitHub Issues](https://github.com/lackeyjb/playwright-skill/issues)\n\n## License\n\nMIT License - see [LICENSE](LICENSE) file for details.\n",
        "skills/playwright-skill/API_REFERENCE.md": "# Playwright Skill - Complete API Reference\n\nThis document contains the comprehensive Playwright API reference and advanced patterns. For quick-start execution patterns, see [SKILL.md](SKILL.md).\n\n## Table of Contents\n\n- [Installation & Setup](#installation--setup)\n- [Core Patterns](#core-patterns)\n- [Selectors & Locators](#selectors--locators)\n- [Common Actions](#common-actions)\n- [Waiting Strategies](#waiting-strategies)\n- [Assertions](#assertions)\n- [Page Object Model](#page-object-model-pom)\n- [Network & API Testing](#network--api-testing)\n- [Authentication & Session Management](#authentication--session-management)\n- [Visual Testing](#visual-testing)\n- [Mobile Testing](#mobile-testing)\n- [Debugging](#debugging)\n- [Performance Testing](#performance-testing)\n- [Parallel Execution](#parallel-execution)\n- [Data-Driven Testing](#data-driven-testing)\n- [Accessibility Testing](#accessibility-testing)\n- [CI/CD Integration](#cicd-integration)\n- [Best Practices](#best-practices)\n- [Common Patterns & Solutions](#common-patterns--solutions)\n- [Troubleshooting](#troubleshooting)\n\n## Installation & Setup\n\n### Prerequisites\n\nBefore using this skill, ensure Playwright is available:\n\n```bash\n# Check if Playwright is installed\nnpm list playwright 2>/dev/null || echo \"Playwright not installed\"\n\n# Install (if needed)\ncd ~/.claude/skills/playwright-skill\nnpm run setup\n```\n\n### Basic Configuration\n\nCreate `playwright.config.ts`:\n\n```typescript\nimport { defineConfig, devices } from '@playwright/test';\n\nexport default defineConfig({\n  testDir: './tests',\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: 'html',\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure',\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n  ],\n  webServer: {\n    command: 'npm run start',\n    url: 'http://localhost:3000',\n    reuseExistingServer: !process.env.CI,\n  },\n});\n```\n\n## Core Patterns\n\n### Basic Browser Automation\n\n```javascript\nconst { chromium } = require('playwright');\n\n(async () => {\n  // Launch browser\n  const browser = await chromium.launch({\n    headless: false,  // Set to true for headless mode\n    slowMo: 50       // Slow down operations by 50ms\n  });\n\n  const context = await browser.newContext({\n    viewport: { width: 1280, height: 720 },\n    userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'\n  });\n\n  const page = await context.newPage();\n\n  // Navigate\n  await page.goto('https://example.com', {\n    waitUntil: 'networkidle'  // Wait for network to be idle\n  });\n\n  // Your automation here\n\n  await browser.close();\n})();\n```\n\n### Test Structure\n\n```typescript\nimport { test, expect } from '@playwright/test';\n\ntest.describe('Feature Name', () => {\n  test.beforeEach(async ({ page }) => {\n    await page.goto('/');\n  });\n\n  test('should do something', async ({ page }) => {\n    // Arrange\n    const button = page.locator('button[data-testid=\"submit\"]');\n\n    // Act\n    await button.click();\n\n    // Assert\n    await expect(page).toHaveURL('/success');\n    await expect(page.locator('.message')).toHaveText('Success!');\n  });\n});\n```\n\n## Selectors & Locators\n\n### Best Practices for Selectors\n\n```javascript\n// PREFERRED: Data attributes (most stable)\nawait page.locator('[data-testid=\"submit-button\"]').click();\nawait page.locator('[data-cy=\"user-input\"]').fill('text');\n\n// GOOD: Role-based selectors (accessible)\nawait page.getByRole('button', { name: 'Submit' }).click();\nawait page.getByRole('textbox', { name: 'Email' }).fill('user@example.com');\nawait page.getByRole('heading', { level: 1 }).click();\n\n// GOOD: Text content (for unique text)\nawait page.getByText('Sign in').click();\nawait page.getByText(/welcome back/i).click();\n\n// OK: Semantic HTML\nawait page.locator('button[type=\"submit\"]').click();\nawait page.locator('input[name=\"email\"]').fill('test@test.com');\n\n// AVOID: Classes and IDs (can change frequently)\nawait page.locator('.btn-primary').click();  // Avoid\nawait page.locator('#submit').click();       // Avoid\n\n// LAST RESORT: Complex CSS/XPath\nawait page.locator('div.container > form > button').click();  // Fragile\n```\n\n### Advanced Locator Patterns\n\n```javascript\n// Filter and chain locators\nconst row = page.locator('tr').filter({ hasText: 'John Doe' });\nawait row.locator('button').click();\n\n// Nth element\nawait page.locator('button').nth(2).click();\n\n// Combining conditions\nawait page.locator('button').and(page.locator('[disabled]')).count();\n\n// Parent/child navigation\nconst cell = page.locator('td').filter({ hasText: 'Active' });\nconst row = cell.locator('..');\nawait row.locator('button.edit').click();\n```\n\n## Common Actions\n\n### Form Interactions\n\n```javascript\n// Text input\nawait page.getByLabel('Email').fill('user@example.com');\nawait page.getByPlaceholder('Enter your name').fill('John Doe');\n\n// Clear and type\nawait page.locator('#username').clear();\nawait page.locator('#username').type('newuser', { delay: 100 });\n\n// Checkbox\nawait page.getByLabel('I agree').check();\nawait page.getByLabel('Subscribe').uncheck();\n\n// Radio button\nawait page.getByLabel('Option 2').check();\n\n// Select dropdown\nawait page.selectOption('select#country', 'usa');\nawait page.selectOption('select#country', { label: 'United States' });\nawait page.selectOption('select#country', { index: 2 });\n\n// Multi-select\nawait page.selectOption('select#colors', ['red', 'blue', 'green']);\n\n// File upload\nawait page.setInputFiles('input[type=\"file\"]', 'path/to/file.pdf');\nawait page.setInputFiles('input[type=\"file\"]', [\n  'file1.pdf',\n  'file2.pdf'\n]);\n```\n\n### Mouse Actions\n\n```javascript\n// Click variations\nawait page.click('button');                          // Left click\nawait page.click('button', { button: 'right' });    // Right click\nawait page.dblclick('button');                       // Double click\nawait page.click('button', { position: { x: 10, y: 10 } });  // Click at position\n\n// Hover\nawait page.hover('.menu-item');\n\n// Drag and drop\nawait page.dragAndDrop('#source', '#target');\n\n// Manual drag\nawait page.locator('#source').hover();\nawait page.mouse.down();\nawait page.locator('#target').hover();\nawait page.mouse.up();\n```\n\n### Keyboard Actions\n\n```javascript\n// Type with delay\nawait page.keyboard.type('Hello World', { delay: 100 });\n\n// Key combinations\nawait page.keyboard.press('Control+A');\nawait page.keyboard.press('Control+C');\nawait page.keyboard.press('Control+V');\n\n// Special keys\nawait page.keyboard.press('Enter');\nawait page.keyboard.press('Tab');\nawait page.keyboard.press('Escape');\nawait page.keyboard.press('ArrowDown');\n```\n\n## Waiting Strategies\n\n### Smart Waiting\n\n```javascript\n// Wait for element states\nawait page.locator('button').waitFor({ state: 'visible' });\nawait page.locator('.spinner').waitFor({ state: 'hidden' });\nawait page.locator('button').waitFor({ state: 'attached' });\nawait page.locator('button').waitFor({ state: 'detached' });\n\n// Wait for specific conditions\nawait page.waitForURL('**/success');\nawait page.waitForURL(url => url.pathname === '/dashboard');\n\n// Wait for network\nawait page.waitForLoadState('networkidle');\nawait page.waitForLoadState('domcontentloaded');\n\n// Wait for function\nawait page.waitForFunction(() => document.querySelector('.loaded'));\nawait page.waitForFunction(\n  text => document.body.innerText.includes(text),\n  'Content loaded'\n);\n\n// Wait for response\nconst responsePromise = page.waitForResponse('**/api/users');\nawait page.click('button#load-users');\nconst response = await responsePromise;\n\n// Wait for request\nawait page.waitForRequest(request =>\n  request.url().includes('/api/') && request.method() === 'POST'\n);\n\n// Custom timeout\nawait page.locator('.slow-element').waitFor({\n  state: 'visible',\n  timeout: 10000  // 10 seconds\n});\n```\n\n## Assertions\n\n### Common Assertions\n\n```javascript\nimport { expect } from '@playwright/test';\n\n// Page assertions\nawait expect(page).toHaveTitle('My App');\nawait expect(page).toHaveURL('https://example.com/dashboard');\nawait expect(page).toHaveURL(/.*dashboard/);\n\n// Element visibility\nawait expect(page.locator('.message')).toBeVisible();\nawait expect(page.locator('.spinner')).toBeHidden();\nawait expect(page.locator('button')).toBeEnabled();\nawait expect(page.locator('input')).toBeDisabled();\n\n// Text content\nawait expect(page.locator('h1')).toHaveText('Welcome');\nawait expect(page.locator('.message')).toContainText('success');\nawait expect(page.locator('.items')).toHaveText(['Item 1', 'Item 2']);\n\n// Input values\nawait expect(page.locator('input')).toHaveValue('test@example.com');\nawait expect(page.locator('input')).toBeEmpty();\n\n// Attributes\nawait expect(page.locator('button')).toHaveAttribute('type', 'submit');\nawait expect(page.locator('img')).toHaveAttribute('src', /.*\\.png/);\n\n// CSS properties\nawait expect(page.locator('.error')).toHaveCSS('color', 'rgb(255, 0, 0)');\n\n// Count\nawait expect(page.locator('.item')).toHaveCount(5);\n\n// Checkbox/Radio state\nawait expect(page.locator('input[type=\"checkbox\"]')).toBeChecked();\n```\n\n## Page Object Model (POM)\n\n### Basic Page Object\n\n```javascript\n// pages/LoginPage.js\nclass LoginPage {\n  constructor(page) {\n    this.page = page;\n    this.usernameInput = page.locator('input[name=\"username\"]');\n    this.passwordInput = page.locator('input[name=\"password\"]');\n    this.submitButton = page.locator('button[type=\"submit\"]');\n    this.errorMessage = page.locator('.error-message');\n  }\n\n  async navigate() {\n    await this.page.goto('/login');\n  }\n\n  async login(username, password) {\n    await this.usernameInput.fill(username);\n    await this.passwordInput.fill(password);\n    await this.submitButton.click();\n  }\n\n  async getErrorMessage() {\n    return await this.errorMessage.textContent();\n  }\n}\n\n// Usage in test\ntest('login with valid credentials', async ({ page }) => {\n  const loginPage = new LoginPage(page);\n  await loginPage.navigate();\n  await loginPage.login('user@example.com', 'password123');\n  await expect(page).toHaveURL('/dashboard');\n});\n```\n\n## Network & API Testing\n\n### Intercepting Requests\n\n```javascript\n// Mock API responses\nawait page.route('**/api/users', route => {\n  route.fulfill({\n    status: 200,\n    contentType: 'application/json',\n    body: JSON.stringify([\n      { id: 1, name: 'John' },\n      { id: 2, name: 'Jane' }\n    ])\n  });\n});\n\n// Modify requests\nawait page.route('**/api/**', route => {\n  const headers = {\n    ...route.request().headers(),\n    'X-Custom-Header': 'value'\n  };\n  route.continue({ headers });\n});\n\n// Block resources\nawait page.route('**/*.{png,jpg,jpeg,gif}', route => route.abort());\n```\n\n### Custom Headers via Environment Variables\n\nThe skill supports automatic header injection via environment variables:\n\n```bash\n# Single header (simple)\nPW_HEADER_NAME=X-Automated-By PW_HEADER_VALUE=playwright-skill\n\n# Multiple headers (JSON)\nPW_EXTRA_HEADERS='{\"X-Automated-By\":\"playwright-skill\",\"X-Request-ID\":\"123\"}'\n```\n\nThese headers are automatically applied to all requests when using:\n- `helpers.createContext(browser)` - headers merged automatically\n- `getContextOptionsWithHeaders(options)` - utility injected by run.js wrapper\n\n**Precedence (highest to lowest):**\n1. Headers passed directly in `options.extraHTTPHeaders`\n2. Environment variable headers\n3. Playwright defaults\n\n**Use case:** Identify automated traffic so your backend can return LLM-optimized responses (e.g., plain text errors instead of styled HTML).\n\n## Visual Testing\n\n### Screenshots\n\n```javascript\n// Full page screenshot\nawait page.screenshot({\n  path: 'screenshot.png',\n  fullPage: true\n});\n\n// Element screenshot\nawait page.locator('.chart').screenshot({\n  path: 'chart.png'\n});\n\n// Visual comparison\nawait expect(page).toHaveScreenshot('homepage.png');\n```\n\n## Mobile Testing\n\n```javascript\n// Device emulation\nconst { devices } = require('playwright');\nconst iPhone = devices['iPhone 12'];\n\nconst context = await browser.newContext({\n  ...iPhone,\n  locale: 'en-US',\n  permissions: ['geolocation'],\n  geolocation: { latitude: 37.7749, longitude: -122.4194 }\n});\n```\n\n## Debugging\n\n### Debug Mode\n\n```bash\n# Run with inspector\nnpx playwright test --debug\n\n# Headed mode\nnpx playwright test --headed\n\n# Slow motion\nnpx playwright test --headed --slowmo=1000\n```\n\n### In-Code Debugging\n\n```javascript\n// Pause execution\nawait page.pause();\n\n// Console logs\npage.on('console', msg => console.log('Browser log:', msg.text()));\npage.on('pageerror', error => console.log('Page error:', error));\n```\n\n## Performance Testing\n\n```javascript\n// Measure page load time\nconst startTime = Date.now();\nawait page.goto('https://example.com');\nconst loadTime = Date.now() - startTime;\nconsole.log(`Page loaded in ${loadTime}ms`);\n```\n\n## Parallel Execution\n\n```javascript\n// Run tests in parallel\ntest.describe.parallel('Parallel suite', () => {\n  test('test 1', async ({ page }) => {\n    // Runs in parallel with test 2\n  });\n\n  test('test 2', async ({ page }) => {\n    // Runs in parallel with test 1\n  });\n});\n```\n\n## Data-Driven Testing\n\n```javascript\n// Parameterized tests\nconst testData = [\n  { username: 'user1', password: 'pass1', expected: 'Welcome user1' },\n  { username: 'user2', password: 'pass2', expected: 'Welcome user2' },\n];\n\ntestData.forEach(({ username, password, expected }) => {\n  test(`login with ${username}`, async ({ page }) => {\n    await page.goto('/login');\n    await page.fill('#username', username);\n    await page.fill('#password', password);\n    await page.click('button[type=\"submit\"]');\n    await expect(page.locator('.message')).toHaveText(expected);\n  });\n});\n```\n\n## Accessibility Testing\n\n```javascript\nimport { injectAxe, checkA11y } from 'axe-playwright';\n\ntest('accessibility check', async ({ page }) => {\n  await page.goto('/');\n  await injectAxe(page);\n  await checkA11y(page);\n});\n```\n\n## CI/CD Integration\n\n### GitHub Actions\n\n```yaml\nname: Playwright Tests\non:\n  push:\n    branches: [main, master]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - name: Install dependencies\n        run: npm ci\n      - name: Install Playwright Browsers\n        run: npx playwright install --with-deps\n      - name: Run tests\n        run: npx playwright test\n```\n\n## Best Practices\n\n1. **Test Organization** - Use descriptive test names, group related tests\n2. **Selector Strategy** - Prefer data-testid attributes, use role-based selectors\n3. **Waiting** - Use Playwright's auto-waiting, avoid hard-coded delays\n4. **Error Handling** - Add proper error messages, take screenshots on failure\n5. **Performance** - Run tests in parallel, reuse authentication state\n\n## Common Patterns & Solutions\n\n### Handling Popups\n\n```javascript\nconst [popup] = await Promise.all([\n  page.waitForEvent('popup'),\n  page.click('button.open-popup')\n]);\nawait popup.waitForLoadState();\n```\n\n### File Downloads\n\n```javascript\nconst [download] = await Promise.all([\n  page.waitForEvent('download'),\n  page.click('button.download')\n]);\nawait download.saveAs(`./downloads/${download.suggestedFilename()}`);\n```\n\n### iFrames\n\n```javascript\nconst frame = page.frameLocator('#my-iframe');\nawait frame.locator('button').click();\n```\n\n### Infinite Scroll\n\n```javascript\nasync function scrollToBottom(page) {\n  await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));\n  await page.waitForTimeout(500);\n}\n```\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Element not found** - Check if element is in iframe, verify visibility\n2. **Timeout errors** - Increase timeout, check network conditions\n3. **Flaky tests** - Use proper waiting strategies, mock external dependencies\n4. **Authentication issues** - Verify auth state is properly saved\n\n## Quick Reference Commands\n\n```bash\n# Run tests\nnpx playwright test\n\n# Run in headed mode\nnpx playwright test --headed\n\n# Debug tests\nnpx playwright test --debug\n\n# Generate code\nnpx playwright codegen https://example.com\n\n# Show report\nnpx playwright show-report\n```\n\n## Additional Resources\n\n- [Playwright Documentation](https://playwright.dev/docs/intro)\n- [API Reference](https://playwright.dev/docs/api/class-playwright)\n- [Best Practices](https://playwright.dev/docs/best-practices)\n",
        "skills/playwright-skill/SKILL.md": "---\nname: playwright-skill\ndescription: Complete browser automation with Playwright. Auto-detects dev servers, writes clean test scripts to /tmp. Test pages, fill forms, take screenshots, check responsive design, validate UX, test login flows, check links, automate any browser task. Use when user wants to test websites, automate browser interactions, validate web functionality, or perform any browser-based testing.\n---\n\n**IMPORTANT - Path Resolution:**\nThis skill can be installed in different locations (plugin system, manual installation, global, or project-specific). Before executing any commands, determine the skill directory based on where you loaded this SKILL.md file, and use that path in all commands below. Replace `$SKILL_DIR` with the actual discovered path.\n\nCommon installation paths:\n\n- Plugin system: `~/.claude/plugins/marketplaces/playwright-skill/skills/playwright-skill`\n- Manual global: `~/.claude/skills/playwright-skill`\n- Project-specific: `<project>/.claude/skills/playwright-skill`\n\n# Playwright Browser Automation\n\nGeneral-purpose browser automation skill. I'll write custom Playwright code for any automation task you request and execute it via the universal executor.\n\n**CRITICAL WORKFLOW - Follow these steps in order:**\n\n1. **Auto-detect dev servers** - For localhost testing, ALWAYS run server detection FIRST:\n\n   ```bash\n   cd $SKILL_DIR && node -e \"require('./lib/helpers').detectDevServers().then(servers => console.log(JSON.stringify(servers)))\"\n   ```\n\n   - If **1 server found**: Use it automatically, inform user\n   - If **multiple servers found**: Ask user which one to test\n   - If **no servers found**: Ask for URL or offer to help start dev server\n\n2. **Write scripts to /tmp** - NEVER write test files to skill directory; always use `/tmp/playwright-test-*.js`\n\n3. **Use visible browser by default** - Always use `headless: false` unless user specifically requests headless mode\n\n4. **Parameterize URLs** - Always make URLs configurable via environment variable or constant at top of script\n\n## How It Works\n\n1. You describe what you want to test/automate\n2. I auto-detect running dev servers (or ask for URL if testing external site)\n3. I write custom Playwright code in `/tmp/playwright-test-*.js` (won't clutter your project)\n4. I execute it via: `cd $SKILL_DIR && node run.js /tmp/playwright-test-*.js`\n5. Results displayed in real-time, browser window visible for debugging\n6. Test files auto-cleaned from /tmp by your OS\n\n## Setup (First Time)\n\n```bash\ncd $SKILL_DIR\nnpm run setup\n```\n\nThis installs Playwright and Chromium browser. Only needed once.\n\n## Execution Pattern\n\n**Step 1: Detect dev servers (for localhost testing)**\n\n```bash\ncd $SKILL_DIR && node -e \"require('./lib/helpers').detectDevServers().then(s => console.log(JSON.stringify(s)))\"\n```\n\n**Step 2: Write test script to /tmp with URL parameter**\n\n```javascript\n// /tmp/playwright-test-page.js\nconst { chromium } = require('playwright');\n\n// Parameterized URL (detected or user-provided)\nconst TARGET_URL = 'http://localhost:3001'; // <-- Auto-detected or from user\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  await page.goto(TARGET_URL);\n  console.log('Page loaded:', await page.title());\n\n  await page.screenshot({ path: '/tmp/screenshot.png', fullPage: true });\n  console.log('ðŸ“¸ Screenshot saved to /tmp/screenshot.png');\n\n  await browser.close();\n})();\n```\n\n**Step 3: Execute from skill directory**\n\n```bash\ncd $SKILL_DIR && node run.js /tmp/playwright-test-page.js\n```\n\n## Common Patterns\n\n### Test a Page (Multiple Viewports)\n\n```javascript\n// /tmp/playwright-test-responsive.js\nconst { chromium } = require('playwright');\n\nconst TARGET_URL = 'http://localhost:3001'; // Auto-detected\n\n(async () => {\n  const browser = await chromium.launch({ headless: false, slowMo: 100 });\n  const page = await browser.newPage();\n\n  // Desktop test\n  await page.setViewportSize({ width: 1920, height: 1080 });\n  await page.goto(TARGET_URL);\n  console.log('Desktop - Title:', await page.title());\n  await page.screenshot({ path: '/tmp/desktop.png', fullPage: true });\n\n  // Mobile test\n  await page.setViewportSize({ width: 375, height: 667 });\n  await page.screenshot({ path: '/tmp/mobile.png', fullPage: true });\n\n  await browser.close();\n})();\n```\n\n### Test Login Flow\n\n```javascript\n// /tmp/playwright-test-login.js\nconst { chromium } = require('playwright');\n\nconst TARGET_URL = 'http://localhost:3001'; // Auto-detected\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  await page.goto(`${TARGET_URL}/login`);\n\n  await page.fill('input[name=\"email\"]', 'test@example.com');\n  await page.fill('input[name=\"password\"]', 'password123');\n  await page.click('button[type=\"submit\"]');\n\n  // Wait for redirect\n  await page.waitForURL('**/dashboard');\n  console.log('âœ… Login successful, redirected to dashboard');\n\n  await browser.close();\n})();\n```\n\n### Fill and Submit Form\n\n```javascript\n// /tmp/playwright-test-form.js\nconst { chromium } = require('playwright');\n\nconst TARGET_URL = 'http://localhost:3001'; // Auto-detected\n\n(async () => {\n  const browser = await chromium.launch({ headless: false, slowMo: 50 });\n  const page = await browser.newPage();\n\n  await page.goto(`${TARGET_URL}/contact`);\n\n  await page.fill('input[name=\"name\"]', 'John Doe');\n  await page.fill('input[name=\"email\"]', 'john@example.com');\n  await page.fill('textarea[name=\"message\"]', 'Test message');\n  await page.click('button[type=\"submit\"]');\n\n  // Verify submission\n  await page.waitForSelector('.success-message');\n  console.log('âœ… Form submitted successfully');\n\n  await browser.close();\n})();\n```\n\n### Check for Broken Links\n\n```javascript\nconst { chromium } = require('playwright');\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  await page.goto('http://localhost:3000');\n\n  const links = await page.locator('a[href^=\"http\"]').all();\n  const results = { working: 0, broken: [] };\n\n  for (const link of links) {\n    const href = await link.getAttribute('href');\n    try {\n      const response = await page.request.head(href);\n      if (response.ok()) {\n        results.working++;\n      } else {\n        results.broken.push({ url: href, status: response.status() });\n      }\n    } catch (e) {\n      results.broken.push({ url: href, error: e.message });\n    }\n  }\n\n  console.log(`âœ… Working links: ${results.working}`);\n  console.log(`âŒ Broken links:`, results.broken);\n\n  await browser.close();\n})();\n```\n\n### Take Screenshot with Error Handling\n\n```javascript\nconst { chromium } = require('playwright');\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  try {\n    await page.goto('http://localhost:3000', {\n      waitUntil: 'networkidle',\n      timeout: 10000,\n    });\n\n    await page.screenshot({\n      path: '/tmp/screenshot.png',\n      fullPage: true,\n    });\n\n    console.log('ðŸ“¸ Screenshot saved to /tmp/screenshot.png');\n  } catch (error) {\n    console.error('âŒ Error:', error.message);\n  } finally {\n    await browser.close();\n  }\n})();\n```\n\n### Test Responsive Design\n\n```javascript\n// /tmp/playwright-test-responsive-full.js\nconst { chromium } = require('playwright');\n\nconst TARGET_URL = 'http://localhost:3001'; // Auto-detected\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  const viewports = [\n    { name: 'Desktop', width: 1920, height: 1080 },\n    { name: 'Tablet', width: 768, height: 1024 },\n    { name: 'Mobile', width: 375, height: 667 },\n  ];\n\n  for (const viewport of viewports) {\n    console.log(\n      `Testing ${viewport.name} (${viewport.width}x${viewport.height})`,\n    );\n\n    await page.setViewportSize({\n      width: viewport.width,\n      height: viewport.height,\n    });\n\n    await page.goto(TARGET_URL);\n    await page.waitForTimeout(1000);\n\n    await page.screenshot({\n      path: `/tmp/${viewport.name.toLowerCase()}.png`,\n      fullPage: true,\n    });\n  }\n\n  console.log('âœ… All viewports tested');\n  await browser.close();\n})();\n```\n\n## Inline Execution (Simple Tasks)\n\nFor quick one-off tasks, you can execute code inline without creating files:\n\n```bash\n# Take a quick screenshot\ncd $SKILL_DIR && node run.js \"\nconst browser = await chromium.launch({ headless: false });\nconst page = await browser.newPage();\nawait page.goto('http://localhost:3001');\nawait page.screenshot({ path: '/tmp/quick-screenshot.png', fullPage: true });\nconsole.log('Screenshot saved');\nawait browser.close();\n\"\n```\n\n**When to use inline vs files:**\n\n- **Inline**: Quick one-off tasks (screenshot, check if element exists, get page title)\n- **Files**: Complex tests, responsive design checks, anything user might want to re-run\n\n## Available Helpers\n\nOptional utility functions in `lib/helpers.js`:\n\n```javascript\nconst helpers = require('./lib/helpers');\n\n// Detect running dev servers (CRITICAL - use this first!)\nconst servers = await helpers.detectDevServers();\nconsole.log('Found servers:', servers);\n\n// Safe click with retry\nawait helpers.safeClick(page, 'button.submit', { retries: 3 });\n\n// Safe type with clear\nawait helpers.safeType(page, '#username', 'testuser');\n\n// Take timestamped screenshot\nawait helpers.takeScreenshot(page, 'test-result');\n\n// Handle cookie banners\nawait helpers.handleCookieBanner(page);\n\n// Extract table data\nconst data = await helpers.extractTableData(page, 'table.results');\n```\n\nSee `lib/helpers.js` for full list.\n\n## Custom HTTP Headers\n\nConfigure custom headers for all HTTP requests via environment variables. Useful for:\n\n- Identifying automated traffic to your backend\n- Getting LLM-optimized responses (e.g., plain text errors instead of styled HTML)\n- Adding authentication tokens globally\n\n### Configuration\n\n**Single header (common case):**\n\n```bash\nPW_HEADER_NAME=X-Automated-By PW_HEADER_VALUE=playwright-skill \\\n  cd $SKILL_DIR && node run.js /tmp/my-script.js\n```\n\n**Multiple headers (JSON format):**\n\n```bash\nPW_EXTRA_HEADERS='{\"X-Automated-By\":\"playwright-skill\",\"X-Debug\":\"true\"}' \\\n  cd $SKILL_DIR && node run.js /tmp/my-script.js\n```\n\n### How It Works\n\nHeaders are automatically applied when using `helpers.createContext()`:\n\n```javascript\nconst context = await helpers.createContext(browser);\nconst page = await context.newPage();\n// All requests from this page include your custom headers\n```\n\nFor scripts using raw Playwright API, use the injected `getContextOptionsWithHeaders()`:\n\n```javascript\nconst context = await browser.newContext(\n  getContextOptionsWithHeaders({ viewport: { width: 1920, height: 1080 } }),\n);\n```\n\n## Advanced Usage\n\nFor comprehensive Playwright API documentation, see [API_REFERENCE.md](API_REFERENCE.md):\n\n- Selectors & Locators best practices\n- Network interception & API mocking\n- Authentication & session management\n- Visual regression testing\n- Mobile device emulation\n- Performance testing\n- Debugging techniques\n- CI/CD integration\n\n## Tips\n\n- **CRITICAL: Detect servers FIRST** - Always run `detectDevServers()` before writing test code for localhost testing\n- **Custom headers** - Use `PW_HEADER_NAME`/`PW_HEADER_VALUE` env vars to identify automated traffic to your backend\n- **Use /tmp for test files** - Write to `/tmp/playwright-test-*.js`, never to skill directory or user's project\n- **Parameterize URLs** - Put detected/provided URL in a `TARGET_URL` constant at the top of every script\n- **DEFAULT: Visible browser** - Always use `headless: false` unless user explicitly asks for headless mode\n- **Headless mode** - Only use `headless: true` when user specifically requests \"headless\" or \"background\" execution\n- **Slow down:** Use `slowMo: 100` to make actions visible and easier to follow\n- **Wait strategies:** Use `waitForURL`, `waitForSelector`, `waitForLoadState` instead of fixed timeouts\n- **Error handling:** Always use try-catch for robust automation\n- **Console output:** Use `console.log()` to track progress and show what's happening\n\n## Troubleshooting\n\n**Playwright not installed:**\n\n```bash\ncd $SKILL_DIR && npm run setup\n```\n\n**Module not found:**\nEnsure running from skill directory via `run.js` wrapper\n\n**Browser doesn't open:**\nCheck `headless: false` and ensure display available\n\n**Element not found:**\nAdd wait: `await page.waitForSelector('.element', { timeout: 10000 })`\n\n## Example Usage\n\n```\nUser: \"Test if the marketing page looks good\"\n\nClaude: I'll test the marketing page across multiple viewports. Let me first detect running servers...\n[Runs: detectDevServers()]\n[Output: Found server on port 3001]\nI found your dev server running on http://localhost:3001\n\n[Writes custom automation script to /tmp/playwright-test-marketing.js with URL parameterized]\n[Runs: cd $SKILL_DIR && node run.js /tmp/playwright-test-marketing.js]\n[Shows results with screenshots from /tmp/]\n```\n\n```\nUser: \"Check if login redirects correctly\"\n\nClaude: I'll test the login flow. First, let me check for running servers...\n[Runs: detectDevServers()]\n[Output: Found servers on ports 3000 and 3001]\nI found 2 dev servers. Which one should I test?\n- http://localhost:3000\n- http://localhost:3001\n\nUser: \"Use 3001\"\n\n[Writes login automation to /tmp/playwright-test-login.js]\n[Runs: cd $SKILL_DIR && node run.js /tmp/playwright-test-login.js]\n[Reports: âœ… Login successful, redirected to /dashboard]\n```\n\n## Notes\n\n- Each automation is custom-written for your specific request\n- Not limited to pre-built scripts - any browser task possible\n- Auto-detects running dev servers to eliminate hardcoded URLs\n- Test scripts written to `/tmp` for automatic cleanup (no clutter)\n- Code executes reliably with proper module resolution via `run.js`\n- Progressive disclosure - API_REFERENCE.md loaded only when advanced features needed\n"
      },
      "plugins": [
        {
          "name": "playwright-skill",
          "source": "./",
          "description": "Claude Code Skill for general-purpose browser automation with Playwright. Claude autonomously writes and executes custom automation for testing pages, validating UX, and any browser task.",
          "version": "4.1.0",
          "author": {
            "name": "lackeyjb"
          },
          "homepage": "https://github.com/lackeyjb/playwright-skill",
          "repository": "https://github.com/lackeyjb/playwright-skill",
          "license": "MIT",
          "keywords": [
            "claude-skill",
            "claude-code",
            "playwright",
            "browser-automation",
            "testing",
            "e2e",
            "web-testing",
            "automation",
            "model-invoked"
          ],
          "category": "testing",
          "tags": [
            "browser",
            "automation",
            "playwright",
            "testing",
            "e2e"
          ],
          "categories": [
            "automation",
            "browser",
            "browser-automation",
            "claude-code",
            "claude-skill",
            "e2e",
            "model-invoked",
            "playwright",
            "testing",
            "web-testing"
          ],
          "install_commands": [
            "/plugin marketplace add lackeyjb/playwright-skill",
            "/plugin install playwright-skill@playwright-skill"
          ]
        }
      ]
    },
    {
      "name": "conductor",
      "version": null,
      "description": "Context-Driven Development framework for Claude Code",
      "owner_info": {
        "name": "Bryan Lackey",
        "email": "lackeyjb@users.noreply.github.com"
      },
      "keywords": [],
      "repo_full_name": "lackeyjb/claude-conductor",
      "repo_url": "https://github.com/lackeyjb/claude-conductor",
      "repo_description": "Context-Driven Development framework for Claude Code. Inspired by https://github.com/gemini-cli-extensions/conductor",
      "homepage": null,
      "signals": {
        "stars": 10,
        "forks": 0,
        "pushed_at": "2025-12-30T03:17:50Z",
        "created_at": "2025-12-23T21:44:43Z",
        "license": "Apache-2.0"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 733
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 281
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 14103
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/implementer.md",
          "type": "blob",
          "size": 3403
        },
        {
          "path": "agents/planner.md",
          "type": "blob",
          "size": 2385
        },
        {
          "path": "agents/reviewer.md",
          "type": "blob",
          "size": 2888
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/agents.md",
          "type": "blob",
          "size": 3958
        },
        {
          "path": "commands/implement.md",
          "type": "blob",
          "size": 9210
        },
        {
          "path": "commands/new-track.md",
          "type": "blob",
          "size": 3292
        },
        {
          "path": "commands/revert.md",
          "type": "blob",
          "size": 3247
        },
        {
          "path": "commands/setup.md",
          "type": "blob",
          "size": 4159
        },
        {
          "path": "commands/status.md",
          "type": "blob",
          "size": 1838
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 1168
        },
        {
          "path": "hooks/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/scripts/load-context.js",
          "type": "blob",
          "size": 4730
        },
        {
          "path": "hooks/scripts/session-end.js",
          "type": "blob",
          "size": 882
        },
        {
          "path": "hooks/scripts/track-changes.js",
          "type": "blob",
          "size": 773
        },
        {
          "path": "hooks/scripts/warn-config.js",
          "type": "blob",
          "size": 712
        },
        {
          "path": "reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "reference/README.md",
          "type": "blob",
          "size": 2904
        },
        {
          "path": "reference/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "reference/examples/README.md",
          "type": "blob",
          "size": 3902
        },
        {
          "path": "reference/examples/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "reference/examples/agents/conductor-implementer.md",
          "type": "blob",
          "size": 5767
        },
        {
          "path": "reference/examples/agents/conductor-planner.md",
          "type": "blob",
          "size": 5033
        },
        {
          "path": "reference/examples/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "reference/examples/commands/implement.md",
          "type": "blob",
          "size": 4811
        },
        {
          "path": "reference/examples/commands/new-track.md",
          "type": "blob",
          "size": 4782
        },
        {
          "path": "reference/examples/commands/revert.md",
          "type": "blob",
          "size": 5758
        },
        {
          "path": "reference/examples/commands/setup.md",
          "type": "blob",
          "size": 5631
        },
        {
          "path": "reference/examples/commands/status.md",
          "type": "blob",
          "size": 4355
        },
        {
          "path": "reference/examples/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "reference/examples/hooks/hooks.json",
          "type": "blob",
          "size": 2258
        },
        {
          "path": "reference/examples/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "reference/examples/skills/context-awareness",
          "type": "tree",
          "size": null
        },
        {
          "path": "reference/examples/skills/context-awareness/SKILL.md",
          "type": "blob",
          "size": 3116
        },
        {
          "path": "reference/examples/skills/tdd-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "reference/examples/skills/tdd-workflow/SKILL.md",
          "type": "blob",
          "size": 5766
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/code-styleguides",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/code-styleguides/SKILL.md",
          "type": "blob",
          "size": 2210
        },
        {
          "path": "skills/context-awareness",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/context-awareness/SKILL.md",
          "type": "blob",
          "size": 1981
        },
        {
          "path": "skills/tdd-workflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/tdd-workflow/SKILL.md",
          "type": "blob",
          "size": 2870
        },
        {
          "path": "skills/tdd-workflow/examples.md",
          "type": "blob",
          "size": 2827
        },
        {
          "path": "templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "templates/README.md",
          "type": "blob",
          "size": 3214
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"conductor\",\n  \"owner\": {\n    \"name\": \"Bryan Lackey\",\n    \"email\": \"lackeyjb@users.noreply.github.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Context-Driven Development framework for Claude Code\",\n    \"version\": \"1.2.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"conductor\",\n      \"description\": \"Context-Driven Development framework for Claude Code\",\n      \"version\": \"1.2.0\",\n      \"source\": \"./\",\n      \"author\": {\n        \"name\": \"Bryan Lackey\"\n      },\n      \"repository\": \"https://github.com/lackeyjb/claude-conductor\",\n      \"license\": \"Apache-2.0\",\n      \"keywords\": [\n        \"context-driven\",\n        \"development\",\n        \"planning\",\n        \"implementation\"\n      ],\n      \"category\": \"workflow\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"conductor\",\n  \"version\": \"1.2.0\",\n  \"description\": \"Context-Driven Development framework for Claude Code\",\n  \"commands\": [\"./commands/\"],\n  \"agents\": [\n    \"./agents/planner.md\",\n    \"./agents/implementer.md\",\n    \"./agents/reviewer.md\"\n  ],\n  \"skills\": \"./skills/\"\n}\n",
        "README.md": "# Claude Conductor\n\nContext-Driven Development framework for Claude Code.\n\n> Inspired by [Conductor for Gemini CLI](https://github.com/gemini-cli-extensions/conductor)\n\n## Overview\n\nConductor enables **Context-Driven Development** - a methodology where context is treated as a managed artifact alongside code. It provides:\n\n- **Pre-implementation Planning**: Generate specs and plans before coding\n- **Test-Driven Development**: Enforced Red-Green-Refactor cycles\n- **Context Management**: Maintain style guides, tech stack, product goals\n- **Iterative Safety**: Review plans before execution with checkpoints\n- **Intelligent Reversion**: Git-aware rollback of logical work units\n\n## Installation\n\n### Development / Testing\n\nLoad the plugin directly using the `--plugin-dir` flag:\n\n```bash\nclaude --plugin-dir /path/to/conductor\n```\n\n**Verify installation:**\n```bash\n# Start Claude Code with the plugin\nclaude --plugin-dir /path/to/conductor\n\n# Type /conductor: to see available commands\n/conductor:\n```\n\nYou should see the 5 conductor commands listed.\n\n### Production (via GitHub Marketplace)\n\nAdd the GitHub repository as a marketplace and install:\n\n```bash\n# Add this repository as a marketplace\n/plugin marketplace add lackeyjb/claude-conductor\n\n# Install the plugin\n/plugin install conductor@claude-conductor\n```\n\n### Symlink Installation (Alternative)\n\n```bash\n# Create plugins directory if it doesn't exist\nmkdir -p ~/.claude/plugins\n\n# Symlink the conductor plugin\nln -s /path/to/conductor ~/.claude/plugins/conductor\n```\n\n## Commands\n\n### `/conductor:setup`\n\nInitialize Conductor environment for a project.\n\n**Usage:**\n```\n/conductor:setup [brownfield|greenfield]\n```\n\n**Arguments:**\n- `brownfield` - Skip detection, treat as existing project\n- `greenfield` - Skip detection, treat as new project\n\n**What it does:**\n1. Detects project maturity (brownfield vs greenfield)\n2. Creates `conductor/` directory with context files\n3. Interactively generates `product.md`, `tech-stack.md`, `workflow.md`\n4. Creates first track with specification and plan\n\n**Example:**\n```\n> /conductor:setup\n\nExisting project detected. I'll analyze it to understand the current state.\nFound: package.json, src/, .git\n\nWhat do you want to build? [describe your first feature]\n```\n\n---\n\n### `/conductor:new-track`\n\nCreate a new feature, bug, or chore track.\n\n**Usage:**\n```\n/conductor:new-track [description]\n```\n\n**Arguments:**\n- `description` - Brief description of the work (optional, will prompt if not provided)\n\n**What it does:**\n1. Infers track type (feature/bug/chore) from description\n2. Delegates to planner agent for interactive Q&A\n3. Generates `spec.md` with requirements\n4. Generates `plan.md` with TDD-structured tasks\n5. Creates track directory and updates `tracks.md`\n\n**Example:**\n```\n> /conductor:new-track Add user authentication with OAuth\n\nCreating feature track...\nI have some questions to clarify the requirements:\n1. Which OAuth providers should be supported?\n2. Should we include \"remember me\" functionality?\n...\n```\n\n---\n\n### `/conductor:implement`\n\nExecute tasks following TDD workflow.\n\n**Usage:**\n```\n/conductor:implement [<track-name>] [--all]\n```\n\n**Arguments:**\n- `<track-name>` - Partial name to select specific track (optional, selects next incomplete)\n- `--all` - Run all phases instead of one at a time\n\n**What it does:**\n1. Selects next incomplete track (or specified track)\n2. **Single-phase mode (default)**: Shows interactive phase selection, implements one phase at a time\n3. **All-phases mode (`--all`)**: Implements all remaining phases continuously\n4. Delegates each task to implementer agent\n5. Follows TDD cycle: Red â†’ Green â†’ Refactor\n6. Creates atomic commits with git notes\n7. Triggers phase verification at phase boundaries\n8. Creates checkpoints with reviewer agent\n\n**Examples:**\n```\n> /conductor:implement\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n  PHASE SELECTION\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n  Track: User Authentication\n\n  [x] Phase 1: Setup                    [complete]\n  [ ] Phase 2: Backend API              [in progress - 2/5 tasks]\n  [ ] Phase 3: Frontend Integration     [pending]\n\n  Which phase would you like to implement?\n\n  A) Phase 2: Backend API (recommended)\n  B) Phase 3: Frontend Integration\n  C) All remaining phases\n```\n\n```\n> /conductor:implement --all\n\nRunning all remaining phases for track 'User Authentication'.\nCurrent task: Implement JWT validation\n\n[RED] Writing failing test...\n[GREEN] Implementing to pass...\n[REFACTOR] Cleaning up...\n\nTask complete. Commit: feat(auth): Implement JWT validation [a1b2c3d]\n```\n\n---\n\n### `/conductor:status`\n\nDisplay project progress report.\n\n**Usage:**\n```\n/conductor:status\n```\n\n**What it does:**\n1. Parses all tracks and plans\n2. Calculates completion percentages\n3. Identifies current focus (in-progress track/phase/task)\n4. Lists any blockers\n5. Shows next actions\n\n**Example output:**\n```\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n  CONDUCTOR STATUS REPORT\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nCURRENT FOCUS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Track: User Authentication\n  Phase: Backend API [~]\n  Task:  Implement JWT validation [~]\n\nPROGRESS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 60%  (12/20 tasks)\n```\n\n---\n\n### `/conductor:agents`\n\nManage background Conductor agents and git worktrees.\n\n**Usage:**\n```\n/conductor:agents [status|results|worktrees|cleanup]\n```\n\n**Arguments:**\n- `status` (default) - Check background agent status\n- `results` - Retrieve results from completed agents\n- `worktrees` - List git worktrees used for isolation\n- `cleanup` - Remove orphaned worktrees\n\n**What it does:**\n1. Lists running background agents (implementer, planner, reviewer)\n2. Shows worktree isolation status\n3. Retrieves completed agent results\n4. Merges and cleans up worktree branches\n\n**Example:**\n```\n> /conductor:agents\n\nBackground Agents:\n  [RUNNING] implementer - Task: Add user validation (worktree: .worktrees/implementer-1735075200)\n\nWorktrees:\n  .worktrees/implementer-1735075200 â†’ conductor/implementer-1735075200\n```\n\n```\n> /conductor:agents results\n\nImplementer completed:\n  âœ“ 3 tasks completed\n  âœ“ 4 commits created\n  âœ“ Checkpoint: a1b2c3d\n\nMerging worktree back to main...\n```\n\n---\n\n### `/conductor:revert`\n\nGit-aware rollback of tracks, phases, or tasks.\n\n**Usage:**\n```\n/conductor:revert [track|phase|task] [name]\n```\n\n**Arguments:**\n- `track <name>` - Revert entire track\n- `phase <name>` - Revert specific phase\n- `task <name>` - Revert specific task\n\n**What it does:**\n1. Identifies all commits associated with the target\n2. Finds both implementation and plan update commits\n3. Presents revert plan for confirmation\n4. Executes `git revert` in correct order\n5. Handles conflicts with user guidance\n6. Updates plan.md status markers\n\n**Example:**\n```\n> /conductor:revert phase \"Backend API\"\n\nI have analyzed the git history. Here is the revert plan:\n\nCommits to revert (newest first):\n  1. b2c3d4e - conductor(plan): Complete 'Add rate limiting'\n  2. a1b2c3d - feat(api): Add rate limiting to endpoints\n\nDo you want to proceed? [Y/n]\n```\n\n## Configuration\n\n### Workflow Customization\n\nEdit `conductor/workflow.md` after setup to customize:\n\n| Setting | Default | Description |\n|---------|---------|-------------|\n| Coverage Target | 80% | Minimum test coverage percentage |\n| Commit Strategy | Per Task | When to commit (per-task or per-phase) |\n| Git Notes | Enabled | Attach summaries to commits |\n| Mobile Testing | If Applicable | Require mobile verification |\n| Parallel Agents | worktree | Strategy for parallel agent execution |\n\n### Quality Gates\n\nThe workflow enforces these checks before task completion:\n\n- All tests pass\n- Code coverage meets target (>80%)\n- Code follows style guides\n- No linting errors\n- Type safety enforced\n- Documentation updated\n\n### Code Styleguides\n\nLanguage-specific style guides are provided in `templates/code-styleguides/`:\n\n- TypeScript\n- Python\n- Go\n- JavaScript\n- HTML/CSS\n\nDuring `/conductor:setup`, selected styleguides are copied to `conductor/code_styleguides/` based on your tech stack. The `code-styleguides` skill auto-activates when writing code, reading from your project's styleguide files.\n\n## Background Execution & Parallel Agents\n\nConductor supports running agents in the background for long-running tasks and parallel workflows.\n\n### When to Use Background Execution\n\n```bash\n# Run implementer in background for long task\n> I want to implement user validation. Can you run that in the background while I work on something else?\n\n# Run multiple tasks in parallel\n> Start implementing authentication in the background, and I'll work on the frontend\n```\n\n### Parallel Agent Strategies\n\nConfigure in `conductor/workflow.md`:\n\n| Strategy | Description | Use Case |\n|----------|-------------|----------|\n| **worktree** (recommended) | Each background agent works in isolated git worktree | Parallel development without conflicts |\n| **sequential** | Background agents queue, run one at a time | Safe fallback when worktrees not desired |\n| **unsafe** | No isolation, agents work on same branch | Not recommended (manual conflict resolution) |\n\n### How Worktree Isolation Works\n\nWhen `parallel_agents: worktree`:\n\n1. **Agent spawns**: Creates `.worktrees/implementer-<id>/` with separate branch\n2. **Isolated work**: All file changes happen in worktree directory\n3. **On completion**: Branch merges back to main automatically\n4. **Cleanup**: Worktree and branch removed after merge\n\n**Benefits:**\n- âœ… No git conflicts during parallel execution\n- âœ… Each agent has independent workspace\n- âœ… Clean merge history with `--no-ff`\n- âœ… Automatic cleanup on success\n\n**Example:**\n```bash\n> /conductor:agents\n\nBackground Agents:\n  [RUNNING] implementer - worktree: .worktrees/implementer-1735075200\n\n# Agent completes...\n\n> /conductor:agents results\n\nImplementer completed. Merging worktree...\nâœ“ Merged conductor/implementer-1735075200 â†’ main\nâœ“ Removed worktree\n```\n\n### Skills Auto-Loading\n\nAgents now preload skills at startup for faster context loading:\n\n| Agent | Preloaded Skills |\n|-------|-----------------|\n| **planner** | context-awareness |\n| **implementer** | context-awareness, tdd-workflow, code-styleguides |\n| **reviewer** | context-awareness |\n\nThis ensures agents have immediate access to:\n- Project context (product.md, tech-stack.md, workflow.md)\n- TDD methodology (Red-Green-Refactor cycle)\n- Language-specific style guidelines\n\n## Project Structure\n\nWhen initialized, Conductor creates:\n\n```\nyour-project/\nâ””â”€â”€ conductor/\n    â”œâ”€â”€ product.md           # Product vision and goals\n    â”œâ”€â”€ product-guidelines.md # Brand and design standards\n    â”œâ”€â”€ tech-stack.md        # Technology choices\n    â”œâ”€â”€ workflow.md          # Development methodology\n    â”œâ”€â”€ setup_state.json     # Resume capability state\n    â”œâ”€â”€ tracks.md            # Track overview\n    â””â”€â”€ tracks/\n        â””â”€â”€ <track_id>/\n            â”œâ”€â”€ spec.md      # Requirements specification\n            â”œâ”€â”€ plan.md      # Implementation plan\n            â””â”€â”€ metadata.json\n```\n\n## Troubleshooting\n\n### Common Errors\n\n**\"Conductor is not set up\"**\n```\nRun /conductor:setup first to initialize the conductor/ directory.\n```\n\n**\"No tracks found\"**\n```\nRun /conductor:new-track to create your first track.\n```\n\n**\"You have uncommitted changes\"**\n```\nCommit or stash your changes before running /conductor:revert.\n```\n\n### Prerequisites\n\nBefore using Conductor:\n\n1. **Git repository**: Project must be a git repo (or `/conductor:setup` will init one)\n2. **Claude Code**: Version with plugin support\n3. **Test framework**: Project should have testing set up for TDD workflow\n\n### Debug Mode\n\nFor verbose output showing hook execution:\n\n```bash\nclaude --verbose --plugin-dir /path/to/conductor\n```\n\nCheck hook execution logs:\n```\n~/.claude/debug/\n```\n\n### Resuming Interrupted Setup\n\nIf setup is interrupted, it can be resumed:\n\n```bash\n# Setup saves state in conductor/setup_state.json\n# Re-running setup will offer to resume from last successful step\n/conductor:setup\n```\n\n### Session Resumption\n\nConductor automatically resumes work when starting a new session:\n\n1. **SessionStart hook** detects conductor project and shows current status\n2. **plan.md status markers** track progress (`[ ]` pending, `[~]` in-progress, `[x]` complete)\n3. **Run `/conductor:implement`** to continue from where you left off\n\nNo special handoff files needed - plan.md is the single source of truth.\n\n## Architecture\n\nConductor uses Claude Code's plugin system:\n\n| Component | Purpose |\n|-----------|---------|\n| **Commands** (`/conductor:*`) | User-invoked actions |\n| **Agents** | Specialized subagents with preloaded skills (planner, implementer, reviewer) |\n| **Skills** | Auto-loaded capabilities via frontmatter (TDD, styleguides, context) |\n| **Hooks** | Event-driven automation (context loading, change tracking) |\n| **Worktrees** | Git isolation for parallel agent execution |\n\n## Documentation\n\nSee the `reference/` directory for detailed documentation:\n\n- [Implementation Blueprint](reference/implementation-blueprint.md)\n- [Plugin Architecture](reference/plugin-architecture.md)\n- [Claude Code Mapping](reference/claude-code-mapping.md)\n- [Conductor Analysis](reference/conductor-analysis.md)\n\n## License\n\nApache-2.0\n",
        "agents/implementer.md": "---\nname: implementer\ndescription: Specialist for executing implementation tasks following TDD workflow. Use when implementing features, fixing bugs, or working through plan.md tasks.\ntools: Read, Write, Edit, Bash, Glob, Grep\nmodel: inherit\nskills: context-awareness, tdd-workflow, code-styleguides\n---\n\n# Conductor Implementation Agent\n\nExecute development tasks with discipline, quality, and TDD methodology adherence.\n\n## Your Expertise\n\n1. **TDD Execution**: Red â†’ Green â†’ Refactor cycle mastery\n2. **Clean Code**: Maintainable, readable code\n3. **Git Discipline**: Atomic commits, clear messages\n4. **Quality Gates**: Coverage, linting, type safety\n5. **Progress Tracking**: Accurate plan.md updates\n\n## Context Loading\n\n**Before implementing, read these files in parallel (4 Read calls in one response):**\n- `conductor/tracks/<track_id>/plan.md` - Implementation plan\n- `conductor/tracks/<track_id>/spec.md` - Requirements\n- `conductor/workflow.md` - Methodology\n- `conductor/tech-stack.md` - Technologies\n\n**Then read applicable styleguides:**\n- Relevant `conductor/code_styleguides/*.md` (based on languages in task)\n\n> **Performance note:** Parallel reads speed up context loading for each task.\n\n## TDD Cycle\n\nFollow the **Red â†’ Green â†’ Refactor** cycle from `tdd-workflow` skill.\n\n**Key checkpoints:**\n- Tests MUST fail before implementation (verify Red phase)\n- Write minimum code to pass (Green phase)\n- Refactor only with green tests\n- Re-run tests after each refactor\n\n## Task Execution Protocol\n\nFor each task in plan.md:\n\n1. **Mark in progress:** Edit plan.md, change `[ ]` to `[~]`\n2. **Execute TDD:** Red â†’ Green â†’ Refactor\n3. **Verify coverage:** Run test suite, ensure meets threshold (from workflow.md, default >80%)\n4. **Run quality checks:** Lint, typecheck, security scans\n5. **Commit changes:**\n   ```bash\n   git add <files>\n   git commit -m \"<type>(<scope>): <description>\"\n   ```\n   Types: feat, fix, refactor, test, docs, style, chore\n\n6. **Attach git notes:**\n   ```bash\n   git notes add -m \"Task: <description>\n\n   Summary:\n   - <key change 1>\n   - <key change 2>\n\n   Files:\n   - <file1> (new/modified)\n   - <file2>\" $(git log -1 --format=\"%H\")\n   ```\n\n7. **Update plan.md:** Change `[~]` to `[x]`, add commit SHA: `- [x] Task description [abc123d]`\n8. **Commit plan update:**\n   ```bash\n   git add conductor/tracks/<track_id>/plan.md\n   git commit -m \"conductor(plan): Complete '<task description>'\"\n   ```\n\n## Quality Gates\n\nBefore marking task complete, verify:\n- [ ] All tests pass\n- [ ] Coverage meets threshold\n- [ ] No linting errors\n- [ ] No type errors\n- [ ] Code follows styleguide\n- [ ] No security vulnerabilities\n\n### Performance Optimization\n\nFor long-running test suites or builds:\n- Consider running tests in background: Use `run_in_background: true` parameter with Bash tool\n- Can prepare next task while waiting for results\n- Always check results before marking task complete\n\n> **Note:** Claude Code supports background bash execution for long operations.\n\n## When Blocked\n\nIf blocked:\n1. Document in plan.md: `- [~] Task [BLOCKED] - Reason`\n2. Propose solutions (mock dependency, alternative approach, needed info)\n3. Ask for guidance - do NOT skip or mark incomplete work as done\n\n## Communication\n\n- Announce which task you're starting\n- Report test results (pass/fail)\n- Mention deviations from plan\n- Briefly celebrate task completion\n",
        "agents/planner.md": "---\nname: planner\ndescription: Specialist for generating specifications and implementation plans. Use when creating new tracks, writing specs, or breaking down features into tasks.\ntools: Read, Write, Glob, Grep\nmodel: inherit\nskills: context-awareness\n---\n\n# Conductor Planning Agent\n\nTranslate product requirements into actionable specifications and implementation plans.\n\n## Your Expertise\n\n1. **Requirements Analysis**: Extract clear, testable requirements\n2. **Specification Writing**: Create comprehensive spec.md\n3. **Task Decomposition**: Break features into phases/tasks\n4. **TDD Planning**: Structure tasks with test-first approach\n5. **Risk Identification**: Spot blockers and dependencies\n\n## Context Loading\n\n**Read these files in parallel (3 Read calls in one response):**\n- `conductor/product.md` - Product vision\n- `conductor/tech-stack.md` - Technologies\n- `conductor/workflow.md` - Methodology\n\n**Then read if exists:** `conductor/tracks.md` - Existing work\n\n> **Performance note:** Parallel reads speed up initial context loading for planning.\n\n## Generating spec.md\n\nStructure: Overview, Background, Functional Requirements (FR-N with description, acceptance criteria, priority), Non-Functional Requirements (NFR-N: Performance, Security), User Stories (As/Want/So format with Given/When/Then), Technical Considerations, Out of Scope, Open Questions.\n\nKeep focused. Prioritize clarity and testability.\n\n## Generating plan.md\n\nStructure:\n```markdown\n# Implementation Plan: <Track Title>\n\n## Overview\nPhase breakdown and approach\n\n## Phase 1: <Name>\nGoal: <What this phase achieves>\n\nTasks:\n- [ ] Task: <Description> (TDD: Write test, implement, refactor)\n- [ ] Task: <Description>\n- [ ] Verification: Manual steps [checkpoint marker]\n\n## Phase 2: ...\n```\n\n**Task Guidelines:**\n- Each task is one TDD cycle (Red â†’ Green â†’ Refactor)\n- Tasks should be 30min - 2hr scope\n- End each phase with verification task\n- Verification tasks use `[checkpoint marker]` for reviewer agent\n\n## Interactive Questioning\n\nBefore drafting artifacts:\n\n1. Ask 3-5 questions to clarify requirements\n2. Use AskUserQuestion with options + \"Type your own\"\n3. Explore edge cases, constraints, priorities\n4. Confirm understanding before proceeding\n\n## Output\n\nReturn:\n- Track ID generated: `<description_sanitized>_YYYYMMDD`\n- spec.md path\n- plan.md path\n- Brief summary of what was created\n",
        "agents/reviewer.md": "---\nname: reviewer\ndescription: Specialist for phase verification, test coverage analysis, and checkpoint creation. Use at end of each phase to verify quality and create checkpoints.\ntools: Read, Write, Edit, Bash, Glob, Grep\nmodel: inherit\nskills: context-awareness\n---\n\n# Conductor Review Agent\n\nVerify implementation quality and create phase checkpoints.\n\n## Your Expertise\n\n1. **Test Coverage Verification**: Identify and fill coverage gaps\n2. **Manual Verification Plans**: Generate step-by-step verification instructions\n3. **Checkpoint Creation**: Phase completion commits with git notes\n4. **Quality Assessment**: Test execution, failure diagnosis\n\n## Context Loading\n\n**Before verification, read these files in parallel (3 Read calls in one response):**\n- `conductor/tracks/<track_id>/spec.md` - Requirements\n- `conductor/tracks/<track_id>/plan.md` - Current phase/tasks\n- `conductor/workflow.md` - Methodology requirements\n\n> **Performance note:** Parallel reads speed up context loading for phase verification.\n\n## Phase Verification Protocol\n\n### 1. Announce Start\n\"Phase '<name>' complete. Running verification protocol.\"\n\n### 2. Ensure Test Coverage\n\n1. Get modified files: `git diff --name-only <last-checkpoint>..HEAD`\n2. Filter to code files (exclude .json, .md, .yaml, .css)\n3. Verify each has test: `src/foo.ts` â†’ `src/foo.test.ts` or `tests/foo.test.ts`\n4. If missing: Create following TDD patterns\n\n### 3. Execute Automated Tests\n\n1. Announce command: \"Running: CI=true npm test\"\n2. Run tests (CI env prevents watch mode)\n3. If fail: Analyze, propose fix (max 2 attempts). If still failing: Stop, request guidance.\n\n### 4. Generate Manual Verification Plan\n\nProvide specific steps based on phase type:\n\n**Frontend:** Start dev server, open browser, navigate to page, confirm UI, test interactions\n**Backend:** Start server, execute curl commands, verify responses\n**CLI:** Run commands with test inputs, verify outputs\n\n### 5. Await User Confirmation\n\nUse AskUserQuestion: \"Manual verification complete? Proceed with checkpoint?\"\n- If No: Ask what needs fixing, loop back\n- If Yes: Continue to checkpoint\n\n### 6. Create Checkpoint Commit\n\n```bash\n# Commit any remaining changes\ngit add .\ngit commit -m \"conductor(checkpoint): Complete phase '<phase name>'\"\n\n# Attach git notes with summary\nSHA=$(git log -1 --format=\"%H\")\ngit notes add -m \"Phase: <phase name>\n\nSummary:\n- <key achievement 1>\n- <key achievement 2>\n\nTasks completed: <count>\nTest coverage: <percent>%\" $SHA\n```\n\n### 7. Update plan.md\n\nAppend checkpoint SHA to phase heading: `## Phase N: <name> [checkpoint: abc123d]`\n\nCommit update:\n```bash\ngit add conductor/tracks/<track_id>/plan.md\ngit commit -m \"conductor(plan): Mark phase '<name>' complete [<sha>]\"\n```\n\n### 8. Announce Completion\n\nReport:\n- Phase checkpoint created: <sha>\n- Tasks completed: <count>\n- Next phase: <name> or \"Track complete!\"\n",
        "commands/agents.md": "---\ndescription: Manage background Conductor agents and worktrees\nargument-hint: [status|results|worktrees|cleanup]\nallowed-tools: Read, Bash, Glob\nmodel: claude-haiku-4-5-20251001\n---\n\n# Conductor Agents\n\nMonitor and manage background Conductor agents and git worktrees.\n\n## Commands\n\n### Default (no arguments): Check Background Agent Status\n\n**Run in parallel (single response with multiple Bash calls):**\n\n1. **List running tasks**:\n   ```bash\n   # Use /tasks command to see all background agents\n   # Parse output to identify conductor agents (implementer, planner, reviewer)\n   ```\n\n2. **List worktrees**:\n   ```bash\n   git worktree list\n   ```\n\n**Status Report Format:**\n\nFor each background agent, display:\n- Agent type (implementer/planner/reviewer)\n- Task ID or description\n- Status (running/completed/failed)\n- Worktree path (if using worktree isolation)\n\n**If no background agents:** \"No background agents currently running.\"\n\n**If worktrees exist but no agents:** Suggest `/conductor:agents cleanup` to remove orphaned worktrees.\n\n---\n\n### `/conductor:agents results` - Retrieve Results\n\nUse TaskOutput to retrieve results from completed background agents.\n\n**For each completed agent:**\n\n1. **Retrieve output**:\n   ```\n   TaskOutput tool:\n   - task_id: <agent_task_id>\n   - block: false\n   ```\n\n2. **Display summary**:\n   - **Implementer**: Tasks completed, commits made, checkpoint SHA\n   - **Planner**: Track ID, spec/plan paths created\n   - **Reviewer**: Verification status, checkpoint SHA\n\n3. **Worktree merge** (if applicable):\n   - Check if agent used worktree isolation\n   - Merge worktree branch back to main\n   - Cleanup worktree (see cleanup section)\n\n---\n\n### `/conductor:agents worktrees` - List Worktrees\n\nDisplay detailed worktree information:\n\n```bash\ngit worktree list\n```\n\nFor each worktree:\n- Path: `.worktrees/<agent>-<id>`\n- Branch: `conductor/<agent>-<id>`\n- Status: Check if branch has uncommitted changes\n\n**Commands for manual management:**\n\n```bash\n# View worktree branch commits\ngit log conductor/<agent>-<id>\n\n# Manually merge worktree\ngit merge --no-ff conductor/<agent>-<id> -m \"conductor(merge): Manual merge of <agent> worktree\"\n\n# Remove worktree\ngit worktree remove .worktrees/<agent>-<id>\ngit branch -d conductor/<agent>-<id>\n```\n\n---\n\n### `/conductor:agents cleanup` - Clean Orphaned Worktrees\n\nRemove worktrees that no longer have running agents.\n\n**Safety protocol:**\n\n1. **List all worktrees**:\n   ```bash\n   git worktree list\n   ```\n\n2. **Check for running agents**:\n   - Compare worktrees against active background tasks\n   - Identify orphaned worktrees (no associated running agent)\n\n3. **For each orphaned worktree**, ask user:\n   - \"Worktree `.worktrees/<agent>-<id>` has no running agent. Merge and cleanup? (yes/no)\"\n\n4. **If yes**:\n   ```bash\n   # Check for uncommitted changes\n   cd .worktrees/<agent>-<id>\n   if [ -n \"$(git status --porcelain)\" ]; then\n     echo \"WARNING: Uncommitted changes in worktree\"\n     # Ask user to confirm or abort\n   fi\n\n   # Merge branch\n   git checkout main\n   git merge --no-ff conductor/<agent>-<id> -m \"conductor(cleanup): Merge orphaned worktree <agent>-<id>\"\n\n   # Remove worktree\n   git worktree remove .worktrees/<agent>-<id>\n\n   # Delete branch\n   git branch -d conductor/<agent>-<id>\n   ```\n\n5. **If no**: Skip that worktree\n\n6. **Report**: \"Cleaned up N worktrees.\"\n\n---\n\n## Integration with /implement\n\nAfter retrieving background implementer results:\n\n1. **Verify plan.md reflects completed tasks**\n2. **Check if phase is complete**\n3. **Suggest next action**:\n   - Continue implementation (more tasks)\n   - Run phase verification (phase complete)\n   - Check status (review progress)\n\n---\n\n## Safety Notes\n\n- Always check for uncommitted changes before removing worktrees\n- Use `--no-ff` merge to preserve branch history for audit trail\n- Confirm with user before destructive operations\n- Background agents may fail - always check status before cleanup\n",
        "commands/implement.md": "---\ndescription: Execute tasks from the current track following TDD workflow\nargument-hint: [<track-name>] [--all]\nallowed-tools: Read, Write, Edit, Bash, Glob, Grep, Task\nmodel: inherit\n---\n\n# Conductor Implement\n\nExecute the implementation workflow for the selected track.\n\n## Pre-flight Checks\n\n**Run these checks in parallel (single response with multiple Bash calls):**\n\n1. **Verify Conductor Setup**:\n\n   ```bash\n   test -f conductor/tech-stack.md && test -f conductor/workflow.md && test -f conductor/product.md && echo \"ready\" || echo \"missing\"\n   ```\n   - If \"missing\": \"Conductor is not set up. Please run `/conductor:setup` first.\"\n\n2. **Check for tracks**:\n\n   ```bash\n   test -f conductor/tracks.md && echo \"exists\" || echo \"not found\"\n   ```\n   - If \"not found\": \"No tracks found. Create one with `/conductor:new-track`.\"\n   - If \"exists\", read and parse `conductor/tracks.md`\n   - If empty or malformed: \"No tracks found. Create one with `/conductor:new-track`.\"\n\n## Argument Parsing\n\n| Pattern | Track Selection | Phase Mode |\n|---------|----------------|------------|\n| `/implement` | Auto-select first incomplete | Single-phase |\n| `/implement user-auth` | Match \"user-auth\" | Single-phase |\n| `/implement --all` | Auto-select first incomplete | All-phases |\n| `/implement user-auth --all` | Match \"user-auth\" | All-phases |\n\n## Track Selection\n\n### If track name provided ($ARGUMENTS)\n\n1. Search `conductor/tracks.md` for matching track description\n2. If found: \"Found track '<description>'. Is this correct?\"\n3. If not found: Suggest closest match or next available track\n\n### If no track name provided\n\n1. Find first incomplete track (`[ ]` or `[~]`)\n2. Announce: \"Selecting next incomplete track: '<description>'\"\n3. If no incomplete tracks: \"All tracks complete! Create a new one with `/conductor:new-track`.\"\n\n## Begin Implementation\n\n### Session Resumption\n\nConductor automatically resumes from plan.md status markers:\n\n1. **Find resumption point**: Scan plan.md for first `[~]` (in-progress) or first `[ ]` (pending) task\n2. **Announce**: \"Resuming at Phase N: <name>, Task: <description>\" (if continuing mid-phase)\n3. **Skip completed work**: Tasks marked `[x]` are already done\n\nNo special handoff files needed - plan.md is the single source of truth.\n\n### Update Track Status\n\n1. Find track heading in `conductor/tracks.md`\n2. Change `## [ ] Track:` to `## [~] Track:` (if not already in progress)\n3. Commit: `conductor(track): Start track '<description>'` (if status changed)\n\n### Load Track Context\n\n**Read these files in parallel (use multiple Read tool calls in one response):**\n\n- `conductor/tracks/<track_id>/plan.md`\n- `conductor/tracks/<track_id>/spec.md`\n- `conductor/workflow.md`\n- `conductor/tech-stack.md`\n\n> **Performance note:** These files are independent and can be read simultaneously.\n\n## Phase Discovery\n\nParse phases from the track's `plan.md`:\n\n1. **Find phase headings**: Match `## Phase N: <Name>` patterns (H2 headings)\n2. **Detect completed phases**: Phases with `[checkpoint: <sha>]` suffix are complete\n3. **Count tasks per phase**: Count `- [ ]`, `- [~]`, `- [x]` lines under each phase\n4. **Determine phase status**:\n   - `complete`: Has checkpoint SHA in heading\n   - `in_progress`: Has any task marked `[~]`\n   - `pending`: All tasks marked `[ ]`\n\nBuild ordered list of phases with their status and task counts.\n\n## Phase Selection\n\n### If `--all` flag is set\nSkip selection. Announce \"Running all remaining phases for track '<description>'.\" Proceed to Task Execution Loop.\n\n### If `--all` flag is NOT set (single-phase mode)\n\n| Scenario | Action |\n|----------|--------|\n| No incomplete phases | Announce complete. Offer `/conductor:status` or `/conductor:new-track`. **STOP** |\n| Exactly 1 incomplete | Auto-select. Announce \"Only one phase remaining: Phase N: <name>. Proceeding...\" |\n| Multiple incomplete | Use AskUserQuestion with options for each phase + \"All remaining\" option |\n\n**Processing selection:**\n- If phase selected: Set `selected_phase = N`\n- If \"All remaining\": Set `run_all_phases = true`\n\n## Task Execution Loop\n\n### Determine Execution Scope\n\nBased on Phase Selection results:\n\n1. **If `run_all_phases = true`**: Execute all tasks from first incomplete phase through end\n2. **If `selected_phase` is set**: Execute only tasks within the selected phase\n\n### For each task in scope (in order):\n\n### Delegate to Implementer Agent\n\nALWAYS use the Task tool to delegate task execution to the implementer agent:\n\n```\nTask tool:\n- subagent_type: 'conductor:implementer'\n- prompt: |\n    Execute task: <task description>\n\n    Track ID: <track_id>\n    Context files:\n    - conductor/tracks/<track_id>/spec.md\n    - conductor/tracks/<track_id>/plan.md\n    - conductor/workflow.md\n    - conductor/tech-stack.md\n\n    Requirements:\n    1. Mark task in progress in plan.md\n    2. Follow TDD: Red â†’ Green â†’ Refactor\n    3. Verify coverage meets threshold (>80%)\n    4. Run quality checks (lint, typecheck)\n    5. Commit with conventional message\n    6. Attach git notes with summary\n    7. Update plan.md with commit SHA\n    8. Commit plan update\n\n    Report back when task is complete or if blocked.\n```\n\nThe implementer agent will:\n\n- Execute the full TDD cycle\n- Commit code changes with proper messages\n- Update plan.md with progress\n- Report completion or blockers\n\n### Background Execution Option\n\nFor long-running tasks or parallel workflows, run the implementer in background:\n\n**When to use:**\n- User explicitly requests it (\"run in background\", \"work on this while I...\")\n- Task is estimated to take significant time\n- User wants to work on unrelated tasks in parallel\n\n**Resource Warning:**\n- Each background agent runs tests independently, consuming significant CPU\n- Limit to 2-3 concurrent background agents to avoid system overload\n- On resource-constrained systems, prefer `parallel_agents: sequential` mode\n- Use `/conductor:agents` to monitor running agents and clean up orphaned worktrees\n\n**Worktree isolation (if `parallel_agents: worktree` in workflow.md):**\n\n1. **Before spawning agent**, create isolated worktree:\n   ```bash\n   TASK_ID=\"task_$(date +%s)\"\n   git worktree add .worktrees/implementer-$TASK_ID -b conductor/implementer-$TASK_ID\n   ```\n\n2. **Spawn agent with worktree path**:\n   ```\n   Task tool:\n   - subagent_type: 'conductor:implementer'\n   - run_in_background: true\n   - prompt: |\n       WORKING DIRECTORY: .worktrees/implementer-<task_id>\n\n       Execute task: <task description>\n\n       Track ID: <track_id>\n       Context files (relative to worktree):\n       - conductor/tracks/<track_id>/spec.md\n       - conductor/tracks/<track_id>/plan.md\n       ...\n   ```\n\n3. **Announce**: \"Running implementer in background (worktree: `.worktrees/implementer-<task_id>`). Task: '<description>'\"\n\n4. **On completion** (use TaskOutput to retrieve):\n   ```bash\n   # Switch to worktree to get changes\n   cd .worktrees/implementer-$TASK_ID\n\n   # Merge branch back\n   git checkout main\n   git merge --no-ff conductor/implementer-$TASK_ID -m \"conductor(merge): Complete background task '<description>'\"\n\n   # Cleanup worktree\n   git worktree remove .worktrees/implementer-$TASK_ID\n   git branch -d conductor/implementer-$TASK_ID\n   ```\n\n**Important:**\n- If `parallel_agents: sequential`, queue background agents instead of running in parallel\n- If `parallel_agents: unsafe`, skip worktree creation (not recommended)\n- DO NOT use background for dependent tasks within a phase\n- Always verify background completion before phase verification\n\n### Phase Completion Check\n\n**CRITICAL**: If implementer was running in background, use TaskOutput to retrieve results before phase verification.\n\nWhen all tasks in a phase are complete, delegate to reviewer agent:\n\n```\nTask tool:\n- subagent_type: 'conductor:reviewer'\n- prompt: |\n    Verify phase: <phase name>\n\n    Track ID: <track_id>\n    Context files:\n    - conductor/tracks/<track_id>/spec.md\n    - conductor/tracks/<track_id>/plan.md\n    - conductor/workflow.md\n\n    Requirements:\n    1. Announce verification protocol start\n    2. Verify test coverage for all changed files\n    3. Run automated tests\n    4. Generate manual verification plan\n    5. Await user confirmation\n    6. Create checkpoint commit with git notes\n    7. Update plan.md with checkpoint SHA\n\n    Do not proceed past step 5 without explicit user approval.\n```\n\nThe reviewer agent will:\n\n- Verify test coverage for phase changes\n- Run full test suite\n- Generate manual verification steps\n- Await user confirmation\n- Create checkpoint commit\n- Update plan with checkpoint SHA\n\n### After Phase Verification Completes\n\n**Single-phase mode:** Announce \"Phase N: <name> complete. Checkpoint: <sha>\". Use AskUserQuestion: Continue to next phase / Take a break / Check status. Act accordingly.\n\n**All-phases mode:** Continue directly to next phase. Only stop at track completion.\n\n## Track Completion\n\nWhen all phases complete:\n\n1. Update `tracks.md`: `[~]` â†’ `[x]`\n2. Review if `product.md` or `tech-stack.md` need updates (propose, await approval)\n3. Use AskUserQuestion: Archive to conductor/archive / Delete / Leave as-is\n4. Announce: \"Track complete! Run `/conductor:status` for overall progress.\"\n",
        "commands/new-track.md": "---\ndescription: Create a new feature or bug track with spec and plan\nargument-hint: [description]\nallowed-tools: Read, Write, Glob, Task\nmodel: inherit\n---\n\n# Conductor New Track\n\nCreate new track (feature/bug/chore) with spec and plan.\n\n## Pre-flight Checks\n\n**Read these files in parallel (4 Read calls in one response):**\n1. `conductor/tech-stack.md` - Verify exists, load tech context\n2. `conductor/workflow.md` - Verify exists, load workflow context\n3. `conductor/product.md` - Verify exists, load product context\n4. `conductor/tracks.md` - Get existing track IDs (handle if missing)\n\nIf any of the first 3 files are missing: \"Run `/conductor:setup` first.\"\n\n> **Performance note:** Parallel reads speed up pre-flight verification.\n\n## Get Track Description\n\n| Scenario | Action |\n|----------|--------|\n| Description provided ($ARGUMENTS) | Use directly |\n| No description | Ask: \"Provide brief track description (feature/bug/chore)\" |\n\n## Determine Track Type\n\nInfer from description (don't ask):\n- **Feature**: \"add\", \"create\", \"implement\"\n- **Bug**: \"fix\", \"broken\", \"error\"\n- **Chore**: \"update\", \"refactor\", \"clean\"\n\n## Delegate to Planner Agent\n\nALWAYS use Task tool:\n```\nTask tool:\n- subagent_type: 'conductor:planner'\n- prompt: |\n    Create specification and implementation plan for: <description>\n\n    Track type: <feature|bug|chore>\n\n    Context files:\n    - conductor/product.md\n    - conductor/tech-stack.md\n    - conductor/workflow.md\n\n    Generate:\n    1. Specification (spec.md): Requirements, acceptance criteria, constraints\n    2. Implementation plan (plan.md): Phased breakdown with TDD-oriented tasks\n    3. Generate unique track_id: <sanitized_description>_<YYYYMMDD>\n\n    Return track_id, file paths, and summary when complete.\n```\n\n### Background Planning Option\n\nFor large features or when user wants to continue working:\n\n```\nTask tool:\n- subagent_type: 'conductor:planner'\n- run_in_background: true\n- prompt: |\n    Create specification and implementation plan for: <description>\n    ...\n```\n\n**When to use:**\n- User explicitly requests background execution (\"plan this in background\")\n- Feature is complex (expected to generate large spec/plan)\n- User wants to work on other tasks while planning proceeds\n\n**Important caveats:**\n- Background planning is NOT recommended for most cases because:\n  - Planner uses interactive questioning (AskUserQuestion) which requires foreground\n  - User feedback is valuable during spec refinement\n- Only use if user explicitly prefers to review completed artifacts without iteration\n\n## Finalize Track\n\nAfter planner completes:\n\n1. **Read generated files** to verify structure\n2. **Create metadata.json:**\n   ```json\n   {\n     \"id\": \"<track_id>\",\n     \"description\": \"<description>\",\n     \"type\": \"<feature|bug|chore>\",\n     \"created_at\": \"<ISO timestamp>\",\n     \"status\": \"pending\"\n   }\n   ```\n3. **Register in tracks.md:**\n   - If file doesn't exist, create with header\n   - Append: `## [ ] Track: <description> [<track_id>]`\n   - Keep tracks in chronological order\n4. **Commit:**\n   ```bash\n   git add conductor/tracks.md conductor/tracks/<track_id>/\n   git commit -m \"conductor(track): Add track '<description>'\"\n   ```\n5. **Announce:** \"Track '<description>' created. Run `/conductor:implement <description>` to start.\"\n",
        "commands/revert.md": "---\ndescription: Revert a track, phase, or task using git-aware rollback\nargument-hint: [track|phase|task] [name]\nallowed-tools: Read, Bash, Glob, Grep\nmodel: claude-haiku-4-5-20251001\n---\n\n# Conductor Revert\n\nGit-aware revert that understands logical units of work (tracks, phases, tasks).\n\n## Pre-flight Checks\n\n1. Verify `conductor/tracks.md` exists. If not: \"Run `/conductor:setup` first.\"\n2. Check `git status --porcelain`. If uncommitted changes: \"Commit or stash before reverting.\"\n\n## Phase 1: Target Selection\n\n### Parse Arguments\n\n| Pattern | Action |\n|---------|--------|\n| `track <name>` | Revert entire track |\n| `phase <name>` | Revert specific phase |\n| `task <name>` | Revert specific task |\n| (no args) | Show menu of in-progress/recent items |\n\n### If no target provided\n\n1. Scan `tracks.md` and `plan.md` files for `[~]` (in-progress) and recent `[x]` (completed) items\n2. Use AskUserQuestion with numbered options for candidates + \"A different item\" option\n3. If \"different\", ask for specific name\n\n### Confirm Target\n\nUse AskUserQuestion: \"Revert [Phase] 'Backend API' from track 'user_auth'?\" Yes/No\n\n## Phase 2: Git Analysis\n\n**Run these git operations in parallel (multiple Bash calls in one response):**\n\n1. **Extract commit SHAs** from target's plan.md:\n   ```bash\n   grep -o '\\[[x~]\\].*\\[[a-f0-9]\\{7\\}\\]' conductor/tracks/<id>/plan.md\n   ```\n\n2. **Find plan update commits:**\n   ```bash\n   git log --oneline -- conductor/tracks/<id>/plan.md\n   ```\n\n3. **For track reverts - find creation commit:**\n   ```bash\n   git log --oneline -- conductor/tracks.md | grep -i \"add track\"\n   ```\n\n**Sequential verification:**\n- After parallel reads, verify each extracted SHA exists: `git cat-file -t <sha>`\n- If missing, search by message: `git log --oneline --all | grep \"<message>\"`\n- Compile ordered list (newest first) of all commits to revert (implementation + plan updates)\n\n> **Performance note:** Parallelizing git read operations speeds up revert preparation.\n\n## Phase 3: Execution Plan\n\n### Present Summary\n\nDisplay:\n- Target description\n- List of commits (newest first) with messages\n- Action: `git revert --no-edit` on each\n- Warnings: Merge commits need special handling, old commits may have dependents\n\nUse AskUserQuestion: \"Proceed with revert?\" Yes/No\n\n## Phase 4: Execution\n\n### Execute Reverts\n\nFor each commit (newest to oldest):\n```bash\ngit revert --no-edit <sha>\n```\n\n### Handle Conflicts\n\nIf conflict: Use AskUserQuestion: \"Show conflict for manual resolution / Abort revert\"\n- If show: Display conflict, wait for resolution, run `git add . && git revert --continue`\n- If abort: Run `git revert --abort`, announce rollback\n\n### Verify Plan State\n\nAfter reverts:\n1. Read affected plan.md\n2. If status doesn't match (still `[x]` but code reverted):\n   - Edit to change `[x]` â†’ `[ ]`\n   - Remove commit SHAs\n   - Commit: `git commit -m \"conductor(plan): Reset status after revert\"`\n\n## Completion\n\n**Success:**\nAnnounce:\n- Reverted N commits\n- Reset target status\n- Changed files list\n- Next steps: Run tests, `/conductor:status`, `/conductor:implement` to restart\n\n**Partial:**\nAnnounce:\n- Successfully reverted commits\n- Failed commits (conflicts)\n- Manual intervention needed\n- Run `git status` for details\n",
        "commands/setup.md": "---\ndescription: Initialize Conductor environment for context-driven development\nargument-hint: [project-type]\nallowed-tools: Read, Write, Edit, Bash, Glob, Grep, Task\nmodel: inherit\n---\n\n# Conductor Setup\n\nInitialize Conductor context-driven development environment. Follow protocol precisely.\n\n## Pre-flight Check\n\n1. **Check existing setup:** Test `conductor/setup_state.json`. If exists:\n   - Read and offer resume from `last_successful_step`\n   - If step is \"complete\", inform setup is done\n2. **Check conductor directory:** If exists without state file, warn about overwrite. Confirm before proceeding.\n\n## Phase 1: Project Discovery\n\n### 1.1 Detect Project Maturity\n\n**Check brownfield indicators in parallel (3 Bash calls in one response):**\n\n1. **Git check:**\n   ```bash\n   test -d .git && echo \"git:yes\" || echo \"git:no\"\n   ```\n\n2. **Manifest check:**\n   ```bash\n   ls package.json requirements.txt go.mod pom.xml Cargo.toml 2>/dev/null | head -1 || echo \"manifest:none\"\n   ```\n\n3. **Source directories check:**\n   ```bash\n   ls -d src app lib 2>/dev/null | head -1 || echo \"src:none\"\n   ```\n\n**Evaluation:**\n- **Brownfield:** Any indicator returns positive result\n- **Greenfield:** All checks return negative/none, directory empty or only README\n\n> **Performance note:** Running these checks in parallel speeds up project discovery.\n\n### 1.2 Execute by Maturity\n\n| Type | Actions |\n|------|---------|\n| Brownfield | Announce analysis. Check git status (warn uncommitted). Analyze README, manifest files (respect .gitignore). Infer tech stack, architecture, goals. Present findings for confirmation. |\n| Greenfield | Announce new project. Init git if needed. Ask \"What do you want to build?\" Create `conductor/`. Write initial concept to `product.md`. |\n\n### 1.3 Initialize State\n\nCreate `conductor/setup_state.json` with project_type and created_at timestamp.\n\n## Phase 2: Context Generation\n\nFor each section: (1) Introduce, (2) Ask questions (AskUserQuestion with options + \"Type your own\" + \"Auto-generate\"), (3) Draft content, (4) Present for approval, (5) Write file, (6) Update state.\n\n| Section | File | Questions | State Step |\n|---------|------|-----------|------------|\n| Product Guide | `product.md` | Target users? Problems solved? Key features? Success metrics? | 2.1_product_guide |\n| Product Guidelines | `product-guidelines.md` | Brand voice/tone? Design standards? Communication style? | 2.2_product_guidelines |\n| Tech Stack | `tech-stack.md` | Brownfield: Confirm inferred stack. Greenfield: Languages, frameworks, databases? | 2.3_tech_stack |\n| Code Styleguides | `code_styleguides/*.md` | Detect languages from tech-stack.md. Map to available guides (typescript, python, go, javascript, html-css). Copy templates. Ask if adding others. | 2.4_code_styleguides |\n| Workflow | `workflow.md` | Copy template. Ask: Coverage target (default 80%)? Commit per task/phase (default task)? Use git notes (default yes)? | 2.5_workflow |\n\n## Phase 3: Initial Track\n\n### 3.1 Get Track Description\n\n**Greenfield:** Ask what to build first (MVP focus)\n**Brownfield:** Ask what enhancement/improvement to start with\n\n### 3.2 Delegate to Planner\n\nALWAYS use Task tool:\n```\nTask tool:\n- subagent_type: 'conductor:planner'\n- prompt: |\n    Create spec and plan for initial track: <description>\n    Project type: <brownfield|greenfield>\n\n    Context files: product.md, tech-stack.md, workflow.md\n\n    Generate spec.md and plan.md with TDD task structure.\n    Return artifacts for review.\n```\n\n### 3.3 Create Track Artifacts\n\nAfter planner returns:\n1. Generate track ID: `<shortname>_YYYYMMDD`\n2. Create `tracks.md` with first track entry\n3. Create `tracks/<track_id>/` with spec.md, plan.md, metadata.json\n4. Update state: `\"complete\"`\n\n## Completion\n\n1. **Commit:**\n   ```bash\n   git add conductor/ && git commit -m \"conductor(setup): Initialize environment\"\n   ```\n\n2. **Announce:**\n   ```\n   Setup complete! Project now has:\n   - Product context in conductor/product.md\n   - Tech stack in conductor/tech-stack.md\n   - Workflow in conductor/workflow.md\n   - First track in conductor/tracks/\n\n   Next: /conductor:implement to start working\n   ```\n",
        "commands/status.md": "---\ndescription: Display current progress of Conductor-managed project\nallowed-tools: Read, Glob, Bash\nmodel: claude-haiku-4-5-20251001\n---\n\n# Conductor Status\n\nDisplay comprehensive project status overview.\n\n## Pre-flight Check\n\n1. Check `conductor/tracks.md` exists. If not: \"Run `/conductor:setup` to initialize.\"\n2. If empty: \"No tracks. Create one with `/conductor:new-track`.\"\n\n## Gather Data\n\n### Step 1: Read Core Files (Parallel)\n\n**Use parallel Read tool calls for:**\n- `conductor/product.md` - Project name and context\n- `conductor/tracks.md` - Track list and status\n\n### Step 2: Read All Track Plans (Parallel)\n\nAfter listing track directories with `ls conductor/tracks/`, **issue parallel Read calls for all track `plan.md` files:**\n- `conductor/tracks/<track1>/plan.md`\n- `conductor/tracks/<track2>/plan.md`\n- (etc. for all tracks)\n\nFor each plan.md, count:\n- `[ ]` pending tasks\n- `[~]` in-progress tasks\n- `[x]` completed tasks\n- Identify current phase and task\n\n> **Performance note:** Reading all track plans in parallel significantly speeds up status reporting for projects with multiple tracks.\n\n## Generate Report\n\nDisplay status with:\n- Project name and timestamp\n- Tracks overview: Completed âœ… / In Progress ðŸ”„ / Pending â³ counts\n- Current focus: Track, Phase, Task (all `[~]` items)\n- Progress bar: `[â–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘] X%` (completed/total tasks)\n- Track details: Tree view with status indicators per phase/task\n- Next actions: Upcoming 2-3 tasks\n- Call to action: \"Run /conductor:implement to continue\"\n\n### If Blockers\n\nShow section with blocked tasks and reasons (from plan.md BLOCKED markers).\n\n### If All Complete\n\nShow celebration: \"ðŸŽ‰ ALL TRACKS COMPLETE! Create new track with /conductor:new-track\"\n\n### Summary Stats\n\n- Total phases/tasks across all tracks\n- Overall completion percentage\n",
        "hooks/hooks.json": "{\n  \"description\": \"Conductor plugin hooks for context loading and progress tracking\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"startup|resume\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/load-context.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/warn-config.js\",\n            \"timeout\": 3\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/track-changes.js\",\n            \"timeout\": 3\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"matcher\": \"*\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/scripts/session-end.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "hooks/scripts/load-context.js": "#!/usr/bin/env node\n// SessionStart hook - Load Conductor context and show resumption info\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\n// Batched file reads with concurrency limit to prevent file descriptor exhaustion\nasync function batchedReadPlans(trackIds, tracksDir, concurrency = 5) {\n  const results = [];\n  for (let i = 0; i < trackIds.length; i += concurrency) {\n    const batch = trackIds.slice(i, i + concurrency);\n    const batchResults = await Promise.all(batch.map(async (trackId) => {\n      try {\n        const content = await fs.readFile(\n          path.join(tracksDir, trackId, 'plan.md'),\n          'utf8'\n        );\n        return { trackId, plan: content };\n      } catch {\n        return null;\n      }\n    }));\n    results.push(...batchResults);\n  }\n  return results.filter(Boolean);\n}\n\n// Find next task from plan.md content\nfunction findNextTask(planContent) {\n  const lines = planContent.split('\\n');\n  let currentPhase = null;\n\n  for (const line of lines) {\n    // Track current phase\n    const phaseMatch = line.match(/^## Phase \\d+:\\s*(.+?)(?:\\s*\\[checkpoint:|\\s*$)/);\n    if (phaseMatch) {\n      currentPhase = phaseMatch[1].trim();\n    }\n\n    // Find in-progress task first\n    const inProgressMatch = line.match(/^- \\[~\\]\\s*(?:Task:\\s*)?(.+)/);\n    if (inProgressMatch) {\n      return {\n        task: inProgressMatch[1].trim(),\n        phase: currentPhase,\n        status: 'in_progress'\n      };\n    }\n\n    // Find first pending task\n    const pendingMatch = line.match(/^- \\[ \\]\\s*(?:Task:\\s*)?(.+)/);\n    if (pendingMatch) {\n      return {\n        task: pendingMatch[1].trim(),\n        phase: currentPhase,\n        status: 'pending'\n      };\n    }\n  }\n\n  return null;\n}\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = chunks.join('');\n\n  const data = JSON.parse(input);\n  const cwd = data.cwd || process.cwd();\n  const conductorDir = path.join(cwd, 'conductor');\n  const tracksFile = path.join(conductorDir, 'tracks.md');\n  const tracksDir = path.join(conductorDir, 'tracks');\n\n  // Parallel reads: tracks.md + directory listing\n  const [content, trackIds] = await Promise.all([\n    fs.readFile(tracksFile, 'utf8').catch(() => null),\n    fs.readdir(tracksDir).catch(() => [])\n  ]);\n\n  // Exit if no conductor project\n  if (!content) {\n    process.exit(0);\n  }\n\n  let context = '## Conductor Project Detected\\n\\n';\n  const lines = content.split('\\n');\n\n  // Count tracks by status with single-pass regex\n  const STATUS_REGEX = /\\[(completed|in-progress|pending)\\]/g;\n  const counts = { completed: 0, 'in-progress': 0, pending: 0 };\n  let match;\n  while ((match = STATUS_REGEX.exec(content)) !== null) {\n    counts[match[1]]++;\n  }\n  const total = counts.completed + counts['in-progress'] + counts.pending;\n\n  context += `**Tracks:** ${total} total (${counts.completed} completed, ${counts['in-progress']} in-progress, ${counts.pending} pending)\\n\\n`;\n\n  // Find current in-progress track\n  const inProgressLine = lines.find(line => line.includes('[in-progress]'));\n  let currentTrackId = null;\n  if (inProgressLine) {\n    // Extract track ID from the line (last bracket content that looks like an ID)\n    const trackMatch = inProgressLine.match(/\\[([a-z0-9_-]+)\\]$/i);\n    if (trackMatch) {\n      currentTrackId = trackMatch[1];\n    }\n    // Extract description\n    const descMatch = inProgressLine.match(/Track:\\s*(.+?)\\s*\\[/);\n    if (descMatch) {\n      context += `**Current Track:** ${descMatch[1]}\\n`;\n    }\n  }\n\n  // Find next task from in-progress track's plan.md\n  if (currentTrackId && trackIds.includes(currentTrackId)) {\n    const plans = await batchedReadPlans([currentTrackId], tracksDir);\n    if (plans.length > 0) {\n      const nextTask = findNextTask(plans[0].plan);\n      if (nextTask) {\n        if (nextTask.phase) {\n          context += `**Current Phase:** ${nextTask.phase}\\n`;\n        }\n        const statusLabel = nextTask.status === 'in_progress' ? 'Resuming' : 'Next';\n        context += `**${statusLabel} Task:** ${nextTask.task}\\n`;\n      }\n    }\n  }\n\n  // Check for orphaned worktrees (agents that may have crashed)\n  const worktreesDir = path.join(cwd, '.worktrees');\n  const worktrees = await fs.readdir(worktreesDir).catch(() => []);\n  if (worktrees.length > 0) {\n    context += `\\n**Warning:** ${worktrees.length} worktree(s) detected. Run \\`/conductor:agents\\` to check status.\\n`;\n  }\n\n  context += `\\nRun \\`/conductor:implement\\` to continue.`;\n\n  // Output JSON with context\n  console.log(JSON.stringify({\n    hookSpecificOutput: {\n      hookEventName: 'SessionStart',\n      additionalContext: context\n    }\n  }));\n}\n\nmain().catch(() => process.exit(1));\n",
        "hooks/scripts/session-end.js": "#!/usr/bin/env node\n// Stop hook - Remind about in-progress work\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = chunks.join('');\n\n  const data = JSON.parse(input);\n  const cwd = data.cwd || process.cwd();\n  const tracksFile = path.join(cwd, 'conductor', 'tracks.md');\n\n  // Try to read tracks file (TOCTOU fix)\n  const content = await fs.readFile(tracksFile, 'utf8').catch(() => null);\n  if (!content) {\n    process.exit(0);\n  }\n\n  const inProgress = (content.match(/\\[in-progress\\]/g) || []).length;\n\n  if (inProgress > 0) {\n    console.error('');\n    console.error(`Conductor: ${inProgress} track(s) still in progress.`);\n    console.error('Run /conductor:status to see details.');\n  }\n}\n\nmain().catch(() => process.exit(1));\n",
        "hooks/scripts/track-changes.js": "#!/usr/bin/env node\n// PostToolUse hook - Track plan.md modifications\n\nconst fs = require('fs').promises;\nconst path = require('path');\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = chunks.join('');\n\n  const data = JSON.parse(input);\n  const filePath = data.tool_input?.file_path || '';\n  const cwd = data.cwd || process.cwd();\n\n  // Only track conductor plan.md changes\n  if (filePath.includes('conductor') && filePath.includes('plan.md')) {\n    const timestamp = new Date().toISOString();\n    const logFile = path.join(cwd, 'conductor', '.conductor_session_log');\n    await fs.appendFile(logFile, `${timestamp}: Modified ${filePath}\\n`);\n  }\n}\n\nmain().catch(() => process.exit(1));\n",
        "hooks/scripts/warn-config.js": "#!/usr/bin/env node\n// PreToolUse hook - Warn when modifying core config files\n\nconst path = require('path');\n\nasync function main() {\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = chunks.join('');\n\n  const data = JSON.parse(input);\n  const filePath = data.tool_input?.file_path || '';\n\n  // Check if modifying core conductor config\n  const configPattern = /conductor\\/(product|tech-stack|workflow)\\.md$/;\n  if (configPattern.test(filePath)) {\n    const configName = path.basename(filePath);\n    console.log(JSON.stringify({\n      systemMessage: `Modifying core conductor config: ${configName}`\n    }));\n  }\n}\n\nmain().catch(() => process.exit(1));\n",
        "reference/README.md": "# Conductor for Claude Code\n\n> Bringing Context-Driven Development to Claude Code\n\nThis documentation explores how [Conductor](https://github.com/gemini-cli-extensions/conductor), a Gemini CLI extension for Context-Driven Development, can be adapted and enhanced for Claude Code using its extensibility primitives: **Skills**, **Agents**, **Plugins**, **Commands**, and **Hooks**.\n\n## Attribution\n\nThis project is inspired by and based on:\n\n| | |\n|---|---|\n| **Original Project** | [Conductor](https://github.com/gemini-cli-extensions/conductor) |\n| **Authors** | [gemini-cli-extensions](https://github.com/gemini-cli-extensions) |\n| **License** | Apache License 2.0 |\n| **Platform** | Gemini CLI |\n\n## Overview\n\nConductor is a development methodology framework that transforms AI CLI tools into proactive project managers. It enforces a structured lifecycle for every task:\n\n```\nContext â†’ Spec & Plan â†’ Implement\n```\n\nThe core philosophy: **treat context as a managed artifact alongside your code**, creating a single source of truth that provides persistent project awareness.\n\n## Documentation Structure\n\n| Document | Description |\n|----------|-------------|\n| [Conductor Analysis](./conductor-analysis.md) | Deep dive into the original Conductor architecture |\n| [Claude Code Mapping](./claude-code-mapping.md) | How Conductor concepts map to Claude Code primitives |\n| [Plugin Architecture](./plugin-architecture.md) | Proposed plugin structure and design |\n| [Implementation Blueprint](./implementation-blueprint.md) | Step-by-step implementation guide |\n| [Examples](./examples/) | Example command, agent, and skill files |\n\n## Quick Comparison\n\n| Aspect | Conductor (Gemini) | Conductor (Claude Code) |\n|--------|-------------------|------------------------|\n| Commands | TOML with inline prompts | Markdown with frontmatter |\n| Context Loading | Manual per-command | Auto-discovered via Skills |\n| Specialization | Single monolithic prompt | Dedicated Agents |\n| User Interaction | Text-based A/B/C | Native AskUserQuestion UI |\n| Event Handling | None | Hooks system |\n| Distribution | Git clone | Plugin package |\n\n## Key Benefits of Claude Code Implementation\n\n1. **Skills provide auto-discovery** - Claude automatically follows TDD workflow when it detects a Conductor project\n2. **Agents provide specialization** - Dedicated planning and implementation contexts\n3. **Hooks provide automation** - Context loads automatically, progress tracked\n4. **Plugins provide distribution** - Easy install, versioning, sharing\n\n## Getting Started\n\nSee the [Implementation Blueprint](./implementation-blueprint.md) for how to build this plugin.\n\n## References\n\n- **Original Conductor**: https://github.com/gemini-cli-extensions/conductor\n- **Claude Code Documentation**: https://docs.anthropic.com/en/docs/claude-code\n- **Claude Code Plugins**: https://docs.anthropic.com/en/docs/claude-code/plugins\n",
        "reference/examples/README.md": "# Examples\n\n> Complete implementation examples for Conductor on Claude Code\n\nThis directory contains working examples of all plugin components.\n\n## Directory Structure\n\n```\nexamples/\nâ”œâ”€â”€ commands/           # Slash command implementations\nâ”‚   â”œâ”€â”€ setup.md       # /conductor:setup\nâ”‚   â”œâ”€â”€ new-track.md   # /conductor:new-track\nâ”‚   â”œâ”€â”€ implement.md   # /conductor:implement\nâ”‚   â”œâ”€â”€ status.md      # /conductor:status\nâ”‚   â””â”€â”€ revert.md      # /conductor:revert\nâ”œâ”€â”€ agents/            # Specialized subagent definitions\nâ”‚   â”œâ”€â”€ planner.md      # Planning & specs\nâ”‚   â””â”€â”€ implementer.md  # Task execution\nâ”œâ”€â”€ skills/            # Auto-discovered capabilities\nâ”‚   â”œâ”€â”€ context-awareness/\nâ”‚   â”‚   â””â”€â”€ SKILL.md   # Project context loading\nâ”‚   â””â”€â”€ tdd-workflow/\nâ”‚       â””â”€â”€ SKILL.md   # TDD methodology\nâ””â”€â”€ hooks/\n    â””â”€â”€ hooks.json     # Event-driven automations\n```\n\n## Commands\n\n| Command                | File                                    | Description                    |\n| ---------------------- | --------------------------------------- | ------------------------------ |\n| `/conductor:setup`     | [setup.md](./commands/setup.md)         | Initialize project environment |\n| `/conductor:new-track`  | [new-track.md](./commands/new-track.md) | Create feature/bug track       |\n| `/conductor:implement` | [implement.md](./commands/implement.md) | Execute tasks with TDD         |\n| `/conductor:status`    | [status.md](./commands/status.md)       | Display progress report        |\n| `/conductor:revert`    | [revert.md](./commands/revert.md)       | Git-aware rollback             |\n\n## Agents\n\n| Agent       | File                                      | Purpose                  |\n| ----------- | ----------------------------------------- | ------------------------ |\n| Planner     | [planner.md](./agents/planner.md)         | Generate specs and plans |\n| Implementer | [implementer.md](./agents/implementer.md) | Execute TDD workflow     |\n\n## Skills\n\n| Skill             | Directory                                         | Auto-Activates When           |\n| ----------------- | ------------------------------------------------- | ----------------------------- |\n| Context Awareness | [context-awareness/](./skills/context-awareness/) | `conductor/` directory exists |\n| TDD Workflow      | [tdd-workflow/](./skills/tdd-workflow/)           | Implementing features         |\n\n## Hooks\n\nSee [hooks.json](./hooks/hooks.json) for event-driven automations:\n\n- **SessionStart**: Show track count on session start\n- **PostToolUse**: Detect plan.md modifications\n- **PreToolUse**: Warn when modifying core configs\n- **Stop**: Remind about in-progress work\n\n## Usage\n\nTo use these examples:\n\n1. Copy the entire `examples/` structure to your plugin directory\n2. Rename to match plugin structure:\n   ```\n   examples/commands/ â†’ your-plugin/commands/\n   examples/agents/ â†’ your-plugin/agents/\n   examples/skills/ â†’ your-plugin/skills/\n   examples/hooks/ â†’ your-plugin/hooks/\n   ```\n3. Create plugin manifest (`.claude-plugin/plugin.json`)\n4. Install plugin in Claude Code\n\n## Key Patterns\n\n### Command Frontmatter\n\n```markdown\n---\ndescription: Brief description for help text\nargument-hint: [optional] [arguments]\nallowed-tools: Read, Write, Bash\nmodel: inherit\n---\n```\n\n### Agent Frontmatter\n\n```markdown\n---\nname: agent-name\ndescription: When to use this agent\ntools: Read, Write, Glob\nmodel: sonnet\n---\n```\n\n### Skill Frontmatter\n\n```yaml\n---\nname: skill-name\ndescription: Auto-discovery trigger conditions\nallowed-tools: Read, Glob\n---\n```\n\n### Hook Structure\n\n```json\n{\n  \"EventName\": [\n    {\n      \"matcher\": \"pattern\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"bash command\",\n          \"timeout\": 5\n        }\n      ]\n    }\n  ]\n}\n```\n",
        "reference/examples/agents/conductor-implementer.md": "---\nname: implementer\ndescription: Specialist for executing implementation tasks following TDD workflow. Use when implementing features, fixing bugs, or working through plan.md tasks.\ntools: Read, Write, Edit, Bash, Glob, Grep\nmodel: inherit\n---\n\n# Conductor Implementation Agent\n\nYou are the Conductor Implementation Agent, an expert at executing development tasks with discipline, quality, and adherence to TDD methodology.\n\n## Your Expertise\n\n1. **TDD Execution**: Red â†’ Green â†’ Refactor cycle mastery\n2. **Clean Code**: Writing maintainable, readable code\n3. **Git Discipline**: Atomic commits, clear messages\n4. **Quality Gates**: Coverage, linting, type safety\n5. **Progress Tracking**: Accurate plan.md updates\n\n## Context Loading\n\nBefore implementing, you MUST read:\n\n- `conductor/tracks/<track_id>/plan.md` - The implementation plan\n- `conductor/tracks/<track_id>/spec.md` - The requirements\n- `conductor/workflow.md` - The methodology to follow\n- `conductor/tech-stack.md` - Technologies in use\n- Relevant code styleguides from `conductor/code_styleguides/`\n\n## The TDD Cycle\n\n### 1. Red Phase: Write Failing Tests\n\n**Purpose**: Define expected behavior before implementation.\n\n```typescript\n// Example: Testing a new function\ndescribe('calculateDiscount', () => {\n  it('should return 0 for orders under $50', () => {\n    expect(calculateDiscount(49.99)).toBe(0);\n  });\n\n  it('should return 10% for orders $50-$99', () => {\n    expect(calculateDiscount(75)).toBe(7.5);\n  });\n\n  it('should return 20% for orders $100+', () => {\n    expect(calculateDiscount(100)).toBe(20);\n  });\n});\n```\n\n**Actions**:\n\n1. Create test file if it doesn't exist\n2. Write tests that capture requirements from spec.md\n3. Run tests: `npm test` or equivalent\n4. Verify tests FAIL (if they pass, the test is wrong)\n\n### 2. Green Phase: Implement Minimum Code\n\n**Purpose**: Make tests pass with the simplest solution.\n\n```typescript\n// Example: Minimum implementation\nfunction calculateDiscount(orderTotal: number): number {\n  if (orderTotal >= 100) return orderTotal * 0.2;\n  if (orderTotal >= 50) return orderTotal * 0.1;\n  return 0;\n}\n```\n\n**Rules**:\n\n- Write ONLY enough code to pass the failing test\n- No extra features\n- No premature optimization\n- No \"while I'm here\" additions\n\n**Actions**:\n\n1. Implement the feature\n2. Run tests: Verify PASS\n3. If tests fail, debug and fix\n\n### 3. Refactor Phase: Improve Quality\n\n**Purpose**: Clean up while maintaining behavior.\n\n```typescript\n// Example: Refactored version\nconst DISCOUNT_TIERS = [\n  { threshold: 100, rate: 0.2 },\n  { threshold: 50, rate: 0.1 },\n] as const;\n\nfunction calculateDiscount(orderTotal: number): number {\n  const tier = DISCOUNT_TIERS.find((t) => orderTotal >= t.threshold);\n  return tier ? orderTotal * tier.rate : 0;\n}\n```\n\n**Actions**:\n\n1. Identify improvement opportunities:\n   - Remove duplication\n   - Improve naming\n   - Simplify logic\n   - Extract functions\n2. Make ONE change at a time\n3. Run tests after EACH change\n4. All tests must stay green\n\n## Task Execution Protocol\n\nFor each task in plan.md:\n\n### Step 1: Mark In Progress\n\nEdit plan.md:\n\n```markdown\n- [~] Task: Implement discount calculation â† Changed from [ ]\n```\n\n### Step 2: Execute TDD Cycle\n\nFollow Red â†’ Green â†’ Refactor as described above.\n\n### Step 3: Verify Coverage\n\n```bash\n# Check coverage meets requirements\nnpx jest --coverage\n\n# Or for Python\npytest --cov=src --cov-report=term-missing\n```\n\nRequired: Coverage meets threshold from workflow.md (default >80%)\n\n### Step 4: Run Quality Checks\n\n```bash\n# Linting\nnpm run lint\n\n# Type checking\nnpm run typecheck\n\n# All checks\nnpm run check\n```\n\nAll must pass before proceeding.\n\n### Step 5: Commit Changes\n\n```bash\ngit add src/discount.ts src/discount.test.ts\ngit commit -m \"feat(pricing): Add discount calculation for orders\"\n```\n\n**Commit Message Format**:\n\n```\n<type>(<scope>): <description>\n\n[optional body]\n[optional footer]\n```\n\nTypes: feat, fix, refactor, test, docs, style, chore\n\n### Step 6: Attach Git Notes\n\n```bash\nSHA=$(git log -1 --format=\"%H\")\ngit notes add -m \"Task: Implement discount calculation\n\nSummary:\n- Added calculateDiscount function\n- Supports tiered discounts (10% for $50+, 20% for $100+)\n- 100% test coverage\n\nFiles:\n- src/discount.ts (new)\n- src/discount.test.ts (new)\" $SHA\n```\n\n### Step 7: Update Plan\n\nEdit plan.md:\n\n```markdown\n- [x] Task: Implement discount calculation [a1b2c3d] â† Added SHA\n```\n\n### Step 8: Commit Plan Update\n\n```bash\ngit add conductor/tracks/<track_id>/plan.md\ngit commit -m \"conductor(plan): Complete 'Implement discount calculation'\"\n```\n\n## Quality Gates\n\nBefore marking ANY task complete, verify:\n\n- [ ] All tests pass\n- [ ] Coverage meets requirements (>80%)\n- [ ] No linting errors\n- [ ] No type errors\n- [ ] Code follows styleguide\n- [ ] No security vulnerabilities introduced\n\n## When Blocked\n\nIf you encounter issues:\n\n1. **Document the Blocker**:\n\n   ```markdown\n   - [~] Task: Integrate payment API [BLOCKED]\n     - Waiting for API credentials\n   ```\n\n2. **Propose Solutions**:\n\n   - Can we mock the dependency?\n   - Is there alternative approach?\n   - What information is needed?\n\n3. **Ask for Guidance**:\n   Do NOT silently skip or mark incomplete work as done.\n\n## Anti-Patterns to Avoid\n\n1. **Writing tests after code**: Always test first\n2. **Big bang commits**: Keep commits atomic\n3. **Skipping refactor**: Technical debt accumulates\n4. **Ignoring coverage**: Untested code is broken code\n5. **Vague commit messages**: Future you will be confused\n6. **\"It works on my machine\"**: Run CI checks locally\n\n## Communication\n\nWhen working through tasks:\n\n- Announce which task you're starting\n- Report test results (pass/fail)\n- Mention any deviations from plan\n- Celebrate task completion (briefly)\n",
        "reference/examples/agents/conductor-planner.md": "---\nname: planner\ndescription: Specialist for generating specifications and implementation plans. Use when creating new tracks, writing specs, or breaking down features into tasks.\ntools: Read, Write, Glob, Grep\nmodel: inherit\n---\n\n# Conductor Planning Agent\n\nYou are the Conductor Planning Agent, an expert at translating product requirements into actionable specifications and implementation plans.\n\n## Your Expertise\n\n1. **Requirements Analysis**: Extract clear, testable requirements from vague descriptions\n2. **Specification Writing**: Create comprehensive spec.md documents\n3. **Task Decomposition**: Break features into phases, tasks, and sub-tasks\n4. **TDD Planning**: Structure tasks with test-first approach\n5. **Risk Identification**: Spot potential blockers and dependencies\n\n## Context Loading\n\nBefore generating any artifacts, you MUST read:\n\n- `conductor/product.md` - Understand the product vision\n- `conductor/tech-stack.md` - Know the technologies\n- `conductor/workflow.md` - Follow the methodology\n- `conductor/tracks.md` - Understand existing work\n\n## Generating Specifications (spec.md)\n\n### Structure\n\n```markdown\n# Specification: <Track Title>\n\n## Overview\n\nBrief description of what this track accomplishes and why.\n\n## Background\n\nContext that led to this track. Link to related tracks if applicable.\n\n## Functional Requirements\n\n### FR-1: <Requirement Name>\n\n- Description: What the system must do\n- Acceptance Criteria:\n  - [ ] Criterion 1\n  - [ ] Criterion 2\n- Priority: High/Medium/Low\n\n### FR-2: ...\n\n## Non-Functional Requirements\n\n### NFR-1: Performance\n\n- Response time < 200ms for API calls\n- Page load < 3 seconds\n\n### NFR-2: Security\n\n- All inputs validated\n- Authentication required for protected routes\n\n## User Stories\n\n### US-1: <Story Title>\n\nAs a <user type>,\nI want to <action>,\nSo that <benefit>.\n\n**Acceptance Criteria:**\n\n- Given <context>, when <action>, then <result>\n\n## Technical Considerations\n\n- Dependencies on other systems\n- Migration requirements\n- Breaking changes\n\n## Out of Scope\n\n- Features explicitly NOT included\n- Future considerations deferred\n\n## Open Questions\n\n- [ ] Question needing resolution before implementation\n```\n\n### Best Practices\n\n1. **Be Specific**: Vague requirements lead to vague implementations\n2. **Testable Criteria**: Every requirement should be verifiable\n3. **Prioritize**: Not everything is P0\n4. **Document Assumptions**: Make implicit knowledge explicit\n5. **Identify Dependencies**: What must exist before this can be built?\n\n## Generating Plans (plan.md)\n\n### Structure\n\n```markdown\n# Implementation Plan: <Track Title>\n\n## Phase 1: <Phase Name>\n\n### Overview\n\nBrief description of phase goals.\n\n### Tasks\n\n- [ ] Task 1.1: <Task Description>\n\n  - [ ] Write tests for <component>\n  - [ ] Implement <component>\n  - [ ] Update documentation\n\n- [ ] Task 1.2: <Task Description>\n\n  - [ ] Write tests for <feature>\n  - [ ] Implement <feature>\n\n- [ ] Conductor: User Manual Verification 'Phase 1'\n\n## Phase 2: <Phase Name>\n\n### Overview\n\n...\n\n### Tasks\n\n...\n\n## Phase 3: Integration & Polish\n\n### Tasks\n\n- [ ] Task 3.1: Integration testing\n- [ ] Task 3.2: Performance optimization\n- [ ] Task 3.3: Documentation updates\n- [ ] Conductor: User Manual Verification 'Phase 3'\n```\n\n### TDD Task Structure\n\nEvery implementation task MUST follow TDD:\n\n```markdown\n- [ ] Task: Implement user authentication\n  - [ ] Write failing tests for login flow\n  - [ ] Implement login endpoint\n  - [ ] Write failing tests for logout flow\n  - [ ] Implement logout endpoint\n  - [ ] Write failing tests for session management\n  - [ ] Implement session management\n```\n\n### Phase Verification Tasks\n\nEvery phase MUST end with:\n\n```markdown\n- [ ] Conductor: User Manual Verification '<Phase Name>'\n```\n\nThis triggers the verification protocol from workflow.md.\n\n### Best Practices\n\n1. **Sequential Order**: Tasks should be doable in order\n2. **Atomic Tasks**: Each task is a single, committable unit\n3. **Test First**: Always write tests before implementation\n4. **Reasonable Scope**: Tasks should take 15-60 minutes\n5. **Clear Dependencies**: If B depends on A, A comes first\n\n## Interactive Questioning\n\nWhen gathering requirements, follow this pattern:\n\n1. **Ask One Question at a Time**: Never batch questions\n2. **Provide Options**: Give 3 suggested answers\n3. **Allow Custom Input**: Always offer \"Type your own\"\n4. **Confirm Understanding**: Summarize before proceeding\n\nExample:\n\n```\nWhat is the primary goal of this feature?\n\nA) Improve user engagement by adding social features\nB) Reduce churn by improving onboarding\nC) Increase revenue through premium features\nD) Type your own answer\n\nPlease select an option.\n```\n\n## Quality Checklist\n\nBefore finalizing any spec or plan:\n\n- [ ] All requirements are testable\n- [ ] Acceptance criteria are specific\n- [ ] Tasks follow TDD structure\n- [ ] Phase verification tasks included\n- [ ] Dependencies are identified\n- [ ] Out of scope is documented\n- [ ] Aligns with tech-stack.md\n- [ ] Follows workflow.md methodology\n",
        "reference/examples/commands/implement.md": "---\ndescription: Execute tasks from the current track following TDD workflow\nargument-hint: [track-name]\nallowed-tools: Read, Write, Edit, Bash, Glob, Grep, Task\n---\n\n# Conductor Implement\n\nExecute the implementation workflow for the selected track.\n\n## Pre-flight Checks\n\n1. **Verify Conductor Setup**:\n   - Check for `conductor/tech-stack.md`\n   - Check for `conductor/workflow.md`\n   - Check for `conductor/product.md`\n   - If any missing: \"Conductor is not set up. Please run `/conductor:setup` first.\"\n\n2. **Check for tracks**:\n   - Parse `conductor/tracks.md`\n   - If empty or malformed: \"No tracks found. Create one with `/conductor:new-track`.\"\n\n## Track Selection\n\n### If track name provided ($ARGUMENTS)\n\n1. Search `conductor/tracks.md` for matching track description\n2. If found: \"Found track '<description>'. Is this correct?\"\n3. If not found: Suggest closest match or next available track\n\n### If no track name provided\n\n1. Find first incomplete track (`[ ]` or `[~]`)\n2. Announce: \"Selecting next incomplete track: '<description>'\"\n3. If no incomplete tracks: \"All tracks complete! Create a new one with `/conductor:new-track`.\"\n\n## Begin Implementation\n\n### Update Track Status\n\n1. Find track heading in `conductor/tracks.md`\n2. Change `## [ ] Track:` to `## [~] Track:`\n3. Commit: `conductor(track): Start track '<description>'`\n\n### Load Track Context\n\nRead into context:\n- `conductor/tracks/<track_id>/plan.md`\n- `conductor/tracks/<track_id>/spec.md`\n- `conductor/workflow.md`\n\n## Task Execution Loop\n\nFor each task in plan.md (in order):\n\n### Step 1: Mark Task In Progress\n\nEdit plan.md: Change `- [ ] Task:` to `- [~] Task:`\n\n### Step 2: TDD Red Phase\n\n1. Identify what needs to be tested\n2. Create or update test file\n3. Write failing test that defines expected behavior\n4. Run tests: Confirm FAILURE\n5. If tests pass prematurely, the test is wrong - fix it\n\n### Step 3: TDD Green Phase\n\n1. Write MINIMUM code to make test pass\n2. No extra features, no premature optimization\n3. Run tests: Confirm PASS\n4. If tests fail, debug and fix\n\n### Step 4: Refactor Phase\n\n1. With passing tests as safety net:\n   - Remove duplication\n   - Improve naming\n   - Simplify logic\n2. Run tests after each change\n3. All tests must stay green\n\n### Step 5: Verify Coverage\n\nRun coverage tool for the project:\n```bash\n# JavaScript/TypeScript\nnpx jest --coverage\n\n# Python\npytest --cov=src\n\n# Go\ngo test -cover ./...\n```\n\nTarget: Coverage meets workflow.md requirement (default >80%)\n\n### Step 6: Commit Code Changes\n\n```bash\ngit add <changed files>\ngit commit -m \"<type>(<scope>): <description>\"\n```\n\nTypes: feat, fix, refactor, test, docs, style, chore\n\n### Step 7: Attach Git Notes\n\nGet commit SHA and attach summary:\n```bash\nSHA=$(git log -1 --format=\"%H\")\ngit notes add -m \"Task: <task name>\nChanges: <summary>\nFiles: <list>\" $SHA\n```\n\n### Step 8: Update Plan\n\n1. Edit plan.md\n2. Change `- [~] Task:` to `- [x] Task: ... [<short-sha>]`\n3. Commit: `conductor(plan): Complete task '<task name>'`\n\n### Phase Completion Check\n\nWhen all tasks in a phase are complete:\n\n1. **Announce**: \"Phase '<name>' complete. Running verification protocol.\"\n\n2. **Ensure Coverage**:\n   - List files changed in this phase\n   - Verify each has corresponding tests\n   - Create missing tests if needed\n\n3. **Run Full Test Suite**:\n   - Announce command before running\n   - If failures, attempt fix (max 2 tries)\n   - If still failing, ask user for guidance\n\n4. **Generate Manual Verification Plan**:\n   Based on phase goals from spec.md, provide specific steps:\n   ```\n   Manual Verification Steps:\n   1. Start the development server: `npm run dev`\n   2. Open browser to: http://localhost:3000\n   3. Confirm you see: [expected result]\n   ```\n\n5. **Await User Confirmation**:\n   \"Does this meet your expectations? Please confirm or provide feedback.\"\n\n6. **Create Checkpoint**:\n   ```bash\n   git add .\n   git commit -m \"conductor(checkpoint): Complete phase '<name>'\"\n   ```\n\n7. **Attach Verification Report**:\n   ```bash\n   git notes add -m \"Phase: <name>\n   Automated Tests: PASSED\n   Manual Verification: CONFIRMED\n   Coverage: XX%\" $(git log -1 --format=\"%H\")\n   ```\n\n8. **Update Plan with Checkpoint SHA**:\n   Add `[checkpoint: <sha>]` to phase heading\n\n## Track Completion\n\nWhen all phases complete:\n\n1. **Update tracks.md**: Change `## [~] Track:` to `## [x] Track:`\n\n2. **Synchronize Documentation**:\n   - Review if product.md needs updates\n   - Review if tech-stack.md needs updates\n   - Propose changes, await approval before writing\n\n3. **Offer Cleanup**:\n   ```\n   Track '<description>' complete! Options:\n   A) Archive: Move to conductor/archive/\n   B) Delete: Permanently remove\n   C) Skip: Leave in tracks.md\n   ```\n\n4. **Announce Completion**:\n   \"Track complete! Run `/conductor:status` to see overall progress.\"\n",
        "reference/examples/commands/new-track.md": "---\ndescription: Create a new feature or bug track with spec and plan\nargument-hint: [description]\nallowed-tools: Read, Write, Glob, Task\n---\n\n# Conductor New Track\n\nCreate a new track (feature, bug, or chore) with specification and implementation plan.\n\n## Pre-flight Checks\n\n1. **Verify Conductor Setup**:\n\n   - Check for `conductor/tech-stack.md`\n   - Check for `conductor/workflow.md`\n   - Check for `conductor/product.md`\n   - If any missing: \"Conductor is not set up. Run `/conductor:setup` first.\"\n\n2. **Check for existing tracks**:\n   - Read `conductor/tracks.md`\n   - List existing track IDs to avoid duplicates\n\n## Get Track Description\n\n### If description provided ($ARGUMENTS)\n\nUse the provided description:\n\n```\nTrack description: $ARGUMENTS\n```\n\n### If no description provided\n\nAsk the user:\n\n> \"Please provide a brief description of the track (feature, bug fix, chore) you want to create.\"\n\nWait for response.\n\n## Determine Track Type\n\nAnalyze the description to infer type:\n\n- **Feature**: New functionality, \"add\", \"create\", \"implement\"\n- **Bug**: Fix, repair, \"fix\", \"broken\", \"error\"\n- **Chore**: Maintenance, \"update\", \"refactor\", \"clean\"\n\nDo NOT ask user to classify - infer from description.\n\n## Generate Specification (spec.md)\n\n### Interactive Questioning\n\nDelegate to planner agent or conduct inline:\n\n1. Announce: \"I'll ask a few questions to build a comprehensive specification.\"\n\n2. Ask 3-5 questions based on track type:\n\n**For Features:**\n\n- What problem does this solve?\n- Who is the target user?\n- What's the expected behavior?\n- Are there any constraints?\n- How should edge cases be handled?\n\n**For Bugs:**\n\n- What is the current (broken) behavior?\n- What is the expected behavior?\n- Steps to reproduce?\n\n**For Chores:**\n\n- What needs to be updated/changed?\n- What's the scope of the change?\n- Any dependencies affected?\n\n3. For each question:\n   - Provide 3 suggested options\n   - Include \"Type your own answer\"\n   - Wait for response before next question\n\n### Draft Specification\n\nGenerate spec.md with:\n\n- Overview\n- Functional Requirements (with acceptance criteria)\n- Non-Functional Requirements (if applicable)\n- User Stories (for features)\n- Technical Considerations\n- Out of Scope\n\n### Review Loop\n\nPresent draft:\n\n> \"I've drafted the specification. Please review:\"\n>\n> ```markdown\n> [spec.md content]\n> ```\n>\n> Does this capture the requirements correctly?\n> A) Approve and continue\n> B) Suggest changes\n\nIf B, incorporate feedback and re-present.\n\n## Generate Plan (plan.md)\n\n### Load Context\n\n- Read confirmed spec.md\n- Read `conductor/workflow.md` for methodology\n\n### Generate Plan\n\nCreate plan.md with:\n\n- Phases (logical groupings)\n- Tasks (actionable items)\n- Sub-tasks (TDD structure if specified in workflow)\n- Verification tasks at end of each phase\n\n### Structure Requirements\n\n1. **Follow workflow methodology** (e.g., TDD):\n\n   ```markdown\n   - [ ] Task: Implement user validation\n     - [ ] Write tests for email validation\n     - [ ] Implement email validation\n     - [ ] Write tests for password validation\n     - [ ] Implement password validation\n   ```\n\n2. **Include phase verification**:\n   ```markdown\n   - [ ] Conductor: User Manual Verification 'Phase 1'\n   ```\n\n### Review Loop\n\nPresent draft:\n\n> \"I've created the implementation plan. Please review:\"\n>\n> ```markdown\n> [plan.md content]\n> ```\n>\n> Does this plan cover all the necessary steps?\n> A) Approve and create track\n> B) Suggest changes\n\n## Create Track Artifacts\n\n### Generate Track ID\n\nFormat: `<shortname>_YYYYMMDD`\n\nExample: `user_auth_20241222`\n\n### Check for Duplicates\n\nIf track ID matches existing track:\n\n> \"A track with similar name already exists. Choose a different name.\"\n\n### Create Files\n\n1. **Create directory**:\n\n   ```\n   conductor/tracks/<track_id>/\n   ```\n\n2. **Write metadata.json**:\n\n   ```json\n   {\n     \"track_id\": \"<track_id>\",\n     \"type\": \"feature\",\n     \"status\": \"new\",\n     \"created_at\": \"<ISO timestamp>\",\n     \"updated_at\": \"<ISO timestamp>\",\n     \"description\": \"<user description>\"\n   }\n   ```\n\n3. **Write spec.md**:\n   The approved specification content.\n\n4. **Write plan.md**:\n   The approved plan content.\n\n### Update Tracks File\n\nAppend to `conductor/tracks.md`:\n\n```markdown\n---\n\n## [ ] Track: <Track Description>\n\n_Link: [./conductor/tracks/<track_id>/](./conductor/tracks/<track_id>/)_\n```\n\n## Completion\n\nAnnounce:\n\n> \"New track '<track_id>' has been created!\n>\n> Files created:\n>\n> - conductor/tracks/<track_id>/spec.md\n> - conductor/tracks/<track_id>/plan.md\n> - conductor/tracks/<track_id>/metadata.json\n>\n> The track has been added to conductor/tracks.md.\n>\n> Next steps:\n>\n> - Review the spec and plan in your editor\n> - Run `/conductor:implement` to start working\n> - Run `/conductor:status` to see all tracks\"\n",
        "reference/examples/commands/revert.md": "---\ndescription: Revert a track, phase, or task using git-aware rollback\nargument-hint: [track|phase|task] [name]\nallowed-tools: Read, Bash, Glob, Grep\n---\n\n# Conductor Revert\n\nGit-aware revert that understands logical units of work (tracks, phases, tasks).\n\n## Pre-flight Checks\n\n1. **Verify Conductor Setup**:\n   - Check for `conductor/tracks.md`\n   - If missing: \"Conductor not set up. Run `/conductor:setup` first.\"\n\n2. **Check Git Status**:\n   ```bash\n   git status --porcelain\n   ```\n   - If uncommitted changes: \"You have uncommitted changes. Please commit or stash before reverting.\"\n\n## Phase 1: Target Selection\n\n### If target provided ($ARGUMENTS)\n\nParse the argument:\n- `track <name>` â†’ Revert entire track\n- `phase <name>` â†’ Revert specific phase\n- `task <name>` â†’ Revert specific task\n\nSearch for matching item in tracks and plans.\n\n### If no target provided\n\n1. **Scan for revert candidates**:\n   - Read `conductor/tracks.md`\n   - Read all `conductor/tracks/*/plan.md`\n\n2. **Prioritize in-progress items**:\n   - Find all `[~]` marked tracks, phases, tasks\n\n3. **Fallback to recently completed**:\n   - If no in-progress items, show 5 most recent `[x]` items\n\n4. **Present menu**:\n   ```\n   I found the following items that can be reverted:\n\n   Track: user_auth_20241222\n     1) [Phase] Backend API [~]\n     2) [Task] Implement JWT validation [~]\n\n   Track: dashboard_ui_20241220\n     3) [Phase] Component Setup [x]\n     4) [Task] Create header component [x]\n\n   5) A different track, phase, or task\n\n   Which would you like to revert?\n   ```\n\n5. **Handle selection**:\n   - If 1-4: Confirm selection and proceed\n   - If 5: Ask for specific name/description\n\n### Confirm Target\n\n> \"You want to revert: [Phase] 'Backend API' from track 'user_auth_20241222'.\n> Is this correct?\n> A) Yes, proceed with analysis\n> B) No, select different target\"\n\n## Phase 2: Git Analysis\n\n### Identify Implementation Commits\n\n1. **Read the plan.md** for the target item\n2. **Extract commit SHAs** from completed tasks:\n   ```\n   - [x] Task: Implement JWT validation [a1b2c3d]\n   ```\n\n3. **Verify commits exist**:\n   ```bash\n   git cat-file -t <sha>\n   ```\n\n4. **Handle missing commits** (rewritten history):\n   > \"Commit a1b2c3d not found. It may have been rebased.\n   > Searching for similar commit...\"\n\n   Search by commit message:\n   ```bash\n   git log --oneline --all | grep \"Implement JWT\"\n   ```\n\n   Present candidate and ask for confirmation.\n\n### Identify Plan Update Commits\n\nFor each implementation commit, find the corresponding plan update:\n```bash\ngit log --oneline -- conductor/tracks/<id>/plan.md\n```\n\nLook for commits with messages like:\n- `conductor(plan): Complete 'Implement JWT validation'`\n- `conductor(checkpoint): Complete phase 'Backend API'`\n\n### For Track Reverts: Find Creation Commit\n\n```bash\ngit log --oneline -- conductor/tracks.md | grep \"Track: <description>\"\n```\n\n### Compile Final List\n\nCreate ordered list of all commits to revert:\n1. Most recent first\n2. Include both implementation and plan commits\n3. Note any merge commits that need special handling\n\n## Phase 3: Execution Plan\n\n### Present Summary\n\n```\nI have analyzed the git history. Here is the revert plan:\n\nTarget: Revert Phase 'Backend API'\n\nCommits to revert (newest first):\n  1. b2c3d4e - conductor(plan): Complete 'Add rate limiting'\n  2. a1b2c3d - feat(api): Add rate limiting to endpoints\n  3. 9f8e7d6 - conductor(plan): Complete 'Implement JWT validation'\n  4. 8e7d6c5 - feat(auth): Implement JWT validation\n\nAction: I will run `git revert --no-edit` on each commit in this order.\n\nDo you want to proceed?\nA) Yes, execute the revert\nB) No, cancel\n```\n\n### Warnings\n\nIf merge commits found:\n> \"WARNING: Commit <sha> is a merge commit. Reverting may be complex.\n> Consider manually reverting or using `git revert -m 1`.\"\n\nIf commits are very old:\n> \"Note: These commits are from <date>. There may be dependent code\n> that will break. Review carefully after revert.\"\n\n## Phase 4: Execution\n\n### Execute Reverts\n\nFor each commit (newest to oldest):\n```bash\ngit revert --no-edit <sha>\n```\n\n### Handle Conflicts\n\nIf conflict occurs:\n```\nConflict detected while reverting commit <sha>.\n\nThe conflicting files are:\n- src/auth/jwt.ts\n\nOptions:\nA) I'll show you the conflict for manual resolution\nB) Abort the revert entirely\n\nPlease choose how to proceed.\n```\n\nIf A:\n- Show the conflict markers\n- Wait for user to resolve\n- Continue with: `git add . && git revert --continue`\n\nIf B:\n- Run: `git revert --abort`\n- Announce: \"Revert aborted. Repository is back to previous state.\"\n\n### Verify Plan State\n\nAfter reverts complete:\n1. Read the affected plan.md\n2. Check if task/phase status matches reverted state\n3. If not, edit to fix:\n   - Change `[x]` back to `[ ]`\n   - Remove commit SHAs from task lines\n4. Commit the plan fix:\n   ```bash\n   git add conductor/tracks/<id>/plan.md\n   git commit -m \"conductor(plan): Reset status after revert\"\n   ```\n\n## Completion\n\n### Announce Success\n\n```\nRevert complete!\n\nSummary:\n- Reverted 4 commits\n- Reset phase 'Backend API' status to pending\n- Plan.md updated to reflect current state\n\nThe following changes were undone:\n- JWT validation implementation\n- Rate limiting implementation\n\nNext steps:\n- Run tests to ensure no regressions: npm test\n- Run /conductor:status to see updated progress\n- Run /conductor:implement to restart work on this phase\n```\n\n### If Partial Revert\n\n```\nPartial revert completed.\n\nSuccessfully reverted:\n- a1b2c3d - feat(auth): Implement JWT validation\n\nFailed to revert (conflicts):\n- b2c3d4e - feat(api): Add rate limiting\n\nThe conflicting commit was skipped. You may need to:\n1. Manually revert the remaining changes\n2. Or accept the partial revert\n\nRun `git status` to see current state.\n```\n",
        "reference/examples/commands/setup.md": "---\ndescription: Initialize Conductor environment for context-driven development\nargument-hint: [project-type]\nallowed-tools: Read, Write, Edit, Bash, Glob, Grep\n---\n\n# Conductor Setup\n\nYou are initializing the Conductor context-driven development environment. Follow this protocol precisely.\n\n## Pre-flight Check\n\n1. **Check for existing setup**:\n   - Look for `conductor/setup_state.json`\n   - If exists, read it and offer to resume from last successful step\n   - If `last_successful_step` is \"complete\", inform user setup is done\n\n2. **Check for conductor directory**:\n   - If `conductor/` exists without state file, warn about potential overwrite\n   - Ask user to confirm before proceeding\n\n## Phase 1: Project Discovery\n\n### 1.1 Detect Project Maturity\n\nClassify the project as **Brownfield** (existing) or **Greenfield** (new):\n\n**Brownfield Indicators** (check in order):\n1. `.git` directory exists\n2. `package.json`, `requirements.txt`, `go.mod`, `pom.xml` exists\n3. `src/`, `app/`, or `lib/` directories with code files\n\n**Greenfield**: None of the above found, directory empty or only has README.md\n\n### 1.2 Execute Based on Maturity\n\n**If Brownfield:**\n1. Announce: \"Existing project detected. I'll analyze it to understand the current state.\"\n2. Check git status - warn if uncommitted changes exist\n3. Analyze README.md if present\n4. Scan manifest files (package.json, etc.) respecting .gitignore\n5. Infer tech stack, architecture, and project goals\n6. Present findings for confirmation\n\n**If Greenfield:**\n1. Announce: \"New project detected. Let's set it up from scratch.\"\n2. Initialize git if no .git directory: `git init`\n3. Ask: \"What do you want to build?\"\n4. Create `conductor/` directory\n5. Write initial concept to `conductor/product.md`\n\n### 1.3 Initialize State\n\nCreate `conductor/setup_state.json`:\n```json\n{\n  \"last_successful_step\": \"\",\n  \"project_type\": \"<brownfield|greenfield>\",\n  \"created_at\": \"<ISO timestamp>\"\n}\n```\n\n## Phase 2: Context Generation\n\nFor each section, follow this pattern:\n1. Introduce the section\n2. Ask up to 5 sequential questions\n3. Provide 3 suggested options + \"Type your own\" + \"Auto-generate\"\n4. Draft content based on responses\n5. Present for approval (revise if needed)\n6. Write file\n7. Update state file\n\n### 2.1 Product Guide (`conductor/product.md`)\n\nQuestions to ask:\n- Who are the target users?\n- What problems does this solve?\n- What are the key features?\n- What does success look like?\n\nUpdate state: `{\"last_successful_step\": \"2.1_product_guide\"}`\n\n### 2.2 Product Guidelines (`conductor/product-guidelines.md`)\n\nQuestions to ask:\n- What's the brand voice/tone?\n- Are there design standards to follow?\n- What's the communication style?\n\nUpdate state: `{\"last_successful_step\": \"2.2_product_guidelines\"}`\n\n### 2.3 Tech Stack (`conductor/tech-stack.md`)\n\n**For Brownfield:** Present inferred stack, ask for confirmation\n**For Greenfield:** Ask about languages, frameworks, databases\n\nUpdate state: `{\"last_successful_step\": \"2.3_tech_stack\"}`\n\n### 2.4 Code Styleguides (`conductor/code_styleguides/`)\n\n**Purpose**: Copy language-specific style guides based on the project's tech stack.\n\n**Process**:\n1. Read `conductor/tech-stack.md` to detect languages\n2. Map detected languages to available styleguides:\n   - TypeScript/Node.js â†’ `typescript.md`\n   - Python â†’ `python.md`\n   - Go/Golang â†’ `go.md`\n   - JavaScript â†’ `javascript.md`\n   - HTML/CSS/Frontend â†’ `html-css.md`\n3. Present detected languages: \"Based on your tech stack, I'll include styleguides for: [list]\"\n4. Ask: \"Would you like to add styleguides for any other languages?\"\n   - Options: TypeScript, Python, Go, JavaScript, HTML/CSS (only show ones not already selected)\n   - Allow multiple selections\n5. Create `conductor/code_styleguides/` directory\n6. Copy selected styleguide files from `templates/code-styleguides/` to `conductor/code_styleguides/`\n7. Inform user: \"You can customize these styleguides by editing files in `conductor/code_styleguides/`\"\n\nUpdate state: `{\"last_successful_step\": \"2.4_code_styleguides\"}`\n\n### 2.5 Workflow (`conductor/workflow.md`)\n\nCopy default workflow template, then ask:\n1. Test coverage target? (default: 80%)\n2. Commit after each task or phase? (default: task)\n3. Use git notes for summaries? (default: yes)\n\nUpdate state: `{\"last_successful_step\": \"2.5_workflow\"}`\n\n## Phase 3: Initial Track\n\n### 3.1 Gather Requirements (Greenfield only)\n\nAsk about:\n- User stories\n- Functional requirements\n- Non-functional requirements\n\n### 3.2 Propose Initial Track\n\n**Greenfield:** Propose MVP track\n**Brownfield:** Propose enhancement or maintenance track\n\nPresent for approval.\n\n### 3.3 Create Track Artifacts\n\n1. Generate track ID: `<shortname>_YYYYMMDD`\n2. Create `conductor/tracks.md` with first track entry\n3. Create `conductor/tracks/<track_id>/`\n4. Generate and write `spec.md`\n5. Generate and write `plan.md` (following workflow methodology)\n6. Create `metadata.json`\n\nUpdate state: `{\"last_successful_step\": \"complete\"}`\n\n## Completion\n\n1. Commit all conductor files:\n   ```\n   git add conductor/\n   git commit -m \"conductor(setup): Initialize conductor environment\"\n   ```\n\n2. Announce completion:\n   > \"Setup complete! Your project now has:\n   > - Product context in conductor/product.md\n   > - Tech stack documented in conductor/tech-stack.md\n   > - Development workflow in conductor/workflow.md\n   > - First track ready in conductor/tracks/\n   >\n   > Next steps:\n   > - Run `/conductor:implement` to start working on the first track\n   > - Run `/conductor:new-track` to create additional tracks\n   > - Run `/conductor:status` to see project progress\"\n",
        "reference/examples/commands/status.md": "---\ndescription: Display current progress of Conductor-managed project\nallowed-tools: Read, Glob, Bash\n---\n\n# Conductor Status\n\nDisplay a comprehensive status overview of the project.\n\n## Pre-flight Check\n\n1. Verify `conductor/tracks.md` exists\n2. If missing: \"Conductor not set up. Run `/conductor:setup` to initialize.\"\n3. Verify file is not empty\n4. If empty: \"No tracks found. Create one with `/conductor:new-track`.\"\n\n## Gather Data\n\n### Read Project Context\n\n- `conductor/product.md` - Extract project name\n- `conductor/tracks.md` - Parse all tracks\n\n### Parse Each Track\n\nFor each track directory in `conductor/tracks/`:\n1. Read `plan.md`\n2. Count tasks by status:\n   - `[ ]` = Pending\n   - `[~]` = In Progress\n   - `[x]` = Completed\n3. Identify current phase and task\n\n## Generate Report\n\nFormat and display:\n\n```\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n  CONDUCTOR STATUS REPORT\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n  Project: <from product.md>\n  Generated: <current timestamp>\n\nTRACKS OVERVIEW\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Completed:   <count>  âœ…\n  In Progress: <count>  ðŸ”„\n  Pending:     <count>  â³\n\nCURRENT FOCUS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Track: <current track description>\n  Phase: <current phase name> [~]\n  Task:  <current task name> [~]\n\nPROGRESS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] 60%  (12/20 tasks)\n\nTRACK DETAILS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n  [x] Track: User Authentication\n      â””â”€â”€ 100% complete (8/8 tasks)\n\n  [~] Track: Dashboard UI\n      â”œâ”€â”€ Phase 1: Setup âœ… (3/3)\n      â”œâ”€â”€ Phase 2: Components ðŸ”„ (2/5)\n      â”‚   â”œâ”€â”€ [x] Create header component\n      â”‚   â”œâ”€â”€ [x] Create sidebar component\n      â”‚   â”œâ”€â”€ [~] Create main content area  â† CURRENT\n      â”‚   â”œâ”€â”€ [ ] Create footer component\n      â”‚   â””â”€â”€ [ ] Add responsive layout\n      â””â”€â”€ Phase 3: Integration â³ (0/4)\n\n  [ ] Track: API Integration\n      â””â”€â”€ Not started (0/12 tasks)\n\nNEXT ACTIONS\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  1. Complete: \"Create main content area\"\n  2. Then: \"Create footer component\"\n  3. After phase: Manual verification required\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n  Run /conductor:implement to continue working\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n```\n\n## Additional Information\n\n### If Blockers Exist\n\nIf any task is marked with \"BLOCKED\" in the plan:\n\n```\nâš ï¸  BLOCKERS DETECTED\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Task: \"Integrate payment API\"\n  Reason: Waiting for API credentials from vendor\n\n  Task: \"Deploy to production\"\n  Reason: Pending security review\n```\n\n### If All Complete\n\n```\nðŸŽ‰ ALL TRACKS COMPLETE!\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n  Total tracks completed: 5\n  Total tasks completed: 47\n\n  Create a new track with /conductor:new-track\n```\n\n### Summary Statistics\n\nAt the end, provide:\n- Total phases across all tracks\n- Total tasks across all tracks\n- Overall completion percentage\n- Estimated remaining work (based on average task time if available)\n",
        "reference/examples/hooks/hooks.json": "{\n  \"SessionStart\": [\n    {\n      \"matcher\": \"startup|resume\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"if [ -d conductor ] && [ -f conductor/tracks.md ]; then completed=$(grep -c '\\\\[x\\\\]' conductor/tracks.md 2>/dev/null || echo 0); in_progress=$(grep -c '\\\\[~\\\\]' conductor/tracks.md 2>/dev/null || echo 0); pending=$(grep -c '\\\\[ \\\\]' conductor/tracks.md 2>/dev/null || echo 0); echo \\\"{\\\\\\\"systemMessage\\\\\\\": \\\\\\\"Conductor: $completed complete, $in_progress in-progress, $pending pending tracks\\\\\\\"}\\\"; fi\",\n          \"timeout\": 5\n        }\n      ]\n    }\n  ],\n  \"PostToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"jq -r '.tool_input.file_path // empty' 2>/dev/null | { read fp; if [ -n \\\"$fp\\\" ] && echo \\\"$fp\\\" | grep -q 'conductor/tracks/.*/plan.md'; then track_id=$(echo \\\"$fp\\\" | sed 's|.*/conductor/tracks/\\\\([^/]*\\\\)/.*|\\\\1|'); echo \\\"Plan updated for track: $track_id\\\"; fi; }\",\n          \"timeout\": 5\n        }\n      ]\n    },\n    {\n      \"matcher\": \"Bash\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"jq -r '.tool_input.command // empty' 2>/dev/null | { read cmd; if echo \\\"$cmd\\\" | grep -q 'git commit'; then echo 'Git commit detected'; fi; }\",\n          \"timeout\": 5\n        }\n      ]\n    }\n  ],\n  \"Stop\": [\n    {\n      \"matcher\": \"*\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"if [ -f conductor/tracks.md ]; then in_progress=$(grep -c '\\\\[~\\\\]' conductor/tracks.md 2>/dev/null || echo 0); if [ \\\"$in_progress\\\" -gt 0 ]; then echo \\\"{\\\\\\\"systemMessage\\\\\\\": \\\\\\\"Reminder: $in_progress track(s) in progress. Run /conductor:status for details.\\\\\\\"}\\\"; fi; fi\",\n          \"timeout\": 5\n        }\n      ]\n    }\n  ],\n  \"PreToolUse\": [\n    {\n      \"matcher\": \"Write|Edit\",\n      \"hooks\": [\n        {\n          \"type\": \"command\",\n          \"command\": \"jq -r '.tool_input.file_path // empty' 2>/dev/null | { read fp; if [ -n \\\"$fp\\\" ]; then if echo \\\"$fp\\\" | grep -qE 'conductor/(product|tech-stack|workflow)\\\\.md$'; then echo \\\"{\\\\\\\"systemMessage\\\\\\\": \\\\\\\"Modifying core conductor config: $fp\\\\\\\"}\\\"; fi; fi; }\",\n          \"timeout\": 5\n        }\n      ]\n    }\n  ]\n}\n",
        "reference/examples/skills/context-awareness/SKILL.md": "---\nname: conductor-context\ndescription: Auto-load Conductor project context when conductor/ directory exists. Use for any development task in a Conductor-managed project to ensure alignment with product goals, tech stack, and workflow methodology.\nallowed-tools: Read, Glob\n---\n\n# Conductor Context Awareness\n\nThis skill provides automatic context loading for Conductor-managed projects.\n\n## When to Activate\n\nActivate this skill when:\n- A `conductor/` directory exists in the project\n- User is asking about implementation tasks\n- User is working on features or bugs\n- User mentions \"the plan\" or \"tracks\"\n\n## Context Files\n\nWhen detected, consider these files:\n\n### 1. Product Context (`conductor/product.md`)\n\nContains:\n- Product vision and goals\n- Target users\n- Key features\n- Success metrics\n\n**Use for**: Understanding WHAT we're building and WHY.\n\n### 2. Tech Stack (`conductor/tech-stack.md`)\n\nContains:\n- Programming languages\n- Frameworks\n- Databases\n- Key libraries\n- Architecture decisions\n\n**Use for**: Making technology choices consistent with project standards.\n\n### 3. Workflow (`conductor/workflow.md`)\n\nContains:\n- Development methodology (likely TDD)\n- Coverage requirements\n- Commit conventions\n- Quality gates\n\n**Use for**: Following the established development process.\n\n### 4. Tracks (`conductor/tracks.md`)\n\nContains:\n- List of all tracks (features/bugs)\n- Current status of each\n- Links to track details\n\n**Use for**: Understanding current work and priorities.\n\n### 5. Code Styleguides (`conductor/code_styleguides/`)\n\nContains:\n- Language-specific coding standards\n- Naming conventions\n- Best practices\n\n**Use for**: Writing code that matches project conventions.\n\n## Quick Reference\n\n### Before Starting Implementation\n\n1. Check `conductor/tracks.md` for current track\n2. Read the track's `spec.md` for requirements\n3. Read the track's `plan.md` for tasks\n4. Follow `conductor/workflow.md` methodology\n\n### During Implementation\n\n- Follow TDD if specified in workflow.md\n- Meet coverage targets from workflow.md\n- Use commit format from workflow.md\n- Apply styleguides from code_styleguides/\n\n### Key Context Points\n\n| Aspect | Where to Find |\n|--------|---------------|\n| Coverage target | workflow.md |\n| Commit format | workflow.md |\n| Test methodology | workflow.md |\n| Technology choices | tech-stack.md |\n| Coding style | code_styleguides/ |\n| Current focus | tracks.md |\n\n## Integration with Other Skills\n\nThis skill works with:\n- **tdd-workflow**: For test-driven development guidance\n- **code-styleguides**: For language-specific conventions\n\n## Common Patterns\n\n### Finding Current Task\n\n```bash\n# Find in-progress items\ngrep -r \"\\[~\\]\" conductor/tracks/*/plan.md\n```\n\n### Understanding Track Status\n\n```bash\n# Count by status\ngrep -c \"\\[ \\]\" conductor/tracks.md  # Pending\ngrep -c \"\\[~\\]\" conductor/tracks.md  # In Progress\ngrep -c \"\\[x\\]\" conductor/tracks.md  # Complete\n```\n\n### Loading Full Context\n\nRead in this order:\n1. `conductor/product.md` (the why)\n2. `conductor/tech-stack.md` (the how)\n3. `conductor/tracks.md` (the what)\n4. Current track's `spec.md` and `plan.md`\n",
        "reference/examples/skills/tdd-workflow/SKILL.md": "---\nname: tdd-workflow\ndescription: Test-Driven Development guidance. Use when writing code, implementing features, or fixing bugs in projects that follow TDD methodology. Provides the Red-Green-Refactor cycle structure.\n---\n\n# TDD Workflow Skill\n\nThis skill provides guidance for Test-Driven Development methodology.\n\n## The Core Cycle\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                                                 â”‚\nâ”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚\nâ”‚    â”‚  RED  â”‚ â”€â”€â–¶ â”‚ GREEN â”‚ â”€â”€â–¶ â”‚ REFACTOR â”‚   â”‚\nâ”‚    â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚\nâ”‚        â”‚                             â”‚         â”‚\nâ”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚\nâ”‚                                                 â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Phase 1: RED - Write a Failing Test\n\n### Purpose\nDefine the expected behavior BEFORE writing implementation.\n\n### Actions\n1. Create or open test file\n2. Write a test that describes ONE behavior\n3. Run the test\n4. Verify it FAILS (important!)\n\n### Example (TypeScript/Jest)\n\n```typescript\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    it('should create a user with valid email', async () => {\n      const user = await userService.createUser({\n        email: 'test@example.com',\n        name: 'Test User'\n      });\n\n      expect(user.id).toBeDefined();\n      expect(user.email).toBe('test@example.com');\n    });\n\n    it('should throw error for invalid email', async () => {\n      await expect(\n        userService.createUser({ email: 'invalid', name: 'Test' })\n      ).rejects.toThrow('Invalid email format');\n    });\n  });\n});\n```\n\n### Common Mistakes\n- Writing tests that pass immediately (means the test is wrong)\n- Testing implementation details instead of behavior\n- Writing too many tests before any implementation\n\n## Phase 2: GREEN - Make It Pass\n\n### Purpose\nWrite the MINIMUM code to make the test pass.\n\n### Actions\n1. Implement just enough to pass the failing test\n2. No extra features\n3. No optimization\n4. Run tests to verify PASS\n\n### Example\n\n```typescript\n// MINIMUM implementation to pass the tests above\nclass UserService {\n  async createUser(data: { email: string; name: string }) {\n    if (!data.email.includes('@')) {\n      throw new Error('Invalid email format');\n    }\n    return {\n      id: crypto.randomUUID(),\n      email: data.email,\n      name: data.name\n    };\n  }\n}\n```\n\n### Common Mistakes\n- Over-engineering on first pass\n- Adding features not covered by tests\n- \"While I'm here\" additions\n\n## Phase 3: REFACTOR - Improve Quality\n\n### Purpose\nClean up the code while keeping tests green.\n\n### Actions\n1. Look for improvements:\n   - Duplication\n   - Poor naming\n   - Complex logic\n   - Long functions\n2. Make ONE change\n3. Run tests\n4. If green, continue. If red, undo.\n\n### Example\n\n```typescript\n// REFACTORED version\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\nclass UserService {\n  async createUser(data: CreateUserInput): Promise<User> {\n    this.validateEmail(data.email);\n    return this.buildUser(data);\n  }\n\n  private validateEmail(email: string): void {\n    if (!EMAIL_REGEX.test(email)) {\n      throw new InvalidEmailError(email);\n    }\n  }\n\n  private buildUser(data: CreateUserInput): User {\n    return {\n      id: crypto.randomUUID(),\n      ...data,\n      createdAt: new Date()\n    };\n  }\n}\n```\n\n### Refactoring Checklist\n- [ ] Extract long methods\n- [ ] Rename unclear variables/functions\n- [ ] Remove duplication (DRY)\n- [ ] Simplify conditionals\n- [ ] Add type safety\n\n## Test Patterns\n\n### Arrange-Act-Assert (AAA)\n\n```typescript\nit('should calculate discount correctly', () => {\n  // Arrange\n  const cart = new Cart();\n  cart.addItem({ price: 100 });\n\n  // Act\n  const discount = cart.calculateDiscount();\n\n  // Assert\n  expect(discount).toBe(10);\n});\n```\n\n### Given-When-Then (BDD)\n\n```typescript\ndescribe('given a cart with items over $100', () => {\n  describe('when calculating discount', () => {\n    it('then should apply 10% discount', () => {\n      // ...\n    });\n  });\n});\n```\n\n## Coverage Commands\n\n### JavaScript/TypeScript\n\n```bash\n# Jest\nnpx jest --coverage\n\n# Vitest\nnpx vitest run --coverage\n```\n\n### Python\n\n```bash\npytest --cov=src --cov-report=html\n```\n\n### Go\n\n```bash\ngo test -cover ./...\ngo test -coverprofile=coverage.out ./...\n```\n\n## Anti-Patterns\n\n### 1. Test After\nWriting code first, tests second defeats the purpose.\n\n### 2. Testing Implementation\n```typescript\n// BAD: Testing HOW it works\nexpect(service.internalMethod).toHaveBeenCalled();\n\n// GOOD: Testing WHAT it does\nexpect(result).toEqual(expectedOutput);\n```\n\n### 3. Brittle Tests\n```typescript\n// BAD: Breaks if order changes\nexpect(users[0].name).toBe('Alice');\n\n// GOOD: Resilient assertion\nexpect(users).toContainEqual(expect.objectContaining({ name: 'Alice' }));\n```\n\n### 4. No Refactoring\nSkipping refactor phase leads to technical debt.\n\n## Quick Reference\n\n| Phase | Question to Answer | Action |\n|-------|-------------------|--------|\n| RED | What should it do? | Write failing test |\n| GREEN | Does it work? | Write minimal code |\n| REFACTOR | Is it clean? | Improve structure |\n\n## Integration\n\nThis skill works with:\n- **conductor-context**: For project-specific coverage targets\n- **code-styleguides**: For language-specific test patterns\n",
        "skills/code-styleguides/SKILL.md": "---\nname: code-styleguides\ndescription: Language-specific code style guidelines. Use when writing TypeScript, Python, Go, JavaScript, or HTML/CSS code to ensure consistent, idiomatic, and maintainable code following best practices.\nallowed-tools: Read, Glob\n---\n\n# Code Styleguides\n\nLanguage-specific coding standards and best practices.\n\n## How It Works\n\nReads project-level styleguides from `conductor/code_styleguides/` (copied during `/conductor:setup` based on tech stack).\n\n## Supported Languages\n\n| Language | Extensions | Styleguide File |\n|----------|------------|-----------------|\n| TypeScript | `.ts`, `.tsx`, `.mts`, `.cts` | `conductor/code_styleguides/typescript.md` |\n| Python | `.py`, `.pyi` | `conductor/code_styleguides/python.md` |\n| Go | `.go` | `conductor/code_styleguides/go.md` |\n| JavaScript | `.js`, `.jsx`, `.mjs`, `.cjs` | `conductor/code_styleguides/javascript.md` |\n| HTML/CSS | `.html`, `.css`, `.scss`, `.sass` | `conductor/code_styleguides/html-css.md` |\n\n## When to Activate\n\nWriting new code, reviewing code, refactoring, or setting up new files/modules.\n\n## Universal Principles\n\n| Aspect | Guideline |\n|--------|-----------|\n| **Naming** | Descriptive, meaningful; clarity over brevity; consistency |\n| **Structure** | Single responsibility; max 3-4 nesting levels; group related code |\n| **Documentation** | Document \"why\" not \"what\"; keep updated; docstrings for public APIs |\n| **Errors** | Handle explicitly; fail fast with clear messages; never swallow |\n| **Testing** | Write alongside code (TDD); test behavior not implementation; high coverage on critical paths |\n\n## Quick Reference\n\n| Setting | Recommendation |\n|---------|----------------|\n| Line length | 80-120 characters |\n| Indentation | 2 spaces (JS/TS), 4 spaces (Python), tabs (Go) |\n| Naming | Follow language conventions |\n| Imports | Organized and grouped |\n| Comments | Minimal, meaningful |\n\n## Setup\n\nIf styleguides missing:\n1. Run `/conductor:setup` to initialize\n2. Or copy from `templates/code-styleguides/` to `conductor/code_styleguides/`\n\nCheck: `ls conductor/code_styleguides/`\n\n## Integration\n\nWorks with: **conductor-context** (project overrides), **tdd-workflow** (language test patterns)\n",
        "skills/context-awareness/SKILL.md": "---\nname: conductor-context\ndescription: Auto-load Conductor project context when conductor/ directory exists. Use for any development task in a Conductor-managed project to ensure alignment with product goals, tech stack, and workflow methodology.\nallowed-tools: Read, Glob\n---\n\n# Conductor Context Awareness\n\nAutomatic context loading for Conductor-managed projects.\n\n## When to Activate\n\nWhen `conductor/` directory exists and user is: implementing tasks, working on features/bugs, or mentions \"plan\"/\"tracks\".\n\n## Context Files\n\n| File | Contains | Use For |\n|------|----------|---------|\n| `product.md` | Vision, goals, users, features, metrics | The WHY |\n| `tech-stack.md` | Languages, frameworks, DBs, libraries, architecture | The HOW |\n| `workflow.md` | Methodology (TDD), coverage, commits, quality gates | The PROCESS |\n| `tracks.md` | All tracks (features/bugs), status, priorities | The WHAT |\n| `code_styleguides/` | Language-specific standards, conventions, practices | The STYLE |\n\n## Workflow Reference\n\n| Need | Read |\n|------|------|\n| Coverage target | workflow.md |\n| Commit format | workflow.md |\n| Test methodology | workflow.md |\n| Technology choices | tech-stack.md |\n| Coding style | code_styleguides/ |\n| Current focus | tracks.md |\n\n## Loading Sequence\n\n**Before starting implementation:**\n1. Check `tracks.md` for current track\n2. Read track's `spec.md` for requirements\n3. Read track's `plan.md` for tasks\n4. Follow `workflow.md` methodology\n\n**Full context load order:**\n1. `product.md` (why)\n2. `tech-stack.md` (how)\n3. `tracks.md` (what)\n4. Track's `spec.md` and `plan.md`\n\n## Quick Commands\n\n```bash\n# Find in-progress items\ngrep -r \"\\[~\\]\" conductor/tracks/*/plan.md\n\n# Count by status\ngrep -c \"\\[ \\]\" conductor/tracks.md   # Pending\ngrep -c \"\\[~\\]\" conductor/tracks.md   # In progress\ngrep -c \"\\[x\\]\" conductor/tracks.md   # Complete\n```\n\n## Integration\n\nWorks with: **tdd-workflow** (TDD guidance), **code-styleguides** (language conventions)\n",
        "skills/tdd-workflow/SKILL.md": "---\nname: tdd-workflow\ndescription: Test-Driven Development guidance. Use when writing code, implementing features, or fixing bugs in projects that follow TDD methodology. Provides the Red-Green-Refactor cycle structure.\n---\n\n# TDD Workflow Skill\n\nGuidance for Test-Driven Development methodology.\n\n## The Core Cycle\n\n**RED â†’ GREEN â†’ REFACTOR** (repeat)\n\n| Phase | Purpose | Actions | Verify |\n|-------|---------|---------|--------|\n| **RED** | Define expected behavior | Write test for ONE behavior, run test | Test FAILS |\n| **GREEN** | Make it work | Write MINIMUM code to pass | Test PASSES |\n| **REFACTOR** | Make it clean | Improve ONE thing at a time, run tests after each change | Tests stay GREEN |\n\n## Phase 1: RED - Write Failing Test\n\n**Purpose:** Define behavior before implementation.\n\n**Actions:**\n1. Create/open test file\n2. Write test for ONE behavior\n3. Run test\n4. Verify FAILURE (if it passes, test is wrong)\n\n**Common mistakes:** Tests pass immediately, testing implementation not behavior, writing too many tests at once\n\n## Phase 2: GREEN - Make It Pass\n\n**Purpose:** Write MINIMUM code to pass test.\n\n**Actions:**\n1. Implement just enough to pass\n2. No extra features, no optimization\n3. Run tests, verify PASS\n\n**Common mistakes:** Over-engineering, adding untested features, \"while I'm here\" additions\n\n## Phase 3: REFACTOR - Improve Quality\n\n**Purpose:** Clean up while keeping tests green.\n\n**Actions:**\n1. Identify improvements: duplication, naming, complex logic, long functions\n2. Make ONE change\n3. Run tests\n4. If green, continue. If red, undo.\n\n**Checklist:** Extract methods, rename variables, remove duplication (DRY), simplify conditionals, add type safety\n\n## Test Patterns\n\n**Arrange-Act-Assert (AAA):**\n1. Arrange: Set up test data\n2. Act: Execute the behavior\n3. Assert: Verify result\n\n**Given-When-Then (BDD):** Structure nested describes for readability\n\n## Coverage Commands\n\n| Language | Command |\n|----------|---------|\n| JS/TS (Jest) | `npx jest --coverage` |\n| JS/TS (Vitest) | `npx vitest run --coverage` |\n| Python | `pytest --cov=src --cov-report=html` |\n| Go | `go test -cover ./...` |\n\n## Anti-Patterns to Avoid\n\n1. **Test After:** Writing code first defeats TDD purpose\n2. **Testing Implementation:** Test WHAT it does, not HOW (test behavior, not internal calls)\n3. **Brittle Tests:** Use resilient assertions (e.g., `toContainEqual` not array index checks)\n4. **No Refactoring:** Skipping refactor creates technical debt\n\n## Quick Reference\n\n- RED: \"What should it do?\" â†’ Write failing test\n- GREEN: \"Does it work?\" â†’ Write minimal code\n- REFACTOR: \"Is it clean?\" â†’ Improve structure\n\n**For detailed code examples**, see `examples.md` in this skill directory.\n\n## Integration\n\nWorks with:\n- **context-awareness**: Project-specific coverage targets\n- **code-styleguides**: Language-specific test patterns\n",
        "skills/tdd-workflow/examples.md": "# TDD Workflow - Code Examples\n\nDetailed examples for the Red-Green-Refactor cycle.\n\n## RED Phase Example\n\n```typescript\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    it('should create a user with valid email', async () => {\n      const user = await userService.createUser({\n        email: 'test@example.com',\n        name: 'Test User'\n      });\n\n      expect(user.id).toBeDefined();\n      expect(user.email).toBe('test@example.com');\n    });\n\n    it('should throw error for invalid email', async () => {\n      await expect(\n        userService.createUser({ email: 'invalid', name: 'Test' })\n      ).rejects.toThrow('Invalid email format');\n    });\n  });\n});\n```\n\n## GREEN Phase Example\n\n```typescript\n// MINIMUM implementation to pass tests\nclass UserService {\n  async createUser(data: { email: string; name: string }) {\n    if (!data.email.includes('@')) {\n      throw new Error('Invalid email format');\n    }\n    return {\n      id: crypto.randomUUID(),\n      email: data.email,\n      name: data.name\n    };\n  }\n}\n```\n\n## REFACTOR Phase Example\n\n```typescript\n// REFACTORED version\nconst EMAIL_REGEX = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n\nclass UserService {\n  async createUser(data: CreateUserInput): Promise<User> {\n    this.validateEmail(data.email);\n    return this.buildUser(data);\n  }\n\n  private validateEmail(email: string): void {\n    if (!EMAIL_REGEX.test(email)) {\n      throw new InvalidEmailError(email);\n    }\n  }\n\n  private buildUser(data: CreateUserInput): User {\n    return {\n      id: crypto.randomUUID(),\n      ...data,\n      createdAt: new Date()\n    };\n  }\n}\n```\n\n## Arrange-Act-Assert Pattern\n\n```typescript\nit('should calculate discount correctly', () => {\n  // Arrange\n  const cart = new Cart();\n  cart.addItem({ price: 100 });\n\n  // Act\n  const discount = cart.calculateDiscount();\n\n  // Assert\n  expect(discount).toBe(10);\n});\n```\n\n## Given-When-Then Pattern\n\n```typescript\ndescribe('given a cart with items over $100', () => {\n  describe('when calculating discount', () => {\n    it('then should apply 10% discount', () => {\n      const cart = new Cart();\n      cart.addItem({ price: 150 });\n\n      const discount = cart.calculateDiscount();\n\n      expect(discount).toBe(15);\n    });\n  });\n});\n```\n\n## Anti-Pattern Examples\n\n### BAD: Testing Implementation\n\n```typescript\n// Testing HOW (brittle, coupled to implementation)\nexpect(service.internalMethod).toHaveBeenCalled();\n```\n\n### GOOD: Testing Behavior\n\n```typescript\n// Testing WHAT (resilient, tests public contract)\nexpect(result).toEqual(expectedOutput);\n```\n\n### BAD: Brittle Assertions\n\n```typescript\n// Breaks if order changes\nexpect(users[0].name).toBe('Alice');\n```\n\n### GOOD: Resilient Assertions\n\n```typescript\n// Works regardless of order\nexpect(users).toContainEqual(expect.objectContaining({ name: 'Alice' }));\n```\n",
        "templates/README.md": "# Conductor Templates\n\nThis directory contains default templates used during `/conductor:setup`.\n\n## Available Templates\n\n### `workflow.md`\n\nThe default development workflow template that defines:\n\n- **Guiding Principles**: Core development philosophy (TDD, planning, coverage)\n- **Task Workflow**: 11-step task lifecycle with TDD cycles\n- **Phase Completion Protocol**: Verification and checkpointing process\n- **Quality Gates**: Pre-commit checklist\n- **Commit Guidelines**: Conventional commit format\n\n### `code-styleguides/`\n\nLanguage-specific code style guidelines that provide:\n\n- **Naming Conventions**: Language-specific naming patterns (camelCase, snake_case, etc.)\n- **Type Definitions**: Type annotation and definition patterns\n- **Function Patterns**: How to structure functions, parameters, and returns\n- **Error Handling**: Language-specific error handling best practices\n- **Module Organization**: Import/export patterns and file structure\n- **Testing Patterns**: Language-specific test patterns and examples\n\nAvailable styleguides:\n- `typescript.md` - TypeScript/TSX code style\n- `python.md` - Python code style\n- `go.md` - Go code style\n- `javascript.md` - JavaScript/JSX code style\n- `html-css.md` - HTML/CSS code style\n\n## How Templates Are Used\n\nDuring `/conductor:setup`:\n\n1. **Workflow**: The `workflow.md` template is copied to `conductor/workflow.md`\n2. **Code Styleguides**: Selected language styleguides are copied from `code-styleguides/` to `conductor/code_styleguides/`\n   - Languages are detected from the tech stack\n   - User can add additional languages if needed\n   - Only selected languages are copied (not all 5)\n3. **Customization**: User is prompted to customize settings (coverage target, commit strategy, etc.)\n4. **Tech-specific**: Language-specific settings are added based on detected tech stack\n\n## Customizing Templates\n\n### Project-Level Overrides\n\nAfter setup, you can edit conductor files directly:\n- **Workflow**: Edit `conductor/workflow.md` for project-specific workflow changes\n- **Styleguides**: Edit files in `conductor/code_styleguides/` for project-specific style rules\n\nChanges are tracked in git and apply only to your project.\n\n### Plugin-Level Customization\n\nTo customize the default templates for all projects:\n\n1. Fork/clone the conductor plugin\n2. Edit files in the `templates/` directory\n3. Use your customized plugin with `--plugin-dir`\n\n## Template Variables\n\nTemplates support these placeholders that are replaced during setup:\n\n| Variable | Description | Example |\n|----------|-------------|---------|\n| `{{project_name}}` | Name from product.md | \"My App\" |\n| `{{coverage_target}}` | User-selected coverage | \"80%\" |\n| `{{commit_strategy}}` | Per-task or per-phase | \"task\" |\n\n## Files NOT in Templates\n\nThe following files are **generated dynamically** during setup based on user Q&A, not copied from templates:\n\n- `product.md` - Product vision, goals, users (from interactive questions)\n- `product-guidelines.md` - Brand voice, design standards (from interactive questions)\n- `tech-stack.md` - Technologies, frameworks (from project detection + user input)\n- `tracks.md` - Master track list (created empty, populated by `/conductor:new-track`)\n"
      },
      "plugins": [
        {
          "name": "conductor",
          "description": "Context-Driven Development framework for Claude Code",
          "version": "1.2.0",
          "source": "./",
          "author": {
            "name": "Bryan Lackey"
          },
          "repository": "https://github.com/lackeyjb/claude-conductor",
          "license": "Apache-2.0",
          "keywords": [
            "context-driven",
            "development",
            "planning",
            "implementation"
          ],
          "category": "workflow",
          "categories": [
            "context-driven",
            "development",
            "implementation",
            "planning",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add lackeyjb/claude-conductor",
            "/plugin install conductor@conductor"
          ]
        }
      ]
    }
  ]
}