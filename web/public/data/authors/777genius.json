{
  "author": {
    "id": "777genius",
    "display_name": "Ğ˜Ğ»Ğ¸Ñ",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/13103045?u=7b8c77975cf33d0c2adc26c70af76bdad06dba73&v=4",
    "url": "https://github.com/777genius",
    "bio": null,
    "stats": {
      "total_marketplaces": 2,
      "total_plugins": 2,
      "total_commands": 3,
      "total_skills": 0,
      "total_stars": 216,
      "total_forks": 11
    }
  },
  "marketplaces": [
    {
      "name": "claude-notifications-go",
      "version": null,
      "description": "Smart notifications marketplace for Claude Code (Go implementation)",
      "owner_info": {
        "name": "777genius",
        "email": "[email protected]"
      },
      "keywords": [],
      "repo_full_name": "777genius/claude-notifications-go",
      "repo_url": "https://github.com/777genius/claude-notifications-go",
      "repo_description": "ğŸ”” Cross-platform smart notifications plugin for Claude Code. 6 different types. Instant. Analyze context. Zero dependencies. webhooks. Easy installation.",
      "homepage": "",
      "signals": {
        "stars": 215,
        "forks": 11,
        "pushed_at": "2026-01-28T12:16:31Z",
        "created_at": "2025-10-19T15:10:46Z",
        "license": "NOASSERTION"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 948
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 527
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 18213
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/notifications-init.md",
          "type": "blob",
          "size": 2416
        },
        {
          "path": "commands/notifications-settings.md",
          "type": "blob",
          "size": 27785
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/webhooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/webhooks/README.md",
          "type": "blob",
          "size": 3393
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 1095
        },
        {
          "path": "internal",
          "type": "tree",
          "size": null
        },
        {
          "path": "internal/errorhandler",
          "type": "tree",
          "size": null
        },
        {
          "path": "internal/errorhandler/README.md",
          "type": "blob",
          "size": 5113
        },
        {
          "path": "internal/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "internal/hooks/INTEGRATION_TESTS.md",
          "type": "blob",
          "size": 6208
        },
        {
          "path": "internal/hooks/hooks.go",
          "type": "blob",
          "size": 13845
        },
        {
          "path": "internal/hooks/hooks_test.go",
          "type": "blob",
          "size": 39198
        },
        {
          "path": "internal/hooks/integration_test.go",
          "type": "blob",
          "size": 18382
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n    \"name\": \"claude-notifications-go\",\n    \"owner\": {\n        \"name\": \"777genius\",\n        \"email\": \"[email protected]\"\n    },\n    \"metadata\": {\n        \"description\": \"Smart notifications marketplace for Claude Code (Go implementation)\",\n        \"version\": \"1.14.0\"\n    },\n    \"plugins\": [{\n        \"name\": \"claude-notifications-go\",\n        \"source\": \"./\",\n        \"description\": \"Smart notifications for Claude Code task statuses (Go implementation)\",\n        \"version\": \"1.14.0\",\n        \"author\": {\n            \"name\": \"777genius\",\n            \"email\": \"[email protected]\"\n        },\n        \"repository\": \"https://github.com/777genius/claude-notifications-go\",\n        \"license\": \"MIT\",\n        \"keywords\": [\n            \"notifications\",\n            \"alerts\",\n            \"productivity\",\n            \"go\",\n            \"hooks\"\n        ],\n        \"category\": \"productivity\",\n        \"tags\": [\"notifications\", \"hooks\", \"alerts\", \"go\"]\n    }]\n}",
        ".claude-plugin/plugin.json": "{\n    \"name\": \"claude-notifications-go\",\n    \"version\": \"1.14.0\",\n    \"description\": \"Smart notifications for Claude Code task statuses (Go implementation)\",\n    \"author\": {\n        \"name\": \"777genius\",\n        \"email\": \"[email protected]\"\n    },\n    \"license\": \"MIT\",\n    \"repository\": \"https://github.com/777genius/claude-notifications-go\",\n    \"keywords\": [\"notifications\", \"alerts\", \"productivity\", \"go\"],\n    \"commands\": [\n        \"./commands/notifications-init.md\",\n        \"./commands/notifications-settings.md\"\n    ]\n}\n",
        "README.md": "# Claude Notifications (plugin)\n\n[![Ubuntu CI](https://github.com/777genius/claude-notifications-go/workflows/Ubuntu%20CI/badge.svg)](https://github.com/777genius/claude-notifications-go/actions)\n[![macOS CI](https://github.com/777genius/claude-notifications-go/workflows/macOS%20CI/badge.svg)](https://github.com/777genius/claude-notifications-go/actions)\n[![Windows CI](https://github.com/777genius/claude-notifications-go/workflows/Windows%20CI/badge.svg)](https://github.com/777genius/claude-notifications-go/actions)\n[![Go Report Card](https://goreportcard.com/badge/github.com/777genius/claude-notifications-go)](https://goreportcard.com/report/github.com/777genius/claude-notifications-go)\n[![codecov](https://codecov.io/gh/777genius/claude-notifications-go/branch/main/graph/badge.svg)](https://codecov.io/gh/777genius/claude-notifications-go)\n\n<img width=\"250\" height=\"350\" alt=\"image\" src=\"https://github.com/user-attachments/assets/e7aa6d8e-5d28-48f7-bafe-ad696857b938\" />\n<img width=\"350\" height=\"239\" alt=\"image\" src=\"https://github.com/user-attachments/assets/42b7a306-f56f-4499-94cf-f3d573416b6d\" />\n<img width=\"220\" alt=\"image\" src=\"https://github.com/user-attachments/assets/4b5929d8-1a51-4a15-a3d5-dda5482554cc\" />\n\n\nSmart notifications for Claude Code with click-to-focus, git branch display, and webhook integrations.\n\n## Table of Contents\n\n  - [Supported Notification Types](#supported-notification-types)\n  - [Installation](#installation)\n    - [Prerequisites](#prerequisites)\n    - [Install from GitHub](#install-from-github)\n    - [Updating](#updating)\n  - [Features](#features)\n    - [ğŸ–¥ï¸ Cross-Platform Support](#ï¸-cross-platform-support)\n    - [ğŸ§  Smart Detection](#-smart-detection)\n    - [ğŸ”” Flexible Notifications](#-flexible-notifications)\n    - [ğŸ”Š Audio Customization](#-audio-customization)\n    - [ğŸŒ Enterprise-Grade Webhooks](#-enterprise-grade-webhooks)\n    - [ğŸ› ï¸ Developer Experience](#ï¸-developer-experience)\n    - [ğŸ¤ Plugin Compatibility](#-plugin-compatibility)\n  - [Platform Support](#platform-support)\n    - [macOS Click-to-Focus](#macos-click-to-focus)\n  - [Quick Start](#quick-start)\n    - [Interactive Setup (Recommended)](#interactive-setup-recommended)\n    - [Manual Configuration](#manual-configuration)\n    - [Sound Options](#sound-options)\n    - [Test Sound Playback](#test-sound-playback)\n  - [Architecture](#architecture)\n  - [Usage](#usage)\n  - [Development](#development)\n    - [Local installation for development](#local-installation-for-development)\n    - [Building binaries](#building-binaries)\n  - [Testing](#testing)\n  - [Documentation](#documentation)\n  - [License](#license)\n\n## Supported Notification Types\n\n| Status | Icon | Description | Trigger |\n|--------|------|-------------|---------|\n| Task Complete | âœ… | Main task completed | Stop/SubagentStop hooks (state machine detects active tools like Write/Edit/Bash, or ExitPlanMode followed by tool usage) |\n| Review Complete | ğŸ” | Code review finished | Stop/SubagentStop hooks (state machine detects only read-like tools: Read/Grep/Glob with no active tools, plus long text response >200 chars) |\n| Question | â“ | Claude has a question | PreToolUse hook (AskUserQuestion) OR Notification hook |\n| Plan Ready | ğŸ“‹ | Plan ready for approval | PreToolUse hook (ExitPlanMode) |\n| Session Limit Reached | â±ï¸ | Session limit reached | Stop/SubagentStop hooks (state machine detects \"Session limit reached\" text in last 3 assistant messages) |\n| API Error: 401 | ğŸ”´ | Authentication expired | Stop/SubagentStop hooks (state machine detects \"API Error: 401\" and \"Please run /login\" in last 3 assistant messages) |\n\n\n## Installation\n\n### Prerequisites\n\n- Claude Code (tested on v2.0.15)\n- **Windows users:** Git Bash (included with [Git for Windows](https://git-scm.com/download/win)) or WSL\n- **macOS/Linux users:** No additional software required\n\n### Install from GitHub\n\n```bash\n# 1) Add marketplace\n/plugin marketplace add 777genius/claude-notifications-go\n# 2) Install plugin\n/plugin install claude-notifications-go@claude-notifications-go\n# 3) Restart Claude Code\n# 4) Init\n/claude-notifications-go:notifications-init\n\n# Optional\n# Configure sounds and settings\n/claude-notifications-go:notifications-settings\n```\n\n**That's it!**\n\n1. `/claude-notifications-go:notifications-init` downloads the correct binary for your platform (macOS/Linux/Windows) from GitHub Releases\n2. `/claude-notifications-go:notifications-settings` guides you through sound configuration with an interactive wizard\n\nThe binary is downloaded once and cached locally. You can re-run `/claude-notifications-go:notifications-settings` anytime to reconfigure.\n\n### Updating\n\nTo update to the latest version:\n\n1. Run `/plugin`, select **Marketplaces**, choose `claude-notifications-go`, then select **Update marketplace**\n2. Select **Installed**, choose `claude-notifications-go`, then select **Update now**\n3. Run `/claude-notifications-go:notifications-init` to download new binaries\n4. Restart Claude Code to apply hook changes\n\nYour `config.json` settings will be preserved during the update.\n\n\n## Features\n\n### ğŸ–¥ï¸ Cross-Platform Support\n- **macOS** (Intel & Apple Silicon), **Linux** (x64 & ARM64), **Windows 10+** (x64)\n- Works in PowerShell, CMD, Git Bash, or WSL\n- Pre-built binaries included - no compilation needed\n\n### ğŸ§  Smart Detection\n- **Operations count** File edits, file creates, ran commans + total time\n- **State machine analysis** with temporal locality for accurate status detection\n- **6 notification types**: Task Complete, Review Complete, Question, Plan Ready, Session Limit, API Error\n- **PreToolUse integration** for instant alerts when Claude asks questions or creates plans\n- Analyzes conversation context to avoid false positives\n\n### ğŸ”” Flexible Notifications\n- **Desktop notifications** with custom icons and sounds\n- **Click-to-focus** (macOS): Click notification to activate your terminal window\n- **Git branch in title**: See current branch like `âœ… Completed [bold-cat] main`\n- **Webhook integrations**: Slack, Discord, Telegram, Lark/Feishu, and custom endpoints\n- **Session names**: Friendly identifiers like `[bold-cat]` for multi-session tracking\n- **Cooldown system** to prevent notification spam\n\n### ğŸ”Š Audio Customization\n- **Multi-format support**: MP3, WAV, FLAC, OGG, AIFF\n- **Volume control**: 0-100% customizable volume\n- **Audio device selection**: Route notifications to a specific output device (e.g., \"MacBook Pro-Lautsprecher\")\n- **Built-in sounds**: Professional notification sounds included\n- **System sounds**: Use macOS/Linux system sounds (optional)\n- **Sound preview**: Test sounds before choosing with `/claude-notifications-go:notifications-settings`\n\n### ğŸŒ Enterprise-Grade Webhooks\n- **Retry logic** with exponential backoff\n- **Circuit breaker** for fault tolerance\n- **Rate limiting** with token bucket algorithm\n- **Rich formatting** with platform-specific embeds/attachments\n- **Request tracing** and performance metrics\n- **â†’ [Complete Webhook Documentation](docs/webhooks/README.md)**\n\n### ğŸ› ï¸ Developer Experience\n- **Interactive setup wizards**: `/claude-notifications-go:notifications-init` for binary setup, `/claude-notifications-go:notifications-settings` for configuration\n- **JSONL streaming parser** for efficient large file processing\n- **Comprehensive testing**: Unit tests with race detection\n- **Two-phase lock deduplication** prevents duplicate notifications\n- **Structured logging** to `notification-debug.log` for troubleshooting\n\n**Notes:**\n- **PreToolUse hooks** trigger instantly when Claude is about to use ExitPlanMode or AskUserQuestion tools\n- **Stop/SubagentStop hooks** analyze the conversation transcript using a state machine to determine the task status\n- **Notification hook** is triggered when Claude needs user input (permission dialogs, questions)\n- The state machine uses temporal locality (last 15 messages) and tool analysis to accurately detect task completion\n\n### ğŸ¤ Plugin Compatibility\n\nCompatible with other Claude Code plugins that spawn background Claude instances:\n\n- **[double-shot-latte](https://github.com/obra/double-shot-latte)** - Auto-continue plugin that uses a background Claude instance for context evaluation. Notifications are automatically suppressed for the background judge process (via `CLAUDE_HOOK_JUDGE_MODE=true` environment variable).\n\nIf you're developing a plugin that spawns background Claude instances and want to suppress notifications, set `CLAUDE_HOOK_JUDGE_MODE=true` in the environment before invoking Claude.\n\n## Platform Support\n\n**Supported platforms:**\n- macOS (Intel & Apple Silicon)\n- Linux (x64 & ARM64)\n- Windows 10+ (x64)\n\n**No additional dependencies:**\n- âœ… Binaries auto-download from GitHub Releases\n- âœ… Pure Go - no C compiler needed\n- âœ… All libraries bundled\n- âœ… Works offline after first setup\n\n**Windows-specific features:**\n- Native Toast notifications (Windows 10+)\n- Works in PowerShell, CMD, Git Bash, or WSL\n- MP3/WAV/OGG/FLAC audio playback via native Windows APIs\n- System sounds not accessible - use built-in MP3s or custom files\n\n### macOS Click-to-Focus\n\nOn macOS, clicking a notification will activate your terminal window - no more hunting for the right window!\n\n**How it works:**\n- Automatically detects your terminal (iTerm2, Warp, Terminal.app, kitty, Ghostty, WezTerm, Alacritty)\n- Uses `terminal-notifier` (auto-installed via `/claude-notifications-go:notifications-init`)\n- Falls back to standard notifications if terminal-notifier is unavailable\n\n**Configuration** (in `config/config.json`):\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"clickToFocus\": true,\n      \"terminalBundleId\": \"\"\n    }\n  }\n}\n```\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `clickToFocus` | `true` | Enable click-to-focus on macOS |\n| `terminalBundleId` | `\"\"` | Override auto-detected terminal. Use bundle ID like `com.googlecode.iterm2` |\n\n**Supported terminals (auto-detected):**\n- Terminal.app, iTerm2, Warp, kitty, Ghostty, WezTerm, Alacritty, Hyper, VS Code\n\nTo find your terminal's bundle ID: `osascript -e 'id of app \"YourTerminal\"'`\n\n## Quick Start\n\n### Interactive Setup (Recommended)\n\nFirst, download the notification binary:\n\n```\n/claude-notifications-go:notifications-init\n```\n\nThen configure your notification sounds:\n\n```\n/claude-notifications-go:notifications-settings\n```\n\nThis will:\n- âœ… Show available built-in and system sounds\n- ğŸ”Š Let you preview sounds before choosing\n- ğŸ“ Create config.json with your preferences\n- âœ… Test your setup when complete\n\n**Features:**\n- Preview sounds: Type `\"play Glass\"` or `\"preview task-complete\"`\n- Choose from built-in MP3s or system sounds (macOS/Linux)\n- Configure webhooks (optional)\n- Interactive questions with AskUserQuestion tool\n\n### Manual Configuration\n\nAlternatively, edit `config/config.json` directly:\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"enabled\": true,\n      \"sound\": true,\n      \"volume\": 1.0,\n      \"audioDevice\": \"\",\n      \"appIcon\": \"${CLAUDE_PLUGIN_ROOT}/claude_icon.png\"\n    },\n    \"webhook\": {\n      \"enabled\": false,\n      \"preset\": \"slack\",\n      \"url\": \"https://hooks.slack.com/services/YOUR/WEBHOOK/URL\",\n      \"chat_id\": \"\",\n      \"format\": \"json\",\n      \"headers\": {}\n    },\n    \"suppressQuestionAfterTaskCompleteSeconds\": 12\n  },\n  \"statuses\": {\n    \"task_complete\": {\n      \"title\": \"âœ… Task Completed\",\n      \"sound\": \"${CLAUDE_PLUGIN_ROOT}/sounds/task-complete.mp3\",\n      \"keywords\": [\"completed\", \"done\", \"finished\"]\n    },\n    \"plan_ready\": {\n      \"title\": \"ğŸ“‹ Plan Ready for Review\",\n      \"sound\": \"${CLAUDE_PLUGIN_ROOT}/sounds/plan-ready.mp3\",\n      \"keywords\": [\"plan\", \"strategy\"]\n    },\n    \"question\": {\n      \"title\": \"â“ Claude Has Questions\",\n      \"sound\": \"${CLAUDE_PLUGIN_ROOT}/sounds/question.mp3\",\n      \"keywords\": [\"question\", \"clarify\"]\n    },\n    \"session_limit_reached\": {\n      \"title\": \"â±ï¸ Session Limit Reached\",\n      \"sound\": \"${CLAUDE_PLUGIN_ROOT}/sounds/question.mp3\"\n    }\n  }\n}\n```\n\n### Sound Options\n\n**Built-in sounds** (included):\n- `${CLAUDE_PLUGIN_ROOT}/sounds/task-complete.mp3`\n- `${CLAUDE_PLUGIN_ROOT}/sounds/review-complete.mp3`\n- `${CLAUDE_PLUGIN_ROOT}/sounds/question.mp3`\n- `${CLAUDE_PLUGIN_ROOT}/sounds/plan-ready.mp3`\n\n**System sounds:**\n- macOS: `/System/Library/Sounds/Glass.aiff`, `/System/Library/Sounds/Hero.aiff`, etc.\n- Linux: `/usr/share/sounds/**/*.ogg` (varies by distribution)\n- Windows: Use built-in MP3s (system sounds not easily accessible)\n\n**Supported formats:** MP3, WAV, FLAC, OGG/Vorbis, AIFF\n\n### Audio Device Selection\n\nRoute notification sounds to a specific audio output device instead of the system default:\n\n```bash\n# List available audio devices\nbin/list-devices\n\n# Output:\n#   0: MacBook Pro-Lautsprecher\n#   1: Babyface (23314790) (default)\n#   2: Immersed\n```\n\nThen add the device name to your `config.json`:\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"audioDevice\": \"MacBook Pro-Lautsprecher\"\n    }\n  }\n}\n```\n\nLeave `audioDevice` empty or omit it to use the system default device.\n\n### Test Sound Playback\n\nPreview any sound file with optional volume control:\n\n```bash\n# Test built-in sound (full volume)\nbin/sound-preview sounds/task-complete.mp3\n\n# Test with reduced volume (30% - recommended for testing)\nbin/sound-preview --volume 0.3 sounds/task-complete.mp3\n\n# Test macOS system sound at 30% volume\nbin/sound-preview --volume 0.3 /System/Library/Sounds/Glass.aiff\n\n# Test custom sound at 50% volume\nbin/sound-preview --volume 0.5 /path/to/your/sound.wav\n\n# Show all options\nbin/sound-preview --help\n```\n\n**Volume flag:** Use `--volume` to control playback volume (0.0 to 1.0). Default is 1.0 (full volume).\n\n\n## Architecture\n\n```text\ncmd/\n  claude-notifications/     # CLI entry point\n  sound-preview/            # Sound preview utility\n  list-devices/             # List available audio output devices\ninternal/\n  audio/                    # Audio playback with device selection (malgo)\n  config/                   # Configuration loading and validation\n  logging/                  # Structured logging to notification-debug.log\n  platform/                 # Cross-platform utilities (temp dirs, mtime, etc.)\n  analyzer/                 # JSONL parsing and state machine\n  state/                    # Per-session state and cooldown management\n  dedup/                    # Two-phase lock deduplication\n  notifier/                 # Desktop notifications and sound playback\n  webhook/                  # Webhook integrations (Slack/Discord/Telegram/Custom)\n  hooks/                    # Hook routing (PreToolUse/Stop/SubagentStop/Notification)\n  summary/                  # Message summarization and markdown cleanup\n  sessionname/              # Friendly session name generation ([bold-cat], etc.)\npkg/\n  jsonl/                    # JSONL streaming parser\ncommands/\n  notifications-init.md     # Binary download wizard\n  notifications-settings.md # Interactive settings configuration wizard\nsounds/                     # Custom notification sounds (MP3)\nclaude_icon.png             # Plugin icon for desktop notifications\n```\n\n## Usage\n\nThe plugin is invoked automatically by Claude Code hooks. You can also test manually:\n\n```bash\n# Test PreToolUse hook\necho '{\"session_id\":\"test\",\"transcript_path\":\"/path/to/transcript.jsonl\",\"tool_name\":\"ExitPlanMode\"}' | \\\n  claude-notifications handle-hook PreToolUse\n\n# Test Stop hook\necho '{\"session_id\":\"test\",\"transcript_path\":\"/path/to/transcript.jsonl\"}' | \\\n  claude-notifications handle-hook Stop\n```\n\n## Development\n\n### Local installation for development\n\n```bash\n# 1. Clone repository\ngit clone https://github.com/777genius/claude-notifications-go\ncd claude-notifications-go\n\n# 2. Build binary for your platform\nmake build\n\n# 3. Add as local marketplace\n/plugin marketplace add .\n\n# 4. Install plugin\n/plugin install claude-notifications-go@local-dev\n\n# 5. Restart Claude Code for hooks to take effect\n\n# 6. Download binary and configure settings\n/claude-notifications-go:notifications-init\n/claude-notifications-go:notifications-settings\n```\n\n**Note:** For local development, build the binary with `make build` first. The `/claude-notifications-go:notifications-init` command will use your locally built binary if it exists, otherwise it will download from GitHub Releases.\n\n### Building binaries\n\n```bash\n# Run tests\nmake test\n\n# Run tests with race detection\nmake test-race\n\n# Generate coverage report\nmake test-coverage\n\n# Build for all platforms\nmake build-all\n\n# Rebuild and prepare for commit\nmake rebuild-and-commit\n\n# Lint\nmake lint\n```\n\n**Note:** GitHub Actions automatically rebuilds binaries when Go code changes are pushed.\n\n## Testing\n\n```bash\n# Unit tests\ngo test ./internal/config -v\ngo test ./internal/analyzer -v\ngo test ./internal/dedup -v -race\n\n# Integration tests\ngo test ./test -v\n\n# Specific test\ngo test -run TestStateMachine ./internal/analyzer -v\n```\n\n## Documentation\n\n- **[Volume Control Guide](docs/volume-control.md)** - Customize notification volume\n  - Configure volume from 0% to 100%\n  - Logarithmic scaling for natural sound\n  - Per-environment recommendations\n\n- **[Interactive Sound Preview](docs/interactive-sound-preview.md)** - Preview sounds during setup\n  - Interactive sound selection\n  - Preview before choosing\n\n- **[Webhook Integration Guide](docs/webhooks/README.md)** - Complete guide for webhook setup\n  - **[Slack](docs/webhooks/slack.md)** - Slack integration with color-coded attachments\n  - **[Discord](docs/webhooks/discord.md)** - Discord integration with rich embeds\n  - **[Telegram](docs/webhooks/telegram.md)** - Telegram bot integration\n  - **[Lark/Feishu](docs/webhooks/lark.md)** - Lark/Feishu integration with interactive cards\n  - **[Custom Webhooks](docs/webhooks/custom.md)** - Any webhook-compatible service\n  - **[Configuration](docs/webhooks/configuration.md)** - Retry, circuit breaker, rate limiting\n  - **[Monitoring](docs/webhooks/monitoring.md)** - Metrics and debugging\n  - **[Troubleshooting](docs/webhooks/troubleshooting.md)** - Common issues and solutions\n\n## License\n\nGPL-3.0 - See [LICENSE](LICENSE) file for details.\n",
        "commands/notifications-init.md": "---\ndescription: Download notification binary for claude-notifications plugin\nallowed-tools: Bash\n---\n\n# ğŸ“¥ Initialize Claude Notifications Binary\n\nThis command downloads the notification binary for your platform (macOS, Linux, or Windows).\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Download Binary\n\nDownloading the notification binary for your platform...\n\n```bash\n# Get plugin root directory\nPLUGIN_ROOT=\"${CLAUDE_PLUGIN_ROOT}\"\nif [ -z \"$PLUGIN_ROOT\" ]; then\n  INSTALLED_PATH=\"$HOME/.claude/plugins/marketplaces/claude-notifications-go\"\n  if [ -d \"$INSTALLED_PATH\" ]; then\n    PLUGIN_ROOT=\"$INSTALLED_PATH\"\n  else\n    PLUGIN_ROOT=\"$(pwd)\"\n  fi\nfi\n\necho \"Plugin root: $PLUGIN_ROOT\"\necho \"\"\n\n# Always download the latest install.sh from GitHub to ensure we have newest version\nINSTALL_SCRIPT_URL=\"https://raw.githubusercontent.com/777genius/claude-notifications-go/main/bin/install.sh\"\n# Use portable temp directory (works on macOS, Linux, Windows Git Bash)\nTEMP_DIR=\"${TMPDIR:-${TEMP:-/tmp}}\"\nTEMP_INSTALL_SCRIPT=\"${TEMP_DIR}/claude-notifications-install-$$.sh\"\n\necho \"ğŸ“¥ Fetching latest installer from GitHub...\"\nif curl -fsSL \"$INSTALL_SCRIPT_URL\" -o \"$TEMP_INSTALL_SCRIPT\" 2>/dev/null; then\n  chmod +x \"$TEMP_INSTALL_SCRIPT\"\n  echo \"âœ“ Latest installer downloaded\"\n  echo \"\"\n\n  # Run with --force to always update binaries\n  # Set INSTALL_TARGET_DIR so install.sh knows where to put binaries\n  INSTALL_TARGET_DIR=\"${PLUGIN_ROOT}/bin\" bash \"$TEMP_INSTALL_SCRIPT\" --force\n  RESULT=$?\n\n  rm -f \"$TEMP_INSTALL_SCRIPT\"\n\n  if [ $RESULT -ne 0 ]; then\n    echo \"\"\n    echo \"âŒ Error: Installation failed\"\n    exit 1\n  fi\nelse\n  echo \"âš  Could not download latest installer, using cached version...\"\n  if ! bash \"${PLUGIN_ROOT}/bin/install.sh\" --force; then\n    echo \"\"\n    echo \"âŒ Error: Failed to install notification binary\"\n    exit 1\n  fi\nfi\n\necho \"\"\necho \"âœ… Binary installed successfully!\"\necho \"\"\necho \"Next steps:\"\necho \"  Run /claude-notifications-go:notifications-settings to configure sounds and notifications\"\n```\n\nThis will automatically download the correct binary for your platform from GitHub Releases. Running this command again will update all binaries to the latest version.\n\n**Supported platforms:**\n- macOS (Intel & Apple Silicon)\n- Linux (x64 & ARM64)\n- Windows (x64)\n",
        "commands/notifications-settings.md": "---\ndescription: Configure notification sounds and settings for claude-notifications plugin\nallowed-tools: Bash, AskUserQuestion, Write, Read\n---\n\n# ğŸµ Claude Notifications Settings\n\nWelcome! This interactive wizard will help you configure notification sounds for Claude Code.\n\nLet's make your Claude experience more delightful with custom audio notifications!\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## ğŸ¯ KEY FEATURE: Interactive Sound Preview\n\n**IMPORTANT FOR CLAUDE:**\n\nThis setup wizard is INTERACTIVE. Users can preview sounds at ANY time by saying:\n- \"play [sound_name]\"\n- \"preview [sound_name]\"\n- \"Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ°Ñ‚ÑŒ [sound_name]\" (Russian)\n- \"Ğ¿Ñ€Ğ¾Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ [sound_name]\" (Russian)\n\n**Your job:**\n1. Detect when user wants to preview a sound (keywords: play, preview, Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ°Ñ‚ÑŒ, Ğ¿Ñ€Ğ¾Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ)\n2. Extract the sound name from their message\n3. Run `${PLUGIN_ROOT}/bin/sound-preview <path>` to play it\n4. Ask if they want to hear more sounds\n5. When they're ready, proceed with AskUserQuestion selections\n\n**Flow:**\n- Step 1: Check binary installation (auto-install if missing)\n- Step 2: Detect system and list available sounds\n- Step 3: **INTERACTIVE PREVIEW PHASE** - let user explore sounds freely\n- Step 4: Ask 4 questions (Task/Review/Question/Plan) - remind about preview before each\n- Step 4.5: **Enable/Disable notification types** - let user choose which types to receive\n- Step 5: Volume configuration\n- Step 5.5: Audio device selection (optional)\n- Step 6: Webhook configuration\n- Step 7: Generate config.json\n- Step 8: Summary & test\n\n**Be patient and encouraging** - sound selection is personal!\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 1: Check Binary Installation\n\nFirst, let me verify the notification binary is installed:\n\n```bash\n# Get plugin root directory\n# Priority: 1) CLAUDE_PLUGIN_ROOT env var, 2) installed plugin location, 3) current directory\nPLUGIN_ROOT=\"${CLAUDE_PLUGIN_ROOT}\"\nif [ -z \"$PLUGIN_ROOT\" ]; then\n  # Try the standard installed plugin location\n  INSTALLED_PATH=\"$HOME/.claude/plugins/marketplaces/claude-notifications-go\"\n  if [ -d \"$INSTALLED_PATH\" ]; then\n    PLUGIN_ROOT=\"$INSTALLED_PATH\"\n  else\n    # Fallback to current directory (for development)\n    PLUGIN_ROOT=\"$(pwd)\"\n  fi\nfi\n\necho \"Plugin root: $PLUGIN_ROOT\"\necho \"\"\n\n# Check if binary exists (platform-agnostic check)\nBINARY_EXISTS=false\nif [ -f \"${PLUGIN_ROOT}/bin/claude-notifications\" ] || \\\n   [ -f \"${PLUGIN_ROOT}/bin/claude-notifications-darwin-amd64\" ] || \\\n   [ -f \"${PLUGIN_ROOT}/bin/claude-notifications-darwin-arm64\" ] || \\\n   [ -f \"${PLUGIN_ROOT}/bin/claude-notifications-linux-amd64\" ] || \\\n   [ -f \"${PLUGIN_ROOT}/bin/claude-notifications-windows-amd64.exe\" ]; then\n  BINARY_EXISTS=true\nfi\n\nif [ \"$BINARY_EXISTS\" = \"false\" ]; then\n  echo \"âš ï¸  Notification binary not found. Installing...\"\n  echo \"\"\n  if ! \"${PLUGIN_ROOT}/bin/install.sh\"; then\n    echo \"\"\n    echo \"âŒ Error: Failed to install notification binary\"\n    echo \"Please run /claude-notifications-go:notifications-init or check your internet connection\"\n    exit 1\n  fi\n  echo \"\"\n  echo \"âœ… Binary installed successfully!\"\n  echo \"\"\nelse\n  echo \"âœ… Notification binary is already installed\"\n  echo \"\"\nfi\n```\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 2: Discover Available Sounds\n\nNow let me detect what sound options are available on your system!\n\n```bash\n# Get plugin root (re-declare for this bash session)\nPLUGIN_ROOT=\"${CLAUDE_PLUGIN_ROOT}\"\nif [ -z \"$PLUGIN_ROOT\" ]; then\n  INSTALLED_PATH=\"$HOME/.claude/plugins/marketplaces/claude-notifications-go\"\n  if [ -d \"$INSTALLED_PATH\" ]; then\n    PLUGIN_ROOT=\"$INSTALLED_PATH\"\n  else\n    PLUGIN_ROOT=\"$(pwd)\"\n  fi\nfi\n\n# Detect Operating System\nOS_TYPE=$(uname -s)\ncase \"$OS_TYPE\" in\n  Darwin*)\n    echo \"Operating System: macOS\"\n    HAS_SYSTEM_SOUNDS=\"true\"\n    SYSTEM_SOUNDS_DIR=\"/System/Library/Sounds\"\n    ;;\n  Linux*)\n    echo \"Operating System: Linux\"\n    if [ -d \"/usr/share/sounds\" ]; then\n      HAS_SYSTEM_SOUNDS=\"true\"\n      SYSTEM_SOUNDS_DIR=\"/usr/share/sounds\"\n    else\n      HAS_SYSTEM_SOUNDS=\"false\"\n    fi\n    ;;\n  MINGW*|MSYS*|CYGWIN*)\n    echo \"Operating System: Windows\"\n    HAS_SYSTEM_SOUNDS=\"false\"\n    ;;\n  *)\n    echo \"Operating System: Unknown\"\n    HAS_SYSTEM_SOUNDS=\"false\"\n    ;;\nesac\n\n# Built-in Sounds\necho \"\"\necho \"Built-in sounds (included with plugin):\"\nif [ -d \"${PLUGIN_ROOT}/sounds\" ]; then\n  ls -1 \"${PLUGIN_ROOT}/sounds/\"*.mp3 2>/dev/null | while read file; do\n    name=$(basename \"$file\" .mp3)\n    echo \"  âœ“ $name.mp3\"\n  done\nelse\n  echo \"  Warning: sounds/ directory not found!\"\nfi\n\n# System Sounds\nif [ \"$HAS_SYSTEM_SOUNDS\" = \"true\" ]; then\n  echo \"\"\n  echo \"System sounds detected at: $SYSTEM_SOUNDS_DIR\"\n\n  case \"$OS_TYPE\" in\n    Darwin*)\n      # macOS system sounds\n      echo \"Available macOS system sounds:\"\n      ls -1 /System/Library/Sounds/*.aiff 2>/dev/null | while read file; do\n        name=$(basename \"$file\" .aiff)\n        echo \"  â€¢ $name\"\n      done\n      ;;\n    Linux*)\n      # Linux system sounds (varies by distribution)\n      echo \"Available Linux system sounds (sample):\"\n      find /usr/share/sounds -type f \\( -name \"*.ogg\" -o -name \"*.wav\" \\) 2>/dev/null | head -10 | while read file; do\n        name=$(basename \"$file\")\n        echo \"  â€¢ $name\"\n      done\n      ;;\n  esac\nelse\n  echo \"\"\n  echo \"âš ï¸  No system sounds detected on this platform.\"\n  echo \"   Don't worry! You can use the built-in MP3 sounds included with the plugin.\"\n  echo \"   They work perfectly on all platforms!\"\nfi\n```\n\n**Always available:**\n- âœ… **task-complete.mp3** - Triumphant completion chime\n- âœ… **review-complete.mp3** - Gentle notification tone\n- âœ… **question.mp3** - Attention-grabbing sound\n- âœ… **plan-ready.mp3** - Professional planning tone\n\n**macOS system sounds** (if detected):\n- **Glass** - Crisp, clean chime âœ¨\n- **Ping** - Subtle ping sound ğŸ“\n- **Pop** - Quick pop sound ğŸˆ\n- **Purr** - Gentle purr ğŸ±\n- **Funk** - Distinctive funk groove ğŸµ\n- **Hero** - Triumphant fanfare ğŸ¦¸\n- **Sosumi** - Pleasant notification ğŸ””\n- **Basso** - Deep bass sound ğŸ»\n- **Blow** - Breeze-like whoosh ğŸ’¨\n- **Frog** - Unique ribbit sound ğŸ¸\n- **Submarine** - Sonar-like ping ğŸŒŠ\n- **Bottle** - Cork pop sound ğŸ¾\n- **Morse** - Morse code beeps âš¡\n- **Tink** - Light metallic sound âœ¨\n\n**Linux system sounds** (if detected):\n- Location varies by distribution (Ubuntu, Fedora, etc.)\n- Typically in `/usr/share/sounds/`\n- Formats: .ogg, .wav files\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 3: Interactive Sound Preview ğŸ”Š\n\n**CRITICAL INSTRUCTION FOR CLAUDE:**\n\nBefore asking the user to make final choices, you MUST offer to play sounds for them.\n\nTell the user:\n\n> ğŸµ **Want to hear sounds before choosing?**\n> I can play any sound for you! Just say:\n> - `\"play task-complete\"` - Built-in task-complete sound\n> - `\"play Glass\"` - macOS Glass system sound\n> - `\"preview Hero\"` - Preview any available sound\n>\n> Try as many as you like! When you're ready, I'll ask you to select sounds for each notification type.\n\n**How to handle preview requests:**\n\nWhen user says \"play [sound_name]\", \"preview [sound_name]\", \"Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ°Ñ‚ÑŒ [sound_name]\", or \"Ğ¿Ñ€Ğ¾Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ [sound_name]\":\n\n1. **Extract sound name** from user message (ignore the command word, keep only the sound name)\n\n2. **Determine the full path** to the sound file:\n   ```bash\n   # Get plugin root\n   PLUGIN_ROOT=\"${CLAUDE_PLUGIN_ROOT}\"\n   if [ -z \"$PLUGIN_ROOT\" ]; then\n     INSTALLED_PATH=\"$HOME/.claude/plugins/marketplaces/claude-notifications-go\"\n     if [ -d \"$INSTALLED_PATH\" ]; then\n       PLUGIN_ROOT=\"$INSTALLED_PATH\"\n     else\n       PLUGIN_ROOT=\"$(pwd)\"\n     fi\n   fi\n\n   # For built-in sounds (no extension needed)\n   if [[ \"$sound_name\" == \"task-complete\" ]] || [[ \"$sound_name\" == \"review-complete\" ]] || [[ \"$sound_name\" == \"question\" ]] || [[ \"$sound_name\" == \"plan-ready\" ]]; then\n     SOUND_PATH=\"${PLUGIN_ROOT}/sounds/${sound_name}.mp3\"\n\n   # For macOS system sounds\n   elif [[ -f \"/System/Library/Sounds/${sound_name}.aiff\" ]]; then\n     SOUND_PATH=\"/System/Library/Sounds/${sound_name}.aiff\"\n\n   # Try common variations\n   elif [[ -f \"/System/Library/Sounds/${sound_name}.mp3\" ]]; then\n     SOUND_PATH=\"/System/Library/Sounds/${sound_name}.mp3\"\n\n   else\n     echo \"âŒ Sound '${sound_name}' not found. Available options listed above.\"\n     exit 1\n   fi\n   ```\n\n2. **Play the sound** using the sound-preview utility with reduced volume:\n   ```bash\n   # Get plugin root\n   PLUGIN_ROOT=\"${CLAUDE_PLUGIN_ROOT}\"\n   if [ -z \"$PLUGIN_ROOT\" ]; then\n     INSTALLED_PATH=\"$HOME/.claude/plugins/marketplaces/claude-notifications-go\"\n     if [ -d \"$INSTALLED_PATH\" ]; then\n       PLUGIN_ROOT=\"$INSTALLED_PATH\"\n     else\n       PLUGIN_ROOT=\"$(pwd)\"\n     fi\n   fi\n\n   echo \"ğŸ”Š Playing: ${sound_name}... (volume: 30%)\"\n   \"${PLUGIN_ROOT}/bin/sound-preview\" --volume 0.3 \"$SOUND_PATH\"\n   echo \"âœ“ Playback complete!\"\n   ```\n\n   **IMPORTANT:** Always use `--volume 0.3` (30% volume) when previewing sounds during setup to avoid disturbing the user with loud sounds.\n\n3. **Ask if they want to hear more**:\n   > Would you like to:\n   > - Hear another sound? (just type \"play [name]\")\n   > - Ready to make your selections? (type \"ready\")\n\n**Examples of user interactions:**\n\n```\nUser: play Glass\nClaude: [runs bin/sound-preview --volume 0.3 /System/Library/Sounds/Glass.aiff]\nClaude: \"ğŸ”Š Playing: Glass... (volume: 30%) âœ“ Playback complete! Would you like to hear another sound, or ready to choose?\"\n\nUser: preview task-complete\nClaude: [runs bin/sound-preview --volume 0.3 sounds/task-complete.mp3]\nClaude: \"ğŸ”Š Playing: task-complete... (volume: 30%) âœ“ Playback complete!\"\n\nUser: Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ°Ñ‚ÑŒ Hero\nClaude: [runs bin/sound-preview --volume 0.3 /System/Library/Sounds/Hero.aiff]\nClaude: \"ğŸ”Š Playing: Hero... (volume: 30%) âœ“ Playback complete!\"\n\nUser: Ğ¿Ñ€Ğ¾Ğ¸Ğ³Ñ€Ğ°Ñ‚ÑŒ Ping\nClaude: [runs bin/sound-preview --volume 0.3 /System/Library/Sounds/Ping.aiff]\nClaude: \"ğŸ”Š Playing: Ping... (volume: 30%) âœ“ Playback complete!\"\n\nUser: ready\nClaude: \"Great! Let's configure your notification sounds...\"\n[proceeds to Questions 1-4]\n```\n\n**Edge cases:**\n\n```\nUser: play unknown-sound\nClaude: \"âŒ Sound 'unknown-sound' not found. Available sounds are:\n  Built-in: task-complete, review-complete, question, plan-ready\n  System (macOS): Glass, Hero, Funk, Sosumi, Ping, Purr, Basso, etc.\nTry: 'play Glass' or 'preview task-complete'\"\n\nUser: I want Glass for everything\nClaude: \"Great choice! Let me confirm - you want Glass for all notification types?\nOr would you like to choose different sounds for each type?\n(You can still preview other sounds if you'd like)\"\n```\n\n**IMPORTANT:**\n- Allow users to preview AS MANY sounds as they want before making selections\n- Be patient and encouraging - sound selection is personal!\n- If a sound name isn't recognized, show the available sounds list again\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 4: Interactive Configuration\n\nNow let's configure your notification sounds! I'll ask you 4 questions - one for each notification type.\n\n**IMPORTANT:** Build the options list dynamically based on what's available:\n\n```bash\n# Build options array based on OS and available sounds\nOPTIONS=\"\"\n\n# Always include built-in sounds (available on all platforms)\nOPTIONS=\"${OPTIONS}Built-in: task-complete.mp3|Triumphant completion chime (recommended)\\n\"\nOPTIONS=\"${OPTIONS}Built-in: review-complete.mp3|Gentle notification tone\\n\"\nOPTIONS=\"${OPTIONS}Built-in: question.mp3|Attention sound\\n\"\nOPTIONS=\"${OPTIONS}Built-in: plan-ready.mp3|Professional tone\\n\"\n\n# Add system sounds if available\nif [ \"$HAS_SYSTEM_SOUNDS\" = \"true\" ] && [ \"$OS_TYPE\" = \"Darwin\"* ]; then\n  # macOS system sounds\n  OPTIONS=\"${OPTIONS}System: Glass|Crisp macOS Glass sound\\n\"\n  OPTIONS=\"${OPTIONS}System: Hero|Triumphant fanfare\\n\"\n  OPTIONS=\"${OPTIONS}System: Funk|Distinctive funk groove\\n\"\n  OPTIONS=\"${OPTIONS}System: Sosumi|Pleasant macOS notification\\n\"\n  OPTIONS=\"${OPTIONS}System: Ping|Subtle ping sound\\n\"\n  OPTIONS=\"${OPTIONS}System: Purr|Gentle purr\\n\"\nfi\n\necho \"Available sound options built: $(echo -e \"$OPTIONS\" | wc -l) options\"\n```\n\n### Question 1: Task Complete Sound âœ…\n\n**Before presenting the question**, remind the user:\n\n> ğŸµ **Reminder:** You can still preview sounds! Just say \"play [sound_name]\" before making your choice.\n\nWhen Claude finishes a task, which sound would you like to hear?\n\nUse AskUserQuestion with dynamically generated options:\n\n**If macOS with system sounds:**\n- question: \"Which sound for Task Complete notifications?\"\n- header: \"âœ… Task Complete\"\n- multiSelect: false\n- options:\n  1. **Built-in: task-complete.mp3** - \"Triumphant completion chime (recommended)\"\n  2. **Built-in: review-complete.mp3** - \"Gentle notification tone\"\n  3. **Built-in: question.mp3** - \"Attention sound\"\n  4. **Built-in: plan-ready.mp3** - \"Professional tone\"\n  5. **System: Glass** - \"Crisp macOS Glass sound\"\n  6. **System: Hero** - \"Triumphant fanfare\"\n  7. **System: Funk** - \"Distinctive funk groove\"\n  8. **System: Sosumi** - \"Pleasant macOS notification\"\n\n**If Linux/Windows (no system sounds):**\n- question: \"Which sound for Task Complete notifications?\"\n- header: \"âœ… Task Complete\"\n- multiSelect: false\n- options:\n  1. **task-complete.mp3** - \"Triumphant completion chime (recommended)\"\n  2. **review-complete.mp3** - \"Gentle notification tone\"\n  3. **question.mp3** - \"Attention sound\"\n  4. **plan-ready.mp3** - \"Professional tone\"\n\n**Note:** System sounds are only available on macOS. On other platforms, use the built-in MP3 sounds which work perfectly everywhere!\n\n**CRITICAL:** If user says \"play [sound]\" instead of choosing, DO NOT call AskUserQuestion yet. First play the sound, then re-ask the question.\n\n### Question 2: Review Complete Sound ğŸ”\n\n**Before presenting the question**, remind the user:\n\n> ğŸµ **Reminder:** You can preview sounds! Just say \"play [sound_name]\" before choosing.\n\nWhen Claude completes a code review or analysis, which sound?\n\nUse AskUserQuestion with the same dynamically generated options as Question 1.\n\n### Question 3: Question Sound â“\n\n**Before presenting the question**, remind the user:\n\n> ğŸµ **Reminder:** You can preview sounds! Just say \"play [sound_name]\" before choosing.\n\nWhen Claude has a question or needs clarification?\n\nUse AskUserQuestion with the same dynamically generated options as Question 1.\n\n### Question 4: Plan Ready Sound ğŸ“‹\n\n**Before presenting the question**, remind the user:\n\n> ğŸµ **Reminder:** You can preview sounds! Just say \"play [sound_name]\" before choosing.\n\nWhen Claude finishes planning and is ready for your review?\n\nUse AskUserQuestion with the same dynamically generated options as Question 1.\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 4.5: Enable/Disable Notification Types\n\nNow let's choose which notification types you want to receive. You can disable specific types that you find too frequent.\n\nUse AskUserQuestion with:\n- question: \"Which notification types do you want to receive? (unselected will be disabled)\"\n- header: \"Types\"\n- multiSelect: true\n- options:\n  1. **task_complete** - \"Task completed with code changes (recommended)\"\n  2. **review_complete** - \"Code review/analysis completed\"\n  3. **question** - \"Claude has a question for you (recommended)\"\n  4. **plan_ready** - \"Plan is ready for review\"\n\n**Note:** By default all types are selected (enabled). Unselecting a type will disable notifications for that status.\n\n**Mapping user selection to config:**\n- For each SELECTED type: `\"enabled\": true` (or omit, as nil = true)\n- For each UNSELECTED type: `\"enabled\": false`\n\n**Example:** If user only selects \"question\" and \"plan_ready\":\n```json\n{\n  \"statuses\": {\n    \"task_complete\": { \"enabled\": false, \"title\": \"...\", \"sound\": \"...\" },\n    \"review_complete\": { \"enabled\": false, \"title\": \"...\", \"sound\": \"...\" },\n    \"question\": { \"enabled\": true, \"title\": \"...\", \"sound\": \"...\" },\n    \"plan_ready\": { \"enabled\": true, \"title\": \"...\", \"sound\": \"...\" }\n  }\n}\n```\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 5: Notification Volume Configuration\n\nNow let's configure the volume for your notification sounds.\n\nUse AskUserQuestion with:\n- question: \"What volume level do you want for notification sounds?\"\n- header: \"ğŸ”Š Volume\"\n- multiSelect: false\n- options:\n  1. **Full volume (100%)** - \"Maximum volume (default)\"\n  2. **High volume (70%)** - \"Loud but not maximum\"\n  3. **Medium volume (50%)** - \"Balanced volume\"\n  4. **Low volume (30%)** - \"Quiet, good for offices\"\n  5. **Very low (10%)** - \"Very quiet, minimal distraction\"\n\n**Volume mapping:**\n- \"Full volume (100%)\" â†’ `1.0`\n- \"High volume (70%)\" â†’ `0.7`\n- \"Medium volume (50%)\" â†’ `0.5`\n- \"Low volume (30%)\" â†’ `0.3`\n- \"Very low (10%)\" â†’ `0.1`\n\n**Important:** Parse the user's choice and extract the numeric value (e.g., \"70%\" â†’ 0.7).\n\n**Note:** You can offer to preview a sound at the selected volume:\n```bash\n# Get plugin root\nPLUGIN_ROOT=\"${CLAUDE_PLUGIN_ROOT}\"\nif [ -z \"$PLUGIN_ROOT\" ]; then\n  INSTALLED_PATH=\"$HOME/.claude/plugins/marketplaces/claude-notifications-go\"\n  if [ -d \"$INSTALLED_PATH\" ]; then\n    PLUGIN_ROOT=\"$INSTALLED_PATH\"\n  else\n    PLUGIN_ROOT=\"$(pwd)\"\n  fi\nfi\n\necho \"Let me play a quick test at your selected volume...\"\n\"${PLUGIN_ROOT}/bin/sound-preview\" --volume <selected_volume> \"${PLUGIN_ROOT}/sounds/task-complete.mp3\"\necho \"How does that sound? (If you want to adjust, just let me know)\"\n```\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 5.5: Audio Device Selection (Optional)\n\nYou can route notification sounds to a specific audio output device instead of using the system default.\n\nFirst, list available audio devices:\n\n```bash\n# Get plugin root\nPLUGIN_ROOT=\"${CLAUDE_PLUGIN_ROOT}\"\nif [ -z \"$PLUGIN_ROOT\" ]; then\n  INSTALLED_PATH=\"$HOME/.claude/plugins/marketplaces/claude-notifications-go\"\n  if [ -d \"$INSTALLED_PATH\" ]; then\n    PLUGIN_ROOT=\"$INSTALLED_PATH\"\n  else\n    PLUGIN_ROOT=\"$(pwd)\"\n  fi\nfi\n\necho \"Available audio output devices:\"\n\"${PLUGIN_ROOT}/bin/list-devices\"\n```\n\nUse AskUserQuestion with:\n- question: \"Which audio output device should play notification sounds?\"\n- header: \"ğŸ”Š Audio Device\"\n- multiSelect: false\n- options:\n  1. **System default** - \"Use the system's default audio output (recommended)\"\n  2. **Specific device** - \"Choose a specific audio device from the list above\"\n\nIf user selects \"Specific device\":\n- Ask them to type the exact device name from the list\n- Store the device name for the config file\n\n**Device name mapping:**\n- \"System default\" â†’ `\"\"` (empty string in config)\n- Specific device â†’ exact device name as shown by list-devices (e.g., \"MacBook Pro-Lautsprecher\")\n\n**Note:** Leave `audioDevice` empty to use the system default. This is recommended unless you have a specific reason to route audio elsewhere.\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 6: Webhook Configuration (Optional)\n\nDo you want to send notifications to a webhook (Slack, Discord, Telegram)?\n\nUse AskUserQuestion with:\n- question: \"Enable webhook notifications?\"\n- header: \"ğŸ”— Webhooks\"\n- multiSelect: false\n- options:\n  1. **No webhooks** - \"Desktop notifications only (recommended)\"\n  2. **Slack** - \"Send to Slack webhook (JSON format)\"\n  3. **Discord** - \"Send to Discord webhook (embed format)\"\n  4. **Telegram** - \"Send to Telegram bot (requires chat_id)\"\n  5. **Custom** - \"Custom webhook endpoint (JSON)\"\n\nIf webhook is enabled, I'll create a placeholder configuration that you can edit later.\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 7: Generate Configuration File\n\nBased on your answers, I'll create `config/config.json`:\n\n**Sound Path Construction (Important!):**\n\nParse the user's choice and construct the correct path:\n\n```bash\n# Function to convert user choice to file path\nget_sound_path() {\n  local choice=\"$1\"\n\n  # Check if it's a built-in sound\n  if [[ \"$choice\" == \"Built-in:\"* ]] || [[ \"$choice\" == *\".mp3\" ]]; then\n    # Extract filename\n    filename=$(echo \"$choice\" | sed 's/Built-in: //' | sed 's/^[^:]*: //')\n    echo \"\\${CLAUDE_PLUGIN_ROOT}/sounds/${filename}\"\n\n  # Check if it's a system sound (macOS)\n  elif [[ \"$choice\" == \"System:\"* ]]; then\n    # Extract sound name (e.g., \"Glass\" from \"System: Glass\")\n    soundname=$(echo \"$choice\" | sed 's/System: //' | awk '{print $1}')\n    echo \"/System/Library/Sounds/${soundname}.aiff\"\n\n  # Fallback to built-in if parsing fails\n  else\n    echo \"\\${CLAUDE_PLUGIN_ROOT}/sounds/task-complete.mp3\"\n  fi\n}\n\n# Example usage:\nTASK_COMPLETE_PATH=$(get_sound_path \"$user_answer_1\")\nREVIEW_COMPLETE_PATH=$(get_sound_path \"$user_answer_2\")\nQUESTION_PATH=$(get_sound_path \"$user_answer_3\")\nPLAN_READY_PATH=$(get_sound_path \"$user_answer_4\")\n```\n\n**Examples:**\n- Built-in: `${CLAUDE_PLUGIN_ROOT}/sounds/task-complete.mp3`\n- System (macOS): `/System/Library/Sounds/Glass.aiff`\n- Fallback (if parsing fails): Always use built-in MP3\n\n**Configuration Template:**\n\n**IMPORTANT - Webhook Configuration Rules:**\n- If user selected \"No webhooks\": Set `\"enabled\": false` and `\"preset\": \"custom\"` (DO NOT use \"none\")\n- If user selected \"Slack\": Set `\"enabled\": true` and `\"preset\": \"slack\"`\n- If user selected \"Discord\": Set `\"enabled\": true` and `\"preset\": \"discord\"`\n- If user selected \"Telegram\": Set `\"enabled\": true` and `\"preset\": \"telegram\"`\n- If user selected \"Custom\": Set `\"enabled\": true` and `\"preset\": \"custom\"`\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"enabled\": true,\n      \"sound\": true,\n      \"volume\": <user's selected volume>,\n      \"audioDevice\": \"<user's selected device or empty string>\",\n      \"appIcon\": \"${CLAUDE_PLUGIN_ROOT}/claude_icon.png\"\n    },\n    \"webhook\": {\n      \"enabled\": <true if webhook selected, false for \"No webhooks\">,\n      \"preset\": \"<slack|discord|telegram|custom - NEVER use 'none', use 'custom' if No webhooks>\",\n      \"url\": \"<placeholder - user must edit>\",\n      \"chat_id\": \"<for telegram only>\",\n      \"format\": \"json\",\n      \"headers\": {}\n    },\n    \"suppressQuestionAfterTaskCompleteSeconds\": 7\n  },\n  \"statuses\": {\n    \"task_complete\": {\n      \"enabled\": <true if selected in Step 4.5, false if not selected>,\n      \"title\": \"âœ… Task Completed\",\n      \"sound\": \"<user's choice>\"\n    },\n    \"review_complete\": {\n      \"enabled\": <true if selected in Step 4.5, false if not selected>,\n      \"title\": \"ğŸ” Review Completed\",\n      \"sound\": \"<user's choice>\"\n    },\n    \"question\": {\n      \"enabled\": <true if selected in Step 4.5, false if not selected>,\n      \"title\": \"â“ Claude Has Questions\",\n      \"sound\": \"<user's choice>\"\n    },\n    \"plan_ready\": {\n      \"enabled\": <true if selected in Step 4.5, false if not selected>,\n      \"title\": \"ğŸ“‹ Plan Ready for Review\",\n      \"sound\": \"<user's choice>\"\n    }\n  }\n}\n```\n\nWrite this to: `${PLUGIN_ROOT}/config/config.json`\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Step 8: Summary & Test\n\nAfter creating the configuration, show the user:\n\n```\nğŸ‰ Configuration Saved Successfully!\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nğŸ“ Summary:\n  âœ… Task Complete    â†’ <chosen sound> <ENABLED/DISABLED>\n  ğŸ” Review Complete  â†’ <chosen sound> <ENABLED/DISABLED>\n  â“ Question         â†’ <chosen sound> <ENABLED/DISABLED>\n  ğŸ“‹ Plan Ready       â†’ <chosen sound> <ENABLED/DISABLED>\n\n  ğŸ”Š Desktop notifications: ENABLED\n  ğŸ”Š Volume: <selected volume>%\n  ğŸ”Š Audio device: <selected device or \"System default\">\n  ğŸ”— Webhooks: <ENABLED/DISABLED>\n\nConfiguration file: config/config.json\n```\n\n### Test Your Setup\n\nAsk user: \"Would you like to test your task-complete notification now?\"\n\nIf yes:\n```bash\n# Get plugin root\nPLUGIN_ROOT=\"${CLAUDE_PLUGIN_ROOT}\"\nif [ -z \"$PLUGIN_ROOT\" ]; then\n  INSTALLED_PATH=\"$HOME/.claude/plugins/marketplaces/claude-notifications-go\"\n  if [ -d \"$INSTALLED_PATH\" ]; then\n    PLUGIN_ROOT=\"$INSTALLED_PATH\"\n  else\n    PLUGIN_ROOT=\"$(pwd)\"\n  fi\nfi\n\necho \"Testing task-complete sound at your configured volume (<selected_volume>%)...\"\n\"${PLUGIN_ROOT}/bin/sound-preview\" --volume <selected_volume> \"<path-to-chosen-sound>\"\necho \"âœ“ Sound test complete!\"\n```\n\n**Note:** This test uses your configured volume level. The actual notifications will use this same volume.\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Additional Notes\n\n**Editing Later:**\n- You can re-run `/claude-notifications-go:notifications-settings` anytime to reconfigure\n- Or manually edit `config/config.json`\n\n**Webhook Configuration:**\nIf you enabled webhooks, you'll need to manually edit `config/config.json` to add:\n- **Slack:** Your webhook URL from Slack integrations\n- **Discord:** Your webhook URL from Discord server settings\n- **Telegram:** Bot token in URL + chat_id field\n- **Custom:** Your endpoint URL and any required headers\n\n**Sound Formats Supported:**\n- MP3, WAV, FLAC, OGG/Vorbis, AIFF\n- Cross-platform playback via malgo (miniaudio) library\n- Audio device selection supported on all platforms\n\n**System Sounds:**\n- macOS: `/System/Library/Sounds/*.aiff`\n- Linux: `/usr/share/sounds/**/*.ogg` (varies by distribution)\n- Windows: Use custom sounds (system sounds not easily accessible)\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n## Tips for Best Experience\n\nâœ¨ **Sound Selection Tips:**\n- Use distinct sounds for different notification types\n- Choose sounds that won't be disruptive in your workspace\n- Test sounds at your typical volume before finalizing\n\nğŸ¯ **Recommended Combinations:**\n\n**Minimal Setup:**\n- Task Complete: Glass (crisp, professional)\n- Review Complete: Tink (subtle)\n- Question: Sosumi (attention-grabbing)\n- Plan Ready: Ping (gentle reminder)\n\n**Power User Setup:**\n- Task Complete: Hero (celebration!)\n- Review Complete: Purr (satisfaction)\n- Question: Funk (stand out)\n- Plan Ready: Submarine (unique)\n\n**Built-in Sounds:**\n- Use the included MP3s if you want consistent cross-platform experience\n- Plugin sounds work on all operating systems\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n**Ready to begin?** Let's start by choosing your sound source! ğŸµ\n",
        "docs/webhooks/README.md": "# Webhook Integration Guide\n\n**Professional webhook system with enterprise-grade reliability patterns.**\n\nSend Claude Code notifications to Slack, Discord, Telegram, Lark/Feishu, or custom endpoints with built-in retry, circuit breaker, and rate limiting.\n\n## Quick Start\n\n### 1. Enable Webhooks\n\nEdit `config/config.json`:\n\n```json\n{\n  \"notifications\": {\n    \"webhook\": {\n      \"enabled\": true,\n      \"preset\": \"slack\",\n      \"url\": \"https://hooks.slack.com/services/YOUR/WEBHOOK/URL\"\n    }\n  }\n}\n```\n\n### 2. Test Your Setup\n\n```bash\necho '{\"session_id\":\"test\",\"tool_name\":\"ExitPlanMode\"}' | \\\n  bin/claude-notifications handle-hook PreToolUse\n```\n\n## Platform Guides\n\nChoose your platform for detailed setup instructions:\n\n### Popular Platforms\n\n- **[Slack](slack.md)** - Color-coded attachments in Slack channels\n- **[Discord](discord.md)** - Rich embeds with timestamps\n- **[Telegram](telegram.md)** - HTML-formatted messages via bot\n- **[Lark/Feishu](lark.md)** - Interactive cards with colored headers\n\n### Other Options\n\n- **[Custom Webhooks](custom.md)** - Integrate with any webhook-compatible service\n\n## Features\n\n- **Platform presets**: Pre-configured formatting for Slack, Discord, and Telegram\n- **Custom endpoints**: Support for any webhook-compatible service\n- **Retry mechanism**: Exponential backoff with jitter (1-3 attempts)\n- **Circuit breaker**: Automatic failure detection and recovery\n- **Rate limiting**: Token bucket algorithm to prevent API overload\n- **Rich formatting**: Color-coded messages with platform-specific layouts\n- **Request tracing**: UUID-based request IDs for debugging\n- **Metrics tracking**: Success/failure rates, latency, circuit breaker state\n- **Session names**: Friendly identifiers like `[bold-cat]` for easy tracking\n\n## Documentation\n\n### Configuration\n- **[Configuration Reference](configuration.md)** - Retry, circuit breaker, and rate limiting options\n\n### Monitoring & Debugging\n- **[Monitoring & Metrics](monitoring.md)** - Track success rates, latency, and system health\n- **[Troubleshooting](troubleshooting.md)** - Common issues and debugging tips\n\n## Status Types\n\nThe system automatically detects and formats these statuses:\n\n| Status | Title | Emoji |\n|--------|-------|-------|\n| `task_complete` | Task Completed | âœ… |\n| `review_complete` | Review Complete | ğŸ” |\n| `question` | Claude Has Questions | â“ |\n| `plan_ready` | Plan Ready | ğŸ“‹ |\n| `session_limit_reached` | Session Limit Reached | â±ï¸ |\n\n## Best Practices\n\n1. **Always enable retry** - Transient network failures are common\n2. **Use circuit breaker in production** - Prevents cascading failures\n3. **Set appropriate rate limits** - Match your webhook provider's limits\n4. **Monitor metrics** - Track success rates and latency\n5. **Use platform presets** - Leverage built-in formatting for better UX\n6. **Test with webhook.site** - Verify payloads before production\n\n## Security\n\n- Store webhook URLs in config files (not in code)\n- Use HTTPS for all webhook endpoints\n- Rotate API keys/tokens regularly\n- Use custom headers for authentication when possible\n- Monitor for unusual activity in webhook metrics\n\n## Support\n\nFor issues, questions, or contributions:\n- GitHub Issues: https://github.com/777genius/claude-notifications-go/issues\n- Main Documentation: [README.md](../../README.md)\n\n---\n\n**Built with reliability patterns from production systems.**\n",
        "hooks/hooks.json": "{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"ExitPlanMode|AskUserQuestion\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"sh ${CLAUDE_PLUGIN_ROOT}/bin/hook-wrapper.sh handle-hook PreToolUse\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ],\n    \"Notification\": [\n      {\n        \"matcher\": \"permission_prompt\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"sh ${CLAUDE_PLUGIN_ROOT}/bin/hook-wrapper.sh handle-hook Notification\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"sh ${CLAUDE_PLUGIN_ROOT}/bin/hook-wrapper.sh handle-hook Stop\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ],\n    \"SubagentStop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"sh ${CLAUDE_PLUGIN_ROOT}/bin/hook-wrapper.sh handle-hook SubagentStop\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "internal/errorhandler/README.md": "# Error Handler Package\n\nĞ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ Ğ² Ñ„Ğ°Ğ¹Ğ» Ğ¸ ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ.\n\n## Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚Ğ¸\n\n- Ğ¦ĞµĞ½Ñ‚Ñ€Ğ°Ğ»Ğ¸Ğ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº\n- ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğµ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ² Ñ„Ğ°Ğ¹Ğ» Ğ¸ ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ\n- ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº\n- Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ panic Ñ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒÑ recover\n- Ğ—Ğ°Ñ‰Ğ¸Ñ‰Ñ‘Ğ½Ğ½Ñ‹Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½\n- Ğ Ğ°Ğ·Ğ½Ñ‹Ğµ ÑƒÑ€Ğ¾Ğ²Ğ½Ğ¸ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ: Debug, Info, Warn, Error, Critical\n\n## Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ\n\n```go\nimport \"github.com/777genius/claude-notifications/internal/errorhandler\"\n\n// Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ Ğ¿Ñ€Ğ¸ ÑÑ‚Ğ°Ñ€Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ\nerrorhandler.Init(\n    true,  // logToConsole: Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ñ‚ÑŒ Ğ»Ğ¾Ğ³Ğ¸ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ\n    false, // exitOnCritical: Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ñƒ Ğ¿Ñ€Ğ¸ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¾ÑˆĞ¸Ğ±ĞºĞ°Ñ…\n    true,  // recoveryEnabled: Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ²Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ÑĞ»Ğµ panic\n)\n```\n\n## Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ\n\n### ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ñ… Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº\n\n```go\nif err := someOperation(); err != nil {\n    errorhandler.HandleError(err, \"Failed to perform operation\")\n}\n```\n\n### ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº\n\n```go\nif err := criticalOperation(); err != nil {\n    errorhandler.HandleCriticalError(err, \"Critical failure in operation\")\n    // ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ²ÑĞµĞ³Ğ´Ğ° Ğ²Ñ‹Ğ²Ğ¾Ğ´ÑÑ‚ÑÑ Ğ² stderr\n}\n```\n\n### Ğ—Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ panic\n\n```go\nfunc riskyFunction() {\n    defer errorhandler.HandlePanic()\n\n    // Ğ’Ğ°Ñˆ ĞºĞ¾Ğ´, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ panic\n    panic(\"something went wrong\")\n    // Panic Ğ±ÑƒĞ´ĞµÑ‚ Ğ¿ĞµÑ€ĞµÑ…Ğ²Ğ°Ñ‡ĞµĞ½ Ğ¸ Ğ·Ğ°Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½\n}\n```\n\n### ĞĞ±Ñ‘Ñ€Ñ‚ĞºĞ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¹ Ñ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼ recover\n\n```go\n// ĞĞ±Ñ‹Ñ‡Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ\nerrorhandler.WithRecovery(func() {\n    // ĞšĞ¾Ğ´, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ panic\n})\n\n// Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ñ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚Ğ¾Ğ¼ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸\nerr := errorhandler.WithRecoveryFunc(func() error {\n    // ĞšĞ¾Ğ´, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²Ñ‹Ğ·Ğ²Ğ°Ñ‚ÑŒ panic Ğ¸Ğ»Ğ¸ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ Ğ¾ÑˆĞ¸Ğ±ĞºÑƒ\n    return someOperation()\n})\n```\n\n### Ğ‘ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ñ‹Ğ¹ Ğ·Ğ°Ğ¿ÑƒÑĞº Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½\n\n```go\n// Ğ’Ğ¼ĞµÑÑ‚Ğ¾ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾Ğ³Ğ¾ go func()\nerrorhandler.SafeGo(func() {\n    // ĞšĞ¾Ğ´ Ğ² Ğ³Ğ¾Ñ€ÑƒÑ‚Ğ¸Ğ½Ğµ Ñ Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ¾Ğ¹ Ğ¾Ñ‚ panic\n    riskyAsyncOperation()\n})\n```\n\n### Ğ›Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ\n\n```go\nerrorhandler.Debug(\"Debug message: %s\", value)\nerrorhandler.Info(\"Info message: %s\", value)\nerrorhandler.Warn(\"Warning: %s\", warning)\n```\n\n## Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ logging\n\nĞŸĞ°ĞºĞµÑ‚ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ Ñ `internal/logging` Ğ¸:\n- Ğ›Ğ¾Ğ³Ğ¸Ñ€ÑƒĞµÑ‚ Ğ²ÑĞµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ² Ñ„Ğ°Ğ¹Ğ» `notification-debug.log`\n- ĞŸÑ€Ğ¸ Ğ²ĞºĞ»ÑÑ‡Ñ‘Ğ½Ğ½Ğ¾Ğ¼ `logToConsole` Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ñ‚ Ğ»Ğ¾Ğ³Ğ¸ Ğ² stderr (Ğ´Ğ»Ñ Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº/Ğ¿Ñ€ĞµĞ´ÑƒĞ¿Ñ€ĞµĞ¶Ğ´ĞµĞ½Ğ¸Ğ¹) Ğ¸Ğ»Ğ¸ stdout (Ğ´Ğ»Ñ info/debug)\n- ĞšÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ Ğ²ÑĞµĞ³Ğ´Ğ° Ğ²Ñ‹Ğ²Ğ¾Ğ´ÑÑ‚ÑÑ Ğ² stderr, Ğ´Ğ°Ğ¶Ğµ ĞµÑĞ»Ğ¸ `logToConsole=false`\n- **Ğ’ÑĞµ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ñ‹ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ Ğ¸Ğ¼ĞµÑÑ‚ Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑ `[claude-notifications]` Ğ´Ğ»Ñ ÑƒĞ´Ğ¾Ğ±Ğ½Ğ¾Ğ¹ Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸**\n\n## ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ğ¸Ğ· ĞºĞ¾Ğ´Ğ°\n\n### main.go\n```go\nfunc main() {\n    errorhandler.Init(true, false, true)\n    defer errorhandler.HandlePanic()\n\n    // ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ°\n}\n```\n\n### hooks.go\n```go\nfunc (h *Handler) HandleHook(hookEvent string, input io.Reader) error {\n    defer errorhandler.HandlePanic()\n\n    // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ…ÑƒĞºĞ°\n}\n```\n\n### ĞÑĞ¸Ğ½Ñ…Ñ€Ğ¾Ğ½Ğ½Ñ‹Ğµ Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸\n```go\n// notifier.go\nerrorhandler.SafeGo(func() {\n    defer n.wg.Done()\n    n.playSound(soundPath)\n})\n\n// webhook.go\nerrorhandler.SafeGo(func() {\n    defer s.wg.Done()\n    if err := s.Send(status, message, sessionID); err != nil {\n        errorhandler.HandleError(err, \"Async webhook send failed\")\n    }\n})\n```\n\n## Ğ¢ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ\n\n```bash\ngo test ./internal/errorhandler/... -v\n```\n\n## ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ°\n\n### Ğ’Ñ‹Ğ²Ğ¾Ğ´ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ (stderr/stdout)\nĞ’ÑĞµ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ² ĞºĞ¾Ğ½ÑĞ¾Ğ»ÑŒ Ğ¸Ğ¼ĞµÑÑ‚ Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑ `[claude-notifications]`:\n```\n[claude-notifications] [2025-10-19 15:30:45] [ERROR] CRITICAL ERROR - Failed to initialize logger: permission denied\n[claude-notifications] PANIC: unexpected nil pointer\n[claude-notifications] [2025-10-19 15:30:46] [INFO] Notification sent successfully\n[claude-notifications] [2025-10-19 15:30:47] [WARN] Rate limit approaching threshold\n```\n\n### Ğ’Ñ‹Ğ²Ğ¾Ğ´ Ğ² Ñ„Ğ°Ğ¹Ğ» (notification-debug.log)\nĞ¤Ğ°Ğ¹Ğ»Ğ¾Ğ²Ñ‹Ğ¹ Ğ»Ğ¾Ğ³ Ğ½Ğµ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ Ğ¿Ñ€ĞµÑ„Ğ¸ĞºÑ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğ°:\n```\n[2025-10-19 15:30:45] [ERROR] CRITICAL ERROR - Failed to initialize logger: permission denied\n[2025-10-19 15:30:45] [ERROR] PANIC RECOVERED: unexpected nil pointer\nruntime/debug.Stack()...\n[2025-10-19 15:30:46] [INFO] Notification sent successfully\n[2025-10-19 15:30:47] [WARN] Rate limit approaching threshold\n```\n",
        "internal/hooks/INTEGRATION_TESTS.md": "# Integration Tests\n\n## ğŸ“– Overview\n\nĞ­Ñ‚Ğ¸ Ñ‚ĞµÑÑ‚Ñ‹ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑÑÑ‚ **Ğ¿Ğ¾Ğ»Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğ°** Ğ±ĞµĞ· Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Claude Code. ĞĞ½Ğ¸ ÑĞ¸Ğ¼ÑƒĞ»Ğ¸Ñ€ÑƒÑÑ‚ Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ ÑÑ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¸ Ñ‡ĞµÑ€ĞµĞ· **mock transcript Ñ„Ğ°Ğ¹Ğ»Ñ‹** Ğ¸ **Ğ½Ğ°ÑÑ‚Ğ¾ÑÑ‰Ğ¸Ğµ HTTP Ğ²Ñ‹Ğ·Ğ¾Ğ²Ñ‹**.\n\n## ğŸš€ Ğ‘Ñ‹ÑÑ‚Ñ€Ñ‹Ğ¹ ÑÑ‚Ğ°Ñ€Ñ‚\n\n```bash\n# Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ñ‹Ğµ Ñ‚ĞµÑÑ‚Ñ‹\ngo test -tags=integration -v ./internal/hooks/\n\n# Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ ĞºĞ¾Ğ½ĞºÑ€ĞµÑ‚Ğ½Ñ‹Ğ¹ Ñ‚ĞµÑÑ‚\ngo test -tags=integration -v -run TestE2E_WebhookRetry ./internal/hooks/\n\n# Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ²ÑĞµ Ñ‚ĞµÑÑ‚Ñ‹ (unit + integration)\ngo test -tags=integration -v ./...\n```\n\n## âœ… Ğ§Ñ‚Ğ¾ Ñ‚ĞµÑÑ‚Ğ¸Ñ€ÑƒĞµÑ‚ÑÑ\n\n### 1. **TestE2E_FullNotificationCycle** (6 ÑĞµĞºÑƒĞ½Ğ´)\nĞŸĞ¾Ğ»Ğ½Ñ‹Ğ¹ Ğ¶Ğ¸Ğ·Ğ½ĞµĞ½Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ» ÑĞµÑÑĞ¸Ğ¸ Ñ state management.\n\n**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹:**\n```\n1. PreToolUse: ExitPlanMode\n   â””â”€> Notification: plan_ready âœ“\n\n2. Notification hook (ÑÑ€Ğ°Ğ·Ñƒ Ğ¿Ğ¾ÑĞ»Ğµ)\n   â””â”€> Suppressed (cooldown Ğ°ĞºÑ‚Ğ¸Ğ²ĞµĞ½) âœ“\n\n3. Wait 6 seconds (cooldown Ğ¸ÑÑ‚ĞµĞºĞ°ĞµÑ‚)\n   â””â”€> Notification: question âœ“\n\n4. Stop: task_complete\n   â””â”€> Notification: task_complete âœ“\n\n5. Cleanup: state files ÑƒĞ´Ğ°Ğ»ĞµĞ½Ñ‹ âœ“\n```\n\n**ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚:**\n- âœ… State management Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚\n- âœ… Cooldown suppression Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚\n- âœ… Session isolation Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚\n- âœ… Notifications Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑÑ‚ÑÑ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»ÑŒĞ½Ğ¾\n\n---\n\n### 2. **TestE2E_WebhookRetry** (< 1 ÑĞµĞºÑƒĞ½Ğ´Ğ°)\nĞ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ HTTP Ğ²Ñ‹Ğ·Ğ¾Ğ²Ñ‹ Ñ retry Ğ¼ĞµÑ…Ğ°Ğ½Ğ¸Ğ·Ğ¼Ğ¾Ğ¼.\n\n**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹:**\n```\nHTTP Server â†’ 503 (fail)\n            â†’ 503 (fail)\n            â†’ 200 (success)\n\nWebhook sender â†’ Retry 3 times âœ“\n```\n\n**ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚:**\n- âœ… Retry Ğ»Ğ¾Ğ³Ğ¸ĞºĞ° Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚\n- âœ… Exponential backoff Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½ÑĞµÑ‚ÑÑ\n- âœ… HTTP headers ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚Ğ½Ñ‹Ğµ\n- âœ… Circuit breaker Ğ½Ğµ Ğ¼ĞµÑˆĞ°ĞµÑ‚ (Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½)\n\n---\n\n### 3. **TestE2E_ConcurrentSessions** (< 1 ÑĞµĞºÑƒĞ½Ğ´Ğ°)\nĞŸĞ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ñ‹Ğµ ÑĞµÑÑĞ¸Ğ¸ Ñ Ğ¸Ğ·Ğ¾Ğ»ÑÑ†Ğ¸ĞµĞ¹.\n\n**Ğ¡Ñ†ĞµĞ½Ğ°Ñ€Ğ¸Ğ¹:**\n```\nSession A: PreToolUse â†’ Stop\nSession B: PreToolUse â†’ Stop  (Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾)\nSession C: PreToolUse â†’ Stop  (Ğ¾Ğ´Ğ½Ğ¾Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾)\n\nĞ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚: 6 notifications (2 Ğ½Ğ° ÑĞµÑÑĞ¸Ñ) âœ“\n```\n\n**ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚:**\n- âœ… Concurrent access Ğº state Ñ„Ğ°Ğ¹Ğ»Ğ°Ğ¼\n- âœ… Lock Ğ¼ĞµÑ…Ğ°Ğ½Ğ¸Ğ·Ğ¼ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚\n- âœ… Ğ˜Ğ·Ğ¾Ğ»ÑÑ†Ğ¸Ñ Ğ¼ĞµĞ¶Ğ´Ñƒ ÑĞµÑÑĞ¸ÑĞ¼Ğ¸\n\n---\n\n## ğŸ¯ Ğ§Ñ‚Ğ¾ ĞĞ• Ñ‚Ñ€ĞµĞ±ÑƒĞµÑ‚ÑÑ\n\nâŒ **Ğ ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Claude Code** - Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ mock transcripts\nâŒ **Ğ“Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ°Ñ ÑÑ€ĞµĞ´Ğ°** - desktop notifications Ğ¼Ğ¾ĞºĞ°ÑÑ‚ÑÑ\nâŒ **ĞÑƒĞ´Ğ¸Ğ¾ ÑƒÑÑ‚Ñ€Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°** - sound playback Ğ¼Ğ¾ĞºĞ°ĞµÑ‚ÑÑ\n\n## ğŸ“Š Ğ ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ñ‹\n\n```bash\n$ go test -tags=integration -v ./internal/hooks/\n\n=== RUN   TestE2E_FullNotificationCycle\n    âœ“ Phase 1: plan_ready sent\n    âœ“ Phase 2: question suppressed\n    âœ“ Phase 3: notification after cooldown\n    âœ“ Phase 4: task_complete sent\n    âœ“ Phase 5: cleanup verified\n--- PASS: TestE2E_FullNotificationCycle (6.16s)\n\n=== RUN   TestE2E_WebhookRetry\n    Webhook attempt #1\n    Webhook attempt #2\n    Webhook attempt #3\n    âœ“ Retry worked (3 attempts)\n--- PASS: TestE2E_WebhookRetry (0.52s)\n\n=== RUN   TestE2E_ConcurrentSessions\n    âœ“ 3 sessions completed\n    âœ“ 6 notifications sent\n--- PASS: TestE2E_ConcurrentSessions (0.14s)\n\nPASS\nok      internal/hooks  7.238s\n```\n\n## ğŸ› ï¸ ĞÑ€Ñ…Ğ¸Ñ‚ĞµĞºÑ‚ÑƒÑ€Ğ°\n\n### Mock Components\n- **mockNotifier** - Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ desktop notifications\n- **mockWebhook** - Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚ webhook calls (Ğ´Ğ»Ñ Ğ½ĞµĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ñ… Ñ‚ĞµÑÑ‚Ğ¾Ğ²)\n- **Real Webhook** - Ğ½Ğ°ÑÑ‚Ğ¾ÑÑ‰Ğ¸Ğ¹ HTTP sender (Ğ´Ğ»Ñ retry Ñ‚ĞµÑÑ‚Ğ¾Ğ²)\n\n### Real Components\n- **State Manager** - Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ² `/tmp`\n- **Dedup Manager** - Ñ€ĞµĞ°Ğ»ÑŒĞ½Ñ‹Ğµ lock Ñ„Ğ°Ğ¹Ğ»Ñ‹\n- **HTTP Server** - Ğ½Ğ°ÑÑ‚Ğ¾ÑÑ‰Ğ¸Ğ¹ `httptest.Server`\n\n### Transcript Simulation\n```go\n// Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ fake transcript ĞºĞ°Ğº Ğ² Ñ€ĞµĞ°Ğ»ÑŒĞ½Ğ¾Ğ¼ Claude\ntranscript := buildTranscriptWithTools(\n    []string{\"Read\", \"Edit\", \"Write\"}, // tools\n    300,                                 // response length\n)\ntranscriptPath := createTempTranscript(t, transcript)\n```\n\n## ğŸ”§ Ğ Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸Ğµ\n\n### Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ E2E Ñ‚ĞµÑÑ‚:\n\n```go\nfunc TestE2E_MyScenario(t *testing.T) {\n    // 1. Setup\n    handler, mockNotif, _ := newE2EHandler(t)\n\n    // 2. Create transcript\n    transcript := buildTranscriptWithTools(\n        []string{\"Grep\", \"Read\"},\n        250,\n    )\n    transcriptPath := createTempTranscript(t, transcript)\n\n    // 3. Simulate hook\n    hookData := buildHookDataJSON(HookData{\n        SessionID:      \"test-session\",\n        TranscriptPath: transcriptPath,\n        HookEventName:  \"Stop\",\n    })\n\n    err := handler.HandleHook(\"Stop\", hookData)\n\n    // 4. Verify\n    if mockNotif.callCount() != 1 {\n        t.Error(\"Expected 1 notification\")\n    }\n}\n```\n\n## ğŸ“ Best Practices\n\n1. **Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ ÑƒĞ½Ğ¸ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğµ session IDs** Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ñ‚ĞµÑÑ‚Ğ°\n2. **Ğ–Ğ´Ğ¸Ñ‚Ğµ async Ğ¾Ğ¿ĞµÑ€Ğ°Ñ†Ğ¸Ğ¹** - webhook.SendAsync Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ\n3. **ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞ¹Ñ‚Ğµ cleanup** - state/lock Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ´Ğ¾Ğ»Ğ¶Ğ½Ñ‹ ÑƒĞ´Ğ°Ğ»ÑÑ‚ÑŒÑÑ\n4. **Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ timeouts** - Ğ½Ğµ Ğ¿Ğ¾Ğ·Ğ²Ğ¾Ğ»ÑĞ¹Ñ‚Ğµ Ñ‚ĞµÑÑ‚Ğ°Ğ¼ Ğ·Ğ°Ğ²Ğ¸ÑĞ½ÑƒÑ‚ÑŒ\n\n## ğŸ› Troubleshooting\n\n**Ğ¢ĞµÑÑ‚Ñ‹ Ğ¼ĞµĞ´Ğ»ĞµĞ½Ğ½Ñ‹Ğµ?**\n```bash\n# Ğ—Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ±Ñ‹ÑÑ‚Ñ€Ñ‹Ğµ Ñ‚ĞµÑÑ‚Ñ‹\ngo test -tags=integration -v -run \"Webhook|Concurrent\" ./internal/hooks/\n```\n\n**State Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ¾ÑÑ‚Ğ°ÑÑ‚ÑÑ?**\n```bash\n# ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ /tmp\nrm -rf /tmp/claude-notifications-*\n```\n\n**Webhook Ğ½Ğµ ÑÑ€Ğ°Ğ±Ğ°Ñ‚Ñ‹Ğ²Ğ°ĞµÑ‚?**\n- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ñ‡Ñ‚Ğ¾ webhook enabled Ğ² config\n- Ğ£Ğ²ĞµĞ»Ğ¸Ñ‡ÑŒÑ‚Ğµ sleep Ğ²Ñ€ĞµĞ¼Ñ Ğ´Ğ»Ñ async operations\n- ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑŒÑ‚Ğµ Ğ»Ğ¾Ğ³Ğ¸ Ñ `-v` Ñ„Ğ»Ğ°Ğ³Ğ¾Ğ¼\n\n## ğŸ“ˆ CI/CD Integration\n\n```yaml\n# .github/workflows/test.yml\n- name: Run Integration Tests\n  run: |\n    go test -tags=integration -v -timeout 30s ./internal/hooks/\n```\n\n---\n\n**Ğ’Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹?** Ğ¡Ğ¼Ğ¾Ñ‚Ñ€Ğ¸Ñ‚Ğµ Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ğ² `integration_test.go`\n",
        "internal/hooks/hooks.go": "package hooks\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/777genius/claude-notifications/internal/analyzer\"\n\t\"github.com/777genius/claude-notifications/internal/config\"\n\t\"github.com/777genius/claude-notifications/internal/dedup\"\n\t\"github.com/777genius/claude-notifications/internal/errorhandler\"\n\t\"github.com/777genius/claude-notifications/internal/logging\"\n\t\"github.com/777genius/claude-notifications/internal/notifier\"\n\t\"github.com/777genius/claude-notifications/internal/platform\"\n\t\"github.com/777genius/claude-notifications/internal/sessionname\"\n\t\"github.com/777genius/claude-notifications/internal/state\"\n\t\"github.com/777genius/claude-notifications/internal/summary\"\n\t\"github.com/777genius/claude-notifications/internal/webhook\"\n)\n\n// HookData represents the data received from Claude Code hooks\ntype HookData struct {\n\tTranscriptPath string `json:\"transcript_path\"`\n\tSessionID      string `json:\"session_id\"`\n\tCWD            string `json:\"cwd\"`\n\tToolName       string `json:\"tool_name,omitempty\"`\n\tHookEventName  string `json:\"hook_event_name,omitempty\"`\n}\n\n// notifierInterface defines the interface for sending desktop notifications\ntype notifierInterface interface {\n\tSendDesktop(status analyzer.Status, message string) error\n\tClose() error\n}\n\n// webhookInterface defines the interface for sending webhook notifications\ntype webhookInterface interface {\n\tSendAsync(status analyzer.Status, message, sessionID string)\n\tShutdown(timeout time.Duration) error\n}\n\n// Handler handles hook events\ntype Handler struct {\n\tcfg         *config.Config\n\tdedupMgr    *dedup.Manager\n\tstateMgr    *state.Manager\n\tnotifierSvc notifierInterface\n\twebhookSvc  webhookInterface\n\tpluginRoot  string\n}\n\n// NewHandler creates a new hook handler\nfunc NewHandler(pluginRoot string) (*Handler, error) {\n\t// Load config\n\tcfg, err := config.LoadFromPluginRoot(pluginRoot)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to load config: %w\", err)\n\t}\n\n\t// Validate config\n\tif err := cfg.Validate(); err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid config: %w\", err)\n\t}\n\n\treturn &Handler{\n\t\tcfg:         cfg,\n\t\tdedupMgr:    dedup.NewManager(),\n\t\tstateMgr:    state.NewManager(),\n\t\tnotifierSvc: notifier.New(cfg),\n\t\twebhookSvc:  webhook.New(cfg),\n\t\tpluginRoot:  pluginRoot,\n\t}, nil\n}\n\n// HandleHook handles a hook event\nfunc (h *Handler) HandleHook(hookEvent string, input io.Reader) error {\n\t// Add panic recovery for robustness\n\tdefer errorhandler.HandlePanic()\n\n\t// Skip notifications when running in background judge mode (e.g., double-shot-latte plugin)\n\t// The CLAUDE_HOOK_JUDGE_MODE env var is set by plugins that spawn background Claude instances\n\t// to evaluate context/decide on continuation - we don't want notifications from these\n\tif os.Getenv(\"CLAUDE_HOOK_JUDGE_MODE\") == \"true\" {\n\t\treturn nil\n\t}\n\n\t// Ensure notifier resources are cleaned up when function exits\n\tdefer func() {\n\t\tif err := h.notifierSvc.Close(); err != nil {\n\t\t\tlogging.Warn(\"Failed to close notifier: %v\", err)\n\t\t}\n\t}()\n\n\t// Ensure webhook sender waits for in-flight requests before exit\n\tdefer func() {\n\t\tif err := h.webhookSvc.Shutdown(5 * time.Second); err != nil {\n\t\t\tlogging.Warn(\"Failed to shutdown webhook sender: %v\", err)\n\t\t}\n\t}()\n\n\tlogging.SetPrefix(fmt.Sprintf(\"PID:%d\", os.Getpid()))\n\tlogging.Debug(\"=== Hook triggered: %s ===\", hookEvent)\n\n\t// Parse hook data\n\tvar hookData HookData\n\tif err := json.NewDecoder(input).Decode(&hookData); err != nil {\n\t\treturn fmt.Errorf(\"failed to parse hook data: %w\", err)\n\t}\n\n\tlogging.Debug(\"Hook data: session=%s, transcript=%s, tool=%s\",\n\t\thookData.SessionID, hookData.TranscriptPath, hookData.ToolName)\n\n\t// Validate session ID\n\tif hookData.SessionID == \"\" {\n\t\thookData.SessionID = \"unknown\"\n\t\tlogging.Warn(\"Session ID is empty, using 'unknown'\")\n\t}\n\n\t// Phase 1: Early duplicate check (per hook event type)\n\tif h.dedupMgr.CheckEarlyDuplicate(hookData.SessionID, hookEvent) {\n\t\tlogging.Debug(\"Early duplicate detected, skipping\")\n\t\treturn nil\n\t}\n\n\t// Check if any notification method is enabled\n\tif !h.cfg.IsAnyNotificationEnabled() {\n\t\tlogging.Debug(\"All notifications disabled, exiting\")\n\t\treturn nil\n\t}\n\n\t// Determine status based on hook type\n\tvar status analyzer.Status\n\tvar err error\n\n\tswitch hookEvent {\n\tcase \"PreToolUse\":\n\t\tstatus = h.handlePreToolUse(&hookData)\n\tcase \"Notification\":\n\t\t// Check session state first (60s TTL) to suppress duplicates after PreToolUse\n\t\tstatus, err = h.handleNotificationEvent(&hookData)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"Stop\":\n\t\t// Analyze the transcript to determine status\n\t\tstatus, err = h.handleStopEvent(&hookData)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Note: We don't delete session state here to preserve cooldown info\n\t\t// State files have TTL and will be cleaned up automatically\n\t\tdefer h.cleanupOldLocks()\n\tcase \"SubagentStop\":\n\t\t// Check config: should we notify on subagent completion?\n\t\tif !h.cfg.Notifications.NotifyOnSubagentStop {\n\t\t\tlogging.Debug(\"SubagentStop: notifications disabled (config), skipping\")\n\t\t\treturn nil\n\t\t}\n\t\t// If enabled, handle like Stop\n\t\tlogging.Debug(\"SubagentStop: notifications enabled (config), processing\")\n\t\tstatus, err = h.handleStopEvent(&hookData)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer h.cleanupOldLocks()\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown hook event: %s\", hookEvent)\n\t}\n\n\t// If status is unknown, skip\n\tif status == analyzer.StatusUnknown {\n\t\tlogging.Debug(\"Status is unknown, skipping notification\")\n\t\treturn nil\n\t}\n\n\t// Phase 2: Acquire lock before sending (per hook event type)\n\tacquired, err := h.dedupMgr.AcquireLock(hookData.SessionID, hookEvent)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to acquire lock: %w\", err)\n\t}\n\tif !acquired {\n\t\tlogging.Debug(\"Failed to acquire lock (duplicate), skipping\")\n\t\treturn nil\n\t}\n\n\tlogging.Debug(\"Lock acquired, proceeding with notification\")\n\t// Note: Lock is NOT released - it ages out naturally after 2s to prevent rapid duplicates\n\n\t// Check cooldown for question status BEFORE updating notification time\n\tif status == analyzer.StatusQuestion {\n\t\tlogging.Debug(\"Checking question cooldown: cooldownSeconds=%d\", h.cfg.Notifications.SuppressQuestionAfterAnyNotificationSeconds)\n\n\t\t// Load state to log its contents\n\t\tsessionState, stateErr := h.stateMgr.Load(hookData.SessionID)\n\t\tif stateErr != nil {\n\t\t\tlogging.Warn(\"Failed to load state for logging: %v\", stateErr)\n\t\t} else if sessionState != nil {\n\t\t\tlogging.Debug(\"Session state: lastNotificationTime=%d, lastNotificationStatus=%s\",\n\t\t\t\tsessionState.LastNotificationTime, sessionState.LastNotificationStatus)\n\t\t} else {\n\t\t\tlogging.Debug(\"No session state found\")\n\t\t}\n\n\t\t// First, check if we should suppress question after ANY notification (not just task_complete)\n\t\tsuppressAfterAny, err := h.stateMgr.ShouldSuppressQuestionAfterAnyNotification(\n\t\t\thookData.SessionID,\n\t\t\th.cfg.Notifications.SuppressQuestionAfterAnyNotificationSeconds,\n\t\t)\n\t\tif err != nil {\n\t\t\tlogging.Warn(\"Failed to check cooldown after any notification: %v\", err)\n\t\t} else if suppressAfterAny {\n\t\t\tlogging.Debug(\"Question suppressed due to recent notification from this session\")\n\t\t\t// Lock will be released by defer\n\t\t\treturn nil\n\t\t} else {\n\t\t\tlogging.Debug(\"Question NOT suppressed (cooldown check passed)\")\n\t\t}\n\n\t\t// Also check legacy cooldown after task_complete\n\t\tsuppress, err := h.stateMgr.ShouldSuppressQuestion(\n\t\t\thookData.SessionID,\n\t\t\th.cfg.Notifications.SuppressQuestionAfterTaskCompleteSeconds,\n\t\t)\n\t\tif err != nil {\n\t\t\tlogging.Warn(\"Failed to check cooldown: %v\", err)\n\t\t} else if suppress {\n\t\t\tlogging.Debug(\"Question suppressed due to cooldown after task complete\")\n\t\t\t// Lock will be released by defer\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Update state (only for task_complete, PreToolUse already updated state)\n\tif status == analyzer.StatusTaskComplete {\n\t\tif err := h.stateMgr.UpdateTaskComplete(hookData.SessionID); err != nil {\n\t\t\tlogging.Warn(\"Failed to update task complete state: %v\", err)\n\t\t}\n\t}\n\n\t// Generate message\n\tmessage := h.generateMessage(&hookData, status)\n\n\t// Acquire content lock to prevent race between different hooks (Stop vs Notification)\n\t// This ensures only one process can check and update duplicate state at a time\n\tcontentLockAcquired, err := h.dedupMgr.AcquireContentLock(hookData.SessionID)\n\tif err != nil {\n\t\tlogging.Warn(\"Failed to acquire content lock: %v\", err)\n\t\t// Error (not \"lock busy\") - continue without lock as fallback\n\t} else if !contentLockAcquired {\n\t\t// Lock is held by another process - it's already handling this notification\n\t\tlogging.Debug(\"Content lock held by another process, skipping to prevent duplicate\")\n\t\treturn nil\n\t}\n\n\t// Release lock on exit if acquired\n\tdefer func() {\n\t\tif contentLockAcquired {\n\t\t\tif err := h.dedupMgr.ReleaseContentLock(hookData.SessionID); err != nil {\n\t\t\t\tlogging.Warn(\"Failed to release content lock: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Check for duplicate message content (3 minutes = 180 seconds window)\n\tisDuplicate, err := h.stateMgr.IsDuplicateMessage(hookData.SessionID, message, 180)\n\tif err != nil {\n\t\tlogging.Warn(\"Failed to check duplicate message: %v\", err)\n\t} else if isDuplicate {\n\t\tlogging.Debug(\"Duplicate message content detected within 3 minutes, skipping\")\n\t\treturn nil\n\t}\n\n\t// Update last notification time and message\n\tif err := h.stateMgr.UpdateLastNotification(hookData.SessionID, status, message); err != nil {\n\t\tlogging.Warn(\"Failed to update last notification: %v\", err)\n\t}\n\n\t// Send notifications\n\th.sendNotifications(status, message, hookData.SessionID, hookData.CWD)\n\n\tlogging.Debug(\"=== Hook completed: %s ===\", hookEvent)\n\treturn nil\n}\n\n// handlePreToolUse handles PreToolUse hook\nfunc (h *Handler) handlePreToolUse(hookData *HookData) analyzer.Status {\n\tlogging.Debug(\"PreToolUse: tool_name='%s'\", hookData.ToolName)\n\n\tstatus := analyzer.GetStatusForPreToolUse(hookData.ToolName)\n\n\t// Write session state BEFORE returning (prevents race with Notification hook)\n\t// This matches bash version behavior: state is written BEFORE notification is sent\n\tif status == analyzer.StatusPlanReady || status == analyzer.StatusQuestion {\n\t\tif err := h.stateMgr.UpdateInteractiveTool(hookData.SessionID, hookData.ToolName, hookData.CWD); err != nil {\n\t\t\tlogging.Warn(\"Failed to update interactive tool state: %v\", err)\n\t\t} else {\n\t\t\tlogging.Debug(\"PreToolUse: session state written (tool=%s)\", hookData.ToolName)\n\t\t}\n\t}\n\n\treturn status\n}\n\n// handleNotificationEvent handles Notification hook\n// Always returns StatusQuestion as per design: Notification hook is triggered\n// when Claude needs user input (e.g., permission dialogs, questions)\nfunc (h *Handler) handleNotificationEvent(hookData *HookData) (analyzer.Status, error) {\n\tlogging.Debug(\"Notification event received â†’ question status\")\n\treturn analyzer.StatusQuestion, nil\n}\n\n// handleStopEvent handles Stop/SubagentStop hooks\nfunc (h *Handler) handleStopEvent(hookData *HookData) (analyzer.Status, error) {\n\tif hookData.TranscriptPath == \"\" {\n\t\tlogging.Warn(\"Transcript path is empty, skipping notification\")\n\t\treturn analyzer.StatusUnknown, nil\n\t}\n\n\tif !platform.FileExists(hookData.TranscriptPath) {\n\t\tlogging.Warn(\"Transcript file not found: %s\", hookData.TranscriptPath)\n\t\treturn analyzer.StatusUnknown, nil\n\t}\n\n\tstatus, err := analyzer.AnalyzeTranscript(hookData.TranscriptPath, h.cfg)\n\tif err != nil {\n\t\tlogging.Error(\"Failed to analyze transcript: %v\", err)\n\t\treturn analyzer.StatusUnknown, nil\n\t}\n\n\tlogging.Debug(\"Analyzed status: %s\", status)\n\treturn status, nil\n}\n\n// generateMessage generates a notification message\nfunc (h *Handler) generateMessage(hookData *HookData, status analyzer.Status) string {\n\tif hookData.TranscriptPath != \"\" && platform.FileExists(hookData.TranscriptPath) {\n\t\tmsg := summary.GenerateFromTranscript(hookData.TranscriptPath, status, h.cfg)\n\t\tif msg != \"\" {\n\t\t\treturn msg\n\t\t}\n\t}\n\n\treturn summary.GenerateSimple(status, h.cfg)\n}\n\n// sendNotifications sends desktop and webhook notifications\nfunc (h *Handler) sendNotifications(status analyzer.Status, message, sessionID, cwd string) {\n\t// Add panic recovery to prevent notification failures from crashing the plugin\n\tdefer errorhandler.HandlePanic()\n\n\t// Add session name, git branch and folder name to message\n\tsessionName := sessionname.GenerateSessionName(sessionID)\n\tgitBranch := platform.GetGitBranch(cwd)\n\tfolderName := filepath.Base(cwd)\n\n\t// Format: \"[session-name|branch folder] message\" or \"[session-name folder] message\"\n\tvar enhancedMessage string\n\tif gitBranch != \"\" {\n\t\tenhancedMessage = fmt.Sprintf(\"[%s|%s %s] %s\", sessionName, gitBranch, folderName, message)\n\t} else {\n\t\tenhancedMessage = fmt.Sprintf(\"[%s %s] %s\", sessionName, folderName, message)\n\t}\n\n\tlogging.Debug(\"Session name: %s, git branch: %s, folder: %s\", sessionName, gitBranch, folderName)\n\n\tstatusStr := string(status)\n\n\t// Send desktop notification (check per-status enabled)\n\tif h.cfg.IsStatusDesktopEnabled(statusStr) {\n\t\tif err := h.notifierSvc.SendDesktop(status, enhancedMessage); err != nil {\n\t\t\terrorhandler.HandleError(err, \"Failed to send desktop notification\")\n\t\t}\n\t} else {\n\t\tlogging.Debug(\"Desktop notification disabled for status: %s\", statusStr)\n\t}\n\n\t// Send webhook notification (async, check per-status enabled)\n\tif h.cfg.IsStatusWebhookEnabled(statusStr) {\n\t\th.webhookSvc.SendAsync(status, enhancedMessage, sessionID)\n\t} else {\n\t\tlogging.Debug(\"Webhook notification disabled for status: %s\", statusStr)\n\t}\n}\n\n// cleanupOldLocks cleans up old lock and state files but preserves session state for cooldown\nfunc (h *Handler) cleanupOldLocks() {\n\t// Cleanup old locks (older than 60 seconds)\n\tif err := h.dedupMgr.Cleanup(60); err != nil {\n\t\tlogging.Warn(\"Failed to cleanup old locks: %v\", err)\n\t}\n\n\t// Cleanup old state files (older than 60 seconds)\n\tif err := h.stateMgr.Cleanup(60); err != nil {\n\t\tlogging.Warn(\"Failed to cleanup old state files: %v\", err)\n\t}\n}\n",
        "internal/hooks/hooks_test.go": "package hooks\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/777genius/claude-notifications/internal/analyzer\"\n\t\"github.com/777genius/claude-notifications/internal/config\"\n\t\"github.com/777genius/claude-notifications/internal/dedup\"\n\t\"github.com/777genius/claude-notifications/internal/state\"\n\t\"github.com/777genius/claude-notifications/pkg/jsonl\"\n)\n\n// === Mock Notifier ===\n\ntype mockNotifier struct {\n\tmu         sync.Mutex\n\tcalls      []notificationCall\n\tshouldFail bool\n}\n\ntype notificationCall struct {\n\tstatus  analyzer.Status\n\tmessage string\n}\n\nfunc (m *mockNotifier) SendDesktop(status analyzer.Status, message string) error {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tm.calls = append(m.calls, notificationCall{\n\t\tstatus:  status,\n\t\tmessage: message,\n\t})\n\n\tif m.shouldFail {\n\t\treturn errors.New(\"mock error\")\n\t}\n\treturn nil\n}\n\nfunc (m *mockNotifier) Close() error {\n\treturn nil\n}\n\nfunc (m *mockNotifier) wasCalled() bool {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treturn len(m.calls) > 0\n}\n\nfunc (m *mockNotifier) callCount() int {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treturn len(m.calls)\n}\n\nfunc (m *mockNotifier) lastCall() *notificationCall {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tif len(m.calls) == 0 {\n\t\treturn nil\n\t}\n\treturn &m.calls[len(m.calls)-1]\n}\n\n// === Mock Webhook ===\n\ntype mockWebhook struct {\n\tmu              sync.Mutex\n\tcalls           []webhookCall\n\tshutdownCalled  bool\n\tshutdownTimeout time.Duration\n}\n\ntype webhookCall struct {\n\tstatus    analyzer.Status\n\tmessage   string\n\tsessionID string\n}\n\nfunc (m *mockWebhook) SendAsync(status analyzer.Status, message, sessionID string) {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\n\tm.calls = append(m.calls, webhookCall{\n\t\tstatus:    status,\n\t\tmessage:   message,\n\t\tsessionID: sessionID,\n\t})\n}\n\nfunc (m *mockWebhook) Shutdown(timeout time.Duration) error {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\tm.shutdownCalled = true\n\tm.shutdownTimeout = timeout\n\treturn nil\n}\n\nfunc (m *mockWebhook) Send(status analyzer.Status, message, sessionID string) error {\n\tm.SendAsync(status, message, sessionID)\n\treturn nil\n}\n\nfunc (m *mockWebhook) wasCalled() bool {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treturn len(m.calls) > 0\n}\n\nfunc (m *mockWebhook) wasShutdownCalled() bool {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treturn m.shutdownCalled\n}\n\nfunc (m *mockWebhook) getShutdownTimeout() time.Duration {\n\tm.mu.Lock()\n\tdefer m.mu.Unlock()\n\treturn m.shutdownTimeout\n}\n\n// === Test Helpers ===\n\nfunc buildHookDataJSON(data HookData) io.Reader {\n\tb, _ := json.Marshal(data)\n\treturn strings.NewReader(string(b))\n}\n\nfunc createTempTranscript(t *testing.T, messages []jsonl.Message) string {\n\tt.Helper()\n\n\ttmpDir := t.TempDir()\n\ttranscriptPath := filepath.Join(tmpDir, \"transcript.jsonl\")\n\n\tf, err := os.Create(transcriptPath)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create transcript: %v\", err)\n\t}\n\tdefer f.Close()\n\n\tencoder := json.NewEncoder(f)\n\tfor _, msg := range messages {\n\t\tif err := encoder.Encode(msg); err != nil {\n\t\t\tt.Fatalf(\"failed to encode message: %v\", err)\n\t\t}\n\t}\n\n\treturn transcriptPath\n}\n\nfunc buildTranscriptWithTools(tools []string, textLength int) []jsonl.Message {\n\tvar content []jsonl.Content\n\n\t// Add tools\n\tfor _, tool := range tools {\n\t\tcontent = append(content, jsonl.Content{\n\t\t\tType: \"tool_use\",\n\t\t\tName: tool,\n\t\t})\n\t}\n\n\t// Add text\n\ttext := strings.Repeat(\"a\", textLength)\n\tcontent = append(content, jsonl.Content{\n\t\tType: \"text\",\n\t\tText: text,\n\t})\n\n\treturn []jsonl.Message{\n\t\t{\n\t\t\tType: \"user\",\n\t\t\tMessage: jsonl.MessageContent{\n\t\t\t\tRole: \"user\",\n\t\t\t\tContent: []jsonl.Content{\n\t\t\t\t\t{Type: \"text\", Text: \"Test request\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTimestamp: \"2025-01-01T12:00:00Z\",\n\t\t},\n\t\t{\n\t\t\tType: \"assistant\",\n\t\t\tMessage: jsonl.MessageContent{\n\t\t\t\tRole:    \"assistant\",\n\t\t\t\tContent: content,\n\t\t\t},\n\t\t\tTimestamp: \"2025-01-01T12:00:01Z\",\n\t\t},\n\t}\n}\n\nfunc newTestHandler(t *testing.T, cfg *config.Config) (*Handler, *mockNotifier, *mockWebhook) {\n\tt.Helper()\n\n\t// Clear CLAUDE_HOOK_JUDGE_MODE by default for all tests\n\t// This ensures tests don't accidentally get affected by judge mode\n\t// Tests that need judge mode set should call t.Setenv AFTER calling newTestHandler\n\tt.Setenv(\"CLAUDE_HOOK_JUDGE_MODE\", \"\")\n\n\t// Cleanup state/lock files from previous test runs\n\t// This prevents duplicate detection issues on fast Go versions (1.25+)\n\t// where tests run faster than the 180-second duplicate window\n\ttestSessionPatterns := []string{\n\t\t\"claude-session-state-test-*.json\",\n\t\t\"claude-notification-test-*.lock\",\n\t\t\"claude-content-lock-test-*.lock\",\n\t}\n\ttempDir := os.TempDir()\n\tfor _, pattern := range testSessionPatterns {\n\t\tmatches, _ := filepath.Glob(filepath.Join(tempDir, pattern))\n\t\tfor _, f := range matches {\n\t\t\t_ = os.Remove(f)\n\t\t}\n\t}\n\n\tmockNotif := &mockNotifier{}\n\tmockWH := &mockWebhook{}\n\n\thandler := &Handler{\n\t\tcfg:         cfg,\n\t\tdedupMgr:    dedup.NewManager(),\n\t\tstateMgr:    state.NewManager(),\n\t\tnotifierSvc: mockNotif,\n\t\twebhookSvc:  mockWH,\n\t\tpluginRoot:  t.TempDir(),\n\t}\n\n\treturn handler, mockNotif, mockWH\n}\n\n// === Integration Tests ===\n\nfunc TestHandler_PreToolUse_ExitPlanMode(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"plan_ready\": {Title: \"Plan Ready\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-session-1\",\n\t\tToolName:  \"ExitPlanMode\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData)\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification to be sent\")\n\t}\n\n\tcall := mockNotif.lastCall()\n\tif call == nil {\n\t\tt.Fatal(\"no notification sent\")\n\t}\n\n\tif call.status != analyzer.StatusPlanReady {\n\t\tt.Errorf(\"got status %v, want StatusPlanReady\", call.status)\n\t}\n}\n\nfunc TestHandler_PreToolUse_AskUserQuestion(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"question\": {Title: \"Question\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-session-2\",\n\t\tToolName:  \"AskUserQuestion\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData)\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification to be sent\")\n\t}\n\n\tcall := mockNotif.lastCall()\n\tif call.status != analyzer.StatusQuestion {\n\t\tt.Errorf(\"got status %v, want StatusQuestion\", call.status)\n\t}\n}\n\nfunc TestHandler_Stop_ReviewComplete(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"review_complete\": {Title: \"Review Complete\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// Create transcript with Read tools + long text\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Read\", \"Read\", \"Grep\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-session-3\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification to be sent\")\n\t}\n\n\tcall := mockNotif.lastCall()\n\tif call.status != analyzer.StatusReviewComplete {\n\t\tt.Errorf(\"got status %v, want StatusReviewComplete\", call.status)\n\t}\n}\n\nfunc TestHandler_Stop_TaskComplete(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// Create transcript with active tools (Write/Edit)\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Read\", \"Edit\", \"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-session-4\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification to be sent\")\n\t}\n\n\tcall := mockNotif.lastCall()\n\tif call.status != analyzer.StatusTaskComplete {\n\t\tt.Errorf(\"got status %v, want StatusTaskComplete\", call.status)\n\t}\n}\n\nfunc TestHandler_Notification_SuppressedAfterExitPlanMode(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t\tSuppressQuestionAfterAnyNotificationSeconds: 60, // 60s suppression window\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"plan_ready\": {Title: \"Plan Ready\"},\n\t\t\t\"question\":   {Title: \"Question\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// 1. Send PreToolUse ExitPlanMode (writes session state)\n\thookData1 := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-session-5\",\n\t\tToolName:  \"ExitPlanMode\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData1)\n\tif err != nil {\n\t\tt.Fatalf(\"PreToolUse error: %v\", err)\n\t}\n\n\tinitialCalls := mockNotif.callCount()\n\n\t// 2. Send Notification hook within 60s (should be suppressed - same session!)\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"ExitPlanMode\"}, 300))\n\n\thookData2 := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-session-5\", // Same session ID\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\ttime.Sleep(100 * time.Millisecond) // Small delay\n\n\terr = handler.HandleHook(\"Notification\", hookData2)\n\tif err != nil {\n\t\tt.Fatalf(\"Notification error: %v\", err)\n\t}\n\n\t// Should not send duplicate notification\n\tif mockNotif.callCount() > initialCalls {\n\t\tt.Error(\"Notification should be suppressed after recent ExitPlanMode\")\n\t}\n}\n\n// === Deduplication Tests ===\n\nfunc TestHandler_EarlyDuplicateCheck(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"same-session\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\t// First call\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"first call error: %v\", err)\n\t}\n\n\tfirstCallCount := mockNotif.callCount()\n\n\t// Immediate second call (< 2s) should be suppressed by early duplicate check\n\ttime.Sleep(50 * time.Millisecond)\n\n\thookData2 := buildHookDataJSON(HookData{\n\t\tSessionID:      \"same-session\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr = handler.HandleHook(\"Stop\", hookData2)\n\tif err != nil {\n\t\tt.Fatalf(\"second call error: %v\", err)\n\t}\n\n\t// Should not send duplicate\n\tif mockNotif.callCount() > firstCallCount {\n\t\tt.Error(\"Duplicate hook should be suppressed by early check\")\n\t}\n}\n\n// === Cooldown Tests ===\n\nfunc TestHandler_QuestionCooldownAfterTaskComplete(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop:                                  config.DesktopConfig{Enabled: true},\n\t\t\tSuppressQuestionAfterTaskCompleteSeconds: 3,\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t\t\"question\":      {Title: \"Question\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// 1. Send task_complete\n\ttranscriptTask := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData1 := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-cooldown-1\",\n\t\tTranscriptPath: transcriptTask,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData1)\n\tif err != nil {\n\t\tt.Fatalf(\"task_complete error: %v\", err)\n\t}\n\n\tif !mockNotif.wasCalled() {\n\t\tt.Fatal(\"task_complete notification should be sent\")\n\t}\n\n\ttaskCallCount := mockNotif.callCount()\n\n\t// 2. Send question within cooldown (3s) - should be suppressed (same session!)\n\t// Wait to ensure state file is fully written and flushed\n\ttime.Sleep(200 * time.Millisecond)\n\n\thookData2 := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-cooldown-1\", // Same session ID\n\t\tCWD:       \"/test\",\n\t})\n\n\terr = handler.HandleHook(\"Notification\", hookData2)\n\tif err != nil {\n\t\tt.Fatalf(\"notification error: %v\", err)\n\t}\n\n\t// Should be suppressed\n\tif mockNotif.callCount() > taskCallCount {\n\t\tt.Errorf(\"Question should be suppressed within cooldown window, got %d calls, expected %d\",\n\t\t\tmockNotif.callCount(), taskCallCount)\n\t}\n\n\t// 3. Wait for cooldown to expire (3s total from task_complete)\n\ttime.Sleep(3 * time.Second)\n\n\t// Use same session ID - cooldown should have expired now\n\thookData3 := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-cooldown-1\", // Same session - cooldown expired\n\t\tCWD:       \"/test\",\n\t})\n\n\terr = handler.HandleHook(\"Notification\", hookData3)\n\tif err != nil {\n\t\tt.Fatalf(\"notification after cooldown error: %v\", err)\n\t}\n\n\t// Should go through after cooldown expires\n\tif mockNotif.callCount() <= taskCallCount {\n\t\tt.Errorf(\"Question should be sent after cooldown expires, got %d calls, expected > %d\",\n\t\t\tmockNotif.callCount(), taskCallCount)\n\t}\n}\n\n// === Error Handling Tests ===\n\nfunc TestHandler_InvalidJSON(t *testing.T) {\n\tcfg := &config.Config{}\n\thandler, _, _ := newTestHandler(t, cfg)\n\n\terr := handler.HandleHook(\"Stop\", strings.NewReader(\"invalid json\"))\n\n\tif err == nil {\n\t\tt.Error(\"expected error for invalid JSON\")\n\t}\n\n\tif !strings.Contains(err.Error(), \"failed to parse hook data\") {\n\t\tt.Errorf(\"unexpected error message: %v\", err)\n\t}\n}\n\nfunc TestHandler_MissingTranscriptFile(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, _, _ := newTestHandler(t, cfg)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-session-9\",\n\t\tTranscriptPath: \"/nonexistent/path.jsonl\",\n\t\tCWD:            \"/test\",\n\t})\n\n\t// Should handle gracefully (degrades, not fails)\n\terr := handler.HandleHook(\"Stop\", hookData)\n\n\tif err != nil {\n\t\tt.Errorf(\"should handle missing file gracefully, got error: %v\", err)\n\t}\n\n\t// May still send notification with default message\n\t// (depends on implementation - this is graceful degradation)\n}\n\nfunc TestHandler_EmptySessionID(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"plan_ready\": {Title: \"Plan Ready\"},\n\t\t},\n\t}\n\n\thandler, _, _ := newTestHandler(t, cfg)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID: \"\", // Empty\n\t\tToolName:  \"ExitPlanMode\",\n\t\tCWD:       \"/test\",\n\t})\n\n\t// Should handle gracefully (uses \"unknown\")\n\terr := handler.HandleHook(\"PreToolUse\", hookData)\n\n\tif err != nil {\n\t\tt.Errorf(\"should handle empty session ID gracefully, got error: %v\", err)\n\t}\n}\n\n// === Notification Disabled Tests ===\n\nfunc TestHandler_NotificationsDisabled(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: false},\n\t\t\tWebhook: config.WebhookConfig{Enabled: false},\n\t\t},\n\t}\n\n\thandler, mockNotif, mockWH := newTestHandler(t, cfg)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-session-10\",\n\t\tToolName:  \"ExitPlanMode\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData)\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\t// Should exit early without sending\n\tif mockNotif.wasCalled() {\n\t\tt.Error(\"should not send notification when disabled\")\n\t}\n\n\tif mockWH.wasCalled() {\n\t\tt.Error(\"should not send webhook when disabled\")\n\t}\n}\n\n// === SubagentStop Tests ===\n\nfunc TestHandler_SubagentStop_DisabledByDefault(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop:              config.DesktopConfig{Enabled: true},\n\t\t\tNotifyOnSubagentStop: false, // Default: no notifications for subagents\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-session-11\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"SubagentStop\", hookData)\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\t// Should NOT send notification when disabled\n\tif mockNotif.wasCalled() {\n\t\tt.Error(\"expected NO notification for SubagentStop (disabled by default)\")\n\t}\n}\n\nfunc TestHandler_SubagentStop_EnabledInConfig(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop:              config.DesktopConfig{Enabled: true},\n\t\t\tNotifyOnSubagentStop: true, // Explicitly enabled\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-session-12\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"SubagentStop\", hookData)\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\t// Should send notification when explicitly enabled\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification for SubagentStop (explicitly enabled)\")\n\t}\n}\n\n// === Unknown Hook Event ===\n\nfunc TestHandler_UnknownHookEvent(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\thandler, _, _ := newTestHandler(t, cfg)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-session-12\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"UnknownEvent\", hookData)\n\n\tif err == nil {\n\t\tt.Fatal(\"expected error for unknown hook event\")\n\t}\n\n\tif !strings.Contains(err.Error(), \"unknown hook event\") {\n\t\tt.Errorf(\"unexpected error message: %v\", err)\n\t}\n}\n\n// === Webhook Integration ===\n\nfunc TestHandler_SendsWebhookWhenEnabled(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t\tWebhook: config.WebhookConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, _, mockWH := newTestHandler(t, cfg)\n\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-session-13\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\ttime.Sleep(50 * time.Millisecond) // Webhook is async\n\n\tif !mockWH.wasCalled() {\n\t\tt.Error(\"expected webhook to be called when enabled\")\n\t}\n}\n\n// === NewHandler Constructor Tests ===\n\nfunc TestNewHandler_Success(t *testing.T) {\n\t// Create temp plugin root with valid config\n\ttmpDir := t.TempDir()\n\n\t// Create config directory and file (expected path: pluginRoot/config/config.json)\n\tconfigDir := filepath.Join(tmpDir, \"config\")\n\terr := os.MkdirAll(configDir, 0755)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create config dir: %v\", err)\n\t}\n\n\tconfigPath := filepath.Join(configDir, \"config.json\")\n\tconfigJSON := `{\n\t\t\"notifications\": {\n\t\t\t\"desktop\": {\"enabled\": true, \"sound\": true},\n\t\t\t\"webhook\": {\"enabled\": false}\n\t\t},\n\t\t\"statuses\": {\n\t\t\t\"task_complete\": {\"title\": \"Task Complete\"}\n\t\t}\n\t}`\n\n\terr = os.WriteFile(configPath, []byte(configJSON), 0644)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to write config: %v\", err)\n\t}\n\n\t// Create handler\n\thandler, err := NewHandler(tmpDir)\n\n\tif err != nil {\n\t\tt.Fatalf(\"NewHandler failed: %v\", err)\n\t}\n\n\tif handler == nil {\n\t\tt.Fatal(\"handler is nil\")\n\t}\n\n\t// Verify handler components\n\tif handler.cfg == nil {\n\t\tt.Error(\"handler.cfg is nil\")\n\t}\n\tif handler.dedupMgr == nil {\n\t\tt.Error(\"handler.dedupMgr is nil\")\n\t}\n\tif handler.stateMgr == nil {\n\t\tt.Error(\"handler.stateMgr is nil\")\n\t}\n\tif handler.notifierSvc == nil {\n\t\tt.Error(\"handler.notifierSvc is nil\")\n\t}\n\tif handler.webhookSvc == nil {\n\t\tt.Error(\"handler.webhookSvc is nil\")\n\t}\n\tif handler.pluginRoot != tmpDir {\n\t\tt.Errorf(\"handler.pluginRoot = %s, want %s\", handler.pluginRoot, tmpDir)\n\t}\n}\n\nfunc TestNewHandler_WithDefaultConfig(t *testing.T) {\n\t// Create empty plugin root (no config file)\n\ttmpDir := t.TempDir()\n\n\t// NewHandler should use default config\n\thandler, err := NewHandler(tmpDir)\n\n\tif err != nil {\n\t\tt.Fatalf(\"NewHandler with defaults failed: %v\", err)\n\t}\n\n\tif handler == nil {\n\t\tt.Fatal(\"handler is nil\")\n\t}\n\n\t// Verify default config was loaded\n\tif !handler.cfg.IsDesktopEnabled() {\n\t\tt.Error(\"expected desktop notifications enabled by default\")\n\t}\n}\n\nfunc TestNewHandler_InvalidConfig(t *testing.T) {\n\ttmpDir := t.TempDir()\n\n\t// Create config directory\n\tconfigDir := filepath.Join(tmpDir, \"config\")\n\terr := os.MkdirAll(configDir, 0755)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create config dir: %v\", err)\n\t}\n\n\t// Create invalid config (webhook enabled but no URL)\n\tconfigPath := filepath.Join(configDir, \"config.json\")\n\tconfigJSON := `{\n\t\t\"notifications\": {\n\t\t\t\"webhook\": {\n\t\t\t\t\"enabled\": true,\n\t\t\t\t\"preset\": \"slack\",\n\t\t\t\t\"url\": \"\"\n\t\t\t}\n\t\t}\n\t}`\n\n\terr = os.WriteFile(configPath, []byte(configJSON), 0644)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to write config: %v\", err)\n\t}\n\n\t// NewHandler should fail validation\n\thandler, err := NewHandler(tmpDir)\n\n\tif err == nil {\n\t\tt.Fatal(\"expected error for invalid config, got nil\")\n\t}\n\n\tif handler != nil {\n\t\tt.Error(\"expected handler to be nil on validation error\")\n\t}\n\n\tif !strings.Contains(err.Error(), \"invalid config\") {\n\t\tt.Errorf(\"unexpected error message: %v\", err)\n\t}\n}\n\nfunc TestNewHandler_MalformedJSON(t *testing.T) {\n\ttmpDir := t.TempDir()\n\n\t// Create config directory\n\tconfigDir := filepath.Join(tmpDir, \"config\")\n\terr := os.MkdirAll(configDir, 0755)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create config dir: %v\", err)\n\t}\n\n\t// Create malformed JSON config\n\tconfigPath := filepath.Join(configDir, \"config.json\")\n\terr = os.WriteFile(configPath, []byte(\"{ invalid json }\"), 0644)\n\tif err != nil {\n\t\tt.Fatalf(\"failed to write config: %v\", err)\n\t}\n\n\t// NewHandler should fail to load config\n\thandler, err := NewHandler(tmpDir)\n\n\tif err == nil {\n\t\tt.Fatal(\"expected error for malformed JSON, got nil\")\n\t}\n\n\tif handler != nil {\n\t\tt.Error(\"expected handler to be nil on load error\")\n\t}\n\n\tif !strings.Contains(err.Error(), \"failed to load config\") {\n\t\tt.Errorf(\"unexpected error message: %v\", err)\n\t}\n}\n\nfunc TestNewHandler_NonexistentPluginRoot(t *testing.T) {\n\t// Use nonexistent directory\n\tnonexistentDir := \"/nonexistent/plugin/root/path\"\n\n\t// NewHandler should still work (config will use defaults)\n\thandler, err := NewHandler(nonexistentDir)\n\n\tif err != nil {\n\t\tt.Fatalf(\"NewHandler with nonexistent root failed: %v\", err)\n\t}\n\n\tif handler == nil {\n\t\tt.Fatal(\"handler is nil\")\n\t}\n\n\t// Should use default config\n\tif !handler.cfg.IsDesktopEnabled() {\n\t\tt.Error(\"expected desktop notifications enabled by default\")\n\t}\n}\n\nfunc TestNewHandler_EmptyPluginRoot(t *testing.T) {\n\t// Empty string as plugin root\n\thandler, err := NewHandler(\"\")\n\n\tif err != nil {\n\t\tt.Fatalf(\"NewHandler with empty root failed: %v\", err)\n\t}\n\n\tif handler == nil {\n\t\tt.Fatal(\"handler is nil\")\n\t}\n\n\t// Should use default config\n\tif !handler.cfg.IsDesktopEnabled() {\n\t\tt.Error(\"expected desktop notifications enabled by default\")\n\t}\n}\n\n// === Cleanup Tests ===\n\nfunc TestCleanupOldLocks_Success(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, _, _ := newTestHandler(t, cfg)\n\n\t// Call cleanupOldLocks - should not panic\n\thandler.cleanupOldLocks()\n\n\t// Verify handler is still functional after cleanup\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-after-cleanup\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"Handler should work after cleanup: %v\", err)\n\t}\n}\n\nfunc TestHandleStopEvent_EmptyTranscriptPath(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, _, _ := newTestHandler(t, cfg)\n\n\t// Send Stop hook with empty TranscriptPath\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-empty-transcript\",\n\t\tTranscriptPath: \"\", // Empty\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\n\t// Should handle gracefully (no error)\n\tif err != nil {\n\t\tt.Errorf(\"should handle empty transcript gracefully, got error: %v\", err)\n\t}\n\n\t// May or may not send notification (depends on fallback behavior)\n\t// But should not crash\n}\n\nfunc TestHandleStopEvent_NonexistentTranscriptFile(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, _, _ := newTestHandler(t, cfg)\n\n\t// Send Stop hook with nonexistent transcript file\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-nonexistent-transcript\",\n\t\tTranscriptPath: \"/nonexistent/path/transcript.jsonl\",\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\n\t// Should handle gracefully (no error, graceful degradation)\n\tif err != nil {\n\t\tt.Errorf(\"should handle nonexistent transcript gracefully, got error: %v\", err)\n\t}\n}\n\n// === Background Judge Mode Tests (double-shot-latte compatibility) ===\n\n// TestHandler_SkipsNotificationsInJudgeMode verifies that notifications are\n// suppressed when CLAUDE_HOOK_JUDGE_MODE=true (set by double-shot-latte plugin\n// when running background Claude instances for context evaluation)\nfunc TestHandler_SkipsNotificationsInJudgeMode(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t\tWebhook: config.WebhookConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t\t\"plan_ready\":    {Title: \"Plan Ready\"},\n\t\t\t\"question\":      {Title: \"Question\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, mockWH := newTestHandler(t, cfg)\n\n\t// Set the judge mode environment variable AFTER creating handler\n\t// (newTestHandler clears it by default, so we override here)\n\tt.Setenv(\"CLAUDE_HOOK_JUDGE_MODE\", \"true\")\n\n\t// Test PreToolUse hook\n\thookData1 := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-judge-mode-1\",\n\t\tToolName:  \"ExitPlanMode\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData1)\n\tif err != nil {\n\t\tt.Fatalf(\"PreToolUse error: %v\", err)\n\t}\n\n\tif mockNotif.wasCalled() {\n\t\tt.Error(\"expected NO notification in judge mode (PreToolUse)\")\n\t}\n\n\t// Test Stop hook\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData2 := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-judge-mode-2\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr = handler.HandleHook(\"Stop\", hookData2)\n\tif err != nil {\n\t\tt.Fatalf(\"Stop error: %v\", err)\n\t}\n\n\tif mockNotif.wasCalled() {\n\t\tt.Error(\"expected NO notification in judge mode (Stop)\")\n\t}\n\n\tif mockWH.wasCalled() {\n\t\tt.Error(\"expected NO webhook in judge mode\")\n\t}\n}\n\n// TestHandler_SendsNotificationsWhenJudgeModeNotSet verifies that notifications\n// work normally when CLAUDE_HOOK_JUDGE_MODE is not set\nfunc TestHandler_SendsNotificationsWhenJudgeModeNotSet(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"plan_ready\": {Title: \"Plan Ready\"},\n\t\t},\n\t}\n\n\t// newTestHandler already clears CLAUDE_HOOK_JUDGE_MODE by default\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-no-judge-mode\",\n\t\tToolName:  \"ExitPlanMode\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"PreToolUse error: %v\", err)\n\t}\n\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification when judge mode is NOT set\")\n\t}\n}\n\n// TestHandler_SendsNotificationsWhenJudgeModeFalse verifies that notifications\n// work normally when CLAUDE_HOOK_JUDGE_MODE is set to something other than \"true\"\nfunc TestHandler_SendsNotificationsWhenJudgeModeFalse(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"plan_ready\": {Title: \"Plan Ready\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// Set env var to \"false\" AFTER handler creation - should NOT suppress notifications\n\tt.Setenv(\"CLAUDE_HOOK_JUDGE_MODE\", \"false\")\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-judge-mode-false\",\n\t\tToolName:  \"ExitPlanMode\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"PreToolUse error: %v\", err)\n\t}\n\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification when judge mode is 'false'\")\n\t}\n}\n\n// TestHandleHookCallsWebhookShutdown verifies that HandleHook calls\n// webhookSvc.Shutdown() in defer to ensure graceful shutdown of async requests\nfunc TestHandleHookCallsWebhookShutdown(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: false},\n\t\t\tWebhook: config.WebhookConfig{Enabled: true},\n\t\t},\n\t}\n\n\thandler, _, mockWH := newTestHandler(t, cfg)\n\n\t// Create transcript file with Stop event\n\ttranscript := []jsonl.Message{\n\t\t{\n\t\t\tType: \"assistant\",\n\t\t\tMessage: jsonl.MessageContent{\n\t\t\t\tRole: \"assistant\",\n\t\t\t\tContent: []jsonl.Content{\n\t\t\t\t\t{Type: \"text\", Text: \"Task completed\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tTimestamp: \"2025-01-01T12:00:00Z\",\n\t\t},\n\t}\n\ttranscriptFile := createTempTranscript(t, transcript)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-shutdown-session\",\n\t\tTranscriptPath: transcriptFile,\n\t\tCWD:            \"/test\",\n\t})\n\n\t// Call HandleHook - this should call Shutdown() in defer\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"HandleHook failed: %v\", err)\n\t}\n\n\t// Verify that Shutdown was called\n\tif !mockWH.wasShutdownCalled() {\n\t\tt.Error(\"expected webhookSvc.Shutdown() to be called in defer, but it wasn't\")\n\t}\n\n\t// Verify that Shutdown was called with correct timeout (5 seconds)\n\texpectedTimeout := 5 * time.Second\n\tactualTimeout := mockWH.getShutdownTimeout()\n\tif actualTimeout != expectedTimeout {\n\t\tt.Errorf(\"expected Shutdown timeout %v, got %v\", expectedTimeout, actualTimeout)\n\t}\n}\n\n// === Per-Status Enabled Tests ===\n\nfunc boolPtr(b bool) *bool {\n\treturn &b\n}\n\n// TestHandler_StatusDisabled_SkipsDesktopNotification verifies that when a status\n// is disabled in config, desktop notifications are not sent for that status\nfunc TestHandler_StatusDisabled_SkipsDesktopNotification(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {\n\t\t\t\tEnabled: boolPtr(false), // Disabled!\n\t\t\t\tTitle:   \"Task Complete\",\n\t\t\t},\n\t\t\t\"review_complete\": {\n\t\t\t\t// Enabled: nil means enabled by default\n\t\t\t\tTitle: \"Review Complete\",\n\t\t\t},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// Create transcript with active tools (Write/Edit) - should trigger task_complete\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-status-disabled-1\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\t// Should NOT send notification because task_complete is disabled\n\tif mockNotif.wasCalled() {\n\t\tt.Error(\"expected NO notification for disabled status (task_complete)\")\n\t}\n}\n\n// TestHandler_StatusEnabled_SendsDesktopNotification verifies that when a status\n// is explicitly enabled, desktop notifications are sent\nfunc TestHandler_StatusEnabled_SendsDesktopNotification(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {\n\t\t\t\tEnabled: boolPtr(true), // Explicitly enabled\n\t\t\t\tTitle:   \"Task Complete\",\n\t\t\t},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-status-enabled-1\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\t// Should send notification\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification for enabled status (task_complete)\")\n\t}\n}\n\n// TestHandler_StatusDisabled_SkipsWebhookNotification verifies that when a status\n// is disabled, webhook notifications are also not sent for that status\nfunc TestHandler_StatusDisabled_SkipsWebhookNotification(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t\tWebhook: config.WebhookConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {\n\t\t\t\tEnabled: boolPtr(false), // Disabled!\n\t\t\t\tTitle:   \"Task Complete\",\n\t\t\t},\n\t\t},\n\t}\n\n\thandler, mockNotif, mockWH := newTestHandler(t, cfg)\n\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-status-disabled-webhook-1\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\t// Should NOT send desktop notification\n\tif mockNotif.wasCalled() {\n\t\tt.Error(\"expected NO desktop notification for disabled status\")\n\t}\n\n\t// Should NOT send webhook notification\n\tif mockWH.wasCalled() {\n\t\tt.Error(\"expected NO webhook notification for disabled status\")\n\t}\n}\n\n// TestHandler_StatusNilEnabled_SendsNotification verifies backward compatibility:\n// when enabled field is nil (not specified), notifications should be sent\nfunc TestHandler_StatusNilEnabled_SendsNotification(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {\n\t\t\t\t// Enabled: nil - not specified, should default to true\n\t\t\t\tTitle: \"Task Complete\",\n\t\t\t},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\ttranscriptPath := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-status-nil-enabled-1\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\t// Should send notification (nil = enabled by default)\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification when enabled is nil (backward compatibility)\")\n\t}\n}\n\n// TestHandler_PreToolUse_StatusDisabled verifies that PreToolUse hooks respect\n// per-status enabled setting\nfunc TestHandler_PreToolUse_StatusDisabled(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"plan_ready\": {\n\t\t\t\tEnabled: boolPtr(false), // Disabled!\n\t\t\t\tTitle:   \"Plan Ready\",\n\t\t\t},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID: \"test-pretool-disabled-1\",\n\t\tToolName:  \"ExitPlanMode\",\n\t\tCWD:       \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t}\n\n\t// Should NOT send notification because plan_ready is disabled\n\tif mockNotif.wasCalled() {\n\t\tt.Error(\"expected NO notification for disabled status (plan_ready)\")\n\t}\n}\n\n// TestHandler_MixedStatusEnabled verifies that different statuses can have\n// different enabled settings\nfunc TestHandler_MixedStatusEnabled(t *testing.T) {\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {\n\t\t\t\tEnabled: boolPtr(false), // Disabled\n\t\t\t\tTitle:   \"Task Complete\",\n\t\t\t},\n\t\t\t\"review_complete\": {\n\t\t\t\tEnabled: boolPtr(true), // Enabled\n\t\t\t\tTitle:   \"Review Complete\",\n\t\t\t},\n\t\t\t\"question\": {\n\t\t\t\t// nil - default enabled\n\t\t\t\tTitle: \"Question\",\n\t\t\t},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// Test 1: task_complete (disabled) - should NOT notify\n\ttranscriptTask := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Write\"}, 300))\n\n\thookData1 := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-mixed-1\",\n\t\tTranscriptPath: transcriptTask,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData1)\n\tif err != nil {\n\t\tt.Fatalf(\"task_complete error: %v\", err)\n\t}\n\n\tif mockNotif.wasCalled() {\n\t\tt.Error(\"expected NO notification for disabled task_complete\")\n\t}\n\n\t// Test 2: review_complete (enabled) - should notify\n\ttranscriptReview := createTempTranscript(t,\n\t\tbuildTranscriptWithTools([]string{\"Read\", \"Grep\"}, 300))\n\n\thookData2 := buildHookDataJSON(HookData{\n\t\tSessionID:      \"test-mixed-2\",\n\t\tTranscriptPath: transcriptReview,\n\t\tCWD:            \"/test\",\n\t})\n\n\terr = handler.HandleHook(\"Stop\", hookData2)\n\tif err != nil {\n\t\tt.Fatalf(\"review_complete error: %v\", err)\n\t}\n\n\tif !mockNotif.wasCalled() {\n\t\tt.Error(\"expected notification for enabled review_complete\")\n\t}\n}\n",
        "internal/hooks/integration_test.go": "//go:build integration\n// +build integration\n\npackage hooks\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/777genius/claude-notifications/internal/analyzer\"\n\t\"github.com/777genius/claude-notifications/internal/config\"\n\t\"github.com/777genius/claude-notifications/internal/dedup\"\n\t\"github.com/777genius/claude-notifications/internal/state\"\n\t\"github.com/777genius/claude-notifications/internal/webhook\"\n)\n\n// === E2E Test: Full Notification Cycle ===\n// Tests: PreToolUse â†’ Notification â†’ Stop with state management\n\nfunc TestE2E_FullNotificationCycle(t *testing.T) {\n\t// Setup: create plugin root with config\n\tpluginRoot := t.TempDir()\n\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t\tWebhook: config.WebhookConfig{Enabled: false},\n\t\t\tSuppressQuestionAfterAnyNotificationSeconds: 5, // 5s suppression window\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"plan_ready\":    {Title: \"Plan Ready\"},\n\t\t\t\"question\":      {Title: \"Question\"},\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\t// Create handler with mock notifier\n\tmockNotif := &mockNotifier{}\n\tmockWH := &mockWebhook{}\n\n\thandler := &Handler{\n\t\tcfg:         cfg,\n\t\tdedupMgr:    newTempDedupManager(t),\n\t\tstateMgr:    newTempStateManager(t),\n\t\tnotifierSvc: mockNotif,\n\t\twebhookSvc:  mockWH,\n\t\tpluginRoot:  pluginRoot,\n\t}\n\n\tsessionID := \"e2e-test-session-1\"\n\n\t// === PHASE 1: PreToolUse ExitPlanMode ===\n\tt.Log(\"Phase 1: PreToolUse ExitPlanMode\")\n\n\thookData1 := buildHookDataJSON(HookData{\n\t\tSessionID:     sessionID,\n\t\tToolName:      \"ExitPlanMode\",\n\t\tCWD:           \"/test\",\n\t\tHookEventName: \"PreToolUse\",\n\t})\n\n\terr := handler.HandleHook(\"PreToolUse\", hookData1)\n\tif err != nil {\n\t\tt.Fatalf(\"PreToolUse failed: %v\", err)\n\t}\n\n\t// Verify: plan_ready notification sent\n\tif !mockNotif.wasCalled() {\n\t\tt.Fatal(\"Expected plan_ready notification\")\n\t}\n\tcall1 := mockNotif.lastCall()\n\tif call1.status != analyzer.StatusPlanReady {\n\t\tt.Errorf(\"Expected StatusPlanReady, got %v\", call1.status)\n\t}\n\n\tinitialCallCount := mockNotif.callCount()\n\tt.Logf(\"âœ“ Phase 1 complete: plan_ready sent (%d notifications)\", initialCallCount)\n\n\t// === PHASE 2: Notification hook (within suppression window) ===\n\tt.Log(\"Phase 2: Notification hook (should be suppressed)\")\n\n\ttime.Sleep(100 * time.Millisecond) // Small delay\n\n\thookData2 := buildHookDataJSON(HookData{\n\t\tSessionID:      sessionID,\n\t\tTranscriptPath: \"\",\n\t\tCWD:            \"/test\",\n\t\tHookEventName:  \"Notification\",\n\t})\n\n\terr = handler.HandleHook(\"Notification\", hookData2)\n\tif err != nil {\n\t\tt.Fatalf(\"Notification hook failed: %v\", err)\n\t}\n\n\t// Verify: question notification was suppressed\n\tif mockNotif.callCount() > initialCallCount {\n\t\tt.Errorf(\"Question should be suppressed, but notification was sent\")\n\t}\n\tt.Logf(\"âœ“ Phase 2 complete: question suppressed correctly\")\n\n\t// === PHASE 3: Wait for suppression window to expire ===\n\tt.Log(\"Phase 3: Wait for suppression to expire...\")\n\ttime.Sleep(6 * time.Second) // Wait past 5s suppression\n\n\t// Send Notification again (should now work)\n\thookData3 := buildHookDataJSON(HookData{\n\t\tSessionID:      \"different-session\", // Different session to avoid dedup\n\t\tTranscriptPath: \"\",\n\t\tCWD:            \"/test\",\n\t\tHookEventName:  \"Notification\",\n\t})\n\n\terr = handler.HandleHook(\"Notification\", hookData3)\n\tif err != nil {\n\t\tt.Fatalf(\"Notification hook after cooldown failed: %v\", err)\n\t}\n\n\t// Verify: question notification sent\n\tafterCooldownCount := mockNotif.callCount()\n\tif afterCooldownCount <= initialCallCount {\n\t\tt.Logf(\"WARNING: Question not sent after cooldown (count: %d, initial: %d)\", afterCooldownCount, initialCallCount)\n\t\t// This may be OK if deduplication is working - different session should bypass suppression\n\t}\n\tt.Logf(\"âœ“ Phase 3 complete: notification count after cooldown = %d\", mockNotif.callCount())\n\n\t// === PHASE 4: Stop hook with task_complete ===\n\tt.Log(\"Phase 4: Stop hook\")\n\n\t// Create transcript with task completion\n\ttranscript := buildTranscriptWithTools([]string{\"Write\", \"Edit\"}, 300)\n\ttranscriptPath := createTempTranscript(t, transcript)\n\n\thookData4 := buildHookDataJSON(HookData{\n\t\tSessionID:      sessionID,\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t\tHookEventName:  \"Stop\",\n\t})\n\n\terr = handler.HandleHook(\"Stop\", hookData4)\n\tif err != nil {\n\t\tt.Fatalf(\"Stop hook failed: %v\", err)\n\t}\n\n\t// Verify: task_complete notification sent\n\tfinalCallCount := mockNotif.callCount()\n\texpectedMin := 2 // At least plan_ready + task_complete\n\tif finalCallCount < expectedMin {\n\t\tt.Errorf(\"Expected at least %d notifications, got %d\", expectedMin, finalCallCount)\n\t}\n\n\tlastCall := mockNotif.lastCall()\n\tif lastCall == nil {\n\t\tt.Fatal(\"No notifications sent\")\n\t}\n\tif lastCall.status != analyzer.StatusTaskComplete {\n\t\tt.Errorf(\"Last notification: expected StatusTaskComplete, got %v\", lastCall.status)\n\t}\n\tt.Logf(\"âœ“ Phase 4 complete: task_complete sent (call #%d)\", finalCallCount)\n\n\t// === PHASE 5: Verify cleanup ===\n\tt.Log(\"Phase 5: Verify state cleanup\")\n\n\t// State files should be cleaned up\n\t// (In real implementation, Stop hook calls cleanupSession)\n\t// We can verify by checking that state manager doesn't return stale data\n\n\tt.Logf(\"âœ“ E2E test complete: Full cycle worked correctly\")\n\tt.Logf(\"  Total notifications: %d\", finalCallCount)\n\tt.Logf(\"  - plan_ready: 1\")\n\tt.Logf(\"  - question: 1 (after cooldown)\")\n\tt.Logf(\"  - task_complete: 1\")\n}\n\n// === E2E Test: Webhook with Retry ===\n// Tests: Real HTTP calls with retry logic\n\nfunc TestE2E_WebhookRetry(t *testing.T) {\n\tt.Log(\"Starting E2E Webhook Retry test\")\n\n\t// Create test webhook server that fails first 2 attempts\n\tattemptCount := atomic.Int32{}\n\trequests := []*http.Request{}\n\tmu := sync.Mutex{}\n\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tcount := attemptCount.Add(1)\n\n\t\tmu.Lock()\n\t\trequests = append(requests, r)\n\t\tmu.Unlock()\n\n\t\tt.Logf(\"Webhook attempt #%d\", count)\n\n\t\tif count < 3 {\n\t\t\t// Fail first 2 attempts\n\t\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\t\tw.Write([]byte(\"Service temporarily unavailable\"))\n\t\t\treturn\n\t\t}\n\n\t\t// Success on 3rd attempt\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write([]byte(\"OK\"))\n\t}))\n\tdefer server.Close()\n\n\t// Create config with webhook retry\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: false},\n\t\t\tWebhook: config.WebhookConfig{\n\t\t\t\tEnabled: true,\n\t\t\t\tURL:     server.URL,\n\t\t\t\tFormat:  \"json\",\n\t\t\t\tRetry: config.RetryConfig{\n\t\t\t\t\tEnabled:        true,\n\t\t\t\t\tMaxAttempts:    5,\n\t\t\t\t\tInitialBackoff: \"10ms\",\n\t\t\t\t\tMaxBackoff:     \"100ms\",\n\t\t\t\t},\n\t\t\t\tCircuitBreaker: config.CircuitBreakerConfig{\n\t\t\t\t\tEnabled: false, // Disable for this test\n\t\t\t\t},\n\t\t\t\tRateLimit: config.RateLimitConfig{\n\t\t\t\t\tEnabled: false, // Disable for this test\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\t// Create handler - use mock notifier but real webhook\n\tpluginRoot := t.TempDir()\n\tmockNotif := &mockNotifier{}\n\n\thandler := &Handler{\n\t\tcfg:         cfg,\n\t\tdedupMgr:    newTempDedupManager(t),\n\t\tstateMgr:    newTempStateManager(t),\n\t\tnotifierSvc: mockNotif,\n\t\twebhookSvc:  webhook.New(cfg), // Real webhook sender\n\t\tpluginRoot:  pluginRoot,\n\t}\n\n\t// Create transcript\n\ttranscript := buildTranscriptWithTools([]string{\"Write\"}, 200)\n\ttranscriptPath := createTempTranscript(t, transcript)\n\n\t// Send Stop hook\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"webhook-test-session\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t\tHookEventName:  \"Stop\",\n\t})\n\n\tstart := time.Now()\n\terr := handler.HandleHook(\"Stop\", hookData)\n\telapsed := time.Since(start)\n\n\tif err != nil {\n\t\tt.Fatalf(\"HandleHook failed: %v\", err)\n\t}\n\n\tt.Logf(\"âœ“ Hook completed in %v\", elapsed)\n\n\t// NO time.Sleep needed! Shutdown() in defer waits for webhook completion\n\t// If this test fails, it means Shutdown() is not working correctly\n\n\t// Verify: exactly 3 attempts (should already be done after HandleHook returns)\n\tfinalAttempts := attemptCount.Load()\n\tif finalAttempts != 3 {\n\t\tt.Errorf(\"Expected 3 attempts, got %d\", finalAttempts)\n\t}\n\n\t// Verify: all requests had correct headers\n\tmu.Lock()\n\tdefer mu.Unlock()\n\n\tif len(requests) != 3 {\n\t\tt.Errorf(\"Expected 3 requests captured, got %d\", len(requests))\n\t}\n\n\tfor i, req := range requests {\n\t\t// Check User-Agent\n\t\tif req.Header.Get(\"User-Agent\") != \"claude-notifications/1.0\" {\n\t\t\tt.Errorf(\"Request %d: wrong User-Agent: %s\", i+1, req.Header.Get(\"User-Agent\"))\n\t\t}\n\n\t\t// Check X-Request-ID exists\n\t\tif req.Header.Get(\"X-Request-ID\") == \"\" {\n\t\t\tt.Errorf(\"Request %d: missing X-Request-ID\", i+1)\n\t\t}\n\n\t\t// Check Content-Type\n\t\tif req.Header.Get(\"Content-Type\") != \"application/json\" {\n\t\t\tt.Errorf(\"Request %d: wrong Content-Type: %s\", i+1, req.Header.Get(\"Content-Type\"))\n\t\t}\n\t}\n\n\tt.Logf(\"âœ“ E2E Webhook Retry test complete\")\n\tt.Logf(\"  Attempts: %d (expected 3)\", finalAttempts)\n\tt.Logf(\"  Elapsed: %v\", elapsed)\n}\n\n// === E2E Test: Concurrent Sessions ===\n// Tests: Multiple sessions running in parallel\n\nfunc TestE2E_ConcurrentSessions(t *testing.T) {\n\tt.Log(\"Starting E2E Concurrent Sessions test\")\n\n\tpluginRoot := t.TempDir()\n\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t\tWebhook: config.WebhookConfig{Enabled: false},\n\t\t\tSuppressQuestionAfterAnyNotificationSeconds: 0, // Disabled for concurrent test\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"plan_ready\":    {Title: \"Plan Ready\"},\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t\t\"question\":      {Title: \"Question\"},\n\t\t},\n\t}\n\n\tmockNotif := &mockNotifier{}\n\tmockWH := &mockWebhook{}\n\n\thandler := &Handler{\n\t\tcfg:         cfg,\n\t\tdedupMgr:    newTempDedupManager(t),\n\t\tstateMgr:    newTempStateManager(t),\n\t\tnotifierSvc: mockNotif,\n\t\twebhookSvc:  mockWH,\n\t\tpluginRoot:  pluginRoot,\n\t}\n\n\tvar wg sync.WaitGroup\n\n\t// Launch 3 concurrent sessions\n\tsessions := []string{\"session-A\", \"session-B\", \"session-C\"}\n\n\tfor _, sessionID := range sessions {\n\t\twg.Add(1)\n\t\tgo func(sid string) {\n\t\t\tdefer wg.Done()\n\n\t\t\t// Each session: PreToolUse â†’ Stop\n\t\t\thookData1 := buildHookDataJSON(HookData{\n\t\t\t\tSessionID: sid,\n\t\t\t\tToolName:  \"ExitPlanMode\",\n\t\t\t\tCWD:       \"/test\",\n\t\t\t})\n\n\t\t\terr := handler.HandleHook(\"PreToolUse\", hookData1)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Session %s PreToolUse failed: %v\", sid, err)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\n\t\t\ttranscript := buildTranscriptWithTools([]string{\"Write\"}, 200)\n\t\t\ttranscriptPath := createTempTranscript(t, transcript)\n\n\t\t\thookData2 := buildHookDataJSON(HookData{\n\t\t\t\tSessionID:      sid,\n\t\t\t\tTranscriptPath: transcriptPath,\n\t\t\t\tCWD:            \"/test\",\n\t\t\t})\n\n\t\t\terr = handler.HandleHook(\"Stop\", hookData2)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Session %s Stop failed: %v\", sid, err)\n\t\t\t}\n\t\t}(sessionID)\n\t}\n\n\t// Wait for all sessions\n\twg.Wait()\n\n\t// Verify: 6 total notifications (2 per session)\n\ttotalNotifications := mockNotif.callCount()\n\texpectedMin := 6 // Each session: plan_ready + task_complete\n\n\tif totalNotifications < expectedMin {\n\t\tt.Errorf(\"Expected at least %d notifications, got %d\", expectedMin, totalNotifications)\n\t}\n\n\tt.Logf(\"âœ“ E2E Concurrent Sessions test complete\")\n\tt.Logf(\"  Sessions: %d\", len(sessions))\n\tt.Logf(\"  Total notifications: %d\", totalNotifications)\n}\n\n// === Helper Functions ===\n\n// newTempDedupManager creates a dedup manager with temp directory\nfunc newTempDedupManager(t *testing.T) *dedup.Manager {\n\tt.Helper()\n\t// Dedup manager uses temp dir automatically\n\treturn dedup.NewManager()\n}\n\n// newTempStateManager creates a state manager with temp directory\nfunc newTempStateManager(t *testing.T) *state.Manager {\n\tt.Helper()\n\t// State manager uses temp dir automatically\n\treturn state.NewManager()\n}\n\n// === E2E Test: Code Review Workflow ===\n// Tests: Real-world code review scenario\n\nfunc TestE2E_CodeReviewWorkflow(t *testing.T) {\n\tt.Log(\"Starting E2E Code Review Workflow test\")\n\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t\tWebhook: config.WebhookConfig{Enabled: false},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"review_complete\": {Title: \"Review Complete\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// Simulate code review: Read + Read + Grep (analyze multiple files)\n\ttranscript := buildTranscriptWithTools(\n\t\t[]string{\"Read\", \"Read\", \"Grep\", \"Read\"},\n\t\t300,\n\t)\n\ttranscriptPath := createTempTranscript(t, transcript)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"review-session-1\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/project/auth\",\n\t\tHookEventName:  \"Stop\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"Stop hook failed: %v\", err)\n\t}\n\n\t// Verify notification sent\n\tif !mockNotif.wasCalled() {\n\t\tt.Fatal(\"Expected review_complete notification\")\n\t}\n\n\tcall := mockNotif.lastCall()\n\tif call.status != analyzer.StatusReviewComplete {\n\t\tt.Errorf(\"Expected StatusReviewComplete, got %v\", call.status)\n\t}\n\n\t// Message should mention review/analysis\n\tif !contains(call.message, \"review\") && !contains(call.message, \"Reviewed\") {\n\t\tt.Logf(\"INFO: Review message: %s\", call.message)\n\t\t// Not critical - just log\n\t}\n\n\tt.Logf(\"âœ“ E2E Code Review Workflow complete\")\n\tt.Logf(\"  Status: %v\", call.status)\n\tt.Logf(\"  Message: %s\", call.message)\n}\n\n// === E2E Test: Fix and Test Workflow ===\n// Tests: Fix bug + run tests scenario\n\nfunc TestE2E_FixAndTestWorkflow(t *testing.T) {\n\tt.Log(\"Starting E2E Fix and Test Workflow test\")\n\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: true},\n\t\t\tWebhook: config.WebhookConfig{Enabled: false},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\thandler, mockNotif, _ := newTestHandler(t, cfg)\n\n\t// Simulate fix: Read + Edit + Edit + Bash (fix files and run tests)\n\ttranscript := buildTranscriptWithTools(\n\t\t[]string{\"Read\", \"Edit\", \"Edit\", \"Bash\"},\n\t\t300,\n\t)\n\ttranscriptPath := createTempTranscript(t, transcript)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"fix-session-1\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/project\",\n\t\tHookEventName:  \"Stop\",\n\t})\n\n\terr := handler.HandleHook(\"Stop\", hookData)\n\tif err != nil {\n\t\tt.Fatalf(\"Stop hook failed: %v\", err)\n\t}\n\n\t// Verify notification sent\n\tif !mockNotif.wasCalled() {\n\t\tt.Fatal(\"Expected task_complete notification\")\n\t}\n\n\tcall := mockNotif.lastCall()\n\tif call.status != analyzer.StatusTaskComplete {\n\t\tt.Errorf(\"Expected StatusTaskComplete, got %v\", call.status)\n\t}\n\n\t// Message should mention edits and command\n\tif !contains(call.message, \"Edited\") && !contains(call.message, \"Ran\") {\n\t\tt.Logf(\"INFO: Task message might not include action summary: %s\", call.message)\n\t\t// Not critical - implementation may vary\n\t}\n\n\tt.Logf(\"âœ“ E2E Fix and Test Workflow complete\")\n\tt.Logf(\"  Status: %v\", call.status)\n\tt.Logf(\"  Message: %s\", call.message)\n}\n\n// === E2E Test: Webhook Graceful Shutdown ===\n// Tests: HandleHook waits for webhook completion via Shutdown() in defer\n// This test verifies Issue #6 fix - no time.Sleep, deterministic\n\nfunc TestE2E_WebhookGracefulShutdown(t *testing.T) {\n\tt.Log(\"Starting E2E Webhook Graceful Shutdown test\")\n\n\trequestReceived := atomic.Bool{}\n\trequestDelay := 200 * time.Millisecond\n\n\tserver := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tt.Log(\"Webhook request received, processing...\")\n\t\ttime.Sleep(requestDelay)\n\t\trequestReceived.Store(true)\n\t\tt.Log(\"Webhook request completed\")\n\t\tw.WriteHeader(http.StatusOK)\n\t}))\n\tdefer server.Close()\n\n\t// Config with real webhook, retry disabled for simplicity\n\tcfg := &config.Config{\n\t\tNotifications: config.NotificationsConfig{\n\t\t\tDesktop: config.DesktopConfig{Enabled: false},\n\t\t\tWebhook: config.WebhookConfig{\n\t\t\t\tEnabled:        true,\n\t\t\t\tURL:            server.URL,\n\t\t\t\tFormat:         \"json\",\n\t\t\t\tRetry:          config.RetryConfig{Enabled: false},\n\t\t\t\tCircuitBreaker: config.CircuitBreakerConfig{Enabled: false},\n\t\t\t\tRateLimit:      config.RateLimitConfig{Enabled: false},\n\t\t\t},\n\t\t},\n\t\tStatuses: map[string]config.StatusInfo{\n\t\t\t\"task_complete\": {Title: \"Task Complete\"},\n\t\t},\n\t}\n\n\tpluginRoot := t.TempDir()\n\tmockNotif := &mockNotifier{}\n\n\thandler := &Handler{\n\t\tcfg:         cfg,\n\t\tdedupMgr:    newTempDedupManager(t),\n\t\tstateMgr:    newTempStateManager(t),\n\t\tnotifierSvc: mockNotif,\n\t\twebhookSvc:  webhook.New(cfg), // REAL webhook sender - not mock!\n\t\tpluginRoot:  pluginRoot,\n\t}\n\n\t// Create transcript with task completion\n\ttranscript := buildTranscriptWithTools([]string{\"Write\"}, 200)\n\ttranscriptPath := createTempTranscript(t, transcript)\n\n\thookData := buildHookDataJSON(HookData{\n\t\tSessionID:      \"graceful-shutdown-e2e-test\",\n\t\tTranscriptPath: transcriptPath,\n\t\tCWD:            \"/test\",\n\t\tHookEventName:  \"Stop\",\n\t})\n\n\t// Call HandleHook and measure time\n\tstart := time.Now()\n\terr := handler.HandleHook(\"Stop\", hookData)\n\telapsed := time.Since(start)\n\n\tif err != nil {\n\t\tt.Fatalf(\"HandleHook failed: %v\", err)\n\t}\n\n\t// === Key assertions - NO time.Sleep! ===\n\n\t// 1. Request should have been received (Shutdown waited for completion)\n\tif !requestReceived.Load() {\n\t\tt.Error(\"CRITICAL: Webhook request should have completed before HandleHook returned. \" +\n\t\t\t\"This means Shutdown() in defer is not waiting for in-flight requests!\")\n\t}\n\n\t// 2. Elapsed time should include webhook delay (proves we waited)\n\t// Using 150ms threshold to account for timing variations\n\tif elapsed < 150*time.Millisecond {\n\t\tt.Errorf(\"HandleHook returned too quickly (%v), expected >= 150ms. \"+\n\t\t\t\"Shutdown() should wait for webhook to complete (~%v)\", elapsed, requestDelay)\n\t}\n\n\tt.Logf(\"âœ“ E2E Webhook Graceful Shutdown test PASSED\")\n\tt.Logf(\"  Elapsed: %v (expected >= 150ms)\", elapsed)\n\tt.Logf(\"  Request received: %v (expected true)\", requestReceived.Load())\n\tt.Logf(\"  This confirms Issue #6 is fixed!\")\n}\n\n// Helper function\nfunc contains(s, substr string) bool {\n\treturn len(s) >= len(substr) && hasSubstring(s, substr)\n}\n\nfunc hasSubstring(s, substr string) bool {\n\tfor i := 0; i <= len(s)-len(substr); i++ {\n\t\tif s[i:i+len(substr)] == substr {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n"
      },
      "plugins": [
        {
          "name": "claude-notifications-go",
          "source": "./",
          "description": "Smart notifications for Claude Code task statuses (Go implementation)",
          "version": "1.14.0",
          "author": {
            "name": "777genius",
            "email": "[email protected]"
          },
          "repository": "https://github.com/777genius/claude-notifications-go",
          "license": "MIT",
          "keywords": [
            "notifications",
            "alerts",
            "productivity",
            "go",
            "hooks"
          ],
          "category": "productivity",
          "tags": [
            "notifications",
            "hooks",
            "alerts",
            "go"
          ],
          "categories": [
            "alerts",
            "go",
            "hooks",
            "notifications",
            "productivity"
          ],
          "install_commands": [
            "/plugin marketplace add 777genius/claude-notifications-go",
            "/plugin install claude-notifications-go@claude-notifications-go"
          ]
        }
      ]
    },
    {
      "name": "claude-notifications",
      "version": null,
      "description": "Smart notifications marketplace for Claude Code",
      "owner_info": {
        "name": "777genius",
        "email": "[email protected]"
      },
      "keywords": [],
      "repo_full_name": "777genius/claude-notifications",
      "repo_url": "https://github.com/777genius/claude-notifications",
      "repo_description": "Smart notifications plugin for Claude Code task statuses with desktop notifications, sound alerts or using  webhooks. Zero dependencies.",
      "homepage": "",
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-10-18T22:54:20Z",
        "created_at": "2025-10-17T23:00:52Z",
        "license": "NOASSERTION"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1094
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 578
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 23465
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/setup-notifications.md",
          "type": "blob",
          "size": 5257
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/README.md",
          "type": "blob",
          "size": 2547
        },
        {
          "path": "docs/issues",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/issues/README.md",
          "type": "blob",
          "size": 1497
        },
        {
          "path": "docs/webhooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/webhooks/README.md",
          "type": "blob",
          "size": 2885
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 1055
        },
        {
          "path": "hooks/notification-handler.sh",
          "type": "blob",
          "size": 12900
        },
        {
          "path": "sounds",
          "type": "tree",
          "size": null
        },
        {
          "path": "sounds/README.md",
          "type": "blob",
          "size": 1603
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n    \"name\": \"claude-notifications\",\n    \"owner\": {\n        \"name\": \"777genius\",\n        \"email\": \"[email protected]\"\n    },\n    \"metadata\": {\n        \"description\": \"Smart notifications marketplace for Claude Code\",\n        \"version\": \"1.0.3\"\n    },\n    \"plugins\": [{\n        \"name\": \"claude-notifications\",\n        \"source\": \"./\",\n        \"description\": \"Desktop notifications, webhooks, and sound alerts for Claude Code task completion, plan mode, and questions\",\n        \"version\": \"1.0.3\",\n        \"author\": {\n            \"name\": \"777genius\",\n            \"email\": \"[email protected]\"\n        },\n        \"homepage\": \"https://github.com/777genius/claude-notifications\",\n        \"repository\": \"https://github.com/777genius/claude-notifications\",\n        \"license\": \"GPL-3.0\",\n        \"keywords\": [\n            \"notifications\",\n            \"alerts\",\n            \"productivity\",\n            \"webhooks\",\n            \"desktop-notifications\",\n            \"plan-mode\",\n            \"hooks\"\n        ],\n        \"category\": \"productivity\",\n        \"tags\": [\"notifications\", \"hooks\", \"alerts\"]\n    }]\n}",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"claude-notifications\",\n  \"version\": \"1.0.3\",\n  \"description\": \"Smart notifications for Claude Code task statuses with desktop notifications, webhooks, and sound alerts\",\n  \"author\": {\n    \"name\": \"777genius\",\n    \"email\": \"[email protected]\"\n  },\n  \"license\": \"GPL-3.0\",\n  \"repository\": \"https://github.com/777genius/claude-notifications\",\n  \"keywords\": [\n    \"notifications\",\n    \"alerts\",\n    \"productivity\",\n    \"webhooks\",\n    \"desktop-notifications\"\n  ],\n  \"commands\": [\n    \"./commands/setup-notifications.md\"\n  ],\n  \"hooks\": [\n    \"./hooks/hooks.json\"\n  ]\n}\n",
        "README.md": "# Claude Notifications Plugin\n\n[![macOS Tests](https://github.com/777genius/claude-notifications/actions/workflows/test-macos.yml/badge.svg)](https://github.com/777genius/claude-notifications/actions/workflows/test-macos.yml)\n[![Linux Tests](https://github.com/777genius/claude-notifications/actions/workflows/test-linux.yml/badge.svg)](https://github.com/777genius/claude-notifications/actions/workflows/test-linux.yml)\n[![Windows Tests](https://github.com/777genius/claude-notifications/actions/workflows/test-windows.yml/badge.svg)](https://github.com/777genius/claude-notifications/actions/workflows/test-windows.yml)\n[![Coverage](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/777genius/claude-notifications/gh-pages/coverage-badge.json)](https://codecov.io/gh/777genius/claude-notifications)\n[![License: GPL v3](https://img.shields.io/badge/License-GPLv3-blue.svg)](https://www.gnu.org/licenses/gpl-3.0)\n![visitor badge](https://visitor-badge.laobi.icu/badge?page_id=claude-notifications)\n\n<img width=\"350\" height=\"239\" alt=\"image\" src=\"https://github.com/user-attachments/assets/42b7a306-f56f-4499-94cf-f3d573416b6d\" />\n\n\n## Table of Contents\n\n- [Claude Notifications Plugin](#claude-notifications-plugin)\n  - [Table of Contents](#table-of-contents)\n  - [Features](#features)\n  - [Test Coverage](#test-coverage)\n  - [Notification Statuses](#notification-statuses)\n  - [Installation](#installation)\n    - [Quick Install from GitHub](#quick-install-from-github)\n    - [Local Installation (for development)](#local-installation-for-development)\n  - [Quick Setup (Recommended)](#quick-setup-recommended)\n    - [Interactive Setup Wizard](#interactive-setup-wizard)\n  - [Manual Setup (Advanced)](#manual-setup-advanced)\n    - [1. Copy Configuration File](#1-copy-configuration-file)\n    - [2. Configure Notifications](#2-configure-notifications)\n    - [3. Configure Sound Files (Optional)](#3-configure-sound-files-optional)\n      - [Option A: Use System Sounds (Easiest - Works Immediately)](#option-a-use-system-sounds-easiest---works-immediately)\n      - [Option B: Add Custom Sound Files](#option-b-add-custom-sound-files)\n      - [Option C: Disable Sounds](#option-c-disable-sounds)\n  - [Configuration Options](#configuration-options)\n    - [Desktop Notifications](#desktop-notifications)\n    - [Webhook Notifications](#webhook-notifications)\n      - [Text Format](#text-format)\n      - [JSON Format](#json-format)\n    - [Status Customization](#status-customization)\n  - [How It Works](#how-it-works)\n    - [Status Detection Logic](#status-detection-logic)\n      - [1. Instant Detection (PreToolUse Hook)](#1-instant-detection-pretooluse-hook)\n      - [2. Post-Completion Detection (Stop/SubagentStop Hooks)](#2-post-completion-detection-stopsubagentstop-hooks)\n    - [Summarization](#summarization)\n  - [Limitations](#limitations)\n    - [What Can Be Tracked](#what-can-be-tracked)\n    - [What Cannot Be Tracked](#what-cannot-be-tracked)\n      - [Why This Happens](#why-this-happens)\n      - [Workaround](#workaround)\n  - [Platform Support](#platform-support)\n    - [Fully Supported Platforms](#fully-supported-platforms)\n    - [Cross-Platform Implementation](#cross-platform-implementation)\n    - [macOS-Only Features](#macos-only-features)\n    - [Requirements](#requirements)\n  - [ğŸ”” Webhook Integrations](#-webhook-integrations)\n    - [Quick Start](#quick-start)\n    - [Available Presets](#available-presets)\n  - [Known Issues](#known-issues)\n    - [Duplicate Notifications (Claude Code Bug)](#duplicate-notifications-claude-code-bug)\n    - [Summary Text Robustness](#summary-text-robustness)\n  - [Troubleshooting](#troubleshooting)\n    - [Notifications not appearing](#notifications-not-appearing)\n    - [Sounds not playing](#sounds-not-playing)\n    - [Webhook not working](#webhook-not-working)\n  - [Contributing](#contributing)\n  - [License](#license)\n  - [Support](#support)\n  - [Roadmap](#roadmap)\n\nSmart notifications for Claude Code task statuses with desktop notifications, webhooks, and sound alerts.\n\n## Features\n\n- âœ… **Desktop Notifications** - Native notifications on macOS, Linux, and Windows\n- ğŸ”” **Sound Alerts** - Customizable sounds for different status types\n- ğŸŒ **Webhook Integration** - Send notifications to external services (text or JSON)\n- ğŸ¯ **Smart Status Detection** - Automatically detects task completion, reviews, questions, and plan readiness\n- ğŸ“ **Auto Summarization** - Generates concise summaries of completed tasks\n- ğŸ”§ **Highly Configurable** - Customize everything through a simple JSON config\n- ğŸš€ **Zero Dependencies** - Works out-of-the-box on Windows without installing jq (uses built-in PowerShell)\n\n## Test Coverage\n\nThis plugin has comprehensive test coverage:\n\n| Metric | Value | Description |\n|--------|-------|-------------|\n| **Coverage/Tests** | See badge above | Code coverage % or test count |\n| **Test Suites** | 13 | Independent test files |\n| **Test Cases** | 228 | Individual test functions |\n| **Source Files** | 10 | Main plugin files (`lib/` + `hooks/`) |\n| **Lines of Code** | 1,700+ | Non-comment, non-blank lines |\n\n**About Coverage:**\nWe attempt to measure bash code coverage using [bashcov](https://github.com/infertux/bashcov) on macOS. However, bash coverage is technically challenging due to sourcing, subshells, and helper functions. If coverage measurement succeeds, the badge shows the percentage (e.g., \"73.5% | 228 tests\"). If not, it shows test count only (e.g., \"228 tests\").\n\nAll tests run on **macOS**, **Linux**, and **Windows**. For detailed reports (when coverage works), visit [Codecov Dashboard](https://codecov.io/gh/777genius/claude-notifications). See [Testing Documentation](docs/testing.md) for details.\n\n## Notification Statuses\n\nThe plugin detects and notifies about the following statuses:\n\n| Status | Icon | Description | Trigger |\n|--------|------|-------------|---------|\n| Task Complete | âœ… | Main task completed | Stop/SubagentStop hooks (state machine analysis) |\n| Review Complete | ğŸ” | Code review finished | Stop/SubagentStop hooks (review keywords detected) |\n| Question | â“ | Claude has a question | PreToolUse hook (AskUserQuestion) OR Notification hook |\n| Plan Ready | ğŸ“‹ | Plan ready for approval | PreToolUse hook (ExitPlanMode) |\n\n## Installation\n\n### Quick Install from GitHub\n\n```bash\n# Add the marketplace\n/plugin marketplace add 777genius/claude-notifications\n\n# Install the plugin\n/plugin install claude-notifications@claude-notifications\n```\n\n### Local Installation (for development)\n\n```bash\n# Add local marketplace\n/plugin marketplace add /path/to/claude-notifications\n\n# Install from local\n/plugin install claude-notifications@local-dev\n```\n\n**Updating local plugin:**\nChanges to a locally installed plugin are reflected immediately - just edit the files and they'll take effect on the next hook trigger. No need to reinstall!\n\n## Quick Setup (Recommended)\n\n### Interactive Setup Wizard\n\nRun the interactive setup command to configure your plugin with ease:\n\n```bash\n/setup-notifications\n```\n\n**What it does:**\n1. ğŸµ **Plays system sounds** so you can hear each one before choosing\n2. â“ **Asks interactive questions** with easy-to-use selection UI\n3. âš™ï¸ **Auto-generates config.json** with your preferences\n4. âœ… **Tests your setup** to confirm everything works\n\n**Benefits:**\n- No manual file editing required\n- Hear sounds before selecting them\n- Visual selection interface\n- Takes 2-3 minutes to complete\n\nYou can re-run `/setup-notifications` anytime to reconfigure.\n\n---\n\n## Manual Setup (Advanced)\n\nIf you prefer to configure manually:\n\n### 1. Copy Configuration File\n\n```bash\ncp config/config.json.example config/config.json\n```\n\n### 2. Configure Notifications\n\nEdit `config/config.json` to customize your notifications:\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"enabled\": true,\n      \"sound\": true\n    },\n    \"webhook\": {\n      \"enabled\": false,\n      \"url\": \"https://your-webhook-url.com\",\n      \"format\": \"json\",\n      \"headers\": {\n        \"Authorization\": \"Bearer YOUR_TOKEN\"\n      }\n    }\n  },\n  \"statuses\": {\n    \"task_complete\": {\n      \"title\": \"âœ… Task Completed\",\n      \"sound\": \"sounds/task-complete.mp3\"\n    }\n  }\n}\n```\n\n### 3. Configure Sound Files (Optional)\n\nYou have three options for sound notifications:\n\n#### Option A: Use System Sounds (Easiest - Works Immediately)\n\nThe default config uses macOS system sounds that work out of the box:\n\n```json\n{\n  \"statuses\": {\n    \"task_complete\": {\n      \"sound\": \"/System/Library/Sounds/Glass.aiff\"\n    }\n  }\n}\n```\n\n**Available macOS System Sounds:**\n- Glass.aiff, Ping.aiff, Pop.aiff, Purr.aiff (subtle)\n- Funk.aiff, Hero.aiff, Sosumi.aiff (distinctive)\n- Basso.aiff, Blow.aiff, Frog.aiff, Submarine.aiff (unique)\n\n**Linux System Sounds:** `/usr/share/sounds/` (varies by distribution)\n\n#### Option B: Add Custom Sound Files\n\n```bash\n# Copy config template for custom sounds\ncp config/config.json.example-custom-sounds config/config.json\n\n# Add your MP3/WAV/OGG files to sounds/ directory\n```\n\nSee [sounds/README.md](sounds/README.md) for free sound resources.\n\n#### Option C: Disable Sounds\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"sound\": false\n    }\n  }\n}\n```\n\n## Configuration Options\n\n### Desktop Notifications\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"enabled\": true,    // Enable/disable desktop notifications\n      \"sound\": true       // Enable/disable sound playback\n    }\n  }\n}\n```\n\n### Webhook Notifications\n\n#### Text Format\n\n```json\n{\n  \"webhook\": {\n    \"enabled\": true,\n    \"url\": \"https://webhook.example.com\",\n    \"format\": \"text\"\n  }\n}\n```\n\nSends: `[task_complete] Created authentication form. Edited 3 files.`\n\n#### JSON Format\n\n```json\n{\n  \"webhook\": {\n    \"enabled\": true,\n    \"url\": \"https://webhook.example.com\",\n    \"format\": \"json\",\n    \"headers\": {\n      \"Content-Type\": \"application/json\",\n      \"Authorization\": \"Bearer YOUR_TOKEN\"\n    }\n  }\n}\n```\n\nSends:\n```json\n{\n  \"status\": \"task_complete\",\n  \"message\": \"Created authentication form. Edited 3 files.\",\n  \"timestamp\": \"2025-10-17T10:30:00Z\",\n  \"session_id\": \"abc123\",\n  \"source\": \"claude-notifications\"\n}\n```\n\n### Status Customization\n\nCustomize the title and sound for each status:\n\n```json\n{\n  \"statuses\": {\n    \"task_complete\": {\n      \"title\": \"âœ… Task Completed\",\n      \"sound\": \"sounds/task-complete.mp3\",\n      \"keywords\": [\"completed\", \"done\", \"finished\"]\n    },\n    \"review_complete\": {\n      \"title\": \"ğŸ” Review Completed\",\n      \"sound\": \"sounds/review-complete.mp3\",\n      \"keywords\": [\"review\", \"analyzed\", \"Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°\"]\n    }\n  }\n}\n```\n\n## How It Works\n\n1. **Hook Events** - The plugin listens to Claude Code hooks (`Stop`, `Notification`, `SubagentStop`)\n2. **Status Analysis** - Analyzes transcript and tool usage to determine task status\n3. **Summarization** - Generates a concise summary using simple logic\n4. **Multi-Channel Delivery** - Sends notifications via desktop and/or webhook\n\n### Status Detection Logic\n\nThe plugin uses **two different detection methods** depending on the type of notification:\n\n#### 1. Instant Detection (PreToolUse Hook)\n\nThese statuses are detected **in real-time** as Claude calls the tool, **BEFORE** any UI prompts appear:\n\n- **Plan Ready** (`ExitPlanMode`)\n  - Fires when: Claude creates a plan using ExitPlanMode tool\n  - Detection: Direct tool_name check (no transcript analysis needed)\n  - Timing: Notification sent â†’ then UI shows \"Would you like to proceed?\"\n\n- **Question** (`AskUserQuestion`)\n  - Fires when: Claude asks explicit questions using AskUserQuestion tool\n  - Detection: Direct tool_name check (no transcript analysis needed)\n  - Timing: Notification sent â†’ then UI shows question prompt\n\n- **Question** (`Notification hook`)\n  - Fires when: Claude Code sends system notification events\n  - Detection: Always treated as \"question\" status\n  - Timing: Instant (no analysis)\n\n#### 2. Post-Completion Detection (Stop/SubagentStop Hooks)\n\nThese statuses are detected **after task completion** using smart analysis:\n\n**State Machine Algorithm:**\n\nThe plugin analyzes the **last 15 assistant messages** to determine what work was completed:\n\n1. **Tool Categories:**\n   - **Active Tools**: Write, Edit, Bash, NotebookEdit, SlashCommand (makes changes)\n   - **Planning Tools**: ExitPlanMode, TodoWrite (creates plans)\n   - **Passive Tools**: Read, Grep, Glob, WebFetch, WebSearch, Task (reads only)\n\n2. **Decision Logic:**\n   - Last tool is active (Write/Edit/Bash) â†’ **Task Complete**\n   - Last tool is passive (Read/Grep) â†’ Check keywords\n   - Review keywords found â†’ **Review Complete**\n   - At least 1 tool used + completion keywords â†’ **Task Complete**\n\n3. **Temporal Analysis:**\n   - Only recent activity (last 15 messages) considered\n   - Old tool usage outside window is ignored\n   - Prevents false positives from stale data\n\n**Examples:**\n\n```\nScenario 1: Code Written\nTools: [Read, Write, Edit, Bash]\nLast tool: Bash (active)\nStatus: task_complete âœ…\n\nScenario 2: Code Review\nTools: [Read, Read, Grep]\nKeywords: \"analyzed the code structure\"\nStatus: review_complete âœ…\n\nScenario 3: Just Researching\nTools: [Read, Grep, Read]\nLast tool: Read (passive)\nKeywords: No completion words\nStatus: unknown (no notification) âœ…\n```\n\n**Prevents false notifications during:**\n- Idle sessions (no tools used)\n- Research/reading sessions (only passive tools, no completion keywords)\n- When state machine returns \"unknown\"\n\n### Summarization\n\nThe plugin creates summaries by:\n1. Extracting the first sentence from Claude's last message\n2. Adding context from tool usage (e.g., \"Edited 3 files\")\n3. Truncating to ~150 characters for readability\n\n## Limitations\n\n### What Can Be Tracked\n\nThe plugin can send notifications for:\n\n- âœ… **Plan Ready** - When Claude creates a plan (PreToolUse hook detects `ExitPlanMode`)\n- âœ… **Questions** - When Claude asks questions (PreToolUse hook detects `AskUserQuestion` OR Notification hook fires)\n- âœ… **Task Complete** - When Claude finishes work (Stop/SubagentStop hooks analyze completion)\n- âœ… **Review Complete** - When Claude finishes code review (Stop/SubagentStop hooks detect review keywords)\n\n### What Cannot Be Tracked\n\n**Important:** The plugin **cannot** detect Claude Code's built-in UI confirmation dialogs.\n\nWhen you see this prompt:\n```\nâ¯ 1. Yes\n  2. Yes, allow all edits during this session\n  3. No, and tell Claude what to do differently\n```\n\nThis is a **UI confirmation dialog** shown by Claude Code itself, not an `AskUserQuestion` tool. The plugin has no way to detect when these dialogs appear.\n\n#### Why This Happens\n\n**Event Sequence:**\n```\n1. Claude decides to use Write/Edit/Bash tool\n2. Claude Code shows UI confirmation dialog â† NO HOOK FIRES HERE\n3. User approves\n4. Tool executes\n5. Hook fires (too late for \"action required\" notification)\n```\n\n**Technical Explanation:**\n\n- `AskUserQuestion` = Claude explicitly asking a question (trackable via PreToolUse hook)\n- UI Confirmation = Claude Code security feature for file operations (not exposed to hooks)\n\nThe difference:\n- **AskUserQuestion tool** - Fired when Claude needs information from you (e.g., \"Which API should I use?\")\n- **UI Confirmation** - Fired when Claude Code asks permission for potentially dangerous operations (Write, Edit, Bash)\n\nSince UI confirmations are handled internally by Claude Code **before** any hooks fire, there is no event the plugin can intercept.\n\n#### Workaround\n\nIf you want notifications when Claude is waiting for approval:\n1. Enable notifications for **Plan Ready** status - you'll be notified when Claude presents a plan\n2. Configure auto-approve for trusted operations in Claude Code settings (reduces confirmation dialogs)\n3. Wait for Claude Code to add a dedicated hook for UI confirmations (feature request)\n\n## Platform Support\n\n### Fully Supported Platforms\n\nThe plugin is fully cross-platform and works on:\n\n| Platform | Status | Desktop Notifications | Sound Playback | Webhooks | Terminal Activation |\n|----------|--------|----------------------|----------------|----------|-------------------|\n| **macOS** (10.12+) | âœ… Full | osascript/terminal-notifier | afplay | âœ… | âœ… Warp/iTerm/Terminal.app |\n| **Linux** | âœ… Full | notify-send | paplay/aplay | âœ… | âŒ Not supported |\n| **Windows** (Git Bash/WSL) | âœ… Full | PowerShell Toast | PowerShell | âœ… | âŒ Not supported |\n\n### Cross-Platform Implementation\n\nAll critical features work across platforms:\n- âœ… Desktop notifications\n- âœ… Sound playback\n- âœ… Webhook integration\n- âœ… Status detection\n- âœ… Auto-summarization\n- âœ… Lock-based deduplication\n\nThe plugin automatically detects your OS and uses the appropriate commands:\n- **Temp directories**: Respects `$TMPDIR` (macOS/Linux) and `$TEMP` (Windows)\n- **File timestamps**: Uses `stat -f` (macOS) or `stat -c` (Linux/Windows)\n- **Notification commands**: Uses `osascript` (macOS), `notify-send` (Linux), or PowerShell (Windows)\n\n### macOS-Only Features\n\nThese features only work on macOS but don't affect core functionality on other platforms:\n- **Terminal tab activation**: Clicking notifications activates the terminal tab (Warp, iTerm, Terminal.app)\n- **Advanced notifications**: Integration with terminal-notifier for richer notifications\n\n### Requirements\n\n**All Platforms:**\n- **No mandatory dependencies!** ğŸ‰\n  - The plugin automatically detects and uses available JSON parsers\n  - Works out-of-the-box on Windows (uses built-in PowerShell)\n\n**Optional (Recommended for Performance):**\n- **jq** - Faster JSON parsing (recommended but not required)\n  - macOS: `brew install jq`\n  - Linux: `apt install jq` or `yum install jq`\n  - Windows: Download from [jqlang.github.io](https://jqlang.github.io/jq/)\n  - Verify: `jq --version`\n\n**Automatic JSON Parser Selection:**\n\nThe plugin automatically selects the best available parser in this order:\n1. **jq** (fastest, ~50% faster than alternatives)\n2. **PowerShell** (Windows built-in via `ConvertFrom-Json`)\n3. **python3/python** (fallback)\n4. **ruby** (fallback)\n\n**Linux-Specific:**\n- **notify-send** (usually pre-installed with desktop environments)\n  - Ubuntu/Debian: `apt install libnotify-bin`\n  - Fedora: `dnf install libnotify`\n\n**Windows-Specific:**\n- **Git Bash** or **WSL** (Windows Subsystem for Linux)\n- **PowerShell 5.0+** (pre-installed on Windows 10+, used for JSON parsing)\n\n## ğŸ”” Webhook Integrations\n\nSend notifications to your favorite messaging platform!\n\n| Platform | Status | Documentation |\n|----------|--------|---------------|\n| **Slack** | âœ… Supported | [Setup Guide](docs/webhooks/slack.md) |\n| **Discord** | âœ… Supported | [Setup Guide](docs/webhooks/discord.md) |\n| **Telegram** | âœ… Supported | [Setup Guide](docs/webhooks/telegram.md) |\n| **Custom** | âœ… Supported | [Setup Guide](docs/webhooks/custom.md) |\n\n### Quick Start\n\n1. Choose your platform from the table above\n2. Follow the setup guide for detailed instructions\n3. Update `config/config.json`:\n\n```json\n{\n  \"notifications\": {\n    \"webhook\": {\n      \"enabled\": true,\n      \"preset\": \"slack\",\n      \"url\": \"https://hooks.slack.com/services/YOUR/WEBHOOK/URL\"\n    }\n  }\n}\n```\n\n**Test your webhook:**\n```bash\n./test/webhook-tester.sh --preset slack --url \"YOUR_WEBHOOK_URL\" --message \"Test\"\n```\n\n### Available Presets\n\n- **`slack`** - Slack Incoming Webhooks (send to Slack channels)\n- **`discord`** - Discord Webhooks (send to Discord channels)\n- **`telegram`** - Telegram Bot API (send to Telegram chats/groups)\n- **`custom`** - Generic JSON/text format (for custom endpoints)\n\nFor detailed setup instructions, examples, and troubleshooting, see [Webhook Documentation](docs/webhooks/README.md).\n\nâš ï¸ **Note:** Webhook integrations are community-contributed and not officially tested by the plugin author.\n\n## Known Issues\n\n### Duplicate Notifications (Claude Code Bug)\n\n**Problem:** You may occasionally receive 2-4 duplicate notifications for the same event.\n\n**Affected Versions:** Claude Code v2.0.17 - v2.0.21\n**Working Versions:** v2.0.15 and earlier âœ…\n\nThis is a known bug in Claude Code where hooks are executed multiple times for single events. The plugin includes automatic deduplication using an atomic lock to minimize duplicates. In practice, it guarantees at least one notification and eliminates race windows where two processes could both send.\n\n**Why this happens:**\n- Claude Code bug ([#9602](https://github.com/anthropics/claude-code/issues/9602), [#3465](https://github.com/anthropics/claude-code/issues/3465), [#3523](https://github.com/anthropics/claude-code/issues/3523))\n- Multiple processes execute simultaneously with different PIDs\n- Duplication increases during long sessions (2x â†’ 4x â†’ 10x+)\n\n**Plugin Protection:**\nThe plugin uses an early duplicate check plus an atomic lock acquisition right before sending:\n- âœ… Early duplicate detection without creating a lock (allows retries if a process exits early)\n- âœ… Atomic lock via noclobber to prevent simultaneous send\n- âœ… Stale locks (>2s) are ignored and safely replaced\n- âœ… Guarantees at least 1 notification is sent\n\n**What you'll see:**\n```\n[2025-XX-XX XX:XX:XX] === Hook triggered: Stop [PID: 12345] ===\n[2025-XX-XX XX:XX:XX] Duplicate hook detected early (age: 0s), skipping [PID: 12346]\n[2025-XX-XX XX:XX:XX] Desktop notification sent\n```\n\n**Workaround:**\n- Update to Claude Code v2.0.15 (or wait for fix in future versions)\n- Accept occasional duplicates as a trade-off for reliable notifications\n\n### Summary Text Robustness\n\nNotifications now use improved summary cleaning:\n- Removes markdown headers, list markers, and backticks\n- Flattens newlines, trims, collapses spaces\n- If cleaned summary becomes empty, a status-specific default message is used\n\n## Troubleshooting\n\n### Notifications not appearing\n\n1. Check if desktop notifications are enabled in OS settings\n2. Verify `config/config.json` has `\"enabled\": true`\n3. Ensure `jq` is installed: `jq --version`\n\n### Sounds not playing\n\n1. Check if sound files exist in `sounds/` directory\n2. Verify `\"sound\": true` in config\n3. Test sound command manually:\n   - macOS: `afplay sounds/task-complete.mp3`\n   - Linux: `paplay sounds/task-complete.mp3`\n\n### Webhook not working\n\n1. Test webhook URL with curl:\n   ```bash\n   curl -X POST https://your-webhook-url.com -d \"test\"\n   ```\n2. Check webhook logs for errors\n3. Verify headers are correct\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n\n## License\n\nGNU General Public License v3.0 (GPL-3.0)\n\nThis program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n\n**Key points:**\n- âœ… Free to use, modify, and distribute\n- âœ… Must keep the same GPL-3.0 license\n- âœ… Must publish source code of any modifications\n- âœ… Must credit original author (777genius)\n\nSee [LICENSE](LICENSE) file for full details.\n\n## Support\n\n- Report issues: [GitHub Issues](https://github.com/your-username/claude-notifications/issues)\n- Documentation: [Claude Code Docs](https://docs.claude.com/en/docs/claude-code)\n\n## Roadmap\n\n- [ ] Add more notification channels (email, SMS)\n- [ ] Support for custom AI summarization (optional)\n- [ ] Priority levels for different statuses\n- [ ] Notification history/log\n- [ ] Web dashboard for notification management\n",
        "commands/setup-notifications.md": "---\ndescription: Interactive setup wizard for claude-notifications plugin\nallowed-tools: Bash, AskUserQuestion, Write, Read\n---\n\n# Setup Notifications Plugin\n\nYou are helping the user configure the claude-notifications plugin interactively. Follow these steps carefully:\n\n## Step 1: Detect System Sounds\n\nFirst, detect the operating system and find available system sounds:\n\n**For macOS:**\n- List sounds in `/System/Library/Sounds/`\n- Common sounds: Glass.aiff, Ping.aiff, Pop.aiff, Purr.aiff, Funk.aiff, Hero.aiff, Sosumi.aiff, Basso.aiff, Blow.aiff, Frog.aiff, Submarine.aiff, Bottle.aiff, Morse.aiff, Tink.aiff\n\n**For Linux:**\n- Check `/usr/share/sounds/` and subdirectories\n- Look for .ogg, .wav files\n\n## Step 2: Present Available Sounds\n\nShow the user a formatted list of all available sounds with descriptions. For example:\n\n**Available System Sounds:**\n- **Glass** - Crisp, clean chime\n- **Ping** - Subtle ping sound\n- **Hero** - Triumphant fanfare\n- **Funk** - Distinctive funk sound\n- **Pop** - Quick pop sound\n- **Purr** - Gentle purr\n- **Basso** - Deep bass sound\n- **Sosumi** - Pleasant notification\n- **Tink** - Light metallic sound\n- **Frog** - Unique ribbit sound\n- **Submarine** - Sonar-like ping\n- (etc.)\n\nTell the user: \"You can ask me to play any sound before making your choice. For example, say 'play Glass' or 'Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ°Ñ‚ÑŒ Hero'. When you're ready, I'll ask you to select sounds for each notification type.\"\n\n## Step 3: Interactive Sound Selection\n\nFor EACH notification type (Task Complete, Review Complete, Question, Plan Ready):\n\n1. **Announce the notification type** you're configuring\n2. **Remind the user** they can request to play any sound (e.g., \"play Funk\", \"Ğ¿Ñ€Ğ¾ÑĞ»ÑƒÑˆĞ°Ñ‚ÑŒ Ping\")\n3. **Wait for user to explore sounds** - If user requests to play a sound:\n   - Play it using bash: `afplay /System/Library/Sounds/[SoundName].aiff` (macOS) or `paplay /usr/share/sounds/[file]` (Linux)\n   - Ask if they want to hear more sounds or are ready to choose\n4. **When user is ready**, use AskUserQuestion to gather their final choice\n\n## Step 4: Ask Confirmation Questions\n\nAfter the user has explored sounds for each notification type, use AskUserQuestion to confirm their selections. Structure the questions as follows:\n\n**For each notification type (Task Complete, Review Complete, Question, Plan Ready):**\n- **question**: \"Which sound would you like for '[Type]' notifications?\"\n- **header**: \"[Type]\"\n- **multiSelect**: false\n- **options**: List all available system sounds with brief descriptions\n\n**Example options format:**\n- Glass - \"Crisp, clean chime\"\n- Ping - \"Subtle ping sound\"\n- Hero - \"Triumphant fanfare\"\n- Funk - \"Distinctive funk sound\"\n- Pop - \"Quick pop sound\"\n- Purr - \"Gentle purr\"\n- Basso - \"Deep bass sound\"\n- Sosumi - \"Pleasant notification\"\n- (include all detected sounds)\n\n### Webhook Configuration\n**question**: \"Do you want to enable webhook notifications?\"\n**header**: \"Webhook\"\n**multiSelect**: false\n**options**:\n- \"No\" - \"Desktop notifications only\"\n- \"Yes, JSON format\" - \"Send structured JSON to webhook\"\n- \"Yes, text format\" - \"Send plain text to webhook\"\n\n**If webhook is enabled**, inform the user:\n\"Please edit `config/config.json` manually to add your webhook URL and any custom headers.\"\n\n## Step 5: Create Configuration File\n\nBased on the user's answers, create the `config/config.json` file. Use the following template:\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"enabled\": true,\n      \"sound\": true\n    },\n    \"webhook\": {\n      \"enabled\": <true/false based on answer>,\n      \"url\": \"\",\n      \"format\": \"<json/text based on answer>\",\n      \"headers\": {}\n    }\n  },\n  \"statuses\": {\n    \"task_complete\": {\n      \"title\": \"âœ… Task Completed\",\n      \"sound\": \"/System/Library/Sounds/<user's choice>\",\n      \"keywords\": [\"completed\", \"done\", \"finished\", \"ÑƒÑĞ¿ĞµÑˆĞ½Ğ¾\", \"Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½\"]\n    },\n    \"review_complete\": {\n      \"title\": \"ğŸ” Review Completed\",\n      \"sound\": \"/System/Library/Sounds/<user's choice>\",\n      \"keywords\": [\"review\", \"Ñ€ĞµĞ²ÑŒÑ\", \"analyzed\", \"Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ°\", \"analysis\"]\n    },\n    \"question\": {\n      \"title\": \"â“ Question\",\n      \"sound\": \"/System/Library/Sounds/<user's choice>\",\n      \"keywords\": [\"question\", \"Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ\", \"clarify\"]\n    },\n    \"plan_ready\": {\n      \"title\": \"ğŸ“‹ Plan Ready\",\n      \"sound\": \"/System/Library/Sounds/<user's choice>\",\n      \"keywords\": [\"plan\", \"Ğ¿Ğ»Ğ°Ğ½\", \"strategy\"]\n    }\n  }\n}\n```\n\n**IMPORTANT**:\n- Get the plugin directory path using: `cd \"$(dirname \"$(readlink -f \"$0\" || echo \"$0\")\")\"`\n- Write the config to `config/config.json` relative to the plugin root directory\n- For Linux, adjust sound paths to use `/usr/share/sounds/` instead\n\n## Step 6: Confirm Success\n\nAfter creating the config file:\n1. Show the user the generated configuration\n2. Confirm setup is complete\n3. Suggest they can re-run `/setup-notifications` anytime to reconfigure\n4. If webhook was enabled, remind them to edit the URL in `config/config.json`\n\n## Step 7: Test Notification\n\nOffer to test the notification by playing the selected \"task_complete\" sound to confirm it works.\n\n---\n\n**Remember**: Be friendly, clear, and help the user understand each step. Make this setup experience smooth and enjoyable!\n",
        "docs/README.md": "## Claude Notifications - Documentation\n\n### Notification cooldown: suppressing questions after task completion\n\nThis plugin can temporarily suppress the \"Claude Has Questions\" notification when it happens immediately after a \"Task Completed\" event. This prevents noisy back-to-back alerts at the end of a task.\n\n#### Configuration\n\n- Key: `notifications.suppressQuestionAfterTaskCompleteSeconds`\n- Type: integer (seconds)\n- Default: `7`\n- Special values:\n  - `0` â†’ disables cooldown (no suppression)\n  - Any positive integer â†’ cooldown window in seconds\n\nExample:\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": { \"enabled\": true, \"sound\": true },\n    \"webhook\": { \"enabled\": false, \"url\": \"\", \"format\": \"json\", \"headers\": {} },\n    \"suppressQuestionAfterTaskCompleteSeconds\": 7\n  }\n}\n```\n\n#### Behavior\n\n- When a `task_complete` status is produced, the handler records a per-session timestamp.\n- If a `question` status would be sent and the last `task_complete` for the same session happened within the configured window, the `question` notification is suppressed.\n- Applies to both sources of `question`:\n  - PreToolUse with `tool_name = \"AskUserQuestion\"`\n  - Generic `Notification` hook classified as `question`\n- Other statuses are unaffected (e.g., `plan_ready`, `review_complete`, `task_complete`).\n\n#### Notes and lifecycle\n\n- The cooldown is session-scoped. The plugin stores per-session state in the OS temp directory and checks it before emitting `question`.\n- The configuration is read on every hook invocation; changing the value takes effect immediately (no restart required).\n- Duplicate hook executions are already mitigated by lock-based deduplication; the cooldown check runs after status resolution and before sending notifications.\n\n#### Troubleshooting\n\n- \"Question still appears immediately\":\n  - Verify the key is present and non-zero in `config/config.json`.\n  - Check `notification-debug.log` for lines like:\n    - `Recorded last_task_complete_ts=...`\n    - `Question suppressed: task_complete Xs ago (< Ys)`\n  - Ensure the events belong to the same session (session IDs must match).\n\n- \"Too aggressive suppression\":\n  - Reduce the window or set to `0` to disable.\n\n#### Logging examples\n\n```\n[2025-10-18 12:00:00] Recorded last_task_complete_ts=1697620800 in /var/.../claude-session-state-<session>.json\n[2025-10-18 12:00:04] Question suppressed: task_complete 4s ago (< 7s)\n```\n\n---\n\n### Other docs\n\n- Webhooks: `docs/webhooks/README.md`\n- Test guides: `docs/testing.md`\n- Coverage setup: `docs/coverage-setup.md`\n\n\n",
        "docs/issues/README.md": "# Known Issues\n\nĞ¡Ğ¿Ğ¸ÑĞ¾Ğº Ğ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ñ… Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼ Ğ¸ Ğ±Ğ°Ğ³Ğ¾Ğ² Ğ¿Ğ»Ğ°Ğ³Ğ¸Ğ½Ğ° Claude Notifications.\n\n## ĞĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ğµ Issues\n\n_(Ğ½ĞµÑ‚ Ğ°ĞºÑ‚Ğ¸Ğ²Ğ½Ñ‹Ñ… issues)_\n\n---\n\n## ĞšĞ°Ğº Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ñ‹Ğ¹ issue\n\n1. Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ¹Ñ‚Ğµ Ñ„Ğ°Ğ¹Ğ» Ğ² `docs/issues/` Ñ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸ĞµĞ¼ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹\n2. Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒÑ‚Ğµ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² ÑÑ‚Ğ¾Ñ‚ README.md\n3. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ template:\n\n```markdown\n### ğŸ› Bug: ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹\n**Ğ¤Ğ°Ğ¹Ğ»:** [filename.md](./filename.md)\n**ĞŸÑ€Ğ¸Ğ¾Ñ€Ğ¸Ñ‚ĞµÑ‚:** Low | Medium | Medium-High | High | Critical\n**Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ:** ĞÑ‚ĞºÑ€Ñ‹Ñ‚ | Ğ’ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğµ | Ğ˜ÑĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½ | ĞŸÑ€Ğ¾Ñ‚ĞµÑÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½ | Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚\n\n**ĞšÑ€Ğ°Ñ‚ĞºĞ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ:**\n1-2 Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ Ğ¾ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ğµ\n\n**Ğ ĞµÑˆĞµĞ½Ğ¸Ğµ:**\nĞšÑ€Ğ°Ñ‚ĞºĞ¾Ğµ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¿Ñ€ĞµĞ´Ğ»Ğ°Ğ³Ğ°ĞµĞ¼Ğ¾Ğ³Ğ¾ Ñ€ĞµÑˆĞµĞ½Ğ¸Ñ\n```\n\n## ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ğ¼ĞµÑ‚Ğ¾Ğº\n\n- `bug` - Ğ‘Ğ°Ğ³Ğ¸ Ğ² ĞºĞ¾Ğ´Ğµ\n- `enhancement` - Ğ£Ğ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»Ğ°\n- `documentation` - ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ñ Ğ´Ğ¾ĞºÑƒĞ¼ĞµĞ½Ñ‚Ğ°Ñ†Ğ¸ĞµĞ¹\n- `performance` - ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ¿Ñ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸\n- `cross-platform` - ĞšÑ€Ğ¾ÑÑĞ¿Ğ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹\n- `notifications` - ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ñ ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸ÑĞ¼Ğ¸\n- `summary-generation` - ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ summary\n- `status-detection` - ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ¸Ñ ÑÑ‚Ğ°Ñ‚ÑƒÑĞ°\n- `webhooks` - ĞŸÑ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹ Ñ webhook Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸ĞµĞ¹\n",
        "docs/webhooks/README.md": "# Webhook Integrations\n\nSend Claude Code notifications to your favorite messaging platform.\n\n## Supported Platforms\n\n- [Slack](slack.md) âœ…\n- [Discord](discord.md) âœ…\n- [Telegram](telegram.md) âœ…\n- [Custom Format](custom.md) âœ…\n\n## Quick Start\n\n1. Choose your platform from the list above\n2. Follow the setup guide\n3. Update `config/config.json` with webhook settings\n4. Enable webhooks: `\"enabled\": true`\n\n## Testing\n\nUse the test script to verify your webhook:\n\n```bash\n./test/webhook-tester.sh --preset slack --url \"YOUR_WEBHOOK_URL\" --message \"Test\"\n```\n\n## Configuration Example\n\nEdit `config/config.json`:\n\n```json\n{\n  \"notifications\": {\n    \"webhook\": {\n      \"enabled\": true,\n      \"preset\": \"slack\",\n      \"url\": \"https://hooks.slack.com/services/YOUR/WEBHOOK/URL\",\n      \"chat_id\": \"\",\n      \"format\": \"json\"\n    }\n  }\n}\n```\n\n### Configuration Fields\n\n| Field | Required | Description | Example |\n|-------|----------|-------------|---------|\n| `enabled` | Yes | Enable/disable webhook notifications | `true` or `false` |\n| `preset` | Yes | Webhook format preset | `\"slack\"`, `\"discord\"`, `\"telegram\"`, `\"custom\"` |\n| `url` | Yes | Webhook endpoint URL | `\"https://hooks.slack.com/...\"` |\n| `chat_id` | Telegram only | Telegram chat ID | `\"123456789\"` |\n| `format` | Custom only | Payload format | `\"json\"` or `\"text\"` |\n| `headers` | Custom only | Custom HTTP headers | `{\"Authorization\": \"Bearer ...\"}` |\n\n## Preset Formats\n\n### Slack\n```json\n{\n  \"text\": \"âœ… Task Completed: Summary...\"\n}\n```\n\n### Discord\n```json\n{\n  \"content\": \"âœ… Task Completed: Summary...\",\n  \"username\": \"Claude Code\"\n}\n```\n\n### Telegram\n```json\n{\n  \"chat_id\": \"123456789\",\n  \"text\": \"âœ… Task Completed: Summary...\"\n}\n```\n\n### Custom\n```json\n{\n  \"status\": \"task_complete\",\n  \"message\": \"Summary...\",\n  \"timestamp\": \"2025-01-17T12:34:56Z\",\n  \"session_id\": \"abc123...\",\n  \"source\": \"claude-notifications\"\n}\n```\n\n## Troubleshooting\n\n### Webhook not firing\n\n1. Check `\"enabled\": true` in config\n2. Verify webhook URL is correct\n3. Check logs: `tail -f notification-debug.log`\n\n### Wrong format received\n\n1. Verify `preset` field matches your platform\n2. For Telegram, ensure `chat_id` is set\n3. Test with `test/test-webhook.sh`\n\n### Custom headers not working\n\nCustom headers are only supported with `preset: \"custom\"`. For platform-specific webhooks (Slack/Discord/Telegram), headers are managed by the platform.\n\n## Disclaimer\n\nâš ï¸ **Note:** Webhook integrations are community-contributed and not officially tested by the plugin author. Please report issues on [GitHub](https://github.com/belief/claude-notifications/issues).\n\n## Contributing\n\nFound a bug or want to add support for another platform? Contributions are welcome!\n\n1. Test your integration\n2. Document the setup process\n3. Submit a pull request\n\nSee the [custom webhook guide](custom.md) for examples of how to add new platforms.\n",
        "hooks/hooks.json": "{\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"ExitPlanMode|AskUserQuestion\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/notification-handler.sh PreToolUse\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"Notification\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/notification-handler.sh Notification\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/notification-handler.sh Stop\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"SubagentStop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash ${CLAUDE_PLUGIN_ROOT}/hooks/notification-handler.sh SubagentStop\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "hooks/notification-handler.sh": "#!/bin/bash\n# notification-handler.sh - Main orchestrator for Claude Code notifications\n\n# Get the plugin directory first (before set -e)\nPLUGIN_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")/..\" && pwd)\"\nexport PLUGIN_DIR\n\n# Setup logging (required by error handler)\nLOG_FILE=\"${PLUGIN_DIR}/notification-debug.log\"\nexport LOG_FILE\nlog_debug() {\n  echo \"[$(date '+%Y-%m-%d %H:%M:%S')] $*\" >> \"$LOG_FILE\"\n}\n\n# Source global error handler FIRST (installs trap and sets strict mode)\nsource \"${PLUGIN_DIR}/lib/error-handler.sh\"\n\n# Source all library functions\nsource \"${PLUGIN_DIR}/lib/platform.sh\"\nsource \"${PLUGIN_DIR}/lib/cross-platform.sh\"\nsource \"${PLUGIN_DIR}/lib/json-parser.sh\"\nsource \"${PLUGIN_DIR}/lib/analyzer.sh\"\nsource \"${PLUGIN_DIR}/lib/summarizer.sh\"\nsource \"${PLUGIN_DIR}/lib/notifier.sh\"\nsource \"${PLUGIN_DIR}/lib/webhook.sh\"\nsource \"${PLUGIN_DIR}/lib/sound.sh\"\nsource \"${PLUGIN_DIR}/lib/session-name.sh\"\n\n# Main function\nmain() {\n  local hook_event=\"${1:-Stop}\"\n  log_debug \"=== Hook triggered: $hook_event [PID: $$] ===\"\n\n  # Read JSON data from stdin\n  local hook_data=$(cat)\n  log_debug \"Hook data received: ${#hook_data} bytes [PID: $$]\"\n\n  # DEBUG: Detailed hook data diagnostics\n  log_debug \"=== Hook Data Diagnostics ===\"\n  log_debug \"Platform: $(detect_os)\"\n  log_debug \"JSON Backend: $(_json_backend)\"\n  log_debug \"Hook data content (first 500 chars): ${hook_data:0:500}\"\n\n  # Parse and validate each field separately\n  local session_id=$(echo \"$hook_data\" | json_get \".session_id\" \"\")\n  local transcript_path=$(echo \"$hook_data\" | json_get \".transcript_path\" \"\")\n  local cwd=$(echo \"$hook_data\" | json_get \".cwd\" \"\")\n  local tool_name=$(echo \"$hook_data\" | json_get \".tool_name\" \"\")\n\n  log_debug \"Parsed fields:\"\n  log_debug \"  - session_id: '${session_id}' (${#session_id} chars)\"\n  log_debug \"  - transcript_path: '${transcript_path}' (${#transcript_path} chars)\"\n  log_debug \"  - cwd: '${cwd}' (${#cwd} chars)\"\n  log_debug \"  - tool_name: '${tool_name}' (${#tool_name} chars)\"\n\n  # Validate required fields\n  if [[ -z \"$session_id\" ]]; then\n    log_debug \"WARNING: session_id is empty!\"\n    session_id=\"unknown\"\n  fi\n\n  if [[ -z \"$transcript_path\" ]]; then\n    log_debug \"WARNING: transcript_path is empty or missing from hook data!\"\n    log_debug \"This is a known issue on Windows (Claude Code 2.0.x)\"\n    log_debug \"Plugin will work with limited functionality (no transcript analysis)\"\n  fi\n\n  log_debug \"=== End Hook Data Diagnostics ===\"\n\n  # Get session ID early for deduplication (already parsed above)\n\n  # Deduplication: Ğ·Ğ°Ñ‰Ğ¸Ñ‚Ğ° Ğ¾Ñ‚ Ğ±Ğ°Ğ³Ğ° Claude Code (versions 2.0.17-2.0.21)\n  # Ğ¥ÑƒĞºĞ¸ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑÑÑ‚ÑÑ 2-4 Ñ€Ğ°Ğ·Ğ° Ğ´Ğ»Ñ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¾Ğ±Ñ‹Ñ‚Ğ¸Ñ (GitHub issues #9602, #3465, #3523)\n  # NOTE: Lock ÑĞ¾Ğ·Ğ´Ğ°ĞµÑ‚ÑÑ ĞŸĞĞ¡Ğ›Ğ• Ğ²ÑĞµÑ… early exit Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¾Ğº, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¸Ğ·Ğ±ĞµĞ¶Ğ°Ñ‚ÑŒ \"0 ÑƒĞ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ğ¹\"\n  local TEMP_DIR=$(get_temp_dir)\n  local LOCK_FILE=\"${TEMP_DIR}/claude-notification-${hook_event}-${session_id}.lock\"\n\n  # Ğ Ğ°Ğ½Ğ½ÑÑ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ½Ğ° Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚ (Ğ½Ğµ ÑĞ¾Ğ·Ğ´Ğ°ĞµĞ¼ lock Ğ·Ğ´ĞµÑÑŒ!)\n  if [[ -f \"$LOCK_FILE\" ]]; then\n    local lock_timestamp=$(get_file_mtime \"$LOCK_FILE\")\n    local current_timestamp=$(get_current_timestamp)\n    local age=$((current_timestamp - lock_timestamp))\n\n    # ĞĞ° Windows stat Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ²ĞµÑ€Ğ½ÑƒÑ‚ÑŒ 0 (mtime Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ¾) â€” ÑÑ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ ÑÑ‚Ğ¾ ÑĞ²ĞµĞ¶Ğ¸Ğ¼ Ğ´ÑƒĞ±Ğ»Ğ¸ĞºĞ°Ñ‚Ğ¾Ğ¼\n    if [[ $lock_timestamp -eq 0 ]] || [[ $age -lt 2 ]]; then\n      log_debug \"Duplicate hook detected early (age: ${age}s, mtime: $lock_timestamp), skipping [PID: $$]\"\n      exit 0\n    fi\n  fi\n\n  # Load configuration\n  local config_file=\"${PLUGIN_DIR}/config/config.json\"\n  local config=\"{}\"\n  if [[ -f \"$config_file\" ]]; then\n    config=$(cat \"$config_file\")\n    log_debug \"Config loaded successfully\"\n  else\n    log_debug \"Config file not found: $config_file\"\n  fi\n\n  # Check if desktop notifications are enabled\n  local desktop_enabled=$(echo \"$config\" | json_get \".notifications.desktop.enabled\" \"true\")\n  log_debug \"Desktop notifications enabled: $desktop_enabled\"\n\n  # Only proceed if at least one notification method is enabled\n  local webhook_enabled=$(echo \"$config\" | json_get \".notifications.webhook.enabled\" \"false\")\n  log_debug \"Webhook enabled: $webhook_enabled\"\n  if [[ \"$desktop_enabled\" != \"true\" ]] && [[ \"$webhook_enabled\" != \"true\" ]]; then\n    log_debug \"All notifications disabled, exiting\"\n    exit 0\n  fi\n\n  # Cooldown for suppressing question after task completion (seconds)\n  local suppress_q_after_task_secs=$(echo \"$config\" | json_get \".notifications.suppressQuestionAfterTaskCompleteSeconds\" \"7\")\n\n  # Declare status variable\n  local status=\"\"\n\n  # For PreToolUse - check tool_name (fires BEFORE tool execution)\n  if [[ \"$hook_event\" == \"PreToolUse\" ]]; then\n    # tool_name is already parsed at the top of main()\n    log_debug \"PreToolUse: tool_name='$tool_name'\"\n\n    if [[ \"$tool_name\" == \"ExitPlanMode\" ]]; then\n      status=\"plan_ready\"\n      log_debug \"PreToolUse: ExitPlanMode detected â†’ plan_ready notification\"\n\n      # Persist interactive state for this session (used by Notification hook)\n      # Based on official hooks flow: PreToolUse fires before UI prompts; Notification fires separately\n      # Docs: https://docs.claude.com/en/docs/claude-code/hooks-guide#custom-notification-hook\n      local state_file=\"${TEMP_DIR}/claude-session-state-${session_id}.json\"\n      local now_ts=$(get_current_timestamp)\n      # Use already parsed values instead of re-parsing\n      local state_json=$(json_build session_id \"$session_id\" last_interactive_tool \"$tool_name\" last_ts \"$now_ts\" cwd \"$cwd\")\n      echo \"$state_json\" > \"$state_file\"\n      log_debug \"PreToolUse: session state written to $state_file\"\n    elif [[ \"$tool_name\" == \"AskUserQuestion\" ]]; then\n      status=\"question\"\n      log_debug \"PreToolUse: AskUserQuestion detected â†’ question notification\"\n\n      # Persist interactive state for AskUserQuestion as well\n      local state_file=\"${TEMP_DIR}/claude-session-state-${session_id}.json\"\n      local now_ts=$(get_current_timestamp)\n      # Use already parsed values instead of re-parsing\n      local state_json=$(json_build session_id \"$session_id\" last_interactive_tool \"$tool_name\" last_ts \"$now_ts\" cwd \"$cwd\")\n      echo \"$state_json\" > \"$state_file\"\n      log_debug \"PreToolUse: session state written to $state_file\"\n    else\n      # Should never happen with matcher, but just in case\n      log_debug \"PreToolUse: unexpected tool '$tool_name' - skipping\"\n      exit 0\n    fi\n    # Continue to notification sending below...\n  else\n    # For other hooks (Stop, SubagentStop, Notification), analyze status\n    status=$(analyze_status \"$hook_event\" \"$hook_data\")\n    log_debug \"Status determined: $status\"\n\n    # Skip unknown and generic notification statuses\n    if [[ \"$status\" == \"unknown\" ]] || [[ \"$status\" == \"notification\" ]]; then\n      log_debug \"Status is $status, skipping notification\"\n      # Output message to prevent \"Plugin hook error\" in Claude Code\n      echo \"[claude-notifications] Skipped: insufficient data (status=$status, transcript_path=${transcript_path:-empty})\" >&2\n      exit 0\n    fi\n  fi\n\n  log_debug \"Processing status: $status\"\n\n  # Update session state on task completion\n  if [[ \"$status\" == \"task_complete\" ]]; then\n    local state_file=\"${TEMP_DIR}/claude-session-state-${session_id}.json\"\n    local now_ts=$(get_current_timestamp)\n    local prev_tool=\"\"\n    local prev_ts=\"0\"\n    if [[ -f \"$state_file\" ]]; then\n      prev_tool=$(cat \"$state_file\" | json_get \".last_interactive_tool\" \"\")\n      prev_ts=$(cat \"$state_file\" | json_get \".last_ts\" \"0\")\n    fi\n    local state_json=$(json_build session_id \"$session_id\" last_interactive_tool \"$prev_tool\" last_ts \"$prev_ts\" last_task_complete_ts \"$now_ts\" cwd \"$hook_cwd_val\")\n    echo \"$state_json\" > \"$state_file\"\n    log_debug \"Recorded last_task_complete_ts=$now_ts in $state_file\"\n  fi\n\n  # Suppress question if within cooldown window after recent task completion\n  if [[ \"$status\" == \"question\" ]]; then\n    local state_file=\"${TEMP_DIR}/claude-session-state-${session_id}.json\"\n    if [[ -f \"$state_file\" ]]; then\n      local last_tc=$(cat \"$state_file\" | json_get \".last_task_complete_ts\" \"0\")\n      if [[ \"$last_tc\" =~ ^[0-9]+$ ]] && [[ \"$suppress_q_after_task_secs\" =~ ^[0-9]+$ ]]; then\n        local now_ts=$(get_current_timestamp)\n        local diff=$((now_ts - last_tc))\n        if [[ $last_tc -gt 0 ]] && [[ $diff -lt $suppress_q_after_task_secs ]]; then\n          log_debug \"Question suppressed: task_complete ${diff}s ago (< ${suppress_q_after_task_secs}s)\"\n          exit 0\n        fi\n      fi\n    fi\n  fi\n\n  # === Ğ’ÑĞµ early exits Ğ¿Ñ€Ğ¾Ğ¹Ğ´ĞµĞ½Ñ‹ â€” Ğ¿Ñ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ°Ñ‚Ğ¾Ğ¼Ğ°Ñ€Ğ½Ğ¾ Ğ·Ğ°Ñ…Ğ²Ğ°Ñ‚Ğ¸Ñ‚ÑŒ lock ===\n  if try_acquire_lock \"$LOCK_FILE\"; then\n    log_debug \"Exclusive lock acquired: $LOCK_FILE [PID: $$]\"\n  else\n    # Lock ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ â€” Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ğ¼ ĞµĞ³Ğ¾ Ğ²Ğ¾Ğ·Ñ€Ğ°ÑÑ‚\n    local lock_timestamp=$(get_file_mtime \"$LOCK_FILE\")\n    local current_timestamp=$(get_current_timestamp)\n    local age=$((current_timestamp - lock_timestamp))\n\n    if [[ $lock_timestamp -eq 0 ]] || [[ $age -lt 2 ]]; then\n      log_debug \"Duplicate detected at lock acquire (age: ${age}s, mtime: $lock_timestamp), skipping [PID: $$]\"\n      exit 0\n    fi\n\n    # ĞŸĞ¾Ñ…Ğ¾Ğ¶Ğµ, lock ÑƒÑÑ‚Ğ°Ñ€ĞµĞ» â€” Ğ¿Ğ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ·Ğ°Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ ĞµĞ³Ğ¾\n    rm -f \"$LOCK_FILE\" 2>/dev/null || true\n    if try_acquire_lock \"$LOCK_FILE\"; then\n      log_debug \"Stale lock replaced: $LOCK_FILE [PID: $$]\"\n    else\n      log_debug \"Another process acquired the lock concurrently, skipping [PID: $$]\"\n      exit 0\n    fi\n  fi\n\n  # Note: transcript_path, session_id, and cwd are already parsed at the top of main()\n  log_debug \"Using parsed values: transcript_path='$transcript_path', session_id='$session_id', cwd='$cwd'\"\n\n  # Generate summary with status context\n  local summary=$(generate_summary \"$transcript_path\" \"$hook_data\" \"$status\")\n  summary=$(clean_text \"$summary\")\n  if [[ -z \"$summary\" ]] || [[ \"$summary\" =~ ^[[:space:]]*$ ]]; then\n    log_debug \"Empty summary after cleaning, using default message for status: $status\"\n    summary=$(get_default_message \"$status\")\n  fi\n  log_debug \"Summary generated: ${summary:0:50}...\"\n\n  # Get status configuration\n  local status_title=$(echo \"$config\" | json_get \".statuses.${status}.title\" \"Claude Code\")\n  local sound_file=$(echo \"$config\" | json_get \".statuses.${status}.sound\" \"\")\n  local app_icon=$(echo \"$config\" | json_get \".notifications.desktop.appIcon\" \"\")\n\n  # Generate friendly session name and add to title\n  local session_name=$(generate_session_name \"$session_id\")\n  status_title=\"${status_title} [${session_name}]\"\n\n  log_debug \"Status title: $status_title\"\n  log_debug \"Session name: $session_name\"\n  log_debug \"Sound file from config: $sound_file\"\n  log_debug \"App icon from config: $app_icon\"\n\n  # Resolve sound file path\n  if [[ -n \"$sound_file\" ]] && [[ ! \"$sound_file\" = /* ]]; then\n    sound_file=\"${PLUGIN_DIR}/${sound_file}\"\n  fi\n  log_debug \"Resolved sound file path: $sound_file\"\n\n  # Resolve app icon path (expand ${CLAUDE_PLUGIN_ROOT} and relative paths)\n  if [[ -n \"$app_icon\" ]]; then\n    app_icon=\"${app_icon//\\$\\{CLAUDE_PLUGIN_ROOT\\}/${PLUGIN_DIR}}\"\n    if [[ ! \"$app_icon\" = /* ]]; then\n      app_icon=\"${PLUGIN_DIR}/${app_icon}\"\n    fi\n    log_debug \"Resolved app icon path: $app_icon\"\n  fi\n\n  # Send desktop notification\n  if [[ \"$desktop_enabled\" == \"true\" ]]; then\n    log_debug \"Sending desktop notification...\"\n    send_notification \"$status_title\" \"$summary\" \"$cwd\" \"$app_icon\" || true\n    log_debug \"Desktop notification sent\"\n\n    # Play sound if configured\n    if [[ -n \"$sound_file\" ]] && [[ -f \"$sound_file\" ]]; then\n      log_debug \"Playing sound: $sound_file\"\n      play_sound \"$sound_file\" \"$config\" || true\n      log_debug \"Sound playback initiated\"\n    else\n      log_debug \"Sound file not found or not configured: $sound_file\"\n    fi\n  fi\n\n  # Send webhook notification\n  if [[ \"$webhook_enabled\" == \"true\" ]]; then\n    log_debug \"Sending webhook notification...\"\n    send_webhook \"$status\" \"$summary\" \"$session_id\" \"$config\" || true\n    log_debug \"Webhook sent\"\n  fi\n\n  # Session state cleanup on Stop/SubagentStop\n  if [[ \"$hook_event\" == \"Stop\" ]] || [[ \"$hook_event\" == \"SubagentStop\" ]]; then\n    local state_file=\"${TEMP_DIR}/claude-session-state-${session_id}.json\"\n    if [[ -f \"$state_file\" ]]; then\n      rm -f \"$state_file\" 2>/dev/null || true\n      log_debug \"Session state file removed: $state_file\"\n    fi\n  fi\n\n  # Cleanup ÑÑ‚Ğ°Ñ€Ñ‹Ñ… lock-Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² (ÑÑ‚Ğ°Ñ€ÑˆĞµ 60 ÑĞµĞºÑƒĞ½Ğ´)\n  cleanup_old_files \"$TEMP_DIR\" \"claude-notification-*.lock\" 60 || true\n\n  log_debug \"=== Notification handler completed successfully ===\"\n  # Exit successfully (don't block Claude)\n  exit 0\n}\n\n# Run main function\nmain \"$@\"\n",
        "sounds/README.md": "# Sound Files\n\nThis directory contains sound files for different notification statuses.\n\n## Quick Start: Use System Sounds\n\n**The easiest option is to use system sounds** - they work immediately without downloading anything!\n\nThe default `config.json.example` uses macOS system sounds:\n- `Glass.aiff` - Task completed (crisp, clean)\n- `Ping.aiff` - Review completed (subtle ping)\n- `Funk.aiff` - Question (distinctive)\n- `Hero.aiff` - Plan ready (triumphant)\n\nAll available macOS system sounds are in `/System/Library/Sounds/`.\n\n## Optional: Custom Sound Files\n\nIf you prefer custom sounds, place them in this directory:\n\n- `task-complete.mp3` - Played when a task is completed\n- `review-complete.mp3` - Played when a review is completed\n- `question.mp3` - Played when Claude has a question\n- `plan-ready.mp3` - Played when a plan is ready\n\nThen use `config.json.example-custom-sounds` as your config template.\n\n### Adding Your Own Sounds\n\n1. Place your sound files in this directory\n2. Update `config/config.json` to reference your sound files\n3. Supported formats: MP3, WAV, OGG, AIFF\n\n## Free Sound Resources\n\nYou can find free notification sounds at:\n\n- [Freesound](https://freesound.org/)\n- [Zapsplat](https://www.zapsplat.com/)\n- [Notification Sounds](https://notificationsounds.com/)\n\n## Disabling Sounds\n\nTo disable sounds, set `\"sound\": false` in your `config/config.json`:\n\n```json\n{\n  \"notifications\": {\n    \"desktop\": {\n      \"enabled\": true,\n      \"sound\": false\n    }\n  }\n}\n```\n\n## Note\n\nSound files are optional. The plugin will work without them, but you won't hear audio notifications.\n"
      },
      "plugins": [
        {
          "name": "claude-notifications",
          "source": "./",
          "description": "Desktop notifications, webhooks, and sound alerts for Claude Code task completion, plan mode, and questions",
          "version": "1.0.3",
          "author": {
            "name": "777genius",
            "email": "[email protected]"
          },
          "homepage": "https://github.com/777genius/claude-notifications",
          "repository": "https://github.com/777genius/claude-notifications",
          "license": "GPL-3.0",
          "keywords": [
            "notifications",
            "alerts",
            "productivity",
            "webhooks",
            "desktop-notifications",
            "plan-mode",
            "hooks"
          ],
          "category": "productivity",
          "tags": [
            "notifications",
            "hooks",
            "alerts"
          ],
          "categories": [
            "alerts",
            "desktop-notifications",
            "hooks",
            "notifications",
            "plan-mode",
            "productivity",
            "webhooks"
          ],
          "install_commands": [
            "/plugin marketplace add 777genius/claude-notifications",
            "/plugin install claude-notifications@claude-notifications"
          ]
        }
      ]
    }
  ]
}