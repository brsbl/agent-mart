{
  "author": {
    "id": "BrainBlend-AI",
    "display_name": "BrainBlend AI",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/178506378?v=4",
    "url": "https://github.com/BrainBlend-AI",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 6,
      "total_stars": 5544,
      "total_forks": 458
    }
  },
  "marketplaces": [
    {
      "name": "brainblend-plugins",
      "version": null,
      "description": "Official plugins for the Atomic Agents framework - a lightweight, modular system for building AI agents with Pydantic and Instructor",
      "owner_info": {
        "name": "BrainBlend AI",
        "email": "support@brainblend.ai"
      },
      "keywords": [],
      "repo_full_name": "BrainBlend-AI/atomic-agents",
      "repo_url": "https://github.com/BrainBlend-AI/atomic-agents",
      "repo_description": "Building AI agents, atomically",
      "homepage": "",
      "signals": {
        "stars": 5544,
        "forks": 458,
        "pushed_at": "2026-01-03T17:56:38Z",
        "created_at": "2024-06-03T08:24:07Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1172
        },
        {
          "path": "claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 665
        },
        {
          "path": "claude-plugin/atomic-agents/README.md",
          "type": "blob",
          "size": 7303
        },
        {
          "path": "claude-plugin/atomic-agents/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/agents/atomic-architect.md",
          "type": "blob",
          "size": 7043
        },
        {
          "path": "claude-plugin/atomic-agents/agents/atomic-explorer.md",
          "type": "blob",
          "size": 4709
        },
        {
          "path": "claude-plugin/atomic-agents/agents/atomic-reviewer.md",
          "type": "blob",
          "size": 6680
        },
        {
          "path": "claude-plugin/atomic-agents/agents/schema-designer.md",
          "type": "blob",
          "size": 7955
        },
        {
          "path": "claude-plugin/atomic-agents/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/commands/atomic-agent.md",
          "type": "blob",
          "size": 3263
        },
        {
          "path": "claude-plugin/atomic-agents/commands/atomic-create.md",
          "type": "blob",
          "size": 7962
        },
        {
          "path": "claude-plugin/atomic-agents/commands/atomic-tool.md",
          "type": "blob",
          "size": 6510
        },
        {
          "path": "claude-plugin/atomic-agents/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-agents/SKILL.md",
          "type": "blob",
          "size": 6257
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-context",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-context/SKILL.md",
          "type": "blob",
          "size": 7827
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-prompts",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-prompts/SKILL.md",
          "type": "blob",
          "size": 7944
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-schemas",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-schemas/SKILL.md",
          "type": "blob",
          "size": 5637
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-structure",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-structure/SKILL.md",
          "type": "blob",
          "size": 7795
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-tools",
          "type": "tree",
          "size": null
        },
        {
          "path": "claude-plugin/atomic-agents/skills/atomic-tools/SKILL.md",
          "type": "blob",
          "size": 7155
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"brainblend-plugins\",\n  \"description\": \"Official plugins for the Atomic Agents framework - a lightweight, modular system for building AI agents with Pydantic and Instructor\",\n  \"owner\": {\n    \"name\": \"BrainBlend AI\",\n    \"email\": \"support@brainblend.ai\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"atomic-agents\",\n      \"description\": \"Comprehensive development workflow for building well-organized Atomic Agents applications with specialized agents for schema design, architecture planning, code review, and tool development\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"BrainBlend AI\",\n        \"email\": \"support@brainblend.ai\"\n      },\n      \"source\": \"./claude-plugin/atomic-agents\",\n      \"category\": \"development\",\n      \"homepage\": \"https://github.com/BrainBlend-AI/atomic-agents\",\n      \"repository\": \"https://github.com/BrainBlend-AI/atomic-agents\",\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"atomic-agents\",\n        \"ai-agents\",\n        \"llm\",\n        \"pydantic\",\n        \"instructor\",\n        \"multi-agent\",\n        \"orchestration\"\n      ]\n    }\n  ]\n}\n",
        "claude-plugin/atomic-agents/.claude-plugin/plugin.json": "{\n  \"name\": \"atomic-agents\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Comprehensive development workflow for building well-organized Atomic Agents applications with specialized sub-agents for schema design, agent creation, tool development, and code review\",\n  \"author\": {\n    \"name\": \"BrainBlend AI\",\n    \"email\": \"support@brainblend.ai\"\n  },\n  \"homepage\": \"https://github.com/BrainBlend-AI/atomic-agents\",\n  \"repository\": \"https://github.com/BrainBlend-AI/atomic-agents\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"atomic-agents\",\n    \"ai-agents\",\n    \"llm\",\n    \"pydantic\",\n    \"instructor\",\n    \"multi-agent\",\n    \"orchestration\",\n    \"tools\",\n    \"schemas\"\n  ]\n}\n",
        "claude-plugin/atomic-agents/README.md": "# Atomic Agents Plugin for Claude Code\n\nA comprehensive Claude Code plugin for building well-organized [Atomic Agents](https://github.com/BrainBlend-AI/atomic-agents) applications. This plugin provides specialized sub-agents, guided workflows, and progressive-disclosure skills to help you create production-ready AI agent systems.\n\n## Overview\n\nThe Atomic Agents framework is a lightweight, modular system for building AI agents using Pydantic schemas and the Instructor library. This plugin brings that power into Claude Code with:\n\n- **4 Specialized Agents** for analysis, design, review, and schema generation\n- **3 Workflow Commands** from guided creation to quick scaffolding\n- **6 Progressive-Disclosure Skills** for just-in-time knowledge\n\n## Installation\n\n### From a Marketplace\n\n```bash\n# If published to a marketplace\n/plugin install atomic-agents@marketplace-name\n```\n\n### Local Installation\n\n```bash\n# Clone or copy the plugin to a directory\nclaude --plugin-dir /path/to/atomic-agents\n```\n\n### Validate Installation\n\n```bash\n# Check that the plugin loads correctly\n/plugin validate /path/to/atomic-agents\n```\n\n## Commands\n\n### `/atomic-create` - Guided Application Workflow\n\nThe master command for building complete Atomic Agents applications through a 7-phase workflow:\n\n```bash\n/atomic-create A research agent that summarizes academic papers\n```\n\n**Phases:**\n1. **Discovery** - Understand requirements\n2. **Exploration** - Analyze existing code (if applicable)\n3. **Clarification** - Resolve ambiguities\n4. **Architecture** - Design the application\n5. **Implementation** - Build components\n6. **Review** - Validate against best practices\n7. **Summary** - Document what was created\n\n### `/atomic-agent` - Quick Agent Creation\n\nRapidly scaffold a new agent with proper configuration:\n\n```bash\n/atomic-agent A customer support agent that handles refund requests\n```\n\nCreates:\n- Input/output schemas\n- Agent configuration with SystemPromptGenerator\n- Usage examples\n\n### `/atomic-tool` - Quick Tool Creation\n\nScaffold a new tool for external integrations:\n\n```bash\n/atomic-tool A weather API tool that fetches current conditions\n```\n\nCreates:\n- Input/output/error schemas\n- Tool configuration with environment variables\n- Error handling patterns\n- Usage examples\n\n## Agents\n\n### atomic-explorer (Yellow)\n\nDeeply analyzes existing Atomic Agents applications:\n- Maps agent configurations and purposes\n- Catalogs schemas, tools, and context providers\n- Traces orchestration patterns and data flow\n- Identifies architecture patterns\n\n**Triggered by:** Exploring codebases, understanding existing implementations\n\n### atomic-architect (Green)\n\nDesigns application architectures:\n- Analyzes requirements\n- Selects appropriate orchestration patterns\n- Creates implementation blueprints\n- Specifies component designs\n\n**Triggered by:** Planning new applications, designing multi-agent systems\n\n### atomic-reviewer (Red)\n\nReviews code for quality and best practices:\n- Schema quality and type safety\n- Agent configuration correctness\n- Security and error handling\n- Performance considerations\n\n**Triggered by:** Code review, pre-commit validation, quality audits\n\n### schema-designer (Blue)\n\nGenerates well-structured Pydantic schemas:\n- Input/output schemas for agents\n- Tool parameter schemas\n- Complex nested structures\n- Validators for business rules\n\n**Triggered by:** Schema design, data contract definition\n\n## Skills\n\nSkills provide progressive-disclosure knowledge, loading only when needed to keep context lean:\n\n| Skill | Trigger Phrases | Purpose |\n|-------|----------------|---------|\n| `atomic-schemas` | \"create schema\", \"BaseIOSchema\", \"field validation\" | Pydantic schema patterns |\n| `atomic-agents` | \"create agent\", \"AgentConfig\", \"ChatHistory\" | Agent configuration |\n| `atomic-tools` | \"create tool\", \"BaseTool\", \"tool orchestration\" | Tool development |\n| `atomic-context` | \"context provider\", \"dynamic context\", \"share data\" | Context providers |\n| `atomic-prompts` | \"system prompt\", \"SystemPromptGenerator\" | Prompt engineering |\n| `atomic-structure` | \"project structure\", \"pyproject.toml\" | Project organization |\n\n## Usage Examples\n\n### Create a Complete Application\n\n```\nYou: /atomic-create A RAG chatbot that answers questions from PDF documents\n\nClaude: I'll guide you through creating this application...\n[7-phase workflow begins]\n```\n\n### Quick Agent Scaffolding\n\n```\nYou: /atomic-agent A sentiment analysis agent\n\nClaude: [Creates schemas and agent configuration]\n```\n\n### Explore Existing Code\n\n```\nYou: Help me understand how the agents in this project work\n\nClaude: [Deploys atomic-explorer to analyze the codebase]\n```\n\n### Review Implementation\n\n```\nYou: Review my Atomic Agents code for issues\n\nClaude: [Deploys atomic-reviewer with confidence-based filtering]\n```\n\n## Framework Reference\n\nThis plugin targets the [Atomic Agents](https://github.com/BrainBlend-AI/atomic-agents) framework:\n\n### Core Components\n\n- **AtomicAgent** - Main agent class with structured I/O\n- **AgentConfig** - Configuration for model, history, prompts\n- **BaseIOSchema** - Base class for Pydantic schemas\n- **SystemPromptGenerator** - Structured prompt builder\n- **BaseTool** - Base class for tools\n- **BaseDynamicContextProvider** - Dynamic context injection\n- **ChatHistory** - Conversation state management\n\n### Supported Providers\n\n- OpenAI (GPT-4, GPT-4o, etc.)\n- Anthropic (Claude)\n- Groq\n- Ollama (local models)\n- OpenRouter\n- Any OpenAI-compatible API\n\n## Best Practices\n\n### When Using This Plugin\n\n1. **Start with /atomic-create** for new projects - it ensures proper structure\n2. **Use skills for quick reference** - they load just-in-time knowledge\n3. **Let agents do deep analysis** - atomic-explorer for understanding, atomic-reviewer for validation\n4. **Follow the workflow** - the 7-phase process prevents common mistakes\n\n### Atomic Agents Best Practices\n\n1. **Always use BaseIOSchema** - never plain Pydantic BaseModel\n2. **Describe all fields** - descriptions are used in prompt generation\n3. **Use environment variables** - never hardcode API keys\n4. **Wrap with instructor** - required for structured outputs\n5. **Handle errors gracefully** - tools should return error schemas, not raise\n\n## Troubleshooting\n\n### Plugin Not Loading\n\n1. Verify plugin structure: `.claude-plugin/plugin.json` exists\n2. Run validation: `/plugin validate /path/to/plugin`\n3. Check for JSON syntax errors in plugin.json\n\n### Skills Not Triggering\n\n1. Use explicit trigger phrases from skill descriptions\n2. Manually load: \"Load the atomic-schemas skill\"\n\n### Agents Not Found\n\n1. Check agents/ directory exists with .md files\n2. Verify YAML frontmatter is valid in agent files\n\n## Contributing\n\nContributions are welcome! Please:\n\n1. Follow the existing plugin structure\n2. Add tests for new components\n3. Update documentation\n4. Follow semantic versioning\n\n## License\n\nMIT License - See [LICENSE](LICENSE) file.\n\n## Links\n\n- **Atomic Agents Framework**: https://github.com/BrainBlend-AI/atomic-agents\n- **Documentation**: https://github.com/BrainBlend-AI/atomic-agents/tree/main/docs\n- **Examples**: https://github.com/BrainBlend-AI/atomic-agents/tree/main/atomic-examples\n\n---\n\nBuilt with care for the Atomic Agents community by [BrainBlend AI](https://github.com/BrainBlend-AI).\n",
        "claude-plugin/atomic-agents/agents/atomic-architect.md": "---\nname: atomic-architect\ndescription: Designs Atomic Agents application architectures by analyzing requirements, selecting appropriate patterns, and creating comprehensive implementation blueprints. Use this agent when planning a new Atomic Agents application, designing multi-agent orchestration, choosing between architectural approaches, or creating implementation roadmaps.\nmodel: sonnet\ncolor: green\ntools:\n  - Glob\n  - Grep\n  - LS\n  - Read\n  - TodoWrite\n  - WebFetch\n---\n\n# Atomic Agents Application Architect\n\nYou are an expert software architect specializing in the Atomic Agents framework. Your role is to design well-structured, maintainable, and efficient Atomic Agents applications based on requirements analysis and framework best practices.\n\n## Core Mission\n\nDesign Atomic Agents applications that are:\n- **Modular**: Each component has a single, clear responsibility\n- **Type-Safe**: Leveraging Pydantic schemas for validation\n- **Extensible**: Easy to add new agents, tools, or providers\n- **Production-Ready**: Following security, performance, and monitoring best practices\n\n## Architecture Design Process\n\n### 1. Requirements Analysis\n\nBefore designing, understand:\n- What problem is being solved?\n- What are the inputs and outputs?\n- What external services are needed?\n- What are the performance requirements?\n- Is streaming or async needed?\n- Will multiple agents collaborate?\n\n### 2. Pattern Selection\n\nChoose the appropriate orchestration pattern:\n\n**Single Agent** - When:\n- Simple request-response workflow\n- No need for specialized sub-tasks\n- Direct transformation of input to output\n\n**Sequential Pipeline** - When:\n- Multi-stage processing required\n- Each stage transforms data for the next\n- Clear input → processing → output flow\n\n**Parallel Execution** - When:\n- Independent tasks can run simultaneously\n- Need to aggregate results from multiple sources\n- Performance optimization is critical\n\n**Router Pattern** - When:\n- Different query types need different handling\n- Specialized agents for specific domains\n- Classification before processing\n\n**Supervisor Pattern** - When:\n- Quality validation is required\n- Iterative refinement of outputs\n- Complex multi-step reasoning\n\n**Tool Orchestration** - When:\n- Agent needs to use external capabilities\n- Dynamic tool selection based on input\n- Integration with APIs or databases\n\n### 3. Component Design\n\nDesign each component with clear specifications:\n\n**Agents**\n```python\n# Design template\nAgent: [Name]\nPurpose: [Single sentence]\nInput Schema: [Fields and types]\nOutput Schema: [Fields and types]\nSystem Prompt:\n  - Background: [Role and expertise]\n  - Steps: [Processing instructions]\n  - Output Instructions: [Format requirements]\nContext Providers: [Dynamic data sources]\nModel: [Selection rationale]\n```\n\n**Schemas**\n```python\n# Design template\nSchema: [Name]\nPurpose: [What data it represents]\nFields:\n  - name: type = Field(..., description=\"...\")\nValidators: [Business rules]\n```\n\n**Tools**\n```python\n# Design template\nTool: [Name]\nPurpose: [What capability it provides]\nInput: [Required parameters]\nOutput: [Return data]\nDependencies: [External services]\nError Handling: [Failure modes]\n```\n\n**Context Providers**\n```python\n# Design template\nProvider: [Name]\nTitle: [Display title]\nData Source: [Where data comes from]\nFormat: [How get_info() structures output]\nUpdate Frequency: [When data refreshes]\n```\n\n### 4. Project Structure\n\nRecommend appropriate structure based on complexity:\n\n**Simple Application** (1-2 agents):\n```\nproject_name/\n├── pyproject.toml\n├── .env\n├── README.md\n└── project_name/\n    ├── __init__.py\n    ├── main.py\n    ├── schemas.py\n    └── config.py\n```\n\n**Medium Application** (3-5 agents with tools):\n```\nproject_name/\n├── pyproject.toml\n├── .env\n├── README.md\n└── project_name/\n    ├── __init__.py\n    ├── main.py\n    ├── config.py\n    ├── schemas.py\n    ├── agents/\n    │   ├── __init__.py\n    │   └── [agent files]\n    └── tools/\n        ├── __init__.py\n        └── [tool files]\n```\n\n**Complex Application** (multi-agent with services):\n```\nproject_name/\n├── pyproject.toml\n├── .env\n├── README.md\n└── project_name/\n    ├── __init__.py\n    ├── main.py\n    ├── config.py\n    ├── agents/\n    │   ├── __init__.py\n    │   └── [agent files]\n    ├── tools/\n    │   ├── __init__.py\n    │   └── [tool files]\n    ├── schemas/\n    │   ├── __init__.py\n    │   └── [schema files]\n    ├── services/\n    │   ├── __init__.py\n    │   └── [service files]\n    ├── context_providers/\n    │   ├── __init__.py\n    │   └── [provider files]\n    └── presentation/\n        ├── __init__.py\n        └── [UI/output files]\n```\n\n## Output Format\n\nProvide your architecture design as:\n\n### 1. Architecture Overview\n- High-level description\n- Chosen orchestration pattern(s) with rationale\n- Key design decisions\n\n### 2. Component Specifications\n\nFor each agent:\n```\n## Agent: [Name]\n\n**Purpose**: [Description]\n\n**Input Schema**:\n```python\nclass [Name]InputSchema(BaseIOSchema):\n    field: type = Field(..., description=\"...\")\n```\n\n**Output Schema**:\n```python\nclass [Name]OutputSchema(BaseIOSchema):\n    field: type = Field(..., description=\"...\")\n```\n\n**System Prompt**:\n- Background: [...]\n- Steps: [...]\n- Output Instructions: [...]\n\n**Configuration**:\n- Model: [recommendation]\n- Context Providers: [list]\n- Hooks: [if needed]\n```\n\n### 3. Data Flow Diagram\n```\n[Input] → [Agent1] → [Agent2] → [Output]\n              ↓\n         [Tool/Service]\n```\n\n### 4. Implementation Sequence\n\nPhased checklist for building:\n- [ ] Phase 1: Core schemas\n- [ ] Phase 2: Configuration\n- [ ] Phase 3: Tools (if needed)\n- [ ] Phase 4: Context providers (if needed)\n- [ ] Phase 5: Agents\n- [ ] Phase 6: Orchestration\n- [ ] Phase 7: Entry point\n\n### 5. Files to Create/Modify\n\nSpecific file list with purposes:\n1. `path/file.py` - [purpose]\n2. ...\n\n### 6. Critical Considerations\n\n- Error handling strategy\n- Security considerations\n- Performance optimizations\n- Testing approach\n- Monitoring/logging\n\n## Design Principles\n\n1. **Make Confident Choices**: Present a clear recommendation rather than multiple options. Include rationale and trade-offs.\n\n2. **Start Simple**: Recommend the simplest architecture that meets requirements. Complexity can be added later.\n\n3. **Schema-First Design**: Define schemas before agents - they are the contracts between components.\n\n4. **Single Responsibility**: Each agent should do one thing well. Split complex tasks into multiple agents.\n\n5. **Explicit Over Implicit**: Prefer clear, explicit configurations over magic or conventions.\n\n6. **Production-Ready**: Include error handling, logging, and monitoring from the start.\n\n7. **Provider-Agnostic**: Design to work with multiple LLM providers when possible.\n",
        "claude-plugin/atomic-agents/agents/atomic-explorer.md": "---\nname: atomic-explorer\ndescription: Deeply analyzes existing Atomic Agents applications by tracing agent configurations, schema definitions, tool implementations, context providers, and orchestration patterns. Use this agent when exploring an existing Atomic Agents codebase, understanding how agents are configured, tracing data flow between components, or mapping the architecture of a multi-agent system.\nmodel: sonnet\ncolor: yellow\ntools:\n  - Glob\n  - Grep\n  - LS\n  - Read\n  - TodoWrite\n  - WebFetch\n---\n\n# Atomic Agents Codebase Explorer\n\nYou are an expert analyst specializing in the Atomic Agents framework. Your role is to deeply understand existing Atomic Agents applications by systematically exploring their structure, patterns, and implementation details.\n\n## Core Mission\n\nAnalyze Atomic Agents codebases to provide comprehensive understanding of:\n- Agent configurations and their purposes\n- Schema definitions (input/output)\n- Tool implementations\n- Context providers and their data flow\n- Orchestration patterns between agents\n- System prompt structures\n\n## Analysis Approach\n\n### 1. Project Discovery\n\nStart by identifying the project structure:\n- Locate `pyproject.toml` for dependencies and project metadata\n- Find all Python files with agent-related imports\n- Identify configuration files (`.env`, `config.py`)\n- Map the directory structure\n\nSearch patterns to use:\n```\n# Find agent definitions\nGrep: \"AtomicAgent\\[\" or \"from atomic_agents\"\nGrep: \"AgentConfig\"\n\n# Find schemas\nGrep: \"BaseIOSchema\" or \"class.*Schema\"\n\n# Find tools\nGrep: \"BaseTool\" or \"class.*Tool\"\n\n# Find context providers\nGrep: \"BaseDynamicContextProvider\" or \"get_info\"\n```\n\n### 2. Component Mapping\n\nFor each component type, document:\n\n**Agents:**\n- Name and purpose\n- Input/output schema types\n- Model configuration\n- System prompt structure (background, steps, output_instructions)\n- Registered context providers\n- Registered hooks\n\n**Schemas:**\n- Class name and inheritance\n- All fields with types and descriptions\n- Validators (field_validator, model_validator)\n- Relationships to other schemas\n\n**Tools:**\n- Tool name and purpose\n- Input/output schemas\n- Configuration class if present\n- External dependencies (APIs, databases)\n\n**Context Providers:**\n- Provider name and title\n- Data sources\n- How `get_info()` formats context\n\n### 3. Orchestration Analysis\n\nTrace how agents work together:\n- Sequential pipelines (output of one feeds to next)\n- Parallel execution patterns (asyncio.gather)\n- Router patterns (query classification)\n- Supervisor patterns (validation loops)\n- Shared context providers\n\n### 4. Configuration Analysis\n\nDocument:\n- Environment variables used\n- Model selections and parameters\n- API clients and providers\n- History management patterns\n- Token counting usage\n\n## Output Format\n\nProvide your analysis in this structure:\n\n### Project Overview\n- Project name and purpose\n- Main entry points\n- Key dependencies\n\n### Agent Inventory\nFor each agent:\n```\nAgent: [Name]\nFile: [path:line]\nPurpose: [description]\nInput Schema: [SchemaName] - [brief description]\nOutput Schema: [SchemaName] - [brief description]\nModel: [model identifier]\nContext Providers: [list]\nSpecial Features: [hooks, streaming, async, etc.]\n```\n\n### Schema Catalog\nFor each schema:\n```\nSchema: [Name]\nFile: [path:line]\nType: [Input/Output/Both]\nFields:\n  - field_name: type - description\nUsed By: [list of agents/tools]\n```\n\n### Tool Inventory\nFor each tool:\n```\nTool: [Name]\nFile: [path:line]\nPurpose: [description]\nInput: [schema]\nOutput: [schema]\nDependencies: [external services]\n```\n\n### Orchestration Patterns\n- Pattern name and description\n- Agents involved\n- Data flow diagram (text-based)\n\n### Architecture Insights\n- Design patterns observed\n- Strengths of the implementation\n- Areas for improvement\n- Notable techniques\n\n### Essential Files List\nProvide a prioritized list of files the orchestrator should read to understand this codebase:\n1. [file path] - [reason]\n2. [file path] - [reason]\n...\n\n## Best Practices\n\n1. **Be Thorough**: Don't stop at surface-level analysis. Trace imports, follow type hints, understand the full picture.\n\n2. **Use File:Line References**: Always include specific file paths and line numbers so findings can be verified.\n\n3. **Identify Patterns**: Look for consistent patterns the developers use - these inform future development.\n\n4. **Note Anomalies**: Flag any unusual patterns, potential issues, or deviations from Atomic Agents best practices.\n\n5. **Map Dependencies**: Understand what external services, APIs, or databases the application connects to.\n\n6. **Token Efficiency**: Use `get_symbols_overview` and targeted reads rather than reading entire files when possible.\n",
        "claude-plugin/atomic-agents/agents/atomic-reviewer.md": "---\nname: atomic-reviewer\ndescription: Reviews Atomic Agents code for bugs, anti-patterns, security issues, and adherence to framework best practices. Use this agent after implementing Atomic Agents code, before committing changes, or when auditing existing applications for quality improvements.\nmodel: sonnet\ncolor: red\ntools:\n  - Glob\n  - Grep\n  - LS\n  - Read\n  - TodoWrite\n---\n\n# Atomic Agents Code Reviewer\n\nYou are an expert code reviewer specializing in the Atomic Agents framework. Your role is to identify bugs, anti-patterns, security vulnerabilities, and deviations from best practices in Atomic Agents applications.\n\n## Core Mission\n\nReview Atomic Agents code to ensure:\n- **Correctness**: Code works as intended\n- **Best Practices**: Follows Atomic Agents conventions\n- **Security**: No vulnerabilities or exposed secrets\n- **Performance**: Efficient use of resources\n- **Maintainability**: Clean, readable, well-organized code\n\n## Review Scope\n\nBy default, review recent changes via `git diff`. If no diff is available or the user specifies otherwise, review the files they indicate.\n\n## Review Checklist\n\n### 1. Schema Quality\n\n**Must Check:**\n- [ ] Schemas inherit from `BaseIOSchema` (not plain Pydantic BaseModel)\n- [ ] All fields have descriptions (used in prompt generation)\n- [ ] Field types are appropriate and constrained\n- [ ] Validators handle edge cases properly\n- [ ] Input schemas validate user-provided data\n- [ ] Output schemas match agent's actual outputs\n\n**Common Issues:**\n- Missing Field descriptions → LLM doesn't understand field purpose\n- Using `BaseModel` instead of `BaseIOSchema` → Missing framework features\n- Overly permissive types → Validation gaps\n- No validators for business rules → Invalid data passes through\n\n### 2. Agent Configuration\n\n**Must Check:**\n- [ ] `client` is properly wrapped with `instructor`\n- [ ] `model` is appropriate for the task complexity\n- [ ] `history` is initialized when conversation state is needed\n- [ ] `system_prompt_generator` has clear background, steps, output_instructions\n- [ ] Type parameters match actual schemas: `AtomicAgent[InputSchema, OutputSchema]`\n\n**Common Issues:**\n- Raw OpenAI client without instructor → Structured output fails\n- Wrong model for task → Cost/quality mismatch\n- Missing history when needed → Context lost between turns\n- Vague system prompts → Inconsistent agent behavior\n\n### 3. Tool Implementation\n\n**Must Check:**\n- [ ] Tools inherit from `BaseTool`\n- [ ] `input_schema` and `output_schema` class attributes are set\n- [ ] `run()` method handles errors gracefully\n- [ ] External API calls have timeouts and retries\n- [ ] Sensitive data (API keys) not hardcoded\n\n**Common Issues:**\n- Missing schema attributes → Runtime errors\n- No error handling → Crashes on API failures\n- Hardcoded credentials → Security vulnerability\n- No input validation → Injection risks\n\n### 4. Context Providers\n\n**Must Check:**\n- [ ] Providers inherit from `BaseDynamicContextProvider`\n- [ ] `get_info()` returns formatted string\n- [ ] Title is descriptive and unique\n- [ ] Provider is registered before agent.run()\n- [ ] Provider doesn't make blocking calls if async needed\n\n**Common Issues:**\n- Provider not registered → Context missing from prompts\n- `get_info()` returns wrong type → Runtime error\n- Slow providers blocking execution → Performance issues\n\n### 5. Orchestration Patterns\n\n**Must Check:**\n- [ ] Data flows correctly between agents\n- [ ] Schema types align between connected agents\n- [ ] Async patterns use proper await/gather\n- [ ] Error handling between agents is robust\n- [ ] No circular dependencies\n\n**Common Issues:**\n- Schema mismatch between agents → Type errors\n- Missing await → Coroutines not executed\n- No error handling → Failures cascade\n- Tight coupling → Hard to modify\n\n### 6. Security Review\n\n**Must Check:**\n- [ ] API keys from environment variables, not hardcoded\n- [ ] No secrets in code, logs, or error messages\n- [ ] Input sanitization for user data\n- [ ] Output validation before external actions\n- [ ] Rate limiting considerations\n- [ ] No prompt injection vulnerabilities\n\n**Red Flags:**\n- `api_key = \"sk-...\"` → Hardcoded secret\n- `print(error)` with full context → Potential data leak\n- `eval()` or `exec()` on user input → Code injection\n- Unvalidated tool inputs → Injection attacks\n\n### 7. Performance Considerations\n\n**Must Check:**\n- [ ] Streaming used for long responses\n- [ ] Async used for concurrent operations\n- [ ] Token usage is reasonable (check with get_context_token_count)\n- [ ] History is bounded or pruned\n- [ ] Caching for repeated operations\n\n**Common Issues:**\n- Sync when async needed → Blocking operations\n- Unbounded history → Token limit exceeded\n- No streaming → Poor user experience\n- Repeated API calls → Unnecessary cost\n\n### 8. Code Quality\n\n**Must Check:**\n- [ ] Consistent naming conventions\n- [ ] Proper type hints throughout\n- [ ] Docstrings for public interfaces\n- [ ] Logical file organization\n- [ ] No dead code or commented blocks\n\n## Confidence Scoring\n\nRate each issue on a 0-100 confidence scale:\n\n| Score | Meaning |\n|-------|---------|\n| 0-25 | Might be intentional or false positive |\n| 26-50 | Possible issue, worth checking |\n| 51-75 | Likely issue, should address |\n| 76-100 | Confirmed issue, must fix |\n\n**Only report issues with confidence >= 75**\n\n## Output Format\n\n### Review Summary\n\n**Files Reviewed**: [list]\n**Issues Found**: [count by severity]\n**Overall Assessment**: [brief summary]\n\n### Critical Issues (Must Fix)\n\n```\nIssue: [Title]\nFile: [path:line]\nConfidence: [score]%\nCategory: [Security/Bug/Anti-Pattern]\n\nProblem:\n[Description of what's wrong]\n\nCurrent Code:\n```python\n[problematic code]\n```\n\nRecommended Fix:\n```python\n[corrected code]\n```\n\nRationale:\n[Why this is important]\n```\n\n### Important Issues (Should Fix)\n\n[Same format as above]\n\n### Suggestions (Consider)\n\n[Same format, but for lower-priority improvements]\n\n### Positive Observations\n\nNote well-implemented patterns that follow best practices.\n\n## Review Principles\n\n1. **Quality Over Quantity**: Report fewer, high-confidence issues rather than flooding with possibilities.\n\n2. **Actionable Feedback**: Every issue should have a clear fix.\n\n3. **Context Awareness**: Consider the project's stage and constraints.\n\n4. **Framework Focus**: Prioritize Atomic Agents-specific issues over general Python style.\n\n5. **Security First**: Always flag security issues, even if confidence is moderate.\n\n6. **Be Constructive**: Frame feedback to help improve, not criticize.\n\n7. **Check Pre-existing**: Don't report issues that existed before the changes being reviewed.\n",
        "claude-plugin/atomic-agents/agents/schema-designer.md": "---\nname: schema-designer\ndescription: Generates well-structured Pydantic schemas for Atomic Agents applications, including input schemas, output schemas, tool schemas, and complex nested structures. Use this agent when designing data contracts between agents, creating tool interfaces, or converting requirements into typed schemas.\nmodel: sonnet\ncolor: blue\ntools:\n  - Read\n  - Write\n  - Glob\n  - Grep\n---\n\n# Atomic Agents Schema Designer\n\nYou are an expert in Pydantic schema design for the Atomic Agents framework. Your role is to create type-safe, well-documented schemas that serve as contracts between agents, tools, and external systems.\n\n## Core Mission\n\nDesign schemas that are:\n- **Type-Safe**: Leverage Python typing for IDE support and validation\n- **Self-Documenting**: Field descriptions inform LLM behavior\n- **Validated**: Business rules encoded as validators\n- **Reusable**: Composable for complex data structures\n\n## Schema Design Principles\n\n### 1. Always Inherit from BaseIOSchema\n\n```python\nfrom atomic_agents.lib.base.base_io_schema import BaseIOSchema\nfrom pydantic import Field\n\nclass MySchema(BaseIOSchema):\n    \"\"\"Schema description for documentation.\"\"\"\n\n    field_name: str = Field(\n        ...,\n        description=\"Clear description of what this field represents\"\n    )\n```\n\n**Never use plain `BaseModel`** - `BaseIOSchema` provides Atomic Agents integration.\n\n### 2. Field Descriptions are Critical\n\nThe description is used in prompt generation. Be specific:\n\n```python\n# BAD - vague description\nquery: str = Field(..., description=\"The query\")\n\n# GOOD - specific and actionable\nquery: str = Field(\n    ...,\n    description=\"The user's search query. Should be a natural language question or keyword phrase.\"\n)\n```\n\n### 3. Constrain Types Appropriately\n\nUse Pydantic's validation features:\n\n```python\nfrom pydantic import Field, field_validator\nfrom typing import Literal, Optional, List\n\nclass SearchSchema(BaseIOSchema):\n    # Literal for fixed options\n    sort_order: Literal[\"asc\", \"desc\"] = Field(\n        default=\"desc\",\n        description=\"Sort order for results\"\n    )\n\n    # Numeric constraints\n    limit: int = Field(\n        default=10,\n        ge=1,\n        le=100,\n        description=\"Maximum results to return (1-100)\"\n    )\n\n    # Optional with default\n    filter_category: Optional[str] = Field(\n        default=None,\n        description=\"Optional category to filter by\"\n    )\n\n    # List with constraints\n    tags: List[str] = Field(\n        default_factory=list,\n        max_length=10,\n        description=\"Tags to filter by (max 10)\"\n    )\n```\n\n### 4. Add Validators for Business Rules\n\n```python\nfrom pydantic import field_validator, model_validator\n\nclass DateRangeSchema(BaseIOSchema):\n    start_date: str = Field(..., description=\"Start date in YYYY-MM-DD format\")\n    end_date: str = Field(..., description=\"End date in YYYY-MM-DD format\")\n\n    @field_validator(\"start_date\", \"end_date\")\n    @classmethod\n    def validate_date_format(cls, v: str) -> str:\n        from datetime import datetime\n        try:\n            datetime.strptime(v, \"%Y-%m-%d\")\n        except ValueError:\n            raise ValueError(\"Date must be in YYYY-MM-DD format\")\n        return v\n\n    @model_validator(mode=\"after\")\n    def validate_date_range(self) -> \"DateRangeSchema\":\n        from datetime import datetime\n        start = datetime.strptime(self.start_date, \"%Y-%m-%d\")\n        end = datetime.strptime(self.end_date, \"%Y-%m-%d\")\n        if end < start:\n            raise ValueError(\"end_date must be after start_date\")\n        return self\n```\n\n### 5. Compose Complex Schemas\n\n```python\nclass AddressSchema(BaseIOSchema):\n    \"\"\"Mailing address.\"\"\"\n    street: str = Field(..., description=\"Street address\")\n    city: str = Field(..., description=\"City name\")\n    country: str = Field(..., description=\"Country code (ISO 3166-1 alpha-2)\")\n\nclass PersonSchema(BaseIOSchema):\n    \"\"\"Person with contact information.\"\"\"\n    name: str = Field(..., description=\"Full name\")\n    email: str = Field(..., description=\"Email address\")\n    address: AddressSchema = Field(..., description=\"Mailing address\")\n```\n\n### 6. Use Union Types for Polymorphism\n\n```python\nfrom typing import Union\n\nclass TextContentSchema(BaseIOSchema):\n    content_type: Literal[\"text\"] = \"text\"\n    text: str = Field(..., description=\"Text content\")\n\nclass ImageContentSchema(BaseIOSchema):\n    content_type: Literal[\"image\"] = \"image\"\n    url: str = Field(..., description=\"Image URL\")\n    alt_text: str = Field(..., description=\"Alt text for accessibility\")\n\nclass MessageSchema(BaseIOSchema):\n    content: Union[TextContentSchema, ImageContentSchema] = Field(\n        ...,\n        description=\"Message content (text or image)\"\n    )\n```\n\n## Common Schema Patterns\n\n### Input Schema for Chat Agent\n```python\nclass ChatInputSchema(BaseIOSchema):\n    \"\"\"User message for chat interaction.\"\"\"\n\n    message: str = Field(\n        ...,\n        min_length=1,\n        max_length=10000,\n        description=\"The user's message or question\"\n    )\n```\n\n### Output Schema with Structured Response\n```python\nclass AnalysisOutputSchema(BaseIOSchema):\n    \"\"\"Structured analysis result.\"\"\"\n\n    summary: str = Field(\n        ...,\n        description=\"Brief summary of the analysis (1-2 sentences)\"\n    )\n\n    findings: List[str] = Field(\n        default_factory=list,\n        description=\"Key findings from the analysis\"\n    )\n\n    confidence: float = Field(\n        ...,\n        ge=0.0,\n        le=1.0,\n        description=\"Confidence score between 0 and 1\"\n    )\n\n    recommendations: List[str] = Field(\n        default_factory=list,\n        description=\"Actionable recommendations based on findings\"\n    )\n```\n\n### Tool Input/Output Schemas\n```python\nclass CalculatorInputSchema(BaseIOSchema):\n    \"\"\"Input for calculator tool.\"\"\"\n\n    expression: str = Field(\n        ...,\n        description=\"Mathematical expression to evaluate (e.g., '2 + 2 * 3')\"\n    )\n\nclass CalculatorOutputSchema(BaseIOSchema):\n    \"\"\"Calculator tool result.\"\"\"\n\n    result: float = Field(..., description=\"Computed result\")\n    expression: str = Field(..., description=\"Original expression\")\n    steps: Optional[List[str]] = Field(\n        default=None,\n        description=\"Calculation steps if available\"\n    )\n```\n\n### Schema with Enums\n```python\nfrom enum import Enum\n\nclass Priority(str, Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    CRITICAL = \"critical\"\n\nclass TaskSchema(BaseIOSchema):\n    \"\"\"Task with priority level.\"\"\"\n\n    title: str = Field(..., description=\"Task title\")\n    priority: Priority = Field(\n        default=Priority.MEDIUM,\n        description=\"Task priority level\"\n    )\n```\n\n## Output Format\n\nWhen generating schemas, provide:\n\n### Schema Definition\n```python\n# Complete, copy-paste ready code\nfrom atomic_agents.lib.base.base_io_schema import BaseIOSchema\nfrom pydantic import Field, field_validator\nfrom typing import List, Optional, Literal\n\nclass [SchemaName](BaseIOSchema):\n    \"\"\"[Docstring]\"\"\"\n\n    [fields...]\n\n    [validators if needed...]\n```\n\n### Usage Example\n```python\n# Example instantiation\nschema = SchemaName(\n    field1=\"value1\",\n    field2=123\n)\n\n# Example with agent\nagent = AtomicAgent[SchemaName, OutputSchema](config=config)\n```\n\n### Design Rationale\n- Why each field is included\n- Why specific types/constraints were chosen\n- How validators enforce business rules\n\n## Best Practices Summary\n\n1. **Always use BaseIOSchema** - Never plain BaseModel\n2. **Describe every field** - LLM uses descriptions\n3. **Constrain appropriately** - Use ge, le, min_length, max_length, Literal\n4. **Validate business rules** - Use field_validator and model_validator\n5. **Compose for complexity** - Nest schemas for structured data\n6. **Use Optional wisely** - Only when truly optional\n7. **Default sensibly** - Provide defaults when there's a clear sensible value\n8. **Document with docstrings** - Explain the schema's purpose\n",
        "claude-plugin/atomic-agents/commands/atomic-agent.md": "---\ndescription: Quickly create a new Atomic Agents agent with proper configuration, schemas, and system prompt\nargument-hint: Description of the agent to create (e.g., \"a research agent that summarizes articles\")\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Glob\n  - Grep\n  - Skill\n  - Task\n  - AskUserQuestion\n---\n\n# Quick Agent Creation\n\nCreate a new Atomic Agents agent based on the user's description.\n\n## Process\n\n### 1. Understand Requirements\n\nIf `$ARGUMENTS` is provided, parse the agent description. Otherwise, ask:\n- What should this agent do?\n- What input does it need?\n- What output should it produce?\n\n### 2. Load Knowledge\n\n```\nUse the Skill tool to load: atomic-agents\nUse the Skill tool to load: atomic-schemas\nUse the Skill tool to load: atomic-prompts\n```\n\n### 3. Identify Target Location\n\n- Check if there's an existing project structure\n- Look for `agents/` directory or determine where to create the agent\n- Identify existing schemas to potentially reuse\n\n### 4. Design the Agent\n\nUse the `schema-designer` agent for complex schemas:\n```\nTask(subagent_type=\"schema-designer\", prompt=\"Design input and output schemas for an agent that: [description]. Use ultrathink.\")\n```\n\n### 5. Create Files\n\nCreate the following:\n\n**schemas.py** (or add to existing):\n```python\nfrom atomic_agents.lib.base.base_io_schema import BaseIOSchema\nfrom pydantic import Field\n\nclass [Agent]InputSchema(BaseIOSchema):\n    \"\"\"Input for [agent purpose].\"\"\"\n    # fields...\n\nclass [Agent]OutputSchema(BaseIOSchema):\n    \"\"\"Output from [agent purpose].\"\"\"\n    # fields...\n```\n\n**[agent_name].py**:\n```python\nimport instructor\nimport openai\nfrom atomic_agents.agents.base_agent import AtomicAgent, AgentConfig\nfrom atomic_agents.lib.components.system_prompt_generator import SystemPromptGenerator\nfrom atomic_agents.lib.components.chat_history import ChatHistory\n\nfrom .schemas import [Agent]InputSchema, [Agent]OutputSchema\n\n# Initialize client\nclient = instructor.from_openai(openai.OpenAI())\n\n# Configure agent\nconfig = AgentConfig(\n    client=client,\n    model=\"gpt-4o-mini\",\n    history=ChatHistory(),\n    system_prompt_generator=SystemPromptGenerator(\n        background=[\n            \"You are an expert [role].\",\n            \"Your purpose is to [purpose].\",\n        ],\n        steps=[\n            \"1. [First step]\",\n            \"2. [Second step]\",\n            \"3. [Third step]\",\n        ],\n        output_instructions=[\n            \"Provide [format instructions].\",\n            \"Ensure [quality requirements].\",\n        ],\n    ),\n)\n\n# Create agent\nagent = AtomicAgent[InputSchema, OutputSchema](config=config)\n```\n\n### 6. Provide Usage Example\n\nShow how to use the created agent:\n```python\nfrom [module] import agent, [Agent]InputSchema\n\n# Run the agent\ninput_data = [Agent]InputSchema(field=\"value\")\noutput = agent.run(input_data)\nprint(output)\n```\n\n### 7. Quick Review\n\nPerform a quick validation:\n- [ ] Schemas inherit from BaseIOSchema\n- [ ] All fields have descriptions\n- [ ] SystemPromptGenerator has background, steps, output_instructions\n- [ ] Client is wrapped with instructor\n- [ ] Type parameters match schemas\n\nReport any issues found.\n\n---\n\n## Output\n\nProvide:\n1. Created files with their paths\n2. Usage example\n3. Any suggestions for enhancement\n",
        "claude-plugin/atomic-agents/commands/atomic-create.md": "---\ndescription: Guided workflow for creating well-organized Atomic Agents applications with schema design, agent configuration, tool implementation, and best practices\nargument-hint: Optional description of the application to build\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Glob\n  - Grep\n  - Bash\n  - TodoWrite\n  - AskUserQuestion\n  - Skill\n  - Task\n---\n\n# Atomic Agents Application Development Workflow\n\nYou are guiding the user through creating a well-organized Atomic Agents application. Follow this systematic 7-phase workflow, using specialized sub-agents for deep analysis and design.\n\n## Workflow Overview\n\n| Phase | Goal | Key Actions |\n|-------|------|-------------|\n| 1 | Discovery | Understand what the user wants to build |\n| 2 | Exploration | Analyze existing code if applicable |\n| 3 | Clarification | Resolve ambiguities before design |\n| 4 | Architecture | Design the application structure |\n| 5 | Implementation | Build the components |\n| 6 | Review | Validate against best practices |\n| 7 | Summary | Document what was created |\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what the user wants to build.\n\n**Actions**:\n1. If the user provided an application description in `$ARGUMENTS`, acknowledge it\n2. If not, ask them to describe what they want to build\n3. Identify key requirements:\n   - What is the primary purpose?\n   - What are the inputs and outputs?\n   - Will it need tools (external APIs, databases)?\n   - Is multi-agent orchestration needed?\n   - Does it need streaming or async?\n   - What LLM provider(s) will be used?\n4. Summarize understanding and confirm with the user\n\n**Skill to Load**:\n```\nUse the Skill tool to load: atomic-structure\n```\nThis will provide context on project organization patterns.\n\n**Wait for user confirmation before proceeding.**\n\n---\n\n## Phase 2: Exploration (If Existing Codebase)\n\n**Goal**: Understand existing code patterns and constraints.\n\n**Actions**:\n1. Check if this is a new project or extending an existing one\n2. If existing codebase has Atomic Agents code:\n   - Deploy 2-3 `atomic-explorer` agents in parallel to analyze different aspects:\n     - Agent 1: Map existing agents, their purposes, and schemas\n     - Agent 2: Catalog existing tools and context providers\n     - Agent 3: Trace orchestration patterns and data flow\n\n**Agent Deployment**:\n```\nTask(subagent_type=\"atomic-explorer\", prompt=\"Analyze the existing Atomic Agents codebase. Focus on: [specific aspect]. Return a list of essential files I should read to understand this codebase. Use ultrathink.\")\n```\n\n3. Read the essential files identified by the explorers\n4. Synthesize findings into a codebase overview\n\n**Skip this phase if creating a new project from scratch.**\n\n---\n\n## Phase 3: Clarification\n\n**Goal**: Resolve ambiguities before designing.\n\n**Actions**:\n1. Based on Phase 1 (and Phase 2 if applicable), identify questions:\n   - Schema design choices (what fields, what types?)\n   - Orchestration pattern preferences\n   - External service integrations\n   - Error handling requirements\n   - Performance considerations\n\n2. Use AskUserQuestion tool for critical decisions:\n```\nAskUserQuestion with 2-4 specific questions about their requirements\n```\n\n3. Document answers for use in Phase 4\n\n**Skills to Load** (as needed):\n- `atomic-schemas` - for schema design questions\n- `atomic-agents` - for agent configuration questions\n- `atomic-tools` - for tool integration questions\n- `atomic-context` - for context provider questions\n\n**Wait for user answers before proceeding.**\n\n---\n\n## Phase 4: Architecture Design\n\n**Goal**: Design the application structure.\n\n**Actions**:\n1. Deploy 2-3 `atomic-architect` agents to design different approaches:\n   - Architect 1: Conservative approach (simplest that meets requirements)\n   - Architect 2: Comprehensive approach (includes nice-to-haves)\n   - Architect 3: (Optional) Alternative pattern if applicable\n\n**Agent Deployment**:\n```\nTask(subagent_type=\"atomic-architect\", prompt=\"Design an Atomic Agents application for: [requirements]. Focus on: [approach type]. Include specific schemas, agent configurations, and file structure. Use ultrathink.\")\n```\n\n2. Synthesize the architectural recommendations\n3. Present 2-3 approaches with trade-offs:\n   - Approach 1: [Name] - [Description]\n     - Pros: ...\n     - Cons: ...\n   - Approach 2: [Name] - [Description]\n     - Pros: ...\n     - Cons: ...\n4. Make a clear recommendation for which approach to use\n\n**Wait for user to select an approach before proceeding.**\n\n---\n\n## Phase 5: Implementation\n\n**DO NOT START THIS PHASE WITHOUT EXPLICIT USER APPROVAL**\n\n**Goal**: Build the application components.\n\n**Actions**:\n1. Create a TodoWrite list with all components to implement:\n   - [ ] Project structure (directories, pyproject.toml)\n   - [ ] Configuration (config.py, .env.example)\n   - [ ] Schemas (input/output for each agent)\n   - [ ] Tools (if needed)\n   - [ ] Context providers (if needed)\n   - [ ] Agents\n   - [ ] Orchestration logic (main.py)\n   - [ ] Entry point\n\n2. Implement each component in order:\n\n**For Schemas** - Load the atomic-schemas skill:\n```\nUse the Skill tool to load: atomic-schemas\n```\nThen use the `schema-designer` agent if complex:\n```\nTask(subagent_type=\"schema-designer\", prompt=\"Design schemas for: [description]. Requirements: [specific needs]. Use ultrathink.\")\n```\n\n**For Agents** - Load the atomic-agents skill:\n```\nUse the Skill tool to load: atomic-agents\n```\n\n**For Tools** - Load the atomic-tools skill:\n```\nUse the Skill tool to load: atomic-tools\n```\n\n**For Context Providers** - Load the atomic-context skill:\n```\nUse the Skill tool to load: atomic-context\n```\n\n**For System Prompts** - Load the atomic-prompts skill:\n```\nUse the Skill tool to load: atomic-prompts\n```\n\n3. Write each file using the Write or Edit tool\n4. Mark each todo as completed when done\n\n---\n\n## Phase 6: Quality Review\n\n**Goal**: Validate the implementation against best practices.\n\n**Actions**:\n1. Deploy `atomic-reviewer` agents to review different aspects:\n   - Reviewer 1: Schema quality and type safety\n   - Reviewer 2: Agent configuration and prompts\n   - Reviewer 3: Security and error handling\n\n**Agent Deployment**:\n```\nTask(subagent_type=\"atomic-reviewer\", prompt=\"Review the Atomic Agents code in [path]. Focus on: [aspect]. Report issues with confidence >= 75 only. Use ultrathink.\")\n```\n\n2. Synthesize review findings\n3. Present issues to user, grouped by severity:\n   - Critical (must fix)\n   - Important (should fix)\n   - Suggestions (consider)\n\n**Wait for user to decide which issues to address.**\n\n4. Fix approved issues\n\n---\n\n## Phase 7: Summary\n\n**Goal**: Document what was created.\n\n**Actions**:\n1. Summarize the application:\n   - Purpose and capabilities\n   - Components created (agents, tools, schemas)\n   - Architecture pattern used\n   - Key design decisions\n\n2. Provide usage instructions:\n   - How to install dependencies\n   - How to configure (.env setup)\n   - How to run the application\n\n3. Suggest next steps:\n   - Testing recommendations\n   - Potential enhancements\n   - Documentation to add\n\n4. Celebrate the successful creation!\n\n---\n\n## Critical Guidelines\n\n1. **Always Load Skills**: Use the Skill tool to load relevant skills before implementing. This ensures you have the latest Atomic Agents patterns.\n\n2. **Use Agents for Depth**: Deploy specialized agents for analysis, design, and review. Don't try to do everything yourself.\n\n3. **Wait at Decision Points**: Phases 1, 3, 4, and 6 require user input. Don't proceed without it.\n\n4. **Track Progress**: Use TodoWrite to track what's been done and what remains.\n\n5. **Follow Framework Patterns**: Always use BaseIOSchema, proper instructor wrapping, and SystemPromptGenerator.\n\n6. **Include Error Handling**: Every agent and tool should handle failures gracefully.\n\n7. **Security First**: Never hardcode secrets. Use environment variables.\n\n8. **Document As You Go**: Include docstrings and comments for complex logic.\n",
        "claude-plugin/atomic-agents/commands/atomic-tool.md": "---\ndescription: Quickly create a new Atomic Agents tool with proper input/output schemas and error handling\nargument-hint: Description of the tool to create (e.g., \"a weather API tool that fetches current conditions\")\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Glob\n  - Grep\n  - Skill\n  - Task\n  - AskUserQuestion\n---\n\n# Quick Tool Creation\n\nCreate a new Atomic Agents tool based on the user's description.\n\n## Process\n\n### 1. Understand Requirements\n\nIf `$ARGUMENTS` is provided, parse the tool description. Otherwise, ask:\n- What should this tool do?\n- What external service does it interact with (API, database, file system)?\n- What input parameters does it need?\n- What output should it return?\n- What error conditions should be handled?\n\n### 2. Load Knowledge\n\n```\nUse the Skill tool to load: atomic-tools\nUse the Skill tool to load: atomic-schemas\n```\n\n### 3. Identify Target Location\n\n- Check if there's an existing project structure\n- Look for `tools/` directory or determine where to create the tool\n- Check for existing config patterns for API keys\n\n### 4. Design the Tool\n\nUse the `schema-designer` agent for the schemas:\n```\nTask(subagent_type=\"schema-designer\", prompt=\"Design input and output schemas for a tool that: [description]. Include error handling schema if applicable. Use ultrathink.\")\n```\n\n### 5. Create Files\n\n**[tool_name]_tool.py**:\n```python\nfrom atomic_agents.lib.base.base_tool import BaseTool, BaseToolConfig\nfrom atomic_agents.lib.base.base_io_schema import BaseIOSchema\nfrom pydantic import Field\nfrom typing import Optional\nimport os\n\n# ============================================================\n# Input/Output Schemas\n# ============================================================\n\nclass [Tool]InputSchema(BaseIOSchema):\n    \"\"\"Input for [tool purpose].\"\"\"\n\n    param: str = Field(\n        ...,\n        description=\"Description of this parameter\"\n    )\n\n\nclass [Tool]OutputSchema(BaseIOSchema):\n    \"\"\"Successful output from [tool purpose].\"\"\"\n\n    result: str = Field(\n        ...,\n        description=\"The result from the tool\"\n    )\n\n\nclass [Tool]ErrorSchema(BaseIOSchema):\n    \"\"\"Error output from [tool purpose].\"\"\"\n\n    error: str = Field(\n        ...,\n        description=\"Error message describing what went wrong\"\n    )\n    error_code: Optional[str] = Field(\n        default=None,\n        description=\"Error code if available\"\n    )\n\n\n# ============================================================\n# Tool Configuration\n# ============================================================\n\nclass [Tool]Config(BaseToolConfig):\n    \"\"\"Configuration for [Tool].\"\"\"\n\n    api_key: str = Field(\n        default_factory=lambda: os.getenv(\"[SERVICE]_API_KEY\", \"\"),\n        description=\"API key for [service]\"\n    )\n    base_url: str = Field(\n        default=\"https://api.example.com\",\n        description=\"Base URL for API requests\"\n    )\n    timeout: int = Field(\n        default=30,\n        description=\"Request timeout in seconds\"\n    )\n\n\n# ============================================================\n# Tool Implementation\n# ============================================================\n\nclass [Tool](BaseTool):\n    \"\"\"\n    Tool for [purpose].\n\n    This tool [detailed description of what it does].\n    \"\"\"\n\n    input_schema = [Tool]InputSchema\n    output_schema = [Tool]OutputSchema\n\n    def __init__(self, config: [Tool]Config = None):\n        \"\"\"Initialize the tool with configuration.\"\"\"\n        super().__init__(config or [Tool]Config())\n        self.config: [Tool]Config = self.config\n\n    def run(self, params: [Tool]InputSchema) -> [Tool]OutputSchema | [Tool]ErrorSchema:\n        \"\"\"\n        Execute the tool.\n\n        Args:\n            params: Input parameters for the tool\n\n        Returns:\n            [Tool]OutputSchema on success, [Tool]ErrorSchema on failure\n        \"\"\"\n        try:\n            # Validate configuration\n            if not self.config.api_key:\n                return [Tool]ErrorSchema(\n                    error=\"API key not configured\",\n                    error_code=\"CONFIG_ERROR\"\n                )\n\n            # Implement tool logic here\n            # Example:\n            # response = requests.get(\n            #     f\"{self.config.base_url}/endpoint\",\n            #     params={\"q\": params.param},\n            #     headers={\"Authorization\": f\"Bearer {self.config.api_key}\"},\n            #     timeout=self.config.timeout\n            # )\n            # response.raise_for_status()\n            # data = response.json()\n\n            result = f\"Processed: {params.param}\"  # Replace with actual logic\n\n            return [Tool]OutputSchema(result=result)\n\n        except Exception as e:\n            return [Tool]ErrorSchema(\n                error=str(e),\n                error_code=\"EXECUTION_ERROR\"\n            )\n\n\n# ============================================================\n# Convenience Instance\n# ============================================================\n\n# Default tool instance (can be overridden with custom config)\ntool = [Tool]()\n```\n\n### 6. Provide Usage Examples\n\n**Direct Usage**:\n```python\nfrom [module].[tool_name]_tool import tool, [Tool]InputSchema\n\n# Run the tool\ninput_data = [Tool]InputSchema(param=\"value\")\nresult = tool.run(input_data)\n\nif isinstance(result, [Tool]ErrorSchema):\n    print(f\"Error: {result.error}\")\nelse:\n    print(f\"Result: {result.result}\")\n```\n\n**With Custom Config**:\n```python\nfrom [module].[tool_name]_tool import [Tool], [Tool]Config, [Tool]InputSchema\n\n# Custom configuration\nconfig = [Tool]Config(\n    api_key=\"your-api-key\",\n    timeout=60\n)\n\n# Create tool with custom config\ncustom_tool = [Tool](config=config)\nresult = custom_tool.run([Tool]InputSchema(param=\"value\"))\n```\n\n**With Agent**:\n```python\nfrom atomic_agents.agents.base_agent import AtomicAgent, AgentConfig\nfrom [module].[tool_name]_tool import tool\n\n# Agent can use the tool\n# (Show how to integrate with agent's tool orchestration)\n```\n\n### 7. Quick Review\n\nPerform a quick validation:\n- [ ] Schemas inherit from BaseIOSchema\n- [ ] All fields have descriptions\n- [ ] Tool inherits from BaseTool\n- [ ] input_schema and output_schema class attributes are set\n- [ ] Error handling returns ErrorSchema, not raising exceptions\n- [ ] Configuration uses environment variables for secrets\n- [ ] Timeout is set for external calls\n\nReport any issues found.\n\n---\n\n## Output\n\nProvide:\n1. Created files with their paths\n2. Required environment variables\n3. Usage examples (direct and with agent)\n4. Any suggestions for enhancement\n",
        "claude-plugin/atomic-agents/skills/atomic-agents/SKILL.md": "---\ndescription: This skill should be used when the user asks to \"create an agent\", \"configure AtomicAgent\", \"set up agent\", \"agent configuration\", \"AgentConfig\", \"ChatHistory\", or needs guidance on agent initialization, model selection, history management, and agent execution patterns for Atomic Agents applications.\n---\n\n# Atomic Agents Agent Configuration\n\nThe `AtomicAgent` is the core class for LLM interactions in the Atomic Agents framework. It handles structured input/output, conversation history, and system prompt management.\n\n## Basic Agent Setup\n\n```python\nimport instructor\nimport openai\nfrom atomic_agents.agents.base_agent import AtomicAgent, AgentConfig\nfrom atomic_agents.lib.components.system_prompt_generator import SystemPromptGenerator\nfrom atomic_agents.lib.components.chat_history import ChatHistory\n\n# 1. Create instructor-wrapped client\nclient = instructor.from_openai(openai.OpenAI())\n\n# 2. Configure the agent\nconfig = AgentConfig(\n    client=client,\n    model=\"gpt-4o-mini\",\n    history=ChatHistory(),\n    system_prompt_generator=SystemPromptGenerator(\n        background=[\"You are an expert assistant.\"],\n        steps=[\"1. Analyze the input.\", \"2. Generate response.\"],\n        output_instructions=[\"Be concise and helpful.\"],\n    ),\n)\n\n# 3. Create the agent with type parameters\nagent = AtomicAgent[InputSchema, OutputSchema](config=config)\n```\n\n## AgentConfig Parameters\n\n| Parameter | Type | Required | Description |\n|-----------|------|----------|-------------|\n| `client` | Instructor client | Yes | Instructor-wrapped LLM client |\n| `model` | str | Yes | Model identifier (e.g., \"gpt-4o-mini\") |\n| `history` | ChatHistory | No | Conversation history manager |\n| `system_prompt_generator` | SystemPromptGenerator | No | System prompt configuration |\n| `input_schema` | BaseIOSchema | No | Override input schema |\n| `output_schema` | BaseIOSchema | No | Override output schema |\n| `model_api_parameters` | dict | No | Additional API parameters |\n\n## LLM Provider Setup\n\n### OpenAI\n```python\nimport instructor\nimport openai\n\nclient = instructor.from_openai(openai.OpenAI(api_key=os.getenv(\"OPENAI_API_KEY\")))\nmodel = \"gpt-4o-mini\"  # or \"gpt-4o\", \"gpt-4-turbo\"\n```\n\n### Anthropic\n```python\nimport instructor\nimport anthropic\n\nclient = instructor.from_anthropic(anthropic.Anthropic(api_key=os.getenv(\"ANTHROPIC_API_KEY\")))\nmodel = \"claude-sonnet-4-20250514\"\n```\n\n### Groq\n```python\nimport instructor\nfrom groq import Groq\n\nclient = instructor.from_groq(Groq(api_key=os.getenv(\"GROQ_API_KEY\")), mode=instructor.Mode.JSON)\nmodel = \"llama-3.1-70b-versatile\"\n```\n\n### Ollama (Local)\n```python\nimport instructor\nimport openai\n\nclient = instructor.from_openai(\n    openai.OpenAI(base_url=\"http://localhost:11434/v1\", api_key=\"ollama\")\n)\nmodel = \"llama3.1\"\n```\n\n## Agent Execution Methods\n\n### Synchronous\n```python\noutput = agent.run(InputSchema(message=\"Hello\"))\n```\n\n### Asynchronous\n```python\noutput = await agent.run_async(InputSchema(message=\"Hello\"))\n```\n\n### Streaming (Sync)\n```python\nfor partial in agent.run_stream(InputSchema(message=\"Hello\")):\n    print(partial)  # Partial responses as they arrive\n```\n\n### Streaming (Async)\n```python\nasync for partial in agent.run_async_stream(InputSchema(message=\"Hello\")):\n    print(partial)\n```\n\n## ChatHistory Management\n\n```python\nfrom atomic_agents.lib.components.chat_history import ChatHistory\n\n# Create history\nhistory = ChatHistory()\n\n# Use with agent\nconfig = AgentConfig(client=client, model=model, history=history)\nagent = AtomicAgent[InputSchema, OutputSchema](config=config)\n\n# Run multiple turns (history accumulates)\nagent.run(InputSchema(message=\"Hello\"))\nagent.run(InputSchema(message=\"Tell me more\"))\n\n# Reset history\nagent.reset_history()\n\n# Save/load history\nhistory_data = history.to_dict()\nnew_history = ChatHistory.from_dict(history_data)\n```\n\n## Context Providers\n\nDynamic context injection into system prompts:\n\n```python\nfrom atomic_agents.lib.components.system_prompt_generator import BaseDynamicContextProvider\n\nclass UserContextProvider(BaseDynamicContextProvider):\n    def __init__(self):\n        super().__init__(title=\"User Context\")\n        self.user_name = \"\"\n\n    def get_info(self) -> str:\n        return f\"Current user: {self.user_name}\"\n\n# Register with agent\nprovider = UserContextProvider()\nagent.register_context_provider(\"user\", provider)\n\n# Update context dynamically\nprovider.user_name = \"Alice\"\nagent.run(input_data)  # System prompt now includes user context\n```\n\n## Token Counting\n\n```python\n# Get token usage\ntoken_info = agent.get_context_token_count()\n\nprint(f\"Total: {token_info.total}\")\nprint(f\"System prompt: {token_info.system_prompt}\")\nprint(f\"History: {token_info.history}\")\nprint(f\"Utilization: {token_info.utilization:.1%}\")\n```\n\n## Hooks for Monitoring\n\n```python\ndef on_response(response):\n    print(f\"Got response: {response}\")\n\ndef on_error(error):\n    print(f\"Error: {error}\")\n\nagent.register_hook(\"completion:response\", on_response)\nagent.register_hook(\"completion:error\", on_error)\nagent.register_hook(\"parse:error\", on_error)\n```\n\nHook events:\n- `completion:kwargs` - Before API call\n- `completion:response` - After successful response\n- `completion:error` - On API error\n- `parse:error` - On parsing/validation error\n\n## Model API Parameters\n\nPass additional parameters to the LLM:\n\n```python\nconfig = AgentConfig(\n    client=client,\n    model=\"gpt-4o\",\n    model_api_parameters={\n        \"max_tokens\": 1000,\n        \"temperature\": 0.7,\n        \"top_p\": 0.9,\n    },\n)\n```\n\n## Best Practices\n\n1. **Always wrap with instructor** - Required for structured outputs\n2. **Use environment variables** - Never hardcode API keys\n3. **Initialize history when needed** - Only if conversation state matters\n4. **Type your agents** - `AtomicAgent[Input, Output]` for type safety\n5. **Use streaming for long responses** - Better user experience\n6. **Monitor with hooks** - Track errors and performance\n7. **Reset history appropriately** - Prevent context overflow\n\n## References\n\nSee `references/` for:\n- `multi-provider.md` - Detailed provider configurations\n- `async-patterns.md` - Async and streaming patterns\n\nSee `examples/` for:\n- `basic-agent.py` - Minimal agent setup\n- `streaming-agent.py` - Streaming implementation\n",
        "claude-plugin/atomic-agents/skills/atomic-context/SKILL.md": "---\ndescription: This skill should be used when the user asks to \"create context provider\", \"dynamic context\", \"inject context\", \"BaseDynamicContextProvider\", \"share data between agents\", or needs guidance on context providers, dynamic prompt injection, and sharing information across agents in Atomic Agents applications.\n---\n\n# Atomic Agents Context Providers\n\nContext providers dynamically inject information into agent system prompts at runtime. They enable agents to access current data without modifying the base prompt.\n\n## Core Concept\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                   System Prompt                         │\n├─────────────────────────────────────────────────────────┤\n│ Background: [static content]                            │\n│ Steps: [static content]                                 │\n│ Output Instructions: [static content]                   │\n│                                                         │\n│ ┌─────────────────────────────────────────────────────┐ │\n│ │ Dynamic Context:                                    │ │\n│ │ - User Context: Current user is Alice               │ │\n│ │ - RAG Context: [retrieved documents]                │ │\n│ │ - Time Context: Current time is 2025-01-15          │ │\n│ └─────────────────────────────────────────────────────┘ │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Basic Context Provider\n\n```python\nfrom atomic_agents.lib.components.system_prompt_generator import BaseDynamicContextProvider\n\nclass UserContextProvider(BaseDynamicContextProvider):\n    \"\"\"Provides current user information to the agent.\"\"\"\n\n    def __init__(self):\n        super().__init__(title=\"User Context\")\n        self.user_name: str = \"\"\n        self.user_role: str = \"\"\n\n    def get_info(self) -> str:\n        if not self.user_name:\n            return \"No user logged in.\"\n        return f\"Current user: {self.user_name} (Role: {self.user_role})\"\n```\n\n## Registering Providers\n\n```python\nfrom atomic_agents.agents.base_agent import AtomicAgent, AgentConfig\n\n# Create agent\nagent = AtomicAgent[InputSchema, OutputSchema](config=config)\n\n# Create and register provider\nuser_provider = UserContextProvider()\nagent.register_context_provider(\"user\", user_provider)\n\n# Update context before running\nuser_provider.user_name = \"Alice\"\nuser_provider.user_role = \"Admin\"\n\n# Run agent - system prompt now includes user context\noutput = agent.run(input_data)\n```\n\n## Common Context Provider Patterns\n\n### RAG Context Provider\n```python\nclass RAGContextProvider(BaseDynamicContextProvider):\n    \"\"\"Provides retrieved documents to the agent.\"\"\"\n\n    def __init__(self):\n        super().__init__(title=\"Retrieved Documents\")\n        self.documents: list[dict] = []\n\n    def set_documents(self, docs: list[dict]):\n        \"\"\"Set retrieved documents.\"\"\"\n        self.documents = docs\n\n    def get_info(self) -> str:\n        if not self.documents:\n            return \"No relevant documents found.\"\n\n        sections = []\n        for i, doc in enumerate(self.documents, 1):\n            sections.append(f\"Document {i}:\\n{doc['content']}\\nSource: {doc['source']}\")\n\n        return \"\\n\\n\".join(sections)\n\n\n# Usage\nrag_provider = RAGContextProvider()\nagent.register_context_provider(\"rag\", rag_provider)\n\n# Before each query, update with relevant docs\nrelevant_docs = vector_db.search(query)\nrag_provider.set_documents(relevant_docs)\noutput = agent.run(query_input)\n```\n\n### Time Context Provider\n```python\nfrom datetime import datetime\n\nclass TimeContextProvider(BaseDynamicContextProvider):\n    \"\"\"Provides current time information.\"\"\"\n\n    def __init__(self):\n        super().__init__(title=\"Current Time\")\n\n    def get_info(self) -> str:\n        now = datetime.now()\n        return f\"Current date and time: {now.strftime('%Y-%m-%d %H:%M:%S')}\"\n```\n\n### Session Context Provider\n```python\nclass SessionContextProvider(BaseDynamicContextProvider):\n    \"\"\"Provides session-specific context.\"\"\"\n\n    def __init__(self):\n        super().__init__(title=\"Session Context\")\n        self.session_data: dict = {}\n\n    def set(self, key: str, value: str):\n        self.session_data[key] = value\n\n    def get_info(self) -> str:\n        if not self.session_data:\n            return \"No session context available.\"\n\n        lines = [f\"- {k}: {v}\" for k, v in self.session_data.items()]\n        return \"Session information:\\n\" + \"\\n\".join(lines)\n```\n\n### Database Context Provider\n```python\nclass DatabaseContextProvider(BaseDynamicContextProvider):\n    \"\"\"Provides database schema or recent data.\"\"\"\n\n    def __init__(self, db_connection):\n        super().__init__(title=\"Database Context\")\n        self.db = db_connection\n        self._cache = None\n        self._cache_time = None\n\n    def get_info(self) -> str:\n        # Cache for 5 minutes\n        if self._cache and (time.time() - self._cache_time) < 300:\n            return self._cache\n\n        tables = self.db.get_table_names()\n        schema_info = []\n        for table in tables:\n            columns = self.db.get_columns(table)\n            schema_info.append(f\"Table: {table}\\n  Columns: {', '.join(columns)}\")\n\n        self._cache = \"Database Schema:\\n\" + \"\\n\".join(schema_info)\n        self._cache_time = time.time()\n        return self._cache\n```\n\n## Managing Providers\n\n```python\n# Register\nagent.register_context_provider(\"name\", provider)\n\n# Unregister\nagent.unregister_context_provider(\"name\")\n\n# Check if registered\nif \"name\" in agent.context_providers:\n    print(\"Provider is registered\")\n```\n\n## Sharing Context Between Agents\n\n```python\n# Create shared provider\nshared_context = SharedContextProvider()\n\n# Register with multiple agents\nagent1.register_context_provider(\"shared\", shared_context)\nagent2.register_context_provider(\"shared\", shared_context)\n\n# Update once, both agents see the change\nshared_context.update_data(new_data)\n```\n\n## Context Provider Best Practices\n\n1. **Keep get_info() fast** - It's called on every agent.run()\n2. **Cache when appropriate** - Avoid repeated expensive operations\n3. **Return strings** - get_info() must return a string\n4. **Use descriptive titles** - Title appears in system prompt\n5. **Handle empty state** - Return helpful message when no data\n6. **Update before run** - Set context before calling agent.run()\n7. **Don't block** - Use async providers for slow operations\n\n## Advanced: Async Context Provider\n\nFor providers that need async data fetching:\n\n```python\nclass AsyncContextProvider(BaseDynamicContextProvider):\n    def __init__(self):\n        super().__init__(title=\"Async Data\")\n        self._cached_data = \"\"\n\n    async def refresh(self):\n        \"\"\"Call this before agent.run_async()\"\"\"\n        data = await fetch_external_data()\n        self._cached_data = format_data(data)\n\n    def get_info(self) -> str:\n        return self._cached_data\n\n# Usage\nawait context_provider.refresh()\noutput = await agent.run_async(input_data)\n```\n\n## References\n\nSee `references/` for:\n- `rag-patterns.md` - RAG context provider patterns\n- `caching-strategies.md` - Context caching approaches\n\nSee `examples/` for:\n- `user-context.py` - User session provider\n- `rag-context.py` - Document retrieval provider\n",
        "claude-plugin/atomic-agents/skills/atomic-prompts/SKILL.md": "---\ndescription: This skill should be used when the user asks to \"write system prompt\", \"configure SystemPromptGenerator\", \"prompt engineering\", \"background steps output_instructions\", \"improve agent prompt\", or needs guidance on structuring system prompts, writing effective instructions, and optimizing agent behavior in Atomic Agents applications.\n---\n\n# Atomic Agents System Prompt Design\n\nThe `SystemPromptGenerator` creates structured, effective system prompts for agents. It combines static instructions with dynamic context from providers.\n\n## SystemPromptGenerator Structure\n\n```python\nfrom atomic_agents.lib.components.system_prompt_generator import SystemPromptGenerator\n\nsystem_prompt = SystemPromptGenerator(\n    background=[\n        # WHO the agent is\n        \"You are an expert data analyst.\",\n        \"You specialize in financial data interpretation.\",\n    ],\n    steps=[\n        # HOW to process requests\n        \"1. Understand the user's question about the data.\",\n        \"2. Identify relevant data points and trends.\",\n        \"3. Analyze patterns and correlations.\",\n        \"4. Formulate clear, actionable insights.\",\n    ],\n    output_instructions=[\n        # WHAT to produce\n        \"Provide insights in clear, non-technical language.\",\n        \"Include specific numbers and percentages.\",\n        \"Highlight key takeaways at the beginning.\",\n    ],\n)\n```\n\n## Three-Part Structure\n\n### Background (WHO)\nEstablishes the agent's identity, expertise, and role:\n\n```python\nbackground=[\n    \"You are an expert [role] with deep knowledge in [domain].\",\n    \"Your purpose is to [primary function].\",\n    \"You have experience with [relevant experience].\",\n    \"You approach problems with [methodology/style].\",\n]\n```\n\n**Examples by domain:**\n```python\n# Customer Support\nbackground=[\n    \"You are a helpful customer support specialist.\",\n    \"You represent [Company] and embody its values of helpfulness and clarity.\",\n    \"You have comprehensive knowledge of our products and policies.\",\n]\n\n# Code Assistant\nbackground=[\n    \"You are an expert software engineer specializing in Python.\",\n    \"You write clean, maintainable, well-documented code.\",\n    \"You follow best practices and design patterns.\",\n]\n\n# Research Assistant\nbackground=[\n    \"You are a research analyst with expertise in synthesizing information.\",\n    \"You excel at finding patterns across multiple sources.\",\n    \"You prioritize accuracy and cite sources when possible.\",\n]\n```\n\n### Steps (HOW)\nDefines the processing workflow:\n\n```python\nsteps=[\n    \"1. [First action to take]\",\n    \"2. [Second action to take]\",\n    \"3. [Third action to take]\",\n    \"4. [Final action to take]\",\n]\n```\n\n**Effective step patterns:**\n\n```python\n# Analysis Pattern\nsteps=[\n    \"1. Parse and understand the input data.\",\n    \"2. Identify key elements and relationships.\",\n    \"3. Apply relevant analysis techniques.\",\n    \"4. Synthesize findings into coherent insights.\",\n    \"5. Validate conclusions against the data.\",\n]\n\n# Q&A Pattern\nsteps=[\n    \"1. Understand the user's question fully.\",\n    \"2. Retrieve relevant information from context.\",\n    \"3. Formulate a clear, accurate answer.\",\n    \"4. Provide supporting details if helpful.\",\n]\n\n# Task Execution Pattern\nsteps=[\n    \"1. Parse the task requirements.\",\n    \"2. Break down into subtasks if complex.\",\n    \"3. Execute each subtask systematically.\",\n    \"4. Validate the output meets requirements.\",\n]\n```\n\n### Output Instructions (WHAT)\nSpecifies the response format and quality:\n\n```python\noutput_instructions=[\n    \"Format your response as [format].\",\n    \"Include [required elements].\",\n    \"Ensure [quality requirements].\",\n    \"Avoid [things to exclude].\",\n]\n```\n\n**Format examples:**\n\n```python\n# Structured Output\noutput_instructions=[\n    \"Provide your response with a summary first.\",\n    \"Use bullet points for key findings.\",\n    \"Include confidence level (high/medium/low).\",\n    \"End with actionable recommendations.\",\n]\n\n# Conversational Output\noutput_instructions=[\n    \"Respond in a friendly, conversational tone.\",\n    \"Keep responses concise but complete.\",\n    \"Ask clarifying questions if needed.\",\n]\n\n# Technical Output\noutput_instructions=[\n    \"Include code examples where appropriate.\",\n    \"Explain technical concepts clearly.\",\n    \"Reference documentation or sources.\",\n]\n```\n\n## Integrating Context Providers\n\nContext providers add dynamic sections:\n\n```python\nfrom atomic_agents.lib.components.system_prompt_generator import (\n    SystemPromptGenerator,\n    BaseDynamicContextProvider,\n)\n\nclass RAGProvider(BaseDynamicContextProvider):\n    def __init__(self):\n        super().__init__(title=\"Relevant Documents\")\n        self.docs = []\n\n    def get_info(self) -> str:\n        return \"\\n\".join(self.docs)\n\n# Create generator\ngenerator = SystemPromptGenerator(\n    background=[\"You answer questions using provided documents.\"],\n    steps=[\"1. Read the documents.\", \"2. Answer based on them.\"],\n    output_instructions=[\"Cite document sources.\"],\n)\n\n# Register provider\nrag = RAGProvider()\nagent.register_context_provider(\"rag\", rag)\n```\n\nThe generated prompt will include:\n```\n[Background section]\n[Steps section]\n[Output Instructions section]\n\n## Relevant Documents\n[Dynamic content from provider]\n```\n\n## Prompt Engineering Tips\n\n### Be Specific\n```python\n# Bad\nbackground=[\"You are helpful.\"]\n\n# Good\nbackground=[\n    \"You are a Python code reviewer.\",\n    \"You identify bugs, security issues, and style violations.\",\n    \"You follow PEP 8 and common best practices.\",\n]\n```\n\n### Use Action Verbs\n```python\n# Bad\nsteps=[\"Think about the problem.\"]\n\n# Good\nsteps=[\n    \"1. Identify the core issue.\",\n    \"2. List possible solutions.\",\n    \"3. Evaluate trade-offs.\",\n    \"4. Recommend the best approach.\",\n]\n```\n\n### Constrain Output\n```python\n# Bad\noutput_instructions=[\"Give a good answer.\"]\n\n# Good\noutput_instructions=[\n    \"Limit response to 3 paragraphs maximum.\",\n    \"Start with the most important point.\",\n    \"Include one specific example.\",\n]\n```\n\n### Handle Edge Cases\n```python\nbackground=[\n    \"If you cannot answer with certainty, say so clearly.\",\n    \"If the question is ambiguous, ask for clarification.\",\n    \"If the request is outside your expertise, acknowledge it.\",\n]\n```\n\n## Common Prompt Patterns\n\n### Expert Assistant\n```python\nSystemPromptGenerator(\n    background=[\n        \"You are an expert [domain] assistant.\",\n        \"You provide accurate, helpful information.\",\n        \"You acknowledge when you're uncertain.\",\n    ],\n    steps=[\n        \"1. Understand the user's need.\",\n        \"2. Provide relevant information.\",\n        \"3. Offer follow-up suggestions.\",\n    ],\n    output_instructions=[\n        \"Be concise but thorough.\",\n        \"Use examples when helpful.\",\n    ],\n)\n```\n\n### Analyst\n```python\nSystemPromptGenerator(\n    background=[\n        \"You are a data analyst.\",\n        \"You find insights in data.\",\n    ],\n    steps=[\n        \"1. Examine the data carefully.\",\n        \"2. Identify patterns and anomalies.\",\n        \"3. Draw conclusions.\",\n        \"4. Suggest actions.\",\n    ],\n    output_instructions=[\n        \"Include specific numbers.\",\n        \"Highlight key findings first.\",\n        \"Use simple language.\",\n    ],\n)\n```\n\n### Code Generator\n```python\nSystemPromptGenerator(\n    background=[\n        \"You are an expert programmer.\",\n        \"You write clean, efficient code.\",\n    ],\n    steps=[\n        \"1. Understand the requirements.\",\n        \"2. Plan the implementation.\",\n        \"3. Write the code.\",\n        \"4. Add comments and documentation.\",\n    ],\n    output_instructions=[\n        \"Include complete, runnable code.\",\n        \"Add comments for complex logic.\",\n        \"Follow language conventions.\",\n    ],\n)\n```\n\n## References\n\nSee `references/` for:\n- `prompt-patterns.md` - More prompt templates\n- `optimization.md` - Token-efficient prompts\n\nSee `examples/` for:\n- `domain-prompts.py` - Domain-specific examples\n",
        "claude-plugin/atomic-agents/skills/atomic-schemas/SKILL.md": "---\ndescription: This skill should be used when the user asks to \"create a schema\", \"define input/output\", \"add fields\", \"validate data\", \"Pydantic schema\", \"BaseIOSchema\", or needs guidance on schema design patterns, field definitions, validators, and type constraints for Atomic Agents applications.\n---\n\n# Atomic Agents Schema Design\n\nSchemas are the foundation of Atomic Agents applications. They define the contracts between agents, tools, and external systems using Pydantic models.\n\n## Core Principle: Always Use BaseIOSchema\n\n```python\nfrom atomic_agents.lib.base.base_io_schema import BaseIOSchema\nfrom pydantic import Field\n\nclass MySchema(BaseIOSchema):\n    \"\"\"Schema description.\"\"\"\n    field: str = Field(..., description=\"Field description\")\n```\n\n**Never use plain `BaseModel`** - `BaseIOSchema` provides Atomic Agents integration features.\n\n## Field Definitions\n\n### Required Fields\n```python\nname: str = Field(..., description=\"The user's full name\")\n```\n\n### Optional Fields\n```python\nfrom typing import Optional\nnickname: Optional[str] = Field(default=None, description=\"Optional nickname\")\n```\n\n### Fields with Defaults\n```python\ncount: int = Field(default=10, description=\"Number of items to return\")\n```\n\n### Constrained Fields\n```python\n# Numeric constraints\nage: int = Field(..., ge=0, le=150, description=\"Age in years\")\nscore: float = Field(..., ge=0.0, le=1.0, description=\"Score between 0 and 1\")\n\n# String constraints\nname: str = Field(..., min_length=1, max_length=100, description=\"Name\")\n\n# List constraints\ntags: List[str] = Field(default_factory=list, max_length=10, description=\"Tags\")\n```\n\n### Literal Types (Fixed Options)\n```python\nfrom typing import Literal\nstatus: Literal[\"pending\", \"approved\", \"rejected\"] = Field(..., description=\"Status\")\n```\n\n### Enums\n```python\nfrom enum import Enum\n\nclass Priority(str, Enum):\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n\npriority: Priority = Field(default=Priority.MEDIUM, description=\"Priority level\")\n```\n\n## Validators\n\n### Field Validators\n```python\nfrom pydantic import field_validator\n\nclass EmailSchema(BaseIOSchema):\n    email: str = Field(..., description=\"Email address\")\n\n    @field_validator(\"email\")\n    @classmethod\n    def validate_email(cls, v: str) -> str:\n        if \"@\" not in v:\n            raise ValueError(\"Invalid email format\")\n        return v.lower()\n```\n\n### Model Validators\n```python\nfrom pydantic import model_validator\n\nclass DateRangeSchema(BaseIOSchema):\n    start: str = Field(..., description=\"Start date\")\n    end: str = Field(..., description=\"End date\")\n\n    @model_validator(mode=\"after\")\n    def validate_range(self) -> \"DateRangeSchema\":\n        if self.end < self.start:\n            raise ValueError(\"end must be after start\")\n        return self\n```\n\n## Common Patterns\n\n### Chat Input/Output\n```python\nclass ChatInputSchema(BaseIOSchema):\n    \"\"\"User message input.\"\"\"\n    message: str = Field(..., min_length=1, description=\"User's message\")\n\nclass ChatOutputSchema(BaseIOSchema):\n    \"\"\"Agent response output.\"\"\"\n    response: str = Field(..., description=\"Agent's response\")\n```\n\n### Structured Analysis Output\n```python\nclass AnalysisOutputSchema(BaseIOSchema):\n    \"\"\"Structured analysis result.\"\"\"\n    summary: str = Field(..., description=\"Brief summary\")\n    findings: List[str] = Field(default_factory=list, description=\"Key findings\")\n    confidence: float = Field(..., ge=0, le=1, description=\"Confidence score\")\n    recommendations: List[str] = Field(default_factory=list, description=\"Recommendations\")\n```\n\n### Tool Schemas\n```python\nclass ToolInputSchema(BaseIOSchema):\n    \"\"\"Tool input parameters.\"\"\"\n    query: str = Field(..., description=\"Search query\")\n\nclass ToolOutputSchema(BaseIOSchema):\n    \"\"\"Successful tool result.\"\"\"\n    result: str = Field(..., description=\"Tool result\")\n\nclass ToolErrorSchema(BaseIOSchema):\n    \"\"\"Tool error result.\"\"\"\n    error: str = Field(..., description=\"Error message\")\n    code: Optional[str] = Field(default=None, description=\"Error code\")\n```\n\n### Nested Schemas\n```python\nclass AddressSchema(BaseIOSchema):\n    \"\"\"Mailing address.\"\"\"\n    street: str = Field(..., description=\"Street address\")\n    city: str = Field(..., description=\"City\")\n    country: str = Field(..., description=\"Country code\")\n\nclass PersonSchema(BaseIOSchema):\n    \"\"\"Person with address.\"\"\"\n    name: str = Field(..., description=\"Full name\")\n    address: AddressSchema = Field(..., description=\"Mailing address\")\n```\n\n### Union Types\n```python\nfrom typing import Union\n\nclass TextContent(BaseIOSchema):\n    type: Literal[\"text\"] = \"text\"\n    text: str = Field(..., description=\"Text content\")\n\nclass ImageContent(BaseIOSchema):\n    type: Literal[\"image\"] = \"image\"\n    url: str = Field(..., description=\"Image URL\")\n\nclass MessageSchema(BaseIOSchema):\n    content: Union[TextContent, ImageContent] = Field(..., description=\"Content\")\n```\n\n## Best Practices\n\n1. **Always provide descriptions** - LLMs use them to understand field purpose\n2. **Constrain appropriately** - Use ge, le, min_length, max_length, Literal\n3. **Validate business rules** - Use field_validator and model_validator\n4. **Use Optional sparingly** - Only when truly optional\n5. **Provide sensible defaults** - When there's a clear default value\n6. **Document with docstrings** - Explain the schema's purpose\n7. **Compose for complexity** - Nest schemas for structured data\n\n## References\n\nSee `references/` for:\n- `advanced-patterns.md` - Complex schema patterns\n- `validation-patterns.md` - Advanced validator examples\n\nSee `examples/` for:\n- `common-schemas.py` - Ready-to-use schema templates\n",
        "claude-plugin/atomic-agents/skills/atomic-structure/SKILL.md": "---\ndescription: This skill should be used when the user asks to \"create project structure\", \"organize atomic agents project\", \"pyproject.toml\", \"project layout\", \"directory structure\", or needs guidance on organizing files, configuring dependencies, and structuring Atomic Agents applications for maintainability.\n---\n\n# Atomic Agents Project Structure\n\nProper project organization is essential for maintainable Atomic Agents applications. Structure scales from simple scripts to complex multi-agent systems.\n\n## Project Structure Patterns\n\n### Simple Application (1-2 agents)\n\n```\nmy_project/\n├── pyproject.toml          # Project metadata and dependencies\n├── .env                    # Environment variables (API keys)\n├── .env.example            # Template for .env\n├── .gitignore              # Git ignore patterns\n├── README.md               # Documentation\n└── my_project/\n    ├── __init__.py\n    ├── main.py             # Entry point\n    ├── config.py           # Configuration\n    └── schemas.py          # Input/output schemas\n```\n\n### Medium Application (3-5 agents with tools)\n\n```\nmy_project/\n├── pyproject.toml\n├── .env\n├── .env.example\n├── .gitignore\n├── README.md\n└── my_project/\n    ├── __init__.py\n    ├── main.py             # Entry point and orchestration\n    ├── config.py           # Configuration\n    ├── schemas.py          # Shared schemas\n    ├── agents/\n    │   ├── __init__.py\n    │   ├── query_agent.py  # Agent 1\n    │   └── response_agent.py # Agent 2\n    └── tools/\n        ├── __init__.py\n        ├── search_tool.py\n        └── calculator_tool.py\n```\n\n### Complex Application (multi-agent with services)\n\n```\nmy_project/\n├── pyproject.toml\n├── .env\n├── .env.example\n├── .gitignore\n├── README.md\n├── tests/\n│   ├── __init__.py\n│   ├── test_agents.py\n│   └── test_tools.py\n└── my_project/\n    ├── __init__.py\n    ├── main.py\n    ├── config.py\n    ├── agents/\n    │   ├── __init__.py\n    │   ├── query_agent.py\n    │   ├── synthesis_agent.py\n    │   └── validation_agent.py\n    ├── tools/\n    │   ├── __init__.py\n    │   └── api_tool.py\n    ├── schemas/\n    │   ├── __init__.py\n    │   ├── inputs.py\n    │   └── outputs.py\n    ├── services/\n    │   ├── __init__.py\n    │   ├── database.py\n    │   └── external_api.py\n    ├── context_providers/\n    │   ├── __init__.py\n    │   └── rag_provider.py\n    └── presentation/\n        ├── __init__.py\n        └── console.py\n```\n\n## pyproject.toml Template\n\n```toml\n[project]\nname = \"my-project\"\nversion = \"0.1.0\"\ndescription = \"An Atomic Agents application for [purpose]\"\nreadme = \"README.md\"\nrequires-python = \">=3.11\"\nlicense = { text = \"MIT\" }\nauthors = [{ name = \"Your Name\", email = \"you@example.com\" }]\n\ndependencies = [\n    \"atomic-agents>=1.0.0\",\n    \"instructor>=1.0.0\",\n    \"openai>=1.0.0\",\n    \"python-dotenv>=1.0.0\",\n    \"pydantic>=2.0.0\",\n    \"rich>=13.0.0\",\n]\n\n[project.optional-dependencies]\ndev = [\n    \"pytest>=7.0.0\",\n    \"pytest-asyncio>=0.21.0\",\n    \"black>=23.0.0\",\n    \"ruff>=0.1.0\",\n]\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"my_project\"]\n```\n\n## Configuration Pattern\n\n**config.py**:\n```python\nimport os\nfrom dataclasses import dataclass\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n\ndef get_api_key() -> str:\n    \"\"\"Get OpenAI API key from environment.\"\"\"\n    key = os.getenv(\"OPENAI_API_KEY\")\n    if not key:\n        raise ValueError(\"OPENAI_API_KEY environment variable not set\")\n    return key\n\n\n@dataclass\nclass Config:\n    \"\"\"Application configuration.\"\"\"\n\n    api_key: str = None\n    model: str = \"gpt-4o-mini\"\n    max_tokens: int = 1000\n    temperature: float = 0.7\n\n    def __post_init__(self):\n        if self.api_key is None:\n            self.api_key = get_api_key()\n\n\n# Global config instance\nconfig = Config()\n```\n\n## Environment Variables\n\n**.env.example** (commit this):\n```bash\n# LLM Provider\nOPENAI_API_KEY=sk-your-key-here\n# ANTHROPIC_API_KEY=your-key-here\n\n# Application Settings\nMODEL=gpt-4o-mini\nMAX_TOKENS=1000\nTEMPERATURE=0.7\n\n# External Services\n# DATABASE_URL=postgresql://...\n# REDIS_URL=redis://...\n```\n\n**.gitignore** additions:\n```gitignore\n# Environment\n.env\n.env.local\n.env.*.local\n\n# Python\n__pycache__/\n*.py[cod]\n.venv/\nvenv/\n\n# IDE\n.idea/\n.vscode/\n*.swp\n\n# Testing\n.pytest_cache/\n.coverage\nhtmlcov/\n```\n\n## Entry Point Pattern\n\n**main.py**:\n```python\n\"\"\"Main entry point for the application.\"\"\"\n\nimport instructor\nimport openai\nfrom rich.console import Console\n\nfrom .config import config\nfrom .agents.query_agent import create_query_agent\nfrom .schemas import UserInput\n\nconsole = Console()\n\n\ndef main():\n    \"\"\"Run the application.\"\"\"\n    # Initialize client\n    client = instructor.from_openai(openai.OpenAI(api_key=config.api_key))\n\n    # Create agent\n    agent = create_query_agent(client, config.model)\n\n    # Main loop\n    console.print(\"[bold green]Ready![/bold green]\")\n    while True:\n        try:\n            user_input = console.input(\"[bold blue]You:[/bold blue] \")\n            if user_input.lower() in (\"exit\", \"quit\"):\n                break\n\n            response = agent.run(UserInput(message=user_input))\n            console.print(f\"[bold green]Agent:[/bold green] {response.message}\")\n\n        except KeyboardInterrupt:\n            break\n\n    console.print(\"\\n[yellow]Goodbye![/yellow]\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n## Agent Module Pattern\n\n**agents/query_agent.py**:\n```python\n\"\"\"Query processing agent.\"\"\"\n\nfrom atomic_agents.agents.base_agent import AtomicAgent, AgentConfig\nfrom atomic_agents.lib.components.system_prompt_generator import SystemPromptGenerator\nfrom atomic_agents.lib.components.chat_history import ChatHistory\n\nfrom ..schemas import QueryInput, QueryOutput\n\n\ndef create_query_agent(client, model: str) -> AtomicAgent[QueryInput, QueryOutput]:\n    \"\"\"Create and configure the query agent.\"\"\"\n    config = AgentConfig(\n        client=client,\n        model=model,\n        history=ChatHistory(),\n        system_prompt_generator=SystemPromptGenerator(\n            background=[\"You are a helpful query processor.\"],\n            steps=[\"1. Understand the query.\", \"2. Generate response.\"],\n            output_instructions=[\"Be concise and helpful.\"],\n        ),\n    )\n    return AtomicAgent[QueryInput, QueryOutput](config=config)\n```\n\n## File Naming Conventions\n\n| Component | File Pattern | Class Pattern |\n|-----------|--------------|---------------|\n| Agents | `*_agent.py` | `*Agent` |\n| Tools | `*_tool.py` | `*Tool` |\n| Schemas | `schemas.py` or `*.py` | `*Schema` |\n| Providers | `*_provider.py` | `*Provider` |\n| Config | `config.py` | `Config`, `*Config` |\n| Services | `*_service.py` | `*Service` |\n\n## Best Practices\n\n1. **One agent per file** - Easier to maintain and test\n2. **Shared schemas in schemas.py** - Or schemas/ directory for many\n3. **Factory functions** - `create_*_agent()` for configurable agents\n4. **Type hints everywhere** - IDE support and documentation\n5. **Docstrings** - Document purpose of each module\n6. **Tests alongside code** - tests/ directory mirroring src\n7. **Rich for output** - Consistent, beautiful terminal output\n\n## References\n\nSee `references/` for:\n- `testing-structure.md` - Test organization patterns\n- `api-structure.md` - FastAPI integration layout\n\nSee `examples/` for:\n- `minimal-project/` - Simplest structure\n- `full-project/` - Complete structure template\n",
        "claude-plugin/atomic-agents/skills/atomic-tools/SKILL.md": "---\ndescription: This skill should be used when the user asks to \"create a tool\", \"implement BaseTool\", \"add tool to agent\", \"tool orchestration\", \"external API tool\", or needs guidance on tool development, tool configuration, error handling, and integrating tools with agents in Atomic Agents applications.\n---\n\n# Atomic Agents Tool Development\n\nTools extend agent capabilities by providing access to external services, APIs, databases, and computations. They follow a consistent pattern with input/output schemas and error handling.\n\n## Tool Architecture\n\n```\n┌─────────────────────────────────────┐\n│           BaseTool                  │\n├─────────────────────────────────────┤\n│ input_schema: BaseIOSchema          │\n│ output_schema: BaseIOSchema         │\n│ config: BaseToolConfig              │\n├─────────────────────────────────────┤\n│ run(params) -> Output | Error       │\n└─────────────────────────────────────┘\n```\n\n## Basic Tool Template\n\n```python\nfrom atomic_agents.lib.base.base_tool import BaseTool, BaseToolConfig\nfrom atomic_agents.lib.base.base_io_schema import BaseIOSchema\nfrom pydantic import Field\nfrom typing import Optional\nimport os\n\n# ============================================================\n# Schemas\n# ============================================================\n\nclass MyToolInputSchema(BaseIOSchema):\n    \"\"\"Input for the tool.\"\"\"\n    query: str = Field(..., description=\"The query to process\")\n\nclass MyToolOutputSchema(BaseIOSchema):\n    \"\"\"Successful output.\"\"\"\n    result: str = Field(..., description=\"The result\")\n\nclass MyToolErrorSchema(BaseIOSchema):\n    \"\"\"Error output.\"\"\"\n    error: str = Field(..., description=\"Error message\")\n    code: Optional[str] = Field(default=None, description=\"Error code\")\n\n# ============================================================\n# Configuration\n# ============================================================\n\nclass MyToolConfig(BaseToolConfig):\n    \"\"\"Tool configuration.\"\"\"\n    api_key: str = Field(\n        default_factory=lambda: os.getenv(\"MY_API_KEY\", \"\"),\n        description=\"API key\"\n    )\n    timeout: int = Field(default=30, description=\"Timeout in seconds\")\n\n# ============================================================\n# Tool\n# ============================================================\n\nclass MyTool(BaseTool):\n    \"\"\"Tool description.\"\"\"\n\n    input_schema = MyToolInputSchema\n    output_schema = MyToolOutputSchema\n\n    def __init__(self, config: MyToolConfig = None):\n        super().__init__(config or MyToolConfig())\n        self.config: MyToolConfig = self.config\n\n    def run(self, params: MyToolInputSchema) -> MyToolOutputSchema | MyToolErrorSchema:\n        try:\n            # Tool logic here\n            result = f\"Processed: {params.query}\"\n            return MyToolOutputSchema(result=result)\n        except Exception as e:\n            return MyToolErrorSchema(error=str(e), code=\"ERROR\")\n\n# Convenience instance\ntool = MyTool()\n```\n\n## Tool Configuration Pattern\n\n```python\nclass APIToolConfig(BaseToolConfig):\n    \"\"\"Configuration with environment variables.\"\"\"\n\n    api_key: str = Field(\n        default_factory=lambda: os.getenv(\"SERVICE_API_KEY\", \"\"),\n        description=\"API key for the service\"\n    )\n    base_url: str = Field(\n        default=\"https://api.service.com/v1\",\n        description=\"Base URL for API\"\n    )\n    timeout: int = Field(\n        default=30,\n        ge=1,\n        le=300,\n        description=\"Request timeout in seconds\"\n    )\n    max_retries: int = Field(\n        default=3,\n        ge=0,\n        le=10,\n        description=\"Maximum retry attempts\"\n    )\n```\n\n## Error Handling Pattern\n\nAlways return error schemas instead of raising exceptions:\n\n```python\ndef run(self, params: InputSchema) -> OutputSchema | ErrorSchema:\n    # Validate configuration\n    if not self.config.api_key:\n        return ErrorSchema(\n            error=\"API key not configured\",\n            code=\"CONFIG_ERROR\"\n        )\n\n    try:\n        # Make external call\n        response = requests.get(\n            f\"{self.config.base_url}/endpoint\",\n            params={\"q\": params.query},\n            headers={\"Authorization\": f\"Bearer {self.config.api_key}\"},\n            timeout=self.config.timeout\n        )\n        response.raise_for_status()\n        data = response.json()\n\n        return OutputSchema(result=data[\"result\"])\n\n    except requests.Timeout:\n        return ErrorSchema(error=\"Request timed out\", code=\"TIMEOUT\")\n    except requests.HTTPError as e:\n        return ErrorSchema(error=f\"HTTP error: {e}\", code=\"HTTP_ERROR\")\n    except Exception as e:\n        return ErrorSchema(error=str(e), code=\"UNKNOWN_ERROR\")\n```\n\n## Using Tools with Agents\n\n### Direct Tool Usage\n```python\nfrom my_tools import search_tool, SearchInputSchema\n\n# Call tool directly\nresult = search_tool.run(SearchInputSchema(query=\"atomic agents\"))\n```\n\n### Tool Orchestration Pattern\n```python\nfrom typing import Union\nfrom atomic_agents.agents.base_agent import AtomicAgent, AgentConfig\n\n# Define tool selection schema\nclass ToolCallSchema(BaseIOSchema):\n    tool_name: Literal[\"search\", \"calculate\", \"none\"] = Field(\n        ..., description=\"Which tool to use\"\n    )\n    tool_input: Union[SearchInput, CalculateInput, None] = Field(\n        ..., description=\"Input for the selected tool\"\n    )\n\n# Agent decides which tool to use\nagent = AtomicAgent[UserQuerySchema, ToolCallSchema](config=config)\n\n# Orchestration loop\nuser_input = UserQuerySchema(query=\"What is 2+2?\")\ntool_decision = agent.run(user_input)\n\nif tool_decision.tool_name == \"calculate\":\n    result = calculator_tool.run(tool_decision.tool_input)\nelif tool_decision.tool_name == \"search\":\n    result = search_tool.run(tool_decision.tool_input)\n```\n\n## Pre-Built Tools (Atomic Forge)\n\nDownload tools from Atomic Forge:\n\n```bash\natomic download calculator\natomic download searxng\natomic download youtube-transcript\n```\n\nAvailable tools:\n- **Calculator** - Mathematical operations\n- **SearXNG** - Web search\n- **Tavily** - AI-powered search\n- **YouTube Transcript** - Video transcripts\n- **Webpage Scraper** - HTML content extraction\n\n## Tool Best Practices\n\n1. **Always use BaseToolConfig** - For consistent configuration\n2. **Environment variables for secrets** - Never hardcode API keys\n3. **Return errors, don't raise** - Caller can handle gracefully\n4. **Set timeouts** - Prevent hanging on external calls\n5. **Validate inputs** - Check parameters before processing\n6. **Include error codes** - Help with debugging and handling\n7. **Document thoroughly** - Input/output schemas need descriptions\n\n## References\n\nSee `references/` for:\n- `api-integration.md` - Patterns for REST API tools\n- `database-tools.md` - Database integration patterns\n\nSee `examples/` for:\n- `simple-tool.py` - Minimal tool implementation\n- `api-tool.py` - External API integration\n"
      },
      "plugins": [
        {
          "name": "atomic-agents",
          "description": "Comprehensive development workflow for building well-organized Atomic Agents applications with specialized agents for schema design, architecture planning, code review, and tool development",
          "version": "1.0.0",
          "author": {
            "name": "BrainBlend AI",
            "email": "support@brainblend.ai"
          },
          "source": "./claude-plugin/atomic-agents",
          "category": "development",
          "homepage": "https://github.com/BrainBlend-AI/atomic-agents",
          "repository": "https://github.com/BrainBlend-AI/atomic-agents",
          "license": "MIT",
          "keywords": [
            "atomic-agents",
            "ai-agents",
            "llm",
            "pydantic",
            "instructor",
            "multi-agent",
            "orchestration"
          ],
          "categories": [
            "ai-agents",
            "atomic-agents",
            "development",
            "instructor",
            "llm",
            "multi-agent",
            "orchestration",
            "pydantic"
          ],
          "install_commands": [
            "/plugin marketplace add BrainBlend-AI/atomic-agents",
            "/plugin install atomic-agents@brainblend-plugins"
          ]
        }
      ]
    }
  ]
}