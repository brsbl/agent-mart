{
  "author": {
    "id": "otolab",
    "display_name": "Naoto Kato",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/6499878?u=b8ce7a412402f6441a92acf209c1edcd00272eb3&v=4",
    "url": "https://github.com/otolab",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 5,
      "total_commands": 2,
      "total_skills": 0,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "otolab",
      "version": null,
      "description": "AI Agent向けのプロンプト・スクリプト・レシピ集",
      "owner_info": {
        "name": "otolab"
      },
      "keywords": [],
      "repo_full_name": "otolab/ai-agent-prompts",
      "repo_url": "https://github.com/otolab/ai-agent-prompts",
      "repo_description": "Claude Code用の個人設定ファイル集",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-11-11T06:21:34Z",
        "created_at": "2025-09-19T08:21:08Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1425
        },
        {
          "path": "agent-prompts",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-prompts/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-prompts/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 423
        },
        {
          "path": "agent-prompts/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-prompts/commands/README.md",
          "type": "blob",
          "size": 1321
        },
        {
          "path": "agent-prompts/commands/advisory.md",
          "type": "blob",
          "size": 10392
        },
        {
          "path": "agent-prompts/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-prompts/hooks/README.md",
          "type": "blob",
          "size": 3514
        },
        {
          "path": "agent-prompts/hooks/hooks.json",
          "type": "blob",
          "size": 269
        },
        {
          "path": "agent-prompts/hooks/post-tool-use.sh",
          "type": "blob",
          "size": 2354
        },
        {
          "path": "agent-prompts/hooks/pre-compact.sh",
          "type": "blob",
          "size": 1050
        },
        {
          "path": "agent-prompts/hooks/start-session.js",
          "type": "blob",
          "size": 4076
        },
        {
          "path": "agent-prompts/mcps",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-prompts/mcps/mode-controller",
          "type": "tree",
          "size": null
        },
        {
          "path": "agent-prompts/mcps/mode-controller/README.md",
          "type": "blob",
          "size": 11874
        },
        {
          "path": "coeiro-operator",
          "type": "tree",
          "size": null
        },
        {
          "path": "coeiro-operator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "coeiro-operator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 376
        },
        {
          "path": "coeiro-operator/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "coeiro-operator/hooks/hooks.json",
          "type": "blob",
          "size": 270
        },
        {
          "path": "recipes",
          "type": "tree",
          "size": null
        },
        {
          "path": "recipes/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "recipes/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 391
        },
        {
          "path": "recipes/README.md",
          "type": "blob",
          "size": 4206
        },
        {
          "path": "recipes/npm-workspaces-typescript",
          "type": "tree",
          "size": null
        },
        {
          "path": "recipes/npm-workspaces-typescript/README.md",
          "type": "blob",
          "size": 189
        },
        {
          "path": "recipes/pnpm-workspaces-typescript",
          "type": "tree",
          "size": null
        },
        {
          "path": "recipes/pnpm-workspaces-typescript/README.md",
          "type": "blob",
          "size": 3400
        },
        {
          "path": "search-docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "search-docs/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "search-docs/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 426
        },
        {
          "path": "search-docs/README.md",
          "type": "blob",
          "size": 4361
        },
        {
          "path": "snippets",
          "type": "tree",
          "size": null
        },
        {
          "path": "snippets/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "snippets/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 378
        },
        {
          "path": "snippets/README.md",
          "type": "blob",
          "size": 989
        },
        {
          "path": "snippets/common-github",
          "type": "tree",
          "size": null
        },
        {
          "path": "snippets/common-github/README.md",
          "type": "blob",
          "size": 12062
        },
        {
          "path": "snippets/rediscloud-gcp-secrets",
          "type": "tree",
          "size": null
        },
        {
          "path": "snippets/rediscloud-gcp-secrets/README.md",
          "type": "blob",
          "size": 4726
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"otolab\",\n  \"owner\": {\n    \"name\": \"otolab\"\n  },\n  \"metadata\": {\n    \"description\": \"AI Agent向けのプロンプト・スクリプト・レシピ集\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"agent-prompts\",\n      \"source\": \"./agent-prompts\",\n      \"description\": \"AI Agent基本原則・動作モード・カスタムコマンド\",\n      \"version\": \"1.0.0\",\n      \"keywords\": [\"foundation\", \"guidelines\", \"modes\", \"commands\"]\n    },\n    {\n      \"name\": \"coeiro-operator\",\n      \"source\": \"./coeiro-operator\",\n      \"description\": \"COEIROINK音声合成MCPサーバー\",\n      \"version\": \"1.3.0\",\n      \"keywords\": [\"mcp\", \"voice\", \"tts\", \"coeiroink\"]\n    },\n    {\n      \"name\": \"recipes\",\n      \"source\": \"./recipes\",\n      \"description\": \"開発パターンとベストプラクティス集\",\n      \"version\": \"1.0.0\",\n      \"keywords\": [\"patterns\", \"best-practices\", \"development\"]\n    },\n    {\n      \"name\": \"snippets\",\n      \"source\": \"./snippets\",\n      \"description\": \"再利用可能なスクリプト・ツール集\",\n      \"version\": \"1.0.0\",\n      \"keywords\": [\"scripts\", \"tools\", \"utilities\"]\n    },\n    {\n      \"name\": \"search-docs\",\n      \"source\": \"./search-docs\",\n      \"description\": \"search-docs MCPサーバー - ドキュメント検索・取得\",\n      \"version\": \"1.0.14\",\n      \"keywords\": [\"mcp\", \"search\", \"vector-search\", \"documentation\", \"markdown\"]\n    }\n  ]\n}",
        "agent-prompts/.claude-plugin/plugin.json": "{\n  \"name\": \"agent-prompts\",\n  \"version\": \"1.0.0\",\n  \"description\": \"AI Agent基本原則・動作モード・カスタムコマンド\",\n  \"author\": {\n    \"name\": \"otolab\"\n  },\n  \"homepage\": \"https://github.com/otolab/ai-agent-prompts\",\n  \"repository\": \"https://github.com/otolab/ai-agent-prompts\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"ai-agent\",\n    \"claude-code\",\n    \"prompts\",\n    \"guidelines\",\n    \"japanese\"\n  ]\n}",
        "agent-prompts/commands/README.md": "# Claude Code カスタムコマンド集\n\nこのディレクトリには、Claude Code用のカスタムコマンド定義を管理しています。\n\n## 利用可能なコマンド\n\n### `/advisory` - アドバイザリーモード\n前提を疑い、作業の問題点を客観的に発見するコマンド。\n- 基本: `/advisory` - 基本的な前提チェック\n- 詳細: `/advisory deep` - Toulminモデルによる論理検証を含む\n\n## セットアップ方法\n\nこのリポジトリはClaude Codeプラグインとして構成されています。\n\n### プラグインとしてインストール\n```bash\n# Claude Codeのプラグインディレクトリにクローンまたはリンク\nln -sfn $(pwd) ~/.claude/plugins/ai-agent-prompts\n\n# または直接クローン\ngit clone https://github.com/otolab/ai-agent-prompts ~/.claude/plugins/ai-agent-prompts\n```\n\n### レガシー方法（プラグイン非対応環境）\n```bash\n# コマンドディレクトリへのシンボリックリンク\nln -sfn $(pwd)/commands ~/.claude/commands\n```\n\n## コマンドの追加方法\n1. `commands/` ディレクトリに新しい `.md` ファイルを作成\n2. コマンドの実行内容を記述\n3. `.claude/commands/` にリンクまたはコピー\n4. このREADMEに説明を追加\n\n---\n**作成**: 2025年10月15日",
        "agent-prompts/commands/advisory.md": "# アドバイザリレポートの作成 - 前提を疑う\n\n## コアコンセプト\n立場を変えることで、2つの視点から支援を提供する：\n1. **作業プロセス**：無意識の前提を発見し、作業の問題点を客観的に見つける\n2. **技術的課題**：複雑な問題を構造的に分析し、解決策を評価する\n\n## 実行方法\n- `/advisory` - 基本的な前提チェック\n- `/advisory deep` - 詳細な論理検証を含む\n\n---\n\n## 実行指示\n\n### 1. 立場と目的の転換\n作業者からレビュアー/監査役へ立場を変更する。\n「作業を進める」から「問題を発見する」へ目的を転換する。\n優先度を速さから正確性・完全性へシフトする。\n\n**既存TODO管理：**\n現在のTODOリストを以下の形式で記録してから、アドバイザリー用の新しいTODOリストを作成する：\n```\n【待避したTODO】\n- [タスク1]: [状態]\n- [タスク2]: [状態]\n```\n（ステップ12で復元時に参照）\n\n### 2. 原則の確認と動作モードの理解\nFOUNDATION_MODEが有効でなければ有効にする。\n作業の検証だけでなく、アドバイザリ自身もこの原則に従う。\nmode_listツールで利用可能なモードを確認し、mode_statusとmode_showで現在アクティブなモードを確認する（アドバイザリーは従わなくてよい）。\n\n### 3. コミュニケーションの事実確認\nユーザーが実際に言ったことを原文のまま確認する。\nアシスタントがどう返答したか、実際の応答を確認する。\nやり取りの時系列を追跡し、指示の変化を記録する。\n質問に対して回答したか、スルーした箇所はないか確認する。\n\n### 4. 認識のズレを発見\nユーザーの本当の意図は何だったか分析する。\nアシスタントはそれをどう理解したか検証する。\nどこで・なぜ認識のズレが生じたか特定する。\n「噛み合っていない」箇所を明確に発見する。\n\n### 5. 状況まとめ（中間チェックポイント）\n状況のまとめを文章化する。\nまとめた文章を確認し、理解できていないこと、追加で調査すべき観点を発見する。\n\n**進捗通知：**\n> 【中間チェックポイント1 - 状況確認】\n> ✅ 完了した調査：ステップ1-4\n> 📝 状況まとめ：[簡潔な要約]\n> 🔍 追加調査項目：[ある場合は件数と概要]\n>\n> → 判定：[次のステップ6へ進みます/ステップ3に戻って再調査します]\n\n判定に基づき、次のステップに進むか、ステップ3に戻って再調査する。\n\n### 6. 独立した視点で資料を探して読み込む\nドキュメントの一覧を作成。\n作業を行う上で重要な資料が存在しないか、十分に参照されているかを調べる。往々にして問題はコンテキストの不足から発生するため、「探す」ことは重要な作業である。\n作業者が明文化されていない情報に基づいて作業していないかを検証する。\n批判的な視点で読み、何が欠けているか、矛盾はないかを探す。\n\n### 7. 現在のコンテキストを外部視点で調査\n作業手順は妥当か、目的に対して適切か確認する。\nTODOリストに書かれていない重要事項を探す。\n作業者が見落としている全体像を把握する。\n本来の目的から逸れていないか検証する。\n\n### 8. 検証まとめ（中間チェックポイント）\n検証のまとめを文章化する。\n作成した文章について批判的に検討し、論理の飛躍、情報の不足の可能性を洗い出す。\n\n**進捗通知：**\n> 【中間チェックポイント2 - 検証結果】\n> ✅ 完了した調査：ステップ6-7\n> 📊 検証結果：[良好/問題あり - 簡潔な要約]\n> ⚠️ 論理の飛躍・情報不足：[ある場合は件数と概要]\n>\n> → 判定：[次のステップへ進みます/ステップ6に戻って再調査します]\n\n判定に基づき、次のステップに進むか、ステップ6に戻って再調査する。\n\n### 9. 論理的検証（deepモード時のみ）\n`/advisory deep` 実行時は、技術的な誤解・理解不足・ミスを体系的に発見するため、Toulminモデルによる論理検証を実施する。詳細は「deepモード詳細」セクションを参照。\n最後に「状況まとめ」「検証まとめ」自体を批判的に検証する。\n\n**進捗通知（deepモード時）：**\n> 【論理検証完了】\n> 🔬 Toulminモデル8項目：[合格数/8]\n> 📝 メタレベル検証：[まとめ自体の問題点]\n>\n> → 判定：[次のステップへ進みます/該当ステップに戻って再実行します]\n\n### 9.5. 技術的課題の分析（deepモード時）\n技術的な課題が存在する場合、構造的に分析して解決策を評価する：\n\n**課題の特定**\n- 何を実現しようとしているか（目標）\n- どこで詰まっているか（障壁）\n- 既知の制約・前提条件は何か\n- エラーメッセージや症状の記録\n\n**5 Whysによる根本原因分析**\n1. なぜこの課題が発生しているか？\n2. それはなぜか？（原因の原因）\n3. さらになぜか？（より深い原因）\n4. さらになぜか？（さらに深く）\n5. 根本原因は何か？\n\n**課題の分類**\n- 仕様の誤解・理解不足\n- 実装のミス・バグ\n- 環境・設定の問題\n- 外部依存・ライブラリの問題\n- アーキテクチャ・設計の課題\n\n**解決策の評価（複数案がある場合）**\n各解決アプローチについて：\n- アプローチの概要\n- メリット（利点・強み）\n- デメリット（欠点・弱み）\n- リスク（潜在的な問題）\n- 実装工数・複雑度\n\n**推奨アプローチの選定**\n- 最も適切な解決策とその理由\n- トレードオフの明示\n- 代替案の提示\n\n### 10. レポート作成\n> 【アドバイザリーからの報告書】\n>\n> ## 作業プロセスの評価\n> 検出された問題：\n> - 原則違反\n> - ユーザー意図との乖離\n> - 動作モードの不適切・未適用（mode_status/mode_showで確認）\n> - 未読ファイル\n> - 疑わしい実装\n>\n> 推奨事項：\n> [具体的な改善提案]\n>\n> ## 技術的課題の分析（deepモード時、課題がある場合）\n> **根本原因**：\n> [5 Whysの結果]\n>\n> **課題の分類**：\n> [仕様誤解/実装ミス/環境問題/設計課題]\n>\n> **推奨する解決策**：\n> [具体的なアプローチとその理由]\n>\n> **トレードオフと代替案**：\n> [考慮すべきリスクと他の選択肢]\n\n### 11. アドバイザリとしての作業終了\nレポートを提出し、作業者モードに戻る。\n\n### 12. 作業者として対応\nレポートを読んで問題を認識する。\n技術的な課題があれば詳細検証の依頼を提案する。\n発見された問題についてユーザーに報告する。\nステップ1で待避した元のTODOリストを必要に応じて復元する。\n作業再開の許可をユーザーから得る。\n\n---\n\n## 調査項目詳細\n\n### 作業手順の妥当性\n- 目的の理解 → 調査 → 実装の順序で進めているか\n- 必要なドキュメントを読んでから作業しているか\n- テスト → 実装 → ドキュメント更新の流れか\n- ユーザーの確認を待ってから進めているか\n\n### 原則との整合性\n- FOUNDATION_MODEの5つの原則に違反していないか\n- 特に「効率とは速さではなく確実性」を理解しているか\n- 「結果と過程」の原則に従っているか\n\n### 知識と理解の検証\n- 仕様の根拠があるか\n- 名前からの推測で進めていないか\n- ハルシネーションしていないか\n- 公式ドキュメントを読んだか\n\n---\n\n## よくあるミスパターン\n\n### 品質の妥協\n- `any`型：正しい型定義を避けている\n- `it.skip`：テストを無効化している\n- `--no-verify`：検証を回避している\n- lint警告の無視：「警告だから」という理由\n\n### プロセスの問題\n- ドキュメント未読での実装\n- エラーメッセージを読まない対処\n- 「後で直す」「たぶん動く」という前提\n- 完了の勝手な宣言\n\n### コミュニケーションの問題\n- ユーザーの質問に答えていない\n- 確認を待たずに進めている\n- 意図を勝手に解釈している\n- エラーや問題を報告していない\n- 適切な動作モードが有効になっていない（mode_statusで確認）\n- モードの実行仕様を適用していない（mode_showで確認）\n\n---\n\n## deepモード詳細\n\n`/advisory deep` 実行時、または詳しい調査を求められた場合は、ステップ9で以下の構造的検証を実施：\n\n### Toulminモデルによる8つの質問\n\n技術的な誤解、理解不足、ミスを体系的に発見するための論理検証：\n\n1. **推論は明確な前提から始まっているか？**\n   前提を明示的に述べているか\n\n2. **前提は証拠や事実で裏付けられているか？**\n   ドキュメント、テスト結果、実行結果など\n\n3. **前提と結論の間に論理的なつながりがあるか？**\n   飛躍していないか\n\n4. **その論理的つながりは妥当か？**\n   他の解釈の可能性は？\n\n5. **推論は論理的誤謬を避けているか？**\n   早まった一般化、誤った二分法など\n\n6. **結論は前提から論理的に導かれているか？**\n   前提から必然的に導かれるか\n\n7. **推論は既存の知識や原則と整合しているか？**\n   ドキュメントや技術的ベストプラクティスと矛盾しないか\n\n8. **推論の結論は妥当で合理的か？**\n   現実的で実装可能か\n\n---\n\n## アドバイザリーの心構え\n\nアドバイザリーは作業者の敵ではなく、より良い成果のための協力者である。\n批判は建設的であるべきで、問題の指摘だけでなく改善策も提示する。良い手順について評価することも重要である。\n最終的な目的はユーザーの満足と、高品質な成果物の実現である。",
        "agent-prompts/hooks/README.md": "# Hooks - Claude Codeフック集\n\nClaude Codeのセッションやツール実行時に自動的に実行されるフックスクリプト集です。\n\n## 利用可能なフック\n\n### start-session.js\n**イベント**: SessionStart\n**目的**: セッション開始時に動作モードの設定を促す\n\nセッション開始時にmode_listの実行と適切なモードの有効化を促します。\nセッションのソースタイプ（startup/resume/clear/compact）に応じて適切な指示を提供します。\nこれにより、コンテキストリセット後も一貫した作業スタイルを維持できます。\n\n### post-tool-use.sh\n**イベント**: PostToolUse (Bashツール限定)\n**目的**: cdコマンド実行後の現在ディレクトリをコンテキストに追加\n\nBashツールで`cd`コマンドが実行された際に、移動後の現在ディレクトリを`[cwd: /path/to/dir]`形式で\nコンテキストに追加します。これにより、ディレクトリ移動の追跡が容易になります。\n\n## フックの仕組み\n\n### 実行フロー\n1. Claude Codeが特定のイベント（SessionStart、PostToolUse等）を検出\n2. `~/.claude/settings.json`のmatcherパターンに一致するか確認\n3. 一致した場合、指定されたコマンドを実行\n4. フックスクリプトがJSON形式で追加コンテキストを出力\n5. Claude Codeがコンテキストを会話に追加\n\n### JSON出力形式\n```json\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"EventName\",\n    \"additionalContext\": \"追加するテキスト\"\n  }\n}\n```\n\n## 新規フックの作成方法\n\n### 1. スクリプトの作成\n```bash\ncat > hooks/my-hook.sh << 'EOF'\n#!/bin/bash\necho '{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"MyEvent\",\n    \"additionalContext\": \"カスタムメッセージ\"\n  }\n}'\nEOF\n```\n\n### 2. 実行権限の付与\n```bash\nchmod +x hooks/my-hook.sh\n```\n\n### 3. settings.jsonへの登録\n```json\n\"EventName\": [\n  {\n    \"matcher\": \"パターン\",\n    \"hooks\": [\n      {\n        \"type\": \"command\",\n        \"command\": \"~/Develop/otolab/ai-agent-prompts/hooks/my-hook.sh\"\n      }\n    ]\n  }\n]\n```\n\n## 環境変数\n\nフックスクリプト内で利用可能な環境変数（イベントによって異なる）：\n\n### PostToolUse\n- `CLAUDE_CODE_TOOL_NAME` - 実行されたツール名（例: \"Bash\", \"Read\", \"Write\"）\n- `CLAUDE_CODE_TOOL_PARAMS` - ツールパラメータ（JSON文字列）\n- `CLAUDE_CODE_TOOL_RESULT` - ツール実行結果（利用可能な場合）\n\n## デバッグ方法\n\n### ログファイルへの出力\n```bash\n#!/bin/bash\n# デバッグ情報をログファイルに記録\necho \"$(date): Hook executed\" >> /tmp/hook-debug.log\necho \"Tool: $CLAUDE_CODE_TOOL_NAME\" >> /tmp/hook-debug.log\n```\n\n### 環境変数の確認\n```bash\n#!/bin/bash\n# すべての環境変数を記録\nenv > /tmp/hook-env.txt\n```\n\n## ベストプラクティス\n\n1. **軽量に保つ**: フックの実行時間を最小限に\n2. **エラーハンドリング**: 失敗してもセッションを妨げない\n3. **条件分岐**: 必要な場合のみ出力を生成\n4. **ログ記録**: デバッグ用のログは別ファイルに\n\n## 注意事項\n\n- フックスクリプトの出力はJSON形式である必要があります\n- 不正なJSON出力はエラーになる可能性があります\n- matcherパターンは正確に設定してください\n- 設定変更後はClaude Codeの再起動が必要です\n\n---\n**作成**: 2025年10月6日",
        "agent-prompts/hooks/hooks.json": "{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"startup|compact|resume|clear\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/start-session.js\"\n          }\n        ]\n      }\n    ]\n  }\n}",
        "agent-prompts/hooks/post-tool-use.sh": "#!/bin/bash\n\n# PostToolUse hook for Bash tool\n# 1. Adds current working directory to context when cd command is executed\n# 2. Warns about git add -A/. without git status in the same command\n#\n# NOTE: このhookは一時的に無効化されています (2025-10-22)\n# 理由: Bashツール実行時にエラーが発生してツールが異常終了する問題が確認された\n# 問題が解決次第、hooks/hooks.jsonで再度有効化する予定\n\n# Function to output JSON response\noutput_json() {\n    local additional_context=\"$1\"\n    if [ -n \"$additional_context\" ]; then\n        cat <<EOF\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"PostToolUse\",\n    \"additionalContext\": \"$additional_context\"\n  }\n}\nEOF\n    fi\n}\n\n# Check if this is a Bash tool call\nif [ \"$CLAUDE_CODE_TOOL_NAME\" == \"Bash\" ]; then\n    # Extract the command from JSON params\n    COMMAND=$(echo \"$CLAUDE_CODE_TOOL_PARAMS\" | grep -o '\"command\"[[:space:]]*:[[:space:]]*\"[^\"]*\"' | sed 's/.*\"command\"[[:space:]]*:[[:space:]]*\"\\([^\"]*\\)\".*/\\1/')\n\n    # Collect all messages to output\n    MESSAGES=\"\"\n\n    # Check if cd command was executed\n    if echo \"$COMMAND\" | grep -q \"cd[[:space:]]\"; then\n        # Get current working directory\n        CWD=$(pwd)\n        # Add to messages\n        if [ -z \"$MESSAGES\" ]; then\n            MESSAGES=\"[cwd: $CWD]\"\n        else\n            MESSAGES=\"${MESSAGES}\n[cwd: $CWD]\"\n        fi\n    fi\n\n    # Check if git add -A or git add . was executed\n    if echo \"$COMMAND\" | grep -q \"git[[:space:]]\\+add[[:space:]]\\+\\(-A\\|\\.\\)\" ; then\n        # Check if git status is also in the same command (e.g., git add -A && git status)\n        if ! echo \"$COMMAND\" | grep -q \"git[[:space:]]\\+status\"; then\n            # Count modified files\n            if git rev-parse --git-dir > /dev/null 2>&1; then\n                MODIFIED_COUNT=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')\n                WARNING=\"[git] ⚠️ ${MODIFIED_COUNT}個のファイルが対象 (git add -A/.) - git statusで内容を確認してください\"\n                if [ -z \"$MESSAGES\" ]; then\n                    MESSAGES=\"$WARNING\"\n                else\n                    MESSAGES=\"${MESSAGES}\n${WARNING}\"\n                fi\n            fi\n        fi\n    fi\n\n    # Output combined messages\n    if [ -n \"$MESSAGES\" ]; then\n        output_json \"$MESSAGES\"\n    fi\nfi",
        "agent-prompts/hooks/pre-compact.sh": "#!/bin/bash\n\n# コンテキスト圧縮前のモード状態復元\n\nMESSAGE=\"⚠️ コンテキスト圧縮前の処理\\n\\n\"\nMESSAGE=\"${MESSAGE}以下の手順を実行してください：\\n\"\nMESSAGE=\"${MESSAGE}1. コンテキストから最新のアクティブなモードリストを検索\\n\"\nMESSAGE=\"${MESSAGE}2. mode_setツールで状態を保存（MCPオンメモリに保存）\\n\\n\"\nMESSAGE=\"${MESSAGE}※ この処理により、compact後もMCPサーバーのモード状態が保持されます\\n\\n\"\n\nMESSAGE=\"${MESSAGE}⚠️ コンテキスト圧縮完了後の処理\\n\\n\"\nMESSAGE=\"${MESSAGE}以下の手順をTODOの最初に追加してください：\\n\"\nMESSAGE=\"${MESSAGE}1. **mode_show()** を実行してモード文書を再読み込み\\n\\n\"\nMESSAGE=\"${MESSAGE}※ 保存されたモードの状態を復元します。\"\n\n# Use jq to properly encode JSON with multi-line strings\njq -n \\\n  --arg message \"$MESSAGE\" \\\n  '{\n    hookSpecificOutput: {\n      hookEventName: \"PreCompact\",\n      additionalContext: $message\n    }\n  }'\n",
        "agent-prompts/hooks/start-session.js": "#!/usr/bin/env node\n\nconst fs = require('fs');\nconst path = require('path');\n\n// 標準入力からJSONを読み取る\nlet inputData = '';\n\nprocess.stdin.on('data', (chunk) => {\n  inputData += chunk;\n});\n\nprocess.stdin.on('end', () => {\n  try {\n    const hookData = JSON.parse(inputData);\n    const source = hookData.source || 'unknown';\n\n    // sourceに応じたメッセージを構築\n    const lines = [\n      '═══════════════════════════════════════════'\n    ];\n\n    switch (source) {\n      case 'startup':\n        lines.push([\n          '📋 **Session Setup - 新規セッション開始**',\n          '',\n          '作業環境をセットアップします。',\n          'TodoWriteツールで以下のタスクをリストの最初に追加してください：',\n          '',\n          '1. mode_list()を実行して利用可能なモードを確認する',\n          '2. 適切なモードを有効化する',\n          '',\n          'これらは作業開始前の準備ステップです。',\n        ].join('\\n'));\n        break;\n\n      case 'resume':\n        lines.push([\n          '📋 **Session Setup - セッション再開**',\n          '',\n          '中断していたセッションを再開します。',\n          'TodoWriteツールで以下のタスクをリストの最初に追加してください：',\n          '',\n          '1. コンテキストから最新のアクティブモードリストを検索する',\n          '2. mode_set()を実行してモードをMCPメモリに復元する',\n          '',\n          'これらは作業再開前の準備ステップです。',\n        ].join('\\n'));\n        break;\n\n      case 'clear':\n        lines.push([\n          '📋 **Session Setup - モードクリア後**',\n          '',\n          'アシスタント動作モードがクリアされました。',\n          'TodoWriteツールで以下のタスクをリストの最初に追加してください：',\n          '',\n          '1. mode_show()を実行してモードドキュメントを再読み込みする',\n          '',\n          'これは作業継続前の準備ステップです。',\n        ].join('\\n'));\n        break;\n\n      case 'compact':\n        lines.push([\n          '📋 **Session Setup - コンテキスト圧縮後の再開**',\n          '',\n          'コンテキストが圧縮されました。モード状態を復元します。',\n          'TodoWriteツールで以下のタスクをリストの最初に追加してください：',\n          '',\n          '1. mode_show()を実行してモード状態を復元する',\n          '',\n          'これは作業継続前の準備ステップです。',\n          '',\n          '💡 ヒント: mode_show()は「サマリが存在する場合でも原文を読み直す」指示を含んでいます。',\n        ].join('\\n'));\n        break;\n\n      default:\n        lines.push([\n          '📋 **Session Setup**',\n          '',\n          `セッションが開始されました (source: ${source})。`,\n          'TodoWriteツールで以下のタスクをリストの最初に追加してください：',\n          '',\n          '1. mode_list()を実行する',\n        ].join('\\n'));\n        break;\n    }\n\n    // .serenaディレクトリのチェック\n    const serenaPath = path.join(process.cwd(), '.serena');\n    if (fs.existsSync(serenaPath) && fs.statSync(serenaPath).isDirectory()) {\n      lines.push('* Serenaのアクティベートを行ってください');\n    }\n\n    lines.push('═══════════════════════════════════════════');\n\n    // JSON出力\n    const output = {\n      hookSpecificOutput: {\n        hookEventName: 'SessionStart',\n        additionalContext: lines.join('\\n')\n      }\n    };\n\n    console.log(JSON.stringify(output, null, 2));\n  } catch (error) {\n    console.error('Error processing hook input:', error.message);\n    process.exit(1);\n  }\n});\n",
        "agent-prompts/mcps/mode-controller/README.md": "# Mode Controller MCP Server\n\nAIアシスタントの動作モードを管理・制御するMCPサーバーです。\n\n## 概要\n\nMode Controllerは、AIアシスタントの動作モードをMarkdownファイルで定義し、MCPツールを通じて動的に切り替えることができるサーバーです。YAMLフロントマターによるメタデータ定義をサポートし、柔軟なモード管理を実現します。\n\n## 機能\n\n- **複数モード同時管理**: 複数のモードを同時にアクティブ化可能\n- **モードの動的切り替え**: mode_enter/mode_exitツールでモードを切り替え\n- **YAMLフロントマターサポート**: モードのメタデータ（表示名、自動トリガー条件、終了メッセージ、fullContent等）を定義\n- **fullContent機能**: mode_enter/mode_showでファイル内容を直接出力（`fullContent: true`）\n- **@参照の自動解決**: fullContent有効時、モード定義内の`@`参照を再帰的に読み込んで結合\n- **モード一覧表示**: 利用可能なモードと詳細情報の表示\n- **状態管理**: 複数のアクティブモードの状態を管理・表示\n\n## インストール\n\n### npmパッケージから（推奨）\n\n```bash\n# npxで自動インストール＆実行（MCP設定で使用）\nnpx -y @otolab/mcp-mode-controller --modes-path /path/to/modes\n```\n\n### ソースからビルド\n\n```bash\n# 依存関係のインストール\nnpm install\n\n# ビルド\nnpm run build\n```\n\n## 使用方法\n\n### MCP設定\n\nClaude Codeプラグインの `.mcp.json` に以下の設定を追加：\n\n#### npxを使用（推奨）\n\n```json\n{\n  \"mcpServers\": {\n    \"mode-controller\": {\n      \"type\": \"stdio\",\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@otolab/mcp-mode-controller\",\n        \"--modes-path\",\n        \"${CLAUDE_PLUGIN_ROOT}/prompts/modes,${CLAUDE_PLUGIN_ROOT}/../products\"\n      ]\n    }\n  }\n}\n```\n\n**注意**: `--modes-path`は**必須**パラメータです。カンマ区切りで複数のディレクトリを指定できます。\n\n#### ローカルビルドを使用\n\n```json\n{\n  \"mcpServers\": {\n    \"mode-controller\": {\n      \"type\": \"stdio\",\n      \"command\": \"node\",\n      \"args\": [\n        \"${CLAUDE_PLUGIN_ROOT}/mcps/mode-controller/dist/server.js\",\n        \"--modes-path\",\n        \"${CLAUDE_PLUGIN_ROOT}/prompts/modes\"\n      ]\n    }\n  }\n}\n```\n\n### モードファイルの作成\n\nモードファイルは`--modes-path`で指定したディレクトリに配置します。サブディレクトリも再帰的に探索されます。\n\n#### YAMLフロントマター付きモード\n\n```markdown\n---\nmode: specification_research\ndisplayName: 仕様調査モード\nautoTrigger:\n  - 仕様理解が必要な時\n  - 作業前調査\n  - API仕様確認\nexitMessage: |\n  調査結果に基づいて次の作業を進めてください。\n  必要に応じて追加調査を検討してください。\n---\n\n# 仕様調査モード\n\n## 目的\nプロジェクトの仕様や実装を深く理解するための調査モード\n\n## 実行内容\n- ドキュメントの体系的な読み込み\n- コードベースの構造理解\n- API仕様の確認\n```\n\n#### fullContent機能を使用したモード\n\n```markdown\n---\nmode: env_setup\ndisplayName: 環境セットアップモード\nfullContent: true  # mode_enterでファイル内容を直接出力\nexitMessage: 環境セットアップが完了しました。\n---\n\n# 環境セットアップモード\n\nセッション開始時・コンテキスト圧縮後の環境再構築を行うモードです。\n\n## 関連ファイル\n\n**作業原則**: @principles.md\n**作業ガイドライン**: @work_guidelines.md\n**スニペット集**: @../../snippets/README.md\n\n（@参照は以下の形式をサポート）\n- 行頭: @file.md\n- リスト項目: - @file.md\n- 行の途中: **: @file.md\n```\n\n#### シンプルなモード（メタデータなし）\n\n```markdown\n# 基本モード\n\nこのモードは基本的な作業を行うためのモードです。\nメタデータがない場合、ファイル名がモード名として使用されます。\n```\n\n## MCPツール\n\n### mode_enter\n\nモードを開始します（複数同時指定可能）。\n\n**動作**:\n- `fullContent: false`（デフォルト）: モード定義ファイルの読み込み指示を返す\n- `fullContent: true`: ファイル内容を直接出力（@参照も自動解決）\n\n```typescript\n// 引数\n{\n  modes: string | string[]  // モード名（文字列または配列）\n}\n\n// 使用例\nmode_enter({ modes: \"specification_research\" })                      // 単一モード\nmode_enter({ modes: [\"specification_research\", \"tech_notes\"] })      // 複数モード同時開始\nmode_enter({ modes: \"env_setup\" })                                   // fullContent: true のモード\n\n// 出力例（fullContent: false）\n【仕様調査モード開始】\n\n以下のモード定義に従って動作してください：\n\nファイル: /path/to/prompts/modes/SPECIFICATION_RESEARCH_MODE.md\n\n※このファイルを読み込んで内容を確認してください\n\n// 出力例（fullContent: true）\n【環境セットアップモード開始】\n\n============================================================\nファイル: /path/to/prompts/modes/ENV_SETUP_MODE.md\n============================================================\n\n# 環境セットアップモード\n\nセッション開始時・コンテキスト圧縮後の環境再構築を行うモードです。\n\n（モードの内容がここに直接展開される）\n\n============================================================\nファイル: /path/to/prompts/principles.md\n============================================================\n\n（@参照で指定されたファイルの内容も自動的に結合される）\n```\n\n**fullContent: false の利点**:\n- トークン効率: 会話履歴に全文ではなくパス情報のみが残る\n- 確実性: Readツールによる明示的なファイル読み込み\n- 柔軟性: ファイル更新が即座に反映される\n\n**fullContent: true の利点**:\n- 確実性重視: mode_enter実行だけで全内容が読み込まれる\n- @参照の自動解決: 関連ファイルを自動的に結合（フルパス表示で明確）\n- セットアップ用途: 環境構築時など確実に読み込みたい場合に最適\n- ファイルパス表示: すべてのファイルのフルパスが明示される\n\n### mode_exit\n\nアクティブなモードを終了します（複数同時指定可能）。\n\n```typescript\n// 引数\n{\n  modes?: string | string[]  // 終了するモード名（省略時は全モード終了）\n}\n\n// 使用例\nmode_exit({})                                          // 全アクティブモードを終了\nmode_exit({ modes: \"specification_research\" })              // 特定のモードを終了\nmode_exit({ modes: [\"specification_research\", \"tech_notes\"] })  // 複数モードを同時終了\n```\n\n### mode_show\n\nモードの内容を表示します。モードの指示内容を確認したい時や、コンテキスト圧縮後にモード内容を再確認する時に使用します。\n\n**動作**: モード定義の全文とファイルパスを返します。\n\n**重要**: モード名が指定された場合、アクティブ状態に関係なくそのモードの内容を表示します。\n\n```typescript\n// 引数\n{\n  mode?: string  // 表示するモード名（省略時は全アクティブモード）\n}\n\n// 使用例\nmode_show({})                         // 全アクティブモードの内容を表示\nmode_show({ mode: \"specification_research\" })  // 特定のモードの内容を表示（非アクティブでも可）\n\n// 出力例（アクティブなモード）\n【仕様調査モード（現在アクティブ）】\n\nファイル: /path/to/prompts/modes/SPECIFICATION_RESEARCH_MODE.md\n\n# 仕様調査モード\n...（モード内容）\n\n// 出力例（非アクティブなモード）\n【技術メモモード（非アクティブ）】\n\nファイル: /path/to/prompts/modes/TECH_NOTES.md\n\n# 技術メモモード\n...（モード内容）\n\n// 出力例（複数モード）\n【仕様調査モード（現在アクティブ）】\n\nファイル: /path/to/prompts/modes/SPECIFICATION_RESEARCH_MODE.md\n\n# 仕様調査モード\n...（モード内容）\n\n────────────────────────────────────────\n\n【コード修正モード（現在アクティブ）】\n\nファイル: /path/to/prompts/modes/CODE_REVIEW_MODE.md\n\n# コード修正モード\n...（モード内容）\n```\n\n**用途**:\n- モード内容の再確認\n- コンテキスト圧縮後の復元\n- デバッグ・トラブルシューティング\n\n### mode_status\n\n現在のモード状態を確認します。\n\n```typescript\n// 引数なし\nmode_status({})\n\n// 出力例（単一モード）\n📊 モード状態\n\nアクティブなモード (1個):\n  🟢 仕様調査モード (specification_research)\n\n// 出力例（複数モード）\n📊 モード状態\n\nアクティブなモード (2個):\n  🟢 仕様調査モード (specification_research)\n  🟢 コード修正モード (tech_notes)\n\n// 出力例（モード未設定）\n📊 モード状態\n\n現在のモード: なし\n状態: ⭕ 待機中\n```\n\n### mode_list\n\n利用可能なモード一覧を表示します。\n\n```typescript\n// 引数なし\nmode_list({})\n```\n\n## 複数モード同時実行\n\nMode Controllerは複数のモードを同時にアクティブ化できます。これにより、異なる側面の指示を組み合わせて作業を進めることが可能です。\n\n### 使用例\n\n```javascript\n// 複数モードを同時に開始\nmode_enter({ modes: [\"specification_research\", \"tech_notes\"] })\n\n// 現在のステータスを確認\nmode_status()\n// → アクティブなモード (2個)\n\n// 特定のモードの内容だけを確認\nmode_show({ mode: \"specification_research\" })\n\n// 特定のモードだけを終了\nmode_exit({ modes: \"specification_research\" })\n\n// 残りのモードも終了\nmode_exit()\n```\n\n### 利点\n\n- **柔軟な作業スタイル**: 調査モードとコード修正モードを同時に有効化\n- **段階的な管理**: 必要に応じてモードを追加・削除\n- **明確な状態把握**: どのモードがアクティブか常に確認可能\n\n## 開発\n\n### テスト\n\n```bash\n# テストの実行\nnpm test\n\n# ウォッチモードでテスト\nnpm run test:watch\n\n# カバレッジレポート生成\nnpm run test:coverage\n```\n\n### ビルド\n\n```bash\n# TypeScriptのビルド\nnpm run build\n\n# ウォッチモードでビルド\nnpm run dev\n```\n\n## ディレクトリ構造\n\n```\nmode-controller/\n├── src/\n│   └── server.ts         # MCPサーバー実装\n├── test/\n│   └── mode-controller.test.ts  # E2Eテスト\n├── test-modes/           # テスト用モードファイル\n│   ├── test_mode_with_metadata.md\n│   └── test_mode_without_metadata.md\n├── dist/                 # ビルド出力\n├── package.json\n├── tsconfig.json\n└── vitest.config.ts\n```\n\n## 技術仕様\n\n- **MCP SDK**: `@modelcontextprotocol/sdk ^1.17.0`\n- **YAMLパーサー**: `js-yaml ^4.1.0`\n- **スキーマ検証**: `zod ^3.22.0`\n- **テスト**: `vitest ^3.2.4` + `@coeiro-operator/mcp-debug`\n\n## メタデータスキーマ\n\nYAMLフロントマターで定義可能なフィールド：\n\n| フィールド | 型 | 説明 |\n|----------|---|------|\n| mode | string | モードID（省略時はファイル名を使用） |\n| displayName | string | 表示名 |\n| autoTrigger | string[] | 自動起動条件のリスト |\n| exitMessage | string | モード終了時のメッセージ |\n\n## ライセンス\n\nプロジェクトのライセンスに準拠",
        "coeiro-operator/.claude-plugin/plugin.json": "{\n  \"name\": \"coeiro-operator\",\n  \"version\": \"1.3.0\",\n  \"description\": \"COEIROINK音声合成MCPサーバー\",\n  \"author\": {\n    \"name\": \"otolab\"\n  },\n  \"homepage\": \"https://github.com/otolab/coeiro-operator\",\n  \"repository\": \"https://github.com/otolab/coeiro-operator\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"mcp\",\n    \"voice\",\n    \"tts\",\n    \"coeiroink\",\n    \"audio\"\n  ]\n}\n",
        "coeiro-operator/hooks/hooks.json": "{\n  \"hooks\": {\n    \"Notification\": [\n      {\n        \"matcher\": \"\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx --package @coeiro-operator/cli -y say-coeiroink '入力待ちです'\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "recipes/.claude-plugin/plugin.json": "{\n  \"name\": \"recipes\",\n  \"version\": \"1.0.0\",\n  \"description\": \"開発パターンとベストプラクティス集\",\n  \"author\": {\n    \"name\": \"otolab\"\n  },\n  \"homepage\": \"https://github.com/otolab/ai-agent-prompts\",\n  \"repository\": \"https://github.com/otolab/ai-agent-prompts\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"recipes\",\n    \"patterns\",\n    \"best-practices\",\n    \"development\"\n  ]\n}",
        "recipes/README.md": "# Recipes - 作業方法・方針雛形集\n\nClaudeとの作業において頻繁に利用する作業方法や方針の雛形を目的別に整理・保存するディレクトリです。\n\n## 概要\n\n**目的**: プロジェクト作成・管理時の一貫した作業方法を確立し、効率的で品質の高い開発を実現する\n\n**対象範囲**:\n- プロジェクト作成時の初期設定手順\n- 開発フロー・方針テンプレート\n- ドキュメント作成・管理方針\n- 品質管理・テスト戦略\n- デプロイ・運用方針\n\n## ディレクトリ構造\n\n```\nrecipes/\n├── README.md                    # 本ファイル - 全体概要とインデックス\n├── document-code-test/          # ドキュメント・コード・テストの三位一体同期管理\n├── npm-workspaces-typescript/   # npm workspaces x TypeScript設定ガイド\n├── serena-integration/          # Serenaコード解析ツールの導入・設定\n└── testing/                     # テスト戦略・分類・実装指針\n```\n\n## 利用方法\n\n### 新しいレシピの作成\n1. 目的に応じて適切なカテゴリディレクトリを選択\n2. `{purpose}-{description}.md` 形式でファイル作成\n3. テンプレート形式で具体的な手順・方針を記述\n\n### 既存レシピの活用\n1. 目的に合致するレシピを検索・選択\n2. プロジェクトの特性に合わせてカスタマイズ\n3. 実践後の改善点をレシピにフィードバック\n\n## レシピ作成ガイドライン\n\n### 記述原則\n- **具体性**: 抽象的でなく実行可能な手順\n- **再現性**: 誰でも同じ結果を得られる明確性\n- **保守性**: 変化に対応できる柔軟な構造\n- **効率性**: 無駄のない最適化された手順\n\n### テンプレート構成\n```markdown\n# [レシピ名]\n\n## 目的\n[何を達成するためのレシピか]\n\n## 前提条件\n[必要な環境・知識・ツール]\n\n## 手順\n[具体的なステップバイステップ手順]\n\n## 期待する成果\n[完了時に得られる結果]\n\n## 注意点・制約\n[注意すべき点や制約事項]\n\n## 関連レシピ\n[関連する他のレシピへのリンク]\n```\n\n## 現在のレシピ\n\n### document-code-test/\nドキュメント・コード・テストの三位一体同期管理\n- **[DOCUMENT_CODE_TEST_SYNC.md](document-code-test/DOCUMENT_CODE_TEST_SYNC.md)** - ドキュメント・コード・テストの三位一体同期管理方針\n  - 三要素の同期戦略と「正」の判定基準\n  - 不一致パターンの検出と解決手順\n  - トレーサビリティ確保のためのコメント・テストタイトル方針\n\n### npm-workspaces-typescript/\nnpm workspacesとTypeScript Project References連携ガイド\n- **[setup-guide.md](npm-workspaces-typescript/setup-guide.md)** - モノレポ環境の正しい設定方法\n  - 二つの依存関係グラフ（ランタイム/コンパイルタイム）の理解\n  - ルート/パッケージレベルの具体的な設定例\n  - npm操作の実行場所と-wフラグの重要性\n  - トラブルシューティングと自動化ツール\n\n### testing/\nテスト戦略・分類・実装指針\n- **[TEST_CLASSIFICATION.md](testing/TEST_CLASSIFICATION.md)** - テストの分類と基本方針\n  - ユニット/インターフェース/統合/システム/E2Eテストの定義\n  - 各テストレベルの責任範囲と実装指針\n  - モック使用方針とセットアップパターン\n\n### serena-integration/\nSerenaコード解析・編集ツールの導入と設定\n- **[SERENA_PROJECT_SETUP.md](serena-integration/SERENA_PROJECT_SETUP.md)** - プロジェクトへのSerena導入手順\n  - Claude Codeとの統合設定（自動アクティベート対応）\n  - ブラウザ自動起動の無効化設定\n  - 大規模プロジェクトのインデックス作成\n  - プロジェクト固有の設定とトラブルシューティング\n\n---\n\n**作成日**: 2025年8月12日\n**最終更新**: 2025年10月22日  \n**管理者**: Claude Code User\n\n**関連ファイル**:\n- `~/.claude/CLAUDE.md` - 個人作業指針\n- `~/.claude/TECH_NOTES.md` - 技術開発ノート",
        "recipes/npm-workspaces-typescript/README.md": "# npm workspaces x TypeScript設定ガイド\n\nnpm workspacesとTypeScript Project Referencesの設定方法について解説しています。\n\n## 詳細ドキュメント\n\n@setup-guide.md",
        "recipes/pnpm-workspaces-typescript/README.md": "# pnpm workspaces × TypeScript × Changeset設定ガイド\n\nモノレポ環境での最適な技術スタック構成について解説しています。\n\n## 技術スタックの組み合わせ\n\n### pnpm × TypeScript × Changeset\nこの3つの組み合わせにより、以下を実現します：\n\n- **pnpm workspaces**: 高速で効率的なパッケージ管理\n- **TypeScript Project References**: インクリメンタルビルドとキャッシュ最適化\n- **Changeset**: セマンティックバージョニングと自動リリース\n\n### なぜこの組み合わせか\n\n#### 1. 開発効率の向上\n- pnpmの高速インストール（npm比2-3倍）\n- TypeScriptのインクリメンタルビルド\n- Changesetによる自動バージョン管理\n\n#### 2. 信頼性の確保\n- pnpmの厳密な依存関係管理\n- TypeScriptの型安全性\n- Changesetによるリリース履歴の追跡\n\n#### 3. npm公開の安全性\n- pnpmの`workspace:*`記法で内部依存を明確化\n- `pnpm publish -r`で依存順序を考慮した公開\n- Changesetでバージョン衝突を防止\n\n### クイックスタート\n\n```bash\n# pnpmのインストール\nnpm install -g pnpm\n\n# プロジェクトの初期化\npnpm init\necho \"packages:\\n  - 'packages/*'\" > pnpm-workspace.yaml\n\n# TypeScriptとChangesetのセットアップ\npnpm add -D typescript @changesets/cli -w\npnpm changeset init\n\n# 基本スクリプトの設定\nnpm pkg set scripts.build=\"tsc --build\"\nnpm pkg set scripts.changeset=\"changeset\"\nnpm pkg set scripts.version=\"changeset version\"\nnpm pkg set scripts.publish=\"pnpm publish -r --no-git-checks\"\n```\n\n### 典型的なプロジェクト構造\n\n```\nmy-monorepo/\n├── pnpm-workspace.yaml     # pnpm workspace設定\n├── tsconfig.json           # TypeScript Project References\n├── .changeset/\n│   └── config.json        # Changeset設定\n├── packages/\n│   ├── common/\n│   │   ├── package.json   # \"name\": \"@my-org/common\"\n│   │   └── tsconfig.json\n│   └── app/\n│       ├── package.json   # \"dependencies\": {\"@my-org/common\": \"workspace:*\"}\n│       └── tsconfig.json  # \"references\": [{\"path\": \"../common\"}]\n└── package.json           # \"private\": true\n```\n\n## 詳細ドキュメント\n\n- @setup-guide.md - 基本設定と構築手順\n- @migration-guide.md - npmからpnpmへの移行ガイド\n- @publishing-guide.md - パッケージ公開とリリースフロー\n\n## よくある質問\n\n### Q: npmやyarnからの移行は難しい？\nA: `migration-guide.md`に段階的な移行手順があります。workspace記法の変換が主な作業です。\n\n### Q: Changesetは必須？\nA: 必須ではありませんが、複数パッケージのバージョン管理が格段に楽になります。\n\n### Q: TypeScript Project Referencesの設定は複雑？\nA: package.jsonの依存関係とtsconfig.jsonのreferencesを同期させるだけです。\n\n## 実装例\n\nこのレシピを実際に適用したプロジェクト：\n- [coeiro-operator](https://github.com/otolab/coeiro-operator) - 音声合成オペレータシステム\n\n## トラブルシューティングのヒント\n\n- **npm公開が失敗**: `workspace:*`が残っていないか確認\n- **ビルドが遅い**: tsconfig.jsonのreferencesが正しいか確認\n- **changesetがない警告**: PR作成前に`pnpm changeset`を実行",
        "search-docs/.claude-plugin/plugin.json": "{\n  \"name\": \"search-docs\",\n  \"version\": \"1.0.14\",\n  \"description\": \"search-docs MCPサーバー - ドキュメント検索・取得\",\n  \"author\": {\n    \"name\": \"otolab\"\n  },\n  \"homepage\": \"https://www.npmjs.com/package/@search-docs/mcp-server\",\n  \"repository\": \"https://github.com/otolab/search-docs\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"mcp\",\n    \"search\",\n    \"vector-search\",\n    \"documentation\",\n    \"markdown\"\n  ]\n}\n",
        "search-docs/README.md": "# search-docs プラグイン\n\nClaude Codeから直接search-docsを利用するためのMCPサーバープラグインです。\n\n## 概要\n\nこのプラグインは、`@search-docs/mcp-server`を提供し、Claude Codeとsearch-docsサーバを接続して、会話から直接ドキュメント検索を実行できるようにします。\n\n## 提供機能\n\n### MCPツール\n\n#### 1. `mcp__plugin_search-docs_search-docs__search`\n文書をベクトル検索します。\n\n**パラメータ**:\n- `query` (string, 必須): 検索クエリ\n- `depth` (number | number[], オプション): 検索深度（0-3）\n- `limit` (number, オプション): 結果数制限（デフォルト: 10）\n- `includeCleanOnly` (boolean, オプション): Clean状態のみ検索\n\n**使用例**:\n```\nquery: \"Vector検索の実装方法\"\ndepth: 1\nlimit: 5\n```\n\n#### 2. `mcp__plugin_search-docs_search-docs__get_document`\n文書の内容を取得します。\n\n**パラメータ**:\n- `path` (string, 必須): 文書パス\n\n**使用例**:\n```\npath: \"docs/architecture.md\"\n```\n\n#### 3. `mcp__plugin_search-docs_search-docs__index_status`\nインデックスの状態を確認します。\n\n**パラメータ**: なし\n\n## セットアップ\n\n### 前提条件\n\n- Node.js 18.0.0以上\n- search-docsサーバがインストールされていること（MCPサーバーが自動起動します）\n\n### インストール\n\nこのプラグインは、otolab AIエージェントプラグインマーケットプレイスの一部として提供されています。\n\nプロジェクトのルートディレクトリで以下を実行：\n\n```bash\n# プラグインマーケットプレイスを有効化\n# （既にotolabマーケットプレイスを追加済みの場合は不要）\n```\n\n### 自動起動機能\n\nv1.0.1以降、MCP Serverは自動的にsearch-docsサーバを起動します。\n\n**動作**:\n1. MCP Server起動時にサーバへの接続を試みる\n2. サーバが起動していない場合、自動的にサーバを起動\n3. サーバが起動したら接続を確立\n\nこれにより、手動でサーバを起動する必要がなくなりました。\n\n## 使用方法\n\n### 基本的な検索\n\nClaude Codeで以下のように指示します：\n\n```\n\"Vector検索について調べてください\"\n```\n\nアシスタントが自動的に`search`ツールを使用して検索を実行します。\n\n### ドキュメント取得\n\n```\n\"docs/architecture.mdの内容を表示してください\"\n```\n\nアシスタントが`get_document`ツールを使用してドキュメントを取得します。\n\n### インデックス状態確認\n\n```\n\"search-docsのインデックス状態を確認してください\"\n```\n\nアシスタントが`index_status`ツールを使用して状態を確認します。\n\n## 設定\n\n### プロジェクト設定\n\n各プロジェクトのルートディレクトリに`.search-docs.json`を配置することで、search-docsサーバの設定をカスタマイズできます。\n\n`.search-docs.json`が存在しない場合は、デフォルト設定（`localhost:24280`）を使用します。\n\n### MCP設定\n\nこのプラグインの`.mcp.json`：\n\n```json\n{\n  \"mcpServers\": {\n    \"search-docs\": {\n      \"type\": \"stdio\",\n      \"command\": \"npx\",\n      \"args\": [\n        \"-y\",\n        \"@search-docs/mcp-server\"\n      ]\n    }\n  }\n}\n```\n\n## トラブルシューティング\n\n### サーバに接続できない\n\n**エラー**: `Failed to connect to search-docs server`\n\n**通常は不要**: MCP Serverはサーバを自動起動します。\n\n**手動で確認する場合**:\n\n```bash\n# search-docs CLIをインストール\nnpx -y @search-docs/cli server status\n\n# 必要に応じて手動起動\nnpx -y @search-docs/cli server start\n```\n\n### 設定ファイルが見つからない\n\nMCP Serverはプロジェクトディレクトリの`.search-docs.json`を読み込みます。\n\nファイルが存在しない場合はデフォルト設定を使用します（問題ありません）。\n\n## 関連リンク\n\n- npmパッケージ: [@search-docs/mcp-server](https://www.npmjs.com/package/@search-docs/mcp-server)\n- 関連パッケージ:\n  - `@search-docs/client`: JSON-RPCクライアント\n  - `@search-docs/server`: 検索サーバ\n  - `@search-docs/cli`: CLIツール\n\n## バージョン\n\n現在のバージョン: 1.0.14\n\n## ライセンス\n\nMIT\n",
        "snippets/.claude-plugin/plugin.json": "{\n  \"name\": \"snippets\",\n  \"version\": \"1.0.0\",\n  \"description\": \"再利用可能なスクリプト・ツール集\",\n  \"author\": {\n    \"name\": \"otolab\"\n  },\n  \"homepage\": \"https://github.com/otolab/ai-agent-prompts\",\n  \"repository\": \"https://github.com/otolab/ai-agent-prompts\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"snippets\",\n    \"scripts\",\n    \"tools\",\n    \"utilities\"\n  ]\n}",
        "snippets/README.md": "# Snippets - 再利用可能なスクリプト集\n\nプロジェクト横断で利用可能な汎用スクリプト。詳細は各ディレクトリのREADME.mdを参照。\n\n## [common-github/](common-github/) - GitHub操作\n\n- **set-issue-relationships.sh** - Issue親子関係の設定（単一/複数子Issue対応）\n- **search-code.sh** - コード検索（自動ページネーション、行番号特定、100件以上対応）\n- **check-ci-errors.sh** - PR CI状態の確認とエラーログ取得\n\n## [rediscloud-gcp-secrets/](rediscloud-gcp-secrets/) - RedisCloud証明書管理\n\n- **fetch_redis_certificates.sh** - GCP Secret Managerから証明書一括取得\n- **analyze_certificate_groups.sh** - 証明書重複検出とSHA256分析\n- **validate_terraform_certificates.sh** - Terraform証明書検証\n- **check_certificate_updates.sh** - 証明書更新履歴確認\n\n---\n詳細・使用例: 各ディレクトリのREADME.md | 新規追加: [CONTRIBUTING.md](CONTRIBUTING.md)",
        "snippets/common-github/README.md": "# GitHub操作スクリプト集\n\nGitHubのIssue管理とコード検索を効率化するためのスクリプト集です。\n\n## スクリプト一覧\n\n### set-issue-relationships.sh\n\nGitHub Issues間の親子関係を設定するスクリプトです。単一または複数の子Issueに対応しています。\n\n#### 使用方法\n```bash\n./set-issue-relationships.sh <repo> <parent-issue-number> <child-issue-number1> [child-issue-number2 ...]\n```\n\n#### 例\n```bash\n# 単一の子Issue\n./set-issue-relationships.sh owner/repo 130482 134277\n\n# 複数の子Issue\n./set-issue-relationships.sh owner/repo 130482 134277 134278 134279\n```\n\n#### 必要な権限\n- リポジトリへの読み取りアクセス\n- GraphQL APIの使用権限\n\n#### 注意事項\n- このスクリプトはGitHub GraphQLの`sub_issues`機能を使用します（プレビュー機能）\n- `GraphQL-Features: sub_issues`ヘッダーが必要です\n- 親子関係は一方向のみ（子から親への参照）\n\n#### 出力例\n```\nRepository: owner/repo\nParent Issue: #130482\nChild Issues: #134277 #134278\n\nFetching parent issue node ID...\nParent node ID: I_kwDOCWB66M6QGj9C\n\n----------------------------------------\nProcessing child issue #134277...\nChild node ID: I_kwDOCWB66M6QpH7V\nSetting relationship...\n✅ Successfully set #134277 as sub-issue of #130482\n\n----------------------------------------\nProcessing child issue #134278...\nChild node ID: I_kwDOCWB66M6QpH7W\nSetting relationship...\n✅ Successfully set #134278 as sub-issue of #130482\n\n========================================\nSummary:\n  Successful: 2\n  Failed: 0\n========================================\n```\n\n### check-ci-errors.sh\n\nGitHub PRのCIチェック結果を確認・分析するスクリプトです。\n\n#### 使用方法\n```bash\n# 現在のブランチのPRのCI状態を確認\n./check-ci-errors.sh\n\n# 特定のPRのCI状態を確認\n./check-ci-errors.sh <pr-number>\n\n# 特定のジョブの詳細ログを表示\n./check-ci-errors.sh [pr-number] --details \"Job Name\"\n```\n\n#### 例\n```bash\n# PR #104のCI状態を確認\n./check-ci-errors.sh 104\n\n# PR #104のTestジョブの詳細を表示\n./check-ci-errors.sh 104 --details \"Test\"\n\n# 現在のブランチのE2E Testsジョブの詳細を表示\n./check-ci-errors.sh --details \"E2E Tests\"\n```\n\n#### 出力例\n\n**概要モード（デフォルト）**\n```\nPR #104 のCIステータスを確認中...\n\n=== CI チェック概要 ===\n\n❌ FAILED: Test\n❌ FAILED: E2E Tests\n\n=== サマリー ===\n✅ 成功: 5\n❌ 失敗: 2\n\n💡 ヒント:\n失敗したジョブの詳細ログを確認するには、以下のコマンドを実行してください:\n  ./check-ci-errors.sh 104 --details \"Test\"\n  ./check-ci-errors.sh 104 --details \"E2E Tests\"\n\n※ --details オプションで失敗したステップの詳細ログをファイルに保存します\n   保存されたファイルのパスとサイズが表示され、任意のエディタで確認できます\n```\n\n**詳細モード（--details）**\n```\nPR #104 のCIステータスを確認中...\n\nジョブ 'Test' の詳細ログを取得中...\n※ ログはファイルに保存され、そのパスとサイズが表示されます\n\nRun ID: 1234567890\n\n失敗したステップのログをファイルに保存中...\n\n✅ ログを正常に取得しました\n📊 統計情報:\n  - 行数: 2345 行\n  - サイズ: 156K\n  - 保存先: /tmp/gh-ci-error-abc123.log\n\n💡 ログを確認するコマンド:\n  cat \"/tmp/gh-ci-error-abc123.log\"               # 全体を表示\n  head -100 \"/tmp/gh-ci-error-abc123.log\"         # 最初の100行\n  grep -A5 -B5 ERROR \"/tmp/gh-ci-error-abc123.log\" # エラー箇所の前後5行\n  less \"/tmp/gh-ci-error-abc123.log\"               # ページャーで閲覧\n\n🗑️  使用後の削除:\n  rm \"/tmp/gh-ci-error-abc123.log\"\n```\n\n#### 機能\n- **概要モード（デフォルト）**: 全CIチェックの成功/失敗数を表示\n- **詳細モード（--details）**: 特定ジョブの失敗ログをファイルに保存\n  - 大きなログファイルも扱えるよう、一時ファイルに保存\n  - ファイルパス、サイズ、行数を表示\n  - ログ確認用のコマンド例を提示\n- **自動PR検出**: PR番号省略時は現在のブランチから自動検出\n- **色付き出力**: 成功は緑、失敗は赤、情報は青で表示\n\n#### 必要な環境\n- GitHub CLI (`gh`) がインストール済み\n- リポジトリへの読み取りアクセス権限\n- PR作成済みのブランチ（PR番号省略時）\n\n### search-code.sh\n\nGitHub REST APIを使用してコード検索を行い、自動ページネーション対応で100件以上の結果も取得可能なスクリプトです。\n\n#### 使用方法\n```bash\n./search-code.sh [OPTIONS] <search_query>\n```\n\n#### オプション\n- `-r, --repo OWNER/REPO`: 検索対象リポジトリ（省略時は現在のリポジトリ）\n- `-o, --org ORGANIZATION`: 検索対象Organization（--repoと同時使用不可）\n- `-l, --limit NUMBER`: 最大結果数（デフォルト: 10、上限なし、自動ページネーション）\n- `-f, --format FORMAT`: 出力形式（table, json, tsv。デフォルト: table）\n- `-s, --show-fragments`: コードfragmentを表示\n- `-L, --locate-lines`: fragmentから行番号を特定\n- `-h, --help`: ヘルプを表示\n\n#### 例\n```bash\n# 現在のリポジトリで検索（上位10件）\n./search-code.sh \"function authenticate\"\n\n# 特定リポジトリでfragment付きで検索\n./search-code.sh -r \"owner/repo\" -s \"TODO\"\n\n# Organization全体で検索\n./search-code.sh -o \"myorg\" \"security vulnerability\"\n\n# 100件以上の結果を取得（自動ページネーション）\n./search-code.sh -r \"owner/repo\" -l 250 \"error handling\"\n\n# 行番号を特定して検索\n./search-code.sh -r \"owner/repo\" -L \"async function\"\n\n# JSON形式で結果を取得\n./search-code.sh -f json \"class.*Controller\"\n```\n\n#### 行番号特定機能\n`--locate-lines`オプションを使用すると、検索結果のfragmentから実際のファイル内の行番号を特定します。\n\n**特定方法**:\n1. 完全一致: fragmentとファイル内容の正規化後の完全一致\n2. 複数行マッチング: fragmentが複数行の場合、最初の行から順次マッチング\n3. ファジーマッチング: 類似度スコアによる近似マッチ（80%以上の類似度）\n4. キーワードマッチング: 重要な識別子（class名、function名など）による特定\n\n**出力例**:\n```\n============================================================\nRepository: owner/repo\nFile: src/auth/authenticator.js\nURL: https://github.com/owner/repo/blob/main/src/auth/authenticator.js\n\n📝 Fragment 1: function authenticate(username, password) {\\\\n  if (!username || !pass...\n   Highlights: authenticate, username, password\n\n📍 Located at:\n   Line 42 ✓✓✓: function authenticate(username, password) {\n   → https://github.com/owner/repo/blob/main/src/auth/authenticator.js#L42\n```\n\n#### 必要な環境\n- GitHub CLI (`gh`) がインストール済みで認証済み\n- 検索対象リポジトリへの読み取りアクセス権限\n- Python 3（`--locate-lines`オプション使用時）\n\n#### 技術詳細\n- GitHub REST API（`/search/code`エンドポイント）を使用\n- **自動ページネーション**: 100件を超える結果は複数ページを自動取得\n- API制限: 最大1000件まで取得可能（GitHub APIの仕様）\n- 検索結果にはfragmentのみが含まれ、直接の行番号は取得できません\n- `--locate-lines`オプション使用時は、各ファイルの完全な内容を`/repos/{owner}/{repo}/contents/{path}`から取得\n- fragmentとファイル内容を照合して行番号を特定\n- 検索クエリはGitHubのコード検索構文に従います\n\n### locate_lines_from_fragment.py\n\n`search-code.sh`の補助スクリプトで、REST API検索結果のfragmentから実際の行番号を特定します。\n\n#### 単体での使用方法\n```bash\ngh api \"/search/code?q=query\" | python3 locate_lines_from_fragment.py\n```\n\n注意: REST APIはファイル内容を含まないため、行番号の正確な特定にはファイル内容の別途取得が必要です。\n\n#### 機能\n- 正規化による空白の差異を吸収\n- 複数行fragmentの連続性チェック\n- ファジーマッチングによる近似一致検出\n- 信頼度スコアの表示（✓✓✓: 90%以上、✓✓: 70-90%、✓: 70%未満）\n\n## トラブルシューティング\n\n### エラー: \"Your token has not been granted the required scopes\"\nGitHub CLIの認証トークンに必要なスコープが付与されていません。以下のコマンドで再認証してください：\n```bash\ngh auth refresh -h github.com -s read:project,write:project\n```\n\n### エラー: \"Field 'addSubIssue' doesn't exist on type 'Mutation'\"\nこの機能はまだプレビュー段階のため、一部の環境では利用できない可能性があります。\n\n### エラー: \"Could not fetch issue\"\n指定されたIssue番号が存在しないか、アクセス権限がありません。\n\n## GitHub APIの活用Tips\n\n### Issue/PRコメントの直接取得\n\nGitHubのコメントURLから直接コメント内容を取得する方法：\n\n```bash\n# コメントURLの例: https://github.com/owner/repo/issues/123#issuecomment-3336557377\n# issuecomment-の後の数字（3336557377）がコメントID\n\n# gh APIでコメントを取得\ngh api /repos/owner/repo/issues/comments/3336557377\n\n# 特定のフィールドのみ取得\ngh api /repos/owner/repo/issues/comments/3336557377 --jq '.body'\n\n# コメントの作成者と内容を取得\ngh api /repos/owner/repo/issues/comments/3336557377 --jq '{author: .user.login, body: .body}'\n```\n\n**注意事項**:\n- URLの`#issuecomment-`の後の数字がコメントIDです\n- PRのコメントも同じ方法で取得可能（issues/commentsエンドポイントを使用）\n- リポジトリへの読み取りアクセス権限が必要\n\n### PRレビューコメントの取得と返信\n\nPRのレビューコメント（コードレビュー）を取得し、返信する方法：\n\n#### 未解決レビューコメントの取得\n\n```bash\n# 未解決のレビューコメントのみ取得（推奨）\ngh api graphql -f query='{\n  repository(owner: \"OWNER\", name: \"REPO\") {\n    pullRequest(number: PR_NUMBER) {\n      reviewThreads(last: 30) {\n        nodes {\n          id\n          path\n          line\n          isResolved\n          comments(last: 1) {\n            nodes {\n              body\n              author { login }\n            }\n          }\n        }\n      }\n    }\n  }\n}' | jq '.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false) | {id, path, comment: .comments.nodes[0].body}'\n```\n\n#### レビューコメントへの返信\n\n```bash\n# レビューコメントスレッドに返信\ngh api graphql -f query='\nmutation {\n  addPullRequestReviewThreadReply(input: {\n    pullRequestReviewThreadId: \"THREAD_ID\",\n    body: \"*🤖 by Claude Code*\\n\\n修正済み: [具体的な修正内容]\"\n  }) {\n    comment { id }\n  }\n}'\n```\n\n#### 返信フォーマット例\n\n状況に応じた返信例：\n\n```bash\n# 修正完了時\n\"*🤖 by Claude Code*\\n\\n修正済み: [具体的な修正内容]\"\n\n# 確認中の場合\n\"*🤖 by Claude Code*\\n\\n確認中: [質問内容]\"\n\n# 別PRで対応する場合\n\"*🤖 by Claude Code*\\n\\n別PRで対応: Issue #XX\"\n```\n\n**注意事項**:\n- すべてのGitHubコメント（Issue、PR、レビュー）で冒頭に `*🤖 by Claude Code*` を記載して身元を明示\n- `THREAD_ID`はGraphQL APIで取得したレビュースレッドのID\n- レビューコメントはIssueコメントとは異なるAPIエンドポイントを使用\n\n## 参考情報\n\n- [GitHub GraphQL API Documentation](https://docs.github.com/en/graphql)\n- [GitHub CLI Documentation](https://cli.github.com/manual/)\n- サブIssue機能は現在プレビュー段階です。将来的に仕様が変更される可能性があります。",
        "snippets/rediscloud-gcp-secrets/README.md": "# RedisCloud / GCP Secrets 管理スクリプト集\n\n## 概要\nRedisCloudで使用するTLS証明書をGCP Secret Managerから取得・管理するためのスクリプト集です。\n\n## スクリプト一覧\n\n### 1. `fetch_redis_certificates.sh`\nGCP Secret Managerから Redis関連の証明書を一括取得するスクリプト。\n\n**使用方法:**\n```bash\n# 環境変数を使用\nsource .env\n./fetch_redis_certificates.sh\n\n# 引数で指定\n./fetch_redis_certificates.sh [project-id] [certs-dir]\n\n# 詳細表示モード\n./fetch_redis_certificates.sh -v\n```\n\n### 2. `analyze_certificate_groups.sh`\n取得した証明書をSHA256ハッシュで分析し、重複を検出するスクリプト。\n\n**使用方法:**\n```bash\n# 環境変数を使用\nsource .env\n./analyze_certificate_groups.sh\n\n# 引数で指定\n./analyze_certificate_groups.sh [certs-dir]\n```\n\n### 3. `validate_terraform_certificates.sh`\nTerraformファイル（certificates.tf）から証明書を抽出して検証するスクリプト。\n\n**使用方法:**\n```bash\n# 環境変数を使用\nsource .env\n./validate_terraform_certificates.sh\n\n# 引数で指定\n./validate_terraform_certificates.sh [certificates.tf-path]\n```\n\n### 4. `check_certificate_updates.sh`\nGCP Secretsの更新履歴を確認し、最新の証明書を特定するスクリプト。\n\n**使用方法:**\n```bash\n# 環境変数を使用\nsource .env\n./check_certificate_updates.sh\n\n# 引数で指定\n./check_certificate_updates.sh [project-id]\n\n# 特定期間の更新をチェック\nCHECK_PERIOD=\"2023-10\" ./check_certificate_updates.sh\n```\n\n## 必要な環境\n- Google Cloud SDK (`gcloud`)\n- OpenSSL\n- bash 4.0以上\n\n## セットアップ\n\n### 環境変数の設定方法\n\n1. **環境変数を直接設定する方法**\n   ```bash\n   export GCP_PROJECT_EVALUATION=\"your-evaluation-project-id\"\n   export CERTS_DIR=\"./redis_certificates\"\n   ./fetch_redis_certificates.sh\n   ```\n\n2. **コマンドライン引数で指定する方法**\n   ```bash\n   # 引数で直接指定（環境変数より優先）\n   ./fetch_redis_certificates.sh your-project-id ./output-dir\n   ```\n\n3. **.envファイルを使用する方法（オプション）**\n   ```bash\n   # .envファイルを作成して環境変数を定義\n   echo 'GCP_PROJECT_EVALUATION=\"your-project-id\"' > .env\n   source .env\n   ./fetch_redis_certificates.sh\n   ```\n\n## 環境変数リスト\n\n### 共通環境変数\n\n| 環境変数 | 必須 | 説明 | デフォルト値 |\n|---------|------|------|------------|\n| GCP_PROJECT_EVALUATION | △ | Evaluationプロジェクト ID | なし（引数で指定可） |\n| GCP_PROJECT_DEVELOP | × | Developプロジェクト ID | なし |\n\n### スクリプト別環境変数\n\n#### fetch_redis_certificates.sh\n\n| 環境変数 | 必須 | 説明 | デフォルト値 |\n|---------|------|------|------------|\n| GCP_PROJECT_EVALUATION | △ | GCPプロジェクトID | なし（第1引数で指定可） |\n| CERTS_DIR | × | 証明書保存先ディレクトリ | ./redis_certificates |\n| CERTIFICATE_LIST | × | 取得する証明書名（カンマ区切り） | スクリプト内定義※1 |\n\n#### analyze_certificate_groups.sh\n\n| 環境変数 | 必須 | 説明 | デフォルト値 |\n|---------|------|------|------------|\n| CERTS_DIR | × | 分析対象ディレクトリ | ./redis_certificates |\n\n#### validate_terraform_certificates.sh\n\n| 環境変数 | 必須 | 説明 | デフォルト値 |\n|---------|------|------|------------|\n| TF_CERTIFICATES_PATH | × | certificates.tfのパス | ./certificates.tf |\n| EXTRACT_DIR | × | 証明書抽出先ディレクトリ | ./extracted_terraform_certs |\n| TF_CERT_VARS | × | Terraform変数名（カンマ区切り） | スクリプト内定義※2 |\n\n#### check_certificate_updates.sh\n\n| 環境変数 | 必須 | 説明 | デフォルト値 |\n|---------|------|------|------------|\n| GCP_PROJECT_EVALUATION | ○ | GCPプロジェクトID | なし（第1引数で指定可） |\n| SERVICE_PATTERNS | × | サービス名パターン（カンマ区切り） | スクリプト内定義※3 |\n| CHECK_PERIOD | × | 特定期間の更新確認（例: \"2023-10\"） | なし |\n\n## 証明書の構成\n調査により判明した証明書グループ構成：\n\n| グループ | 証明書名 | サービス数 | 有効期限 |\n|---------|---------|-----------|----------|\n| A | common_certificate | 8 | 2028-09-20 |\n| B | admin_certificate | 2 | 2029-01-15 |\n| C-I | 個別証明書 | 各1 | 各種 |\n\n## 注意事項\n- GCP認証が必要（`gcloud auth login`）\n- 適切なプロジェクトへのアクセス権限が必要\n- 証明書は機密情報のため、取り扱いに注意\n\n## 関連Issue\n- Issue #130482: Redis証明書の統合管理"
      },
      "plugins": [
        {
          "name": "agent-prompts",
          "source": "./agent-prompts",
          "description": "AI Agent基本原則・動作モード・カスタムコマンド",
          "version": "1.0.0",
          "keywords": [
            "foundation",
            "guidelines",
            "modes",
            "commands"
          ],
          "categories": [
            "commands",
            "foundation",
            "guidelines",
            "modes"
          ],
          "install_commands": [
            "/plugin marketplace add otolab/ai-agent-prompts",
            "/plugin install agent-prompts@otolab"
          ]
        },
        {
          "name": "coeiro-operator",
          "source": "./coeiro-operator",
          "description": "COEIROINK音声合成MCPサーバー",
          "version": "1.3.0",
          "keywords": [
            "mcp",
            "voice",
            "tts",
            "coeiroink"
          ],
          "categories": [
            "coeiroink",
            "mcp",
            "tts",
            "voice"
          ],
          "install_commands": [
            "/plugin marketplace add otolab/ai-agent-prompts",
            "/plugin install coeiro-operator@otolab"
          ]
        },
        {
          "name": "recipes",
          "source": "./recipes",
          "description": "開発パターンとベストプラクティス集",
          "version": "1.0.0",
          "keywords": [
            "patterns",
            "best-practices",
            "development"
          ],
          "categories": [
            "best-practices",
            "development",
            "patterns"
          ],
          "install_commands": [
            "/plugin marketplace add otolab/ai-agent-prompts",
            "/plugin install recipes@otolab"
          ]
        },
        {
          "name": "snippets",
          "source": "./snippets",
          "description": "再利用可能なスクリプト・ツール集",
          "version": "1.0.0",
          "keywords": [
            "scripts",
            "tools",
            "utilities"
          ],
          "categories": [
            "scripts",
            "tools",
            "utilities"
          ],
          "install_commands": [
            "/plugin marketplace add otolab/ai-agent-prompts",
            "/plugin install snippets@otolab"
          ]
        },
        {
          "name": "search-docs",
          "source": "./search-docs",
          "description": "search-docs MCPサーバー - ドキュメント検索・取得",
          "version": "1.0.14",
          "keywords": [
            "mcp",
            "search",
            "vector-search",
            "documentation",
            "markdown"
          ],
          "categories": [
            "documentation",
            "markdown",
            "mcp",
            "search",
            "vector-search"
          ],
          "install_commands": [
            "/plugin marketplace add otolab/ai-agent-prompts",
            "/plugin install search-docs@otolab"
          ]
        }
      ]
    }
  ]
}