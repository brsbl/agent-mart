{
  "author": {
    "id": "birdcar",
    "display_name": "Nick Cannariato",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/434063?u=46259e16237cc8670212e8f3ff62e087f96c554d&v=4",
    "url": "https://github.com/birdcar",
    "bio": "Product, Support, Documentation, and whatever else is needed @yettoapp",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 5,
      "total_commands": 10,
      "total_skills": 0,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "birdcar-plugins",
      "version": "0.1.0",
      "description": "Personal Claude Code plugin marketplace",
      "owner_info": {
        "name": "birdcar"
      },
      "keywords": [],
      "repo_full_name": "birdcar/claude-plugins",
      "repo_url": "https://github.com/birdcar/claude-plugins",
      "repo_description": "Personal Claude Code plugin marketplace",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-23T15:50:42Z",
        "created_at": "2026-01-14T22:47:36Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1139
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/creator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/creator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/creator/commands/create-skill.md",
          "type": "blob",
          "size": 6030
        },
        {
          "path": "plugins/dev-commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev-commands/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/dev-commands/commands/build.md",
          "type": "blob",
          "size": 645
        },
        {
          "path": "plugins/dev-commands/commands/check.md",
          "type": "blob",
          "size": 658
        },
        {
          "path": "plugins/dev-commands/commands/deps.md",
          "type": "blob",
          "size": 821
        },
        {
          "path": "plugins/dev-commands/commands/lint.md",
          "type": "blob",
          "size": 662
        },
        {
          "path": "plugins/dev-commands/commands/test.md",
          "type": "blob",
          "size": 719
        },
        {
          "path": "plugins/github-actions-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/github-actions-generator/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/INSTRUCTIONS.md",
          "type": "blob",
          "size": 11492
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/action-yml-template.md",
          "type": "blob",
          "size": 2726
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/ci-workflow-template.md",
          "type": "blob",
          "size": 3863
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/entrypoint-template.md",
          "type": "blob",
          "size": 3317
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/error-handling-patterns.md",
          "type": "blob",
          "size": 7418
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/implementation-patterns.md",
          "type": "blob",
          "size": 4133
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/octokit-patterns.md",
          "type": "blob",
          "size": 6668
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/package-template.md",
          "type": "blob",
          "size": 1793
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/readme-template.md",
          "type": "blob",
          "size": 3851
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/release-workflow-template.md",
          "type": "blob",
          "size": 4365
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/testing-patterns.md",
          "type": "blob",
          "size": 8651
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/tsconfig-template.md",
          "type": "blob",
          "size": 1786
        },
        {
          "path": "plugins/github-actions-generator/skills/generate-action/references/versioning-guide.md",
          "type": "blob",
          "size": 4248
        },
        {
          "path": "plugins/octoflow",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/octoflow/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/octoflow/commands/commit.md",
          "type": "blob",
          "size": 5362
        },
        {
          "path": "plugins/octoflow/commands/pr.md",
          "type": "blob",
          "size": 1464
        },
        {
          "path": "plugins/plugin-tools",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-tools/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-tools/commands/analyze-plugins.md",
          "type": "blob",
          "size": 2998
        },
        {
          "path": "plugins/plugin-tools/commands/improve-skill.md",
          "type": "blob",
          "size": 4021
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"birdcar-plugins\",\n  \"owner\": {\n    \"name\": \"birdcar\"\n  },\n  \"version\": \"0.1.0\",\n  \"description\": \"Personal Claude Code plugin marketplace\",\n  \"plugins\": [\n    {\n      \"name\": \"creator\",\n      \"source\": \"./plugins/creator\",\n      \"description\": \"Commands for generating new Claude Code components from natural language\",\n      \"version\": \"0.1.0\"\n    },\n    {\n      \"name\": \"dev-commands\",\n      \"source\": \"./plugins/dev-commands\",\n      \"description\": \"Slash commands for common development workflows\",\n      \"version\": \"0.1.0\"\n    },\n    {\n      \"name\": \"github-actions-generator\",\n      \"source\": \"./plugins/github-actions-generator\",\n      \"description\": \"Generate TypeScript GitHub Actions with Bun workspaces\",\n      \"version\": \"0.1.0\"\n    },\n    {\n      \"name\": \"octoflow\",\n      \"source\": \"./plugins/octoflow\",\n      \"description\": \"Core Git workflow commands for commits and pull requests\",\n      \"version\": \"0.1.0\"\n    },\n    {\n      \"name\": \"plugin-tools\",\n      \"source\": \"./plugins/plugin-tools\",\n      \"description\": \"Commands for analyzing and enhancing Claude Code plugins\",\n      \"version\": \"0.1.0\"\n    }\n  ]\n}\n",
        "plugins/creator/commands/create-skill.md": "---\nname: create-skill\ndescription: Generate new Claude Code skills from natural language descriptions\nallowed-tools: [Bash, Read, Write, Edit, Glob, Grep]\n---\n\nGenerate new Claude Code skills from natural language descriptions with comprehensive validation and structure.\n\n## Process\n\n1. **Parse the Description**\n   Analyze the user's skill description to extract:\n   - **Primary action**: What the skill fundamentally does\n   - **Inputs**: What information or arguments it needs\n   - **Outputs**: What it produces or changes\n   - **Scope**: Is this a single skill or should it be multiple skills?\n   - **Complexity**: Simple (single step) vs complex (multi-step workflow)\n\n2. **Determine Component Type**\n   Decide whether this should be a command or skill:\n   - **Command**: User invokes explicitly via `/command-name`, discrete action\n   - **Skill**: Agent triggers proactively based on context, background behavior\n\n3. **Generate Names**\n   Create kebab-case names:\n   - **Plugin name**: Descriptive of the domain (e.g., `json-formatter`, `test-runner`)\n   - **Component name**: Action-oriented verb phrase (e.g., `format-json`, `run-tests`)\n\n   If a suitable existing plugin exists, ask the user if they want to add the component there instead.\n\n4. **Check for Conflicts**\n   Before creating anything:\n   - Check if `plugins/{plugin-name}/` already exists\n   - Check if any plugin has a component with the same name\n   - If conflicts exist, present options:\n     - Use a different name\n     - Add to existing plugin\n     - Overwrite (requires explicit confirmation)\n\n5. **Create Plugin Structure**\n   Generate the complete directory structure:\n\n   For commands:\n\n   ```\n   plugins/{plugin-name}/\n   ├── package.json\n   ├── tsconfig.json\n   ├── plugin.json\n   ├── src/\n   │   └── index.ts\n   └── commands/\n       └── {command-name}.md\n   ```\n\n   For skills:\n\n   ```\n   plugins/{plugin-name}/\n   ├── package.json\n   ├── tsconfig.json\n   ├── plugin.json\n   ├── src/\n   │   └── index.ts\n   └── skills/{skill-name}/\n       └── INSTRUCTIONS.md\n   ```\n\n6. **Generate Files**\n\n   **package.json**:\n\n   ```json\n   {\n     \"name\": \"@birdcar/claude-plugin-{plugin-name}\",\n     \"version\": \"0.1.0\",\n     \"private\": true,\n     \"type\": \"module\",\n     \"main\": \"./dist/index.js\",\n     \"types\": \"./dist/index.d.ts\"\n   }\n   ```\n\n   **tsconfig.json**:\n\n   ```json\n   {\n     \"extends\": \"../../tsconfig.base.json\",\n     \"compilerOptions\": {\n       \"rootDir\": \"src\",\n       \"outDir\": \"dist\"\n     },\n     \"include\": [\"src\"]\n   }\n   ```\n\n   **plugin.json** (for commands):\n\n   ```json\n   {\n     \"name\": \"{plugin-name}\",\n     \"version\": \"0.1.0\",\n     \"description\": \"{Generated description}\",\n     \"commands\": [\"./commands/\"]\n   }\n   ```\n\n   **plugin.json** (for skills):\n\n   ```json\n   {\n     \"name\": \"{plugin-name}\",\n     \"version\": \"0.1.0\",\n     \"description\": \"{Generated description}\",\n     \"skills\": [\"./skills/\"]\n   }\n   ```\n\n   **src/index.ts**:\n\n   ```typescript\n   // {Plugin name} plugin\n   export const name = '{plugin-name}';\n   ```\n\n7. **Update Project Configuration**\n   - Add reference to root `tsconfig.json`\n   - Run `bun run sync` to update marketplace.json\n\n8. **Validate Creation**\n   After creating files, run:\n\n   ```bash\n   bun run typecheck\n   bun run build\n   ```\n\n   If either fails, fix the issue before reporting success.\n\n9. **Report Results**\n   Provide:\n   - Summary of what was created\n   - File locations\n   - How to test the new component\n   - Suggested next steps for refinement\n\n## Command Template\n\nGenerate command files with this structure:\n\n```markdown\n---\nname: { command-name }\ndescription: { One-line description }\nallowed-tools: [{ Tool1 }, { Tool2 }, ...]\n---\n\n{Description of what this command does}\n\n## Process\n\n1. **{Step Title}**\n   {Detailed description}\n\n2. **{Step Title}**\n   {Continue for all steps}\n\n## Examples\n\n### Example 1: Basic Usage\n\n{Show input and result}\n\n## Edge Cases\n\n- **Case 1**: {Description} → {How handled}\n\n## Important Rules\n\n- {Rule 1}\n- {Rule 2}\n```\n\n## Skill Template\n\nGenerate INSTRUCTIONS.md files with this structure:\n\n```markdown\n# {Skill Name in Title Case}\n\n{One-line description}\n\n## When to Use\n\n{Describe when the agent should proactively invoke this skill}\n\n## Process\n\n1. **{Step Title}**\n   {Detailed description}\n\n## Arguments\n\n| Argument | Required | Description |\n| -------- | -------- | ----------- |\n| `arg1`   | Yes      | Description |\n\n## Examples\n\n### Example 1\n\n{Show scenario and result}\n\n## Important Rules\n\n- {Rule 1}\n- {Rule 2}\n```\n\n## Examples\n\n### Simple Command\n\nUser: `/create-skill A command that formats JSON files with proper indentation`\n\nCreates:\n\n- Plugin: `plugins/json-formatter/`\n- Command: `commands/format-json.md`\n- Detects JSON files, formats with configurable indent\n\n### Adding to Existing Plugin\n\nUser: `/create-skill A command for creating release notes` (when `essentials` plugin exists)\n\nPrompts: \"Would you like to add this to the existing `essentials` plugin, or create a new plugin?\"\n\nIf adding to existing:\n\n- Only creates `commands/release-notes.md`\n- Updates `plugin.json` if needed\n- Runs sync\n\n## Important Rules\n\n- **Never overwrite without confirmation**: If a plugin or component exists, always ask before replacing\n- **Follow conventions exactly**: Match the patterns in existing plugins for consistency\n- **Generate comprehensive instructions**: Include process, examples, edge cases, and rules\n- **Validate before reporting success**: Run typecheck and build, fix any issues\n- **Use kebab-case everywhere**: Plugin names, component names, directory names, file names\n- **Run sync after creation**: Always update marketplace.json\n- **Suggest improvements**: After creation, suggest how the user might refine the component\n- **Single responsibility**: Each component should do one thing well - suggest splitting if too complex\n- **Commands for user actions**: Most `/invoke-name` patterns should be commands, not skills\n",
        "plugins/dev-commands/commands/build.md": "---\nname: build\ndescription: Build the project\nallowed-tools: [Bash, Read, Glob]\n---\n\nBuild the project using the appropriate build system.\n\n## Detection\n\nCheck for build configuration:\n\n1. `package.json` - look for build script\n2. `tsconfig.json` - TypeScript compilation\n3. `Cargo.toml` - Rust build\n4. `go.mod` - Go build\n5. `pyproject.toml` - Python build\n\n## Execution\n\nRun the build command:\n\n- **Node/Bun**: `npm run build` or `bun run build`\n- **TypeScript only**: `tsc --build`\n- **Rust**: `cargo build --release`\n- **Go**: `go build ./...`\n- **Python**: `python -m build` or `uv build`\n\nReport build errors with suggestions for fixes.\n",
        "plugins/dev-commands/commands/check.md": "---\nname: check\ndescription: Run all checks (typecheck, lint, test)\nallowed-tools: [Bash, Read, Glob]\n---\n\nRun all validation checks for the project before committing.\n\n## Workflow\n\nExecute checks in order, stopping on first failure:\n\n1. **Type Check**\n   - TypeScript: `tsc --noEmit` or `npx tsc --noEmit`\n   - Python: `pyright` or `mypy`\n   - Rust: `cargo check`\n\n2. **Lint**\n   - Run project's configured linter (see /lint)\n\n3. **Test**\n   - Run project's test suite (see /test)\n\n## Output\n\nSummarize results:\n\n- Total checks run\n- Pass/fail status for each\n- First error details if any failed\n\nIf all checks pass, confirm the project is ready to commit.\n",
        "plugins/dev-commands/commands/deps.md": "---\nname: deps\ndescription: Install or update project dependencies\nallowed-tools: [Bash, Read, Glob]\n---\n\nInstall or update project dependencies.\n\n## Detection\n\nIdentify package manager:\n\n- `bun.lock` or `bun.lockb` -> bun\n- `pnpm-lock.yaml` -> pnpm\n- `package-lock.json` -> npm\n- `yarn.lock` -> yarn\n- `uv.lock` -> uv\n- `Pipfile.lock` -> pipenv\n- `requirements.txt` -> pip\n- `Cargo.lock` -> cargo\n- `go.sum` -> go\n\n## Execution\n\nIf $ARGUMENTS contains \"update\" or \"upgrade\":\n\n- **bun**: `bun update`\n- **npm**: `npm update`\n- **pnpm**: `pnpm update`\n- **uv**: `uv lock --upgrade && uv sync`\n- **cargo**: `cargo update`\n- **go**: `go get -u ./...`\n\nOtherwise install:\n\n- **bun**: `bun install`\n- **npm**: `npm install`\n- **pnpm**: `pnpm install`\n- **uv**: `uv sync`\n- **cargo**: `cargo build`\n- **go**: `go mod download`\n",
        "plugins/dev-commands/commands/lint.md": "---\nname: lint\ndescription: Run linter and fix issues\nallowed-tools: [Bash, Read, Glob, Edit]\n---\n\nRun the project's linter and optionally fix issues.\n\n## Detection\n\nCheck for linting tools:\n\n1. `package.json` - eslint, biome, prettier, oxlint\n2. `pyproject.toml` - ruff, black, flake8\n3. `Cargo.toml` - clippy\n4. `.golangci.yml` - golangci-lint\n\n## Execution\n\nRun the linter:\n\n- **ESLint**: `npx eslint . --fix`\n- **Biome**: `npx biome check --write`\n- **Prettier**: `npx prettier --write .`\n- **Ruff**: `ruff check --fix . && ruff format .`\n- **Clippy**: `cargo clippy --fix`\n- **Go**: `golangci-lint run --fix`\n\nReport any issues that couldn't be auto-fixed.\n",
        "plugins/dev-commands/commands/test.md": "---\nname: test\ndescription: Run the project's test suite\nallowed-tools: [Bash, Read, Glob]\n---\n\nRun the test suite for this project.\n\n## Detection\n\nFirst, detect the test runner by checking:\n\n1. `package.json` for test scripts (npm test, vitest, jest, etc.)\n2. `pyproject.toml` or `pytest.ini` for pytest\n3. `Cargo.toml` for Rust tests\n4. `go.mod` for Go tests\n\n## Execution\n\nRun the appropriate test command:\n\n- **Node/Bun**: `npm test` or `bun test` or `pnpm test`\n- **Python**: `pytest` or `python -m pytest`\n- **Rust**: `cargo test`\n- **Go**: `go test ./...`\n\nIf tests fail, analyze the output and suggest fixes.\n\nIf $ARGUMENTS is provided, use it to filter tests (e.g., `/test auth` runs only auth-related tests).\n",
        "plugins/github-actions-generator/skills/generate-action/INSTRUCTIONS.md": "# Generate GitHub Action\n\nGenerate TypeScript GitHub Actions for Bun workspace monorepos with full lifecycle support.\n\n## When to Use\n\nUse this skill when the user wants to:\n\n- Create a new GitHub Action in their actions monorepo\n- Scaffold an action with TypeScript, Bun, and Octokit\n- Add a new action to an existing Bun workspace\n\n## Prerequisites\n\nBefore starting, verify these requirements:\n\n1. **Bun Workspace**: Current directory has a `package.json` with `\"workspaces\"` field\n2. **Dependencies Available**: Root `package.json` includes `@actions/core`, `@actions/github`, and `@octokit/*` packages\n3. **Bun Catalog**: Root `package.json` has a `\"catalog\"` section for shared dependency versions\n4. **Actions Directory**: Identify where actions live (commonly `packages/`, `actions/`, or similar)\n\nIf prerequisites are missing, guide the user to set them up before proceeding.\n\n## Workflow\n\n### Step 1: Detect Workspace Structure\n\nRead the root `package.json` to understand the workspace:\n\n```typescript\n// Check for workspace configuration\nconst pkg = await Bun.file('package.json').json();\n\n// Verify it's a Bun workspace\nif (!pkg.workspaces) {\n  // Not a Bun workspace - inform user\n}\n\n// Check for Bun Catalog\nif (!pkg.catalog) {\n  // No catalog - may need to set one up\n}\n\n// Find actions directory from workspaces patterns\nconst actionsDir = pkg.workspaces.find((p) => p.includes('actions') || p.includes('packages'));\n```\n\nExamine existing actions to understand patterns:\n\n- Package naming convention (scoped vs unscoped)\n- Directory structure\n- Existing dependencies\n\n### Step 2: Gather Action Details\n\nUse `AskUserQuestion` to collect information:\n\n1. **Action Name** (kebab-case): What should the action be called?\n2. **Description**: One-line description of what it does\n3. **Primary Purpose**: What GitHub resources does it interact with? (Issues, PRs, Repos, etc.)\n\nExample questions:\n\n```\nQuestion: \"What should this action be named?\"\nHeader: \"Action Name\"\nOptions:\n- User provides kebab-case name (e.g., \"add-label\", \"create-issue\", \"sync-files\")\n```\n\n### Step 3: Check for Conflicts\n\nBefore creating files:\n\n1. Check if `{actions-dir}/{action-name}/` already exists\n2. If exists, ask user how to proceed:\n   - Choose different name\n   - Overwrite (requires explicit confirmation)\n\n### Step 4: Handle Dependencies\n\nWhen the action needs additional dependencies beyond the defaults:\n\nUse `AskUserQuestion`:\n\n```\nQuestion: \"Should {package-name} be a global dependency (shared across all actions) or local to this action only?\"\nHeader: \"Dependency\"\nOptions:\n- \"Global\" - Add to root package.json catalog, use catalog: in action\n- \"Local\" - Add directly to action's package.json with pinned version\n```\n\n**For global dependencies**:\n\n1. Add to root `package.json` dependencies\n2. Add version to `catalog` section\n3. Use `\"package-name\": \"catalog:\"` in action's package.json\n\n**For local dependencies**:\n\n1. Add directly to action's package.json with specific version\n\n### Step 5: Generate Files\n\nCreate files in this order using the reference templates:\n\n1. **package.json** - Use `references/package-template.md`\n2. **tsconfig.json** - Use `references/tsconfig-template.md`\n3. **action.yml** - Use `references/action-yml-template.md`\n4. **src/index.ts** - Use `references/entrypoint-template.md`\n\nFile generation checklist:\n\n- [ ] All `catalog:` references match root package.json catalog\n- [ ] tsconfig extends root or has appropriate standalone config\n- [ ] action.yml has placeholder inputs/outputs ready for Phase 2\n- [ ] src/index.ts has basic structure with @actions/core imports\n\n### Step 6: Workspace Integration\n\nAfter generating files:\n\n```bash\n# Install dependencies and link the new package\nbun install\n\n# Verify TypeScript compiles\nbun run build --filter=@{scope}/{action-name}\n```\n\n### Step 7: Validate\n\nRun validation to ensure the scaffold is correct:\n\n```bash\n# From the new action directory\nbun install\nbun run build\nbiome check .\n```\n\nReport any errors and fix before completing.\n\n### Step 8: Report Results\n\nProvide a summary:\n\n```markdown\n## Action Created: {action-name}\n\n**Location**: {actions-dir}/{action-name}/\n\n**Files created**:\n\n- package.json (using Bun Catalog dependencies)\n- tsconfig.json\n- action.yml\n- src/index.ts\n\n**Next steps**:\n\n1. Implement action logic in src/index.ts\n2. Define inputs/outputs in action.yml\n3. Add unit tests\n4. Generate README and CI workflow\n\nUse this skill again to help with implementation (Phase 2).\n```\n\n## Default Dependencies\n\nActions are created with these dependencies via Bun Catalog:\n\n**Dependencies**:\n\n- `@actions/core` - GitHub Actions toolkit core\n- `@actions/github` - GitHub context and Octokit\n- `@octokit/rest` - GitHub REST API client\n\n**Dev Dependencies**:\n\n- `@biomejs/biome` - Linting and formatting\n- `@types/bun` - Bun type definitions\n\n## Implementation Assistance\n\nWhen the user wants to implement the action logic after scaffolding:\n\n### Step 1: Understand Requirements\n\nAsk the user to describe:\n\n- **Primary purpose**: What should the action do?\n- **GitHub resources**: What does it interact with? (issues, PRs, repos, files, etc.)\n- **Inputs needed**: What information does it need from users?\n- **Outputs produced**: What should it return?\n- **Edge cases**: Any special situations to handle?\n\n### Step 2: Choose Implementation Pattern\n\nBased on requirements, select appropriate patterns from:\n\n- `references/implementation-patterns.md` - General action patterns\n- `references/octokit-patterns.md` - GitHub API interactions\n- `references/error-handling-patterns.md` - Error handling\n\n### Step 3: Implement\n\n1. Update `src/index.ts` with the implementation\n2. Update `action.yml` with actual inputs/outputs and descriptions\n3. Add JSDoc comments to exported functions and types\n4. Only add clarifying comments for complex or non-obvious logic\n\n### Step 4: Validate Implementation\n\nRun these commands:\n\n```bash\nbun run build    # Verify compilation\nbiome check .    # Verify code quality\n```\n\nFix any issues before proceeding.\n\n## Test Generation\n\nAfter implementation, generate unit tests:\n\n### Step 1: Create Test File\n\nCreate `src/index.test.ts` (or `tests/index.test.ts` based on project convention).\n\n### Step 2: Apply Testing Patterns\n\nUse patterns from `references/testing-patterns.md`:\n\n- Mock `@actions/core` (getInput, setOutput, setFailed, logging)\n- Mock `@actions/github` (context, getOctokit)\n- Mock Octokit client methods as needed\n\n### Step 3: Write Test Cases\n\nRequired coverage for comprehensive testing:\n\n**Happy path**:\n\n- Valid inputs produce expected outputs\n- API calls made with correct parameters\n\n**Edge cases**:\n\n- Empty optional inputs use defaults\n- Missing optional context handled gracefully\n- Boundary conditions (empty arrays, max values)\n\n**Error cases**:\n\n- API failures (rate limits, 404, 403)\n- Invalid inputs (wrong format, out of range)\n- Missing required inputs\n\n### Step 4: Run Tests\n\n```bash\nbun test\n```\n\nAll tests must pass before completing.\n\n### Step 5: Report Test Results\n\n```markdown\n## Tests Created\n\n**Test file**: src/index.test.ts\n\n**Coverage**:\n\n- Happy path: {number} tests\n- Edge cases: {number} tests\n- Error cases: {number} tests\n\n**Run with**: `bun test`\n```\n\n## Documentation Generation\n\nAfter implementation and tests are complete, generate documentation:\n\n### Step 1: Gather Context\n\n- Read `action.yml` for inputs/outputs\n- Check git tags for latest version: `git describe --tags --abbrev=0`\n- For monorepos: `git tag --list '{action-name}-v*' --sort=-version:refname | head -1`\n- Identify repository owner/repo from git remote\n\n### Step 2: Generate README\n\nUse `references/readme-template.md` to create `README.md` in the action directory:\n\n- Action name and description from action.yml\n- Usage example with **actual version tag** (never `@latest` or `@main`)\n- Inputs table matching action.yml exactly\n- Outputs table matching action.yml exactly\n- Example workflow showing real-world usage\n- Development section with build/test commands\n\n### Step 3: Validate README\n\n- [ ] Version tag exists (or warn user to create release)\n- [ ] Inputs table matches action.yml\n- [ ] Outputs table matches action.yml\n- [ ] Example workflow is syntactically valid\n\n## CI Workflow Generation\n\n### Step 1: Determine Workflow Strategy\n\nAsk user preference via `AskUserQuestion`:\n\n```\nQuestion: \"How should CI be structured for this action?\"\nHeader: \"CI Strategy\"\nOptions:\n- \"Per-action workflow (Recommended)\" - Create .github/workflows/test-{action-name}.yml\n- \"Add to existing monorepo workflow\" - Update existing workflow with path filters\n```\n\n### Step 2: Generate CI Workflow\n\nUse `references/ci-workflow-template.md`:\n\n- Path filters for action directory\n- Bun setup with latest version\n- Install, lint, build, test steps\n- Working directory scoped to action\n\n### Step 3: Place Workflow File\n\nCreate at `.github/workflows/test-{action-name}.yml`\n\n### Step 4: Report CI Setup\n\n```markdown\n## CI Workflow Created\n\n**File**: `.github/workflows/test-{action-name}.yml`\n\n**Triggers**:\n\n- Pull requests modifying `{action-path}/**`\n- Push to main modifying `{action-path}/**`\n\n**Jobs**:\n\n- Install dependencies\n- Run linter\n- Build action\n- Run tests\n```\n\n## Release Guidance\n\nWhen user is ready to release:\n\n### Step 1: Versioning Strategy\n\nReference `references/versioning-guide.md`:\n\n- **Major**: Breaking changes (removed inputs, changed behavior)\n- **Minor**: New features (new optional inputs, new outputs)\n- **Patch**: Bug fixes, documentation\n\n### Step 2: Release Options\n\nAsk user preference:\n\n```\nQuestion: \"How would you like to handle releases?\"\nHeader: \"Release\"\nOptions:\n- \"Manual releases\" - Guide through manual tagging process\n- \"Automated workflow\" - Generate release workflow from references/release-workflow-template.md\n```\n\n### Step 3: For Manual Releases\n\nGuide through:\n\n```bash\n# 1. Update version in package.json\ncd {action-path}\n# Edit package.json version field\n\n# 2. Build the action\nbun run build\n\n# 3. Commit changes\ngit add .\ngit commit -m \"release: {action-name} v{version}\"\n\n# 4. Create tags\ngit tag {action-name}-v{version}\ngit tag -f {action-name}-v{major}\n\n# 5. Push\ngit push origin main\ngit push origin {action-name}-v{version}\ngit push origin -f {action-name}-v{major}\n\n# 6. Create GitHub release\ngh release create {action-name}-v{version} --generate-notes\n```\n\n### Step 4: For Automated Releases\n\nUse `references/release-workflow-template.md` to create `.github/workflows/release-{action-name}.yml`\n\n## Important Rules\n\n- **Always use Bun Catalog**: Dependencies should reference `catalog:` for version management\n- **Follow existing patterns**: Match naming and structure conventions from other actions in the repo\n- **Validate before reporting success**: Run build and lint, fix any issues\n- **Use kebab-case everywhere**: Action names, package names, directory names\n- **No unnecessary dependencies**: Prefer Bun runtime utilities over npm packages\n- **Comments policy**: Only JSDoc for public APIs, or comments for genuinely complex code\n- **Ask before overwriting**: Never replace existing files without explicit confirmation\n- **Test coverage**: Every action should have unit tests covering happy path, edge cases, and errors\n- **Use bun:test**: Always use bun:test for testing, not Jest or other frameworks\n- **Real version tags**: Never use `@latest`, `@main`, or `@master` in documentation examples\n- **Per-action CI**: Prefer per-action workflows with path filters for monorepo efficiency\n",
        "plugins/github-actions-generator/skills/generate-action/references/action-yml-template.md": "# action.yml Template\n\nGenerate `action.yml` metadata file for a GitHub Action.\n\n## Template\n\n```yaml\nname: '{Action Name}'\ndescription: '{One-line description of what the action does}'\nauthor: '{author}'\n\nbranding:\n  icon: '{icon}'\n  color: '{color}'\n\ninputs:\n  github-token:\n    description: 'GitHub token for API access'\n    required: false\n    default: ${{ github.token }}\n  # Add more inputs based on action requirements\n\noutputs:\n  # Add outputs based on action requirements\n  # example:\n  #   description: 'Description of the output value'\n\nruns:\n  using: 'node20'\n  main: 'dist/index.js'\n```\n\n## Variables\n\n| Variable        | Source                         | Example                                                    |\n| --------------- | ------------------------------ | ---------------------------------------------------------- |\n| `{Action Name}` | Title case from user input     | `Add Label`, `Create Issue`                                |\n| `{description}` | One-line description from user | `Automatically add labels to issues based on content`      |\n| `{author}`      | From git config or user input  | `birdcar`                                                  |\n| `{icon}`        | Feather icon name              | `tag`, `git-pull-request`, `file-text`                     |\n| `{color}`       | Branding color                 | `blue`, `green`, `orange`, `purple`, `yellow`, `gray-dark` |\n\n## Common Input Patterns\n\n**GitHub Token** (most actions need this):\n\n```yaml\ninputs:\n  github-token:\n    description: 'GitHub token for API access'\n    required: false\n    default: ${{ github.token }}\n```\n\n**Required String Input**:\n\n```yaml\ninputs:\n  label-name:\n    description: 'Name of the label to add'\n    required: true\n```\n\n**Optional Input with Default**:\n\n```yaml\ninputs:\n  dry-run:\n    description: 'Run without making changes'\n    required: false\n    default: 'false'\n```\n\n## Common Output Patterns\n\n**Single Value**:\n\n```yaml\noutputs:\n  issue-number:\n    description: 'Number of the created issue'\n```\n\n**JSON Data**:\n\n```yaml\noutputs:\n  result:\n    description: 'JSON object containing operation results'\n```\n\n## Branding Icons\n\nCommon icons for GitHub Actions:\n\n- `tag` - labeling, tagging\n- `git-pull-request` - PR operations\n- `git-commit` - commit operations\n- `file-text` - file operations\n- `check-circle` - validation, checks\n- `alert-triangle` - warnings, notifications\n- `message-square` - comments, messaging\n- `refresh-cw` - sync, update operations\n\n## Notes\n\n- Always include `github-token` input even if not immediately needed\n- Use `node20` runtime (current GitHub Actions standard)\n- Outputs are set in code via `core.setOutput('name', value)`\n- Keep descriptions concise but clear\n",
        "plugins/github-actions-generator/skills/generate-action/references/ci-workflow-template.md": "# CI Workflow Template\n\nTemplate for generating GitHub Actions CI workflows to test actions in a monorepo.\n\n## Template\n\n```yaml\nname: Test {action-name}\n\non:\n  pull_request:\n    paths:\n      - '{action-path}/**'\n      - '.github/workflows/test-{action-name}.yml'\n  push:\n    branches:\n      - main\n    paths:\n      - '{action-path}/**'\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n        with:\n          bun-version: latest\n\n      - name: Install dependencies\n        run: bun install\n        working-directory: { action-path }\n\n      - name: Lint\n        run: bun run lint\n        working-directory: { action-path }\n\n      - name: Build\n        run: bun run build\n        working-directory: { action-path }\n\n      - name: Test\n        run: bun test\n        working-directory: { action-path }\n```\n\n## Template Variables\n\n| Variable        | Source                          | Example              |\n| --------------- | ------------------------------- | -------------------- |\n| `{action-name}` | Kebab-case action name          | `add-label`          |\n| `{action-path}` | Relative path to action package | `packages/add-label` |\n\n## File Placement\n\nThe workflow should be created at:\n\n```\n.github/workflows/test-{action-name}.yml\n```\n\nFor example: `.github/workflows/test-add-label.yml`\n\n## Path Filter Strategy\n\nThe workflow uses path filters to:\n\n1. **Only run on relevant changes** - Won't trigger for unrelated code\n2. **Include workflow file itself** - Changes to the CI config trigger a run\n3. **Run on main push** - Verify merged changes\n\n```yaml\npaths:\n  - '{action-path}/**' # Any file in the action\n  - '.github/workflows/test-{action-name}.yml' # The workflow itself\n```\n\n## Alternative: Monorepo-Wide Workflow\n\nFor repos that prefer a single workflow for all actions:\n\n```yaml\nname: Test Actions\n\non:\n  pull_request:\n    paths:\n      - 'packages/**'\n  push:\n    branches:\n      - main\n    paths:\n      - 'packages/**'\n\njobs:\n  detect-changes:\n    runs-on: ubuntu-latest\n    outputs:\n      actions: ${{ steps.changes.outputs.actions }}\n    steps:\n      - uses: actions/checkout@v4\n      - uses: dorny/paths-filter@v3\n        id: changes\n        with:\n          filters: |\n            add-label:\n              - 'packages/add-label/**'\n            create-issue:\n              - 'packages/create-issue/**'\n\n  test:\n    needs: detect-changes\n    if: ${{ needs.detect-changes.outputs.actions != '[]' }}\n    strategy:\n      matrix:\n        action: ${{ fromJson(needs.detect-changes.outputs.actions) }}\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: oven-sh/setup-bun@v2\n      - run: bun install\n        working-directory: packages/${{ matrix.action }}\n      - run: bun test\n        working-directory: packages/${{ matrix.action }}\n```\n\n## Bun Setup Notes\n\n- Uses `oven-sh/setup-bun@v2` (latest stable)\n- `bun-version: latest` ensures newest Bun\n- Working directory scoped to action for proper lockfile resolution\n\n## Adding Type Checking (Optional)\n\nIf the action has TypeScript type checking:\n\n```yaml\n- name: Type Check\n  run: bun run typecheck\n  working-directory: { action-path }\n```\n\n## Adding Integration Tests (Optional)\n\nIf the action has integration tests that run the action itself:\n\n```yaml\n- name: Integration Test\n  uses: ./{action-path}\n  with:\n    github-token: ${{ secrets.GITHUB_TOKEN }}\n    # test inputs\n```\n\n## Caching Dependencies (Optional)\n\nFor faster CI runs:\n\n```yaml\n- name: Setup Bun\n  uses: oven-sh/setup-bun@v2\n  with:\n    bun-version: latest\n\n- name: Cache dependencies\n  uses: actions/cache@v4\n  with:\n    path: ~/.bun/install/cache\n    key: ${{ runner.os }}-bun-${{ hashFiles('{action-path}/bun.lockb') }}\n    restore-keys: |\n      ${{ runner.os }}-bun-\n```\n",
        "plugins/github-actions-generator/skills/generate-action/references/entrypoint-template.md": "# src/index.ts Template\n\nGenerate the entrypoint file for a GitHub Action.\n\n## Template\n\n```typescript\nimport * as core from '@actions/core';\nimport * as github from '@actions/github';\n\n/**\n * Main entry point for the {Action Name} action.\n */\nasync function run(): Promise<void> {\n  try {\n    // Get inputs\n    const token = core.getInput('github-token', { required: true });\n\n    // Create Octokit client\n    const octokit = github.getOctokit(token);\n\n    // Get context\n    const { owner, repo } = github.context.repo;\n\n    // TODO: Implement action logic here\n\n    // Set outputs\n    // core.setOutput('result', value);\n\n    core.info('Action completed successfully');\n  } catch (error) {\n    if (error instanceof Error) {\n      core.setFailed(error.message);\n    } else {\n      core.setFailed('An unexpected error occurred');\n    }\n  }\n}\n\nrun();\n```\n\n## Structure Explanation\n\n### Imports\n\n```typescript\nimport * as core from '@actions/core'; // Input/output handling, logging, failure\nimport * as github from '@actions/github'; // GitHub context, Octokit factory\n```\n\n### Input Handling\n\n```typescript\n// Required input - throws if not provided\nconst requiredInput = core.getInput('input-name', { required: true });\n\n// Optional input with default\nconst optionalInput = core.getInput('optional-input') || 'default-value';\n\n// Boolean input\nconst boolInput = core.getBooleanInput('bool-input');\n\n// Multiline input (returns array)\nconst multilineInput = core.getMultilineInput('list-input');\n```\n\n### Octokit Client\n\n```typescript\nconst token = core.getInput('github-token', { required: true });\nconst octokit = github.getOctokit(token);\n\n// REST API calls\nconst { data } = await octokit.rest.issues.create({\n  owner,\n  repo,\n  title: 'Issue title',\n});\n\n// GraphQL queries\nconst result = await octokit.graphql(\n  `\n  query($owner: String!, $repo: String!) {\n    repository(owner: $owner, name: $repo) {\n      name\n    }\n  }\n`,\n  { owner, repo }\n);\n```\n\n### Context Access\n\n```typescript\nconst { owner, repo } = github.context.repo;\nconst { eventName, payload, sha, ref } = github.context;\n\n// For pull_request events\nconst prNumber = github.context.payload.pull_request?.number;\n\n// For issue events\nconst issueNumber = github.context.payload.issue?.number;\n```\n\n### Output Setting\n\n```typescript\n// String output\ncore.setOutput('result', 'value');\n\n// JSON output\ncore.setOutput('data', JSON.stringify(data));\n\n// Export variable for subsequent steps\ncore.exportVariable('MY_VAR', 'value');\n```\n\n### Logging\n\n```typescript\ncore.info('Information message');\ncore.warning('Warning message');\ncore.error('Error message');\ncore.debug('Debug message'); // Only shows when ACTIONS_STEP_DEBUG=true\n\n// Grouped output\ncore.startGroup('Processing files');\ncore.info('File 1...');\ncore.info('File 2...');\ncore.endGroup();\n```\n\n### Error Handling\n\n```typescript\ntry {\n  await riskyOperation();\n} catch (error) {\n  if (error instanceof Error) {\n    core.setFailed(error.message);\n  } else {\n    core.setFailed('An unexpected error occurred');\n  }\n}\n```\n\n## Notes\n\n- Always wrap main logic in try/catch with `core.setFailed`\n- Use `core.info` for user-visible progress messages\n- Use `core.debug` for verbose debugging (hidden by default)\n- Prefer async/await over callbacks\n- The `run()` call at the end starts the action\n",
        "plugins/github-actions-generator/skills/generate-action/references/error-handling-patterns.md": "# Error Handling Patterns\n\nBest practices for error handling in GitHub Actions.\n\n## Standard Error Wrapper\n\nEvery action should wrap its main logic in a try-catch that calls `setFailed`:\n\n```typescript\nimport * as core from '@actions/core';\n\nasync function run(): Promise<void> {\n  try {\n    await performAction();\n  } catch (error) {\n    handleError(error);\n  }\n}\n\nfunction handleError(error: unknown): void {\n  if (error instanceof Error) {\n    core.setFailed(error.message);\n  } else if (typeof error === 'string') {\n    core.setFailed(error);\n  } else {\n    core.setFailed('An unexpected error occurred');\n  }\n}\n\nrun();\n```\n\n## Octokit Error Handling\n\nHandle GitHub API errors with specific status codes:\n\n```typescript\nimport { RequestError } from '@octokit/request-error';\n\ntry {\n  await octokit.rest.issues.create({\n    owner,\n    repo,\n    title: 'Issue title',\n  });\n} catch (error) {\n  if (error instanceof RequestError) {\n    switch (error.status) {\n      case 401:\n        core.setFailed('Authentication failed. Check your GITHUB_TOKEN.');\n        break;\n      case 403:\n        if (error.response?.headers['x-ratelimit-remaining'] === '0') {\n          core.setFailed('GitHub API rate limit exceeded. Try again later.');\n        } else {\n          core.setFailed('Permission denied. Ensure the token has required scopes.');\n        }\n        break;\n      case 404:\n        core.setFailed('Repository not found or no access.');\n        break;\n      case 422:\n        core.setFailed(`Validation failed: ${error.message}`);\n        break;\n      default:\n        core.setFailed(`GitHub API error (${error.status}): ${error.message}`);\n    }\n  } else {\n    throw error; // Re-throw unexpected errors\n  }\n}\n```\n\n## Input Validation\n\nValidate inputs early and fail with clear messages:\n\n```typescript\ninterface ActionInputs {\n  token: string;\n  labelName: string;\n  maxItems: number;\n}\n\nfunction validateInputs(): ActionInputs {\n  const token = core.getInput('github-token', { required: true });\n  if (!token) {\n    throw new Error('github-token is required');\n  }\n\n  const labelName = core.getInput('label-name', { required: true });\n  if (!labelName.match(/^[a-zA-Z0-9-_]+$/)) {\n    throw new Error(\n      'label-name must contain only alphanumeric characters, hyphens, and underscores'\n    );\n  }\n\n  const maxItemsRaw = core.getInput('max-items') || '100';\n  const maxItems = parseInt(maxItemsRaw, 10);\n  if (isNaN(maxItems) || maxItems < 1 || maxItems > 1000) {\n    throw new Error('max-items must be a number between 1 and 1000');\n  }\n\n  return { token, labelName, maxItems };\n}\n```\n\n## Context Validation\n\nEnsure the action runs in the correct context:\n\n```typescript\nfunction validateContext(): { prNumber: number } {\n  if (github.context.eventName !== 'pull_request') {\n    throw new Error(\n      `This action only supports pull_request events, got: ${github.context.eventName}`\n    );\n  }\n\n  const prNumber = github.context.payload.pull_request?.number;\n  if (!prNumber) {\n    throw new Error('Could not determine pull request number from context');\n  }\n\n  return { prNumber };\n}\n```\n\n## Graceful Degradation\n\nWhen optional features fail, continue with a warning:\n\n```typescript\nasync function run(): Promise<void> {\n  try {\n    // Core functionality\n    const result = await performMainAction();\n    core.setOutput('result', result);\n\n    // Optional enhancement - don't fail if this errors\n    try {\n      await addOptionalMetadata(result);\n    } catch (error) {\n      core.warning(`Optional metadata failed: ${error}`);\n      // Continue without failing\n    }\n\n    // Another optional feature\n    try {\n      await notifySlack(result);\n    } catch (error) {\n      core.warning(`Slack notification failed: ${error}`);\n      // Continue without failing\n    }\n  } catch (error) {\n    handleError(error);\n  }\n}\n```\n\n## Retries for Transient Errors\n\nRetry operations that might fail due to network issues:\n\n```typescript\nasync function withRetry<T>(\n  operation: () => Promise<T>,\n  maxAttempts = 3,\n  delayMs = 1000\n): Promise<T> {\n  let lastError: Error | undefined;\n\n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      return await operation();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Don't retry on client errors (4xx except 429)\n      if (error instanceof RequestError) {\n        if (error.status >= 400 && error.status < 500 && error.status !== 429) {\n          throw error;\n        }\n      }\n\n      if (attempt < maxAttempts) {\n        core.warning(`Attempt ${attempt} failed, retrying in ${delayMs}ms...`);\n        await new Promise((resolve) => setTimeout(resolve, delayMs * attempt));\n      }\n    }\n  }\n\n  throw lastError;\n}\n\n// Usage\nconst result = await withRetry(() => octokit.rest.issues.create({ owner, repo, title: 'Issue' }));\n```\n\n## Error Messages for Users\n\nWrite error messages that help users fix the problem:\n\n```typescript\n// Bad - doesn't help user\ncore.setFailed('Error occurred');\n\n// Good - tells user what went wrong and how to fix\ncore.setFailed(\n  'Failed to add label: Label \"needs-review\" does not exist. ' +\n    'Create the label in your repository settings first.'\n);\n\n// Good - includes context for debugging\ncore.setFailed(\n  `Failed to create issue in ${owner}/${repo}. ` +\n    `Ensure the GITHUB_TOKEN has 'issues: write' permission.`\n);\n```\n\n## Structured Error Information\n\nFor complex errors, provide structured information:\n\n```typescript\ninterface ActionError {\n  code: string;\n  message: string;\n  details?: Record<string, unknown>;\n}\n\nfunction createError(\n  code: string,\n  message: string,\n  details?: Record<string, unknown>\n): ActionError {\n  return { code, message, details };\n}\n\nfunction handleStructuredError(error: ActionError): void {\n  core.error(`[${error.code}] ${error.message}`);\n  if (error.details) {\n    core.debug(`Error details: ${JSON.stringify(error.details, null, 2)}`);\n  }\n  core.setFailed(error.message);\n}\n\n// Usage\nif (!prNumber) {\n  handleStructuredError(\n    createError('MISSING_CONTEXT', 'Pull request number not found in context', {\n      eventName: github.context.eventName,\n      hasPayload: !!github.context.payload,\n    })\n  );\n}\n```\n\n## Cleanup on Failure\n\nEnsure cleanup happens even when the action fails:\n\n```typescript\nasync function run(): Promise<void> {\n  let tempFile: string | undefined;\n\n  try {\n    tempFile = await createTempFile();\n    await performAction(tempFile);\n  } catch (error) {\n    handleError(error);\n  } finally {\n    // Cleanup always runs\n    if (tempFile) {\n      try {\n        (await Bun.file(tempFile).exists()) && (await unlink(tempFile));\n      } catch {\n        core.warning('Failed to cleanup temporary file');\n      }\n    }\n  }\n}\n```\n\n## Error Boundaries for Parallel Operations\n\nWhen running multiple operations, collect all errors:\n\n```typescript\nasync function processItems(items: string[]): Promise<void> {\n  const results = await Promise.allSettled(items.map((item) => processItem(item)));\n\n  const failures = results.filter((r): r is PromiseRejectedResult => r.status === 'rejected');\n\n  if (failures.length > 0) {\n    const errorMessages = failures.map((f) => f.reason?.message || 'Unknown error');\n    core.setFailed(`${failures.length}/${items.length} items failed:\\n${errorMessages.join('\\n')}`);\n  } else {\n    core.info(`Successfully processed all ${items.length} items`);\n  }\n}\n```\n",
        "plugins/github-actions-generator/skills/generate-action/references/implementation-patterns.md": "# Implementation Patterns\n\nCommon patterns for implementing GitHub Actions with TypeScript.\n\n## Basic Action Structure\n\n```typescript\nimport * as core from '@actions/core';\nimport * as github from '@actions/github';\n\nasync function run(): Promise<void> {\n  try {\n    const result = await performAction();\n    core.setOutput('result', result);\n  } catch (error) {\n    if (error instanceof Error) {\n      core.setFailed(error.message);\n    } else {\n      core.setFailed('An unexpected error occurred');\n    }\n  }\n}\n\nrun();\n```\n\n## Input Handling\n\n```typescript\n// Required input - throws if not provided\nconst requiredInput = core.getInput('required-input', { required: true });\n\n// Optional input with default\nconst optionalInput = core.getInput('optional-input') || 'default-value';\n\n// Boolean input (handles 'true', 'false', 'yes', 'no', etc.)\nconst boolInput = core.getBooleanInput('bool-input');\n\n// Multiline input (returns array of lines)\nconst multilineInput = core.getMultilineInput('multiline-input');\n\n// Trimmed whitespace (default is true)\nconst untrimmedInput = core.getInput('input', { trimWhitespace: false });\n```\n\n## Output Setting\n\n```typescript\n// String output\ncore.setOutput('result', 'value');\n\n// JSON output (consumer needs to parse)\ncore.setOutput('data', JSON.stringify(data));\n\n// Export variable for subsequent steps\ncore.exportVariable('MY_VAR', value);\n\n// Add to PATH\ncore.addPath('/path/to/tool');\n```\n\n## Logging\n\n```typescript\n// Standard logging (always visible)\ncore.info('Information message');\ncore.warning('Warning message');\ncore.error('Error message');\n\n// Debug logging (only when ACTIONS_STEP_DEBUG=true)\ncore.debug('Debug message');\n\n// Notice (creates annotation)\ncore.notice('Notice message', {\n  title: 'Notice Title',\n  file: 'src/index.ts',\n  startLine: 10,\n});\n\n// Group output for readability\ncore.startGroup('Processing files');\ncore.info('File 1...');\ncore.info('File 2...');\ncore.endGroup();\n\n// Mask sensitive values from logs\ncore.setSecret(sensitiveValue);\n```\n\n## Conditional Execution\n\n```typescript\n// Check event type\nif (github.context.eventName === 'pull_request') {\n  // PR-specific logic\n}\n\n// Check action type within event\nconst action = github.context.payload.action;\nif (action === 'opened' || action === 'synchronize') {\n  // Handle new or updated PR\n}\n\n// Check if running in a specific context\nconst isPR = !!github.context.payload.pull_request;\nconst isIssue = !!github.context.payload.issue;\n```\n\n## Working with Files\n\n```typescript\n// Read file using Bun (preferred over Node.js fs)\nconst content = await Bun.file('path/to/file.ts').text();\n\n// Write file using Bun\nawait Bun.write('path/to/output.json', JSON.stringify(data, null, 2));\n\n// Check if file exists\nconst file = Bun.file('path/to/file.ts');\nconst exists = await file.exists();\n```\n\n## Environment Variables\n\n```typescript\n// Access environment variables\nconst token = process.env.GITHUB_TOKEN;\nconst workspace = process.env.GITHUB_WORKSPACE;\nconst repository = process.env.GITHUB_REPOSITORY;\n\n// Common GitHub Actions environment variables:\n// - GITHUB_TOKEN: Authentication token\n// - GITHUB_WORKSPACE: Working directory\n// - GITHUB_REPOSITORY: owner/repo\n// - GITHUB_SHA: Commit SHA\n// - GITHUB_REF: Branch or tag ref\n// - GITHUB_ACTOR: Username who triggered the action\n// - GITHUB_RUN_ID: Unique workflow run ID\n```\n\n## Async Operations\n\n```typescript\n// Sequential operations\nconst result1 = await operation1();\nconst result2 = await operation2(result1);\n\n// Parallel operations (when independent)\nconst [issues, prs] = await Promise.all([\n  octokit.rest.issues.listForRepo({ owner, repo }),\n  octokit.rest.pulls.list({ owner, repo }),\n]);\n\n// Handle pagination\nconst allIssues = await octokit.paginate(octokit.rest.issues.listForRepo, {\n  owner,\n  repo,\n  per_page: 100,\n});\n```\n\n## State Management\n\n```typescript\n// Save state for post action\ncore.saveState('previousValue', currentValue);\n\n// Retrieve state in post action\nconst previousValue = core.getState('previousValue');\n\n// Check if in post action\nconst isPost = !!core.getState('isPost');\ncore.saveState('isPost', 'true');\n```\n",
        "plugins/github-actions-generator/skills/generate-action/references/octokit-patterns.md": "# Octokit Patterns\n\nPatterns for GitHub API interactions using Octokit SDK.\n\n## Getting Authenticated Client\n\n```typescript\nimport * as core from '@actions/core';\nimport * as github from '@actions/github';\n\n// Using GITHUB_TOKEN from action input\nconst token = core.getInput('github-token', { required: true });\nconst octokit = github.getOctokit(token);\n\n// Access context\nconst { owner, repo } = github.context.repo;\nconst { eventName, payload, sha, ref } = github.context;\n```\n\n## Issues\n\n### Create Issue\n\n```typescript\nconst { data: issue } = await octokit.rest.issues.create({\n  owner,\n  repo,\n  title: 'Issue title',\n  body: 'Issue body with **markdown** support',\n  labels: ['bug', 'high-priority'],\n  assignees: ['username'],\n  milestone: 1,\n});\n\ncore.info(`Created issue #${issue.number}`);\ncore.setOutput('issue-number', issue.number);\ncore.setOutput('issue-url', issue.html_url);\n```\n\n### Add Comment\n\n```typescript\nconst { data: comment } = await octokit.rest.issues.createComment({\n  owner,\n  repo,\n  issue_number: issueNumber,\n  body: 'Comment body with **markdown**',\n});\n```\n\n### Add Labels\n\n```typescript\nawait octokit.rest.issues.addLabels({\n  owner,\n  repo,\n  issue_number: issueNumber,\n  labels: ['needs-review', 'documentation'],\n});\n```\n\n### List Issues\n\n```typescript\n// Simple list\nconst { data: issues } = await octokit.rest.issues.listForRepo({\n  owner,\n  repo,\n  state: 'open',\n  labels: 'bug',\n  per_page: 100,\n});\n\n// With pagination (get all)\nconst allIssues = await octokit.paginate(octokit.rest.issues.listForRepo, {\n  owner,\n  repo,\n  state: 'all',\n  per_page: 100,\n});\n```\n\n## Pull Requests\n\n### Get PR from Context\n\n```typescript\n// For pull_request events\nconst pr = github.context.payload.pull_request;\nif (!pr) {\n  core.setFailed('This action only runs on pull_request events');\n  return;\n}\n\nconst prNumber = pr.number;\nconst prTitle = pr.title;\nconst prBody = pr.body;\nconst baseBranch = pr.base.ref;\nconst headBranch = pr.head.ref;\n```\n\n### Get PR Details\n\n```typescript\nconst { data: pullRequest } = await octokit.rest.pulls.get({\n  owner,\n  repo,\n  pull_number: prNumber,\n});\n\ncore.info(`PR: ${pullRequest.title}`);\ncore.info(`State: ${pullRequest.state}`);\ncore.info(`Mergeable: ${pullRequest.mergeable}`);\n```\n\n### List PR Files\n\n```typescript\nconst { data: files } = await octokit.rest.pulls.listFiles({\n  owner,\n  repo,\n  pull_number: prNumber,\n});\n\nfor (const file of files) {\n  core.info(`${file.status}: ${file.filename}`);\n  // file.status: 'added' | 'removed' | 'modified' | 'renamed' | 'copied' | 'changed' | 'unchanged'\n}\n```\n\n### Create Review Comment\n\n```typescript\nawait octokit.rest.pulls.createReviewComment({\n  owner,\n  repo,\n  pull_number: prNumber,\n  body: 'Comment on specific line',\n  commit_id: github.context.sha,\n  path: 'src/index.ts',\n  line: 10,\n});\n```\n\n### Request Reviewers\n\n```typescript\nawait octokit.rest.pulls.requestReviewers({\n  owner,\n  repo,\n  pull_number: prNumber,\n  reviewers: ['username1', 'username2'],\n  team_reviewers: ['team-slug'],\n});\n```\n\n## Repository Operations\n\n### Get File Contents\n\n```typescript\nconst { data: file } = await octokit.rest.repos.getContent({\n  owner,\n  repo,\n  path: 'path/to/file.ts',\n  ref: 'main', // branch, tag, or commit SHA\n});\n\n// file.content is base64 encoded\nif ('content' in file) {\n  const content = Buffer.from(file.content, 'base64').toString('utf-8');\n}\n```\n\n### Create or Update File\n\n```typescript\n// Get existing file SHA (required for updates)\nlet existingSha: string | undefined;\ntry {\n  const { data: existing } = await octokit.rest.repos.getContent({\n    owner,\n    repo,\n    path: 'path/to/file.ts',\n  });\n  if ('sha' in existing) {\n    existingSha = existing.sha;\n  }\n} catch {\n  // File doesn't exist, will create new\n}\n\nawait octokit.rest.repos.createOrUpdateFileContents({\n  owner,\n  repo,\n  path: 'path/to/file.ts',\n  message: 'Commit message',\n  content: Buffer.from(newContent).toString('base64'),\n  sha: existingSha, // Required for updates, omit for new files\n  branch: 'main',\n});\n```\n\n### List Repository Topics\n\n```typescript\nconst { data: topics } = await octokit.rest.repos.getAllTopics({\n  owner,\n  repo,\n});\n```\n\n## Commits and Refs\n\n### Get Commit\n\n```typescript\nconst { data: commit } = await octokit.rest.repos.getCommit({\n  owner,\n  repo,\n  ref: github.context.sha,\n});\n\ncore.info(`Author: ${commit.commit.author?.name}`);\ncore.info(`Message: ${commit.commit.message}`);\n```\n\n### Compare Commits\n\n```typescript\nconst { data: comparison } = await octokit.rest.repos.compareCommits({\n  owner,\n  repo,\n  base: 'main',\n  head: github.context.sha,\n});\n\ncore.info(`${comparison.ahead_by} commits ahead`);\ncore.info(`${comparison.behind_by} commits behind`);\n```\n\n## GraphQL Queries\n\nFor complex queries, use GraphQL instead of REST:\n\n```typescript\ninterface QueryResult {\n  repository: {\n    pullRequest: {\n      title: string;\n      reviews: {\n        nodes: Array<{\n          state: string;\n          author: { login: string };\n        }>;\n      };\n    };\n  };\n}\n\nconst { repository } = await octokit.graphql<QueryResult>(\n  `\n  query($owner: String!, $repo: String!, $number: Int!) {\n    repository(owner: $owner, name: $repo) {\n      pullRequest(number: $number) {\n        title\n        reviews(last: 10) {\n          nodes {\n            state\n            author {\n              login\n            }\n          }\n        }\n      }\n    }\n  }\n`,\n  {\n    owner,\n    repo,\n    number: prNumber,\n  }\n);\n```\n\n## Pagination\n\n```typescript\n// Using paginate helper (recommended for large datasets)\nconst allIssues = await octokit.paginate(\n  octokit.rest.issues.listForRepo,\n  {\n    owner,\n    repo,\n    per_page: 100,\n  },\n  (response) => response.data // Optional mapper\n);\n\n// Manual pagination\nlet page = 1;\nconst allItems: Issue[] = [];\nwhile (true) {\n  const { data: items } = await octokit.rest.issues.listForRepo({\n    owner,\n    repo,\n    per_page: 100,\n    page,\n  });\n  if (items.length === 0) break;\n  allItems.push(...items);\n  page++;\n}\n```\n\n## Rate Limiting\n\n```typescript\n// Check rate limit\nconst { data: rateLimit } = await octokit.rest.rateLimit.get();\ncore.info(`Remaining: ${rateLimit.rate.remaining}/${rateLimit.rate.limit}`);\ncore.info(`Resets at: ${new Date(rateLimit.rate.reset * 1000)}`);\n\n// Handle rate limiting in requests\ntry {\n  await octokit.rest.issues.create({ ... });\n} catch (error) {\n  if (error instanceof RequestError && error.status === 403) {\n    if (error.response?.headers['x-ratelimit-remaining'] === '0') {\n      const resetTime = error.response?.headers['x-ratelimit-reset'];\n      core.setFailed(`Rate limited. Resets at ${new Date(Number(resetTime) * 1000)}`);\n    }\n  }\n}\n```\n",
        "plugins/github-actions-generator/skills/generate-action/references/package-template.md": "# Package.json Template\n\nGenerate `package.json` for a new GitHub Action.\n\n## Template\n\n```json\n{\n  \"name\": \"@{scope}/{action-name}\",\n  \"version\": \"0.0.0\",\n  \"private\": true,\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"scripts\": {\n    \"build\": \"bun build src/index.ts --outdir dist --target node\",\n    \"test\": \"bun test\",\n    \"lint\": \"biome check .\",\n    \"format\": \"biome format --write .\"\n  },\n  \"dependencies\": {\n    \"@actions/core\": \"catalog:\",\n    \"@actions/github\": \"catalog:\",\n    \"@octokit/rest\": \"catalog:\"\n  },\n  \"devDependencies\": {\n    \"@biomejs/biome\": \"catalog:\",\n    \"@types/bun\": \"catalog:\"\n  }\n}\n```\n\n## Variables\n\n| Variable        | Source                                                  | Example                     |\n| --------------- | ------------------------------------------------------- | --------------------------- |\n| `{scope}`       | Organization scope from root package.json or user input | `birdcar`, `workos`         |\n| `{action-name}` | Kebab-case action name from user input                  | `add-label`, `create-issue` |\n\n## Determining Scope\n\n1. Check root `package.json` for existing package names with scopes\n2. If multiple scopes exist, ask user which to use\n3. If no scope pattern, ask user for preferred scope\n\n## Adding Dependencies\n\nWhen user needs additional dependencies:\n\n**Global (Catalog)**:\n\n```json\n{\n  \"dependencies\": {\n    \"new-package\": \"catalog:\"\n  }\n}\n```\n\nAlso add to root package.json catalog section.\n\n**Local (Pinned)**:\n\n```json\n{\n  \"dependencies\": {\n    \"new-package\": \"^1.2.3\"\n  }\n}\n```\n\n## Notes\n\n- Version starts at `0.0.0` - will be set properly on first release\n- `private: true` prevents accidental npm publish\n- Build target is `node` for GitHub Actions runtime\n- All shared dependencies use `catalog:` protocol\n",
        "plugins/github-actions-generator/skills/generate-action/references/readme-template.md": "# README Template\n\nTemplate for generating README.md files for GitHub Actions.\n\n## Template\n\n````markdown\n# {Action Name}\n\n{Description from action.yml}\n\n## Usage\n\n```yaml\n- uses: {owner}/{repo}/{action-path}@v{version}\n  with:\n    # Required inputs\n    {input-name}: {example-value}\n    # Optional inputs\n    {optional-input}: {example-value} # default: {default}\n```\n\n## Inputs\n\n| Name           | Description   | Required | Default       |\n| -------------- | ------------- | -------- | ------------- |\n| `{input-name}` | {description} | {yes/no} | {default/N/A} |\n\n## Outputs\n\n| Name            | Description   |\n| --------------- | ------------- |\n| `{output-name}` | {description} |\n\n## Example Workflow\n\n```yaml\nname: Example using {Action Name}\n\non:\n  pull_request:\n    types: [opened, synchronize]\n\njobs:\n  example:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - uses: {owner}/{repo}/{action-path}@v{version}\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          {other-inputs}\n```\n\n## Development\n\n```bash\n# Install dependencies\nbun install\n\n# Run tests\nbun test\n\n# Build\nbun run build\n\n# Lint\nbun run lint\n```\n\n## License\n\n{License from root repo or MIT}\n````\n\n## Template Variables\n\n| Variable        | Source                         | Example                           |\n| --------------- | ------------------------------ | --------------------------------- |\n| `{Action Name}` | action.yml `name` field        | `Add Label`, `Create Issue`       |\n| `{Description}` | action.yml `description` field | `Automatically add labels to PRs` |\n| `{owner}`       | Git remote or user input       | `birdcar`, `workos`               |\n| `{repo}`        | Git remote or user input       | `actions`, `se-tools`             |\n| `{action-path}` | Relative path in monorepo      | `packages/add-label`              |\n| `{version}`     | Latest git tag or user input   | `1.0.0`                           |\n| `{input-name}`  | From action.yml inputs         | `label-name`, `github-token`      |\n| `{output-name}` | From action.yml outputs        | `issue-number`, `result`          |\n\n## Version Detection\n\nTo determine the version for README examples:\n\n1. **Check git tags**:\n\n   ```bash\n   git describe --tags --abbrev=0\n   ```\n\n2. **For monorepos with prefixed tags**:\n\n   ```bash\n   git tag --list '{action-name}-v*' --sort=-version:refname | head -1\n   ```\n\n3. **If no tags exist**:\n   - Ask user for intended first version\n   - Suggest `v1.0.0` as starting point\n\n4. **Never use**:\n   - `@latest` (doesn't exist in GitHub Actions)\n   - `@main` or `@master` (unstable)\n\n## Generating Inputs Table\n\nRead from action.yml and format:\n\n```yaml\n# action.yml\ninputs:\n  github-token:\n    description: 'GitHub token for API access'\n    required: false\n    default: ${{ github.token }}\n  label-name:\n    description: 'Name of the label to add'\n    required: true\n```\n\nBecomes:\n\n| Name           | Description                 | Required | Default               |\n| -------------- | --------------------------- | -------- | --------------------- |\n| `github-token` | GitHub token for API access | No       | `${{ github.token }}` |\n| `label-name`   | Name of the label to add    | Yes      | N/A                   |\n\n## Generating Outputs Table\n\nRead from action.yml:\n\n```yaml\n# action.yml\noutputs:\n  added:\n    description: 'Whether the label was added'\n  label-url:\n    description: 'URL of the label in the repository'\n```\n\nBecomes:\n\n| Name        | Description                        |\n| ----------- | ---------------------------------- |\n| `added`     | Whether the label was added        |\n| `label-url` | URL of the label in the repository |\n\n## License Detection\n\nCheck for license in order:\n\n1. Root repository LICENSE file\n2. Root package.json `license` field\n3. Default to MIT if not found\n",
        "plugins/github-actions-generator/skills/generate-action/references/release-workflow-template.md": "# Release Workflow Template\n\nTemplate for automated release workflows for GitHub Actions in a monorepo.\n\n## Template\n\n```yaml\nname: Release {action-name}\n\non:\n  release:\n    types: [published]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    if: startsWith(github.event.release.tag_name, '{action-name}-v')\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n\n      - name: Install and build\n        run: |\n          bun install\n          bun run build\n        working-directory: { action-path }\n\n      - name: Update major version tag\n        uses: actions/publish-action@v0.2.2\n        with:\n          source-tag: ${{ github.event.release.tag_name }}\n```\n\n## Template Variables\n\n| Variable        | Source                          | Example              |\n| --------------- | ------------------------------- | -------------------- |\n| `{action-name}` | Kebab-case action name          | `add-label`          |\n| `{action-path}` | Relative path to action package | `packages/add-label` |\n\n## Tagging Convention for Monorepos\n\nFor monorepos with multiple actions, use prefixed tags:\n\n| Tag Type | Format                   | Example            |\n| -------- | ------------------------ | ------------------ |\n| Full     | `{action-name}-v{x.y.z}` | `add-label-v1.2.0` |\n| Major    | `{action-name}-v{x}`     | `add-label-v1`     |\n\nThe workflow's `if` condition filters releases to only run for the specific action:\n\n```yaml\nif: startsWith(github.event.release.tag_name, '{action-name}-v')\n```\n\n## Manual Release Process\n\nIf not using automated releases, follow these steps:\n\n```bash\n# 1. Update version in package.json\ncd {action-path}\nbun pkg set version=1.2.0\n\n# 2. Build the action\nbun run build\n\n# 3. Commit the changes (including dist folder)\ngit add .\ngit commit -m \"release: {action-name} v1.2.0\"\n\n# 4. Create full version tag\ngit tag {action-name}-v1.2.0\n\n# 5. Update major version tag (force push to move the tag)\ngit tag -f {action-name}-v1\n\n# 6. Push everything\ngit push origin main\ngit push origin {action-name}-v1.2.0\ngit push origin -f {action-name}-v1\n\n# 7. Create GitHub release\ngh release create {action-name}-v1.2.0 \\\n  --title \"{Action Name} v1.2.0\" \\\n  --generate-notes\n```\n\n## Alternative: Single Release Workflow for All Actions\n\nFor repos that prefer one workflow:\n\n```yaml\nname: Release Action\n\non:\n  release:\n    types: [published]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Parse release tag\n        id: parse\n        run: |\n          TAG=\"${{ github.event.release.tag_name }}\"\n          # Extract action name: \"add-label-v1.2.0\" -> \"add-label\"\n          ACTION_NAME=$(echo \"$TAG\" | sed 's/-v[0-9].*//')\n          echo \"action_name=$ACTION_NAME\" >> $GITHUB_OUTPUT\n          echo \"action_path=packages/$ACTION_NAME\" >> $GITHUB_OUTPUT\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n\n      - name: Install and build\n        run: |\n          bun install\n          bun run build\n        working-directory: ${{ steps.parse.outputs.action_path }}\n\n      - name: Update major version tag\n        uses: actions/publish-action@v0.2.2\n        with:\n          source-tag: ${{ github.event.release.tag_name }}\n```\n\n## Major Version Tag Updates\n\nThe `actions/publish-action` handles updating the major version tag:\n\n- From `add-label-v1.2.0`, it updates `add-label-v1` to point to the same commit\n- Users referencing `@add-label-v1` automatically get the latest patch\n\n## Permissions Required\n\nThe release workflow needs these permissions:\n\n```yaml\npermissions:\n  contents: write # To push tags\n```\n\nOr ensure the `GITHUB_TOKEN` has write access to the repository.\n\n## Pre-Release vs Release\n\nFor pre-releases (alpha, beta, rc):\n\n```yaml\non:\n  release:\n    types: [published]\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    # Skip major tag update for pre-releases\n    if: |\n      startsWith(github.event.release.tag_name, '{action-name}-v') &&\n      !github.event.release.prerelease\n```\n\n## Verifying Release\n\nAfter releasing, verify:\n\n1. **Tag exists**: `git tag -l '{action-name}-v*'`\n2. **Major tag updated**: `git rev-parse {action-name}-v1` matches full tag\n3. **Release visible**: Check GitHub Releases page\n4. **Action usable**: Test in another repo with the new version\n",
        "plugins/github-actions-generator/skills/generate-action/references/testing-patterns.md": "# Testing Patterns\n\nUnit testing patterns for GitHub Actions using bun:test.\n\n## Basic Test Structure\n\n```typescript\nimport { describe, it, expect, mock, beforeEach, afterEach, spyOn } from 'bun:test';\n\ndescribe('action', () => {\n  beforeEach(() => {\n    // Reset mocks before each test\n  });\n\n  afterEach(() => {\n    // Cleanup after each test\n  });\n\n  it('should succeed with valid inputs', async () => {\n    // Arrange - set up test data and mocks\n    // Act - call the function under test\n    // Assert - verify the results\n  });\n});\n```\n\n## Mocking @actions/core\n\n```typescript\nimport { mock, beforeEach } from 'bun:test';\n\n// Create mock functions\nconst mockGetInput = mock((name: string, options?: { required?: boolean }) => {\n  const inputs: Record<string, string> = {\n    'github-token': 'fake-token',\n    'label-name': 'bug',\n  };\n  const value = inputs[name] ?? '';\n  if (options?.required && !value) {\n    throw new Error(`Input required and not supplied: ${name}`);\n  }\n  return value;\n});\n\nconst mockSetOutput = mock(() => {});\nconst mockSetFailed = mock(() => {});\nconst mockInfo = mock(() => {});\nconst mockWarning = mock(() => {});\nconst mockError = mock(() => {});\nconst mockDebug = mock(() => {});\n\n// Mock the module\nmock.module('@actions/core', () => ({\n  getInput: mockGetInput,\n  getBooleanInput: mock((name: string) => mockGetInput(name) === 'true'),\n  getMultilineInput: mock((name: string) => mockGetInput(name).split('\\n')),\n  setOutput: mockSetOutput,\n  setFailed: mockSetFailed,\n  info: mockInfo,\n  warning: mockWarning,\n  error: mockError,\n  debug: mockDebug,\n  startGroup: mock(() => {}),\n  endGroup: mock(() => {}),\n  saveState: mock(() => {}),\n  getState: mock(() => ''),\n  exportVariable: mock(() => {}),\n  setSecret: mock(() => {}),\n}));\n\n// Reset mocks between tests\nbeforeEach(() => {\n  mockGetInput.mockClear();\n  mockSetOutput.mockClear();\n  mockSetFailed.mockClear();\n  mockInfo.mockClear();\n});\n```\n\n## Mocking @actions/github\n\n```typescript\nimport { mock } from 'bun:test';\n\n// Create mock Octokit client\nconst mockOctokit = {\n  rest: {\n    issues: {\n      create: mock(() =>\n        Promise.resolve({ data: { number: 1, html_url: 'https://github.com/...' } })\n      ),\n      createComment: mock(() => Promise.resolve({ data: { id: 123 } })),\n      addLabels: mock(() => Promise.resolve({ data: [] })),\n      listForRepo: mock(() => Promise.resolve({ data: [] })),\n    },\n    pulls: {\n      get: mock(() => Promise.resolve({ data: { title: 'Test PR', mergeable: true } })),\n      listFiles: mock(() => Promise.resolve({ data: [] })),\n      requestReviewers: mock(() => Promise.resolve({ data: {} })),\n    },\n    repos: {\n      getContent: mock(() => Promise.resolve({ data: { content: '', sha: 'abc123' } })),\n      createOrUpdateFileContents: mock(() => Promise.resolve({ data: {} })),\n    },\n  },\n  graphql: mock(() => Promise.resolve({})),\n  paginate: mock(() => Promise.resolve([])),\n};\n\n// Mock context\nconst mockContext = {\n  repo: { owner: 'test-owner', repo: 'test-repo' },\n  eventName: 'pull_request',\n  sha: 'abc123def456',\n  ref: 'refs/heads/main',\n  payload: {\n    pull_request: {\n      number: 123,\n      title: 'Test PR',\n      body: 'Test body',\n      head: { ref: 'feature-branch' },\n      base: { ref: 'main' },\n    },\n    issue: null,\n    action: 'opened',\n  },\n};\n\n// Mock the module\nmock.module('@actions/github', () => ({\n  context: mockContext,\n  getOctokit: mock(() => mockOctokit),\n}));\n\n// Helper to change context for specific tests\nfunction setContext(overrides: Partial<typeof mockContext>) {\n  Object.assign(mockContext, overrides);\n}\n\nfunction setPayload(overrides: Partial<typeof mockContext.payload>) {\n  Object.assign(mockContext.payload, overrides);\n}\n```\n\n## Test Case Patterns\n\n### Happy Path\n\n```typescript\nit('should create issue when triggered', async () => {\n  // Arrange\n  mockGetInput.mockImplementation((name) => {\n    if (name === 'github-token') return 'fake-token';\n    if (name === 'title') return 'New Issue';\n    return '';\n  });\n\n  // Act\n  await run();\n\n  // Assert\n  expect(mockOctokit.rest.issues.create).toHaveBeenCalledWith(\n    expect.objectContaining({\n      owner: 'test-owner',\n      repo: 'test-repo',\n      title: 'New Issue',\n    })\n  );\n  expect(mockSetOutput).toHaveBeenCalledWith('issue-number', 1);\n  expect(mockSetFailed).not.toHaveBeenCalled();\n});\n```\n\n### Edge Cases\n\n```typescript\nit('should handle empty optional input', async () => {\n  mockGetInput.mockImplementation((name) => {\n    if (name === 'github-token') return 'fake-token';\n    if (name === 'optional-input') return ''; // Empty\n    return 'value';\n  });\n\n  await run();\n\n  // Verify default behavior is used\n  expect(mockOctokit.rest.issues.create).toHaveBeenCalledWith(\n    expect.objectContaining({\n      body: 'Default body', // Should use default\n    })\n  );\n});\n\nit('should handle missing PR context', async () => {\n  // Set up context without PR\n  setPayload({ pull_request: undefined, issue: { number: 456 } });\n  setContext({ eventName: 'issues' });\n\n  await run();\n\n  // Verify appropriate behavior\n  expect(mockSetFailed).toHaveBeenCalledWith(expect.stringContaining('pull_request'));\n});\n\nit('should handle pagination correctly', async () => {\n  // Return multiple pages worth of data\n  mockOctokit.paginate.mockResolvedValue([{ number: 1 }, { number: 2 }, { number: 3 }]);\n\n  await run();\n\n  expect(mockOctokit.paginate).toHaveBeenCalled();\n});\n```\n\n### Error Cases\n\n```typescript\nit('should fail gracefully on API error', async () => {\n  mockOctokit.rest.issues.create.mockRejectedValue(new Error('API rate limited'));\n\n  await run();\n\n  expect(mockSetFailed).toHaveBeenCalledWith('API rate limited');\n});\n\nit('should fail on missing required input', async () => {\n  mockGetInput.mockImplementation((name, options) => {\n    if (options?.required) {\n      throw new Error(`Input required and not supplied: ${name}`);\n    }\n    return '';\n  });\n\n  await run();\n\n  expect(mockSetFailed).toHaveBeenCalled();\n});\n\nit('should handle 404 errors appropriately', async () => {\n  const notFoundError = new Error('Not Found');\n  (notFoundError as any).status = 404;\n  mockOctokit.rest.repos.getContent.mockRejectedValue(notFoundError);\n\n  await run();\n\n  expect(mockSetFailed).toHaveBeenCalledWith(expect.stringContaining('not found'));\n});\n\nit('should handle rate limiting', async () => {\n  const rateLimitError = new Error('Rate limited');\n  (rateLimitError as any).status = 403;\n  mockOctokit.rest.issues.create.mockRejectedValue(rateLimitError);\n\n  await run();\n\n  expect(mockSetFailed).toHaveBeenCalledWith(expect.stringContaining('Rate limited'));\n});\n```\n\n## Testing Async Operations\n\n```typescript\nit('should process items in parallel', async () => {\n  const items = [1, 2, 3];\n\n  await run();\n\n  // Verify all operations were called\n  expect(mockOctokit.rest.issues.addLabels).toHaveBeenCalledTimes(items.length);\n});\n\nit('should handle concurrent API calls', async () => {\n  // Set up multiple API calls\n  mockOctokit.rest.issues.listForRepo.mockResolvedValue({ data: [{ number: 1 }] });\n  mockOctokit.rest.pulls.list.mockResolvedValue({ data: [{ number: 2 }] });\n\n  await run();\n\n  // Both should be called\n  expect(mockOctokit.rest.issues.listForRepo).toHaveBeenCalled();\n  expect(mockOctokit.rest.pulls.list).toHaveBeenCalled();\n});\n```\n\n## Spying on Functions\n\n```typescript\nimport { spyOn } from 'bun:test';\n\nit('should log progress', async () => {\n  const consoleSpy = spyOn(console, 'log');\n\n  await run();\n\n  expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Processing'));\n\n  consoleSpy.mockRestore();\n});\n```\n\n## Testing with Different Event Types\n\n```typescript\ndescribe('on pull_request event', () => {\n  beforeEach(() => {\n    setContext({ eventName: 'pull_request' });\n    setPayload({ pull_request: { number: 123 } });\n  });\n\n  it('should process PR', async () => {\n    await run();\n    expect(mockOctokit.rest.pulls.get).toHaveBeenCalled();\n  });\n});\n\ndescribe('on issues event', () => {\n  beforeEach(() => {\n    setContext({ eventName: 'issues' });\n    setPayload({ issue: { number: 456 }, pull_request: undefined });\n  });\n\n  it('should process issue', async () => {\n    await run();\n    expect(mockOctokit.rest.issues.get).toHaveBeenCalled();\n  });\n});\n```\n\n## Test File Organization\n\n```\nsrc/\n├── index.ts              # Main action entry point\n├── index.test.ts         # Tests for main entry\n├── utils.ts              # Utility functions\n├── utils.test.ts         # Tests for utilities\n└── __mocks__/            # Optional: shared mock factories\n    ├── core.ts\n    └── github.ts\n```\n",
        "plugins/github-actions-generator/skills/generate-action/references/tsconfig-template.md": "# tsconfig.json Template\n\nGenerate `tsconfig.json` for a GitHub Action package.\n\n## Template (Extending Root)\n\nWhen the monorepo has a root tsconfig.json:\n\n```json\n{\n  \"extends\": \"../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\",\n    \"declaration\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Template (Standalone)\n\nWhen no root tsconfig exists or extending isn't appropriate:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"outDir\": \"dist\",\n    \"rootDir\": \"src\",\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"noEmit\": false\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n```\n\n## Determining Which to Use\n\n1. Check if root `tsconfig.json` exists\n2. Check if other actions in the monorepo extend it\n3. If yes to both, use extending template\n4. If no root config or other packages don't extend, use standalone\n\n## Adjusting Extends Path\n\nThe `extends` path depends on action location:\n\n| Action Location            | Extends Path             |\n| -------------------------- | ------------------------ |\n| `packages/action-name/`    | `../../tsconfig.json`    |\n| `actions/action-name/`     | `../../tsconfig.json`    |\n| `src/actions/action-name/` | `../../../tsconfig.json` |\n\n## Notes\n\n- `declaration: true` generates `.d.ts` files (useful for testing)\n- Target ES2022 for modern Node.js features\n- NodeNext module resolution works best with Bun\n- Always exclude `node_modules` and `dist`\n",
        "plugins/github-actions-generator/skills/generate-action/references/versioning-guide.md": "# Action Versioning Guide\n\nBest practices for versioning GitHub Actions.\n\n## Semantic Versioning\n\nActions follow semver (Semantic Versioning):\n\n| Type  | When to Use                                   | Example             |\n| ----- | --------------------------------------------- | ------------------- |\n| Major | Breaking changes to inputs, outputs, behavior | `v1` → `v2`         |\n| Minor | New features, backward compatible             | `v1.0` → `v1.1`     |\n| Patch | Bug fixes, no feature changes                 | `v1.0.0` → `v1.0.1` |\n\n## Tag Strategy\n\n### Full Version Tags\n\nAlways create full semver tags:\n\n- `v1.0.0`, `v1.0.1`, `v1.1.0`, `v2.0.0`\n\nThese are immutable - once created, they should never change.\n\n### Major Version Tags (Recommended)\n\nMaintain floating major version tags for user convenience:\n\n- `v1` points to latest `v1.x.x`\n- `v2` points to latest `v2.x.x`\n\nUsers reference `@v1` to automatically get patches and minor updates.\n\n### For Monorepos\n\nPrefix tags with action name to avoid collisions:\n\n| Tag Type | Format                   | Example            |\n| -------- | ------------------------ | ------------------ |\n| Full     | `{action-name}-v{x.y.z}` | `add-label-v1.2.0` |\n| Major    | `{action-name}-v{x}`     | `add-label-v1`     |\n\n## When to Bump Versions\n\n### Major Version (Breaking)\n\nBump major version when you:\n\n- Remove an input\n- Remove an output\n- Change input/output types or semantics\n- Change default behavior in incompatible ways\n- Upgrade Node.js runtime requirement (e.g., node16 → node20)\n- Change required inputs to have different names\n\n**Example**: Renaming `token` to `github-token` is a breaking change.\n\n### Minor Version (Features)\n\nBump minor version when you:\n\n- Add new optional inputs\n- Add new outputs\n- Add new functionality with backward compatibility\n- Deprecate (but don't remove) inputs/outputs\n\n**Example**: Adding a `dry-run` input that defaults to `false`.\n\n### Patch Version (Fixes)\n\nBump patch version when you:\n\n- Fix bugs without changing API\n- Update documentation\n- Update dependencies (non-breaking)\n- Improve performance\n- Fix typos in error messages\n\n**Example**: Fixing a bug where the action failed on empty input.\n\n## README Version Examples\n\n### Good\n\nShow real, stable version tags:\n\n```yaml\n- uses: owner/repo/action@v1.2.0\n# or\n- uses: owner/repo/action@v1\n```\n\n### Bad\n\nNever use these in documentation:\n\n```yaml\n# DON'T DO THIS\n- uses: owner/repo/action@latest # Doesn't exist\n- uses: owner/repo/action@main # Unstable\n- uses: owner/repo/action@master # Unstable\n- uses: owner/repo/action@HEAD # Unpredictable\n```\n\n## Version in package.json\n\nKeep `package.json` version in sync with tags:\n\n```json\n{\n  \"name\": \"@scope/add-label\",\n  \"version\": \"1.2.0\"\n}\n```\n\nThis isn't strictly required (users reference tags, not npm), but helps with:\n\n- Tracking which version is deployed\n- Automated release workflows\n- Changelog generation\n\n## First Release Checklist\n\nFor a new action's first release:\n\n1. **Choose version**: Start with `v1.0.0` (stable) or `v0.1.0` (experimental)\n2. **Update package.json**: Set matching version\n3. **Build**: Run `bun run build`\n4. **Commit**: `git commit -m \"release: add-label v1.0.0\"`\n5. **Tag**: `git tag add-label-v1.0.0`\n6. **Major tag**: `git tag add-label-v1`\n7. **Push**: `git push origin main --tags`\n8. **Create release**: Use GitHub UI or `gh release create`\n\n## Version Lifecycle\n\n```\nv0.x.x → Experimental (breaking changes expected)\nv1.0.0 → First stable release\nv1.0.1 → Patch (bug fix)\nv1.1.0 → Minor (new feature)\nv1.1.1 → Patch\nv2.0.0 → Major (breaking change)\n```\n\n## Deprecation Process\n\nWhen planning breaking changes:\n\n1. **Announce**: Add deprecation warnings in current version\n2. **Document**: Update README with migration guide\n3. **Wait**: Give users time to migrate (2+ weeks)\n4. **Release**: Publish new major version\n5. **Support**: Keep old major version for critical fixes\n\n## Commit Message Convention\n\nUse conventional commits for easy changelog generation:\n\n```\nfeat(add-label): add dry-run option\nfix(add-label): handle empty label list\ndocs(add-label): update usage examples\nchore(add-label): update dependencies\nBREAKING CHANGE: rename token input to github-token\n```\n",
        "plugins/octoflow/commands/commit.md": "---\nname: commit\ndescription: Create a git commit with a well-crafted message\nallowed-tools: [Bash, Read, Glob, Grep]\n---\n\nGenerate well-crafted commit messages and create Git commits following best practices.\n\n## Process\n\n1. Run `git status` to check for staged changes\n2. If no staged changes, ask user what to stage or offer to stage all modified files\n3. Run `git diff --cached` to analyze staged changes\n4. Run `git log --oneline -10` to understand the repository's commit message style\n5. Generate a commit message following the rules below\n6. Present the message to user for approval or editing\n7. Execute the commit with the approved message\n8. Show the commit result\n\n## The Seven Rules of Great Commits\n\n### 1. Separate Subject from Body with a Blank Line\n\n```\ntype(scope): subject line here\n\nBody starts after blank line. Explains the why, not the what.\n```\n\n### 2. Limit Subject to 50 Characters\n\n- 50 characters is the target for readability\n- 72 characters is the hard limit (GitHub truncates beyond this)\n- Forces concise, meaningful summaries\n\n### 3. Capitalize the Subject Line\n\n- Write `feat: Add user authentication` not `feat: add user authentication`\n\n### 4. Do Not End Subject with a Period\n\n- Periods waste space and are unnecessary for headlines\n- Write `fix: Resolve login timeout` not `fix: Resolve login timeout.`\n\n### 5. Use Imperative Mood in Subject\n\nWrite commands, not descriptions of what happened:\n\n- **Good**: `Add`, `Fix`, `Update`, `Remove`, `Refactor`\n- **Bad**: `Added`, `Fixed`, `Updated`, `Removed`, `Refactored`\n\n**Test**: \"If applied, this commit will _[your subject line]_\" should be grammatically correct.\n\n### 6. Wrap Body at 72 Characters\n\n- Manually wrap body text at 72 characters\n- Allows room for Git's indentation in various tools\n- Most editors can be configured to do this automatically\n\n### 7. Use Body to Explain What and Why, Not How\n\n- The code diff shows how\n- The body explains:\n  - Why was this change necessary?\n  - What problem does it solve?\n  - What side effects or consequences exist?\n\n## Commit Message Format\n\n```\ntype(scope): imperative subject under 50 chars\n\nOptional body wrapped at 72 characters. Focus on explaining\nWHY this change was made, not what was changed (the diff shows\nthat). Include context that future developers will need.\n\nOptional footers like:\nFixes #123\nBREAKING CHANGE: description of breaking change\n```\n\n## Commit Types\n\n| Type       | Use For                                       |\n| ---------- | --------------------------------------------- |\n| `feat`     | New feature visible to users                  |\n| `fix`      | Bug fix for existing functionality            |\n| `docs`     | Documentation only changes                    |\n| `style`    | Formatting, whitespace (no code logic change) |\n| `refactor` | Code restructuring without behavior change    |\n| `perf`     | Performance improvements                      |\n| `test`     | Adding or updating tests                      |\n| `build`    | Build system or external dependencies         |\n| `ci`       | CI/CD configuration changes                   |\n| `chore`    | Maintenance tasks (tooling, configs)          |\n| `revert`   | Reverting a previous commit                   |\n\n## Breaking Changes\n\nFor changes that break backward compatibility:\n\n```\nfeat!: Remove deprecated authentication method\n\nBREAKING CHANGE: The `legacyAuth()` function has been removed.\nMigrate to `newAuth()` before upgrading. See migration guide\nin docs/migration-v2.md.\n```\n\n## Examples\n\n### Good Commit Messages\n\n```\nfeat(auth): Add OAuth2 support for GitHub login\n\nEnables users to authenticate via GitHub OAuth2. This reduces\nfriction for developers who already have GitHub accounts.\n\nCloses #234\n```\n\n```\nfix: Prevent crash when config file is missing\n\nThe app crashed on first run because it expected a config file.\nNow creates a default config if none exists.\n```\n\n```\nrefactor: Extract validation logic into separate module\n\nValidation was duplicated across 4 controllers. Centralizing it\nreduces maintenance burden and ensures consistent behavior.\n```\n\n### Bad Commit Messages\n\n```\nfixed stuff                      # Too vague, not imperative\nUpdated the code.                # Says nothing useful\nfeat: added new feature.         # Not imperative, has period\nWIP                              # Meaningless\n```\n\n## Important Rules\n\n- Never commit without explicit user approval of the message\n- Never add a Co-Authored-By line unless the user explicitly requests it\n- Warn user if staging files that look like secrets (.env, credentials, tokens, keys, \\*.pem, id_rsa)\n- Match the existing commit style in the repository when possible\n- For multi-file changes, consider whether they should be separate commits\n- If the diff is large, summarize the key changes in the body\n\n## Edge Cases\n\n### Amending Commits\n\nOnly offer to amend if:\n\n- The previous commit was made in the current session\n- It hasn't been pushed to remote\n- User explicitly requests it\n\nOtherwise, create a new commit.\n\n### Empty Commits\n\nNever create empty commits unless explicitly requested for CI triggers.\n\n### Large Changesets\n\nIf staging many files, ask user if changes should be split into multiple focused commits.\n\n### Generated Files\n\nWarn if committing generated files (node_modules, dist/, build/, \\*.min.js) that are typically gitignored.\n",
        "plugins/octoflow/commands/pr.md": "---\nname: pr\ndescription: Create a GitHub pull request with a structured description\nallowed-tools: [Bash, Read, Glob, Grep]\n---\n\nCreate GitHub pull requests with structured descriptions.\n\n## Process\n\n1. Check current branch is not main/master - if it is, ask user to create a feature branch\n2. Run `git log main..HEAD --oneline` to see commits included in this PR\n3. Run `git diff main...HEAD --stat` to see file changes\n4. Analyze all changes and generate PR description:\n   - Summary (3-5 bullet points of what changed and why)\n   - Test plan (checklist of verification steps)\n5. Check if branch is pushed to remote, push if needed (with user confirmation)\n6. Create PR via `gh pr create` with the generated description\n7. Return the PR URL to the user\n\n## PR Template\n\n```markdown\n## Summary\n\n- {bullet point 1}\n- {bullet point 2}\n- {bullet point 3}\n\n## Test plan\n\n- [ ] {verification step 1}\n- [ ] {verification step 2}\n```\n\n## Important Rules\n\n- Never create PR without user approval of the description\n- Always push branch before creating PR\n- Use HEREDOC syntax for PR body to preserve formatting:\n\n```bash\ngh pr create --title \"the pr title\" --body \"$(cat <<'EOF'\n## Summary\n- Change 1\n- Change 2\n\n## Test plan\n- [ ] Verify change 1\n- [ ] Verify change 2\nEOF\n)\"\n```\n\n- Return the PR URL when complete so user can review\n- If `gh` CLI is not installed, inform user how to install it\n- If the base branch is not main/master, ask user which branch to target\n",
        "plugins/plugin-tools/commands/analyze-plugins.md": "---\nname: analyze-plugins\ndescription: Analyze plugin repository to identify improvements and suggest enhancements\nallowed-tools: [Bash, Read, Glob, Grep]\n---\n\nAnalyze this plugin repository to identify improvements, discover patterns, and suggest enhancements.\n\n## Process\n\n1. **Scan Repository Structure**\n   - Read all plugin directories under `plugins/`\n   - Parse each `plugin.json` for metadata\n   - Collect all skill INSTRUCTIONS.md and command files\n\n2. **Analyze Plugin Quality**\n   For each plugin, evaluate:\n   - Completeness: Does it have all required files? (package.json, tsconfig.json, plugin.json, commands/ or skills/)\n   - Consistency: Do naming conventions match? (kebab-case everywhere)\n   - Documentation: Are instructions comprehensive?\n   - Structure: Does it follow established patterns?\n\n3. **Identify Improvement Opportunities**\n   Look for:\n   - Missing or sparse documentation\n   - Inconsistent patterns between plugins\n   - Components that could be more robust\n   - Common patterns that could be extracted\n   - Error handling gaps in instructions\n\n4. **Check Against Best Practices**\n   Compare components against:\n   - Clear trigger/description documentation\n   - Step-by-step process instructions\n   - Important rules section\n   - Example usage\n   - Edge case handling\n\n5. **Generate Report**\n   Output a structured analysis with:\n   - Summary of plugins found\n   - Quality scores for each plugin\n   - Specific improvement suggestions\n   - Priority ranking of fixes\n\n## Arguments\n\n| Argument | Required | Description                                                                 |\n| -------- | -------- | --------------------------------------------------------------------------- |\n| focus    | No       | Focus area: `structure`, `documentation`, `consistency`, or `{plugin-name}` |\n\n## Focus Areas\n\n- `/analyze-plugins structure` - Focus on directory and file organization\n- `/analyze-plugins documentation` - Focus on instruction quality\n- `/analyze-plugins consistency` - Focus on pattern consistency across plugins\n- `/analyze-plugins {plugin-name}` - Deep dive into a specific plugin\n\n## Output Format\n\n```markdown\n## Plugin Analysis Report\n\n### Summary\n\n- Total plugins: N\n- Total commands: N\n- Total skills: N\n- Overall health: Good/Needs Attention/Critical\n\n### Plugin Details\n\n#### {plugin-name}\n\n- **Status**: Complete/Incomplete\n- **Components**: command1, command2, skill1\n- **Issues**:\n  - Issue 1\n  - Issue 2\n- **Suggestions**:\n  - Suggestion 1\n  - Suggestion 2\n\n### Priority Improvements\n\n1. [High] Description of critical improvement\n2. [Medium] Description of moderate improvement\n3. [Low] Description of minor improvement\n```\n\n## Important Rules\n\n- Never modify files during analysis - this is read-only\n- Be specific in suggestions - point to exact files and lines\n- Prioritize improvements by impact\n- Compare against existing patterns in the repository, not external standards\n- If a plugin is well-structured, say so - don't invent problems\n",
        "plugins/plugin-tools/commands/improve-skill.md": "---\nname: improve-skill\ndescription: Iteratively improve an existing skill or command based on feedback\nallowed-tools: [Bash, Read, Write, Edit, Glob, Grep]\n---\n\nIteratively improve an existing skill or command based on feedback, corrections, or identified issues.\n\n## Process\n\n1. **Locate the Component**\n   - Search `plugins/*/commands/` and `plugins/*/skills/` for the specified name\n   - Read the current instruction file\n   - Understand its purpose and current implementation\n\n2. **Gather Context**\n   If feedback is provided, analyze it. Otherwise, prompt for:\n   - What's not working as expected?\n   - What behavior should change?\n   - Any specific scenarios that fail?\n\n3. **Analyze Current Instructions**\n   Evaluate the existing component for:\n   - Clarity of description/trigger documentation\n   - Completeness of process steps\n   - Coverage of edge cases\n   - Robustness of rules\n   - Quality of examples\n\n4. **Propose Improvements**\n   Based on feedback and analysis, suggest specific changes:\n   - Additional process steps\n   - New rules to handle edge cases\n   - Better examples\n   - Clarified language\n   - Error handling additions\n\n5. **Present Changes**\n   Show a diff-style view of proposed changes:\n\n   ```\n   ## Proposed Changes to {component-name}\n\n   ### Addition: New Rule\n   + - Handle edge case X by doing Y\n\n   ### Modification: Process Step 3\n   - 3. Old step description\n   + 3. Improved step description with more detail\n\n   ### Addition: Example\n   + ## Example: Edge Case Handling\n   + User: `/component-name --edge-case`\n   + Result: Handles it gracefully\n   ```\n\n6. **Apply or Iterate**\n   - If user approves, apply the changes\n   - If user has more feedback, incorporate and re-propose\n   - Track what was changed for potential rollback\n\n## Arguments\n\n| Argument | Required | Description                             |\n| -------- | -------- | --------------------------------------- |\n| name     | Yes      | Name of the skill or command to improve |\n| feedback | No       | Specific feedback or issues to address  |\n\n## Component Type Assessment\n\nBefore improving, verify the component is the right type:\n\n**Commands** (`commands/*.md`) - Use when:\n\n- User should invoke explicitly via `/command-name`\n- Needs to appear in autocomplete\n- Discrete, user-initiated action (commit, build, test, deploy)\n- Format: YAML frontmatter with `name`, `description`, `allowed-tools`\n\n**Skills** (`skills/*/INSTRUCTIONS.md`) - Use when:\n\n- Agent should trigger proactively based on context\n- No explicit user invocation needed\n- Background behavior or analysis\n- Format: Markdown with `## When to Use` description\n\nIf a skill should be a command (user-invoked action), recommend converting it.\n\n## Improvement Categories\n\n### Clarity Improvements\n\n- Ambiguous language made specific\n- Complex steps broken down\n- Jargon explained or removed\n\n### Robustness Improvements\n\n- Edge cases handled\n- Error scenarios addressed\n- Fallback behaviors defined\n\n### Completeness Improvements\n\n- Missing steps added\n- Examples included\n- Rules expanded\n\n### Consistency Improvements\n\n- Alignment with other components in the repo\n- Standardized formatting\n- Consistent terminology\n\n## Example\n\nUser: `/improve-skill commit`\n\nAnalysis reveals:\n\n- Missing guidance on merge commits\n- No example for breaking changes\n- Unclear on when to use which commit type\n\nProposed additions:\n\n```markdown\n### Merge Commits\n\nWhen committing a merge, use the format:\n`merge: integrate {branch} into {target}`\n\n### Breaking Changes\n\nFor breaking changes, use:\n`feat!: description` or `fix!: description`\nInclude a BREAKING CHANGE footer explaining the impact.\n```\n\n## Important Rules\n\n- Always show proposed changes before applying\n- Preserve the component's original intent - don't change what it does, just how well it does it\n- Make incremental improvements - don't rewrite entire components\n- Reference specific feedback when explaining changes\n- After applying changes, run `bun run typecheck` and `bun run build` to verify\n"
      },
      "plugins": [
        {
          "name": "creator",
          "source": "./plugins/creator",
          "description": "Commands for generating new Claude Code components from natural language",
          "version": "0.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add birdcar/claude-plugins",
            "/plugin install creator@birdcar-plugins"
          ]
        },
        {
          "name": "dev-commands",
          "source": "./plugins/dev-commands",
          "description": "Slash commands for common development workflows",
          "version": "0.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add birdcar/claude-plugins",
            "/plugin install dev-commands@birdcar-plugins"
          ]
        },
        {
          "name": "github-actions-generator",
          "source": "./plugins/github-actions-generator",
          "description": "Generate TypeScript GitHub Actions with Bun workspaces",
          "version": "0.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add birdcar/claude-plugins",
            "/plugin install github-actions-generator@birdcar-plugins"
          ]
        },
        {
          "name": "octoflow",
          "source": "./plugins/octoflow",
          "description": "Core Git workflow commands for commits and pull requests",
          "version": "0.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add birdcar/claude-plugins",
            "/plugin install octoflow@birdcar-plugins"
          ]
        },
        {
          "name": "plugin-tools",
          "source": "./plugins/plugin-tools",
          "description": "Commands for analyzing and enhancing Claude Code plugins",
          "version": "0.1.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add birdcar/claude-plugins",
            "/plugin install plugin-tools@birdcar-plugins"
          ]
        }
      ]
    }
  ]
}