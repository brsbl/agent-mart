{
  "author": {
    "id": "langroid",
    "display_name": "Langroid",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/130325191?v=4",
    "url": "https://github.com/langroid",
    "bio": "Harness LLMs with Multi-Agent Programming",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 2,
      "total_stars": 3866,
      "total_forks": 353
    }
  },
  "marketplaces": [
    {
      "name": "langroid",
      "version": "1.0.0",
      "description": "Langroid multi-agent framework patterns and best practices",
      "owner_info": {
        "name": "Langroid"
      },
      "keywords": [],
      "repo_full_name": "langroid/langroid",
      "repo_url": "https://github.com/langroid/langroid",
      "repo_description": "Harness LLMs with Multi-Agent Programming",
      "homepage": "https://langroid.github.io/langroid/",
      "signals": {
        "stars": 3866,
        "forks": 353,
        "pushed_at": "2026-01-29T21:15:37Z",
        "created_at": "2023-04-16T20:47:28Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 266
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/langroid",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/langroid/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/langroid/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 168
        },
        {
          "path": "plugins/langroid/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/langroid/skills/add-pattern",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/langroid/skills/add-pattern/SKILL.md",
          "type": "blob",
          "size": 1031
        },
        {
          "path": "plugins/langroid/skills/patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/langroid/skills/patterns/SKILL.md",
          "type": "blob",
          "size": 4680
        },
        {
          "path": "plugins/langroid/skills/patterns/agent-handler-validation-with-state.md",
          "type": "blob",
          "size": 5769
        },
        {
          "path": "plugins/langroid/skills/patterns/agent-tool-handler-with-state.md",
          "type": "blob",
          "size": 5412
        },
        {
          "path": "plugins/langroid/skills/patterns/done-sequences-specific-tool.md",
          "type": "blob",
          "size": 3962
        },
        {
          "path": "plugins/langroid/skills/patterns/mcp-tool-integration.md",
          "type": "blob",
          "size": 4632
        },
        {
          "path": "plugins/langroid/skills/patterns/quiet-mode.md",
          "type": "blob",
          "size": 2151
        },
        {
          "path": "plugins/langroid/skills/patterns/run-batch-tasks.md",
          "type": "blob",
          "size": 6285
        },
        {
          "path": "plugins/langroid/skills/patterns/task-return-tool.md",
          "type": "blob",
          "size": 6168
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"langroid\",\n  \"version\": \"1.0.0\",\n  \"owner\": {\n    \"name\": \"Langroid\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"langroid\",\n      \"source\": \"./plugins/langroid\",\n      \"description\": \"Langroid multi-agent framework patterns and best practices\"\n    }\n  ]\n}\n",
        "plugins/langroid/.claude-plugin/plugin.json": "{\n  \"name\": \"langroid\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Design patterns for the Langroid multi-agent LLM framework\",\n  \"author\": {\n    \"name\": \"Langroid\"\n  }\n}\n",
        "plugins/langroid/skills/add-pattern/SKILL.md": "---\nname: add-pattern\ndescription: Use this skill when you learn one or more design pattern(s) in the\n  Langroid (multi) agent framework, and want to make a note for future reference\n  for yourself. Use this either autonomously, or when asked by the user to record \n  a new pattern.\n---\n\n# add-pattern\n\n## Instructions\n\nWhen you learn a new Langroid design pattern, do the following:\n\n1. Add an entry in the sibling `patterns/SKILL.md` file in the appropriate category\n   section, containing a DESCRIPTION of the goal of the pattern (i.e. what it enables\n   you to implement), accompanied by a `- Reference:` pointer to a markdown DOCUMENT\n   in the `patterns/` directory.\n\n   IMPORTANT - The DESCRIPTION should be clear enough that future YOU can effectively\n   use it to MATCH design problems you may encounter in future.\n\n2. In that DOCUMENT, describe the idea of the implementation along with code examples.\n   Follow the format of existing pattern files (Problem, Solution, Complete Code\n   Example, Key Points, When to Use).\n",
        "plugins/langroid/skills/patterns/SKILL.md": "---\nname: patterns\ndescription: Design patterns for the Langroid multi-agent LLM framework. Covers\n  agent configuration, tools, task control, and integrations.\n---\n\n# Langroid Patterns\n\n## Instructions\n\nBelow is an INDEX of design patterns organized by category. Each item describes\nWHAT you might want to implement, followed by a REFERENCE to a document with\na complete code example.\n\nScan this index to find patterns matching your needs, then consult the\ncorresponding document.\n\n---\n\n## Agent & Task Basics\n\n1. **Task Returns Tool Directly**\n\n   Create a Langroid Agent equipped with a single Tool (a ToolMessage), and wrap\n   it in a Task so that running the task returns that ToolMessage directly. Use\n   this pattern when you want a simple LLM agent that returns a structured\n   response.\n\n   - Reference: `./task-return-tool.md`\n\n---\n\n## Tool Handlers\n\n2. **Stateful Handler on Agent**\n\n   Define a STATEFUL tool handler as a METHOD on the agent (not inside the\n   ToolMessage). Use this pattern when: (a) the tool handler needs to execute\n   external operations (API calls, database queries, file I/O), (b) you need to\n   track state across retries (e.g., failure counter), (c) the handler needs\n   access to agent-level resources (connections, configs), or (d) you want\n   Langroid to automatically loop errors back to the LLM for self-correction.\n   The method name must match the `request` field of the ToolMessage. Return a\n   string for errors (LLM sees it and can retry), or DoneTool(content=result)\n   to terminate successfully.\n\n   - Reference: `./agent-tool-handler-with-state.md`\n\n3. **Handler with Validation**\n\n   Validate tool output against agent state before accepting it. Use this\n   pattern when: (a) the LLM's tool output must preserve certain content from\n   the input (e.g., placeholders, required fields), (b) you want automatic\n   retry if validation fails, (c) you need to compare tool output against\n   context the LLM received. Define a handler method on a custom agent class\n   that stores the input context as state, validates the tool output, and\n   returns an error string for retry or AgentDoneTool for success (note: use\n   AgentDoneTool, NOT DoneTool). Use `done_sequences=[\"T[ToolName], A\"]` so the\n   handler runs before task termination.\n\n   - Reference: `./agent-handler-validation-with-state.md`\n\n---\n\n## Task Control\n\n4. **Terminate on Specific Tool**\n\n   Terminate a Task only when a SPECIFIC tool is called. Use\n   `TaskConfig(done_sequences=[\"T[ToolName]\"])` to exit immediately when that\n   tool is emitted, or `TaskConfig(done_sequences=[\"T[ToolName], A\"])` to exit\n   after the tool is emitted AND handled by the agent. Use this when an agent\n   has multiple tools but you only want one specific tool to trigger task\n   termination.\n\n   - Reference: `./done-sequences-specific-tool.md`\n\n5. **Batch Processing**\n\n   Run the SAME task on MULTIPLE inputs concurrently using `run_batch_tasks()`.\n   Use this pattern when: (a) you need to process many items with the same\n   agent/task logic, (b) you want parallelism without manual asyncio/threading,\n   (c) you need state isolation between items (each gets a cloned agent with\n   fresh message history), (d) you want to avoid connection exhaustion from\n   creating too many agents manually. Each item gets a cloned task+agent, runs\n   independently, results collected in order. Supports batch_size for\n   concurrency limiting.\n\n   - Reference: `./run-batch-tasks.md`\n\n---\n\n## Integration & Output\n\n6. **MCP Tools Integration**\n\n   Enable a Langroid agent to use MCP (Model Context Protocol) tools from an\n   external MCP server like Claude Code. Use this pattern when: (a) you want\n   your agent to use file editing tools (Read, Edit, Write) from Claude Code,\n   (b) you need to connect to any MCP server via stdio transport, (c) you want\n   to enable ALL tools from an MCP server or just SPECIFIC tools selectively,\n   (d) you want to customize/post-process MCP tool results before returning to\n   the LLM. Uses `@mcp_tool` decorator for specific tools or `get_tools_async()`\n   for all tools.\n\n   - Reference: `./mcp-tool-integration.md`\n\n7. **Quiet Mode**\n\n   Suppress verbose Langroid agent output (streaming, tool JSON, intermediate\n   messages) while showing your own custom progress messages. Use this pattern\n   when: (a) you want clean CLI output showing only milestone events, (b) you're\n   running a multi-step workflow and want to show progress without agent noise,\n   (c) you need thread-safe output control. Use `quiet_mode()` context manager\n   to wrap agent task.run() calls, then print your own messages outside the\n   context.\n\n   - Reference: `./quiet-mode.md`\n",
        "plugins/langroid/skills/patterns/agent-handler-validation-with-state.md": "# Pattern: Validate Tool Output Against Agent State\n\n## Problem\n\nYou have an agent that produces tool output, but you need to validate that output\nagainst the input context before accepting it. For example:\n- Ensuring placeholders like `{{differentiation}}` are preserved in edited text\n- Verifying required fields aren't removed\n- Checking that certain patterns from the input appear in the output\n\nIf validation fails, you want the LLM to automatically retry.\n\n## Solution\n\n1. Create a **custom agent class** that stores input context as state\n2. Define a **handler method** on the agent (name matches tool's `request` field)\n3. In the handler, **validate** tool output against stored state\n4. Return **error string** for retry, or **AgentDoneTool** for success\n5. Use `done_sequences=[\"T[ToolName], A\"]` so handler runs before task terminates\n   (use `[\"T, A\"]` only if agent has a single unambiguous tool)\n\n## Complete Code Example\n\n```python\nimport langroid as lr\nfrom langroid.agent.chat_agent import ChatAgent, ChatAgentConfig\nfrom langroid.agent.tool_message import ToolMessage\nfrom langroid.agent.tools.orchestration import AgentDoneTool\nfrom pydantic import Field\n\n\n# Reserved content that must be preserved\nRESERVED_PLACEHOLDERS = [\"{{differentiation}}\", \"{{company_info}}\"]\n\n\nclass LineReplacementTool(ToolMessage):\n    \"\"\"Tool for LLM to output replacement text.\"\"\"\n    request: str = \"emit_line_replacement\"\n    purpose: str = \"Output the replacement text for the specified lines\"\n\n    replacement_text: str = Field(..., description=\"The new text\")\n    explanation: str = Field(..., description=\"Brief explanation of the edit\")\n\n\nclass LineEditorAgent(ChatAgent):\n    \"\"\"Editor agent that validates placeholder preservation.\"\"\"\n\n    def __init__(self, config: ChatAgentConfig):\n        super().__init__(config)\n        self.current_text: str = \"\"  # Set before task.run()\n\n    def init_state(self):\n        \"\"\"Reset state between tasks.\"\"\"\n        super().init_state()\n        self.current_text = \"\"\n\n    def emit_line_replacement(self, msg: LineReplacementTool) -> str | AgentDoneTool:\n        \"\"\"\n        Handler for LineReplacementTool. Validates placeholder preservation.\n\n        Name matches the tool's `request` field exactly.\n        \"\"\"\n        # Check if any reserved placeholder in original is missing from replacement\n        for placeholder in RESERVED_PLACEHOLDERS:\n            if placeholder in self.current_text:\n                if placeholder not in msg.replacement_text:\n                    # Return error string - LLM sees this and can retry\n                    return (\n                        f\"ERROR: You removed the placeholder {placeholder}. \"\n                        f\"This placeholder MUST be preserved exactly as-is. \"\n                        f\"Please output the replacement again, keeping {placeholder} intact.\"\n                    )\n\n        # Validation passed - terminate task successfully\n        # Return AgentDoneTool with the validated tool in the tools list\n        return AgentDoneTool(tools=[msg])\n\n\ndef create_editor_agent(model: str) -> LineEditorAgent:\n    \"\"\"Create the editor agent with validation handler.\"\"\"\n    config = ChatAgentConfig(\n        name=\"LineEditor\",\n        llm=lr.language_models.OpenAIGPTConfig(chat_model=model),\n        system_message=\"\"\"You are a precise technical editor.\nYou will receive text to edit along with instructions.\nOutput the replacement using the emit_line_replacement tool.\nIMPORTANT: Preserve any {{...}} placeholders exactly as they appear.\"\"\",\n    )\n    agent = LineEditorAgent(config)\n    agent.enable_message(LineReplacementTool)\n    return agent\n\n\ndef apply_edit(current_text: str, instruction: str, model: str) -> LineReplacementTool | None:\n    \"\"\"Apply an edit with placeholder validation.\"\"\"\n    agent = create_editor_agent(model)\n\n    # Store current text in agent state for handler to access\n    agent.current_text = current_text\n\n    # Use done_sequences so handler runs before task terminates\n    # \"T[ToolName], A\" = Specific tool emitted, then Agent handles it\n    # Use \"T, A\" only if agent has a single unambiguous tool\n    task = lr.Task(\n        agent,\n        interactive=False,\n        config=lr.TaskConfig(done_sequences=[\"T[LineReplacementTool], A\"]),\n    )[LineReplacementTool]\n\n    prompt = f\"\"\"Edit this text:\n\n{current_text}\n\nInstruction: {instruction}\n\nUse emit_line_replacement tool with your replacement.\"\"\"\n\n    # If handler returns error string, LLM retries automatically\n    # If handler returns DoneTool, task terminates and we get the tool\n    result: LineReplacementTool | None = task.run(prompt, turns=5)\n    return result\n```\n\n## Key Points\n\n1. **Handler method name = tool's `request` field**: If `request = \"emit_line_replacement\"`,\n   define `def emit_line_replacement(self, msg)`\n\n2. **Store context before task.run()**: Set `agent.current_text = ...` so handler can access it\n\n3. **Return types control flow**:\n   - `str` (error message) → Langroid sends to LLM, triggers retry\n   - `AgentDoneTool(tools=[msg])` → Task terminates successfully with the tool\n   - Note: Use `AgentDoneTool` (has `tools` field), NOT `DoneTool` (no `tools` field)\n\n4. **done_sequences=[\"T[ToolName], A\"]**: Ensures handler runs. Without this, task\n   might exit immediately when tool is emitted, skipping validation. Use `[\"T, A\"]`\n   only when agent has a single unambiguous tool.\n\n5. **init_state()**: Override to reset state between uses if agent is reused\n\n## When to Use This Pattern\n\n- LLM must preserve certain content (placeholders, markers, required fields)\n- You need to validate output against input context\n- Validation failure should trigger automatic retry\n- Simple prompt instructions aren't reliable enough (small LLMs ignore them)\n",
        "plugins/langroid/skills/patterns/agent-tool-handler-with-state.md": "# Stateful Tool Handler as Agent Method\n\n## The Pattern\n\nInstead of defining a `handle()` method inside the `ToolMessage` class, define a\nmethod on the **agent** with the same name as the tool's `request` field. This\ngives the handler access to agent state and resources.\n\n## When to Use\n\n- Handler needs to execute external operations (API calls, DB queries, shell cmds)\n- Need to track state across retries (e.g., failure counter to limit retries)\n- Handler needs access to agent-level resources (connections, configs, caches)\n- Want Langroid's automatic retry loop: errors go back to LLM for self-correction\n\n## Key Concepts\n\n1. **Method name = `request` field**: If `request = \"my_tool\"`, define\n   `def my_tool(self, msg: MyToolMessage)`\n\n2. **Return types control flow**:\n   - Return `str` (especially error messages) -> Langroid sends to LLM, can retry\n   - Return `DoneTool(content=\"result\")` -> Task terminates with this result\n\n3. **State in `init_state()`**: Override `init_state()` to reset counters/state\n   between uses. Called by `task.reset_all_sub_tasks()`.\n\n## Example: Query Executor with Retry Limit\n\n```python\nfrom langroid.agent.chat_agent import ChatAgent, ChatAgentConfig\nfrom langroid.agent.tool_message import ToolMessage\nfrom langroid.agent.tools.orchestration import DoneTool\nfrom pydantic import Field\nfrom typing import Union\n\n\nclass QueryTool(ToolMessage):\n    \"\"\"Tool for LLM to emit a query.\"\"\"\n    request: str = \"execute_query\"\n    purpose: str = \"Execute a database query\"\n\n    query: str = Field(..., description=\"The SQL query to execute\")\n\n\nclass QueryExecutorAgent(ChatAgent):\n    \"\"\"Agent that executes queries with retry limiting.\"\"\"\n\n    def __init__(self, config: ChatAgentConfig, db_connection, max_retries: int = 3):\n        super().__init__(config)\n        self.db_connection = db_connection\n        self.max_retries = max_retries\n        self.failure_count = 0\n\n    def init_state(self):\n        \"\"\"Reset state between tasks. Called by task.reset_all_sub_tasks().\"\"\"\n        super().init_state()\n        self.failure_count = 0\n\n    def execute_query(self, msg: QueryTool) -> Union[str, DoneTool]:\n        \"\"\"Handler for QueryTool. Name matches request field.\"\"\"\n        try:\n            result = self.db_connection.execute(msg.query)\n            # Success - terminate task with result\n            return DoneTool(content=str(result))\n\n        except Exception as e:\n            self.failure_count += 1\n\n            if self.failure_count >= self.max_retries:\n                # Give up after max retries\n                return DoneTool(content=\"\")  # Empty = failure\n\n            # Return error string - Langroid sends to LLM for retry\n            return f\"Query failed with error: {e}\\nPlease fix and try again.\"\n\n\n# Usage\nconfig = ChatAgentConfig(\n    name=\"QueryAgent\",\n    system_message=\"You execute SQL queries. Use the execute_query tool.\",\n)\nagent = QueryExecutorAgent(config, db_connection=my_db, max_retries=3)\nagent.enable_message([QueryTool])\n\ntask = lr.Task(agent, interactive=False)\nresult = task.run(\"Run a query to get all users\")\n# result.content will be query results or empty string on failure\n```\n\n## Example: External API with Validation\n\n```python\nclass APICallTool(ToolMessage):\n    request: str = \"call_api\"\n    purpose: str = \"Call an external API endpoint\"\n\n    endpoint: str = Field(..., description=\"API endpoint path\")\n    payload: dict = Field(default_factory=dict, description=\"Request payload\")\n\n\nclass APIAgent(ChatAgent):\n    def __init__(self, config, api_client):\n        super().__init__(config)\n        self.api_client = api_client\n        self.call_count = 0\n\n    def init_state(self):\n        super().init_state()\n        self.call_count = 0\n\n    def call_api(self, msg: APICallTool) -> Union[str, DoneTool]:\n        \"\"\"Handler matches 'call_api' request field.\"\"\"\n        # Validate before calling\n        if not msg.endpoint.startswith(\"/\"):\n            return \"Error: endpoint must start with '/'. Please fix.\"\n\n        try:\n            response = self.api_client.post(msg.endpoint, json=msg.payload)\n\n            if response.status_code != 200:\n                return f\"API returned {response.status_code}: {response.text}\"\n\n            self.call_count += 1\n            return DoneTool(content=response.json())\n\n        except Exception as e:\n            return f\"API call failed: {e}. Check endpoint and payload.\"\n```\n\n## Integration with Batch Processing\n\nWhen using `run_batch_tasks()`, each item gets a cloned agent with fresh state:\n\n```python\nfrom langroid.agent.batch import run_batch_tasks\n\nbase_task = lr.Task(agent, interactive=False)\n\n# Each item gets a cloned agent - no state leakage between items\nresults = run_batch_tasks(\n    base_task,\n    items=[\"query1\", \"query2\", \"query3\"],\n    input_map=lambda q: f\"Execute: {q}\",\n    output_map=lambda r: r.content if r else None,\n    sequential=False,  # Run in parallel\n    batch_size=10,\n)\n```\n\n## Important Notes\n\n1. The handler method receives the parsed `ToolMessage` object, not raw JSON\n2. Langroid automatically deserializes the LLM's tool call into the ToolMessage\n3. If handler returns a string, Langroid treats it as a response and continues\n   the conversation (LLM sees it, can emit another tool call)\n4. `DoneTool` signals task completion - the task's `run()` returns\n5. For async handlers, define `async def my_tool(self, msg)` - Langroid handles it\n",
        "plugins/langroid/skills/patterns/done-sequences-specific-tool.md": "# Pattern: Terminate Task on SPECIFIC Tool (done_sequences)\n\n## Problem\n\nYou have an agent with multiple tools, but you only want the task to terminate\nwhen ONE specific tool is called. Other tools should NOT trigger termination.\n\n## Solution\n\nUse `TaskConfig(done_sequences=[\"T[ToolName]\"])` with the specific tool name.\n\n### Two Variants\n\n**Exit immediately on tool EMISSION:**\n```python\ntask_config = lr.TaskConfig(\n    done_sequences=[\"T[FinalAnswerTool]\"]  # No \", A\"\n)\n```\nTask terminates as soon as the LLM emits `FinalAnswerTool`, before any handling.\n\n**Exit after tool is HANDLED:**\n```python\ntask_config = lr.TaskConfig(\n    done_sequences=[\"T[FinalAnswerTool], A\"]  # With \", A\"\n)\n```\nTask waits for the tool to be emitted AND for the agent to handle it before\nterminating.\n\n## Complete Code Example\n\n```python\nimport langroid as lr\nfrom langroid.agent.task import Task\nfrom langroid.agent.tool_message import ToolMessage\nfrom langroid.agent.chat_agent import ChatAgent, ChatAgentConfig\n\n\nclass SearchTool(ToolMessage):\n    \"\"\"Intermediate tool - should NOT trigger exit.\"\"\"\n    request: str = \"search\"\n    purpose: str = \"Search for information\"\n    query: str\n\n\nclass FinalAnswerTool(ToolMessage):\n    \"\"\"Final tool - SHOULD trigger exit.\"\"\"\n    request: str = \"final_answer\"\n    purpose: str = \"Provide the final answer\"\n    answer: str\n    confidence: float\n\n\ndef create_agent() -> ChatAgent:\n    config = ChatAgentConfig(\n        name=\"ResearchAgent\",\n        llm=lr.language_models.OpenAIGPTConfig(chat_model=\"gpt-4o\"),\n        system_message=\"\"\"\nYou are a research agent. Use the search tool to find information,\nthen use final_answer when you have enough to answer confidently.\n\"\"\",\n    )\n    agent = ChatAgent(config)\n    agent.enable_message(SearchTool)\n    agent.enable_message(FinalAnswerTool)\n    return agent\n\n\ndef research(question: str) -> str | None:\n    agent = create_agent()\n\n    # Only exit when FinalAnswerTool is used (SearchTool won't trigger exit)\n    task_config = lr.TaskConfig(\n        done_sequences=[\"T[FinalAnswerTool]\"]\n    )\n    task = Task(agent, interactive=False, config=task_config)[FinalAnswerTool]\n\n    # Agent can use SearchTool multiple times without exiting\n    # Task only exits when FinalAnswerTool is emitted\n    result: FinalAnswerTool | None = task.run(question, turns=15)\n\n    if result:\n        return result.answer\n    return None\n```\n\n## DSL Syntax Reference\n\n| Pattern | Meaning |\n|---------|---------|\n| `T` | Any tool |\n| `T[ToolName]` | Specific tool by class name |\n| `A` | Agent response (tool handling) |\n| `C[pattern]` | Content matching regex pattern |\n| `,` | Then (sequence of events) |\n\n## Key Differences Between Variants\n\n| Pattern | When it exits | Use case |\n|---------|---------------|----------|\n| `[\"T[Tool]\"]` | Immediately on emission | Get tool output, no handling needed |\n| `[\"T[Tool], A\"]` | After emission + handling | Tool has side effects to complete |\n\n## Complex Patterns\n\n### Exit after two specific tools in sequence\n```python\ndone_sequences=[\"T[SearchTool], A, T[AnalyzeTool], A\"]\n```\n\n### Multiple exit conditions (OR logic)\n```python\ndone_sequences=[\n    \"C[quit|exit|bye]\",      # Exit if user says quit\n    \"T[FinalAnswerTool]\"     # OR if FinalAnswerTool is used\n]\n```\n\n### Exit only after tool AND specific content\n```python\ndone_sequences=[\"T[CompletionTool], A, C[done|complete]\"]\n```\n\n## When to Use This Pattern\n\n- Agent has multiple tools but only ONE should trigger exit\n- Other tools are intermediate steps that should NOT terminate the task\n- You need fine-grained control over which tool ends the conversation\n\n## Common Mistake\n\n```python\n# WRONG: Bracket notation does NOT filter which tools trigger exit\n# It only specifies the RETURN TYPE\ntask = Task(agent, config=task_config)[FinalAnswerTool]\n```\n\nThe bracket notation `[FinalAnswerTool]` specifies what type the task returns.\nTo control which tool TRIGGERS exit, you must use `done_sequences`.\n",
        "plugins/langroid/skills/patterns/mcp-tool-integration.md": "# MCP Tool Integration Pattern\n\nEnable Langroid agents to use tools from MCP (Model Context Protocol) servers,\nsuch as Claude Code's file editing tools.\n\n## Key Imports\n\n```python\nfrom fastmcp.client.transports import StdioTransport\nfrom langroid.agent.tools.mcp import mcp_tool\nfrom langroid.agent.tools.mcp.fastmcp_client import get_tools_async\nimport langroid as lr\n```\n\n## Setting Up the Transport\n\nConnect to an MCP server via stdio (e.g., Claude Code):\n\n```python\ntransport = StdioTransport(\n    command=\"claude\",\n    args=[\"mcp\", \"serve\"],\n    env={},\n)\n```\n\n## Option 1: Enable ALL Tools from MCP Server\n\nUse `get_tools_async()` to fetch and enable all available tools:\n\n```python\nasync def setup_agent_with_all_tools():\n    all_tools = await get_tools_async(transport)\n\n    agent = lr.ChatAgent(lr.ChatAgentConfig(\n        system_message=\"You have access to file tools.\",\n        llm=lr.language_models.OpenAIGPTConfig(chat_model=\"gpt-4o\"),\n    ))\n\n    agent.enable_message(all_tools)  # Enable all tools at once\n    return agent\n```\n\n## Option 2: Enable SPECIFIC Tools (Preferred)\n\nUse the `@mcp_tool` decorator to create ToolMessage subclasses for specific\ntools. This gives you control over which tools are available and lets you\ncustomize result handling.\n\n```python\n# Basic usage - just wrap the MCP tool\n@mcp_tool(transport, \"Read\")\nclass ReadTool(lr.ToolMessage):\n    async def handle_async(self):\n        return await self.call_tool_async()\n\n\n@mcp_tool(transport, \"Edit\")\nclass EditTool(lr.ToolMessage):\n    async def handle_async(self):\n        return await self.call_tool_async()\n\n\n@mcp_tool(transport, \"Write\")\nclass WriteTool(lr.ToolMessage):\n    async def handle_async(self):\n        return await self.call_tool_async()\n\n\n# Enable specific tools on agent\nagent.enable_message(ReadTool)\nagent.enable_message(EditTool)\nagent.enable_message(WriteTool)\n```\n\n## Option 3: Custom Result Processing\n\nOverride `handle_async()` to transform MCP tool results before returning to LLM:\n\n```python\n@mcp_tool(transport, \"Grep\")\nclass GrepTool(lr.ToolMessage):\n    async def handle_async(self):\n        result = await self.call_tool_async()\n\n        # Result may be tuple (text, files) or just text\n        result_text, _files = result if isinstance(result, tuple) else (result, [])\n\n        # Parse and transform the result\n        import json\n        try:\n            data = json.loads(result_text)\n            # Custom formatting...\n            return f\"Found {data.get('numMatches', 0)} matches:\\n{data.get('content', '')}\"\n        except:\n            return result_text\n```\n\n## Complete Example: File Editor Agent\n\n```python\nfrom fastmcp.client.transports import StdioTransport\nfrom langroid.agent.tools.mcp import mcp_tool\nimport langroid as lr\n\ntransport = StdioTransport(\n    command=\"claude\",\n    args=[\"mcp\", \"serve\"],\n    env={},\n)\n\n\n@mcp_tool(transport, \"Read\")\nclass ReadFileTool(lr.ToolMessage):\n    async def handle_async(self):\n        return await self.call_tool_async()\n\n\n@mcp_tool(transport, \"Edit\")\nclass EditFileTool(lr.ToolMessage):\n    async def handle_async(self):\n        return await self.call_tool_async()\n\n\nasync def create_file_editor_agent():\n    agent = lr.ChatAgent(lr.ChatAgentConfig(\n        name=\"FileEditor\",\n        system_message=\"\"\"You are a file editor. Use the Read tool to read files\n        and the Edit tool to make changes.\"\"\",\n        llm=lr.language_models.OpenAIGPTConfig(chat_model=\"gpt-4o\"),\n    ))\n\n    agent.enable_message(ReadFileTool)\n    agent.enable_message(EditFileTool)\n\n    return agent\n\n\nasync def main():\n    agent = await create_file_editor_agent()\n    task = lr.Task(agent, interactive=False)\n\n    result = await task.run_async(\n        \"Read the file proposal.md and fix any typos you find.\"\n    )\n    return result\n```\n\n## Server Factory Pattern (for Concurrency)\n\nFor concurrent usage, create fresh transports to avoid `ClosedResourceError`:\n\n```python\ndef make_transport():\n    return StdioTransport(\n        command=\"claude\",\n        args=[\"mcp\", \"serve\"],\n        env={},\n    )\n\n# Use factory when creating tools for concurrent scenarios\n@mcp_tool(make_transport, \"Edit\")  # Pass factory, not instance\nclass EditTool(lr.ToolMessage):\n    async def handle_async(self):\n        return await self.call_tool_async()\n```\n\n## Available Claude Code MCP Tools\n\nCommon tools exposed by Claude Code's MCP server:\n\n- `Read` - Read file contents\n- `Edit` - Edit file with old_string/new_string replacement\n- `Write` - Write/create files\n- `Grep` - Search with ripgrep\n- `Glob` - Find files by pattern\n- `Bash` - Execute shell commands\n- `LS` - List directory contents\n",
        "plugins/langroid/skills/patterns/quiet-mode.md": "# Quiet Mode - Suppressing Verbose Agent Output\n\nSuppress Langroid's verbose agent output while showing your own custom progress.\n\n## Key Imports\n\n```python\nfrom langroid.utils.configuration import quiet_mode, settings\n```\n\n## Context Manager (Recommended)\n\n```python\nfrom langroid.utils.configuration import quiet_mode\n\n# Wrap agent runs in quiet_mode context\nprint(\"Starting writer...\")\n\nwith quiet_mode():\n    result = writer_task.run(\"Write the proposal\")\n\nprint(f\"Done! {len(result)} chars\")\n```\n\n## Global Setting\n\n```python\nfrom langroid.utils.configuration import settings\n\nsettings.quiet = True   # Enable globally\nresult = task.run(...)\nsettings.quiet = False  # Disable\n```\n\n## What Gets Suppressed\n\n- Agent streaming output\n- Intermediate messages and tool outputs\n- Rich console spinners/status messages\n- Response statistics (show_stats)\n- Debug information\n\n## Pattern: Multi-Step Workflow with Progress\n\n```python\nfrom langroid.utils.configuration import quiet_mode\n\ndef run_workflow():\n    print(\"Phase 1: Writing proposal...\")\n    with quiet_mode():\n        proposal = writer_task.run(\"Write proposal\")\n    print(f\"  ✓ Proposal written ({len(proposal)} chars)\")\n\n    print(\"Phase 2: Reviewing...\")\n    with quiet_mode():\n        edits = reviewer_task.run(f\"Review:\\n{proposal}\")\n    print(f\"  ✓ Found {len(edits)} issues\")\n\n    for i, edit in enumerate(edits, 1):\n        print(f\"  Applying edit {i}/{len(edits)}...\")\n        with quiet_mode():\n            result = editor_task.run(edit)\n        print(f\"    ✓ Applied\")\n\n    print(\"Done!\")\n```\n\n## Thread Safety\n\n- Uses thread-local storage\n- Supports nesting (once quiet, stays quiet in nested contexts)\n- Exception-safe (reverts even on error)\n\n```python\nwith quiet_mode():\n    with quiet_mode(quiet=False):\n        # Still quiet - once enabled, stays enabled in nesting\n        assert settings.quiet\n```\n\n## Key Files in Langroid Repo\n\n- `langroid/utils/configuration.py` - Main implementation (lines 111-128)\n- `langroid/utils/output/status.py` - Status output helper\n- `langroid/agent/batch.py` - Real-world usage example\n- `tests/main/test_quiet_mode.py` - Test examples\n",
        "plugins/langroid/skills/patterns/run-batch-tasks.md": "# Batch Processing with run_batch_tasks()\n\n## The Pattern\n\nUse `run_batch_tasks()` to process multiple inputs through the same task/agent\nlogic concurrently. Each input gets a **cloned** task+agent with isolated state.\n\n## When to Use\n\n- Process many items (prompts, questions, documents) with the same agent logic\n- Need parallelism without manual asyncio/threading complexity\n- Need state isolation between items (no message history leakage)\n- Want to avoid connection exhaustion from creating agents manually\n- Need ordered results matching input order\n\n## Key Functions\n\n### `run_batch_tasks()` - Simple Case\n\n```python\nfrom langroid.agent.batch import run_batch_tasks\n\nresults = run_batch_tasks(\n    task,                    # Base task to clone\n    items,                   # List of items to process\n    input_map=lambda x: x,   # Convert item -> prompt string\n    output_map=lambda x: x,  # Convert result -> desired output\n    sequential=False,        # False = parallel, True = sequential\n    batch_size=10,           # Max concurrent tasks (None = unlimited)\n    turns=-1,                # Max turns per task (-1 = unlimited)\n)\n```\n\n### `run_batch_task_gen()` - Custom Task Generation\n\n```python\nfrom langroid.agent.batch import run_batch_task_gen\n\ndef task_gen(i: int) -> Task:\n    \"\"\"Generate a custom task for item at index i.\"\"\"\n    return base_task.clone(i)  # or create entirely new task\n\nresults = run_batch_task_gen(\n    gen_task=task_gen,       # Function that creates task for each index\n    items=items,\n    input_map=lambda x: x,\n    output_map=lambda x: x,\n    sequential=False,\n)\n```\n\n## How Cloning Works\n\nWhen `run_batch_tasks()` processes each item, it calls `task.clone(i)`:\n\n1. **Task cloning** (`Task.clone()`):\n   - Creates new Task with name `{original}-{i}`\n   - Calls `agent.clone(i)` for the agent\n\n2. **Agent cloning** (`ChatAgent.clone()`):\n   - Deep copies the config\n   - Creates fresh agent with new message history\n   - Copies tool definitions (shared, not duplicated)\n   - Clones vector store client if present\n   - Assigns unique agent ID\n\n**Result**: Each item is processed by an isolated agent with no state leakage.\n\n## Example: Analyze Multiple Code Files\n\n```python\nimport langroid as lr\nfrom langroid.agent.batch import run_batch_tasks\n\n# Create base agent and task\nagent = lr.ChatAgent(\n    lr.ChatAgentConfig(\n        name=\"CodeAnalyzer\",\n        llm=lr.language_models.OpenAIGPTConfig(chat_model=\"gpt-4\"),\n        system_message=\"Analyze code for security vulnerabilities.\",\n    )\n)\nagent.enable_message([VulnerabilityTool])\nbase_task = lr.Task(agent, interactive=False)\n\n# Process multiple code files\ncode_files = [\n    {\"id\": \"file1\", \"code\": \"void foo() { strcpy(buf, input); }\"},\n    {\"id\": \"file2\", \"code\": \"void bar() { strncpy(buf, input, sizeof(buf)); }\"},\n    {\"id\": \"file3\", \"code\": \"void baz() { gets(buffer); }\"},\n]\n\nresults = run_batch_tasks(\n    base_task,\n    items=code_files,\n    input_map=lambda f: f\"Analyze this code:\\n{f['code']}\",\n    output_map=lambda r: r.content if r else \"ANALYSIS_FAILED\",\n    sequential=False,\n    batch_size=5,  # Max 5 concurrent analyses\n)\n\nfor file, result in zip(code_files, results):\n    print(f\"{file['id']}: {result}\")\n```\n\n## Example: Q&A with Structured Output\n\n```python\nfrom langroid.agent.batch import run_batch_tasks\n\nclass AnswerTool(lr.ToolMessage):\n    request: str = \"answer\"\n    purpose: str = \"Provide an answer\"\n    answer: str\n    confidence: float\n\nagent = lr.ChatAgent(config)\nagent.enable_message([AnswerTool])\n\n# Configure task to return tool directly\ntask = lr.Task(\n    agent,\n    interactive=False,\n    config=lr.TaskConfig(done_if_tool=True)\n)[AnswerTool]  # Bracket notation: task returns AnswerTool | None\n\nquestions = [\"What is 2+2?\", \"Capital of France?\", \"Largest planet?\"]\n\nanswers = run_batch_tasks(\n    task,\n    items=questions,\n    input_map=lambda q: q,\n    output_map=lambda tool: tool.answer if tool else \"NO_ANSWER\",\n    sequential=False,\n    batch_size=3,\n)\n# answers = [\"4\", \"Paris\", \"Jupiter\"]\n```\n\n## Example: With Stateful Agent Handler\n\nCombining batch processing with stateful handlers (see pattern #2):\n\n```python\nclass QueryAgent(lr.ChatAgent):\n    def __init__(self, config, db_connection, max_retries=3):\n        super().__init__(config)\n        self.db = db_connection\n        self.max_retries = max_retries\n        self.failures = 0\n\n    def init_state(self):\n        super().init_state()\n        self.failures = 0  # Reset per clone\n\n    def execute_query(self, msg: QueryTool) -> str | DoneTool:\n        try:\n            result = self.db.execute(msg.query)\n            return DoneTool(content=str(result))\n        except Exception as e:\n            self.failures += 1\n            if self.failures >= self.max_retries:\n                return DoneTool(content=\"\")\n            return f\"Error: {e}. Fix and retry.\"\n\nagent = QueryAgent(config, db_connection=my_db)\nagent.enable_message([QueryTool])\nbase_task = lr.Task(agent, interactive=False)\n\n# Each query gets a cloned agent with fresh failure counter\nqueries = [\"SELECT * FROM users\", \"SELECT * FROM orders\", ...]\nresults = run_batch_tasks(base_task, queries, ...)\n```\n\n## Parameters Reference\n\n| Parameter | Type | Description |\n|-----------|------|-------------|\n| `task` | Task | Base task to clone for each item |\n| `items` | List[T] | Items to process |\n| `input_map` | Callable[[T], str] | Convert item to prompt |\n| `output_map` | Callable[[Result], U] | Convert result to output |\n| `sequential` | bool | True=one at a time, False=parallel |\n| `batch_size` | int\\|None | Max concurrent tasks (None=all) |\n| `turns` | int | Max turns per task (-1=unlimited) |\n| `handle_exceptions` | bool\\|ExceptionHandling | How to handle errors |\n| `max_cost` | float | Stop if cumulative cost exceeds |\n| `max_tokens` | int | Stop if cumulative tokens exceed |\n\n## Important Notes\n\n1. **Order preserved**: Results list matches input items order\n2. **Exceptions**: By default raised; use `handle_exceptions=RETURN_NONE` to continue\n3. **Memory**: Each clone has separate message history - no accumulation\n4. **Connections**: Cloned agents share underlying LLM client but have separate state\n5. **Vector stores**: Each clone gets its own vector store client (same data, isolated state)\n",
        "plugins/langroid/skills/patterns/task-return-tool.md": "# Pattern: Make Task Return a Specific ToolMessage Directly\n\n## Problem\n\nWhen an agent emits a ToolMessage, you need to extract it from the task result. The naive approach is to search through `task.agent.message_history` to find the tool, but this is **error-prone** and **inefficient**.\n\n## Solution\n\nUse **TaskConfig with `done_if_tool=True`** combined with **bracket notation** to make the task:\n1. Terminate as soon as a tool is emitted\n2. Return the tool directly (typed as `ToolClass | None`)\n\n## Code Pattern\n\n### Wrong Approach (searching message_history)\n\n```python\nfrom langroid.agent.task import Task\n\ntask = Task(agent, interactive=False)\nresult = task.run(prompt, turns=5)\n\n# BAD: Searching message_history\npruned_classes = None\nfor msg in task.agent.message_history:\n    if isinstance(msg, EmitPrunedModelTool):\n        pruned_classes = msg.classes\n        break\n\nif not pruned_classes:\n    print(\"❌ Agent did not use the tool\")\n    return 1\n```\n\n**Problems**:\n- Iterating through entire message history\n- Error-prone type checking with `isinstance`\n- Can miss the tool if not searching correctly\n- Not type-safe\n\n### Correct Approach (TaskConfig + bracket notation)\n\n```python\nimport langroid as lr\nfrom langroid.agent.task import Task\n\n# 1. Create TaskConfig with done_if_tool=True\ntask_config = lr.TaskConfig(done_if_tool=True)\n\n# 2. Use bracket notation to specify return type\ntask = Task(agent, interactive=False, config=task_config)[EmitPrunedModelTool]\n\n# 3. Run task - returns EmitPrunedModelTool | None\nresult: EmitPrunedModelTool | None = task.run(prompt, turns=5)\n\n# 4. Check if tool was emitted\nif not result:\n    print(\"❌ Agent did not use the tool\")\n    return 1\n\n# 5. Access tool data directly\npruned_classes = result.classes  # Type-safe!\n```\n\n**Benefits**:\n- Task terminates immediately when tool is emitted (efficient)\n- Return type is explicit and type-safe\n- No need to search message_history\n- Clean, readable code\n\n## Key Components\n\n### 1. TaskConfig(done_if_tool=True)\n\n```python\ntask_config = lr.TaskConfig(done_if_tool=True)\n```\n\nThis tells the task to **stop as soon as any tool is emitted**, rather than continuing for `turns` iterations.\n\n### 2. Bracket Notation: `Task(...)[ToolClass]`\n\n```python\ntask = Task(agent, interactive=False, config=task_config)[EmitPrunedModelTool]\n```\n\nThe bracket notation **specifies the expected return type**:\n- If the agent emits `EmitPrunedModelTool`, task returns it\n- If the agent doesn't emit the tool, task returns `None`\n- Return type is `EmitPrunedModelTool | None`\n\n### 3. Type-Safe Result Handling\n\n```python\nresult: EmitPrunedModelTool | None = task.run(prompt, turns=5)\n\nif not result:\n    # Agent didn't emit the tool\n    handle_failure()\nelse:\n    # Tool was emitted, access fields directly\n    data = result.classes  # Type-safe attribute access\n```\n\n## Real-World Example\n\nFrom `tools/prune_xsdata_models.py`:\n\n```python\nimport langroid as lr\nfrom langroid.agent.task import Task\nfrom interop.agents.model_pruning_agent import (\n    EmitPrunedModelTool,\n    create_model_pruning_agent,\n)\n\n# Create agent\nagent = create_model_pruning_agent(\n    raw_generated_code=raw_content,\n    reference_code=reference_code,\n    target_entity=\"Aircraft\",\n    model=\"gpt-4o\",\n)\n\n# Configure task to return tool directly\ntask_config = lr.TaskConfig(done_if_tool=True)\ntask = Task(agent, interactive=False, config=task_config)[EmitPrunedModelTool]\n\n# Build prompt\nprompt = f\"\"\"\nHere is the raw xsdata-generated code for Aircraft:\n\n```python\n{raw_content[:50000]}\n```\n\nPlease analyze this code and emit pruned class definitions using the tool.\n\"\"\"\n\n# Run task - returns tool or None\nresult: EmitPrunedModelTool | None = task.run(prompt, turns=5)\n\nif not result:\n    print(\"❌ Agent did not use the EmitPrunedModelTool\")\n    return 1\n\n# Extract data from tool\npruned_classes = result.classes\nprint(f\"✅ Agent produced {len(pruned_classes)} pruned classes\")\n\n# Use the data\nfor cls_def in pruned_classes:\n    print(f\"   • {cls_def.class_name}: {len(cls_def.fields)} fields\")\n```\n\n## When to Use This Pattern\n\nUse this pattern when:\n- ✅ You expect the agent to emit a **specific tool** as its final output\n- ✅ You want **type-safe access** to the tool data\n- ✅ You want the task to **terminate immediately** when the tool is emitted\n- ✅ The tool emission is the **primary goal** of the task (not intermediate step)\n\nDon't use this pattern when:\n- ❌ The agent might emit multiple different tools during conversation\n- ❌ You need the full conversation history\n- ❌ Tool emission is an intermediate step in a longer workflow\n\n## Related Patterns\n\n- **handle_llm_no_tool**: Use this in `ChatAgentConfig` to catch cases where the LLM doesn't use the tool\n- **ToolMessage validation**: Use Pydantic models to ensure tool output is well-formed\n- **Multi-turn tasks**: Combine with `turns` parameter for agents that need multiple attempts\n\n## Common Mistakes\n\n### Mistake 1: Forgetting `done_if_tool=True`\n\n```python\n# WRONG: Task will run for all turns even after tool is emitted\ntask = Task(agent)[EmitPrunedModelTool]\nresult = task.run(prompt, turns=5)  # Wastes turns!\n```\n\n**Fix**: Always use `TaskConfig(done_if_tool=True)`\n\n### Mistake 2: Not checking for None\n\n```python\n# WRONG: Will crash if agent doesn't emit tool\nresult = task.run(prompt, turns=5)\npruned_classes = result.classes  # AttributeError if result is None!\n```\n\n**Fix**: Always check `if not result:` before accessing fields\n\n### Mistake 3: Searching message_history instead\n\n```python\n# WRONG: Negates the entire point of bracket notation\nresult = task.run(prompt, turns=5)\nfor msg in task.agent.message_history:\n    if isinstance(msg, EmitPrunedModelTool):\n        # Why did you use bracket notation then?\n```\n\n**Fix**: Trust the bracket notation - result IS the tool\n\n## Summary\n\n**Pattern**: `Task(agent, config=TaskConfig(done_if_tool=True))[ToolClass]`\n\n**Returns**: `ToolClass | None`\n\n**Benefits**:\n- Efficient (terminates immediately)\n- Type-safe (explicit return type)\n- Clean (no message_history iteration)\n- Robust (can't miss the tool)\n\n**Use when**: Tool emission is the primary goal of the task\n"
      },
      "plugins": [
        {
          "name": "langroid",
          "source": "./plugins/langroid",
          "description": "Langroid multi-agent framework patterns and best practices",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add langroid/langroid",
            "/plugin install langroid@langroid"
          ]
        }
      ]
    }
  ]
}