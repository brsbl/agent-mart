{
  "author": {
    "id": "langroid",
    "display_name": "Langroid",
    "avatar_url": "https://avatars.githubusercontent.com/u/130325191?v=4"
  },
  "marketplaces": [
    {
      "name": "langroid",
      "version": "1.0.0",
      "description": "Langroid multi-agent framework patterns and best practices",
      "repo_full_name": "langroid/langroid",
      "repo_url": "https://github.com/langroid/langroid",
      "repo_description": "Harness LLMs with Multi-Agent Programming",
      "signals": {
        "stars": 3867,
        "forks": 354,
        "pushed_at": "2026-01-31T23:37:49Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"langroid\",\n  \"version\": \"1.0.0\",\n  \"owner\": {\n    \"name\": \"Langroid\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"langroid\",\n      \"source\": \"./plugins/langroid\",\n      \"description\": \"Langroid multi-agent framework patterns and best practices\"\n    }\n  ]\n}\n",
        "README.md": "<div align=\"center\">\n  <img src=\"docs/assets/langroid-card-lambda-ossem-rust-1200-630.png\" alt=\"Logo\" \n        width=\"400\" align=\"center\">\n</div>\n\n<div align=\"center\">\n\n[![PyPI - Version](https://img.shields.io/pypi/v/langroid)](https://pypi.org/project/langroid/)\n[![Downloads](https://img.shields.io/pypi/dm/langroid)](https://pypi.org/project/langroid/)\n[![Pytest](https://github.com/langroid/langroid/actions/workflows/pytest.yml/badge.svg)](https://github.com/langroid/langroid/actions/workflows/pytest.yml)\n[![codecov](https://codecov.io/gh/langroid/langroid/graph/badge.svg)](https://codecov.io/gh/langroid/langroid)\n[![Multi-Architecture DockerHub](https://github.com/langroid/langroid/actions/workflows/docker-publish.yml/badge.svg)](https://github.com/langroid/langroid/actions/workflows/docker-publish.yml)\n\n[![Static Badge](https://img.shields.io/badge/Documentation-blue?link=https%3A%2F%2Flangroid.github.io%2Flangroid%2F&link=https%3A%2F%2Flangroid.github.io%2Flangroid%2F)](https://langroid.github.io/langroid)\n[![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langroid/langroid/blob/main/examples/Langroid_quick_start.ipynb)\n[![Discord](https://img.shields.io/badge/Discord-%235865F2.svg?style=flat&logo=discord&logoColor=white)](https://discord.gg/ZU36McDgDs)\n[![Substack](https://img.shields.io/badge/Substack-%23006f5c.svg?style=flat&logo=substack&logoColor=FF6719)](https://langroid.substack.com/p/langroid-harness-llms-with-multi-agent-programming)\n\n[![GitMCP](https://img.shields.io/endpoint?url=https://gitmcp.io/badge/OWNER/REPO)](https://gitmcp.io/langroid/langroid)\n</div>\n\n<h3 align=\"center\">\n  <a target=\"_blank\" \n    href=\"https://langroid.github.io/langroid/\" rel=\"dofollow\">\n      <strong>Documentation</strong></a>\n  &middot;\n  <a target=\"_blank\" href=\"https://github.com/langroid/langroid-examples\" rel=\"dofollow\">\n      <strong>Examples Repo</strong></a>\n  &middot;\n  <a target=\"_blank\" href=\"https://discord.gg/ZU36McDgDs\" rel=\"dofollow\">\n      <strong>Discord</strong></a>\n  &middot;\n  <a target=\"_blank\" href=\"./CONTRIBUTING.md\" rel=\"dofollow\">\n      <strong>Contributing</strong></a>\n\n  <br />\n</h3>\n\n`Langroid` is an intuitive, lightweight, extensible and principled\nPython framework to easily build LLM-powered applications, from CMU and UW-Madison researchers. \nYou set up Agents, equip them with optional components (LLM, \nvector-store and tools/functions), assign them tasks, and have them \ncollaboratively solve a problem by exchanging messages. \nThis Multi-Agent paradigm is inspired by the\n[Actor Framework](https://en.wikipedia.org/wiki/Actor_model)\n(but you do not need to know anything about this!). \n\n`Langroid` is a fresh take on LLM app-development, where considerable thought has gone \ninto simplifying the developer experience; \nit does not use `Langchain`, or any other LLM framework, \nand works with [practically any LLM](https://langroid.github.io/langroid/tutorials/supported-models/).\n\n:fire: :sparkles: A Claude Code [plugin](#claude-code-plugin-optional) is available to\naccelerate Langroid development with built-in patterns and best practices.\n\n\n:fire: Read the (WIP) [overview of the langroid architecture](https://langroid.github.io/langroid/blog/2024/08/15/overview-of-langroids-multi-agent-architecture-prelim/), \n and a [quick tour of Langroid](https://langroid.github.io/langroid/tutorials/langroid-tour/).\n\n:fire: MCP Support: Allow any LLM-Agent to leverage MCP Servers via Langroid's simple\n[MCP tool adapter](https://langroid.github.io/langroid/notes/mcp-tools/) that converts \nthe server's tools into Langroid's `ToolMessage` instances.\n\nðŸ“¢ Companies are using/adapting Langroid in **production**. Here is a quote:\n\n>[Nullify](https://www.nullify.ai) uses AI Agents for secure software development. \n> It finds, prioritizes and fixes vulnerabilities. We have internally adapted Langroid's multi-agent orchestration framework in production, after evaluating CrewAI, Autogen, LangChain, Langflow, etc. We found Langroid to be far superior to those frameworks in terms of ease of setup and flexibility. Langroid's Agent and Task abstractions are intuitive, well thought out, and provide a great developer  experience. We wanted the quickest way to get something in production. With other frameworks it would have taken us weeks, but with Langroid we got to good results in minutes. Highly recommended! <br> -- Jacky Wong, Head of AI at Nullify.\n\n\n:fire: See this [Intro to Langroid](https://lancedb.substack.com/p/langoid-multi-agent-programming-framework)\nblog post from the LanceDB team\n\n:fire: Just published in ML for Healthcare (2024): a Langroid-based Multi-Agent RAG system for \npharmacovigilance, see [blog post](https://langroid.github.io/langroid/blog/2024/08/12/malade-multi-agent-architecture-for-pharmacovigilance/)\n\n\nWe welcome contributions: See the [contributions](./CONTRIBUTING.md) document\nfor ideas on what to contribute.\n\nAre you building LLM Applications, or want help with Langroid for your company, \nor want to prioritize Langroid features for your company use-cases? \n[Prasad Chalasani](https://www.linkedin.com/in/pchalasani/) is available for consulting\n(advisory/development): pchalasani at gmail dot com.\n\nSponsorship is also accepted via [GitHub Sponsors](https://github.com/sponsors/langroid)\n\n**Questions, Feedback, Ideas? Join us on [Discord](https://discord.gg/ZU36McDgDs)!**\n\n# Quick glimpse of coding with Langroid\nThis is just a teaser; there's much more, like function-calling/tools, \nMulti-Agent Collaboration, Structured Information Extraction, DocChatAgent \n(RAG), SQLChatAgent, non-OpenAI local/remote LLMs, etc. Scroll down or see docs for more.\nSee the Langroid Quick-Start [Colab](https://colab.research.google.com/github/langroid/langroid/blob/main/examples/Langroid_quick_start.ipynb)\nthat builds up to a 2-agent information-extraction example using the OpenAI ChatCompletion API. \nSee also this [version](https://colab.research.google.com/drive/190Tk7t4AdY1P9F_NlZ33-YEoGnHweQQ0) that uses the OpenAI Assistants API instead.\n\n:fire: just released! [Example](https://github.com/langroid/langroid-examples/blob/main/examples/docqa/chat-multi-extract-local.py) \nscript showing how you can use Langroid multi-agents and tools\nto extract structured information from a document using **only a local LLM**\n(Mistral-7b-instruct-v0.2).\n\n```python\nimport langroid as lr\nimport langroid.language_models as lm\n\n# set up LLM\nllm_cfg = lm.OpenAIGPTConfig( # or OpenAIAssistant to use Assistant API \n  # any model served via an OpenAI-compatible API\n  chat_model=lm.OpenAIChatModel.GPT4o, # or, e.g., \"ollama/mistral\"\n)\n# use LLM directly\nmdl = lm.OpenAIGPT(llm_cfg)\nresponse = mdl.chat(\"What is the capital of Ontario?\", max_tokens=10)\n\n# use LLM in an Agent\nagent_cfg = lr.ChatAgentConfig(llm=llm_cfg)\nagent = lr.ChatAgent(agent_cfg)\nagent.llm_response(\"What is the capital of China?\") \nresponse = agent.llm_response(\"And India?\") # maintains conversation state \n\n# wrap Agent in a Task to run interactive loop with user (or other agents)\ntask = lr.Task(agent, name=\"Bot\", system_message=\"You are a helpful assistant\")\ntask.run(\"Hello\") # kick off with user saying \"Hello\"\n\n# 2-Agent chat loop: Teacher Agent asks questions to Student Agent\nteacher_agent = lr.ChatAgent(agent_cfg)\nteacher_task = lr.Task(\n  teacher_agent, name=\"Teacher\",\n  system_message=\"\"\"\n    Ask your student concise numbers questions, and give feedback. \n    Start with a question.\n    \"\"\"\n)\nstudent_agent = lr.ChatAgent(agent_cfg)\nstudent_task = lr.Task(\n  student_agent, name=\"Student\",\n  system_message=\"Concisely answer the teacher's questions.\",\n  single_round=True,\n)\n\nteacher_task.add_sub_task(student_task)\nteacher_task.run()\n```\n\n# :fire: Updates/Releases\n\n<details>\n<summary> <b>Click to expand</b></summary>\n\n- **Aug 2025:**\n  - [0.59.0](https://github.com/langroid/langroid/releases/tag/0.59.0) Complete Pydantic V2 Migration - \n    5-50x faster validation, modern Python patterns, 100% backward compatible.\n- **Jul 2025:**\n  - [0.58.0](https://github.com/langroid/langroid/releases/tag/0.58.0) Crawl4AI integration - \n    browser-based web crawling with Playwright for JavaScript-heavy sites, no API key required (thank you @abab-dev!).\n  - [0.57.0](https://github.com/langroid/langroid/releases/tag/0.57.0) HTML Logger for interactive task visualization - \n    self-contained HTML logs with collapsible entries, auto-refresh, and persistent UI state.\n- **Jun 2025:**\n  - [0.56.0](https://github.com/langroid/langroid/releases/tag/0.56.0) `TaskTool` for delegating tasks to sub-agents - \n    enables agents to spawn sub-agents with specific tools and configurations.\n  - [0.55.0](https://github.com/langroid/langroid/releases/tag/0.55.0) Event-based task termination with `done_sequences` - \n    declarative task completion using event patterns.\n  - [0.54.0](https://github.com/langroid/langroid/releases/tag/0.54.0) Portkey AI Gateway support - access 200+ models \n    across providers through unified API with caching, retries, observability.\n- **Mar-Apr 2025:**\n  - [0.53.0](https://github.com/langroid/langroid/releases/tag/0.53.0) MCP Tools Support.\n  - [0.52.0](https://github.com/langroid/langroid/releases/tag/0.52.0) Multimodal support, i.e. allow PDF, image \n    inputs to LLM.\n  - [0.51.0](https://github.com/langroid/langroid/releases/tag/0.51.0) `LLMPdfParser`, generalizing \n    `GeminiPdfParser` to parse documents directly with LLM.\n  - [0.50.0](https://github.com/langroid/langroid/releases/tag/0.50.0) Structure-aware Markdown chunking with chunks \n    enriched by section headers.\n  - [0.49.0](https://github.com/langroid/langroid/releases/tag/0.49.0) Enable easy switch to LiteLLM Proxy-server \n  - [0.48.0](https://github.com/langroid/langroid/releases/tag/0.48.0) Exa Crawler, Markitdown Parser\n  - [0.47.0](https://github.com/langroid/langroid/releases/tag/0.47.0) Support Firecrawl URL scraper/crawler - \n    thanks @abab-dev\n  - [0.46.0](https://github.com/langroid/langroid/releases/tag/0.46.0) Support LangDB LLM Gateway - thanks @MrunmayS.\n  - [0.45.0](https://github.com/langroid/langroid/releases/tag/0.45.0) Markdown parsing with `Marker` - thanks @abab-dev\n  - [0.44.0](https://github.com/langroid/langroid/releases/tag/0.44.0) Late imports to reduce startup time. Thanks \n    @abab-dev\n- **Feb 2025:**\n  - [0.43.0](https://github.com/langroid/langroid/releases/tag/0.43.0): `GeminiPdfParser` for parsing PDF using \n    Gemini LLMs - Thanks @abab-dev.\n  - [0.42.0](https://github.com/langroid/langroid/releases/tag/0.42.0): `markitdown` parser for `pptx,xlsx,xls` files \n    Thanks @abab-dev.\n  - [0.41.0](https://github.com/langroid/langroid/releases/tag/0.41.0): `pinecone` vector-db (Thanks @coretado), \n    `Tavily` web-search (Thanks @Sozhan308), `Exa` web-search (Thanks @MuddyHope).\n  - [0.40.0](https://github.com/langroid/langroid/releases/tag/0.40.0): `pgvector` vector-db. Thanks @abab-dev.\n  - [0.39.0](https://github.com/langroid/langroid/releases/tag/0.39.0): `ChatAgentConfig.handle_llm_no_tool` for \n    handling LLM \"forgetting\" to use a tool.\n  - [0.38.0](https://github.com/langroid/langroid/releases/tag/0.38.0): Gemini embeddings - Thanks @abab-dev)\n  - [0.37.0](https://github.com/langroid/langroid/releases/tag/0.37.0): New PDF Parsers: `docling`, `pymupdf4llm`\n- **Jan 2025:**\n  - [0.36.0](https://github.com/langroid/langroid/releases/tag/0.36.0): Weaviate vector-db support (thanks @abab-dev).\n  - [0.35.0](https://github.com/langroid/langroid/releases/tag/0.35.0): Capture/Stream reasoning content from \n    Reasoning LLMs (e.g. DeepSeek-R1, OpenAI o1) in addition to final answer.\n  - [0.34.0](https://github.com/langroid/langroid/releases/tag/0.34.0): DocChatAgent \n    chunk enrichment to improve retrieval. (collaboration with @dfm88). \n  - [0.33.0](https://github.com/langroid/langroid/releases/tag/0.33.3) Move from Poetry to uv! (thanks @abab-dev).\n  - [0.32.0](https://github.com/langroid/langroid/releases/tag/0.32.0) DeepSeek v3 support.\n- **Dec 2024:**\n  - [0.31.0](https://github.com/langroid/langroid/releases/tag/0.31.0) Azure OpenAI Embeddings\n  - [0.30.0](https://github.com/langroid/langroid/releases/tag/0.30.0) Llama-cpp embeddings (thanks @Kwigg).\n  - [0.29.0](https://github.com/langroid/langroid/releases/tag/0.29.0) Custom Azure OpenAI Client (thanks \n    @johannestang).\n  - [0.28.0](https://github.com/langroid/langroid/releases/tag/0.28.0) `ToolMessage`: `_handler` field to override \ndefault handler method name in `request` field (thanks @alexagr).\n  - [0.27.0](https://github.com/langroid/langroid/releases/tag/0.27.0) OpenRouter Support.\n  - [0.26.0](https://github.com/langroid/langroid/releases/tag/0.26.0) Update to latest Chainlit.\n  - [0.25.0](https://github.com/langroid/langroid/releases/tag/0.25.0) True Async Methods for agent and \n    user-response (thanks @alexagr).\n- **Nov 2024:**\n  - **[0.24.0](https://langroid.github.io/langroid/notes/structured-output/)**: \n     Enables support for `Agent`s with strict JSON schema output format on compatible LLMs and strict mode for the OpenAI tools API.\n    (thanks @nilspalumbo).\n  - **[0.23.0](https://langroid.github.io/langroid/tutorials/local-llm-setup/#local-llms-hosted-on-glhfchat)**: \n      support for LLMs (e.g. `Qwen2.5-Coder-32b-Instruct`) hosted on glhf.chat \n  - **[0.22.0](https://langroid.github.io/langroid/notes/large-tool-results/)**: \n     Optional parameters to truncate large tool results.\n  - **[0.21.0](https://langroid.github.io/langroid/notes/gemini/)** Direct support for Gemini models via OpenAI client instead of using LiteLLM.\n  - **[0.20.0](https://github.com/langroid/langroid/releases/tag/0.20.0)** Support for \n    ArangoDB Knowledge Graphs.\n- **Oct 2024:**\n  - **[0.18.0]** [LLMConfig.async_stream_quiet](https://langroid.github.io/langroid/notes/async-streaming/) flag to \n    turn off LLM output in async + stream mode.\n  - **[0.17.0]** XML-based tools, see [docs](https://langroid.github.io/langroid/notes/xml-tools/).\n- **Sep 2024:**\n  - **[0.16.0](https://github.com/langroid/langroid/releases/tag/0.16.0)**  Support for OpenAI `o1-mini` and `o1-preview` models.\n  - **[0.15.0](https://github.com/langroid/langroid/releases/tag/0.15.0)** Cerebras API support -- run llama-3.1 models hosted on Cerebras Cloud (very fast inference).\n  - **[0.14.0](https://github.com/langroid/langroid/releases/tag/0.14.0)** `DocChatAgent` uses Reciprocal Rank Fusion (RRF) to rank chunks retrieved by different methods.\n  - **[0.12.0](https://github.com/langroid/langroid/releases/tag/0.12.0)** `run_batch_task` new option -- `stop_on_first_result` - allows termination of batch as soon as any task returns a result.  \n- **Aug 2024:**\n  - **[0.11.0](https://github.com/langroid/langroid/releases/tag/0.11.0)** Polymorphic `Task.run(), Task.run_async`.\n  - **[0.10.0](https://github.com/langroid/langroid/releases/tag/0.10.0)** Allow tool handlers to return arbitrary result type, including other tools.\n  - **[0.9.0](https://github.com/langroid/langroid/releases/tag/0.9.0)** Orchestration Tools, to signal various task statuses, and to pass messages between agents.\n  - **[0.7.0](https://github.com/langroid/langroid/releases/tag/0.7.0)** OpenAI tools API support, including multi-tools.\n- **Jul 2024:**\n  - **[0.3.0](https://github.com/langroid/langroid/releases/tag/0.3.0)**: Added [FastEmbed](https://qdrant.github.io/fastembed/qdrant/Usage_With_Qdrant/) embeddings from Qdrant\n- **Jun 2024:**\n  - **0.2.0:** Improved lineage tracking, granular sub-task configs, and a new tool, `RewindTool`, \n    that lets an agent \"rewind and redo\" a past message (and all dependent messages are cleared out \n    thanks to the lineage tracking). Read notes [here](https://github.com/langroid/langroid/releases/tag/0.2.0).\n- **May 2024:** \n  - **Slimmer langroid**: All document-parsers (i.e. pdf, doc, docx) and most \n    vector-databases (except qdrant) \n    are now optional/extra dependencies, which helps reduce build size, script \n    start-up time, and install time. For convenience various grouping of \"extras\" are \n    provided, e.g. `doc-chat`, `db` (for database-related dependencies). See updated \n    install instructions below and in the docs.\n  - **Few-shot examples** for tools: when defining a [ToolMessage](https://langroid.github.io/langroid/quick-start/chat-agent-tool/#example-find-the-smallest-number-in-a-list), previously you were able to include a classmethod named `examples`,\n    and a random example from this list would be used to generate a 1-shot example \n    for the LLM. This has been improved so you can now supply a list of examples \n    where each example is either a tool instance, or a tuple of (description, \n    tool instance), where the description is a \"thought\" that leads the LLM to use \n    the tool (see example in the [docs](https://langroid.github.io/langroid/quick-start/chat-agent-tool/#example-find-the-smallest-number-in-a-list)). In some scenarios this can improve LLM tool \n    generation accuracy. Also, now instead of a random example, ALL examples are used to generate few-shot \n    examples.     \n  - [Infinite loop detection](https://github.com/langroid/langroid/blob/0ed30eb467b00d5eaf2933b577a4b2cc37de1aa1/langroid/agent/task.py#L1121) for task loops of cycle-length <= 10 (configurable \n    in [`TaskConfig`](https://langroid.github.io/langroid/reference/agent/task/#langroid.agent.task.TaskConfig). Only detects _exact_ loops, rather than _approximate_ loops where the entities are saying essentially similar (but not exactly the same) things repeatedly.\n  - \"@\"-addressing: any entity can address any other by name, which can be the name \n    of an agent's responder (\"llm\", \"user\", \"agent\") or a sub-task name. This is a \n    simpler alternative to the `RecipientTool` mechanism, with the tradeoff that \n    since it's not a tool, there's no way to enforce/remind the LLM to explicitly \n    specify an addressee (in scenarios where this is important).\n  - [Much-Improved Citation](https://github.com/langroid/langroid/issues/477) \n    generation and display when using `DocChatAgent`.\n  - `gpt-4o` is now the default LLM throughout; Update tests and examples to work \n    with this LLM; use tokenizer corresponding to the LLM.\n  - `gemini 1.5 pro` support via `litellm`\n  - `QdrantDB:` update to support learned sparse embeddings.\n- **Apr 2024:**\n  - **0.1.236**: Support for open LLMs hosted on Groq, e.g. specify \n    `chat_model=\"groq/llama3-8b-8192\"`.\n      See [tutorial](https://langroid.github.io/langroid/tutorials/local-llm-setup/).\n  - **0.1.235**: `Task.run(), Task.run_async(), run_batch_tasks` have `max_cost` \n    and `max_tokens` params to exit when tokens or cost exceed a limit. The result \n    `ChatDocument.metadata` now includes a `status` field which is a code indicating a \n     task completion reason code. Also `task.run()` etc can be invoked with an explicit\n     `session_id` field which is used as a key to look up various settings in Redis cache.\n    Currently only used to look up \"kill status\" - this allows killing a running task, either by `task.kill()`\n    or by the classmethod `Task.kill_session(session_id)`.\n    For example usage, see the `test_task_kill` in [tests/main/test_task.py](https://github.com/langroid/langroid/blob/main/tests/main/test_task.py)\n  \n- **Mar 2024:**\n  - **0.1.216:** Improvements to allow concurrent runs of `DocChatAgent`, see the\n    [`test_doc_chat_agent.py`](https://github.com/langroid/langroid/blob/main/tests/main/test_doc_chat_agent.py)\n    in particular the `test_doc_chat_batch()`;\n    New task run utility: [`run_batch_task_gen`](https://github.com/langroid/langroid/blob/main/langroid/agent/batch.py) \n    where a task generator can be specified, to generate one task per input. \n  - **0.1.212:** ImagePdfParser: support for extracting text from image-based PDFs.\n    (this means `DocChatAgent` will now work with image-pdfs).\n  - **0.1.194 - 0.1.211:** Misc fixes, improvements, and features:\n    - Big enhancement in RAG performance (mainly, recall) due to a [fix in Relevance \n      Extractor](https://github.com/langroid/langroid/releases/tag/0.1.209)\n    - `DocChatAgent` [context-window fixes](https://github.com/langroid/langroid/releases/tag/0.1.208)\n    - Anthropic/Claude3 support via Litellm\n    - `URLLoader`: detect file time from header when URL doesn't end with a \n      recognizable suffix like `.pdf`, `.docx`, etc.\n    - Misc lancedb integration fixes\n    - Auto-select embedding config based on whether `sentence_transformer` module is available.\n    - Slim down dependencies, make some heavy ones optional, e.g. `unstructured`, \n      `haystack`, `chromadb`, `mkdocs`, `huggingface-hub`, `sentence-transformers`.\n    - Easier top-level imports from `import langroid as lr`\n    - Improve JSON detection, esp from weak LLMs\n- **Feb 2024:** \n  - **0.1.193:** Support local LLMs using Ollama's new OpenAI-Compatible server: \n     simply specify `chat_model=\"ollama/mistral\"`. See [release notes](https://github.com/langroid/langroid/releases/tag/0.1.193).\n  - **0.1.183:** Added Chainlit support via [callbacks](https://github.com/langroid/langroid/blob/main/langroid/agent/callbacks/chainlit.py). \n   See [examples](https://github.com/langroid/langroid/tree/main/examples/chainlit).\n- **Jan 2024:**\n  - **0.1.175** \n    - [Neo4jChatAgent](https://github.com/langroid/langroid/tree/main/langroid/agent/special/neo4j) to chat with a neo4j knowledge-graph.\n      (Thanks to [Mohannad](https://github.com/Mohannadcse)!). The agent uses tools to query the Neo4j schema and translate user queries to Cypher queries,\n      and the tool handler executes these queries, returning them to the LLM to compose\n      a natural language response (analogous to how `SQLChatAgent` works).\n      See example [script](https://github.com/langroid/langroid/tree/main/examples/kg-chat) using this Agent to answer questions about Python pkg dependencies.\n    - Support for `.doc` file parsing (in addition to `.docx`)\n    - Specify optional [`formatter` param](https://github.com/langroid/langroid/releases/tag/0.1.171) \n      in `OpenAIGPTConfig` to ensure accurate chat formatting for local LLMs. \n  - **[0.1.157](https://github.com/langroid/langroid/releases/tag/0.1.157):** `DocChatAgentConfig` \n     has a new param: `add_fields_to_content`, to specify additional document fields to insert into \n     the main `content` field, to help improve retrieval.\n  - **[0.1.156](https://github.com/langroid/langroid/releases/tag/0.1.156):** New Task control signals\n     PASS_TO, SEND_TO; VectorStore: Compute Pandas expression on documents; LanceRAGTaskCreator creates 3-agent RAG system with Query Planner, Critic and RAG Agent.\n- **Dec 2023:**\n  - **0.1.154:** (For details see release notes of [0.1.149](https://github.com/langroid/langroid/releases/tag/0.1.149)\n      and [0.1.154](https://github.com/langroid/langroid/releases/tag/0.1.154)). \n    - `DocChatAgent`: Ingest Pandas dataframes and filtering.\n    - `LanceDocChatAgent` leverages `LanceDB` vector-db for efficient vector search\n     and full-text search and filtering.\n    - Improved task and multi-agent control mechanisms\n    - `LanceRAGTaskCreator` to create a 2-agent system consisting of a `LanceFilterAgent` that\n      decides a filter and rephrase query to send to a RAG agent.\n  - **[0.1.141](https://github.com/langroid/langroid/releases/tag/0.1.141):**\n    API Simplifications to reduce boilerplate:\n    auto-select an available OpenAI model (preferring gpt-4o), simplifies defaults.\n    Simpler `Task` initialization with default `ChatAgent`.\n- **Nov 2023:**\n  - **[0.1.126](https://github.com/langroid/langroid/releases/tag/0.1.126):**\n     OpenAIAssistant agent: Caching Support. \n  - **0.1.117:** Support for OpenAI Assistant API tools: Function-calling, \n    Code-intepreter, and Retriever (RAG), file uploads. These work seamlessly \n    with Langroid's task-orchestration.\n    Until docs are ready, it's best to see these usage examples:\n    \n    - **Tests:**\n      - [test_openai_assistant.py](https://github.com/langroid/langroid/blob/main/tests/main/test_openai_assistant.py)\n      - [test_openai_assistant_async.py](https://github.com/langroid/langroid/blob/main/tests/main/test_openai_assistant_async.py)\n\n    - **Example scripts:**\n      - [The most basic chat app](https://github.com/langroid/langroid/blob/main/examples/basic/oai-asst-chat.py)\n      - [Chat with code interpreter](https://github.com/langroid/langroid/blob/main/examples/basic/oai-code-chat.py)\n      - [Chat with retrieval (RAG)](https://github.com/langroid/langroid/blob/main/examples/docqa/oai-retrieval-assistant.py)\n      - [2-agent RAG chat](https://github.com/langroid/langroid/blob/main/examples/docqa/oai-retrieval-2.py)\n  - **0.1.112:** [`OpenAIAssistant`](https://github.com/langroid/langroid/blob/main/langroid/agent/openai_assistant.py) is a subclass of `ChatAgent` that \n    leverages the new OpenAI Assistant API. It can be used as a drop-in \n    replacement for `ChatAgent`, and relies on the Assistant API to\n    maintain conversation state, and leverages persistent threads and \n    assistants to reconnect to them if needed. Examples: \n    [`test_openai_assistant.py`](https://github.com/langroid/langroid/blob/main/tests/main/test_openai_assistant.py),\n    [`test_openai_assistant_async.py`](https://github.com/langroid/langroid/blob/main/tests/main/test_openai_assistant_async.py)\n  - **0.1.111:** Support latest OpenAI model: `GPT4_TURBO`\n(see [test_llm.py](tests/main/test_llm.py) for example usage)\n  - **0.1.110:** Upgrade from OpenAI v0.x to v1.1.1 (in preparation for \n    Assistants API and more); (`litellm` temporarily disabled due to OpenAI \n    version conflict).\n- **Oct 2023:**\n  - **0.1.107:** `DocChatAgent` re-rankers: `rank_with_diversity`, `rank_to_periphery` (lost in middle).\n  - **0.1.102:** `DocChatAgentConfig.n_neighbor_chunks > 0` allows returning context chunks around match.\n  - **0.1.101:** `DocChatAgent` uses `RelevanceExtractorAgent` to have \n    the LLM extract relevant portions of a chunk using \n    sentence-numbering, resulting in huge speed up and cost reduction \n    compared to the naive \"sentence-parroting\" approach (writing out full \n    sentences out relevant whole sentences) which `LangChain` uses in their \n    `LLMChainExtractor`.\n  - **0.1.100:** API update: all of Langroid is accessible with a single import, i.e. `import langroid as lr`. See the [documentation](\"https://langroid.github.io/langroid/\") for usage.\n  - **0.1.99:** Convenience batch functions to run tasks, agent methods on a list of inputs concurrently in async mode. See examples in [test_batch.py](https://github.com/langroid/langroid/blob/main/tests/main/test_batch.py).\n  - **0.1.95:** Added support for [Momento Serverless Vector Index](https://docs.momentohq.com/vector-index)\n  - **0.1.94:** Added support for [LanceDB](https://lancedb.github.io/lancedb/) vector-store -- allows vector, Full-text, SQL search.\n  - **0.1.84:** Added [LiteLLM](https://docs.litellm.ai/docs/providers), so now Langroid can be used with over 100 LLM providers (remote or local)! \n     See guide [here](https://langroid.github.io/langroid/tutorials/non-openai-llms/).\n- **Sep 2023:**\n  - **0.1.78:** Async versions of several Task, Agent and LLM methods; \n      Nested Pydantic classes are now supported for LLM Function-calling, Tools, Structured Output.    \n  - **0.1.76:** DocChatAgent: support for loading `docx` files (preliminary).\n  - **0.1.72:** Many improvements to DocChatAgent: better embedding model, \n          hybrid search to improve retrieval, better pdf parsing, re-ranking retrieved results with cross-encoders. \n  - **Use with local LLama Models:** see tutorial [here](https://langroid.github.io/langroid/blog/2023/09/14/using-langroid-with-local-llms/)\n  - **Langroid Blog/Newsletter Launched!**: First post is [here](https://substack.com/notes/post/p-136704592) -- Please subscribe to stay updated. \n  - **0.1.56:** Support Azure OpenAI. \n  - **0.1.55:** Improved [`SQLChatAgent`](https://github.com/langroid/langroid/blob/main/langroid/agent/special/sql/sql_chat_agent.py) that efficiently retrieves relevant schema info when translating natural language to SQL.  \n- **Aug 2023:**\n  - **[Hierarchical computation](https://langroid.github.io/langroid/examples/agent-tree/)** example using Langroid agents and task orchestration.\n  - **0.1.51:** Support for global state, see [test_global_state.py](tests/main/test_global_state.py).\n  - **:whale: Langroid Docker image**, available, see instructions below.\n  - [**RecipientTool**](langroid/agent/tools/recipient_tool.py) enables (+ enforces) LLM to \nspecify an intended recipient when talking to 2 or more agents. \nSee [this test](tests/main/test_recipient_tool.py) for example usage.\n  - **Example:** [Answer questions](examples/docqa/chat-search.py) using Google Search + vecdb-retrieval from URL contents. \n  - **0.1.39:** [`GoogleSearchTool`](langroid/agent/tools/google_search_tool.py) to enable Agents (their LLM) to do Google searches via function-calling/tools.\n    See [this chat example](examples/basic/chat-search.py) for how easy it is to add this tool to an agent.\n  - **Colab notebook** to try the quick-start examples: [![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langroid/langroid/blob/main/examples/Langroid_quick_start.ipynb) \n  - **0.1.37:** Added [`SQLChatAgent`](langroid/agent/special/sql_chat_agent.py) -- thanks to our latest contributor [Rithwik Babu](https://github.com/rithwikbabu)!\n  - Multi-agent Example: [Autocorrect chat](examples/basic/autocorrect.py)\n- **July 2023:** \n  - **0.1.30:** Added [`TableChatAgent`](langroid/agent/special/table_chat_agent.py) to \n    [chat](examples/data-qa/table_chat.py) with tabular datasets (dataframes, files, URLs): LLM generates Pandas code,\n    and code is executed using Langroid's tool/function-call mechanism. \n  - **Demo:** 3-agent system for Audience [Targeting](https://langroid.github.io/langroid/demos/targeting/audience-targeting/).\n  - **0.1.27**: Added [support](langroid/cachedb/momento_cachedb.py) \n    for [Momento Serverless Cache](https://www.gomomento.com/) as an alternative to Redis.\n  - **0.1.24**: [`DocChatAgent`](langroid/agent/special/doc_chat_agent.py) \n    now [accepts](langroid/parsing/document_parser.py) PDF files or URLs.\n\n</details>\n\n# :rocket: Demo\nSuppose you want to extract structured information about the key terms \nof a commercial lease document. You can easily do this with Langroid using a two-agent system,\nas we show in the [langroid-examples](https://github.com/langroid/langroid-examples/blob/main/examples/docqa/chat_multi_extract.py) repo.\n(See [this script](https://github.com/langroid/langroid-examples/blob/main/examples/docqa/chat-multi-extract-local.py)\nfor a version with the same functionality using a local Mistral-7b model.)\nThe demo showcases just a few of the many features of Langroid, such as:\n- Multi-agent collaboration: `LeaseExtractor` is in charge of the task, and its LLM (GPT4) generates questions \nto be answered by the `DocAgent`.\n- Retrieval augmented question-answering, with **source-citation**: `DocAgent` LLM (GPT4) uses retrieval from a vector-store to \nanswer the `LeaseExtractor`'s questions, cites the specific excerpt supporting the answer. \n- Function-calling (also known as tool/plugin): When it has all the information it \nneeds, the `LeaseExtractor` LLM presents the information in a structured \nformat using a Function-call. \n\nHere is what it looks like in action \n(a pausable mp4 video is [here](https://vimeo.com/871429249)).\n\n![Demo](docs/assets/demos/lease-extractor-demo.gif)\n\n\n# :zap: Highlights\n(For a more up-to-date list see the \n[Updates/Releases](https://github.com/langroid/langroid?tab=readme-ov-file#fire-updatesreleases) \nsection above)\n- **Agents as first-class citizens:** The [Agent](https://langroid.github.io/langroid/reference/agent/base/#langroid.agent.base.Agent) class encapsulates LLM conversation state,\n  and optionally a vector-store and tools. Agents are a core abstraction in Langroid;\n  Agents act as _message transformers_, and by default provide 3 _responder_ methods, one corresponding to each entity: LLM, Agent, User.\n- **Tasks:** A [Task](https://langroid.github.io/langroid/reference/agent/task/) class wraps an Agent, and gives the agent instructions (or roles, or goals), \n  manages iteration over an Agent's responder methods, \n  and orchestrates multi-agent interactions via hierarchical, recursive\n  task-delegation. The `Task.run()` method has the same \n  type-signature as an Agent's responder's methods, and this is key to how \n  a task of an agent can delegate to other sub-tasks: from the point of view of a Task,\n  sub-tasks are simply additional responders, to be used in a round-robin fashion \n  after the agent's own responders.\n- **Modularity, Reusability, Loose coupling:** The `Agent` and `Task` abstractions allow users to design\n  Agents with specific skills, wrap them in Tasks, and combine tasks in a flexible way.\n- **LLM Support**: Langroid supports OpenAI LLMs as well as LLMs from hundreds of \nproviders ([local/open](https://langroid.github.io/langroid/tutorials/local-llm-setup/) or [remote/commercial](https://langroid.github.io/langroid/tutorials/non-openai-llms/)) via proxy libraries and local model servers\nsuch as [ollama](https://github.com/ollama), [oobabooga](https://github.com/oobabooga/text-generation-webui), \n  [LiteLLM](https://docs.litellm.ai/docs/providers) that in effect mimic the OpenAI API. See the [supported LLMs](https://langroid.github.io/langroid/tutorials/supported-models/). \n- **Caching of LLM responses:** Langroid supports [Redis](https://redis.com/try-free/) to cache LLM responses.\n- **Vector-stores**: [Qdrant](https://qdrant.tech/), [Chroma](https://www.trychroma.com/), LanceDB, Pinecone, PostgresDB (PGVector), Weaviate are currently supported.\n  Vector stores allow for Retrieval-Augmented-Generation (RAG).\n- **Grounding and source-citation:** Access to external documents via vector-stores \n   allows for grounding and source-citation.\n- **Observability, Logging, Lineage:** Langroid generates detailed logs of multi-agent interactions and\n  maintains provenance/lineage of messages, so that you can trace back\n  the origin of a message.\n- **[Tools/Plugins/Function-calling](https://langroid.github.io/langroid/quick-start/chat-agent-tool/)**:\n  Langroid supports OpenAI's [function calling](https://platform.openai.com/docs/guides/gpt/function-calling), as\n  well as an equivalent `ToolMessage` mechanism which works with\n  any LLM, not just OpenAI's.\n  Function calling and tools have the same developer-facing interface, implemented\n  using [Pydantic](https://docs.pydantic.dev/latest/),\n  which makes it very easy to define tools/functions and enable agents\n  to use them. Benefits of using Pydantic are that you never have to write\n  complex JSON specs for function calling, and when the LLM\n  hallucinates malformed JSON, the Pydantic error message is sent back to\n  the LLM so it can fix it.\n\n--- \n\n# :gear: Installation and Setup\n\n### Install `langroid`\nLangroid requires Python 3.11+. We recommend using a virtual environment.\nUse `pip` to install a bare-bones slim version of `langroid` (from PyPi) to your virtual \nenvironment:\n```bash\npip install langroid\n```\nThe core Langroid package lets you use OpenAI Embeddings models via their API. \nIf you instead want to use the `sentence-transformers` embedding models from HuggingFace, \ninstall Langroid like this: \n```bash\npip install \"langroid[hf-embeddings]\"\n```\nFor many practical scenarios, you may need additional optional dependencies:\n- To use various document-parsers, install langroid with the `doc-chat` extra:\n    ```bash\n    pip install \"langroid[doc-chat]\"\n    ```\n- For \"chat with databases\", use the `db` extra:\n    ```bash\n    pip install \"langroid[db]\"\n    ```\n- You can specify multiple extras by separating them with commas, e.g.:\n    ```bash\n    pip install \"langroid[doc-chat,db]\"\n    ```\n- To simply install _all_ optional dependencies, use the `all` extra (but note that this will result in longer load/startup times and a larger install size):\n    ```bash\n    pip install \"langroid[all]\"\n    ```\n<details>\n<summary><b>Optional Installs for using SQL Chat with a PostgreSQL DB </b></summary>\n\nIf you are using `SQLChatAgent` \n(e.g. the script [`examples/data-qa/sql-chat/sql_chat.py`](examples/data-qa/sql-chat/sql_chat.py)),\nwith a postgres db, you will need to:\n\n- Install PostgreSQL dev libraries for your platform, e.g.\n  - `sudo apt-get install libpq-dev` on Ubuntu,\n  - `brew install postgresql` on Mac, etc.\n- Install langroid with the postgres extra, e.g. `pip install langroid[postgres]`\n  or `poetry add \"langroid[postgres]\"` or `poetry install -E postgres`,\n  (or the corresponding `uv` versions, e.g. `uv add \"langroid[postgres]\"`\n  or `uv pip install langroid[postgres]`).\n  If this gives you an error, try `pip install psycopg2-binary` in your virtualenv.\n</details>\n\n:memo: If you get strange errors involving `mysqlclient`, try doing `pip uninstall mysqlclient` followed by `pip install mysqlclient`.\n\n### Claude Code Plugin (Optional)\n\nThis plugin provides two skills:\n\n- `langroid:patterns` - Your Claude Code agent can leverage this skill to produce\n  Langroid multi-agent code using proper design patterns.\n- `langroid:add-pattern` - The agent can use this skill to record new patterns it\n  learns, for future reference, either autonomously or when prompted by the user.\n\n**Step 1: Add the Langroid marketplace**\n\nFrom terminal:\n```bash\nclaude plugin marketplace add langroid/langroid\n```\n\nOr within Claude Code:\n```\n/plugin marketplace add langroid/langroid\n```\n\n**Step 2: Install the Langroid plugin**\n\nFrom terminal:\n```bash\nclaude plugin install langroid@langroid\n```\n\nOr within Claude Code:\n```\n/plugin install langroid@langroid\n```\n\nOnce installed, simply ask your Claude Code agent to implement Langroid patterns in\nnatural language, e.g.,\n\n> set up a Langroid agent so it uses the EditTool, and wrap it in a task that ends as soon as the tool is generated\n\nand it will automatically use the `langroid:patterns` skill to follow the right design pattern.\n\nYou can also ask Claude Code to record a new pattern when you discover one, e.g.,\n\n> record this as a new Langroid pattern for setting up MCP tools\n\n\n### Set up environment variables (API keys, etc)\n\nTo get started, all you need is an OpenAI API Key.\nIf you don't have one, see [this OpenAI Page](https://platform.openai.com/docs/quickstart).\n(Note that while this is the simplest way to get started, Langroid works with practically any LLM, not just those from OpenAI. \nSee the guides to using [Open/Local LLMs](https://langroid.github.io/langroid/tutorials/local-llm-setup/), \nand other [non-OpenAI](https://langroid.github.io/langroid/tutorials/non-openai-llms/) proprietary LLMs.) \n\nIn the root of the repo, copy the `.env-template` file to a new file `.env`: \n```bash\ncp .env-template .env\n```\nThen insert your OpenAI API Key. \nYour `.env` file should look like this (the organization is optional \nbut may be required in some scenarios).\n```bash\nOPENAI_API_KEY=your-key-here-without-quotes\nOPENAI_ORGANIZATION=optionally-your-organization-id\n````\n\nAlternatively, you can set this as an environment variable in your shell\n(you will need to do this every time you open a new shell):\n```bash\nexport OPENAI_API_KEY=your-key-here-without-quotes\n```\n\n\n<details>\n<summary><b>Optional Setup Instructions (click to expand) </b></summary>\n\nAll of the following environment variable settings are optional, and some are only needed \nto use specific features (as noted below).\n\n- **Qdrant** Vector Store API Key, URL. This is only required if you want to use Qdrant cloud.\n  Alternatively [Chroma](https://docs.trychroma.com/) or [LanceDB](https://lancedb.com/) are also currently supported. \n  We use the local-storage version of Chroma, so there is no need for an API key.\n- **Redis** Password, host, port: This is optional, and only needed to cache LLM API responses\n  using Redis Cloud. Redis [offers](https://redis.com/try-free/) a free 30MB Redis account\n  which is more than sufficient to try out Langroid and even beyond.\n  If you don't set up these, Langroid will use a pure-python \n  Redis in-memory cache via the [Fakeredis](https://fakeredis.readthedocs.io/en/latest/) library.\n- **Momento** Serverless Caching of LLM API responses (as an alternative to Redis). \n   To use Momento instead of Redis:\n  - enter your Momento Token in the `.env` file, as the value of `MOMENTO_AUTH_TOKEN` (see example file below),\n  - in the `.env` file set `CACHE_TYPE=momento` (instead of `CACHE_TYPE=redis` which is the default).\n- **GitHub** Personal Access Token (required for apps that need to analyze git\n  repos; token-based API calls are less rate-limited). See this\n  [GitHub page](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).\n- **Google Custom Search API Credentials:** Only needed to enable an Agent to use the `GoogleSearchTool`.\n  To use Google Search as an LLM Tool/Plugin/function-call, \n  you'll need to set up \n  [a Google API key](https://developers.google.com/custom-search/v1/introduction#identify_your_application_to_google_with_api_key),\n  then [setup a Google Custom Search Engine (CSE) and get the CSE ID](https://developers.google.com/custom-search/docs/tutorial/creatingcse).\n  (Documentation for these can be challenging, we suggest asking GPT4 for a step-by-step guide.)\n  After obtaining these credentials, store them as values of \n  `GOOGLE_API_KEY` and `GOOGLE_CSE_ID` in your `.env` file. \n  Full documentation on using this (and other such \"stateless\" tools) is coming soon, but \n  in the meantime take a peek at this [chat example](examples/basic/chat-search.py), which \n  shows how you can easily equip an Agent with a `GoogleSearchtool`.\n  \n\n\nIf you add all of these optional variables, your `.env` file should look like this:\n```bash\nOPENAI_API_KEY=your-key-here-without-quotes\nGITHUB_ACCESS_TOKEN=your-personal-access-token-no-quotes\nCACHE_TYPE=redis # or momento\nREDIS_PASSWORD=your-redis-password-no-quotes\nREDIS_HOST=your-redis-hostname-no-quotes\nREDIS_PORT=your-redis-port-no-quotes\nMOMENTO_AUTH_TOKEN=your-momento-token-no-quotes # instead of REDIS* variables\nQDRANT_API_KEY=your-key\nQDRANT_API_URL=https://your.url.here:6333 # note port number must be included\nGOOGLE_API_KEY=your-key\nGOOGLE_CSE_ID=your-cse-id\n```\n</details>\n\n<details>\n<summary><b>Optional setup instructions for Microsoft Azure OpenAI(click to expand)</b></summary> \n\nWhen using Azure OpenAI, additional environment variables are required in the \n`.env` file.\nThis page [Microsoft Azure OpenAI](https://learn.microsoft.com/en-us/azure/ai-services/openai/chatgpt-quickstart?tabs=command-line&pivots=programming-language-python#environment-variables)\nprovides more information, and you can set each environment variable as follows:\n\n- `AZURE_OPENAI_API_KEY`, from the value of `API_KEY`\n- `AZURE_OPENAI_API_BASE` from the value of `ENDPOINT`, typically looks like `https://your.domain.azure.com`.\n- For `AZURE_OPENAI_API_VERSION`, you can use the default value in `.env-template`, and latest version can be found [here](https://learn.microsoft.com/en-us/azure/ai-services/openai/whats-new#azure-openai-chat-completion-general-availability-ga)\n- `AZURE_OPENAI_DEPLOYMENT_NAME` is the name of the deployed model, which is defined by the user during the model setup \n- `AZURE_OPENAI_MODEL_NAME` Azure OpenAI allows specific model names when you select the model for your deployment. You need to put precisly the exact model name that was selected. For example, GPT-4 (should be `gpt-4-32k` or `gpt-4`).\n- `AZURE_OPENAI_MODEL_VERSION` is required if `AZURE_OPENAI_MODEL_NAME = gpt=4`, which will assist Langroid to determine the cost of the model  \n</details>\n\n---\n\n# :whale: Docker Instructions\n\nWe provide a containerized version of the [`langroid-examples`](https://github.com/langroid/langroid-examples) \nrepository via this [Docker Image](https://hub.docker.com/r/langroid/langroid).\nAll you need to do is set up environment variables in the `.env` file.\nPlease follow these steps to setup the container:\n\n```bash\n# get the .env file template from `langroid` repo\nwget -O .env https://raw.githubusercontent.com/langroid/langroid/main/.env-template\n\n# Edit the .env file with your favorite editor (here nano), and remove any un-used settings. E.g. there are \"dummy\" values like \"your-redis-port\" etc -- if you are not using them, you MUST remove them.\nnano .env\n\n# launch the container (the appropriate image for your architecture will be pulled automatically)\ndocker run -it --rm  -v ./.env:/langroid/.env langroid/langroid:latest\n\n# Use this command to run any of the scripts in the `examples` directory\npython examples/<Path/To/Example.py> \n``` \n\n\n\n# :tada: Usage Examples\n\nThese are quick teasers to give a glimpse of what you can do with Langroid\nand how your code would look. \n\n:warning: The code snippets below are intended to give a flavor of the code\nand they are **not** complete runnable examples! For that we encourage you to \nconsult the [`langroid-examples`](https://github.com/langroid/langroid-examples) \nrepository.\n\n:information_source:\nThe various LLM prompts and instructions in Langroid\nhave been tested to work well with GPT-4 (and to some extent GPT-4o).\nSwitching to other LLMs (local/open and proprietary) is easy (see guides mentioned above),\nand may suffice for some applications, but in general you may see inferior results\nunless you adjust the prompts and/or the multi-agent setup.\n\n\n:book: Also see the\n[`Getting Started Guide`](https://langroid.github.io/langroid/quick-start/)\nfor a detailed tutorial.\n\n\n\nClick to expand any of the code examples below.\nAll of these can be run in a Colab notebook:\n[![Open in Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/langroid/langroid/blob/main/examples/Langroid_quick_start.ipynb)\n\n<details>\n<summary> <b> Direct interaction with LLM </b> </summary>\n\n```python\nimport langroid.language_models as lm\n\nmdl = lm.OpenAIGPT(\n    lm.OpenAIGPTConfig(\n        chat_model=lm.OpenAIChatModel.GPT4o, # or, e.g.  \"ollama/qwen2.5\"\n    ),\n)\n\nmessages = [\n  lm.LLMMessage(content=\"You are a helpful assistant\",  role=lm.Role.SYSTEM), \n  lm.LLMMessage(content=\"What is the capital of Ontario?\",  role=lm.Role.USER),\n]\n\nresponse = mdl.chat(messages, max_tokens=200)\nprint(response.message)\n```\nSee the guides to use\n([local/open LLMs](https://langroid.github.io/langroid/tutorials/local-llm-setup/) or [remote/commercial LLMs](https://langroid.github.io/langroid/tutorials/non-openai-llms/)).\n</details>\n\n<details>\n<summary> <b> Interaction with non-OpenAI LLM (local or remote) </b> </summary>\nLocal model: if model is served at `http://localhost:8000`:\n\n```python\ncfg = lm.OpenAIGPTConfig(\n  chat_model=\"local/localhost:8000\", \n  chat_context_length=4096\n)\nmdl = lm.OpenAIGPT(cfg)\n# now interact with it as above, or create an Agent + Task as shown below.\n```\n</details>\n\n<details>\n<summary> <b> Define an agent, set up a task, and run it </b> </summary>\n\n```python\nimport langroid as lr\n\nagent = lr.ChatAgent()\n\n# get response from agent's LLM, and put this in an interactive loop...\n# answer = agent.llm_response(\"What is the capital of Ontario?\")\n  # ... OR instead, set up a task (which has a built-in loop) and run it\ntask = lr.Task(agent, name=\"Bot\") \ntask.run() # ... a loop seeking response from LLM or User at each turn\n```\n</details>\n\n<details>\n<summary><b> Three communicating agents </b></summary>\n\nA toy numbers game, where when given a number `n`:\n- `repeater_task`'s LLM simply returns `n`,\n- `even_task`'s LLM returns `n/2` if `n` is even, else says \"DO-NOT-KNOW\"\n- `odd_task`'s LLM returns `3*n+1` if `n` is odd, else says \"DO-NOT-KNOW\"\n\nEach of these `Task`s automatically configures a default `ChatAgent`.\n\n```python\nimport langroid as lr\nfrom langroid.utils.constants import NO_ANSWER\n\nrepeater_task = lr.Task(\n    name = \"Repeater\",\n    system_message=\"\"\"\n    Your job is to repeat whatever number you receive.\n    \"\"\",\n    llm_delegate=True, # LLM takes charge of task\n    single_round=False, \n)\n\neven_task = lr.Task(\n    name = \"EvenHandler\",\n    system_message=f\"\"\"\n    You will be given a number. \n    If it is even, divide by 2 and say the result, nothing else.\n    If it is odd, say {NO_ANSWER}\n    \"\"\",\n    single_round=True,  # task done after 1 step() with valid response\n)\n\nodd_task = lr.Task(\n    name = \"OddHandler\",\n    system_message=f\"\"\"\n    You will be given a number n. \n    If it is odd, return (n*3+1), say nothing else. \n    If it is even, say {NO_ANSWER}\n    \"\"\",\n    single_round=True,  # task done after 1 step() with valid response\n)\n```\nThen add the `even_task` and `odd_task` as sub-tasks of `repeater_task`, \nand run the `repeater_task`, kicking it off with a number as input:\n```python\nrepeater_task.add_sub_task([even_task, odd_task])\nrepeater_task.run(\"3\")\n```\n\n</details>\n\n<details>\n<summary><b> Simple Tool/Function-calling example </b></summary>\n\nLangroid leverages Pydantic to support OpenAI's\n[Function-calling API](https://platform.openai.com/docs/guides/gpt/function-calling)\nas well as its own native tools. The benefits are that you don't have to write\nany JSON to specify the schema, and also if the LLM hallucinates a malformed\ntool syntax, Langroid sends the Pydantic validation error (suitably sanitized) \nto the LLM so it can fix it!\n\nSimple example: Say the agent has a secret list of numbers, \nand we want the LLM to find the smallest number in the list. \nWe want to give the LLM a `probe` tool/function which takes a\nsingle number `n` as argument. The tool handler method in the agent\nreturns how many numbers in its list are at most `n`.\n\nFirst define the tool using Langroid's `ToolMessage` class:\n\n\n```python\nimport langroid as lr\n\nclass ProbeTool(lr.agent.ToolMessage):\n  request: str = \"probe\" # specifies which agent method handles this tool\n  purpose: str = \"\"\"\n        To find how many numbers in my list are less than or equal to  \n        the <number> you specify.\n        \"\"\" # description used to instruct the LLM on when/how to use the tool\n  number: int  # required argument to the tool\n```\n\nThen define a `SpyGameAgent` as a subclass of `ChatAgent`, \nwith a method `probe` that handles this tool:\n\n```python\nclass SpyGameAgent(lr.ChatAgent):\n  def __init__(self, config: lr.ChatAgentConfig):\n    super().__init__(config)\n    self.numbers = [3, 4, 8, 11, 15, 25, 40, 80, 90]\n\n  def probe(self, msg: ProbeTool) -> str:\n    # return how many numbers in self.numbers are less or equal to msg.number\n    return str(len([n for n in self.numbers if n <= msg.number]))\n```\n\nWe then instantiate the agent and enable it to use and respond to the tool:\n\n```python\nspy_game_agent = SpyGameAgent(\n    lr.ChatAgentConfig(\n        name=\"Spy\",\n        vecdb=None,\n        use_tools=False, #  don't use Langroid native tool\n        use_functions_api=True, # use OpenAI function-call API\n    )\n)\nspy_game_agent.enable_message(ProbeTool)\n```\n\nFor a full working example see the\n[chat-agent-tool.py](https://github.com/langroid/langroid-examples/blob/main/examples/quick-start/chat-agent-tool.py)\nscript in the `langroid-examples` repo.\n</details>\n\n<details>\n<summary> <b>Tool/Function-calling to extract structured information from text </b> </summary>\n\nSuppose you want an agent to extract \nthe key terms of a lease, from a lease document, as a nested JSON structure.\nFirst define the desired structure via Pydantic models:\n\n```python\nfrom pydantic import BaseModel\nclass LeasePeriod(BaseModel):\n    start_date: str\n    end_date: str\n\n\nclass LeaseFinancials(BaseModel):\n    monthly_rent: str\n    deposit: str\n\nclass Lease(BaseModel):\n    period: LeasePeriod\n    financials: LeaseFinancials\n    address: str\n```\n\nThen define the `LeaseMessage` tool as a subclass of Langroid's `ToolMessage`.\nNote the tool has a required argument `terms` of type `Lease`:\n\n```python\nimport langroid as lr\n\nclass LeaseMessage(lr.agent.ToolMessage):\n    request: str = \"lease_info\"\n    purpose: str = \"\"\"\n        Collect information about a Commercial Lease.\n        \"\"\"\n    terms: Lease\n```\n\nThen define a `LeaseExtractorAgent` with a method `lease_info` that handles this tool,\ninstantiate the agent, and enable it to use and respond to this tool:\n\n```python\nclass LeaseExtractorAgent(lr.ChatAgent):\n    def lease_info(self, message: LeaseMessage) -> str:\n        print(\n            f\"\"\"\n        DONE! Successfully extracted Lease Info:\n        {message.terms}\n        \"\"\"\n        )\n        return json.dumps(message.terms.dict())\n    \nlease_extractor_agent = LeaseExtractorAgent()\nlease_extractor_agent.enable_message(LeaseMessage)\n```\n\nSee the [`chat_multi_extract.py`](https://github.com/langroid/langroid-examples/blob/main/examples/docqa/chat_multi_extract.py)\nscript in the `langroid-examples` repo for a full working example.\n</details>\n\n<details>\n<summary><b> Chat with documents (file paths, URLs, etc) </b></summary>\n\nLangroid provides a specialized agent class `DocChatAgent` for this purpose.\nIt incorporates document sharding, embedding, storage in a vector-DB, \nand retrieval-augmented query-answer generation.\nUsing this class to chat with a collection of documents is easy.\nFirst create a `DocChatAgentConfig` instance, with a \n`doc_paths` field that specifies the documents to chat with.\n\n```python\nimport langroid as lr\nfrom langroid.agent.special import DocChatAgentConfig, DocChatAgent\n\nconfig = DocChatAgentConfig(\n  doc_paths = [\n    \"https://en.wikipedia.org/wiki/Language_model\",\n    \"https://en.wikipedia.org/wiki/N-gram_language_model\",\n    \"/path/to/my/notes-on-language-models.txt\",\n  ],\n  vecdb=lr.vector_store.QdrantDBConfig(),\n)\n```\n\nThen instantiate the `DocChatAgent` (this ingests the docs into the vector-store):\n\n```python\nagent = DocChatAgent(config)\n```\nThen we can either ask the agent one-off questions,\n```python\nagent.llm_response(\"What is a language model?\")\n```\nor wrap it in a `Task` and run an interactive loop with the user:\n```python\ntask = lr.Task(agent)\ntask.run()\n```\n\nSee full working scripts in the \n[`docqa`](https://github.com/langroid/langroid-examples/tree/main/examples/docqa)\nfolder of the `langroid-examples` repo.\n</details>\n\n<details>\n<summary><b> :fire: Chat with tabular data (file paths, URLs, dataframes) </b></summary>\n\nUsing Langroid you can set up a `TableChatAgent` with a dataset (file path, URL or dataframe),\nand query it. The Agent's LLM generates Pandas code to answer the query, \nvia function-calling (or tool/plugin), and the Agent's function-handling method\nexecutes the code and returns the answer.\n\nHere is how you can do this:\n\n```python\nimport langroid as lr\nfrom langroid.agent.special import TableChatAgent, TableChatAgentConfig\n```\n\nSet up a `TableChatAgent` for a data file, URL or dataframe\n(Ensure the data table has a header row; the delimiter/separator is auto-detected):\n```python\ndataset =  \"https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv\"\n# or dataset = \"/path/to/my/data.csv\"\n# or dataset = pd.read_csv(\"/path/to/my/data.csv\")\nagent = TableChatAgent(\n    config=TableChatAgentConfig(\n        data=dataset,\n    )\n)\n```\nSet up a task, and ask one-off questions like this: \n\n```python\ntask = lr.Task(\n  agent, \n  name = \"DataAssistant\",\n  default_human_response=\"\", # to avoid waiting for user input\n)\nresult = task.run(\n  \"What is the average alcohol content of wines with a quality rating above 7?\",\n  turns=2 # return after user question, LLM fun-call/tool response, Agent code-exec result\n) \nprint(result.content)\n```\nOr alternatively, set up a task and run it in an interactive loop with the user:\n\n```python\ntask = lr.Task(agent, name=\"DataAssistant\")\ntask.run()\n``` \n\nFor a full working example see the \n[`table_chat.py`](https://github.com/langroid/langroid-examples/tree/main/examples/data-qa/table_chat.py)\nscript in the `langroid-examples` repo.\n\n\n</details>\n\n---\n\n# :heart: Thank you to our [supporters](https://github.com/langroid/langroid/stargazers)\n\nIf you like this project, please give it a star â­ and ðŸ“¢ spread the word in your network or social media:\n\n[![Share on Twitter](https://img.shields.io/twitter/url?style=social&url=https://github.com/langroid/langroid)](https://twitter.com/intent/tweet?text=Langroid%20is%20a%20powerful,%20elegant%20new%20framework%20to%20easily%20build%20%23LLM%20applications.%20You%20set%20up%20LLM-powered%20Agents%20with%20vector-stores,%20assign%20tasks,%20and%20have%20them%20collaboratively%20solve%20problems%20via%20message-transformations.%20https://github.com/langroid/langroid)\n[![Share on LinkedIn](https://img.shields.io/badge/Share%20on-LinkedIn-blue)](https://www.linkedin.com/shareArticle?mini=true&url=https://github.com/langroid/langroid&title=Langroid:%20A%20Powerful,%20Elegant%20Framework&summary=Langroid%20is%20a%20powerful,%20elegant%20new%20framework%20to%20easily%20build%20%23LLM%20applications.%20You%20set%20up%20LLM-powered%20Agents%20with%20vector-stores,%20assign%20tasks,%20and%20have%20them%20collaboratively%20solve%20problems%20via%20message-transformations.)\n[![Share on Hacker News](https://img.shields.io/badge/-Share%20on%20Hacker%20News-orange)](https://news.ycombinator.com/submitlink?u=https%3A%2F%2Fgithub.com%2Flangroid%2Flangroid&t=Harness%20LLMs%20with%20Multi-Agent%20Programming)\n[![Share on Reddit](https://img.shields.io/badge/-Share%20on%20Reddit-blue)](https://www.reddit.com/submit?url=https%3A%2F%2Fgithub.com%2Flangroid%2Flangroid&title=Harness%20LLMs%20with%20Multi-Agent%20Programming)\n\nYour support will help build Langroid's momentum and community.\n\n# Langroid Co-Founders\n\n- [Prasad Chalasani](https://www.linkedin.com/in/pchalasani/) (IIT BTech/CS, CMU PhD/ML; Independent ML Consultant)\n- [Somesh Jha](https://www.linkedin.com/in/somesh-jha-80208015/) (IIT BTech/CS, CMU PhD/CS; Professor of CS, U Wisc at Madison)\n\n\n\n"
      },
      "plugins": [
        {
          "name": "langroid",
          "source": "./plugins/langroid",
          "description": "Langroid multi-agent framework patterns and best practices",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add langroid/langroid",
            "/plugin install langroid@langroid"
          ]
        }
      ]
    }
  ]
}