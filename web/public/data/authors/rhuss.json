{
  "author": {
    "id": "rhuss",
    "display_name": "Roland Hu√ü",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/99080?u=f8b4326f58b061c82189c7077ef4b8dd015bf78e&v=4",
    "url": "https://github.com/rhuss",
    "bio": "I'm a software engineer and\r\nüå∂ head, author of the O'Reilly book \"Kubernetes Patterns\", together w. @bibryam (k8spatterns.com). Knative, Jolokia, d-m-p",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 10,
      "total_skills": 14,
      "total_stars": 2,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "sdd-plugin-development",
      "version": null,
      "description": "Local development marketplace for the Specification-Driven Development (SDD) plugin. Provides spec-first workflows, TDD implementation, and spec/code reconciliation tools for Claude Code.",
      "owner_info": {
        "name": "Roland Huss",
        "email": "rhuss@redhat.com"
      },
      "keywords": [],
      "repo_full_name": "rhuss/cc-superpowers-sdd",
      "repo_url": "https://github.com/rhuss/cc-superpowers-sdd",
      "repo_description": "Specification-Driven Development with Process Discipline for Claude Code",
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 1,
        "pushed_at": "2026-01-29T17:24:00Z",
        "created_at": "2025-11-10T10:42:10Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 776
        },
        {
          "path": "sdd",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 582
        },
        {
          "path": "sdd/.claude",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/.claude/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/.claude/commands/update-superpowers.md",
          "type": "blob",
          "size": 10035
        },
        {
          "path": "sdd/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/commands/brainstorm.md",
          "type": "blob",
          "size": 276
        },
        {
          "path": "sdd/commands/constitution.md",
          "type": "blob",
          "size": 196
        },
        {
          "path": "sdd/commands/evolve.md",
          "type": "blob",
          "size": 211
        },
        {
          "path": "sdd/commands/help.md",
          "type": "blob",
          "size": 221
        },
        {
          "path": "sdd/commands/implement.md",
          "type": "blob",
          "size": 227
        },
        {
          "path": "sdd/commands/review-code.md",
          "type": "blob",
          "size": 283
        },
        {
          "path": "sdd/commands/review-spec.md",
          "type": "blob",
          "size": 225
        },
        {
          "path": "sdd/commands/spec.md",
          "type": "blob",
          "size": 202
        },
        {
          "path": "sdd/commands/tutorial.md",
          "type": "blob",
          "size": 209
        },
        {
          "path": "sdd/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/brainstorm",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/brainstorm/SKILL.md",
          "type": "blob",
          "size": 9426
        },
        {
          "path": "sdd/skills/constitution",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/constitution/SKILL.md",
          "type": "blob",
          "size": 11170
        },
        {
          "path": "sdd/skills/evolve",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/evolve/SKILL.md",
          "type": "blob",
          "size": 12660
        },
        {
          "path": "sdd/skills/help",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/help/SKILL.md",
          "type": "blob",
          "size": 2020
        },
        {
          "path": "sdd/skills/help/quick-reference.md",
          "type": "blob",
          "size": 2105
        },
        {
          "path": "sdd/skills/implement",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/implement/SKILL.md",
          "type": "blob",
          "size": 10971
        },
        {
          "path": "sdd/skills/review-code",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/review-code/SKILL.md",
          "type": "blob",
          "size": 9503
        },
        {
          "path": "sdd/skills/review-spec",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/review-spec/SKILL.md",
          "type": "blob",
          "size": 11738
        },
        {
          "path": "sdd/skills/spec-kit",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/spec-kit/SKILL.md",
          "type": "blob",
          "size": 7989
        },
        {
          "path": "sdd/skills/spec-refactoring",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/spec-refactoring/SKILL.md",
          "type": "blob",
          "size": 10718
        },
        {
          "path": "sdd/skills/spec",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/spec/SKILL.md",
          "type": "blob",
          "size": 6546
        },
        {
          "path": "sdd/skills/tutorial",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/tutorial/SKILL.md",
          "type": "blob",
          "size": 3928
        },
        {
          "path": "sdd/skills/tutorial/full-introduction.md",
          "type": "blob",
          "size": 7714
        },
        {
          "path": "sdd/skills/tutorial/quick-start.md",
          "type": "blob",
          "size": 3302
        },
        {
          "path": "sdd/skills/tutorial/team-collaboration.md",
          "type": "blob",
          "size": 6482
        },
        {
          "path": "sdd/skills/using-superpowers-sdd",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/using-superpowers-sdd/SKILL.md",
          "type": "blob",
          "size": 10723
        },
        {
          "path": "sdd/skills/verification-before-completion",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/verification-before-completion/SKILL.md",
          "type": "blob",
          "size": 11138
        },
        {
          "path": "sdd/skills/writing-plans",
          "type": "tree",
          "size": null
        },
        {
          "path": "sdd/skills/writing-plans/SKILL.md",
          "type": "blob",
          "size": 11648
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"sdd-plugin-development\",\n  \"owner\": {\n    \"name\": \"Roland Huss\",\n    \"email\": \"rhuss@redhat.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Local development marketplace for the Specification-Driven Development (SDD) plugin. Provides spec-first workflows, TDD implementation, and spec/code reconciliation tools for Claude Code.\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"sdd\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Specification-Driven Development with Process Discipline for Claude Code\",\n      \"author\": {\n        \"name\": \"Roland Huss\",\n        \"email\": \"rhuss@redhat.com\"\n      },\n      \"source\": \"./sdd\",\n      \"homepage\": \"https://github.com/rhuss/cc-superpowers-sdd\",\n      \"repository\": \"https://github.com/rhuss/cc-superpowers-sdd.git\"\n    }\n  ]\n}\n",
        "sdd/.claude-plugin/plugin.json": "{\n  \"name\": \"sdd\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Specification-Driven Development with Process Discipline for Claude Code\",\n  \"author\": {\n    \"name\": \"Roland Huss\",\n    \"email\": \"rhuss@redhat.com\"\n  },\n  \"license\": \"MIT\",\n  \"repository\": \"https://github.com/rhuss/cc-superpowers-sdd\",\n  \"homepage\": \"https://github.com/rhuss/cc-superpowers-sdd\",\n  \"keywords\": [\n    \"claude-code\",\n    \"plugin\",\n    \"specification-driven-development\",\n    \"sdd\",\n    \"specs\",\n    \"test-driven-development\",\n    \"tdd\",\n    \"process-discipline\",\n    \"quality-gates\",\n    \"superpowers\"\n  ]\n}\n",
        "sdd/.claude/commands/update-superpowers.md": "---\ndescription: \"[Plugin Dev] Sync modified skills with upstream superpowers while preserving SDD enhancements\"\n---\n\n# Upstream Superpowers Sync Workflow\n\n**Purpose**: Sync modified skills with upstream superpowers while preserving SDD enhancements.\n\n**Context**: This command is for maintaining the cc-superpowers-sdd plugin, not for end users.\n\n## Safety Check\n\nBefore proceeding, verify we're in the plugin development directory:\n\n```bash\n# Check for plugin marker\nif [ ! -f \"sdd/.superpowers-sync\" ] || [ ! -f \"sdd/.claude-plugin/plugin.json\" ]; then\n  echo \"ERROR: This command only works in cc-superpowers-sdd plugin directory\"\n  echo \"Current directory: $(pwd)\"\n  exit 1\nfi\n\n# Verify we're in the right repo\nif ! grep -q \"cc-superpowers-sdd\" sdd/.claude-plugin/plugin.json 2>/dev/null; then\n  echo \"ERROR: This doesn't appear to be the cc-superpowers-sdd repository\"\n  exit 1\nfi\n\necho \"Plugin directory confirmed\"\n```\n\n**If checks fail, STOP and inform user this command is only for plugin maintenance.**\n\n## Pre-Sync Preparation\n\n### 1. Load Current Sync State\n\n```bash\ncat sdd/.superpowers-sync\n```\n\nExtract:\n- `last_sync_commit`: Last upstream commit we synced from\n- `modified_skills`: Which skills are modified and how\n- `upstream_repo`: Upstream repository URL\n\n### 2. Clone/Update Upstream Repository\n\n```bash\n# Create temp directory\nTEMP_DIR=$(mktemp -d)\ncd \"$TEMP_DIR\"\n\n# Clone upstream\ngit clone https://github.com/obra/superpowers superpowers-upstream\ncd superpowers-upstream\n\n# Get current HEAD\nCURRENT_COMMIT=$(git rev-parse HEAD)\nCURRENT_DATE=$(git log -1 --format=%cd --date=short)\n\necho \"Upstream HEAD: $CURRENT_COMMIT ($CURRENT_DATE)\"\n```\n\n### 3. Check What Changed\n\nFor each modified skill, get the diff:\n\n```bash\nLAST_SYNC=$(jq -r '.last_sync_commit' sdd/.superpowers-sync)\n\n# For each modified skill\nfor skill in writing-plans code-review verification-before-completion brainstorming; do\n  UPSTREAM_FILE=\"skills/${skill}/SKILL.md\"\n\n  # Get changes since last sync\n  if [ \"$LAST_SYNC\" != \"INITIAL\" ]; then\n    echo \"=== Changes to $skill ===\"\n    git log --oneline $LAST_SYNC..HEAD -- \"$UPSTREAM_FILE\"\n    echo \"\"\n  else\n    echo \"=== $skill (INITIAL SYNC) ===\"\n    echo \"Will use current upstream version as baseline\"\n    echo \"\"\n  fi\ndone\n```\n\nSave the temp directory path for later: `echo $TEMP_DIR`\n\n## AI-Assisted Merge Workflow\n\nFor each modified skill, we'll use AI agents to merge upstream changes with SDD enhancements.\n\n### Per-Skill Merge Process\n\nFor each skill in `sdd/.superpowers-sync` ‚Üí `modified_skills`:\n\n1. **Read three sources**:\n   - Upstream current version: `$TEMP_DIR/superpowers-upstream/skills/[skill]/SKILL.md`\n   - Local current version: `sdd/skills/[skill]/SKILL.md`\n   - Modification metadata: from `sdd/.superpowers-sync`\n\n2. **Get upstream changes** (if not INITIAL sync):\n   ```bash\n   cd $TEMP_DIR/superpowers-upstream\n\n   # Get patch of changes\n   git diff $LAST_SYNC..HEAD -- skills/[skill]/SKILL.md > /tmp/upstream-changes-[skill].patch\n\n   # Get commit messages for context\n   git log --format=\"%h %s\" $LAST_SYNC..HEAD -- skills/[skill]/SKILL.md > /tmp/upstream-commits-[skill].txt\n   ```\n\n3. **Launch merge agent**:\n\n   Use the Task tool to launch a merge agent for EACH skill:\n\n   ```\n   Prompt for agent:\n\n   You are merging upstream superpowers changes into a modified skill that has SDD enhancements.\n\n   **Context:**\n   - Skill: [skill-name]\n   - Upstream repo: https://github.com/obra/superpowers\n   - Local repo: cc-superpowers-sdd (this plugin)\n\n   **Your task:**\n   1. Read the current local version: sdd/skills/[skill]/SKILL.md\n   2. Read the upstream current version: $TEMP_DIR/superpowers-upstream/skills/[skill]/SKILL.md\n   3. Read the modification metadata from sdd/.superpowers-sync\n   4. If not INITIAL sync, read upstream changes: /tmp/upstream-changes-[skill].patch\n   5. Analyze:\n      - What improved in upstream (better examples, new patterns, fixes)\n      - What SDD enhancements exist in local (from modification_summary)\n      - Where conflicts might occur\n   6. Create merged version that:\n      - Preserves ALL SDD sections (listed in sdd_additions)\n      - Integrates upstream improvements (better wording, examples, anti-rationalization)\n      - Maintains consistency in tone and structure\n      - Keeps both superpowers discipline AND spec-awareness\n   7. Output:\n      - The complete merged SKILL.md content\n      - Summary of changes made\n      - List of conflicts (if any) and how resolved\n      - Recommendation: \"READY TO APPLY\" or \"NEEDS REVIEW\" with reasons\n\n   **Critical rules:**\n   - DO NOT remove SDD-specific sections\n   - DO NOT weaken spec-first principles\n   - DO integrate better examples/wording from upstream\n   - DO preserve quality gates from both sources\n   - DO maintain anti-rationalization patterns from both versions\n\n   **Modification metadata for this skill:**\n   ```json\n   [paste relevant section from .superpowers-sync]\n   ```\n\n   Begin merge analysis and output merged content.\n   ```\n\n4. **Review agent output**:\n   - Check that SDD sections are preserved\n   - Verify upstream improvements are integrated\n   - Confirm no conflicts or all conflicts resolved\n   - If \"NEEDS REVIEW\", examine conflicts carefully\n\n5. **Apply or defer**:\n   - If \"READY TO APPLY\": Write merged content to `sdd/skills/[skill]/SKILL.md`\n   - If \"NEEDS REVIEW\": Save to `sdd/skills/[skill]/SKILL.md.proposed` and mark for manual review\n\n## Run Merge for All Modified Skills\n\nExecute the above process for each skill:\n\n1. `writing-plans` (upstream: `skills/writing-plans/SKILL.md`)\n2. `review-code` (upstream: `skills/code-review/SKILL.md`)\n3. `verification-before-completion` (upstream: `skills/verification-before-completion/SKILL.md`)\n4. `brainstorm` (upstream: `skills/brainstorming/SKILL.md`)\n\n**Use TodoWrite to track progress:**\n- [ ] Merge writing-plans\n- [ ] Merge review-code\n- [ ] Merge verification-before-completion\n- [ ] Merge brainstorm\n- [ ] Review all merged files\n- [ ] Update .superpowers-sync\n- [ ] Update CHANGELOG\n- [ ] Test merged skills\n\n## Post-Merge Actions\n\n### 1. Generate Sync Report\n\nCreate `docs/sync-reports/sync-YYYY-MM-DD.md`:\n\n```markdown\n# Superpowers Sync Report: YYYY-MM-DD\n\n**Upstream Commit**: [COMMIT_HASH]\n**Upstream Date**: [DATE]\n**Previous Sync**: [LAST_SYNC_COMMIT]\n\n## Skills Updated\n\n### writing-plans\n**Status**: ‚úÖ Merged / ‚ö†Ô∏è Needs Review\n\n**Upstream Changes Integrated**:\n- [List improvements from upstream commits]\n\n**SDD Enhancements Preserved**:\n- Spec-first input parsing\n- Requirements coverage validation\n- Plan-to-spec validation\n\n**Conflicts Resolved**:\n- [List any conflicts and how resolved, or \"None\"]\n\n---\n\n[Repeat for each skill]\n\n## Summary\n\n- Modified skills synced: X/4\n- Skills needing manual review: X\n- SDD enhancements: All preserved ‚úÖ\n- Upstream improvements: [count] integrated\n\n## Next Steps\n\n- [ ] Review any skills marked \"NEEDS REVIEW\"\n- [ ] Test all merged skills for consistency\n- [ ] Update CHANGELOG with sync entry\n- [ ] Commit with message: \"Sync with superpowers@[COMMIT]\"\n```\n\n### 2. Update .superpowers-sync\n\n```bash\n# Update tracking file\njq --arg commit \"$CURRENT_COMMIT\" --arg date \"$(date +%Y-%m-%d)\" \\\n  '.last_sync_commit = $commit | .last_sync_date = $date | .note = \"Synced via /update-superpowers\"' \\\n  sdd/.superpowers-sync > sdd/.superpowers-sync.tmp\n\nmv sdd/.superpowers-sync.tmp sdd/.superpowers-sync\n```\n\n### 3. Update CHANGELOG\n\nAdd entry:\n\n```markdown\n## [Unreleased]\n\n### Changed\n- Synced with superpowers@[COMMIT_SHORT] ([DATE])\n  - `writing-plans`: [summary of upstream improvements]\n  - `review-code`: [summary]\n  - `verification-before-completion`: [summary]\n  - `brainstorm`: [summary]\n  - All SDD spec-compliance enhancements preserved\n```\n\n### 4. Cleanup\n\n```bash\n# Remove temp directory\nrm -rf $TEMP_DIR\n\n# Show status\ngit status\n```\n\n## Testing Merged Skills\n\nAfter merge, verify each skill:\n\n```bash\n# Read through each modified skill\ncat sdd/skills/writing-plans/SKILL.md\ncat sdd/skills/review-code/SKILL.md\ncat sdd/skills/verification-before-completion/SKILL.md\ncat sdd/skills/brainstorm/SKILL.md\n\n# Check for:\n# - SDD sections still present (spec-first, compliance checking, etc.)\n# - Superpowers discipline maintained (anti-rationalization, quality gates)\n# - Improved examples/wording from upstream integrated\n# - No merge artifacts (<<<<<<, >>>>>>, etc.)\n# - Consistent tone and structure\n```\n\n## Final Output\n\nPresent to user:\n\n```\n‚úÖ Superpowers Sync Complete\n\n**Synced from**: obra/superpowers@[COMMIT] ([DATE])\n**Skills updated**: 4\n\n**Summary**:\n- writing-plans: ‚úÖ [X changes integrated]\n- review-code: ‚úÖ [X changes integrated]\n- verification-before-completion: ‚úÖ [X changes integrated]\n- brainstorm: ‚úÖ [X changes integrated]\n\n**Reports**:\n- Detailed report: docs/sync-reports/sync-YYYY-MM-DD.md\n- Changes staged for review\n\n**Next steps**:\n1. Review changed files: `git diff`\n2. Test skills work correctly\n3. Commit: `git commit -m \"Sync with superpowers@[COMMIT_SHORT]\"`\n4. Update CHANGELOG if needed\n\n[If any skills need manual review]:\n‚ö†Ô∏è  Manual review needed:\n- sdd/skills/[skill]/SKILL.md.proposed - [reason]\n\nPlease review and resolve before committing.\n```\n\n## Usage Example\n\n```bash\n# User runs in cc-superpowers-sdd directory\n/update-superpowers\n\n# Claude executes:\n# 1. Verifies we're in plugin directory ‚úÖ\n# 2. Reads sdd/.superpowers-sync\n# 3. Clones upstream superpowers\n# 4. Checks for changes since last sync\n# 5. Launches merge agents for each modified skill\n# 6. Reviews agent outputs\n# 7. Applies merged versions\n# 8. Generates sync report\n# 9. Updates sdd/.superpowers-sync\n# 10. Suggests CHANGELOG entry\n# 11. Shows summary and next steps\n```\n\n## Notes\n\n- This command is **only for plugin maintainers**\n- It will fail if run outside cc-superpowers-sdd directory\n- Always review merged skills before committing\n- SDD enhancements should NEVER be removed\n- Upstream improvements should be integrated when they don't conflict\n- When in doubt, mark for manual review\n",
        "sdd/commands/brainstorm.md": "---\nname: sdd:brainstorm\ndescription: Refine rough ideas into executable specifications through collaborative dialogue\n---\n\nUse the `sdd:brainstorm` skill to guide the user through collaborative brainstorming, turning their rough idea into a formal, executable specification.\n",
        "sdd/commands/constitution.md": "---\nname: sdd:constitution\ndescription: Create and manage project constitution defining project-wide principles\n---\n\nUse the `sdd:constitution` skill to create or update the project constitution.\n",
        "sdd/commands/evolve.md": "---\nname: sdd:evolve\ndescription: Reconcile spec/code mismatches with AI-guided evolution and user control\n---\n\nUse the `sdd:evolve` skill to reconcile mismatches between specifications and code implementation.\n",
        "sdd/commands/help.md": "---\nname: sdd:help\ndescription: Quick reference for all SDD commands with offer to answer questions\n---\n\nUse the `sdd:help` skill to display the quick reference guide and offer to answer questions about the SDD workflow.\n",
        "sdd/commands/implement.md": "---\nname: sdd:implement\ndescription: Implement features from validated specifications using TDD with spec compliance checking\n---\n\nUse the `sdd:implement` skill to implement a feature from an existing, validated specification.\n",
        "sdd/commands/review-code.md": "---\nname: sdd:review-code\ndescription: Review code against spec compliance - checks implementation matches spec requirements, identifies deviations, reports compliance score\n---\n\nUse the `sdd:review-code` skill to review code implementation against the specification for compliance.\n",
        "sdd/commands/review-spec.md": "---\nname: sdd:review-spec\ndescription: Review specifications for soundness, completeness, and implementability\n---\n\nUse the `sdd:review-spec` skill to review a specification for soundness, completeness, and implementability.\n",
        "sdd/commands/spec.md": "---\nname: sdd:spec\ndescription: Create formal specifications directly from clear requirements\n---\n\nUse the `sdd:spec` skill to create a formal specification directly from the user's clear requirements.\n",
        "sdd/commands/tutorial.md": "---\nname: sdd:tutorial\ndescription: Interactive guide to SDD methodology and team collaboration workflows\n---\n\nUse the `sdd:tutorial` skill for an interactive introduction to Specification-Driven Development.\n",
        "sdd/skills/brainstorm/SKILL.md": "---\nname: brainstorm\ndescription: Use when starting from rough ideas - refines concepts into executable specifications through collaborative questioning, alternative exploration, and incremental validation, use this skill when called from a command\n---\n\n# Brainstorming Ideas Into Specifications\n\n## Overview\n\nHelp turn rough ideas into formal, executable specifications through natural collaborative dialogue.\n\nStart by understanding the current project context, then ask questions one at a time to refine the idea. Once you understand what you're building, create the specification using spec-kit (if available) or directly as markdown.\n\n**Key Difference from Standard Brainstorming:**\n- **Output is a SPEC**, not a design document\n- Spec is the **source of truth** for implementation\n- Focus on **\"what\" and \"why\"**, defer \"how\" to implementation phase\n- Validate spec soundness before finishing\n\n## Prerequisites\n\nBefore starting the brainstorming workflow, ensure spec-kit is initialized:\n\n{Skill: spec-kit}\n\nIf spec-kit prompts for restart, pause this workflow and resume after restart.\n\n## The Process\n\n### Understanding the idea\n\n**Check context first:**\n- Review existing specs (if any) in `specs/` directory\n- Check for constitution (`specs/constitution.md`)\n- Review recent commits to understand project state\n- Look for related features or patterns\n\n**Ask questions to refine:**\n- Ask questions one at a time\n- Prefer multiple choice when possible\n- Focus on: purpose, constraints, success criteria, edge cases\n- Identify dependencies and integrations\n\n**Remember:** You're building a SPEC, so focus on WHAT needs to happen, not HOW it will be implemented.\n\n### Exploring approaches\n\n**Propose 2-3 different approaches:**\n- Present options conversationally with trade-offs\n- Lead with your recommended option\n- Explain reasoning clearly\n- Consider: complexity, maintainability, user impact\n\n**Questions to explore:**\n- What are the core requirements vs. nice-to-have?\n- What are the error cases and edge conditions?\n- How does this integrate with existing features?\n- What are the success criteria?\n\n### Creating the specification\n\n**Once you understand what you're building:**\n\n1. **Announce spec creation:**\n   \"Based on our discussion, I'm creating the specification...\"\n\n2. **Create spec file:**\n   - Location: `specs/features/[feature-name]/spec.md`\n   - Use spec-kit CLI if available: `speckit specify`\n   - Otherwise: Create markdown directly\n\n3. **IMPORTANT: Capture implementation insights separately**\n\n   If technical details emerged during brainstorming (technology choices, architecture decisions, trade-off discussions), **create implementation-notes.md** to capture them:\n\n   - Location: `specs/features/[feature-name]/implementation-notes.md`\n   - Purpose: Document the \"why\" behind design decisions\n   - Content:\n     - Alternative approaches considered\n     - Trade-offs discussed\n     - Technology choices and rationale\n     - Technical constraints discovered\n     - Questions answered during brainstorming\n\n   **Why separate from spec:**\n   - Spec = WHAT and WHY (requirements, contracts)\n   - Implementation notes = Technical context for HOW\n   - Keeps spec stable while preserving valuable context\n   - Helps future implementers understand decisions\n\n   **Example content:**\n   ```markdown\n   # Implementation Notes: User Authentication\n\n   ## Design Decisions\n\n   ### Decision: OAuth vs. Magic Links\n   - Chose OAuth (Google + GitHub)\n   - Rationale: User preference for familiar login flow\n   - Rejected magic links: Email deliverability concerns\n\n   ### Decision: JWT in httpOnly cookies\n   - Prevents XSS attacks\n   - Refresh token rotation for security\n   - Trade-off: Slightly more complex than localStorage\n   ```\n\n4. **Spec structure** (use this template):\n\n```markdown\n# Feature: [Feature Name]\n\n## Purpose\n[Why this feature exists - the problem it solves]\n\n## Requirements\n\n### Functional Requirements\n- [What the feature must do]\n- [Behavior in specific scenarios]\n- [Integration points]\n\n### Non-Functional Requirements\n- [Performance constraints]\n- [Security requirements]\n- [Accessibility needs]\n\n## Success Criteria\n- [How we know it works]\n- [Measurable outcomes]\n\n## Error Handling\n- [What can go wrong]\n- [How errors should be handled]\n\n## Edge Cases\n- [Boundary conditions]\n- [Unusual scenarios]\n\n## Dependencies\n- [Other features/systems required]\n- [External services]\n\n## Out of Scope\n- [What this feature explicitly does NOT do]\n- [Future considerations]\n\n## Open Questions\n- [Anything still unclear]\n- [Decisions deferred to implementation]\n```\n\n4. **Validate against constitution** (if exists):\n   - Read `specs/constitution.md`\n   - Check spec aligns with project principles\n   - Note any violations and address them\n\n5. **Present spec in sections:**\n   - Show 200-300 words at a time\n   - Ask: \"Does this look right so far?\"\n   - Be ready to revise based on feedback\n\n### After spec creation\n\n**Validate the spec:**\n- Use `sdd:review-spec` to check soundness\n- Ensure spec is implementable\n- Confirm no ambiguities remain\n\n**Offer next steps:**\n- \"Spec created and validated. Ready to implement?\"\n- If yes ‚Üí Use `sdd:implement`\n- If no ‚Üí Offer to refine spec or pause\n\n**Commit the spec:**\n```bash\ngit add specs/features/[feature-name].md\ngit commit -m \"Add spec for [feature name]\n\n[Brief description of what the feature does]\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\"\n```\n\n## Key Principles\n\n- **One question at a time** - Don't overwhelm with multiple questions\n- **Multiple choice preferred** - Easier to answer than open-ended\n- **YAGNI ruthlessly** - Remove unnecessary features from all specs\n- **Explore alternatives** - Always propose 2-3 approaches before settling\n- **Incremental validation** - Present spec in sections, validate each\n- **Be flexible** - Go back and clarify when something doesn't make sense\n- **Separate WHAT from HOW** - Spec focuses on requirements and contracts; implementation notes capture technical decisions\n- **Capture context** - If technical details emerge, put them in implementation-notes.md, not the spec\n- **Spec, not design** - Focus on WHAT, defer HOW to implementation\n\n## Recommend Constitution (First Time Users)\n\nIf no constitution exists and this seems to be early in project:\n\n**After first spec created:**\n- \"I notice you don't have a constitution yet.\"\n- \"A constitution defines project-wide principles like:\"\n  - Coding standards\n  - Architectural patterns\n  - Quality gates\n  - Error handling approaches\n- \"Would you like to create one? It ensures consistency across features.\"\n- If yes ‚Üí Use `sdd:constitution`\n\n**Don't be pushy:** Constitution is optional but recommended.\n\n## Checklist\n\nUse TodoWrite to track:\n\n- [ ] Understand current project context\n- [ ] Ask questions to refine idea\n- [ ] Explore 2-3 approaches with trade-offs\n- [ ] Create specification file\n- [ ] Validate against constitution (if exists)\n- [ ] Review spec for soundness\n- [ ] Commit spec to git\n- [ ] Offer next steps (implement or refine)\n\n## Example Flow\n\n```\nUser: I want to add a comment system to the blog\n\nYou: I'm using sdd:brainstorm to refine this idea into a spec.\n\nLet me understand the context first...\n[Reviews existing code and specs]\n\nFor the comment system, what level of features do you want?\n\nA) Basic - Name, email, comment text only\nB) Standard - Above + threading/replies\nC) Advanced - Above + reactions, editing, moderation\nD) Full - Above + notifications, mentions, markdown\n\nUser: B - Standard with threading\n\nYou: Great. For threading, should replies be:\n\nA) Unlimited depth (comments on comments on comments...)\nB) One level only (reply to top-level comments)\nC) Two levels (reply and one nested level)\n\n[... conversation continues ...]\n\nYou: Based on our discussion, I'm creating the specification at:\nspecs/features/blog-comments.md\n\n[Creates spec with all discussed requirements]\n\nHere's the Purpose and Requirements section:\n\n## Purpose\nEnable readers to discuss blog posts through threaded comments,\nfostering community engagement and feedback.\n\n## Requirements\n\n### Functional Requirements\n- Readers can submit comments on published blog posts\n- Comments require: name, email, comment text\n- Comments support one level of replies (threading)\n- Comments display in chronological order, newest first\n- Replies display under parent comment\n...\n\nDoes this look right so far?\n\nUser: Yes\n\n[... continues through all sections ...]\n\nYou: Spec created! Let me validate it for soundness...\n\n[Runs sdd:review-spec]\n\nSpec is sound and implementable ‚úì\n\nCommitted to git ‚úì\n\nReady to implement the comment system?\n```\n\n## Common Pitfalls\n\n**Don't:**\n- Create design documents instead of specs\n- Include implementation details (\"use Redis for caching\")\n- Make decisions that belong in implementation phase\n- Skip exploring alternatives\n- Rush to spec creation before understanding the problem\n\n**Do:**\n- Focus on requirements and behavior\n- Specify WHAT, not HOW\n- Explore multiple approaches\n- Validate incrementally\n- Check against constitution\n- Ensure spec is implementable\n\n## Remember\n\nThe spec you create here becomes the source of truth. Implementation will flow from it. Code reviews will validate against it. Make it clear, complete, and correct.\n\n**Good specs enable good implementation. Take the time to get it right.**\n",
        "sdd/skills/constitution/SKILL.md": "---\nname: constitution\ndescription: Create and manage project constitution - defines project-wide principles, patterns, and standards that guide all specs and implementations\n---\n\n# Project Constitution Management\n\n## Overview\n\nCreate and maintain a project constitution that defines project-wide principles, standards, and patterns.\n\nA constitution provides:\n- Architectural decisions\n- Coding standards\n- Error handling patterns\n- Quality gates\n- Common practices\n\nAll specs are validated against the constitution for consistency.\n\n## Prerequisites\n\nEnsure spec-kit is initialized:\n\n{Skill: spec-kit}\n\nIf spec-kit prompts for restart, pause this workflow and resume after restart.\n\n## What is a Constitution?\n\n**Purpose:**\nDocument project-wide rules that ensure consistency across features.\n\n**Contains:**\n- Architectural principles\n- Coding standards\n- API design patterns\n- Error handling approaches\n- Security requirements\n- Testing standards\n- Performance requirements\n- Accessibility standards\n\n**Benefits:**\n- Consistency across features\n- Onboarding documentation\n- Design decision record\n- Spec validation reference\n\n## When to Create\n\n**Good times:**\n- New project starting\n- After second or third feature (patterns emerging)\n- Team wants consistency\n- Before major expansion\n\n**Bad times:**\n- First feature (too early, no patterns yet)\n- During active implementation\n- As reaction to single issue\n\n**Rule of thumb:** Create after you see patterns repeating.\n\n## The Process\n\n### 1. Decide if Constitution Needed\n\n**Ask:**\n- Are there repeated patterns in specs?\n- Do you want consistency enforced?\n- Is this a team project?\n- Is this a long-term project?\n\n**If solo + small project:** Constitution might be overkill\n\n**If team OR large OR long-term:** Constitution recommended\n\n### 2. Gather Existing Patterns\n\n**Review existing specs:**\n```bash\nls specs/features/\ncat specs/features/*.md\n```\n\n**Identify patterns:**\n- How do we handle errors?\n- What API patterns do we follow?\n- What security requirements are common?\n- What coding standards do we use?\n\n**Extract commonalities:**\nMake implicit standards explicit.\n\n### 3. Use Spec-Kit or Manual Creation\n\n**With spec-kit:**\n```bash\nspeckit constitution\n```\n\n**Manual creation:**\nCreate `specs/constitution.md` with template below.\n\n### 4. Create Constitution Content\n\n**Template:**\n\n```markdown\n# Project Constitution\n\n**Project:** [Project Name]\n**Created:** YYYY-MM-DD\n**Last Updated:** YYYY-MM-DD\n\n## Purpose\n\nThis constitution defines project-wide principles, patterns, and standards.\nAll features and implementations must align with these principles.\n\n## Architectural Principles\n\n### [Principle Name]\n**Description:** [What this principle means]\n**Rationale:** [Why we follow this]\n**Examples:**\n- ‚úì [Good example]\n- ‚úó [Bad example]\n\n[Repeat for each principle]\n\n## API Design Standards\n\n### RESTful Conventions\n- Use standard HTTP methods (GET, POST, PUT, DELETE)\n- Plural resource names (/users, not /user)\n- Return appropriate status codes\n- Use JSON for request/response bodies\n\n### Error Responses\n**Format:**\n```json\n{\n  \"error\": \"Human-readable error message\",\n  \"code\": \"ERROR_CODE\",\n  \"details\": { ... }\n}\n```\n\n**Status Codes:**\n- 400: Bad Request (client error)\n- 401: Unauthorized (auth required)\n- 403: Forbidden (auth insufficient)\n- 404: Not Found\n- 422: Unprocessable Entity (validation failed)\n- 500: Internal Server Error\n\n## Error Handling\n\n### Approach\n- All errors must be handled explicitly\n- Use try-catch for I/O operations\n- Log errors with context\n- Return user-friendly messages\n\n### Retry Logic\n- Database operations: 3 retries with exponential backoff\n- External APIs: 2 retries with fixed delay\n- Timeout: 30 seconds for external calls\n\n## Security Requirements\n\n### Authentication\n- All API endpoints require JWT authentication (except public endpoints)\n- JWTs expire after 30 minutes\n- Refresh tokens expire after 7 days\n\n### Input Validation\n- Validate all user input\n- Sanitize before database operations\n- Reject unexpected fields\n\n### Secrets Management\n- Never commit secrets to git\n- Use environment variables\n- Rotate secrets quarterly\n\n## Testing Standards\n\n### Coverage Requirements\n- Minimum 80% code coverage\n- 100% coverage for critical paths\n\n### Test Types\n- Unit tests for all functions\n- Integration tests for API endpoints\n- E2E tests for critical user flows\n\n### Test Organization\n- Tests in `tests/` directory\n- Mirror source structure\n- Use descriptive test names\n\n## Performance Requirements\n\n### Response Times\n- API responses: < 200ms (p95)\n- Database queries: < 50ms (p95)\n- Page loads: < 2 seconds\n\n### Scalability\n- Design for 10,000 concurrent users\n- Horizontal scaling preferred\n- Stateless where possible\n\n## Code Quality Standards\n\n### Code Style\n- Follow [ESLint/Prettier/etc.] configuration\n- Consistent naming conventions\n- Comments for complex logic only\n\n### Code Review\n- All code must be reviewed\n- Spec compliance verified\n- Tests required before merge\n\n## Accessibility Standards\n\n### WCAG Compliance\n- Meet WCAG 2.1 Level AA\n- Keyboard navigation required\n- Screen reader compatible\n\n## Documentation Standards\n\n### Code Documentation\n- JSDoc for public functions\n- README in each module\n- Architecture diagrams for complex systems\n\n### Spec Documentation\n- All features must have specs\n- Specs updated with changes\n- Specs validated before implementation\n\n## Change Management\n\n### Updating This Constitution\n- Requires team discussion (if team)\n- Document rationale for changes\n- Update all affected specs\n- Communicate changes\n\n### Exceptions\n- Exceptions must be documented in spec\n- Requires justification\n- Reviewed during code review\n\n## Glossary\n\n**[Term 1]:** [Definition]\n**[Term 2]:** [Definition]\n\n## Decision Log\n\n### [Decision Date]: [Decision Title]\n**Context:** [Why decision needed]\n**Decision:** [What was decided]\n**Rationale:** [Why this decision]\n**Implications:** [What this affects]\n\n[Add new decisions here]\n```\n\n### 5. Review and Refine\n\n**Questions to ask:**\n- Is this too restrictive?\n- Is this clear enough?\n- Can we realistically follow this?\n- Does this reflect our actual practices?\n\n**Adjust as needed.**\n\n### 6. Validate Against Existing Specs\n\n**Check existing specs:**\n```bash\n# For each existing spec\ncat specs/features/[feature].md\n\n# Does it align with constitution?\n# Any violations?\n```\n\n**If violations found:**\n- Update spec, OR\n- Update constitution (if spec is right), OR\n- Note as exception\n\n### 7. Commit Constitution\n\n```bash\ngit add specs/constitution.md\ngit commit -m \"Add project constitution\n\nDefines project-wide principles and standards:\n- Architectural principles\n- API design standards\n- Error handling patterns\n- Security requirements\n- Testing standards\n- Code quality standards\n\nAll future specs will be validated against this constitution.\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\"\n```\n\n### 8. Communicate and Adopt\n\n**For team projects:**\n- Share with team\n- Get consensus\n- Document exceptions\n- Reference in onboarding\n\n**For solo projects:**\n- Keep visible\n- Reference when creating specs\n- Update as you learn\n\n## Constitution Checklist\n\nUse TodoWrite to track:\n\n- [ ] Decide if constitution needed\n- [ ] Gather existing patterns from specs/code\n- [ ] Create constitution file (spec-kit or manual)\n- [ ] Fill in all relevant sections\n- [ ] Review for clarity and feasibility\n- [ ] Validate against existing specs\n- [ ] Handle any violations found\n- [ ] Commit constitution to git\n- [ ] Communicate to team (if applicable)\n\n## Example Constitution\n\n```markdown\n# Todo App Project Constitution\n\n**Created:** 2025-11-10\n\n## Purpose\n\nDefine standards for the todo app project to ensure consistency.\n\n## Architectural Principles\n\n### RESTful API Design\nAll endpoints follow REST conventions:\n- `GET /api/todos` - List todos\n- `POST /api/todos` - Create todo\n- `PUT /api/todos/:id` - Update todo\n- `DELETE /api/todos/:id` - Delete todo\n\n### Data Validation\n- Validate on server (never trust client)\n- Return 422 for validation failures\n- Provide specific error messages\n\n## Error Handling\n\n### Error Response Format\n```json\n{\n  \"error\": \"Human-readable message\",\n  \"field\": \"field_name\",  // for validation errors\n  \"code\": \"ERROR_CODE\"\n}\n```\n\n### Common Errors\n- 400: Malformed request\n- 401: Not authenticated\n- 404: Todo not found\n- 422: Validation failed (e.g., title too long)\n\n## Testing Standards\n\n### Requirements\n- All endpoints have integration tests\n- All validation rules have tests\n- Edge cases tested\n\n### Coverage\n- Minimum 80% coverage\n- 100% coverage for API endpoints\n\n## Code Quality\n\n### Naming\n- camelCase for variables and functions\n- PascalCase for classes\n- UPPER_CASE for constants\n\n### Comments\n- JSDoc for public functions\n- Inline comments for complex logic only\n\n## Security\n\n### Authentication\n- JWT tokens required for all /api/* endpoints\n- Tokens expire after 1 hour\n- Refresh on activity\n\n### Input Sanitization\n- Escape HTML in todo titles/descriptions\n- Limit field lengths (title: 200 chars, description: 2000 chars)\n\n## Decision Log\n\n### 2025-11-10: Use JWT for Auth\n**Context:** Need authentication for multi-user support\n**Decision:** Use JWT tokens stored in httpOnly cookies\n**Rationale:** Secure, stateless, industry standard\n**Implications:** Need token refresh mechanism, logout handling\n```\n\n## Maintaining the Constitution\n\n**Update when:**\n- New patterns emerge\n- Decisions change\n- Standards evolve\n- Exceptions become rules\n\n**Don't update when:**\n- Single feature needs exception\n- Trying to justify shortcut\n- Reacting to single issue\n\n**Update process:**\n1. Propose change\n2. Update constitution\n3. Update affected specs\n4. Communicate change\n5. Add to decision log\n\n## Common Sections\n\n### Minimal Constitution\n- Architectural principles\n- Error handling\n- Testing standards\n\n### Standard Constitution\n- Above, plus:\n- API design\n- Security requirements\n- Code quality\n\n### Comprehensive Constitution\n- Above, plus:\n- Performance requirements\n- Accessibility standards\n- Deployment practices\n- Monitoring/observability\n\n**Start minimal, expand as needed.**\n\n## Anti-Patterns\n\n**Avoid:**\n- Creating constitution too early (no patterns yet)\n- Making it too restrictive (can't follow it)\n- Copying from other projects (doesn't fit yours)\n- Never updating it (becomes outdated)\n- Not following it (then why have it?)\n\n**Instead:**\n- Wait for patterns to emerge\n- Make it realistic and followable\n- Extract from your own project\n- Update as project evolves\n- Enforce during spec validation\n\n## Remember\n\n**Constitution is living document.**\n\n- Starts small, grows with project\n- Reflects actual practices\n- Updated as standards evolve\n- Referenced regularly\n\n**Constitution enables consistency.**\n\n- Specs validated against it\n- Reduces decision fatigue\n- Onboards new developers\n- Documents architectural decisions\n\n**Constitution serves the project.**\n\n- Not rigid rules set in stone\n- Pragmatic guidelines\n- Updated when they don't serve\n- Exceptions documented\n\n**Good constitution helps. Bad constitution hinders.**\n\nMake yours helpful.\n",
        "sdd/skills/evolve/SKILL.md": "---\nname: evolve\ndescription: Use when spec and code diverge - AI analyzes mismatches, recommends update spec vs fix code with reasoning, handles evolution with user control or auto-updates\n---\n\n# Spec Evolution and Reconciliation\n\n## Overview\n\nHandle spec/code mismatches through AI-guided analysis and user-controlled evolution.\n\nSpecs WILL diverge from code. This is normal and healthy. The question is: which should change?\n\nThis skill detects divergence, analyzes the mismatch, recommends resolution, and executes the change.\n\n## When to Use\n\n**Use this skill when:**\n- Code review detects spec/code mismatch\n- Verification finds spec compliance issues\n- Developer explicitly requests evolution\n- Implementation reveals better approach than spec\n- Spec ambiguity discovered during implementation\n\n**Auto-triggered by:**\n- `sdd:review-code` (when deviations found)\n- `sdd:verification-before-completion` (when compliance fails)\n\n**Don't use this skill when:**\n- No mismatch exists (everything compliant)\n- Spec doesn't exist yet ‚Üí Use `sdd:spec`\n- Multiple specs need consolidation ‚Üí Use `sdd:spec-refactoring`\n\n## Prerequisites\n\nEnsure spec-kit is initialized:\n\n{Skill: spec-kit}\n\nIf spec-kit prompts for restart, pause this workflow and resume after restart.\n\n## The Process\n\n### 1. Detect Mismatches\n\n**Identify all spec/code divergences:**\n\n```bash\n# Read spec\ncat specs/features/[feature-name].md\n\n# Compare to implementation\n# For each requirement in spec:\n#   - What does spec say?\n#   - What does code do?\n#   - Do they match?\n```\n\n**Categorize each mismatch:**\n- **Missing in code**: Spec requires it, code doesn't have it\n- **Extra in code**: Code implements it, spec doesn't mention it\n- **Different behavior**: Spec says X, code does Y\n- **Ambiguous spec**: Spec unclear, code made assumption\n\n**Document all mismatches with:**\n- Spec requirement (quote from spec)\n- Actual implementation (what code does)\n- Location (file:line in code, section in spec)\n\n### 2. Analyze Each Mismatch\n\n**For each mismatch, determine:**\n\n**Type:**\n- Architectural (affects system design)\n- Behavioral (changes functionality)\n- Cosmetic (naming, organization, details)\n\n**Severity:**\n- **Critical**: Breaking change, security issue, data loss\n- **Major**: Significant behavior change, API contract change\n- **Minor**: Small deviation, non-breaking addition\n- **Trivial**: Naming, formatting, implementation details\n\n**Impact:**\n- User-facing vs internal\n- Breaking vs non-breaking\n- Risky vs safe\n\n### 3. Recommend Resolution\n\n**For each mismatch, recommend:**\n\n**Option A: Update Spec**\n- When: Implementation reveals better approach\n- Why: Spec was incomplete/wrong, code is better\n- Impact: Spec changes to match reality\n\n**Option B: Fix Code**\n- When: Code deviates from intended design\n- Why: Spec is correct, code is wrong\n- Impact: Code changes to match spec\n\n**Option C: Clarify Spec**\n- When: Spec was ambiguous, code made reasonable choice\n- Why: Make implicit explicit\n- Impact: Spec expanded with details, code unchanged\n\n**Provide reasoning for recommendation:**\n- Why this option is best\n- Trade-offs of alternatives\n- Risk assessment\n- User impact\n\n### 4. Decide Resolution\n\n**Decision flow:**\n\n```\nIs this mismatch trivial/minor AND auto-update enabled?\n  Yes ‚Üí Auto-update with notification\n  No ‚Üí Ask user to decide\n\nUser decides:\n  A) Update spec\n  B) Fix code\n  C) Clarify spec\n  D) Defer (mark as known deviation)\n```\n\n**Check user configuration:**\n\n```json\n{\n  \"sdd\": {\n    \"auto_update_spec\": {\n      \"enabled\": true,\n      \"threshold\": \"minor\",  // \"none\", \"minor\", \"moderate\"\n      \"notify\": true\n    }\n  }\n}\n```\n\n**Thresholds:**\n- `none`: Never auto-update\n- `minor`: Auto-update trivial/minor mismatches\n- `moderate`: Include non-breaking behavioral changes\n\n### 5. Execute Resolution\n\n**Option A: Update Spec**\n\n1. Modify spec to match implementation\n2. Add to spec changelog\n3. Validate updated spec for soundness\n4. Commit spec change with clear message\n\n```bash\n# Update spec\nvim specs/features/[feature].md\n\n# Add changelog entry\necho \"- YYYY-MM-DD: Updated [requirement] to include [change]\" >> specs/features/[feature].md\n\n# Commit\ngit add specs/features/[feature].md\ngit commit -m \"Update spec: [change]\n\nImplementation revealed [reason for change].\n\nPrevious: [old requirement]\nUpdated: [new requirement]\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\"\n```\n\n**Option B: Fix Code**\n\n1. Modify code to match spec\n2. Update tests if needed\n3. Verify spec compliance\n4. Commit code change\n\n```bash\n# Fix code\n[Make changes to match spec]\n\n# Update tests\n[Adjust tests to match spec]\n\n# Verify compliance\n[Run sdd:verification-before-completion]\n\n# Commit\ngit add [files]\ngit commit -m \"Fix: Align [component] with spec\n\nCode was [what it did], spec requires [what spec says].\n\nUpdated to match spec requirement: [spec section]\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\"\n```\n\n**Option C: Clarify Spec**\n\n1. Add detail to spec (keep code unchanged)\n2. Make implicit assumptions explicit\n3. Add to spec changelog\n4. Commit clarification\n\n**Option D: Defer**\n\n1. Document as known deviation\n2. Add to spec's \"Known Deviations\" section\n3. Note reason and plan to address\n4. Commit documentation\n\n### 6. Verify Reconciliation\n\n**After resolution:**\n\n```bash\n# Re-check spec compliance\n# Ensure mismatch is resolved\n# Verify no new mismatches introduced\n```\n\n**Confirm:**\n- Spec and code now aligned\n- Tests still passing\n- No regressions introduced\n\n## Checklist\n\nUse TodoWrite to track:\n\n- [ ] Detect all spec/code mismatches\n- [ ] Categorize each mismatch (type, severity, impact)\n- [ ] Analyze and recommend resolution for each\n- [ ] Check user configuration for auto-update\n- [ ] Decide resolution (auto or ask user)\n- [ ] Execute resolution (update spec, fix code, or clarify)\n- [ ] Verify reconciliation complete\n- [ ] Commit changes with clear messages\n- [ ] Update documentation if needed\n\n## Examples\n\n### Example 1: Auto-Update (Minor Addition)\n\n```\n[During verification]\n\nSpec compliance check: 95%\n\nMismatch detected:\n\n**Mismatch 1: Response includes timestamp (MINOR)**\n- **Spec says:** Return `{ id, name, email }`\n- **Code does:** Returns `{ id, name, email, updated_at }`\n- **Location:** src/api/users.ts:45, specs/features/user-api.md#response\n\n**Analysis:**\n- Type: Behavioral (but non-breaking addition)\n- Severity: Minor\n- Impact: Non-breaking, adds useful information\n\n**Recommendation: Update Spec (Option A)**\n\n**Reasoning:**\n- `updated_at` is standard practice for update endpoints\n- Provides useful information to clients\n- Non-breaking addition (clients can ignore it)\n- Implementation is better than spec\n\n**User config:** auto_update_spec.threshold = \"minor\"\n\n**Action:** Auto-updating spec...\n\nUpdated specs/features/user-api.md:\n- Added `updated_at` to response format\n- Changelog: \"2025-11-10: Added updated_at timestamp to responses\"\n\n‚úÖ Spec updated\n‚úÖ Compliance now 100%\n‚úÖ Committed to git\n\nNotification: Spec auto-updated with updated_at field (minor addition)\n```\n\n### Example 2: User Decision (Major Change)\n\n```\n[During code review]\n\nSpec compliance check: 85%\n\nMismatch detected:\n\n**Mismatch 1: Validation behavior difference (MAJOR)**\n- **Spec says:** \"Reject requests with invalid avatar_url, return 422\"\n- **Code does:** \"Accept invalid URLs, set avatar_url to null, return 200\"\n- **Location:** src/middleware/validation.ts:78, specs/features/user-profile.md#validation\n\n**Analysis:**\n- Type: Behavioral (changes error handling)\n- Severity: Major\n- Impact: User-facing, affects API contract\n\n**Options:**\n\n**A) Update Spec - Lenient validation**\n- Pros: More user-friendly, prevents frustration\n- Cons: Inconsistent with other validation (strict)\n- Risk: Users might not know avatar failed\n\n**B) Fix Code - Strict validation**\n- Pros: Consistent with spec and other validation\n- Cons: Worse UX when URL is invalid\n- Risk: None (matches spec)\n\n**C) Clarify Spec - Explicit fallback**\n- Pros: Best of both (validate but handle gracefully)\n- Cons: More complex\n- Risk: None\n\n**Recommendation: Option C**\n\n**Reasoning:**\nBest practice is to validate input but handle gracefully. Update spec to explicitly define fallback behavior: validate URL, set to null if invalid, log warning, return success with indication.\n\nWhich option do you prefer?\n\nUser: C - explicit fallback\n\nYou: Perfect. Updating spec to clarify fallback behavior...\n\nUpdated spec:\n\n## Validation Rules\n\n### avatar_url\n- Must be valid URL format if provided\n- **Fallback behavior:** If URL validation fails:\n  - Set avatar_url to null\n  - Log validation error\n  - Return 200 (success) with warning in response\n  - Response includes: `warnings: [\"avatar_url invalid, set to null\"]`\n\nCode now matches clarified spec ‚úÖ\n\nSpec compliance: 100%\n\nCommitted to git ‚úÖ\n```\n\n### Example 3: Fix Code (Spec Correct)\n\n```\n[During verification]\n\nSpec compliance check: 90%\n\nMismatch detected:\n\n**Mismatch 1: Missing error handling (CRITICAL)**\n- **Spec says:** \"Handle database connection errors with retry logic (3 attempts)\"\n- **Code does:** \"Single attempt, fails immediately on error\"\n- **Location:** src/db/client.ts:34, specs/features/data-persistence.md#error-handling\n\n**Analysis:**\n- Type: Architectural (missing reliability mechanism)\n- Severity: Critical\n- Impact: Production reliability risk\n\n**Recommendation: Fix Code (Option B)**\n\n**Reasoning:**\n- Spec defines critical reliability requirement\n- Single-attempt fails too easily (production risk)\n- Retry logic is standard practice\n- Code is missing required feature\n\n**No user decision needed - critical spec requirement missing**\n\nFixing code to implement retry logic...\n\n```typescript\n// Added retry logic\nasync function queryWithRetry(sql, params, attempts = 3) {\n  for (let i = 0; i < attempts; i++) {\n    try {\n      return await db.query(sql, params);\n    } catch (error) {\n      if (i === attempts - 1) throw error;\n      await sleep(1000 * (i + 1)); // Exponential backoff\n    }\n  }\n}\n```\n\nTests updated to verify retry behavior ‚úÖ\nSpec compliance: 100% ‚úÖ\n\nCommitted code fix ‚úÖ\n```\n\n## Auto-Update Configuration\n\n### Recommended Settings\n\n**For solo projects:**\n```json\n{\n  \"auto_update_spec\": {\n    \"enabled\": true,\n    \"threshold\": \"minor\",\n    \"notify\": true\n  }\n}\n```\n\n**For team projects:**\n```json\n{\n  \"auto_update_spec\": {\n    \"enabled\": true,\n    \"threshold\": \"none\",  // Always ask\n    \"notify\": true\n  }\n}\n```\n\n**For experimental work:**\n```json\n{\n  \"auto_update_spec\": {\n    \"enabled\": true,\n    \"threshold\": \"moderate\",\n    \"notify\": true\n  }\n}\n```\n\n## Classification Guidelines\n\n### Minor (Auto-Update Eligible)\n- Adding timestamps to responses\n- Renaming variables/functions\n- Reorganizing code structure\n- Adding logging/instrumentation\n- Implementation detail changes\n\n### Major (Always Ask)\n- Changing API contracts\n- Modifying behavior\n- Adding/removing features\n- Changing error handling\n- Architectural changes\n\n### Critical (Usually Fix Code)\n- Security issues\n- Data integrity problems\n- Missing required features\n- Incorrect business logic\n\n## Common Patterns\n\n### Pattern: Better Error Messages\n\n**Mismatch:** Spec says \"return error\", code returns detailed error with context\n\n**Resolution:** Update spec (minor)\n- More detailed errors are better\n- Non-breaking improvement\n\n### Pattern: Missing Edge Case\n\n**Mismatch:** Spec doesn't mention empty array, code handles it\n\n**Resolution:** Clarify spec (add edge case)\n- Make implicit explicit\n- Document intended behavior\n\n### Pattern: Performance Optimization\n\n**Mismatch:** Spec doesn't specify caching, code adds cache\n\n**Resolution:** Update spec (moderate)\n- Document optimization in spec\n- Ensure cache behavior is correct\n\n### Pattern: Different Architecture\n\n**Mismatch:** Spec implies synchronous, code is async\n\n**Resolution:** Ask user (major)\n- Significant architectural change\n- May affect other components\n\n## Remember\n\n**Spec evolution is normal and healthy.**\n\n- Specs are not contracts set in stone\n- Implementation reveals reality\n- Better approaches emerge during coding\n- Ambiguities get discovered\n\n**The goal is alignment, not rigidity.**\n\n- Specs guide implementation\n- Implementation informs specs\n- Both should reflect truth\n\n**Always provide reasoning:**\n- Why update spec vs fix code\n- What's the impact\n- What are the trade-offs\n\n**Trust the process:**\n- Detect mismatches early\n- Analyze thoughtfully\n- Recommend clearly\n- Execute decisively\n- Verify completely\n\n**Spec and code in sync = quality software.**\n",
        "sdd/skills/help/SKILL.md": "---\nname: help\ndescription: Display SDD quick reference and offer to answer questions about the workflow\n---\n\n# SDD Help\n\n## Overview\n\nDisplay a one-page quick reference for all SDD commands, then offer to answer questions.\n\n## Execution\n\n1. **Read the quick reference file:**\n   - Read `sdd/skills/help/quick-reference.md`\n\n2. **Display the content:**\n   - Present the entire quick reference as a single, scannable page\n   - Use the content as-is (it's designed to be compact)\n\n3. **Offer to help:**\n   After displaying the reference, say:\n\n   > Any questions about the SDD workflow? I can explain any command in detail, help you choose the right one for your situation, or walk you through a specific scenario.\n\n4. **Answer follow-up questions:**\n   - If the user asks about a specific command, explain it in detail\n   - If they describe a situation, recommend the appropriate command\n   - If they want to try something, offer to run that command with them\n   - Point them to `/sdd:tutorial` if they want a deeper introduction\n\n## GitHub Capability Check\n\nWhen users ask about PR workflows or want to create PRs:\n\n1. **Check for GitHub MCP server first** (preferred):\n   - Look for `mcp__plugin_github_github__*` tools in available tools\n   - If available, use MCP tools for PR operations\n\n2. **Fall back to gh CLI**:\n   - If no GitHub MCP server, check if `gh` CLI is available: `gh --version`\n   - If available, use `gh pr create` for PR operations\n\n3. **If neither is available**:\n   - Inform the user that PR creation requires either:\n     - GitHub MCP server (recommended)\n     - `gh` CLI tool (`brew install gh` or similar)\n   - They can still create PRs manually using the branch\n\n## Guidelines\n\n- Keep the initial display clean and uncluttered\n- Don't add explanatory text around the reference; let it speak for itself\n- Be ready to go deeper on any topic if asked\n- For complex questions, consider recommending the tutorial\n- When discussing team workflows, mention the two-PR pattern (spec PR, then code PR)\n",
        "sdd/skills/help/quick-reference.md": "# SDD Quick Reference\n\n## Commands at a Glance\n\n```\nSPECIFICATION\n  /sdd:brainstorm     Rough idea ‚Üí formal spec (interactive dialogue)\n  /sdd:spec           Clear requirements ‚Üí spec (direct creation)\n  /sdd:constitution   Define project-wide principles and standards\n\nVALIDATION\n  /sdd:review-spec    Check spec quality and completeness\n  /sdd:review-code    Check code compliance against spec\n\nIMPLEMENTATION\n  /sdd:implement      Build code from spec using TDD\n\nEVOLUTION\n  /sdd:evolve         Reconcile spec/code drift\n\nLEARNING\n  /sdd:tutorial       Interactive SDD introduction\n  /sdd:help           This quick reference\n```\n\n## Decision Guide\n\n| You Have | You Want | Use |\n|----------|----------|-----|\n| Vague idea | Clear spec | `/sdd:brainstorm` |\n| Clear requirements | Formal spec | `/sdd:spec` |\n| Validated spec | Working code | `/sdd:implement` |\n| Draft spec | Quality check | `/sdd:review-spec` |\n| Code changes | Compliance check | `/sdd:review-code` |\n| Spec/code mismatch | Realignment | `/sdd:evolve` |\n| New project | Standards | `/sdd:constitution` |\n\n## Core Workflow\n\n```\n1. SPEC      Idea ‚Üí Spec (brainstorm or spec)\n2. REVIEW    Validate spec (review-spec)\n3. SPEC PR   Create PR for spec review (team alignment)\n4. IMPLEMENT Build from spec (implement)\n5. VERIFY    Check compliance (review-code)\n6. CODE PR   Create PR for implementation\n7. EVOLVE    Fix drift when needed (evolve)\n```\n\n## Team PR Workflow\n\nFor team projects, use two PRs per feature:\n\n1. **Spec PR** - After spec creation, before implementation\n   - Team reviews and aligns on WHAT before debating HOW\n   - Catches requirement issues early\n\n2. **Code PR** - After implementation passes verification\n   - Implementation review with spec as reference\n   - Reviewers can check code-to-spec compliance\n\n**Requires:** GitHub MCP server (preferred) or `gh` CLI tool\n\n## Key Principles\n\n- **Spec-first**: Always spec before code\n- **WHAT, not HOW**: Specs define requirements, not implementation\n- **Evolution is healthy**: Specs change as you learn\n- **Verify both ways**: Tests pass AND code matches spec\n",
        "sdd/skills/implement/SKILL.md": "---\nname: implement\ndescription: Use when spec exists and is validated - generates implementation plan FROM spec, executes with TDD, and verifies spec compliance throughout\n---\n\n# Spec-Driven Implementation\n\n## Overview\n\nImplement features from validated specifications using Test-Driven Development, with continuous spec compliance checking throughout.\n\nThis is the core SDD implementation workflow: Spec ‚Üí Plan ‚Üí TDD ‚Üí Verify.\n\n**Critical Rule:** Implementation MUST match spec. Any deviation triggers spec evolution workflow.\n\n## When to Use\n\n**Use this skill when:**\n- Spec exists and is validated\n- Ready to write code\n- Starting implementation of new feature\n\n**Don't use this skill when:**\n- No spec exists ‚Üí Use `sdd:spec` or `sdd:brainstorm` first\n- Spec/code mismatch exists ‚Üí Use `sdd:evolve`\n- Debugging existing code ‚Üí Use `systematic-debugging`\n\n## Technical Prerequisites\n\nEnsure spec-kit is initialized:\n\n{Skill: spec-kit}\n\nIf spec-kit prompts for restart, pause this workflow and resume after restart.\n\n## Workflow Prerequisites\n\n**Before starting implementation:**\n- [ ] Spec exists in `specs/features/[feature-name].md`\n- [ ] Spec validated for soundness (`sdd:review-spec`)\n- [ ] Spec validated against constitution (if exists)\n- [ ] No open questions in spec that block implementation\n\n**If prerequisites not met:** Stop and address them first.\n\n## The Process\n\n### 1. Read and Understand Spec\n\n**Load the spec:**\n```bash\ncat specs/features/[feature-name].md\n```\n\n**Extract key information:**\n- Functional requirements (what to build)\n- Success criteria (how to verify)\n- Error handling (what can go wrong)\n- Dependencies (what's needed)\n- Constraints (limitations)\n\n**Validate understanding:**\n- Summarize spec back to user\n- Confirm no ambiguities remain\n- Identify any implementation questions\n\n### 2. Generate Implementation Plan FROM Spec\n\n**Use `sdd:writing-plans` skill** to create plan.\n\n**The plan MUST:**\n- Derive directly from spec requirements\n- Include all functional requirements\n- Cover all error cases\n- Address all edge cases\n- Reference spec sections explicitly\n\n**Plan structure:**\n```markdown\n# Implementation Plan: [Feature Name]\n\n**Source Spec:** specs/features/[feature-name].md\n**Date:** YYYY-MM-DD\n\n## Requirements Coverage\n\n### Functional Requirement 1: [From spec]\n**Implementation approach:**\n- [ ] Task 1\n- [ ] Task 2\n...\n\n[Repeat for all functional requirements]\n\n## Error Handling Implementation\n\n[For each error case in spec]\n- **Error:** [From spec]\n- **Implementation:** [How to handle]\n\n## Test Strategy\n\n[How we'll verify each requirement]\n\n## Files to Create/Modify\n\n[List with file paths]\n\n## Verification Steps\n\n- [ ] All tests pass\n- [ ] Spec compliance check passes\n- [ ] Code review against spec\n```\n\n**Save plan:** `docs/plans/[date]-[feature]-implementation.md`\n\n### 3. Set Up Isolated Workspace\n\n**Use `using-git-worktrees`** (optional but recommended):\n\n```bash\ngit worktree add ../feature-[name] -b feature/[name]\ncd ../feature-[name]\n```\n\n**Or work in current branch:**\n- Ensure clean working directory\n- Create feature branch if needed\n\n### 4. Implement with Test-Driven Development\n\n**Use `test-driven-development` skill.**\n\n**For each requirement in spec:**\n\n1. **Write test first** (based on spec requirement)\n   - Test validates spec requirement directly\n   - Include error cases from spec\n   - Include edge cases from spec\n\n2. **Watch it fail**\n   - Confirms test is testing the right thing\n   - Red phase of TDD\n\n3. **Write minimal code to pass**\n   - Implement spec requirement\n   - Don't add features not in spec\n   - Green phase of TDD\n\n4. **Refactor**\n   - Clean up while keeping tests green\n   - Refactor phase of TDD\n\n5. **Verify spec compliance**\n   - Does code match spec requirement?\n   - Check implementation against spec section\n   - Document any necessary deviations\n\n**Track progress with TodoWrite:**\n- Mark requirements as in_progress/completed\n- One requirement at a time\n- Don't skip or batch\n\n### 5. Continuous Spec Compliance Checking\n\n**During implementation, regularly check:**\n\n```bash\n# Compare implementation to spec\n# For each functional requirement:\n# - ‚úì Implemented as specified\n# - ‚úó Deviation detected ‚Üí document reason\n```\n\n**If deviation needed:**\n- Document WHY spec cannot be followed\n- Note what changed and reason\n- Will trigger `sdd:evolve` during review\n\n### 6. Code Review Against Spec\n\n**Use `sdd:review-code` skill.**\n\n**Review checks:**\n- Code implements all spec requirements\n- No extra features beyond spec\n- Error handling matches spec\n- Edge cases covered per spec\n- Tests validate spec requirements\n\n**Output:**\n- Compliance score (% of requirements met)\n- List of deviations with reasons\n- Recommendations: approve or evolve\n\n### 7. Verification Before Completion\n\n**Use `sdd:verification-before-completion` skill.**\n\n**Verification steps:**\n1. All tests pass\n2. Spec compliance validation passes\n3. No unaddressed deviations\n4. All success criteria met (from spec)\n\n**If verification fails:** Fix issues before claiming completion.\n\n## Checklist\n\nUse TodoWrite to track:\n\n- [ ] Read and understand spec\n- [ ] Generate implementation plan from spec\n- [ ] Set up workspace (worktree or branch)\n- [ ] For each requirement: TDD cycle (test, fail, implement, pass, refactor)\n- [ ] Check spec compliance continuously\n- [ ] Request code review against spec\n- [ ] Run verification (tests + spec compliance)\n- [ ] Address any deviations (evolve spec or fix code)\n- [ ] Commit implementation\n- [ ] Clean up workspace\n\n## Example Flow\n\n```\nUser: Let's implement the user profile API from the spec\n\nYou: I'm using sdd:implement to build this feature from the spec.\n\nReading spec: specs/features/user-profile-api.md\n\nThe spec defines:\n- PUT /api/users/:id/profile endpoint\n- Fields: name (2-50 chars), bio (max 500), avatar_url\n- Auth: JWT required\n- Errors: 401, 403, 404, 422\n- Success criteria: authenticated users can update profiles\n\nGenerating implementation plan from spec...\n[Uses sdd:writing-plans]\n\nPlan created: docs/plans/2025-11-10-user-profile-api-implementation.md\n\nPlan includes:\n1. Create route handler (src/api/users/profile.ts)\n2. Add validation middleware (src/middleware/validate-profile.ts)\n3. Update service layer (src/services/user.ts)\n4. Add tests (tests/api/users/profile.test.ts)\n\nReady to implement with TDD. Starting...\n\n[Uses test-driven-development]\n\nTest 1: Should reject unauthenticated requests (Spec: Error Handling)\n\nWriting test...\n```typescript\ntest('PUT /api/users/:id/profile returns 401 without JWT', async () => {\n  const response = await request(app)\n    .put('/api/users/123/profile')\n    .send({ name: 'Test' });\n\n  expect(response.status).toBe(401);\n  expect(response.body.error).toBe('Authentication required');\n});\n```\n\nRunning test... ‚ùå FAIL (expected - no auth implemented yet)\n\nImplementing auth middleware...\n[Adds JWT validation]\n\nRunning test... ‚úÖ PASS\n\nSpec compliance check:\n‚úì Matches spec requirement: \"User must be authenticated with valid JWT\"\n‚úì Error message matches spec: \"Authentication required\"\n\n---\n\nTest 2: Should validate name length (Spec: Functional Requirements #2)\n\nWriting test...\n```typescript\ntest('PUT /api/users/:id/profile validates name length', async () => {\n  const token = generateTestJWT({ sub: '123' });\n\n  // Too short\n  let response = await request(app)\n    .put('/api/users/123/profile')\n    .set('Authorization', `Bearer ${token}`)\n    .send({ name: 'A' });\n\n  expect(response.status).toBe(422);\n\n  // Too long\n  response = await request(app)\n    .put('/api/users/123/profile')\n    .set('Authorization', `Bearer ${token}`)\n    .send({ name: 'A'.repeat(51) });\n\n  expect(response.status).toBe(422);\n\n  // Valid\n  response = await request(app)\n    .put('/api/users/123/profile')\n    .set('Authorization', `Bearer ${token}`)\n    .send({ name: 'Valid Name' });\n\n  expect(response.status).toBe(200);\n});\n```\n\nRunning test... ‚ùå FAIL\n\nImplementing validation...\n[Adds name length validation]\n\nRunning test... ‚úÖ PASS\n\nSpec compliance check:\n‚úì Matches spec: \"name: string, 2-50 characters\"\n\n---\n\n[Continues through all requirements...]\n\nAll requirements implemented ‚úì\n\nRequesting code review against spec...\n[Uses sdd:review-code]\n\nCode Review Results:\n‚úì All functional requirements implemented (6/6)\n‚úì All error cases handled (4/4)\n‚úì All edge cases covered (3/3)\n‚úì Tests validate spec requirements\n\nSpec Compliance: 100%\n\nDeviations detected: 1\n- Added `updated_at` field to response (not in spec)\n  Reason: Standard practice for update endpoints\n  Recommendation: Update spec (minor addition)\n\nRunning verification...\n[Uses sdd:verification-before-completion]\n\n‚úÖ All tests passing (24/24)\n‚úÖ Spec compliance validated\n‚ö†Ô∏è  Minor deviation: updated_at field\n\nRecommendation: Use sdd:evolve to update spec with updated_at field\n\nYou: Should I update the spec to include the updated_at field?\n```\n\n## Handling Deviations\n\n**When code deviates from spec:**\n\n1. **Document the deviation** during implementation\n2. **Note the reason** (technical constraint, better approach, etc.)\n3. **Continue implementation** (don't block on it)\n4. **Trigger evolution** during review\n5. **Use `sdd:evolve`** to reconcile\n\n**Never:**\n- Silently deviate without documentation\n- Force-fit code to incorrect spec\n- Skip spec compliance checks\n\n## Integration with Superpowers Skills\n\n**This skill orchestrates:**\n- `sdd:writing-plans` - Generate plan from spec\n- `test-driven-development` - TDD implementation\n- `sdd:review-code` - Spec compliance review\n- `sdd:verification-before-completion` - Tests + spec validation\n- `sdd:evolve` - If deviations need reconciliation\n\n**Also compatible with:**\n- `using-git-worktrees` - Isolated workspace\n- `systematic-debugging` - If bugs found during implementation\n\n## Success Criteria\n\n**Implementation is complete when:**\n- [ ] All spec requirements implemented\n- [ ] All tests passing\n- [ ] Spec compliance 100% (or deviations reconciled)\n- [ ] Code review passed\n- [ ] Verification passed\n- [ ] All success criteria from spec met\n\n## Common Pitfalls\n\n**Avoid:**\n- Implementing features not in spec\n- Skipping TDD (spec doesn't mean no tests!)\n- Ignoring error cases from spec\n- Deviating without documentation\n- Claiming completion before verification\n\n**Instead:**\n- Implement only what's in spec (YAGNI)\n- TDD for every requirement\n- Test all error cases from spec\n- Document all deviations\n- Verify before completing\n\n## Remember\n\n**The spec is your contract.**\n\n- Don't add features not in spec\n- Don't skip requirements from spec\n- Don't ignore error cases in spec\n- Don't deviate silently\n\n**If spec is wrong or incomplete:**\n- Document the issue\n- Continue implementation\n- Use `sdd:evolve` to fix spec\n\n**Quality gates exist for a reason:**\n- TDD ensures testability\n- Code review ensures compliance\n- Verification ensures correctness\n\n**Follow the process. Ship quality code that matches the spec.**\n",
        "sdd/skills/review-code/SKILL.md": "---\nname: review-code\ndescription: Review code against spec compliance - checks implementation matches spec requirements, identifies deviations, reports compliance score, triggers evolution if needed\n---\n\n# Code Review Against Specification\n\n## Overview\n\nReview code implementation against specification to ensure compliance.\n\n**Key Difference from Standard Code Review:**\n- Primary focus: **Does code match spec?**\n- Secondary focus: Code quality, patterns, best practices\n- Output: **Compliance score** + deviation list\n- Triggers: **Spec evolution** if mismatches found\n\n## When to Use\n\n- After implementation complete (called by `sdd:implement`)\n- Before merging/deploying code\n- When validating existing code against spec\n- As part of verification workflow\n\n## The Process\n\n### 1. Load Spec and Code\n\n**Read specification:**\n```bash\ncat specs/features/[feature-name].md\n```\n\n**Identify implementation files:**\n```bash\n# From implementation plan or code exploration\nls -la [implementation-files]\n```\n\n### 2. Review Functional Requirements\n\n**For each functional requirement in spec:**\n\n1. **Find implementation** in code\n2. **Compare behavior**: Does code do what spec says?\n3. **Check completeness**: All aspects implemented?\n4. **Note deviations**: Any differences?\n\n**Create compliance matrix:**\n```\nRequirement 1: [Spec text]\n  Implementation: [file:line]\n  Status: ‚úì Compliant | ‚úó Deviation | ? Missing\n  Notes: [If deviation, explain]\n\nRequirement 2: [Spec text]\n  ...\n```\n\n### 3. Review Error Handling\n\n**For each error case in spec:**\n\n1. **Find error handling** in code\n2. **Check error response**: Matches spec?\n3. **Verify error codes**: Correct HTTP status / error codes?\n4. **Test error messages**: Clear and helpful?\n\n**Error handling compliance:**\n```\nError Case 1: [From spec]\n  Implemented: Yes/No\n  Location: [file:line]\n  Response: [What code returns]\n  Spec Expected: [What spec says]\n  Status: ‚úì / ‚úó\n```\n\n### 4. Review Edge Cases\n\n**For each edge case in spec:**\n\n1. **Find handling** in code\n2. **Check behavior**: Matches spec?\n3. **Verify tests**: Edge case tested?\n\n### 5. Check for Extra Features\n\n**Identify code features NOT in spec:**\n\n- Functions/endpoints not mentioned in spec\n- Behavior beyond spec requirements\n- Additional error handling\n- Extra validations\n\n**For each extra feature:**\n- Document what it does\n- Assess: Helpful addition or scope creep?\n- Note for potential spec update\n\n### 6. Calculate Compliance Score\n\n**Formula:**\n```\nCompliance % = (Compliant Requirements / Total Requirements) √ó 100\n```\n\n**Include:**\n- Functional requirements\n- Error cases\n- Edge cases\n- Non-functional requirements\n\n**Example:**\n```\nFunctional: 8/8 = 100%\nError Cases: 3/4 = 75%\nEdge Cases: 2/3 = 67%\nNon-Functional: 3/3 = 100%\n\nOverall: 16/18 = 89%\n```\n\n### 7. Generate Report\n\n**Report structure:**\n\n```markdown\n# Code Review: [Feature Name]\n\n**Spec:** specs/features/[feature].md\n**Date:** YYYY-MM-DD\n**Reviewer:** Claude (sdd:review-code)\n\n## Compliance Summary\n\n**Overall Score: XX%**\n\n- Functional Requirements: X/X (XX%)\n- Error Handling: X/X (XX%)\n- Edge Cases: X/X (XX%)\n- Non-Functional: X/X (XX%)\n\n## Detailed Review\n\n### Functional Requirements\n\n#### ‚úì Requirement 1: [Spec text]\n**Implementation:** src/[file]:line\n**Status:** Compliant\n**Notes:** Correctly implemented as specified\n\n#### ‚úó Requirement 2: [Spec text]\n**Implementation:** src/[file]:line\n**Status:** Deviation\n**Issue:** [What differs from spec]\n**Impact:** [Minor/Major]\n**Recommendation:** [Update spec / Fix code]\n\n### Error Handling\n\n[Similar format for each error case]\n\n### Edge Cases\n\n[Similar format for each edge case]\n\n### Extra Features (Not in Spec)\n\n#### [Feature name]\n**Location:** src/[file]:line\n**Description:** [What it does]\n**Assessment:** [Helpful / Scope creep]\n**Recommendation:** [Add to spec / Remove]\n\n## Code Quality Notes\n\n[Secondary observations about code quality, patterns, etc.]\n\n## Recommendations\n\n### Critical (Must Fix)\n- [ ] [Issue requiring immediate attention]\n\n### Spec Evolution Candidates\n- [ ] [Deviation that might warrant spec update]\n\n### Optional Improvements\n- [ ] [Nice-to-have suggestions]\n\n## Conclusion\n\n[Overall assessment]\n\n**Next Steps:**\n- If compliance < 100%: Use `sdd:evolve` to reconcile deviations\n- If compliance = 100%: Proceed to verification\n```\n\n### 8. Trigger Evolution if Needed\n\n**If deviations found:**\n- Present review results to user\n- Recommend using `sdd:evolve`\n- Don't proceed to verification until resolved\n\n**If 100% compliant:**\n- Approve for verification\n- Proceed to `sdd:verification-before-completion`\n\n## Review Checklist\n\nUse TodoWrite to track:\n\n- [ ] Load specification\n- [ ] Identify all implementation files\n- [ ] Review each functional requirement\n- [ ] Review each error case\n- [ ] Review each edge case\n- [ ] Identify extra features not in spec\n- [ ] Calculate compliance score\n- [ ] Generate detailed review report\n- [ ] Make recommendations\n- [ ] Trigger evolution if deviations found\n\n## Example Output\n\n```\n# Code Review: User Profile Update API\n\n**Spec:** specs/features/user-profile-api.md\n**Date:** 2025-11-10\n**Reviewer:** Claude (sdd:review-code)\n\n## Compliance Summary\n\n**Overall Score: 94%**\n\n- Functional Requirements: 6/6 (100%)\n- Error Handling: 4/4 (100%)\n- Edge Cases: 3/3 (100%)\n- Non-Functional: 2/3 (67%)\n\n## Detailed Review\n\n### Functional Requirements\n\n#### ‚úì Requirement 1: PUT endpoint accepts requests\n**Implementation:** src/api/users/profile.ts:12\n**Status:** Compliant\n**Notes:** Route correctly configured at PUT /api/users/:id/profile\n\n#### ‚úì Requirement 2: Validates request body\n**Implementation:** src/middleware/validation/profile.ts:5\n**Status:** Compliant\n**Notes:** All validations match spec (name 2-50, bio max 500, avatar_url URL)\n\n[... all ‚úì ...]\n\n### Error Handling\n\n#### ‚úì Error: Missing/Invalid JWT\n**Implementation:** src/middleware/auth.ts:22\n**Status:** Compliant\n**Spec Expected:** 401 with \"Authentication required\"\n**Actual:** 401 with \"Authentication required\" ‚úì\n\n[... all ‚úì ...]\n\n### Non-Functional Requirements\n\n#### ‚úó Performance: Response time < 200ms\n**Status:** Not Verified\n**Issue:** No performance testing implemented\n**Impact:** Minor (likely meets requirement but unverified)\n**Recommendation:** Add performance test or update spec to remove specific timing\n\n### Extra Features (Not in Spec)\n\n#### Updated timestamp in response\n**Location:** src/api/users/profile.ts:45\n**Description:** Adds `updated_at` timestamp to response object\n**Assessment:** Helpful - standard practice for update endpoints\n**Recommendation:** Add to spec (minor addition)\n\n## Recommendations\n\n### Spec Evolution Candidates\n- [ ] Add `updated_at` field to response spec (minor addition)\n- [ ] Remove specific performance timing or add perf tests\n\n## Conclusion\n\nCode implementation is 94% compliant with spec. All functional requirements and error handling correctly implemented. One non-functional requirement unverified and one helpful feature added beyond spec.\n\n**Next Steps:**\nUse `sdd:evolve` to update spec with:\n1. `updated_at` field (minor addition)\n2. Clarify performance requirement (remove specific timing or add test)\n\nAfter spec evolution, compliance will be 100%.\n```\n\n## Assessment Criteria\n\n### Compliant (‚úì)\n- Code does exactly what spec says\n- No deviations in behavior\n- All aspects covered\n\n### Minor Deviation (‚ö†)\n- Small differences (naming, details)\n- Non-breaking additions\n- Better error messages than spec\n- Typically ‚Üí Update spec\n\n### Major Deviation (‚úó)\n- Different behavior than spec\n- Missing functionality\n- Wrong error handling\n- Typically ‚Üí Fix code or evolve spec\n\n### Missing (?)\n- Spec requires it, code doesn't have it\n- Critical gap\n- Must fix code\n\n## Anti-Rationalization: What You Must NOT Do\n\n**DO NOT skip checking ANY requirement.** Each spec requirement must be verified against code. Not \"spot checking.\" Not \"seems fine.\" Every. Single. One.\n\n**DO NOT assume compliance.** \"It looks right\" is not compliance. \"I think it matches\" is not compliance. Show the code location. Compare the behavior. Document the status.\n\n**DO NOT hide deviations.** A deviation is not a failure; it's information. Hiding deviations breaks the feedback loop. Report every deviation, even minor ones.\n\n**DO NOT proceed with deviations unresolved.** 89% compliance is NOT ready for verification. 99% compliance is NOT ready for verification. Only 100% compliance proceeds to verification.\n\n**DO NOT rationalize scope creep.** \"But this feature is useful!\" is not justification for unspecified code. Either add it to the spec (via evolution) or remove it. Undocumented features are invisible bugs.\n\n**DO NOT conflate code quality with spec compliance.** Code can be beautiful AND non-compliant. Code can be ugly AND compliant. Check both, report both, but never confuse them.\n\n## Remember\n\n**Spec compliance is primary concern.**\n\nThis is not just code quality review; it's **spec validation**.\n\n- Does code match spec? (Most important)\n- Is code quality good? (Secondary)\n- Any improvements? (Tertiary)\n\n**100% compliance is the goal.**\n\n- < 90%: Significant issues, fix before proceeding\n- 90-99%: Minor deviations, likely spec updates\n- 100%: Perfect compliance, ready for verification\n\n**Deviations trigger evolution.**\n\n- Don't force-fit wrong spec\n- Don't ignore deviations\n- Use `sdd:evolve` to reconcile\n\n**The code and spec must tell the same story.**\n\n**Evidence before assertions. Always.**\n",
        "sdd/skills/review-spec/SKILL.md": "---\nname: review-spec\ndescription: Review specifications for soundness, completeness, and implementability - validates structure, identifies ambiguities, checks for gaps before implementation\n---\n\n# Reviewing Specifications for Soundness\n\n## Overview\n\nValidate specification quality before implementation begins.\n\nA poor spec leads to confusion, rework, and spec/code drift. A sound spec enables smooth implementation.\n\nThis skill checks: completeness, clarity, implementability, and testability.\n\n## When to Use\n\n- After spec creation (before implementation)\n- Before generating implementation plan\n- When spec seems unclear or incomplete\n- Periodically for important specs\n\n## Prerequisites\n\nEnsure spec-kit is initialized:\n\n{Skill: spec-kit}\n\nIf spec-kit prompts for restart, pause this workflow and resume after restart.\n\n## Review Dimensions\n\n### 1. Completeness\n- All sections filled\n- No TBD or placeholder text\n- All requirements defined\n- Success criteria specified\n\n### 2. Clarity\n- No ambiguous language\n- Concrete, specific requirements\n- Edge cases explicitly defined\n- Error handling specified\n\n### 3. Implementability\n- Can generate implementation plan\n- Dependencies identified\n- Constraints realistic\n- Scope manageable\n\n### 4. Testability\n- Success criteria measurable\n- Requirements verifiable\n- Acceptance criteria clear\n\n## The Process\n\n### 1. Load and Read Spec\n\n```bash\ncat specs/features/[feature-name].md\n```\n\nRead thoroughly, take notes on issues.\n\n### 2. Check Structure\n\n**Required sections (should exist):**\n- [ ] Purpose/Overview\n- [ ] Functional Requirements\n- [ ] Success Criteria\n- [ ] Error Handling\n\n**Recommended sections:**\n- [ ] Non-Functional Requirements\n- [ ] Edge Cases\n- [ ] Dependencies\n- [ ] Constraints\n- [ ] Out of Scope\n\n**If sections missing:**\n- Note which ones\n- Assess if truly needed for this spec\n- Recommend additions\n\n### 3. Review Completeness\n\n**For each section, check:**\n\n**Purpose:**\n- [ ] Clearly states why feature exists\n- [ ] Describes problem being solved\n- [ ] Avoids implementation details\n\n**Functional Requirements:**\n- [ ] Numbered/listed clearly\n- [ ] Each requirement is specific\n- [ ] No \"TBD\" or placeholders\n- [ ] All aspects covered\n\n**Success Criteria:**\n- [ ] Measurable outcomes defined\n- [ ] Clear completion indicators\n- [ ] Testable assertions\n\n**Error Handling:**\n- [ ] All error cases identified\n- [ ] Handling approach specified\n- [ ] Error messages/codes defined\n\n**Edge Cases:**\n- [ ] Boundary conditions listed\n- [ ] Expected behavior specified\n- [ ] Not marked as \"TBD\"\n\n### 4. Check for Ambiguities\n\n**Red flag words/phrases:**\n- \"should\" (vs \"must\")\n- \"might\", \"could\", \"probably\"\n- \"fast\", \"slow\" (without metrics)\n- \"user-friendly\" (vague)\n- \"handle appropriately\" (non-specific)\n- \"etc.\" (incomplete list)\n- \"similar to...\" (unclear)\n\n**For each ambiguity:**\n- Identify the vague requirement\n- Note what's unclear\n- Suggest specific alternative\n\n### 5. Validate Implementability\n\n**Ask:**\n- Can I generate an implementation plan from this?\n- Are file locations/components identifiable?\n- Are dependencies clear?\n- Is scope reasonable?\n\n**Check for:**\n- Unknown dependencies\n- Unrealistic constraints\n- Scope too large\n- Conflicting requirements\n\n### 6. Assess Testability\n\n**For each requirement:**\n- How will this be tested?\n- Is the outcome verifiable?\n- Can success be measured?\n\n**For success criteria:**\n- Are they specific enough to test?\n- Can they be automated?\n- Are they objective (not subjective)?\n\n### 7. Check Against Constitution\n\n**If constitution exists:**\n\n```bash\ncat specs/constitution.md\n```\n\n**Validate:**\n- Does spec follow project principles?\n- Are patterns consistent?\n- Does error handling match standards?\n- Are architectural decisions aligned?\n\n**Note any violations with reasoning.**\n\n### 8. Generate Review Report\n\n**Report structure:**\n\n```markdown\n# Spec Review: [Feature Name]\n\n**Spec:** specs/features/[feature].md\n**Date:** YYYY-MM-DD\n**Reviewer:** Claude (sdd:review-spec)\n\n## Overall Assessment\n\n**Status:** ‚úÖ SOUND / ‚ö†Ô∏è NEEDS WORK / ‚ùå MAJOR ISSUES\n\n**Summary:** [1-2 sentence overall assessment]\n\n## Completeness: [Score/5]\n\n### Structure\n- [‚úì/‚úó] All required sections present\n- [‚úì/‚úó] Recommended sections included\n- [‚úì/‚úó] No placeholder text\n\n### Coverage\n- [‚úì/‚úó] All functional requirements defined\n- [‚úì/‚úó] Error cases identified\n- [‚úì/‚úó] Edge cases covered\n- [‚úì/‚úó] Success criteria specified\n\n**Issues:**\n- [List any completeness issues]\n\n## Clarity: [Score/5]\n\n### Language Quality\n- [‚úì/‚úó] No ambiguous language\n- [‚úì/‚úó] Requirements are specific\n- [‚úì/‚úó] No vague terms\n\n**Ambiguities Found:**\n1. [Quote ambiguous text]\n   - Issue: [What's unclear]\n   - Suggestion: [Specific alternative]\n\n## Implementability: [Score/5]\n\n### Plan Generation\n- [‚úì/‚úó] Can generate implementation plan\n- [‚úì/‚úó] Dependencies identified\n- [‚úì/‚úó] Constraints realistic\n- [‚úì/‚úó] Scope manageable\n\n**Issues:**\n- [List any implementability issues]\n\n## Testability: [Score/5]\n\n### Verification\n- [‚úì/‚úó] Success criteria measurable\n- [‚úì/‚úó] Requirements verifiable\n- [‚úì/‚úó] Acceptance criteria clear\n\n**Issues:**\n- [List any testability issues]\n\n## Constitution Alignment\n\n[If constitution exists]\n\n- [‚úì/‚úó] Follows project principles\n- [‚úì/‚úó] Patterns consistent\n- [‚úì/‚úó] Error handling aligned\n\n**Violations:**\n- [List any violations]\n\n## Recommendations\n\n### Critical (Must Fix Before Implementation)\n- [ ] [Critical issue 1]\n- [ ] [Critical issue 2]\n\n### Important (Should Fix)\n- [ ] [Important issue 1]\n\n### Optional (Nice to Have)\n- [ ] [Optional improvement 1]\n\n## Conclusion\n\n[Final assessment and recommendation]\n\n**Ready for implementation:** Yes / No / After fixes\n\n**Next steps:**\n[What should be done]\n```\n\n### 9. Make Recommendation\n\n**If sound (minor issues only):**\n- ‚úÖ Ready for implementation\n- Proceed with `sdd:implement`\n\n**If needs work (important issues):**\n- ‚ö†Ô∏è Fix issues before implementing\n- Update spec, re-review\n\n**If major issues:**\n- ‚ùå Not ready for implementation\n- Significant rework needed\n- May need re-brainstorming\n\n## Review Checklist\n\nUse TodoWrite to track:\n\n- [ ] Load and read spec thoroughly\n- [ ] Check structure (all sections present)\n- [ ] Review completeness (no TBD, all covered)\n- [ ] Identify ambiguities (vague language)\n- [ ] Validate implementability (can plan from this)\n- [ ] Assess testability (can verify requirements)\n- [ ] Check constitution alignment (if exists)\n- [ ] Generate review report\n- [ ] Make recommendation (ready/needs work/major issues)\n\n## Example: Sound Spec\n\n```\n# Spec Review: User Profile Update API\n\n**Spec:** specs/features/user-profile-api.md\n**Status:** ‚úÖ SOUND\n\n## Overall Assessment\n\nSpecification is well-written, complete, and ready for implementation.\nMinor suggestions for improvement but no blocking issues.\n\n## Completeness: 5/5\n\n‚úì All required sections present\n‚úì All functional requirements clearly defined (6 requirements)\n‚úì All error cases identified (4 cases)\n‚úì All edge cases covered (3 cases)\n‚úì Success criteria specified and measurable\n\n## Clarity: 4.5/5\n\n‚úì Requirements are specific and unambiguous\n‚úì Error handling clearly defined\n‚ö†Ô∏è One minor ambiguity (see below)\n\n**Ambiguities Found:**\n1. \"Response should be fast\"\n   - Issue: \"Fast\" is subjective\n   - Suggestion: Specify \"Response time < 200ms\" or remove\n\n## Implementability: 5/5\n\n‚úì Can generate detailed implementation plan\n‚úì All dependencies identified (JWT auth, database)\n‚úì Constraints are realistic\n‚úì Scope is manageable (single endpoint)\n\n## Testability: 5/5\n\n‚úì All success criteria measurable\n‚úì Each requirement verifiable through tests\n‚úì Clear acceptance criteria\n\n## Constitution Alignment\n\n‚úì Follows RESTful conventions (from constitution)\n‚úì Error handling matches project patterns\n‚úì Auth requirements aligned with standards\n\n## Recommendations\n\n### Important (Should Fix)\n- [ ] Clarify \"fast\" response requirement (specify < 200ms or remove)\n\n### Optional\n- [ ] Consider adding rate limiting requirement\n- [ ] Specify audit logging if required by project\n\n## Conclusion\n\nExcellent spec, ready for implementation after minor clarification on\nperformance requirement.\n\n**Ready for implementation:** Yes (after performance clarification)\n\n**Next steps:** Clarify \"fast\" requirement, then proceed to sdd:implement\n```\n\n## Example: Needs Work\n\n```\n# Spec Review: Real-time Notifications\n\n**Spec:** specs/features/real-time-notifications.md\n**Status:** ‚ö†Ô∏è NEEDS WORK\n\n## Overall Assessment\n\nSpecification has good foundation but several important gaps that will\ncause confusion during implementation.\n\n## Completeness: 3/5\n\n‚úì Purpose clearly stated\n‚úó Non-functional requirements missing\n‚úó Error handling incomplete\n‚ö†Ô∏è Edge cases partially defined\n\n**Issues:**\n- No specification of real-time latency requirements\n- Database storage requirements unclear\n- Error recovery not defined\n- Scalability requirements missing\n\n## Clarity: 3/5\n\n**Ambiguities Found:**\n1. \"Notifications should appear in real-time\"\n   - Issue: \"Real-time\" undefined (< 100ms? < 1s? < 5s?)\n   - Suggestion: Specify exact latency requirement\n\n2. \"Handle notification delivery failures appropriately\"\n   - Issue: \"Appropriately\" is non-specific\n   - Suggestion: Define retry logic, fallback, user notification\n\n3. \"Support many users\"\n   - Issue: \"Many\" is vague\n   - Suggestion: Specify target (100? 1000? 10000?)\n\n## Implementability: 2/5\n\n‚úó Cannot generate complete implementation plan\n‚úó Technology stack not specified (WebSocket? SSE? Polling?)\n‚úó Storage mechanism unclear\n\n**Issues:**\n- Is this WebSocket or polling? Spec doesn't say\n- Where are notifications stored? For how long?\n- What happens when user offline?\n- No mention of infrastructure requirements\n\n## Testability: 3/5\n\n‚ö†Ô∏è Some criteria measurable, others vague\n\n**Issues:**\n- \"Users receive notifications quickly\" - not measurable\n- \"System handles failures\" - no specific test criteria\n\n## Recommendations\n\n### Critical (Must Fix Before Implementation)\n- [ ] Define exact real-time latency requirement (< Xms)\n- [ ] Specify technology (WebSocket vs polling vs SSE)\n- [ ] Define notification storage (where, how long)\n- [ ] Specify error handling and retry logic\n- [ ] Define scalability target (number of users)\n\n### Important (Should Fix)\n- [ ] Add detailed error cases\n- [ ] Specify offline handling\n- [ ] Define notification expiration\n- [ ] Add infrastructure requirements\n\n## Conclusion\n\nSpec has good intent but lacks critical technical details needed for\nimplementation. Requires significant expansion before coding can begin.\n\n**Ready for implementation:** No\n\n**Next steps:**\n1. Address all critical issues\n2. Re-review spec\n3. Then proceed to implementation\n```\n\n## Quality Standards\n\n**A sound spec has:**\n- All sections complete\n- No ambiguous language\n- Specific, measurable requirements\n- Identified dependencies\n- Realistic constraints\n- Clear error handling\n- Defined edge cases\n- Testable success criteria\n\n**A poor spec has:**\n- Missing sections\n- Vague language\n- Unmeasurable requirements\n- Unknown dependencies\n- Unrealistic constraints\n- Unclear error handling\n- Ignored edge cases\n- Subjective criteria\n\n## Remember\n\n**Reviewing specs saves time in implementation.**\n\n- 1 hour reviewing spec saves 10 hours debugging\n- Ambiguities caught early prevent rework\n- Complete specs enable smooth TDD\n- Sound specs reduce spec/code drift\n\n**Be thorough but not pedantic:**\n- Flag real issues, not nitpicks\n- Focus on what blocks implementation\n- Suggest specific improvements\n- Balance perfection with pragmatism\n\n**The goal is implementability, not perfection.**\n",
        "sdd/skills/spec-kit/SKILL.md": "---\nname: spec-kit\ndescription: Technical integration layer for spec-kit CLI - handles automatic initialization, installation validation, project setup, and ensures proper file/directory layout. Called by all SDD workflow skills.\n---\n\n# Spec-Kit Technical Integration\n\n## Purpose\n\nThis skill is the **single source of truth** for all spec-kit technical integration:\n- Automatic initialization and setup\n- Installation validation\n- Project structure management\n- CLI command wrappers\n- Layout and file path enforcement\n\n**This is a low-level technical skill.** Workflow skills (brainstorm, implement, etc.) call this skill for setup, then proceed with their specific workflows.\n\n## Automatic Initialization Protocol\n\n**IMPORTANT: This runs automatically when called by any workflow skill.**\n\nEvery SDD workflow skill calls this skill first via `{Skill: spec-kit}`. When called, execute this initialization sequence once per session.\n\n### Session Tracking\n\n```bash\n# Check if already initialized this session\n# Use an environment variable or similar mechanism\n# If \"sdd_init_done\" flag is set, skip to step 4\n```\n\n### Step 1: Check spec-kit CLI Installation\n\n```bash\nwhich speckit\n```\n\n**If NOT found:**\n```\n‚ùå ERROR: spec-kit is required but not installed\n\nspec-kit provides the templates, scripts, and tooling for SDD workflows.\n\nInstallation:\n1. Visit: https://github.com/github/spec-kit\n2. Follow installation instructions\n3. Ensure 'speckit' is in your PATH\n4. Verify: run 'which speckit'\n\nAfter installation, restart this workflow.\n```\n\n**STOP workflow.** Do not proceed without spec-kit.\n\n**If found:**\n```bash\n# Get version for logging\nspeckit --version\n```\n\nProceed to step 2.\n\n### Step 2: Check Project Initialization\n\n```bash\n# Check if .specify/ directory exists\n[ -d .specify ] && echo \"initialized\" || echo \"not-initialized\"\n```\n\n**If NOT initialized:**\n\nDisplay message:\n```\nspec-kit is installed ‚úì\n\nThis project needs initialization...\nRunning: speckit init\n```\n\nExecute initialization:\n```bash\nspeckit init\n```\n\n**Check for errors:**\n- Permission denied ‚Üí suggest running with proper permissions\n- Command failed ‚Üí display error and suggest manual init\n- Success ‚Üí proceed to step 3\n\n**If already initialized:**\nSkip to step 3.\n\n### Step 3: Check for New Commands (Restart Detection)\n\nAfter `speckit init` runs, check if local commands were installed:\n\n```bash\n# Check if spec-kit installed Claude Code commands\nif [ -d .claude/commands ]; then\n  ls .claude/commands/ | grep -q speckit\n  if [ $? -eq 0 ]; then\n    echo \"commands-installed\"\n  fi\nfi\n```\n\n**If commands were installed:**\n\nDisplay restart prompt:\n```\n‚úÖ Project initialized successfully!\n\n‚ö†Ô∏è  RESTART REQUIRED ‚ö†Ô∏è\n\nspec-kit has installed local slash commands in:\n  .claude/commands/speckit.*\n\nTo load these new commands, please:\n1. Save your work\n2. Close this conversation\n3. Restart Claude Code application\n4. Return to this project\n5. Continue your workflow\n\nAfter restart, you'll have access to:\n- /sdd:* commands (from this plugin)\n- /speckit.* commands (from local spec-kit installation)\n\n[Workflow paused - resume after restart]\n```\n\n**STOP workflow.** User must restart before continuing.\n\n**If no new commands installed:**\nProceed to step 4.\n\n### Step 4: Verify Installation\n\nQuick sanity check:\n```bash\n# Verify key files exist\n[ -f .specify/templates/spec-template.md ] && \\\n[ -f .specify/scripts/bash/common.sh ] && \\\necho \"verified\" || echo \"corrupt\"\n```\n\n**If verification fails:**\n```\n‚ùå ERROR: .specify/ exists but appears incomplete\n\nThis may be due to a failed initialization.\n\nPlease run: speckit init --force\n\nThen restart this workflow.\n```\n\n**STOP workflow.**\n\n**If verification succeeds:**\n- Set session flag: \"sdd_init_done\"\n- Return success to calling skill\n- Calling skill continues with its workflow\n\n## Layout Validation\n\nUse these helpers to validate spec-kit file structure:\n\n### Check Constitution\n\n```bash\n# Constitution location (per spec-kit convention)\nCONSTITUTION=\".specify/memory/constitution.md\"\n\nif [ -f \"$CONSTITUTION\" ]; then\n  echo \"constitution-exists\"\nelse\n  echo \"no-constitution\"\nfi\n```\n\n### Get Feature Spec Path\n\n```bash\n# Validate feature spec path follows spec-kit layout\n# Expected: specs/NNNN-feature-name/spec.md\n# Or: specs/features/feature-name.md\n\nvalidate_spec_path() {\n  local spec_path=$1\n\n  # Check if follows spec-kit conventions\n  if [[ $spec_path =~ ^specs/[0-9]+-[a-z-]+/spec\\.md$ ]] || \\\n     [[ $spec_path =~ ^specs/features/[a-z-]+\\.md$ ]]; then\n    echo \"valid\"\n  else\n    echo \"invalid: spec must be in specs/ directory with proper naming\"\n  fi\n}\n```\n\n### Get Plan Path\n\n```bash\n# Plan location (per spec-kit convention)\n# Expected: specs/NNNN-feature-name/docs/plan.md\n\nget_plan_path() {\n  local feature_dir=$1  # e.g., \"specs/0001-user-auth\"\n  echo \"$feature_dir/docs/plan.md\"\n}\n```\n\n### Ensure Directory Structure\n\n```bash\n# Create spec-kit compliant feature structure\nensure_feature_structure() {\n  local feature_dir=$1  # e.g., \"specs/0001-user-auth\"\n\n  mkdir -p \"$feature_dir/docs\"\n  mkdir -p \"$feature_dir/checklists\"\n  mkdir -p \"$feature_dir/contracts\"\n\n  echo \"created: $feature_dir structure\"\n}\n```\n\n## Spec-Kit CLI Commands\n\nWrapper helpers for common spec-kit commands:\n\n### Initialize Project\n\n```bash\n# Already covered in automatic initialization\nspeckit init\n```\n\n### Create Specification\n\n```bash\n# Interactive spec creation\nspeckit specify [feature-description]\n\n# Uses template from .specify/templates/spec-template.md\n```\n\n### Validate Specification\n\n```bash\n# Validate spec format and structure\nspeckit validate <spec-file>\n\n# Example:\nspeckit validate specs/0001-user-auth/spec.md\n```\n\n### Generate Plan\n\n```bash\n# Generate implementation plan from spec\nspeckit plan <spec-file>\n\n# Example:\nspeckit plan specs/0001-user-auth/spec.md\n```\n\n### Create Constitution\n\n```bash\n# Interactive constitution creation\nspeckit constitution\n\n# Creates .specify/memory/constitution.md\n```\n\n## Error Handling\n\n### spec-kit CLI Errors\n\n**Command not found after installation:**\n- Check PATH configuration\n- Suggest shell restart\n- Provide which speckit output\n\n**Init fails:**\n- Check write permissions\n- Check disk space\n- Suggest manual troubleshooting\n\n**Validation fails:**\n- Display validation errors\n- Suggest fixes based on error type\n- Reference spec template\n\n### File System Errors\n\n**Permission denied:**\n```\nCannot write to project directory.\n\nPlease ensure you have write permissions:\n  chmod +w .\n```\n\n**Path not found:**\n```\nExpected file not found: <path>\n\nThis suggests incomplete initialization.\nRun: speckit init --force\n```\n\n## Integration Points\n\n**Called by these workflow skills:**\n- sdd:brainstorm (at start)\n- sdd:implement (at start)\n- sdd:evolve (at start)\n- sdd:constitution (at start)\n- sdd:review-spec (at start)\n- All workflow skills that need spec-kit\n\n**Calls:**\n- spec-kit CLI (external command)\n- File system operations\n- No other skills (this is a leaf skill)\n\n## Session Management\n\n**First call in session:**\n- Run full initialization protocol\n- Check installation, project, commands\n- Prompt restart if needed\n- Set session flag\n\n**Subsequent calls in session:**\n- Check session flag\n- Skip initialization if already done\n- Optionally re-verify critical paths\n- Return success immediately\n\n**Session reset:**\n- New conversation = new session\n- Re-run initialization protocol\n- Ensures project state is current\n\n## Remember\n\n**This skill is infrastructure, not workflow.**\n\n- Don't make decisions about WHAT to build\n- Don't route to other workflow skills\n- Just ensure spec-kit is ready to use\n- Validate paths and structure\n- Handle technical errors\n\n**Workflow skills handle:**\n- What to create (specs, plans, code)\n- When to use which tool\n- Process discipline and quality gates\n\n**This skill handles:**\n- Is spec-kit installed?\n- Is project initialized?\n- Do files exist in correct locations?\n- Are commands available?\n\n**The goal: Zero-config, automatic, invisible setup.**\n",
        "sdd/skills/spec-refactoring/SKILL.md": "---\nname: spec-refactoring\ndescription: Consolidate and improve evolved specs - identifies inconsistencies, removes redundancy, improves structure while maintaining feature coverage\n---\n\n# Specification Refactoring\n\n## Overview\n\nRefactor specifications that have grown organically to improve clarity, consistency, and maintainability.\n\nAs specs evolve through `sdd:evolve`, they can accumulate:\n- Inconsistencies\n- Redundancies\n- Unclear sections\n- Poor organization\n\nThis skill consolidates and improves specs while ensuring all implemented features remain covered.\n\n## When to Use\n\n- Spec has evolved significantly through multiple updates\n- Multiple related specs have redundancy\n- Spec is difficult to understand or implement from\n- Before major feature work on legacy spec\n- Periodic maintenance (quarterly review)\n\n**Warning:** Never refactor specs during active implementation. Wait until stable.\n\n## The Process\n\n### 1. Analyze Current State\n\n**Read all related specs:**\n```bash\n# Single spec\ncat specs/features/[feature].md\n\n# Multiple related specs\ncat specs/features/user-*.md\n```\n\n**Document current issues:**\n- Inconsistencies (conflicting requirements)\n- Redundancies (duplicate requirements)\n- Unclear sections (ambiguities)\n- Poor structure (hard to navigate)\n- Outdated sections (no longer relevant)\n\n### 2. Review Implementation\n\n**Check what's actually implemented:**\n```bash\n# Find implementation\nrg \"[feature-related-terms]\" src/\n\n# Check tests\nrg \"[feature-related-terms]\" tests/\n```\n\n**Critical:** Refactored spec MUST cover all implemented features.\n\n**Create coverage map:**\n```\nImplemented Feature 1 ‚Üí Spec Requirement X\nImplemented Feature 2 ‚Üí Spec Requirement Y\n...\n```\n\nIf implementation exists without spec coverage, ADD it during refactor.\n\n### 3. Identify Consolidation Opportunities\n\n**Look for:**\n\n**Redundant requirements:**\n- Same requirement stated multiple times\n- Similar requirements that could merge\n- Duplicate error handling\n\n**Inconsistent terminology:**\n- Same concept called different names\n- Inconsistent capitalization\n- Different formats for similar things\n\n**Scattered related requirements:**\n- Auth requirements in multiple places\n- Error handling spread throughout\n- Related features not grouped\n\n### 4. Design Improved Structure\n\n**Better organization:**\n- Group related requirements\n- Logical section order\n- Consistent formatting\n- Clear hierarchy\n\n**Example improvement:**\n\n**Before:**\n```markdown\n## Requirements\n- User login\n- Password validation\n- Email validation\n- Session management\n- Logout\n- Password reset\n- Email verification\n```\n\n**After:**\n```markdown\n## Authentication Requirements\n\n### User Registration\n- Email validation\n- Email verification\n- Password validation\n\n### Session Management\n- User login\n- Session creation\n- Logout\n- Session expiration\n\n### Password Management\n- Password reset\n- Password change\n- Password strength requirements\n```\n\n### 5. Refactor Spec\n\n**Steps:**\n\n1. **Create refactored version** (new file or branch)\n2. **Reorganize sections** for clarity\n3. **Consolidate redundancies**\n4. **Standardize terminology**\n5. **Improve requirement clarity**\n6. **Add missing coverage** (if implementation exists)\n7. **Remove obsolete sections** (if truly no longer relevant)\n\n**Throughout:** Maintain traceability to old spec\n\n### 6. Validate Refactored Spec\n\n**Check:**\n- [ ] All implemented features covered\n- [ ] No requirements lost\n- [ ] Terminology consistent\n- [ ] Structure logical\n- [ ] No new ambiguities introduced\n\n**Use `sdd:review-spec`** on refactored version.\n\n### 7. Create Changelog\n\n**Document changes:**\n\n```markdown\n## Spec Refactoring Changelog\n\n**Date:** YYYY-MM-DD\n**Previous Version:** [link or commit]\n\n### Changes Made\n\n**Structural Changes:**\n- Reorganized requirements into logical groups\n- Moved error handling to dedicated section\n- Created sub-sections for clarity\n\n**Consolidated Requirements:**\n- Merged requirements 3, 7, 12 (all about validation)\n- Combined duplicate error cases\n- Unified session management requirements\n\n**Terminology Standardization:**\n- \"User\" ‚Üí \"Authenticated User\" (consistent usage)\n- \"Login\" ‚Üí \"Authentication\" (aligned with codebase)\n\n**Added Coverage:**\n- Requirement 15: Password strength (implemented but not in spec)\n- Error case 8: Rate limiting (implemented but not in spec)\n\n**Removed:**\n- Obsolete requirement 9 (feature removed in v2.0)\n\n### Migration Notes\n\n[How to map old spec sections to new spec sections]\n\nOld Section 2.1 ‚Üí New Section 3.1.1\nOld Section 3.4 ‚Üí New Section 2.3\n...\n```\n\n### 8. Transition Strategy\n\n**For active projects:**\n\n1. **Review with team** (if team project)\n2. **Create PR for spec refactor**\n3. **Get approval before merging**\n4. **Keep old spec accessible** (git history)\n5. **Update documentation** (if references spec)\n\n**For solo projects:**\n\n1. **Commit old spec** (ensure it's in git)\n2. **Replace with refactored spec**\n3. **Commit with detailed message**\n\n### 9. Verify Against Code\n\n**After refactoring:**\n\n```bash\n# Check spec compliance with current code\n# Use sdd:review-code\n```\n\n**Ensure:**\n- Refactored spec still describes existing implementation\n- No accidental requirement changes\n- Compliance still 100%\n\n## Refactoring Checklist\n\nUse TodoWrite to track:\n\n- [ ] Analyze current spec state (issues, redundancies)\n- [ ] Review actual implementation (what exists in code)\n- [ ] Create coverage map (implementation ‚Üí spec)\n- [ ] Identify consolidation opportunities\n- [ ] Design improved structure\n- [ ] Refactor spec content\n- [ ] Validate refactored spec for soundness\n- [ ] Ensure all implemented features covered\n- [ ] Create changelog documenting changes\n- [ ] Verify refactored spec against code (compliance check)\n- [ ] Commit with detailed message\n\n## Example: Before and After\n\n### Before Refactoring\n\n```markdown\n# Feature: User System\n\n## Requirements\n1. Users can register\n2. Email must be validated\n3. Password must be strong\n4. Users can login\n5. Sessions expire after 30 minutes\n6. Users can logout\n7. Passwords must have 8 characters\n8. Passwords must have uppercase\n9. Passwords must have lowercase\n10. Passwords must have number\n11. Email format must be valid\n12. Users can reset password\n13. Reset tokens expire after 1 hour\n14. Users get logged out on password change\n15. Sessions use JWT\n16. JWT secret must be secure\n...\n\n(Requirements scattered, no organization, redundancy)\n```\n\n### After Refactoring\n\n```markdown\n# Feature: User Authentication System\n\n## Purpose\nProvide secure user authentication with registration, login, and password management.\n\n## User Registration\n\n### Functional Requirements\n1. Users can register with email and password\n2. Registration creates user account and initial session\n\n### Email Validation\n- Must be valid email format (RFC 5322)\n- Email verification required before account activation\n- Verification link expires after 24 hours\n\n### Password Requirements\n- Minimum 8 characters\n- Must contain: uppercase, lowercase, number\n- Common passwords rejected (check against list)\n\n## Session Management\n\n### Authentication Flow\n1. User provides credentials (email + password)\n2. System validates credentials\n3. On success: JWT token generated\n4. Client stores token for subsequent requests\n\n### Session Configuration\n- Token type: JWT (JSON Web Token)\n- Token expiration: 30 minutes\n- Secret: Stored in environment variable (not in code)\n- Algorithm: HS256\n\n### Logout\n- Client discards token\n- Optional: Server-side token invalidation (if implemented)\n\n## Password Management\n\n### Password Reset\n- User requests reset via email\n- Reset token generated and emailed\n- Reset token expires after 1 hour\n- On successful reset: all sessions invalidated\n\n### Password Change\n- Requires current password confirmation\n- On success: all sessions invalidated (forces re-login)\n...\n\n(Organized, consolidated, clear)\n```\n\n### Changelog for Above\n\n```markdown\n## Spec Refactoring Changelog\n\n**Date:** 2025-11-10\n\n### Structural Changes\n- Reorganized flat list into hierarchical sections:\n  - User Registration\n  - Session Management\n  - Password Management\n\n### Consolidated Requirements\n- Requirements 7-10 ‚Üí Single \"Password Requirements\" section\n- Requirements 2, 11 ‚Üí \"Email Validation\" section\n- Requirements 4, 5, 6, 15, 16 ‚Üí \"Session Management\" section\n\n### Terminology Standardization\n- Consistently use \"JWT\" (not \"token\" and \"JWT\" interchangeably)\n- \"User\" context now explicit (authenticated vs unauthenticated)\n\n### Added Coverage\n- None (all features already in original spec)\n\n### Removed\n- None (all requirements preserved, just reorganized)\n```\n\n## Types of Refactoring\n\n### 1. Structural Refactoring\n- Reorganize sections\n- Create hierarchy\n- Group related items\n- Improve navigation\n\n### 2. Consolidation Refactoring\n- Merge duplicate requirements\n- Combine scattered related items\n- Remove redundancy\n\n### 3. Clarification Refactoring\n- Remove ambiguities\n- Add specificity\n- Improve wording\n- Standardize terminology\n\n### 4. Coverage Refactoring\n- Add missing implemented features\n- Remove obsolete requirements\n- Align with current codebase\n\n## Common Patterns\n\n### Pattern: Password Requirements Scattered\n\n**Problem:** Password requirements in multiple places\n\n**Solution:** Consolidate into single \"Password Requirements\" section\n\n### Pattern: Inconsistent Error Handling\n\n**Problem:** Some requirements specify errors, others don't\n\n**Solution:** Create dedicated \"Error Handling\" section, reference from requirements\n\n### Pattern: Mixed Abstraction Levels\n\n**Problem:** High-level and low-level requirements mixed\n\n**Solution:** Create hierarchy - high-level functional requirements with detailed sub-sections\n\n### Pattern: Terminology Drift\n\n**Problem:** \"User\", \"Account\", \"Profile\" used interchangeably\n\n**Solution:** Standardize on one term, define others in glossary if needed\n\n## Warnings\n\n**Don't:**\n- Change requirements (that's spec evolution, not refactoring)\n- Remove coverage of implemented features\n- Refactor during active implementation\n- Make untracked changes (always document)\n\n**Do:**\n- Preserve all requirement content\n- Improve organization and clarity\n- Maintain traceability\n- Document all changes\n\n## Remember\n\n**Refactoring improves form, not function.**\n\n- Same requirements, better organization\n- Same coverage, better clarity\n- Same intent, better structure\n\n**Refactoring is maintenance, not change.**\n\n- Spec still describes same implementation\n- No behavioral changes\n- Only organizational improvements\n\n**Good specs enable good work.**\n\n- Clear specs enable smooth implementation\n- Organized specs reduce confusion\n- Consistent specs prevent errors\n\n**Periodic refactoring prevents spec decay.**\n",
        "sdd/skills/spec/SKILL.md": "---\nname: spec\ndescription: Create specifications directly from clear requirements - uses spec-kit tools to create formal, executable specs following WHAT/WHY principle (not HOW)\n---\n\n# Direct Specification Creation\n\n## Overview\n\nCreate formal specifications directly when requirements are clear and well-defined.\n\n**Use this instead of brainstorm when:**\n- Requirements are already clear\n- User provides detailed description\n- Feature scope is well-defined\n- No exploratory dialogue needed\n\n**This skill creates specs using spec-kit tools and ensures WHAT/WHY focus (not HOW).**\n\n## When to Use\n\n**Use this skill when:**\n- User provides clear, detailed requirements\n- Feature scope is well-defined\n- User wants to skip exploratory dialogue\n- Requirements come from external source (PRD, ticket, etc.)\n\n**Don't use this skill when:**\n- Requirements are vague or exploratory ‚Üí Use `sdd:brainstorm`\n- Spec already exists ‚Üí Use `sdd:implement` or `sdd:evolve`\n- Making changes to existing spec ‚Üí Use `sdd:spec-refactoring`\n\n## Prerequisites\n\nEnsure spec-kit is initialized:\n\n{Skill: spec-kit}\n\nIf spec-kit prompts for restart, pause this workflow and resume after restart.\n\n## Critical: Specifications are WHAT and WHY, NOT HOW\n\n**Specs define contracts and requirements, not implementation.**\n\n### ‚úÖ Specs SHOULD include:\n- **Requirements**: What the feature must do\n- **Behaviors**: How the feature should behave (user-observable)\n- **Contracts**: API structures, file formats, data schemas\n- **Error handling rules**: What errors must be handled and how they should appear to users\n- **Success criteria**: Measurable outcomes\n- **Constraints**: Limitations and restrictions\n- **User-visible paths**: File locations, environment variables users interact with\n\n### ‚ùå Specs should NOT include:\n- **Implementation algorithms**: Specific sorting algorithms, data structure choices\n- **Code**: Function signatures, class hierarchies, pseudocode\n- **Technology choices**: \"Use Redis\", \"Use React hooks\", \"Use Python asyncio\"\n- **Internal architecture**: How components communicate internally\n- **Optimization strategies**: Caching mechanisms, performance tuning\n\n### üìã Example: What belongs where\n\n**SPEC (WHAT/WHY):**\n```markdown\n## Requirements\n- FR-001: System MUST validate email addresses before storing\n- FR-002: System MUST return validation errors within 200ms\n- FR-003: Invalid emails MUST return 422 status with error details\n\n## Error Handling\n- Invalid format: Return `{\"error\": \"Invalid email format\", \"field\": \"email\"}`\n- Duplicate email: Return `{\"error\": \"Email already exists\"}`\n```\n\n**PLAN (HOW):**\n```markdown\n## Validation Implementation\n- Use regex pattern: `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$`\n- Cache validation results in Redis (TTL: 5 min)\n- Database query: `SELECT COUNT(*) FROM users WHERE email = ?`\n```\n\n### Why this matters:\n- **Specs remain stable** - Implementation details change, requirements don't\n- **Implementation flexibility** - Can change HOW without changing WHAT\n- **Clearer reviews** - Easy to see if requirements are met vs implementation quality\n- **Better evolution** - When code diverges from spec, know which to update\n\n## The Process\n\n### 1. Gather Requirements\n\n**Extract from user input:**\n- What needs to be built\n- Why it's needed (purpose/problem)\n- Success criteria\n- Constraints and dependencies\n- Error cases and edge conditions\n\n**Ask clarifying questions** (brief, targeted):\n- Only if critical information is missing\n- Keep questions focused and specific\n- Don't turn this into full brainstorming session\n\n**If requirements are vague:**\nStop and use `sdd:brainstorm` instead.\n\n### 2. Check Project Context\n\n**Review existing specs:**\n```bash\nls -la specs/features/\n# Or: ls -la specs/[NNNN]-*/\n```\n\n**Check for constitution:**\n```bash\ncat .specify/memory/constitution.md\n```\n\n**Look for related features:**\n- Similar functionality already specced\n- Integration points\n- Shared components\n\n### 3. Create Specification\n\n**Use spec-kit tools:**\n\n```bash\n# Interactive spec creation using spec-kit template\nspeckit specify \"[feature description]\"\n\n# Or use spec-kit scripts directly\n.specify/scripts/bash/create-new-feature.sh --json \"[feature description]\"\n```\n\n**This will:**\n- Create feature directory (e.g., `specs/0001-feature-name/`)\n- Initialize spec.md from template\n- Set up directory structure (docs/, checklists/, contracts/)\n\n**Fill in the spec following template structure:**\n- Purpose - WHY this feature exists\n- Functional Requirements - WHAT it must do\n- Non-Functional Requirements - Performance, security, etc.\n- Success Criteria - Measurable outcomes\n- Error Handling - What can go wrong\n- Edge Cases - Boundary conditions\n- Constraints - Limitations\n- Dependencies - What this relies on\n- Out of Scope - What this doesn't do\n\n**Follow WHAT/WHY principle:**\n- Focus on observable behavior\n- Avoid implementation details\n- Use user/system perspective\n- Keep technology-agnostic where possible\n\n### 4. Validate Against Constitution\n\n**If constitution exists:**\n\n```bash\ncat .specify/memory/constitution.md\n```\n\n**Check alignment:**\n- Does spec follow project principles?\n- Are patterns consistent with constitution?\n- Does error handling match standards?\n- Are architectural decisions aligned?\n\n**Note any deviations** and justify them in spec.\n\n### 5. Review Spec Soundness\n\n**Before finishing, validate:**\n\nUse `sdd:review-spec` skill to check:\n- Completeness (all sections filled)\n- Clarity (no ambiguous language)\n- Implementability (can generate plan from this)\n- Testability (success criteria measurable)\n\n**If review finds issues:**\n- Fix critical issues before proceeding\n- Document any known gaps\n- Mark unclear areas for clarification\n\n### 6. Commit Spec\n\n**Create git commit:**\n\n```bash\ngit add specs/[feature-dir]/\ngit commit -m \"Add spec for [feature-name]\"\n```\n\n**Spec is now source of truth** for this feature.\n\n## Next Steps\n\nAfter spec creation:\n\n1. **Review spec soundness** (if not already done):\n   ```\n   Use sdd:review-spec\n   ```\n\n2. **Implement the feature**:\n   ```\n   Use sdd:implement\n   ```\n\n3. **Or refine spec further** if issues found\n\n## Remember\n\n**Spec is contract, not design doc:**\n- Defines WHAT and WHY\n- Defers HOW to implementation\n- Remains stable as code evolves\n- Is source of truth for compliance\n\n**Keep specs:****\n- Technology-agnostic\n- User-focused\n- Measurable\n- Implementable\n\n**The goal:**\nA clear, unambiguous specification that serves as the single source of truth for implementation and validation.\n",
        "sdd/skills/tutorial/SKILL.md": "---\nname: tutorial\ndescription: Interactive onboarding for SDD methodology - offers learning paths for quick start, full introduction, or team collaboration focus\n---\n\n# SDD Tutorial\n\n## Overview\n\nInteractive guide to Specification-Driven Development. Offers 3 learning paths based on your goals.\n\nThis skill provides structured onboarding for new users, explaining:\n- What SDD is and why it matters\n- The workflow phases and when to use each command\n- Team collaboration patterns (when to share specs via PR)\n- Decision guidance (which command for which situation)\n\n## Context Detection\n\nBefore presenting paths, check the project state to customize messaging:\n\n1. **Look for `specs/` directory** - indicates SDD may already be in use\n2. **Check for `specs/constitution.md`** - indicates project principles exist\n3. **Check for `.specify/` directory** - indicates spec-kit is initialized\n\nAdapt the tutorial messaging based on findings:\n- New project: Focus on getting started\n- Existing SDD project: Focus on advanced patterns\n- Team project: Emphasize collaboration workflows\n\n## Learning Path Selection\n\nPresent the user with 3 learning paths using AskUserQuestion:\n\n**Path A: Quick Start (5 min)**\n- Core concepts and cheat sheet\n- Best for: Experienced developers who want to jump in\n\n**Path B: Full Introduction (15 min)**\n- All phases explained with examples\n- Best for: New users wanting thorough understanding\n\n**Path C: Team Collaboration (10 min)**\n- PR workflows and spec reviews\n- Best for: Teams adopting SDD together\n\n## Deliver Content\n\nBased on the user's selection:\n\n1. **Read the corresponding content file:**\n   - Path A: Read `sdd/skills/tutorial/quick-start.md`\n   - Path B: Read `sdd/skills/tutorial/full-introduction.md`\n   - Path C: Read `sdd/skills/tutorial/team-collaboration.md`\n\n2. **Present the content section by section:**\n   - Show one major section at a time\n   - Pause after each section: \"Ready to continue, or any questions?\"\n   - Be prepared to answer questions before moving on\n\n3. **Keep it conversational:**\n   - Don't just dump the entire file\n   - Engage with the user throughout\n   - Offer to skip sections if they're already familiar\n\n## Next Steps\n\nAfter completing the tutorial, suggest next actions based on project state:\n\n**No specs exist yet:**\n- \"Ready to try it? Start with `/sdd:brainstorm` to turn an idea into a spec\"\n- \"Or create a constitution first with `/sdd:constitution` to set project standards\"\n\n**Specs already exist:**\n- \"You have existing specs. Try `/sdd:implement` to build from one\"\n- \"Or use `/sdd:review-spec` to validate your specs\"\n\n**Team project:**\n- \"For team projects, remember to create spec PRs for major features\"\n- \"This lets the team align on WHAT before debating HOW\"\n\n## Presentation Guidelines\n\n- Use the content files as your source, but present conversationally\n- Don't overwhelm: one concept at a time\n- Check understanding before moving to next section\n- Be ready to give examples from the user's domain if they share context\n- End with clear, actionable next step\n\n## Example Flow\n\n```\nYou: I'm using sdd:tutorial to introduce you to SDD.\n\nLet me check your project first...\n[Checks for specs/, constitution, .specify/]\n\nThis looks like a new project, so I'll tailor the tutorial for getting started.\n\nWhich learning path would you prefer?\n[Presents AskUserQuestion with 3 paths]\n\nUser: Quick Start\n\nYou: [Reads quick-start.md]\n[Presents Core Concepts section]\n\nThe core idea is simple: specs come first, code validates against specs.\n[Explains briefly]\n\nReady to see the workflow overview, or any questions so far?\n\nUser: Continue\n\nYou: [Presents Workflow section]\n...\n\nYou: That's the quick start! Ready to try it on your project?\n\nThe best way to learn is by doing. I suggest starting with:\n/sdd:brainstorm - if you have a rough idea for a feature\n/sdd:spec - if you have clear requirements already\n\nWhich would you like to try?\n```\n",
        "sdd/skills/tutorial/full-introduction.md": "# Full Introduction to SDD\n\n## What is Specification-Driven Development?\n\n**The Problem:** In traditional development, documentation drifts from code. Specs become outdated the moment implementation starts. Intent gets buried in implementation details.\n\n**The Solution:** Make specifications the single source of truth. Code validates against specs. When they diverge, reconcile them through a deliberate process.\n\n**SDD = Specifications that stay current, enforced by process discipline.**\n\n## The SDD Workflow\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                                                             ‚îÇ\n‚îÇ   IDEA ‚îÄ‚îÄ‚Üí SPEC ‚îÄ‚îÄ‚Üí REVIEW ‚îÄ‚îÄ‚Üí IMPLEMENT ‚îÄ‚îÄ‚Üí VERIFY        ‚îÇ\n‚îÇ             ‚Üë                                    ‚îÇ          ‚îÇ\n‚îÇ             ‚îÇ                                    ‚Üì          ‚îÇ\n‚îÇ             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ EVOLVE ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ (drift?) ‚îÄ‚îÄ‚îò          ‚îÇ\n‚îÇ                                                             ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n### Phase 1: Ideation to Specification\n\nEvery feature starts as an idea. Before writing code, turn that idea into a formal spec.\n\n**Two paths to specs:**\n\n| Path | When to Use | Command |\n|------|-------------|---------|\n| Brainstorm | Rough idea, needs exploration | `/sdd:brainstorm` |\n| Direct spec | Clear requirements, no ambiguity | `/sdd:spec` |\n\n**Brainstorm workflow:**\n1. You describe your rough idea\n2. Claude asks clarifying questions (one at a time)\n3. You explore 2-3 approaches with trade-offs\n4. You refine requirements collaboratively\n5. Claude creates a formal spec\n\n**Direct spec workflow:**\n1. You provide clear requirements\n2. Claude creates spec using spec-kit templates\n3. Spec is ready for review\n\n**Spec structure:**\n```markdown\n# Feature: [Name]\n\n## Purpose\nWhy this feature exists\n\n## Requirements\n### Functional Requirements\nWhat it must do\n\n### Non-Functional Requirements\nPerformance, security, etc.\n\n## Success Criteria\nHow we know it works\n\n## Error Handling\nWhat can go wrong\n\n## Edge Cases\nBoundary conditions\n\n## Dependencies\nWhat it needs\n\n## Out of Scope\nWhat it explicitly doesn't do\n```\n\n### Phase 2: Specification Review\n\nBefore implementing, validate your spec.\n\n**Command:** `/sdd:review-spec`\n\n**What it checks:**\n- Structure and completeness\n- Clarity and lack of ambiguity\n- Implementability\n- Alignment with constitution (if exists)\n- Missing edge cases or error handling\n\n**Output:** Validation report with issues to address\n\n### Phase 3: Implementation\n\nBuild from your validated spec using TDD.\n\n**Command:** `/sdd:implement`\n\n**What happens:**\n1. Generates implementation plan FROM spec\n2. Creates tests first (test-driven development)\n3. Implements code to pass tests\n4. Continuously validates against spec\n5. Commits with spec reference\n\n**Key principle:** The plan comes FROM the spec, not from scratch. The spec is your requirements document.\n\n### Phase 4: Verification\n\nAfter implementation, verify both tests and spec compliance.\n\n**Automatic verification includes:**\n- All tests pass\n- Code matches spec requirements\n- No unauthorized deviations\n\n**If verification passes:** Feature complete.\n\n**If drift detected:** Move to evolution phase.\n\n### Phase 5: Evolution\n\nSpecs will drift from code. This is normal and healthy. The key is handling it deliberately.\n\n**Command:** `/sdd:evolve`\n\n**What happens:**\n1. AI analyzes the mismatch\n2. Determines: Is the code right (update spec) or is the spec right (fix code)?\n3. Provides recommendation with reasoning\n4. You decide (or auto-update based on threshold)\n5. Alignment is restored\n\n**Common drift causes:**\n- Implementation revealed spec was incomplete\n- Requirements changed during development\n- Edge cases discovered during coding\n- Better approach found during implementation\n\n## Quality Gates\n\nSDD enforces quality gates at key points:\n\n| Gate | When | What's Checked |\n|------|------|----------------|\n| Spec Review | Before implementation | Spec completeness and clarity |\n| Implementation | During coding | Tests + spec compliance |\n| Verification | After coding | Full compliance check |\n| Evolution | On drift | Deliberate reconciliation |\n\n## The Constitution\n\nFor projects with multiple features or team members, create a constitution.\n\n**What is it?**\n- Project-wide principles and standards\n- Referenced during all spec creation and review\n- Ensures consistency across features\n\n**Command:** `/sdd:constitution`\n\n**What it defines:**\n- Coding standards (naming, structure)\n- Architectural patterns (how things fit together)\n- Quality requirements (testing, performance)\n- Error handling approaches\n- Security requirements\n\n**When to create:**\n- New projects: After first feature spec\n- Existing projects: When patterns emerge\n- Team projects: Always (defines shared understanding)\n\n## Command Reference\n\n### Spec Creation\n| Command | Purpose |\n|---------|---------|\n| `/sdd:brainstorm` | Rough idea to spec through dialogue |\n| `/sdd:spec` | Clear requirements to spec directly |\n| `/sdd:constitution` | Project-wide principles |\n\n### Validation\n| Command | Purpose |\n|---------|---------|\n| `/sdd:review-spec` | Validate spec quality |\n| `/sdd:review-code` | Check code-to-spec compliance |\n\n### Implementation\n| Command | Purpose |\n|---------|---------|\n| `/sdd:implement` | Spec to code with TDD |\n\n### Evolution\n| Command | Purpose |\n|---------|---------|\n| `/sdd:evolve` | Reconcile spec/code drift |\n\n## FAQ\n\n**Q: What if my feature is too small for a spec?**\nA: Even small features benefit from spec context. A minimal spec (Purpose, Requirements, Success Criteria) is fine. The discipline matters more than the length.\n\n**Q: Can I skip straight to code if I know exactly what I'm building?**\nA: No. The spec is what you \"know exactly.\" Write it down, then implement. This catches gaps you didn't realize existed.\n\n**Q: What if the spec keeps changing during implementation?**\nA: That's normal. Use `/sdd:evolve` to reconcile. The process makes changes deliberate rather than accidental.\n\n**Q: How detailed should specs be?**\nA: Detailed enough that implementation is unambiguous. If you're guessing during implementation, the spec needs more detail.\n\n**Q: What about legacy code without specs?**\nA: Create specs by analyzing existing code. Use `/sdd:evolve` to reconcile any differences between what the code does and what it should do.\n\n**Q: Can multiple features share a spec?**\nA: Generally no. Each feature should have its own spec. Use the constitution for shared patterns and principles.\n\n## Key Principles Summary\n\n1. **Spec-first, always** - No code without spec\n2. **WHAT, not HOW** - Specs define requirements, code defines implementation\n3. **Living specs** - Specs evolve with implementation reality\n4. **Deliberate evolution** - Drift is handled explicitly, not ignored\n5. **Process discipline** - Quality gates prevent shortcuts\n6. **Single source of truth** - The spec is authoritative\n\n## Getting Started\n\n1. **First feature:** `/sdd:brainstorm` to create your first spec\n2. **Review it:** `/sdd:review-spec` to validate\n3. **Build it:** `/sdd:implement` with TDD\n4. **If drift:** `/sdd:evolve` to reconcile\n5. **For consistency:** `/sdd:constitution` to set project standards\n\nThe best way to learn SDD is to use it on a real feature. Start small, follow the process, and see how it feels.\n",
        "sdd/skills/tutorial/quick-start.md": "# Quick Start Guide\n\n## What is SDD?\n\n**Specification-Driven Development** = Specs are your single source of truth.\n\nTraditional development: Code first, document later (if ever). Docs drift. Intent gets lost.\n\nSDD: Spec first, code validates against spec. Specs evolve with reality. Intent is preserved.\n\n**The core loop:**\n```\nIdea ‚Üí Spec ‚Üí Code ‚Üí Verify ‚Üí (Drift? ‚Üí Evolve)\n```\n\n## The Three Phases\n\n### 1. Specification Phase\n\n**Turn ideas into specs before writing code.**\n\n| Starting Point | Command | What Happens |\n|----------------|---------|--------------|\n| Rough idea | `/sdd:brainstorm` | Collaborative dialogue refines idea into formal spec |\n| Clear requirements | `/sdd:spec` | Create spec directly using spec-kit |\n\n**Output:** A specification file in `specs/features/[name]/spec.md`\n\n### 2. Implementation Phase\n\n**Build from specs with TDD and compliance checking.**\n\n| Command | What Happens |\n|---------|--------------|\n| `/sdd:implement` | Generates plan from spec, uses TDD, validates compliance |\n\n**Output:** Working code that matches the spec\n\n### 3. Evolution Phase\n\n**When code and spec diverge (it happens), reconcile them.**\n\n| Situation | Command | What Happens |\n|-----------|---------|--------------|\n| Spec/code mismatch | `/sdd:evolve` | AI analyzes, recommends update spec vs fix code |\n\n**Output:** Restored alignment between spec and code\n\n## Command Decision Table\n\nUse this to pick the right command:\n\n| You Have | You Want | Use |\n|----------|----------|-----|\n| Vague idea | Clear spec | `/sdd:brainstorm` |\n| Clear requirements | Formal spec | `/sdd:spec` |\n| Validated spec | Working code | `/sdd:implement` |\n| Spec + code mismatch | Alignment | `/sdd:evolve` |\n| Draft spec | Validation | `/sdd:review-spec` |\n| Code changes | Compliance check | `/sdd:review-code` |\n| New project | Standards | `/sdd:constitution` |\n\n## Quick Reference Card\n\n```\nSPEC CREATION\n  /sdd:brainstorm    Rough idea ‚Üí spec (interactive)\n  /sdd:spec          Clear reqs ‚Üí spec (direct)\n  /sdd:constitution  Project-wide principles\n\nVALIDATION\n  /sdd:review-spec   Check spec quality\n  /sdd:review-code   Check code-to-spec compliance\n\nIMPLEMENTATION\n  /sdd:implement     Spec ‚Üí code with TDD\n\nEVOLUTION\n  /sdd:evolve        Fix spec/code drift\n```\n\n## Key Principles\n\n1. **Spec-first, always** - No code without spec. Period.\n2. **WHAT, not HOW** - Specs define requirements, not implementation details\n3. **Evolution is normal** - Specs change as you learn. That's healthy.\n4. **Quality gates** - Verification checks both tests AND spec compliance\n\n## Common Mistakes to Avoid\n\n**Don't:**\n- Skip specs for \"simple\" features (they still need spec context)\n- Put implementation details in specs (that's for code)\n- Ignore drift warnings (use `/sdd:evolve`)\n- Write code then spec afterward (that's documentation, not SDD)\n\n**Do:**\n- Start every feature with a spec\n- Keep specs focused on WHAT and WHY\n- Use `/sdd:evolve` when reality differs from plan\n- Review specs before implementing\n\n## Try It Now\n\nBest way to learn: try it on a real feature.\n\n1. Think of a feature you want to build\n2. Run `/sdd:brainstorm` to turn it into a spec\n3. Run `/sdd:implement` to build it\n4. See how the workflow feels\n\nThat's it. Specs first, code validates, evolve when needed.\n",
        "sdd/skills/tutorial/team-collaboration.md": "# Team Collaboration with SDD\n\n## The Core Principle\n\n**Share specs via PR before implementation for significant features.**\n\nThis lets the team align on WHAT before debating HOW.\n\nTraditional approach: Write code, create PR, debate implementation details, realize requirements were misunderstood, rewrite.\n\nSDD team approach: Create spec, get team alignment, then implement. The PR reviews the contract, not the code.\n\n## When to Create Spec PRs\n\n### Always Create Separate Spec PRs\n\n**Major new features:**\n- New user-facing functionality\n- New API endpoints or services\n- New integrations with external systems\n\n**Architecture changes:**\n- New patterns or conventions\n- Changes to data models\n- Infrastructure modifications\n\n**Why:** These decisions affect everyone. Get alignment before investing in implementation.\n\n### Judgment Call (Often Same PR is Fine)\n\n**Minor features:**\n- Small enhancements to existing features\n- Bug fixes with clear solutions\n- Internal refactoring\n\n**Quick fixes:**\n- Typo corrections\n- Configuration changes\n- Dependency updates\n\n**Guideline:** If it takes longer to discuss than implement, just do it. If implementation is non-trivial, spec first.\n\n## Team Feature Development Workflow\n\n### Example: Adding User Authentication\n\n```\n1. CREATE BRANCH AND SPEC\n   Developer creates feature branch\n   Runs /sdd:brainstorm to create spec\n   Spec lives at specs/features/authentication/spec.md\n\n2. CREATE SPEC-ONLY PR\n   gh pr create --title \"RFC: User Authentication Spec\"\n   PR contains only the spec file\n   No implementation code yet\n\n3. TEAM REVIEWS SPEC\n   Team reviews requirements, not code\n   Discussion focuses on WHAT, not HOW\n   \"Do we need OAuth or is magic links enough?\"\n   \"What error messages for failed login?\"\n\n4. SPEC APPROVED\n   Team aligns on requirements\n   Spec is merged to main\n   Developer now has approved contract\n\n5. IMPLEMENT IN SEPARATE PR\n   Developer runs /sdd:implement\n   Creates implementation PR\n   Code review is faster: \"Does this match the spec?\"\n\n6. MERGE AND SHIP\n   Implementation matches approved spec\n   No surprises at code review\n   Feature ships with aligned expectations\n```\n\n## Spec as Contract\n\nThink of specs as contracts between team members:\n\n**The spec author promises:**\n- Clear requirements\n- Defined success criteria\n- Considered edge cases\n- Documented dependencies\n\n**The reviewer promises:**\n- Thorough review of requirements\n- Raise concerns before implementation\n- Approve = \"I agree this is what we should build\"\n\n**The implementer promises:**\n- Build exactly what's specified\n- Use `/sdd:evolve` if reality differs\n- Don't silently deviate from spec\n\n## Multi-Developer Patterns\n\n### Pattern 1: Spec Author != Implementer\n\n```\nAlice creates spec for authentication\nTeam reviews and approves spec\nBob implements from Alice's spec\n\nBenefits:\n- Fresh eyes catch spec gaps during implementation\n- Knowledge sharing across team\n- Reduces bus factor\n```\n\n### Pattern 2: Parallel Specs, Sequential Implementation\n\n```\nSprint planning:\n- Alice specs Feature A\n- Bob specs Feature B\n- Carol specs Feature C\n\nAfter spec review:\n- Implementation can happen in parallel\n- Dependencies are clear from specs\n- Integration points defined upfront\n```\n\n### Pattern 3: Spec Pairing\n\n```\nFor complex features:\n- Two developers brainstorm together\n- One drives, one reviews in real-time\n- Shared ownership of the spec\n\nWhen to use:\n- Features touching multiple systems\n- High-risk or high-complexity work\n- Onboarding new team members\n```\n\n## Code Review with Specs\n\nWith SDD, code review becomes simpler:\n\n**Traditional code review questions:**\n- \"What is this trying to do?\"\n- \"Why did you do it this way?\"\n- \"Should this handle X edge case?\"\n\n**SDD code review questions:**\n- \"Does this match the spec?\"\n- \"Any deviations to discuss?\"\n- \"Tests cover the success criteria?\"\n\n**The spec answers the \"what\" and \"why.\" Code review focuses on \"how well.\"**\n\n## Handling Disagreements\n\n### During Spec Review\n\n```\nReviewer: \"I don't think we need OAuth, magic links are simpler\"\nAuthor: \"Good point. Let me update the spec to explore both options\"\n[Spec is updated with comparison]\nTeam: \"Let's go with magic links for v1, OAuth as future enhancement\"\n[Spec reflects decision]\n```\n\n**Key:** Decisions are captured in the spec. Future developers know WHY.\n\n### During Implementation\n\n```\nImplementer: \"The spec says X, but I discovered Y is better\"\n‚Üí Don't silently change. Use /sdd:evolve\n‚Üí Create PR updating spec with reasoning\n‚Üí Team reviews the change\n‚Üí Spec and code stay aligned\n```\n\n## Onboarding New Team Members\n\nSDD makes onboarding easier:\n\n**New developer can:**\n1. Read constitution to understand project standards\n2. Read existing specs to understand features\n3. See the \"why\" behind code decisions\n4. Follow the same process as everyone else\n\n**Onboarding workflow:**\n```\n1. /sdd:tutorial - Learn the methodology\n2. Review constitution - Understand project standards\n3. Review 2-3 feature specs - See examples\n4. Pair on spec creation - Practice with support\n5. Solo spec + review - Demonstrate understanding\n```\n\n## Team Adoption Tips\n\n### Starting with SDD\n\n**Week 1-2: Pilot**\n- Pick one feature\n- One developer creates spec\n- Team reviews together\n- Discuss what worked, what didn't\n\n**Week 3-4: Expand**\n- All new features get specs\n- Create project constitution\n- Refine process based on learnings\n\n**Month 2+: Normal**\n- SDD is default process\n- Spec PRs are routine\n- New members onboarded to process\n\n### Common Adoption Challenges\n\n**\"This slows us down\"**\n- Front-loaded thinking reduces rework\n- Code reviews are faster with spec context\n- Fewer \"I thought it meant X\" moments\n\n**\"Specs become outdated\"**\n- That's what `/sdd:evolve` is for\n- Deliberate evolution > silent drift\n- Constitution defines update expectations\n\n**\"We don't have time for process\"**\n- Process prevents the bugs that steal time\n- Clear specs reduce back-and-forth\n- Aligned teams ship faster\n\n## Summary\n\n**For teams, SDD provides:**\n- Shared understanding before implementation\n- Clear contracts between team members\n- Faster code reviews\n- Easier onboarding\n- Decisions captured with context\n\n**Key practices:**\n1. Spec PRs for significant features\n2. Review specs before implementation\n3. Use `/sdd:evolve` for any deviations\n4. Constitution for shared standards\n5. Treat specs as team contracts\n\n**The goal:** Aligned teams shipping quality software with specs that remain the source of truth.\n",
        "sdd/skills/using-superpowers-sdd/SKILL.md": "---\nname: using-superpowers-sdd\ndescription: Establishes SDD methodology - workflow routing, process discipline, spec-first principle, and skill discovery. Use when starting any SDD conversation to determine which workflow skill to invoke.\n---\n\n<EXTREMELY-IMPORTANT>\nIf you think there is even a 1% chance a skill might apply to what you are doing, you ABSOLUTELY MUST read the skill.\n\nIF A SKILL APPLIES TO YOUR TASK, YOU DO NOT HAVE A CHOICE. YOU MUST USE IT.\n\nThis is not negotiable. This is not optional. You cannot rationalize your way out of this.\n</EXTREMELY-IMPORTANT>\n\n# Getting Started with Superpowers-SDD\n\n## What is SDD?\n\n**SDD = Specification-Driven Development**\n\nA development methodology where specifications are the single source of truth:\n- Specs created before code\n- Code validated against specs\n- Specs evolve with implementation reality\n- Quality gates enforce spec compliance\n\nThis plugin combines:\n- **Superpowers** process discipline (TDD, verification, quality gates)\n- **Spec-Driven Development** (specs as source of truth)\n- Result: High-quality software with specs that stay current\n\n## Technical Prerequisites\n\n**NOTE: The `spec-kit` skill handles all technical setup automatically.**\n\nEvery SDD workflow skill calls `{Skill: spec-kit}` first, which:\n- Checks if spec-kit CLI is installed\n- Initializes the project if needed\n- Prompts restart if new commands installed\n- Validates file structure\n\nYou don't need to worry about setup. Focus on choosing the right workflow.\n\n## MANDATORY FIRST RESPONSE PROTOCOL\n\nBefore responding to ANY user message, you MUST complete this checklist:\n\n1. ‚òê List available SDD skills in your mind\n2. ‚òê Ask yourself: \"Does ANY SDD skill match this request?\"\n3. ‚òê If yes ‚Üí Use the Skill tool to read and run the skill file\n4. ‚òê Announce which skill you're using\n5. ‚òê Follow the skill exactly\n\n**Responding WITHOUT completing this checklist = automatic failure.**\n\n## The Specification-First Principle\n\n**CRITICAL RULE: Specs are the source of truth. Everything flows from and validates against specs.**\n\nBefore ANY implementation work:\n- Spec must exist OR be created first\n- Spec must be reviewed for soundness\n- Implementation must validate against spec\n- Spec/code mismatches trigger evolution workflow\n\n**You CANNOT write code without a spec. Period.**\n\n## Critical Rules\n\n1. **Spec-first, always.** No code without spec. No exceptions.\n2. **Follow mandatory workflows.** Brainstorm ‚Üí Spec ‚Üí Plan ‚Üí TDD ‚Üí Verify.\n3. **Check for relevant skills before ANY task.** SDD has skills for each phase.\n4. **Validate spec compliance.** Code review and verification check specs.\n5. **Handle spec/code drift.** Use sdd:evolve when mismatches detected.\n\n## Available SDD Skills\n\n### Phase Entry Points\n- **sdd:brainstorm** - Rough idea ‚Üí spec through collaborative dialogue\n- **sdd:implement** - Spec ‚Üí code with TDD and compliance checking\n- **sdd:evolve** - Handle spec/code mismatches with AI guidance\n\n### Modified Core Skills\n- **sdd:writing-plans** - Generate plans FROM specs (not from scratch)\n- **sdd:review-code** - Review code-to-spec compliance\n- **sdd:verification-before-completion** - Tests + spec compliance validation\n\n### SDD-Specific Skills\n- **sdd:review-spec** - Validate spec soundness and completeness\n- **sdd:spec-refactoring** - Consolidate and improve evolved specs\n- **sdd:spec-kit** - Technical integration for spec-kit CLI (called automatically)\n- **sdd:constitution** - Create/manage project-wide principles\n- **sdd:tutorial** - Interactive onboarding for SDD methodology and team workflows\n\n### Compatible Superpowers Skills\nThese work as-is with spec context:\n- **test-driven-development** - Use AFTER spec, during implementation\n- **systematic-debugging** - Use spec as reference during debugging\n- **using-git-worktrees** - For isolated feature development\n- **dispatching-parallel-agents** - For independent parallel work\n\n## Workflow Decision Tree\n\n```\nUser request arrives\n    ‚Üì\nIs this a new feature/project?\n    Yes ‚Üí Is it a rough idea?\n            Yes ‚Üí sdd:brainstorm\n            No ‚Üí Create spec using spec-kit tools\n    No ‚Üí Does spec exist for this area?\n            Yes ‚Üí Is there spec/code mismatch?\n                    Yes ‚Üí sdd:evolve\n                    No ‚Üí sdd:implement\n            No ‚Üí Create spec first using spec-kit tools\n```\n\n## Creating Specifications\n\n### Rough Idea ‚Üí Use Brainstorm\n\n```\nUser: \"I want to add authentication to my app\"\n‚Üí Use sdd:brainstorm\n```\n\n**Brainstorm will:**\n- Explore the idea through questions\n- Propose approaches with trade-offs\n- Refine requirements collaboratively\n- Create formal spec using spec-kit\n\n### Clear Requirements ‚Üí Direct Spec Creation\n\n```\nUser: \"Add a POST /api/users endpoint that validates email and returns 422 on invalid format\"\n‚Üí Create spec directly using spec-kit tools\n```\n\n**Direct spec creation:**\n- Requirements are already clear\n- No exploratory dialogue needed\n- Use spec-kit CLI or templates directly\n- Follow spec-kit layout conventions\n\n**WHAT vs HOW principle:**\nSpecs define WHAT and WHY, not HOW.\n- ‚úÖ WHAT: Requirements, behaviors, contracts, success criteria\n- ‚ùå HOW: Algorithms, code, technology choices, architecture\n\n## Common Rationalizations That Mean You're About To Fail\n\nIf you catch yourself thinking ANY of these thoughts, STOP. You are rationalizing. Check for and use the skill.\n\n**Spec-avoidance rationalizations:**\n- \"This is too simple for a spec\" ‚Üí WRONG. Simple changes still need spec context.\n- \"I'll just write the code quickly\" ‚Üí WRONG. Code without spec creates drift.\n- \"The spec is obvious from the description\" ‚Üí WRONG. Make it explicit.\n- \"We can spec it after implementation\" ‚Üí WRONG. That's documentation, not SDD.\n\n**Skill-avoidance rationalizations:**\n- \"This is just a quick fix\" ‚Üí WRONG. Quick fixes need spec validation.\n- \"I can check the spec manually\" ‚Üí WRONG. Use sdd:verification-before-completion.\n- \"The spec is good enough\" ‚Üí WRONG. Use sdd:review-spec before implementing.\n- \"I remember this workflow\" ‚Üí WRONG. Skills evolve. Run the current version.\n\n**Why:** Specs prevent drift. Skills enforce discipline. Both save time by preventing mistakes.\n\nIf a skill for your task exists, you must use it or you will fail at your task.\n\n## Skills with Checklists\n\nIf a skill has a checklist, YOU MUST create TodoWrite todos for EACH item.\n\n**Don't:**\n- Work through checklist mentally\n- Skip creating todos \"to save time\"\n- Batch multiple items into one todo\n- Mark complete without doing them\n\n**Why:** Checklists without TodoWrite tracking = steps get skipped. Every time.\n\n## Announcing Skill Usage\n\nBefore using a skill, announce that you are using it.\n\n\"I'm using [Skill Name] to [what you're doing].\"\n\n**Examples:**\n- \"I'm using sdd:brainstorm to refine your idea into a spec.\"\n- \"I'm using sdd:implement to build this feature from the spec.\"\n- \"I'm using sdd:evolve to reconcile the spec/code mismatch.\"\n\n**Why:** Transparency helps your human partner understand your process and catch errors early.\n\n## Spec Evolution is Normal\n\nSpecs WILL diverge from code. This is expected and healthy.\n\n**When mismatch detected:**\n1. DON'T panic or force-fit code to wrong spec\n2. DO use sdd:evolve\n3. AI analyzes: update spec vs. fix code\n4. User decides (or auto-update if configured)\n\n**Remember:** Specs are source of truth, but truth can evolve based on reality.\n\n## Constitution: Optional but Powerful\n\nConsider creating a constitution for your project:\n\n**What is it?**\n- Project-wide principles and standards\n- Referenced during spec validation\n- Ensures consistency across features\n\n**When to create:**\n- New projects: Early, after first feature spec\n- Existing projects: When patterns emerge\n- Team projects: Always (defines shared understanding)\n\n**How to create:**\nUse `/sdd:constitution` skill.\n\n## Instructions ‚â† Permission to Skip Workflows\n\nYour human partner's specific instructions describe WHAT to do, not HOW.\n\n\"Add X\", \"Fix Y\" = the goal, NOT permission to skip spec-first or verification.\n\n**Red flags:** \"Instruction was specific\" ‚Ä¢ \"Seems simple\" ‚Ä¢ \"Workflow is overkill\"\n\n**Why:** Specific instructions mean clear requirements, which is when specs matter MOST.\n\n## Summary\n\n**Starting any task:**\n1. Check this skill first for routing\n2. Determine: brainstorm vs. direct spec vs. implement vs. evolve\n3. Invoke the appropriate workflow skill\n4. That skill will call spec-kit for setup automatically\n5. Follow the workflow discipline exactly\n\n**The methodology is:**\n- Specs first, always\n- Code validates against specs\n- Specs evolve when reality teaches us\n- Quality gates prevent shortcuts\n- Process discipline ensures quality\n\n**The tools are:**\n- spec-kit (technical integration)\n- Workflow skills (brainstorm, implement, evolve)\n- Verification and validation skills\n- TDD and debugging skills\n\n**The goal is:**\nHigh-quality software with specs that remain the living source of truth.\n\n## Workflow Patterns\n\n### Pattern 1: New Feature from Rough Idea\n\n```\nUser: \"I want to add notifications to my app\"\n\n1. Recognize: Rough idea\n2. Route to: sdd:brainstorm\n3. Brainstorm will:\n   - Call spec-kit (auto-setup)\n   - Explore idea collaboratively\n   - Create formal spec\n   - Hand off to sdd:implement\n```\n\n### Pattern 2: New Feature from Clear Requirements\n\n```\nUser: \"Add GET /api/stats endpoint returning JSON with user_count and post_count\"\n\n1. Recognize: Clear requirements\n2. Create spec using spec-kit tools\n3. Route to: sdd:implement\n4. Implement will:\n   - Call spec-kit (auto-setup)\n   - Generate plan from spec\n   - Use TDD\n   - Verify spec compliance\n```\n\n### Pattern 3: Code Exists, Spec Missing\n\n```\nUser: \"Document what this auth module does\"\n\n1. Recognize: Code without spec\n2. Create spec by analyzing code\n3. Route to: sdd:evolve (to reconcile)\n```\n\n### Pattern 4: Code and Spec Diverged\n\n```\nUser: \"The login endpoint returns different errors than the spec says\"\n\n1. Recognize: Spec/code mismatch\n2. Route to: sdd:evolve\n3. Evolve will:\n   - Call spec-kit (auto-setup)\n   - Analyze mismatch\n   - Recommend update spec vs. fix code\n   - User decides or auto-update\n```\n\n## Remember\n\n**You are the methodology enforcer.**\n\n- Route to correct workflow skill\n- Enforce spec-first principle\n- Catch rationalizations\n- Ensure quality gates run\n\n**You are NOT:**\n- The technical setup manager (that's spec-kit)\n- The implementer (that's workflow skills)\n- The spec creator (that's spec-kit + brainstorm)\n\n**Your job:**\nEnsure the right skill gets used for the right task, and that SDD principles are followed.\n\n**The goal:**\nSpecs that stay current. Code that matches intent. Quality through discipline.\n",
        "sdd/skills/verification-before-completion/SKILL.md": "---\nname: verification-before-completion\ndescription: Extended verification including tests AND spec compliance - runs tests, validates spec compliance, checks for drift, blocks completion on failures\n---\n\n# Verification Before Completion (Spec-Aware)\n\n## Overview\n\nClaiming work is complete without verification is dishonesty, not efficiency.\n\n**Core principle:** Evidence before claims, always.\n\nVerify implementation is complete by running tests AND validating spec compliance.\n\n**Key Additions from Standard Verification:**\n- Step 1: Run tests (existing behavior)\n- **Step 2: Validate spec compliance** (new)\n- **Step 3: Check for spec drift** (new)\n- Blocks completion if EITHER tests OR spec compliance fails\n\n## The Iron Law\n\n```\nNO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE\n```\n\nIf you haven't run the verification command in this message, you cannot claim it passes.\n\n## The Gate Function\n\n```\nBEFORE claiming any status or expressing satisfaction:\n\n1. IDENTIFY: What command proves this claim?\n2. RUN: Execute the FULL command (fresh, complete)\n3. READ: Full output, check exit code, count failures\n4. VERIFY: Does output confirm the claim?\n   - If NO: State actual status with evidence\n   - If YES: State claim WITH evidence\n5. CHECK SPEC: Does implementation match spec?\n   - If NO: State actual compliance with evidence\n   - If YES: State compliance score WITH evidence\n6. ONLY THEN: Make the claim\n\nSkip any step = lying, not verifying\n```\n\n## When to Use\n\n- After implementation and code review\n- Before claiming work is complete\n- Before committing/merging/deploying\n- As final gate in `sdd:implement` workflow\n\n## The Process\n\n### 1. Run Tests\n\n**Execute all tests:**\n```bash\n# Run full test suite\nnpm test  # or pytest, go test, etc.\n```\n\n**Check results:**\n- All tests passing?\n- No flaky tests?\n- Coverage adequate?\n\n**If tests fail:**\n- STOP: Fix tests before proceeding\n- Do not skip this step\n- Do not claim completion\n\n### 2. Validate Spec Compliance\n\n**Load spec:**\n```bash\ncat specs/features/[feature-name].md\n```\n\n**Check each requirement:**\n\n```markdown\nFunctional Requirement 1: [From spec]\n  IMPLEMENTED / MISSING\n  TESTED / UNTESTED\n  MATCHES SPEC / DEVIATION\n\nFunctional Requirement 2: [From spec]\n  ...\n```\n\n**Verify:**\n- All requirements implemented\n- All requirements tested\n- All behavior matches spec\n- No missing features\n- No extra features (or documented)\n\n**Calculate compliance:**\n```\nSpec Compliance: X/X requirements = XX%\n```\n\n**If compliance < 100%:**\n- STOP: Use `sdd:evolve` to reconcile\n- Document all deviations\n- Do not proceed until resolved\n\n### 3. Check for Spec Drift\n\n**Compare:**\n- What spec says NOW\n- What code does NOW\n- Any divergence?\n\n**Common drift sources:**\n- Spec updated but code not\n- Code changed but spec not\n- Undocumented additions\n- Forgotten requirements\n\n**If drift detected:**\n- Document each instance\n- Use `sdd:evolve` to reconcile\n- Do not proceed with drift\n\n### 4. Verify Success Criteria\n\n**From spec, check each criterion:**\n\n```markdown\nSuccess Criteria (from spec):\n- [ ] Criterion 1: [Description]\n      Status: Met / Not met\n      Evidence: [How verified]\n\n- [ ] Criterion 2: [Description]\n      ...\n```\n\n**All criteria must be met.**\n\nIf any criterion not met:\n- STOP: Criterion not met\n- Implement missing piece\n- Re-verify\n\n### 5. Generate Verification Report\n\n**Report structure:**\n\n```markdown\n# Verification Report: [Feature Name]\n\n**Date:** YYYY-MM-DD\n**Spec:** specs/features/[feature].md\n\n## Test Results\n\n**Status:** PASS / FAIL\n\n```\n[Test output]\n```\n\n**Summary:**\n- Total: X tests\n- Passed: X\n- Failed: X\n- Coverage: XX%\n\n## Spec Compliance\n\n**Status:** COMPLIANT / NON-COMPLIANT\n\n**Compliance Score:** XX%\n\n### Requirements Status\n- Functional: X/X (XX%)\n- Error Cases: X/X (XX%)\n- Edge Cases: X/X (XX%)\n- Non-Functional: X/X (XX%)\n\n### Deviations\n[List any deviations found]\n\n## Spec Drift Check\n\n**Status:** NO DRIFT / DRIFT DETECTED\n\n[Details if drift found]\n\n## Success Criteria\n\n**Status:** ALL MET / INCOMPLETE\n\n- [x] Criterion 1\n- [x] Criterion 2\n...\n\n## Overall Status\n\n**VERIFIED - Ready for completion**\n\nOR\n\n**NOT VERIFIED - Issues must be resolved**\n\n**Blocking Issues:**\n- [Issue 1]\n- [Issue 2]\n\n**Next Steps:**\n[What needs to be done]\n```\n\n### 6. Make Go/No-Go Decision\n\n**All conditions must be true:**\n- [x] All tests passing\n- [x] Spec compliance 100%\n- [x] No spec drift\n- [x] All success criteria met\n\n**If ALL true:**\n- VERIFIED: Proceed to completion\n- Safe to commit/merge/deploy\n\n**If ANY false:**\n- NOT VERIFIED: Block completion\n- Fix issues before proceeding\n- Re-run verification after fixes\n\n## Common Failures\n\n| Claim | Requires | Not Sufficient |\n|-------|----------|----------------|\n| Tests pass | Test command output: 0 failures | Previous run, \"should pass\" |\n| Spec compliant | Line-by-line requirement check | \"Looks complete\" |\n| Linter clean | Linter output: 0 errors | Partial check |\n| Build succeeds | Build command: exit 0 | Linter passing |\n| Bug fixed | Test original symptom: passes | Code changed |\n| Requirements met | Line-by-line checklist | Tests passing |\n\n## Red Flags - STOP\n\n- Using \"should\", \"probably\", \"seems to\"\n- Expressing satisfaction before verification (\"Great!\", \"Perfect!\", \"Done!\")\n- About to commit/push/PR without verification\n- Relying on partial verification\n- Thinking \"just this once\"\n- Tired and wanting work over\n- **ANY wording implying success without having run verification**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Should work now\" | RUN the verification |\n| \"I'm confident\" | Confidence is not evidence |\n| \"Just this once\" | No exceptions |\n| \"Tests pass\" | Did you check spec compliance? |\n| \"Spec compliant\" | Did you run the tests? |\n| \"I'm tired\" | Exhaustion is not an excuse |\n| \"Partial check is enough\" | Partial proves nothing |\n\n## Verification Checklist\n\nUse TodoWrite to track:\n\n- [ ] Run full test suite\n- [ ] Verify all tests passing\n- [ ] Load specification\n- [ ] Validate spec compliance for all requirements\n- [ ] Check for spec drift\n- [ ] Verify all success criteria met\n- [ ] Generate verification report\n- [ ] Make go/no-go decision\n- [ ] If not verified: Document blocking issues\n- [ ] If verified: Proceed to completion\n\n## Example: Verification PASS\n\n```\nYou: Running verification before completion...\n\nStep 1: Running tests...\n\n$ npm test\n\nAll tests passing (24/24)\nCoverage: 95%\n\nStep 2: Validating spec compliance...\n\nReading spec: specs/features/user-profile-api.md\n\nChecking requirements:\nCOMPLIANT: Functional Requirement 1: PUT endpoint - Implemented & tested\nCOMPLIANT: Functional Requirement 2: Validation - Implemented & tested\nCOMPLIANT: Functional Requirement 3: Auth - Implemented & tested\nCOMPLIANT: Functional Requirement 4: Authorization - Implemented & tested\nCOMPLIANT: Functional Requirement 5: Response format - Implemented & tested\nCOMPLIANT: Functional Requirement 6: Partial updates - Implemented & tested\n\nCOMPLIANT: Error Case 1: Missing JWT - Handled & tested\nCOMPLIANT: Error Case 2: User not found - Handled & tested\nCOMPLIANT: Error Case 3: Validation failure - Handled & tested\nCOMPLIANT: Error Case 4: Authorization failure - Handled & tested\n\nCOMPLIANT: Edge Case 1: Empty update - Handled & tested\nCOMPLIANT: Edge Case 2: Invalid avatar URL - Handled & tested\nCOMPLIANT: Edge Case 3: Special characters in name - Handled & tested\n\nSpec Compliance: 13/13 = 100%\n\nStep 3: Checking for spec drift...\n\nComparing spec to implementation...\nNo drift detected\n\nStep 4: Verifying success criteria...\n\nFrom spec:\nMET: Authenticated users can update their profile\nMET: Validation errors return 422 with clear messages\nMET: Users cannot update other users' profiles\nMET: All edge cases handled gracefully\n\nAll criteria met\n\n=== VERIFICATION REPORT ===\n\nTests: PASS (24/24)\nSpec Compliance: 100%\nSpec Drift: None\nSuccess Criteria: All met\n\n**OVERALL: VERIFIED**\n\nImplementation is complete and verified. Ready for commit/merge.\n```\n\n## Example: Verification FAIL\n\n```\nYou: Running verification before completion...\n\nStep 1: Running tests...\n\n$ npm test\n\nTests FAILED (22/24 passing, 2 failing)\n\nFailures:\n1. \"Should handle database connection errors\"\n   Error: Connection retry not implemented\n\n2. \"Should return 503 when database unavailable\"\n   Error: Returns 500 instead of 503\n\n**BLOCKING: Tests must pass before proceeding**\n\nStep 2: Validating spec compliance...\n\nReading spec: specs/features/user-profile-api.md\n\nChecking requirements:\n[checks requirements...]\n\nDEVIATION: Non-Functional Requirement 1: Database retry logic\n   Status: Not implemented\n   Spec says: \"3 retry attempts with exponential backoff\"\n   Code does: Single attempt, no retry\n\nSpec Compliance: 12/13 = 92%\n\nStep 3: Checking success criteria...\n\nFrom spec:\nMET: Authenticated users can update their profile\nMET: Validation errors return 422\nNOT MET: Handles database failures gracefully (missing retry logic)\nMET: Users cannot update other users' profiles\n\n=== VERIFICATION REPORT ===\n\nTests: FAIL (2 failures)\nSpec Compliance: 92% (missing retry logic)\nSuccess Criteria: 3/4 met\n\n**OVERALL: NOT VERIFIED**\n\n**Blocking Issues:**\n1. Database retry logic not implemented (from spec)\n2. Tests failing for error handling\n3. Returns wrong HTTP status (500 vs 503)\n\n**Next Steps:**\n1. Implement database retry logic per spec\n2. Fix HTTP status code\n3. Re-run verification\n\n**DO NOT PROCEED until all issues resolved.**\n```\n\n## Common Failure Scenarios\n\n### Scenario: Tests Pass but Spec Compliance Fails\n\n```\nTests: 24/24 passing\nSpec Compliance: 85%\nBLOCKED\n\nIssue: Tests don't cover all spec requirements\n\nAction: Add tests for uncovered requirements, re-verify\n```\n\n### Scenario: Spec Compliant but Tests Fail\n\n```\nTests: 20/24 passing\nSpec Compliance: 100%\nBLOCKED\n\nIssue: Implementation exists but has bugs\n\nAction: Fix bugs, ensure tests pass, re-verify\n```\n\n### Scenario: Both Pass but Drift Detected\n\n```\nTests: 24/24 passing\nSpec Compliance: 100%\nSpec Drift: Spec updated after implementation\nBLOCKED\n\nIssue: Spec changed, code doesn't reflect changes\n\nAction: Update code or revert spec, re-verify\n```\n\n## Quality Gates\n\n**This skill enforces quality gates:**\n\n1. **All tests must pass** (from superpowers)\n2. **100% spec compliance required** (SDD)\n3. **No spec drift allowed** (SDD)\n4. **All success criteria must be met** (SDD)\n\n**No exceptions. No shortcuts.**\n\nThese gates exist to prevent:\n- Incomplete implementations\n- Untested code\n- Spec/code divergence\n- False claims of completion\n\n## Remember\n\n**Verification is not optional.**\n\n- Don't skip verification \"just this once\"\n- Don't claim completion without verification\n- Don't ignore failing gates\n\n**Verification failures are information.**\n\n- Tests failing? Code has bugs\n- Spec compliance failing? Missing features\n- Drift detected? Synchronization problem\n- Criteria not met? Work incomplete\n\n**No shortcuts for verification.**\n\nRun the command. Read the output. Check the spec. THEN claim the result.\n\n**Fix issues, don't rationalize past them.**\n\n**Evidence before assertions. Always.**\n\nThis is non-negotiable.\n",
        "sdd/skills/writing-plans/SKILL.md": "---\nname: writing-plans\ndescription: Generate implementation plans FROM specifications - reads spec as input, extracts requirements, creates step-by-step tasks with validation against spec\n---\n\n# Writing Implementation Plans from Specifications\n\n## Overview\n\nGenerate detailed implementation plans derived FROM specifications, not from scratch.\n\nThe spec is the source of truth. The plan translates spec requirements into concrete, actionable implementation tasks.\n\n**Key Difference from Standard Writing-Plans:**\n- **Input is SPEC** (not blank slate)\n- Plan MUST cover all spec requirements\n- Plan validates against spec for completeness\n- Tasks reference spec sections explicitly\n\n## When to Use\n\n**Use this skill when:**\n- Spec exists and is validated\n- Ready to create implementation plan\n- Called by `sdd:implement` workflow\n- Need to break spec into tasks\n\n**Don't use this skill when:**\n- No spec exists ‚Üí Create spec first\n- Plan already exists ‚Üí Review/update existing plan\n- Just clarifying approach ‚Üí Use brainstorming\n\n## Prerequisites\n\n- [ ] Spec exists and is complete\n- [ ] Spec validated for soundness\n- [ ] No blocking open questions in spec\n- [ ] Ready to start implementation\n\n## The Process\n\n### 1. Read and Parse Specification\n\n**Load the spec:**\n```bash\ncat specs/features/[feature-name].md\n```\n\n**Extract all elements:**\n- **Functional requirements** (what to build)\n- **Non-functional requirements** (how it should perform)\n- **Success criteria** (how to verify)\n- **Error handling** (what can go wrong)\n- **Edge cases** (boundary conditions)\n- **Dependencies** (what's needed)\n- **Constraints** (limitations)\n\n**Create requirements checklist:**\n- Number each requirement\n- Reference spec section\n- Mark coverage status\n\n### 2. Understand Project Context\n\n**Check existing codebase:**\n```bash\n# Find related files\nrg \"[relevant-terms]\"\n\n# Check architecture\nls -la src/\n\n# Review dependencies\ncat package.json  # or requirements.txt, go.mod, etc.\n```\n\n**Identify:**\n- Where new code should live\n- Existing patterns to follow\n- Components to reuse\n- Integration points\n\n### 3. Design Implementation Strategy\n\n**For each functional requirement, determine:**\n\n**Approach:**\n- How will this be implemented?\n- What components are needed?\n- What patterns apply?\n\n**Files:**\n- What files to create?\n- What files to modify?\n- Full file paths\n\n**Dependencies:**\n- What needs to exist first?\n- What can be done in parallel?\n- What's the critical path?\n\n**Testing:**\n- How will this be tested?\n- What test files needed?\n- What edge cases to cover?\n\n### 4. Create Implementation Plan\n\n**Use this structure:**\n\n```markdown\n# Implementation Plan: [Feature Name]\n\n**Source Spec:** specs/features/[feature-name].md\n**Date:** YYYY-MM-DD\n**Estimated Effort:** [time estimate if relevant]\n\n## Overview\n\n[Brief summary of what we're implementing and why]\n\n## Requirements Coverage\n\n### Functional Requirement 1: [Quote from spec]\n**Spec Reference:** specs/features/[feature].md#[section]\n\n**Implementation Approach:**\n[How we'll implement this requirement]\n\n**Tasks:**\n- [ ] [Specific actionable task]\n- [ ] [Another task]\n\n**Files to Create/Modify:**\n- `path/to/file.ext` - [What changes]\n\n**Tests:**\n- [ ] [Test case for this requirement]\n\n---\n\n### Functional Requirement 2: [Quote from spec]\n[Repeat structure]\n\n---\n\n[Continue for ALL functional requirements]\n\n## Non-Functional Requirements\n\n[For each non-functional requirement from spec]\n\n### [Requirement Name]: [Quote from spec]\n**Spec Reference:** specs/features/[feature].md#[section]\n\n**Implementation:**\n[How we'll achieve this]\n\n**Validation:**\n[How we'll measure/verify this]\n\n## Error Handling Implementation\n\n[For each error case in spec]\n\n### Error: [From spec]\n**Spec Reference:** specs/features/[feature].md#error-handling\n\n**Implementation:**\n```\n[Code approach or pseudocode]\n```\n\n**Test Cases:**\n- [ ] [Test for this error case]\n\n## Edge Cases Implementation\n\n[For each edge case in spec]\n\n### Edge Case: [From spec]\n**Expected Behavior:** [From spec]\n\n**Implementation:**\n[How we'll handle this]\n\n**Test:**\n- [ ] [Test for edge case]\n\n## Dependencies\n\n**Required Before Implementation:**\n- [ ] [Dependency 1 from spec]\n- [ ] [Dependency 2 from spec]\n\n**Integration Points:**\n- [Component/service 1]: [How we integrate]\n- [Component/service 2]: [How we integrate]\n\n## Implementation Order\n\n**Phase 1: Foundation**\n1. [Task]\n2. [Task]\n\n**Phase 2: Core Functionality**\n1. [Task]\n2. [Task]\n\n**Phase 3: Error Handling**\n1. [Task]\n2. [Task]\n\n**Phase 4: Edge Cases & Polish**\n1. [Task]\n2. [Task]\n\n## Test Strategy\n\n**Unit Tests:**\n- [ ] [Component/function to test]\n- [ ] [Another component/function]\n\n**Integration Tests:**\n- [ ] [Integration scenario]\n- [ ] [Another scenario]\n\n**Spec Compliance Tests:**\n- [ ] [Verify requirement 1]\n- [ ] [Verify requirement 2]\n\n## Files to Create\n\n- `path/to/new/file1.ext` - [Purpose]\n- `path/to/new/file2.ext` - [Purpose]\n\n## Files to Modify\n\n- `path/to/existing/file1.ext` - [What changes]\n- `path/to/existing/file2.ext` - [What changes]\n\n## Success Criteria\n\n[From spec, repeated here for reference]\n- [ ] [Criterion 1]\n- [ ] [Criterion 2]\n\n## Spec Validation Checklist\n\n**All requirements covered:**\n- [ ] All functional requirements have tasks\n- [ ] All non-functional requirements addressed\n- [ ] All error cases have implementation approach\n- [ ] All edge cases have handling strategy\n- [ ] All dependencies identified\n- [ ] All success criteria have verification plan\n\n**Plan completeness:**\n- [ ] All tasks are specific and actionable\n- [ ] All file paths are complete (not \"TBD\")\n- [ ] All requirements reference spec sections\n- [ ] Test strategy covers all requirements\n- [ ] Implementation order is logical\n\n## Notes\n\n[Any additional context, decisions, or considerations]\n```\n\n### 5. Validate Plan Against Spec\n\n**Completeness check:**\n\nFor each requirement in spec:\n- [ ] Plan has implementation approach\n- [ ] Plan has specific tasks\n- [ ] Plan has test coverage\n- [ ] Plan references spec section\n\n**Coverage matrix:**\n```\nRequirement 1 ‚Üí Tasks [1,2,3], Tests [A,B]     ‚úì\nRequirement 2 ‚Üí Tasks [4,5], Tests [C,D]       ‚úì\nRequirement 3 ‚Üí Tasks [6], Tests [E,F,G]       ‚úì\n...\n```\n\n**If any requirement uncovered:** Add tasks before proceeding.\n\n### 6. Review for Implementability\n\n**Check that plan:**\n- Has concrete file paths (not \"somewhere\")\n- Has specific tasks (not vague \"implement X\")\n- Has realistic order (dependencies respected)\n- Has test coverage (every requirement tested)\n\n**Red flags:**\n- \"Figure out how to...\"\n- \"Implement [vague concept]\"\n- \"TBD\"\n- Missing file paths\n- No test strategy\n\n### 7. Save and Commit Plan\n\n**Save plan:**\n```bash\n# Location\ndocs/plans/[date]-[feature]-implementation.md\n```\n\n**Commit plan:**\n```bash\ngit add docs/plans/[date]-[feature]-implementation.md\ngit commit -m \"Add implementation plan for [feature]\n\nGenerated from spec: specs/features/[feature].md\n\nCoverage:\n- [N] functional requirements\n- [N] error cases\n- [N] edge cases\n\nEstimated [N] tasks\n\nü§ñ Generated with [Claude Code](https://claude.com/claude-code)\n\nCo-Authored-By: Claude <noreply@anthropic.com>\"\n```\n\n## Checklist\n\nUse TodoWrite to track:\n\n- [ ] Read and parse specification completely\n- [ ] Extract all requirements, errors, edge cases\n- [ ] Understand project context and codebase\n- [ ] Design implementation strategy\n- [ ] Create implementation plan with all sections\n- [ ] Validate plan coverage against spec (100%)\n- [ ] Review plan for implementability\n- [ ] Ensure all file paths are complete\n- [ ] Ensure all tasks are specific and actionable\n- [ ] Save plan to docs/plans/\n- [ ] Commit plan to git\n\n## Example\n\n```\n[Called from sdd:implement]\n\nYou: Generating implementation plan from spec...\n\nReading spec: specs/features/user-profile-api.md\n\nExtracting requirements:\n- Functional: 6 requirements\n- Non-functional: 3 requirements\n- Error cases: 4\n- Edge cases: 3\n- Dependencies: 2\n\nUnderstanding project context...\n- Existing API routes in: src/api/\n- Validation middleware in: src/middleware/\n- User service in: src/services/user.ts\n- Tests in: tests/api/\n\nCreating implementation plan...\n\n# Implementation Plan: User Profile Update API\n\n**Source Spec:** specs/features/user-profile-api.md\n**Date:** 2025-11-10\n\n## Overview\n\nImplement REST API endpoint for authenticated users to update their profiles.\nIncludes validation, error handling, and partial update support.\n\n## Requirements Coverage\n\n### Functional Requirement 1: PUT endpoint accepts requests\n**Spec Reference:** specs/features/user-profile-api.md#functional-requirements\n\n**Implementation Approach:**\nCreate Express route handler at PUT /api/users/:id/profile using\nexisting route structure in src/api/users/\n\n**Tasks:**\n- [ ] Create route file at src/api/users/profile.ts\n- [ ] Register route in src/api/users/index.ts\n- [ ] Add route handler function\n\n**Files to Create/Modify:**\n- `src/api/users/profile.ts` - New route handler\n- `src/api/users/index.ts` - Register route\n\n**Tests:**\n- [ ] Test route responds to PUT requests\n- [ ] Test route path is /api/users/:id/profile\n\n---\n\n### Functional Requirement 2: Validate request body\n**Spec Reference:** specs/features/user-profile-api.md#functional-requirements\n\n**Implementation Approach:**\nCreate validation middleware using existing validation pattern.\nValidate: name (2-50 chars), bio (max 500), avatar_url (URL format).\n\n**Tasks:**\n- [ ] Create validation schema in src/middleware/validation/profile.ts\n- [ ] Add validation middleware to route\n- [ ] Return 422 on validation errors\n\n**Files to Create/Modify:**\n- `src/middleware/validation/profile.ts` - Validation schema\n- `src/api/users/profile.ts` - Apply middleware\n\n**Tests:**\n- [ ] Test name length validation (too short)\n- [ ] Test name length validation (too long)\n- [ ] Test bio length validation\n- [ ] Test avatar_url format validation\n\n[... continues for all requirements ...]\n\n## Spec Validation Checklist\n\n**All requirements covered:**\n- [x] All 6 functional requirements have tasks\n- [x] All 3 non-functional requirements addressed\n- [x] All 4 error cases have implementation\n- [x] All 3 edge cases handled\n- [x] All 2 dependencies identified\n- [x] All 5 success criteria have verification\n\nPlan validated against spec ‚úì\nCoverage: 100%\n\nSaving plan to: docs/plans/2025-11-10-user-profile-api-implementation.md\n\nPlan created ‚úì\nCommitted to git ‚úì\n\nPlan has 24 tasks across 4 phases.\nReady to implement with TDD?\n```\n\n## Quality Standards\n\n**Every plan MUST have:**\n- Complete file paths (no \"TBD\")\n- Specific tasks (not vague)\n- Test coverage (every requirement)\n- Error handling (every error case)\n- Edge case coverage (every edge case)\n- Spec references (every requirement linked)\n\n**Every task MUST be:**\n- Actionable (clear what to do)\n- Testable (can verify completion)\n- Atomic (one clear outcome)\n- Ordered (dependencies respected)\n\n## Common Pitfalls\n\n**Avoid:**\n- Creating plan before spec exists\n- Missing spec requirements in plan\n- Vague tasks (\"implement feature\")\n- Missing file paths\n- No test strategy\n- Skipping error cases\n- Ignoring edge cases\n\n**Instead:**\n- Always start from spec\n- Cover 100% of spec requirements\n- Make tasks concrete and specific\n- Provide complete file paths\n- Test every requirement\n- Handle every error case\n- Cover every edge case\n\n## Remember\n\n**The plan is a bridge from spec to code.**\n\n- Spec says WHAT\n- Plan says HOW and WHERE and WHEN\n- Code implements the plan\n\n**A good plan makes implementation smooth.**\n**A poor plan causes confusion and rework.**\n\n**Validate against spec before proceeding.**\n**100% coverage is non-negotiable.**\n"
      },
      "plugins": [
        {
          "name": "sdd",
          "version": "1.0.0",
          "description": "Specification-Driven Development with Process Discipline for Claude Code",
          "author": {
            "name": "Roland Huss",
            "email": "rhuss@redhat.com"
          },
          "source": "./sdd",
          "homepage": "https://github.com/rhuss/cc-superpowers-sdd",
          "repository": "https://github.com/rhuss/cc-superpowers-sdd.git",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add rhuss/cc-superpowers-sdd",
            "/plugin install sdd@sdd-plugin-development"
          ]
        }
      ]
    }
  ]
}