{
  "author": {
    "id": "yucchiy",
    "display_name": "Yuichiro MUKAI",
    "avatar_url": "https://avatars.githubusercontent.com/u/325819?u=8cdaf2e33c840aa98fe4b7bf4e35f7b9a66e8991&v=4"
  },
  "marketplaces": [
    {
      "name": "unicli",
      "version": null,
      "description": "Claude Code plugin for controlling Unity Editor via UniCli CLI",
      "repo_full_name": "yucchiy/UniCli",
      "repo_url": "https://github.com/yucchiy/UniCli",
      "repo_description": "A CLI tool to control Unity Editor - enabling both humans and AI agents to run compilations, tests, and editor commands from the terminal.",
      "signals": {
        "stars": 11,
        "forks": 0,
        "pushed_at": "2026-02-21T12:33:02Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"unicli\",\n  \"owner\": {\n    \"name\": \"Yuichiro Mukai\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugin for controlling Unity Editor via UniCli CLI\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"unicli\",\n      \"source\": \"./.claude-plugin/unicli\",\n      \"description\": \"Control Unity Editor from Claude Code using UniCli CLI\",\n      \"version\": \"0.11.1\",\n      \"author\": {\n        \"name\": \"Yuichiro Mukai\"\n      },\n      \"homepage\": \"https://github.com/yucchiy/UniCli\",\n      \"repository\": \"https://github.com/yucchiy/UniCli\",\n      \"license\": \"MIT\",\n      \"strict\": false\n    }\n  ]\n}\n",
        "README.md": "# UniCli\n\nA command-line interface for controlling Unity Editor from the terminal.\nUniCli lets you compile scripts, run tests, manage packages, inspect GameObjects, and more — all without leaving your terminal.\n\nDesigned to work with AI coding agents such as [Claude Code](https://docs.anthropic.com/en/docs/claude-code), UniCli gives AI the ability to interact with Unity Editor directly through structured CLI commands with JSON output.\n\n## How It Works\n\nUniCli consists of two components:\n\n- **CLI** (`unicli`) — A NativeAOT-compiled binary that you run from the terminal\n- **Unity Package** (`com.yucchiy.unicli-server`) — An Editor plugin that receives and executes commands inside Unity\n\n### Architecture\n\n```\n┌──────────┐  Named Pipe     ┌────────────────┐  PlayerConnection  ┌────────────────┐\n│  unicli  │◄───────────────►│  Unity Editor  │◄──────────────────►│     Device     │\n│  (CLI)   │ Length-prefixed │  (Server)      │ Chunked messages   │  (Dev Build)   │\n│          │ JSON messages   │                │                    │                │\n└──────────┘                 └────────────────┘                    └────────────────┘\n```\n\n**CLI ↔ Editor (Named Pipe):**\nThe CLI and Unity Editor communicate over a named pipe. The pipe name is derived from a SHA256 hash of the project's `Assets` path, so each project gets its own connection. Messages use a length-prefixed JSON framing protocol with a handshake (magic bytes `UCLI` + protocol version). The server plugin initializes via `[InitializeOnLoad]`, creates a background listener on the named pipe, and enqueues incoming commands to a `ConcurrentQueue`. Commands are dequeued and executed on Unity's main thread every frame via `EditorApplication.update`.\n\n**Editor ↔ Device (PlayerConnection):**\nFor remote debugging, the Editor relays commands to a running Development Build via Unity's `PlayerConnection`. The runtime module (`UniCli.Remote`) auto-initializes a `RuntimeDebugReceiver` on the device, which discovers debug commands via reflection and registers message handlers. Responses are split into 16 KB chunks to work around PlayerConnection's undocumented message size limits. The Editor's `RemoteBridge` reassembles chunks and returns the complete response to the CLI.\n\n## Requirements\n\n- Unity 2022.3 or later\n- macOS (arm64 / x64) or Windows (x64)\n\n## Installation\n\n### CLI\n\n**Homebrew (macOS):**\n\n```bash\nbrew tap yucchiy/tap\nbrew install unicli\n```\n\n**Manual:** Download the latest binary from the [Releases](https://github.com/yucchiy/UniCli/releases) page and place it in your PATH.\n\n### Unity Package\n\nThe UniCli package must be installed in your Unity project. You can install it using the CLI:\n\n```bash\nunicli install\n```\n\nOr add it manually via Unity Package Manager using the git URL:\n\n```\nhttps://github.com/yucchiy/UniCli.git?path=src/UniCli.Unity/Packages/com.yucchiy.unicli-server\n```\n\n## CLI Subcommands\n\nThe `unicli` binary provides the following subcommands:\n\n| Subcommand    | Description                                                 |\n|---------------|-------------------------------------------------------------|\n| `check`       | Check package installation and Unity Editor connection      |\n| `install`     | Install the UniCli package into a Unity project             |\n| `exec`        | Execute a command on the Unity Editor                       |\n| `eval`        | Compile and execute C# code dynamically in the Unity Editor |\n| `commands`    | List all available commands                                 |\n| `status`      | Show connection status and project info                     |\n| `completions` | Generate shell completion scripts (bash / zsh / fish)       |\n\n```\nunicli check             # verify installation and editor connection\nunicli install           # install the Unity package\nunicli commands          # list all available commands\nunicli eval '<code>'     # compile and execute C# code dynamically\nunicli status            # show connection details\nunicli completions bash  # generate shell completions\n```\n\nAdd `--json` to `check`, `commands`, or `status` for machine-readable JSON output.\n\n### Project Discovery\n\nBy default, `unicli` searches the current directory and its ancestors for a Unity project (a directory containing an `Assets` folder). If you run `unicli` from outside a Unity project, or want to target a specific project, set the `UNICLI_PROJECT` environment variable:\n\n```bash\n# Run from anywhere by specifying the project path\nUNICLI_PROJECT=/path/to/my/unity-project unicli exec Compile --json\n\n# Useful when the current directory is not inside the Unity project\nUNICLI_PROJECT=src/UniCli.Unity unicli commands --json\n```\n\nThe pipe name used for communication is derived from the project path, so each Unity project gets its own connection.\n\n\n## Dynamic Code Execution (Eval)\n\n`unicli eval` compiles and executes arbitrary C# code in the Unity Editor context using `AssemblyBuilder`. Code has full access to Unity APIs including `UnityEngine` and `UnityEditor`.\n\n```bash\nunicli eval '<code>' [--json] [--declarations '<decl>'] [--timeout <ms>]\n```\n\n| Option | Description |\n|---|---|\n| `--json` | Output in JSON format |\n| `--declarations` | Additional type declarations (classes, structs, enums) |\n| `--timeout` | Timeout in milliseconds |\n\nFor multi-line code, use shell heredocs:\n\n```bash\nunicli eval \"$(cat <<'EOF'\nvar scene = UnityEngine.SceneManagement.SceneManager.GetActiveScene();\nvar objects = GameObject.FindObjectsOfType<GameObject>(true);\nreturn $\"{scene.name}: {objects.Length} objects\";\nEOF\n)\" --json\n```\n\nThe result is returned as raw JSON. If the return type is `[Serializable]`, it is serialized with `JsonUtility`. `UnityEngine.Object` types use `EditorJsonUtility`. Primitives and strings are returned directly. Code that doesn't return a value (`void` operations) returns `null`.\n\nEval code supports `async`/`await` and receives a `cancellationToken` variable (`System.Threading.CancellationToken`) that is cancelled when the client disconnects. Use it for cooperative cancellation of long-running operations:\n\n```bash\n# Wait asynchronously with cancellation support\nunicli eval 'await Task.Delay(5000, cancellationToken); return \"done\";' --json\n```\n\n\n## Executing Commands\n\nUse `unicli exec <command>` to run commands on the Unity Editor.\n\n### Parameter syntax\n\nParameters can be passed as `--key value` flags (recommended) or as a raw JSON string:\n\n```bash\n# --key value syntax (recommended)\nunicli exec GameObject.Find --name \"Main Camera\"\nunicli exec TestRunner.RunEditMode --testNameFilter MyTest\n\n# Raw JSON syntax\nunicli exec GameObject.Find '{\"name\":\"Main Camera\"}'\n```\n\nBoolean flags can be passed without a value:\n\n```bash\nunicli exec GameObject.Find --includeInactive\n```\n\nArray parameters can be passed by repeating the same flag:\n\n```bash\nunicli exec BuildPlayer.Build --locationPathName \"Builds/Test.app\" --options Development --options ConnectWithProfiler\nunicli exec BuildPlayer.Compile --target iOS --extraScriptingDefines MY_DEFINE --extraScriptingDefines ANOTHER_DEFINE\n```\n\n### Common options\n\nThese options can be combined with any `exec` command:\n\n| Option      | Description                          |\n|-------------|--------------------------------------|\n| `--json`    | Output in JSON format                |\n| `--timeout` | Set command timeout in milliseconds  |\n| `--no-focus`| Don't bring Unity Editor to front    |\n| `--help`    | Show command parameters and usage    |\n\nBy default, when the server is not responding (e.g., after an assembly reload), the CLI automatically brings Unity Editor to the foreground using a PID file (`Library/UniCli/server.pid`) and restores focus to the original application once the command completes. Use `--no-focus` to disable this behavior, or set the `UNICLI_FOCUS` environment variable to `0` or `false` to disable it globally.\n\nFor example:\n\n```bash\nunicli exec Compile --json\nunicli exec Compile --timeout 30000\nunicli exec GameObject.Find --help\n```\n\n### Examples\n\n```bash\n# Compile scripts\nunicli exec Compile\n\n# Build the player\nunicli exec BuildPlayer.Build --locationPathName \"Builds/Test.app\"\nunicli exec BuildPlayer.Build --locationPathName \"Builds/Test.app\" --options Development\nunicli exec BuildPlayer.Build --locationPathName \"Builds/Test.app\" --options Development --options ConnectWithProfiler\nunicli exec BuildPlayer.Build --locationPathName \"Builds/Test.app\" --target Android --scenes \"Assets/Scenes/Main.unity\"\n\n# Compile player scripts for a specific build target\nunicli exec BuildPlayer.Compile\nunicli exec BuildPlayer.Compile --target Android\nunicli exec BuildPlayer.Compile --target iOS --extraScriptingDefines MY_DEFINE --extraScriptingDefines ANOTHER_DEFINE\n\n# List available connection targets (players/devices)\nunicli exec Connection.List\n\n# Get current connection status\nunicli exec Connection.Status\n\n# Connect to a target by ID, IP, or device ID\nunicli exec Connection.Connect '{\"id\":-1}'\nunicli exec Connection.Connect '{\"ip\":\"192.168.1.100\"}'\nunicli exec Connection.Connect '{\"deviceId\":\"DEVICE_SERIAL\"}'\n\n# Run tests\nunicli exec TestRunner.RunEditMode\nunicli exec TestRunner.RunPlayMode\nunicli exec TestRunner.RunEditMode --testNameFilter MyTest\n\n# Find GameObjects\nunicli exec GameObject.Find --name \"Main Camera\"\nunicli exec GameObject.Find --tag Player --includeInactive\nunicli exec GameObject.GetHierarchy\nunicli exec GameObject.GetComponents --instanceId 1234\nunicli exec GameObject.AddComponent --path \"Player\" --typeName BoxCollider\nunicli exec GameObject.RemoveComponent --componentInstanceId 1234\n\n# Create GameObjects\nunicli exec GameObject.Create --name \"Enemy\"\nunicli exec GameObject.Create --name \"Child\" --parent \"Enemy\"\nunicli exec GameObject.Create --name \"WithCollider\" --components BoxCollider\nunicli exec GameObject.CreatePrimitive --primitiveType Cube\nunicli exec GameObject.CreatePrimitive --primitiveType Sphere --name \"Ball\" --parent \"Enemy\"\n\n# Modify GameObjects\nunicli exec GameObject.Rename --path \"Enemy\" --name \"Boss\"\nunicli exec GameObject.SetTransform --path \"Boss\" --position 1,2,3 --rotation 0,90,0\nunicli exec GameObject.Duplicate --path \"Boss\"\nunicli exec GameObject.SetParent --path \"Boss(Clone)\" --parentPath \"Boss\"\nunicli exec GameObject.Destroy --path \"Boss(Clone)\"\n\n# Set component properties\nunicli exec Component.SetProperty --componentInstanceId 1234 --propertyPath \"m_IsKinematic\" --value \"true\"\n\n# Set ObjectReference properties (e.g. assign a material to a renderer)\nunicli exec Component.SetProperty --componentInstanceId 1234 --propertyPath \"m_Materials.Array.data[0]\" --value \"guid:abc123def456\"\nunicli exec Component.SetProperty --componentInstanceId 1234 --propertyPath \"m_Mesh\" --value \"Assets/Meshes/Custom.mesh\"\nunicli exec Component.SetProperty --componentInstanceId 1234 --propertyPath \"m_Material\" --value \"null\"\n\n# Material operations\nunicli exec Material.Create --assetPath \"Assets/Materials/MyMat.mat\"\nunicli exec Material.Create --assetPath \"Assets/Materials/MyMat.mat\" --shader \"Standard\"\nunicli exec Material.Inspect --guid \"abc123def456\"\nunicli exec Material.SetColor --guid \"abc123def456\" --name \"_Color\" --value '{\"r\":1,\"g\":0,\"b\":0,\"a\":1}'\nunicli exec Material.SetFloat --guid \"abc123def456\" --name \"_Metallic\" --value 0.8\n\n# AnimatorController operations\nunicli exec AnimatorController.Create --assetPath \"Assets/Animations/Player.controller\"\nunicli exec AnimatorController.Inspect --assetPath \"Assets/Animations/Player.controller\"\nunicli exec AnimatorController.AddParameter --assetPath \"Assets/Animations/Player.controller\" --name \"Speed\" --type Float\nunicli exec AnimatorController.AddState --assetPath \"Assets/Animations/Player.controller\" --name \"Idle\"\nunicli exec AnimatorController.AddState --assetPath \"Assets/Animations/Player.controller\" --name \"Walk\"\nunicli exec AnimatorController.AddTransition --assetPath \"Assets/Animations/Player.controller\" --sourceStateName \"Idle\" --destinationStateName \"Walk\"\nunicli exec AnimatorController.AddTransitionCondition --assetPath \"Assets/Animations/Player.controller\" --sourceStateName \"Idle\" --destinationStateName \"Walk\" --parameter \"Speed\" --mode Greater --threshold 0.1\n\n# Animator component operations\nunicli exec Animator.SetController --path \"Player\" --controllerAssetPath \"Assets/Animations/Player.controller\"\nunicli exec Animator.Inspect --path \"Player\"\n\n# Prefab operations\nunicli exec Prefab.GetStatus --path \"MyPrefabInstance\"\nunicli exec Prefab.Instantiate --assetPath \"Assets/Prefabs/Enemy.prefab\"\nunicli exec Prefab.Save --path \"Player\" --assetPath \"Assets/Prefabs/Player.prefab\"\nunicli exec Prefab.Apply --path \"MyPrefabInstance\"\nunicli exec Prefab.Unpack --path \"MyPrefabInstance\" --completely\n\n# Delete an asset\nunicli exec AssetDatabase.Delete --path \"Assets/Prefabs/Old.prefab\"\n\n# Manage packages\nunicli exec PackageManager.List\nunicli exec PackageManager.Add --packageIdOrName com.unity.mathematics\nunicli exec PackageManager.Remove --packageIdOrName com.unity.mathematics\nunicli exec PackageManager.GetInfo --name com.unity.test-framework\nunicli exec PackageManager.Update --name com.unity.test-framework\nunicli exec PackageManager.Update --name com.unity.test-framework --version 1.4.5\n\n# Scene operations\nunicli exec Scene.List\nunicli exec Scene.GetActive\nunicli exec Scene.Open --path \"Assets/Scenes/Level1.unity\"\nunicli exec Scene.Open --path \"Assets/Scenes/Additive.unity\" --additive\nunicli exec Scene.SetActive --name \"Level1\"\nunicli exec Scene.Save --all\nunicli exec Scene.Save --name \"Level1\" --saveAsPath \"Assets/Scenes/Level1_backup.unity\"\nunicli exec Scene.Close --name \"Additive\"\nunicli exec Scene.New --empty --additive\n\n# Settings — inspect all values\nunicli exec PlayerSettings.Inspect\nunicli exec EditorSettings.Inspect\n\n# Settings — set a property\nunicli exec PlayerSettings.companyName --value \"MyCompany\"\nunicli exec PlayerSettings.Android.minSdkVersion --value AndroidApiLevel28\n\n# Settings — call Set/Get methods (with platform target)\nunicli exec PlayerSettings.SetScriptingBackend --buildTarget Android --value IL2CPP\nunicli exec PlayerSettings.GetScriptingBackend --buildTarget Android\n\n# Execute menu items\nunicli exec Menu.Execute --menuPath \"Window/General/Console\"\n\n# Console logs\nunicli exec Console.GetLog\nunicli exec Console.Clear\n\n# Dynamic C# code execution (Eval)\nunicli eval 'return Application.unityVersion;' --json\nunicli eval 'return PlayerSettings.productName;' --json\n\n# Multi-line code with heredoc\nunicli eval \"$(cat <<'EOF'\nvar go = GameObject.Find(\"Main Camera\");\nreturn go.transform.position;\nEOF\n)\" --json\n\n# Void operations (no return value needed)\nunicli eval \"$(cat <<'EOF'\nvar go = new GameObject(\"Created by Eval\");\ngo.AddComponent<BoxCollider>();\nEOF\n)\" --json\n\n# Async/await (the generated code receives a cancellationToken variable)\nunicli eval 'await Task.Delay(100, cancellationToken); return \"done\";' --json\n\n# Custom type declarations with --declarations\nunicli eval \"$(cat <<'EOF'\nvar stats = new MyStats();\nstats.objectCount = GameObject.FindObjectsOfType<GameObject>().Length;\nstats.sceneName = UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;\nreturn stats;\nEOF\n)\" --declarations \"$(cat <<'EOF'\n[System.Serializable]\npublic class MyStats\n{\n    public int objectCount;\n    public string sceneName;\n}\nEOF\n)\" --json\n```\n\n**Profiler operations:**\n\n```bash\n# Get profiler status and memory statistics\nunicli exec Profiler.Inspect --json\n\n# Start profiler recording (clears existing frames by default)\nunicli exec Profiler.StartRecording --json\nunicli exec Profiler.StartRecording '{\"deep\":true}' --json\nunicli exec Profiler.StartRecording '{\"editor\":true}' --json\n\n# Stop profiler recording\nunicli exec Profiler.StopRecording --json\n\n# Save profiler data to a .raw file\nunicli exec Profiler.SaveProfile '{\"path\":\"Profiles/capture.raw\"}' --json\n\n# Load profiler data from a .raw file\nunicli exec Profiler.LoadProfile '{\"path\":\"Profiles/capture.raw\"}' --json\n\n# Get CPU sample data for the last frame (top 20 by default)\nunicli exec Profiler.GetFrameData --json\nunicli exec Profiler.GetFrameData '{\"frame\":10,\"limit\":5}' --json\n\n# Take a memory snapshot (.snap file)\nunicli exec Profiler.TakeSnapshot --json\nunicli exec Profiler.TakeSnapshot '{\"path\":\"MemoryCaptures/my_snapshot.snap\"}' --json\n\n# Analyze recorded frames (aggregate statistics)\nunicli exec Profiler.AnalyzeFrames --json\nunicli exec Profiler.AnalyzeFrames '{\"startFrame\":100,\"endFrame\":200,\"topSampleCount\":20}' --json\n\n# Find spike frames (frame time or GC threshold)\nunicli exec Profiler.FindSpikes '{\"frameTimeThresholdMs\":16.6}' --json\nunicli exec Profiler.FindSpikes '{\"gcThresholdBytes\":1024,\"limit\":5}' --json\n```\n\n**NuGet package management (requires [NuGetForUnity](https://github.com/GlitchEnzo/NuGetForUnity)):**\n\n```bash\n# List installed NuGet packages\nunicli exec NuGet.List --json\n\n# Install a NuGet package\nunicli exec NuGet.Install '{\"id\":\"Newtonsoft.Json\"}' --json\nunicli exec NuGet.Install '{\"id\":\"Newtonsoft.Json\",\"version\":\"13.0.3\"}' --json\n\n# Uninstall a NuGet package\nunicli exec NuGet.Uninstall '{\"id\":\"Newtonsoft.Json\"}' --json\n\n# Restore all NuGet packages\nunicli exec NuGet.Restore --json\n```\n\n\n## Available Commands\n\nThe following commands are built in. You can also run `unicli commands` to see this list from the terminal.\n\n| Category           | Command                              | Description                        |\n|--------------------|--------------------------------------|------------------------------------|\n| BuildPlayer        | `BuildPlayer.Build`                  | Build the player                   |\n| BuildPlayer        | `BuildPlayer.Compile`                | Compile player scripts for a build target |\n| Core               | `Compile`                            | Compile scripts and return results |\n| Connection         | `Connection.List`                    | List available connection targets  |\n| Connection         | `Connection.Connect`                 | Connect to a target by ID, IP, or device ID |\n| Connection         | `Connection.Status`                  | Get current connection status      |\n| Console            | `Console.GetLog`                     | Get console log entries            |\n| Console            | `Console.Clear`                      | Clear console                      |\n| PlayMode           | `PlayMode.Enter`                     | Enter play mode                    |\n| PlayMode           | `PlayMode.Exit`                      | Exit play mode                     |\n| PlayMode           | `PlayMode.Pause`                     | Toggle pause                       |\n| Menu               | `Menu.List`                          | List menu items                    |\n| Menu               | `Menu.Execute`                       | Execute a menu item                |\n| TestRunner         | `TestRunner.RunEditMode`             | Run EditMode tests                 |\n| TestRunner         | `TestRunner.RunPlayMode`             | Run PlayMode tests                 |\n| GameObject         | `GameObject.Find`                    | Find GameObjects                   |\n| GameObject         | `GameObject.Create`                  | Create a new GameObject            |\n| GameObject         | `GameObject.CreatePrimitive`         | Create a primitive GameObject      |\n| GameObject         | `GameObject.GetComponents`           | Get components                     |\n| GameObject         | `GameObject.SetActive`               | Set active state                   |\n| GameObject         | `GameObject.GetHierarchy`            | Get scene hierarchy                |\n| GameObject         | `GameObject.AddComponent`            | Add a component                    |\n| GameObject         | `GameObject.RemoveComponent`         | Remove a component                 |\n| GameObject         | `GameObject.Destroy`                 | Destroy a GameObject               |\n| GameObject         | `GameObject.SetTransform`            | Set local transform                |\n| GameObject         | `GameObject.Duplicate`               | Duplicate a GameObject             |\n| GameObject         | `GameObject.Rename`                  | Rename a GameObject                |\n| GameObject         | `GameObject.SetParent`               | Change parent or move to root      |\n| Component          | `Component.SetProperty`              | Set a component property (supports ObjectReference via `guid:`, `instanceId:`, asset path) |\n| Material           | `Material.Create`                    | Create a new material asset        |\n| AnimatorController | `AnimatorController.Create`          | Create a new .controller asset     |\n| AnimatorController | `AnimatorController.Inspect`         | Inspect layers, parameters, states |\n| AnimatorController | `AnimatorController.AddParameter`    | Add a parameter                    |\n| AnimatorController | `AnimatorController.RemoveParameter` | Remove a parameter                 |\n| AnimatorController | `AnimatorController.AddState`        | Add a state to a layer             |\n| AnimatorController | `AnimatorController.AddTransition`   | Add a transition between states    |\n| AnimatorController | `AnimatorController.AddTransitionCondition` | Add a condition to a transition |\n| Animator           | `Animator.Inspect`                   | Inspect Animator component         |\n| Animator           | `Animator.SetController`             | Assign an AnimatorController       |\n| Animator           | `Animator.SetParameter`              | Set a parameter value (PlayMode)   |\n| Animator           | `Animator.Play`                      | Play a state immediately (PlayMode)|\n| Animator           | `Animator.CrossFade`                 | Cross-fade to a state (PlayMode)   |\n| Prefab             | `Prefab.GetStatus`                   | Get prefab instance status         |\n| Prefab             | `Prefab.Instantiate`                 | Instantiate a prefab into scene    |\n| Prefab             | `Prefab.Save`                        | Save GameObject as prefab          |\n| Prefab             | `Prefab.Apply`                       | Apply prefab overrides             |\n| Prefab             | `Prefab.Unpack`                      | Unpack a prefab instance           |\n| AssetDatabase      | `AssetDatabase.Find`                 | Search assets                      |\n| AssetDatabase      | `AssetDatabase.Import`               | Import an asset                    |\n| AssetDatabase      | `AssetDatabase.GetPath`              | Get asset path by GUID             |\n| AssetDatabase      | `AssetDatabase.Delete`               | Delete an asset                    |\n| Project            | `Project.Inspect`                    | Get project info                   |\n| PackageManager     | `PackageManager.List`                | List packages                      |\n| PackageManager     | `PackageManager.Add`                 | Add a package                      |\n| PackageManager     | `PackageManager.Remove`              | Remove a package                   |\n| PackageManager     | `PackageManager.Search`              | Search registry                    |\n| PackageManager     | `PackageManager.GetInfo`             | Get package details                |\n| PackageManager     | `PackageManager.Update`              | Update a package                   |\n| AssemblyDefinition | `AssemblyDefinition.List`            | List assembly definitions          |\n| AssemblyDefinition | `AssemblyDefinition.Get`             | Get assembly definition            |\n| AssemblyDefinition | `AssemblyDefinition.Create`          | Create assembly definition         |\n| AssemblyDefinition | `AssemblyDefinition.AddReference`    | Add asmdef reference               |\n| AssemblyDefinition | `AssemblyDefinition.RemoveReference` | Remove asmdef reference            |\n| Scene              | `Scene.List`                         | List all loaded scenes             |\n| Scene              | `Scene.GetActive`                    | Get the active scene               |\n| Scene              | `Scene.SetActive`                    | Set the active scene               |\n| Scene              | `Scene.Open`                         | Open a scene by asset path         |\n| Scene              | `Scene.Close`                        | Close a loaded scene               |\n| Scene              | `Scene.Save`                         | Save a scene or all open scenes    |\n| Scene              | `Scene.New`                          | Create a new scene                 |\n| Utility            | `TypeCache.List`                     | List types derived from a base type |\n| Utility            | `TypeInspect`                        | Inspect nested types of a given type |\n| Eval               | `Eval`                               | Compile and execute C# code dynamically |\n| NuGet (optional)   | `NuGet.List`                         | List all installed NuGet packages  |\n| NuGet (optional)   | `NuGet.Install`                      | Install a NuGet package            |\n| NuGet (optional)   | `NuGet.Uninstall`                    | Uninstall a NuGet package          |\n| NuGet (optional)   | `NuGet.Restore`                      | Restore all NuGet packages         |\n| Profiler           | `Profiler.Inspect`                   | Get profiler status and memory statistics |\n| Profiler           | `Profiler.StartRecording`            | Start profiler recording           |\n| Profiler           | `Profiler.StopRecording`             | Stop profiler recording            |\n| Profiler           | `Profiler.SaveProfile`               | Save profiler data to a .raw file  |\n| Profiler           | `Profiler.LoadProfile`               | Load profiler data from a .raw file |\n| Profiler           | `Profiler.GetFrameData`              | Get CPU profiler sample data for a specific frame |\n| Profiler           | `Profiler.TakeSnapshot`              | Take a memory snapshot (.snap file) |\n| Profiler           | `Profiler.AnalyzeFrames`             | Analyze recorded frames and return aggregate statistics |\n| Profiler           | `Profiler.FindSpikes`                | Find frames exceeding frame time or GC allocation thresholds |\n\nUse `unicli exec <command> --help` to see parameters for any command.\n\n### Settings Commands (auto-generated)\n\nUniCli auto-generates commands via a Roslyn Source Generator at Unity compile time. Target types are declared with the `[GenerateCommands]` assembly attribute, so the available commands always match your exact Unity version.\n\n#### Static types (Settings)\n\nCommands for `PlayerSettings`, `EditorSettings`, and `EditorUserBuildSettings`:\n\n| Pattern | Example | Description |\n|---|---|---|\n| `<Settings>.Inspect` | `PlayerSettings.Inspect` | Get all property values at once |\n| `<Settings>.<property>` | `PlayerSettings.companyName` | Set a single property |\n| `<Settings>.<Nested>.<property>` | `PlayerSettings.Android.minSdkVersion` | Set a nested type property |\n| `<Settings>.<Method>` | `PlayerSettings.SetScriptingBackend` | Call a Set/Get method |\n\nEnum values are passed as strings (e.g., `\"IL2CPP\"`, `\"AndroidApiLevel28\"`). Invalid values return an error with the list of valid options.\n\n#### Instance types (asset-based)\n\nCommands for instance types like `Material` require a `guid` parameter to identify the target asset:\n\n| Pattern | Example | Description |\n|---|---|---|\n| `<Type>.Inspect` | `Material.Inspect` | Read all properties of an instance |\n| `<Type>.Set<Property>` | `Material.SetRenderQueue` | Set a property on the instance |\n| `<Type>.<Method>` | `Material.SetColor`, `Material.GetFloat` | Call a Set/Get method on the instance |\n\nInstance type commands automatically call `EditorUtility.SetDirty()` after mutations to ensure changes are saved.\n\nRun `unicli commands` to see the full list of available commands, including all generated commands.\n\n\n## Custom Commands\n\nYou can extend UniCli by adding custom commands in your Unity project. Commands are auto-discovered — no manual registration required.\n\n### Class-based commands\n\nInherit from `CommandHandler<TRequest, TResponse>` and define `[Serializable]` request/response types:\n\n```csharp\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing UniCli.Protocol;\nusing UniCli.Server.Editor.Handlers;\n\npublic sealed class GreetHandler : CommandHandler<GreetRequest, GreetResponse>\n{\n    public override string CommandName => \"MyApp.Greet\";\n    public override string Description => \"Returns a greeting message\";\n\n    protected override ValueTask<GreetResponse> ExecuteAsync(GreetRequest request, CancellationToken cancellationToken)\n    {\n        return new ValueTask<GreetResponse>(new GreetResponse\n        {\n            message = $\"Hello, {request.name}!\"\n        });\n    }\n}\n\n[Serializable]\npublic class GreetRequest\n{\n    public string name;\n}\n\n[Serializable]\npublic class GreetResponse\n{\n    public string message;\n}\n```\n\nOnce the handler is placed anywhere in your Unity project, it becomes immediately available:\n\n```bash\nunicli exec MyApp.Greet --name \"World\"\n```\n\nFor commands that require no input or produce no output, use `Unit` as the type parameter:\n\n```csharp\npublic sealed class PingHandler : CommandHandler<Unit, PingResponse>\n{\n    public override string CommandName => \"MyApp.Ping\";\n    public override string Description => \"Health check\";\n\n    protected override ValueTask<PingResponse> ExecuteAsync(Unit request, CancellationToken cancellationToken)\n    {\n        return new ValueTask<PingResponse>(new PingResponse { ok = true });\n    }\n}\n```\n\n### Text formatting\n\nOverride `TryWriteFormatted` to provide human-readable output (used when `--json` is not specified):\n\n```csharp\nprotected override bool TryWriteFormatted(GreetResponse response, bool success, IFormatWriter writer)\n{\n    writer.WriteLine(response.message);\n    return true;\n}\n```\n\n### Async handlers and cancellation\n\nAll command handlers receive a `CancellationToken` that is cancelled when the client disconnects (e.g., Ctrl+C). For long-running async operations, pass the token through to ensure prompt cancellation:\n\n```csharp\nusing System.Threading;\nusing System.Threading.Tasks;\nusing UniCli.Server.Editor;\nusing UniCli.Server.Editor.Handlers;\n\npublic sealed class LongRunningHandler : CommandHandler<MyRequest, MyResponse>\n{\n    public override string CommandName => \"MyApp.LongTask\";\n    public override string Description => \"A long-running async operation\";\n\n    protected override async ValueTask<MyResponse> ExecuteAsync(MyRequest request, CancellationToken cancellationToken)\n    {\n        var tcs = new TaskCompletionSource<string>();\n\n        // Start an async Unity operation\n        SomeAsyncUnityApi.Start(result => tcs.SetResult(result));\n\n        // Use WithCancellation to abort the wait if the client disconnects\n        var result = await tcs.Task.WithCancellation(cancellationToken);\n\n        return new MyResponse { value = result };\n    }\n}\n```\n\nThe `WithCancellation` extension method (on `Task` / `Task<T>`) races the task against the cancellation token. If the client disconnects, the await throws `OperationCanceledException` and the server immediately becomes available for the next command.\n\nFor synchronous handlers that complete instantly, the `cancellationToken` parameter can be ignored.\n\n### Error handling\n\nThrow `CommandFailedException` to report failures while still returning structured data:\n\n```csharp\nif (hasErrors)\n    throw new CommandFailedException(\"Validation failed\", response);\n```\n\n## Remote Commands\n\nUniCli can invoke debug commands on a running Development Build via Unity's `PlayerConnection`. This lets you inspect runtime state, query performance stats, and execute custom debug operations on a connected device — all from the terminal.\n\n**Communication path:** CLI → Unity Editor (Named Pipe) → Device (PlayerConnection)\n\n### Prerequisites\n\n1. **Define symbol** — Add `UNICLI_REMOTE` to your project's Scripting Define Symbols (Player Settings → Other Settings).\n   - The remote module's asmdef has two define constraints: `UNICLI_REMOTE || UNITY_EDITOR` and `DEVELOPMENT_BUILD || UNITY_EDITOR`.\n   - In the Editor, both constraints are satisfied automatically — no additional setup needed for development.\n   - In player builds, `UNICLI_REMOTE` must be defined **and** the build must be a Development Build for the module to be included.\n   - This means release builds and builds without `UNICLI_REMOTE` will never contain the remote module code.\n2. **Development Build** — Build with the \"Development Build\" and \"Autoconnect Profiler\" options enabled to allow PlayerConnection communication.\n3. **Connect** — Use `Connection.Connect` to connect the Editor to the running player before sending remote commands.\n\n### Editor-side commands\n\n| Command | Description |\n|---|---|\n| `Remote.List` | List all debug commands registered on the connected player |\n| `Remote.Invoke` | Invoke a debug command on the connected player |\n\n```bash\n# List debug commands on connected runtime player\nunicli exec Remote.List\n\n# Invoke a debug command\nunicli exec Remote.Invoke '{\"command\":\"Debug.Stats\"}'\n\n# Invoke with parameters\nunicli exec Remote.Invoke '{\"command\":\"Debug.GetPlayerPref\",\"data\":\"{\\\"key\\\":\\\"HighScore\\\",\\\"type\\\":\\\"int\\\"}\"}'\n\n# Specify a particular player (when multiple are connected)\nunicli exec Remote.Invoke '{\"command\":\"Debug.SystemInfo\",\"playerId\":1}'\n```\n\n### Built-in debug commands\n\nThe following debug commands are included in the package and available on any Development Build with `UNICLI_REMOTE` defined:\n\n| Command | Description |\n|---|---|\n| `Debug.SystemInfo` | Device model, OS, CPU, GPU, memory, battery, screen, quality settings |\n| `Debug.Stats` | FPS, frame time, memory usage, GC collection counts, scene/object counts |\n| `Debug.GetLogs` | Recent log entries from a ring buffer (supports limit and type filter) |\n| `Debug.GetHierarchy` | Active scene hierarchy tree with depth, active state, component names |\n| `Debug.FindGameObjects` | Substring search across all GameObjects (including inactive) |\n| `Debug.GetScenes` | All loaded scenes with name, path, build index, root count |\n| `Debug.GetPlayerPref` | Read a PlayerPrefs value by key (string, int, or float) |\n\n### Creating custom debug commands\n\nInherit from `DebugCommand<TRequest, TResponse>` and annotate with `[DebugCommand]`. Commands are auto-discovered at runtime via reflection.\n\n```csharp\nusing System;\nusing UniCli.Remote;\nusing UnityEngine;\n\n[DebugCommand(\"Debug.ToggleHitboxes\", \"Toggle hitbox visualization\")]\npublic sealed class ToggleHitboxesCommand : DebugCommand<ToggleHitboxesCommand.Request, ToggleHitboxesCommand.Response>\n{\n    protected override Response ExecuteCommand(Request request)\n    {\n        HitboxVisualizer.Enabled = request.enabled;\n        return new Response { enabled = HitboxVisualizer.Enabled };\n    }\n\n    [Serializable]\n    public class Request\n    {\n        public bool enabled;\n    }\n\n    [Serializable]\n    public class Response\n    {\n        public bool enabled;\n    }\n}\n```\n\nUse `Unit` as the type parameter when no input or output is needed:\n\n```csharp\n[DebugCommand(\"Debug.ResetState\", \"Reset game state\")]\npublic sealed class ResetStateCommand : DebugCommand<Unit, Unit>\n{\n    protected override Unit ExecuteCommand(Unit request)\n    {\n        GameManager.ResetAll();\n        return Unit.Value;\n    }\n}\n```\n\nKey points:\n\n- Request/Response types must be `[Serializable]` with **public fields** (required by `JsonUtility`)\n- The base class uses `[RequireDerived]` to protect all subclasses from Managed Stripping automatically\n- Commands run synchronously on the main thread\n- The `[DebugCommand]` attribute takes a name (by convention `Debug.*`) and an optional description\n- Place custom commands anywhere in your project — they are discovered automatically via reflection at startup\n\n\n## Claude Code Integration\n\nUniCli provides a [Claude Code](https://docs.anthropic.com/en/docs/claude-code) plugin via the marketplace. This plugin gives Claude Code the ability to interact with Unity Editor — compiling scripts, running tests, inspecting GameObjects, managing packages, and more — as part of its coding workflow.\n\nWith the plugin installed, Claude Code can:\n\n- **Compile & verify** — catch compilation errors immediately after code changes\n- **Run tests** — execute EditMode / PlayMode tests and read results\n- **Inspect the scene** — find GameObjects, check components, and navigate the hierarchy\n- **Manage packages** — add, remove, and search Unity packages\n- **Discover commands** — automatically find all available commands, including project-specific custom commands\n\nThe plugin also handles server package setup: if the `com.yucchiy.unicli-server` package is not yet installed in the Unity project, Claude Code will run `unicli install` to set it up automatically.\n\n### Install the plugin\n\nThe UniCli CLI must be installed beforehand. See [Installation — CLI](#cli) above.\n\n```bash\n# 1. Add the UniCli marketplace\n/plugin marketplace add yucchiy/UniCli\n\n# 2. Install the plugin\n/plugin install unicli@unicli\n```\n\n## License\n\n[MIT](./LICENSE)\n"
      },
      "plugins": [
        {
          "name": "unicli",
          "source": "./.claude-plugin/unicli",
          "description": "Control Unity Editor from Claude Code using UniCli CLI",
          "version": "0.11.1",
          "author": {
            "name": "Yuichiro Mukai"
          },
          "homepage": "https://github.com/yucchiy/UniCli",
          "repository": "https://github.com/yucchiy/UniCli",
          "license": "MIT",
          "strict": false,
          "categories": [],
          "install_commands": [
            "/plugin marketplace add yucchiy/UniCli",
            "/plugin install unicli@unicli"
          ]
        }
      ]
    }
  ]
}