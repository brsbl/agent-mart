{
  "author": {
    "id": "yerry262",
    "display_name": "Yerry",
    "avatar_url": "https://avatars.githubusercontent.com/u/46946504?u=b9b575ad5d0df984571bcbaba30a6dea6b178dce&v=4"
  },
  "marketplaces": [
    {
      "name": "arm-reference",
      "version": null,
      "description": "ARM architecture reference -- 23 tools covering registers, instructions, calling conventions, exception levels, security models, page tables, memory attributes, extensions, assembly patterns, barriers, core/IP reference, NEON intrinsics, SME tiles, optimization, system registers, PMU events, and x86-to-ARM translation for AArch32 and AArch64.",
      "repo_full_name": "yerry262/arm-reference-mcp",
      "repo_url": "https://github.com/yerry262/arm-reference-mcp",
      "repo_description": "ARM register reference MCP server for AArch32/AArch64 architectures",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-21T08:51:59Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"arm-reference\",\n  \"owner\": {\n    \"name\": \"yerry262\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"arm-reference-mcp\",\n      \"description\": \"ARM architecture reference -- 23 tools covering registers, instructions, calling conventions, exception levels, security models, page tables, memory attributes, extensions, assembly patterns, barriers, core/IP reference, NEON intrinsics, SME tiles, optimization, system registers, PMU events, and x86-to-ARM translation for AArch32 and AArch64.\",\n      \"source\": \"./\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"arm-reference-mcp\",\n  \"description\": \"ARM architecture reference -- 23 tools covering registers, instructions, calling conventions, exception levels, security models, page tables, memory attributes, extensions, assembly patterns, barriers, core/IP reference, NEON intrinsics, SME tiles, optimization, system registers, PMU events, and x86-to-ARM translation for AArch32 and AArch64.\",\n  \"version\": \"0.2.0\"\n}\n",
        "README.md": "# ARM Register Reference MCP\n\nA [Model Context Protocol](https://modelcontextprotocol.io/) (MCP) server that gives AI assistants instant access to ARM architecture reference data. It covers **AArch32** (ARMv7) and **AArch64** (ARMv8/v9) with 23 tools spanning registers, instruction decoding, condition codes, calling conventions, exception levels, security models, page tables, memory attributes, architecture extensions, assembly patterns, memory barriers, core/IP reference, NEON/ASIMD intrinsics, SME tile operations, optimization suggestions, system registers, PMU events, and x86-to-ARM intrinsic translation -- all without leaving your editor or CLI.\n\nBuilt in Python. Works with any MCP-compatible client over stdio transport.\n\n---\n\n## Tools\n\nThe server exposes **23 tools** organized into six categories:\n\n### Register tools\n\n| Tool | Description | Example Input |\n|------|-------------|---------------|\n| `lookup_register` | Detailed info on a specific register by name or alias | `lookup_register(\"CPSR\")`, `lookup_register(\"X0\", architecture=\"aarch64\")` |\n| `list_registers` | Browse registers by architecture and optional category | `list_registers(\"aarch64\", category=\"system\")` |\n| `search_registers` | Keyword search across all register data | `search_registers(\"cache\")`, `search_registers(\"stack\", architecture=\"aarch32\")` |\n| `decode_register_value` | Decode a hex value against a register's named bit fields | `decode_register_value(\"CPSR\", \"0x600001D3\")` |\n\n### Instruction & convention tools\n\n| Tool | Description | Example Input |\n|------|-------------|---------------|\n| `decode_instruction` | Decode a 32-bit AArch32 instruction from hex encoding | `decode_instruction(\"0xE3A01005\")` |\n| `explain_condition_code` | Explain an ARM condition code suffix (EQ, NE, GT, etc.) | `explain_condition_code(\"GE\")` |\n| `explain_calling_convention` | Full AAPCS32/AAPCS64 calling convention reference | `explain_calling_convention(\"aarch64\")` |\n\n### System architecture tools\n\n| Tool | Description | Example Input |\n|------|-------------|---------------|\n| `explain_exception_levels` | EL0-EL3 exception levels (AArch64) or processor modes (AArch32) | `explain_exception_levels(\"aarch64\")` |\n| `explain_security_model` | TrustZone, RME, Arm CCA security model reference | `explain_security_model(\"aarch64\")` |\n| `explain_page_table_format` | AArch64 page table translation for a given granule/VA size | `explain_page_table_format(\"4KB\", va_bits=48)` |\n| `explain_memory_attributes` | Memory attributes: cacheability, shareability, permissions | `explain_memory_attributes(\"device\")` |\n\n### Architecture & extensions tools\n\n| Tool | Description | Example Input |\n|------|-------------|---------------|\n| `explain_extension` | Detailed reference for an ARM architecture extension | `explain_extension(\"SVE\")`, `explain_extension(\"MTE\")` |\n| `compare_architecture_versions` | Features for an ARMv8/v9 version, or compare two versions | `compare_architecture_versions(\"armv9.0\", compare_to=\"armv8.0\")` |\n\n### Core/IP & programming tools\n\n| Tool | Description | Example Input |\n|------|-------------|---------------|\n| `lookup_core` | ARM core/IP reference card (Cortex-A/R/M/X, Neoverse) | `lookup_core(\"Cortex-A78\")`, `lookup_core(\"N2\")` |\n| `compare_cores` | Side-by-side comparison of two ARM cores | `compare_cores(\"Cortex-A78\", \"Cortex-X4\")` |\n| `show_assembly_pattern` | Annotated assembly for common ARM patterns | `show_assembly_pattern(\"spinlock_acquire\", architecture=\"aarch64\")` |\n| `explain_barrier` | Memory barrier and synchronization instruction reference | `explain_barrier(\"DMB\")`, `explain_barrier(\"LDAR\")` |\n\n### SIMD, optimization & porting tools\n\n| Tool | Description | Example Input |\n|------|-------------|---------------|\n| `explain_neon_intrinsic` | NEON/ASIMD intrinsic reference with instruction, types, latency, and usage example | `explain_neon_intrinsic(\"vfmaq_f32\")`, `explain_neon_intrinsic(\"vld1q_f32\")` |\n| `explain_sme_tile` | SME tile operations, ZA storage, streaming SVE mode, outer products | `explain_sme_tile(\"outer_product\")`, `explain_sme_tile(\"za_storage\")` |\n| `suggest_optimization` | ARM-specific optimization suggestions for code patterns | `suggest_optimization(\"matrix_multiply\", target_core=\"cortex-a78\")` |\n| `lookup_system_register` | Full AArch64 system register reference (beyond the basic set) | `lookup_system_register(\"TCR_EL1\")`, `lookup_system_register(\"list\", el=\"EL1\")` |\n| `explain_performance_counter` | ARM PMU performance counter event reference | `explain_performance_counter(\"L1D_CACHE_REFILL\")`, `explain_performance_counter(\"topdown\")` |\n| `translate_intrinsic` | Translate between x86 SSE/AVX and ARM NEON/SVE intrinsics | `translate_intrinsic(\"_mm_add_ps\", \"x86\", \"neon\")` |\n\n### Tool details\n\n**`lookup_register(name, architecture?)`** -- Returns the register's bit width, architecture, category, description, bit field layout (if any), and usage notes. Supports aliases (e.g., `FP`, `LR`, `IP0`, `WZR`). If `architecture` is omitted, matches from both AArch32 and AArch64 are returned.\n\n**`list_registers(architecture, category?)`** -- Lists all registers for a given architecture in a table format. Categories: `general_purpose`, `status`, `system`, `floating_point`. Omit `category` to list everything.\n\n**`search_registers(query, architecture?)`** -- Case-insensitive keyword search across register names, aliases, descriptions, and usage notes. Returns matching registers with context snippets showing where the keyword was found.\n\n**`decode_register_value(register_name, hex_value, architecture?)`** -- Takes a hex value and a register name (e.g., `CPSR`, `SCTLR_EL1`, `FPSCR`, `DAIF`), then extracts each named bit field from the value and displays its decoded contents. Useful for interpreting raw register dumps from debuggers.\n\n**`decode_instruction(hex_value)`** -- Parses a 32-bit AArch32 instruction encoding and breaks it into fields: condition code, instruction type (data processing, branch, load/store, etc.), opcode, registers, immediates, and shift operands. Accepts hex strings with or without `0x` prefix.\n\n**`explain_condition_code(suffix)`** -- Given a condition code mnemonic like `EQ`, `NE`, `CS`, `HI`, `GT`, or `AL`, returns the full name, which NZCV flags are tested, the flag condition expression, the opposite condition, and a usage example.\n\n**`explain_calling_convention(architecture)`** -- Returns a comprehensive AAPCS reference for `aarch32` or `aarch64`, covering argument registers, return value registers, caller-saved vs callee-saved registers, stack alignment requirements, frame pointer convention, and special notes (e.g., PAC, platform register, HFA rules).\n\n**`explain_exception_levels(architecture?)`** -- Describes EL0-EL3 exception levels for AArch64 (with registers, typical software, and transition mechanisms at each level) or the seven processor modes for AArch32 (User, FIQ, IRQ, Supervisor, Abort, Undefined, System). Defaults to AArch64.\n\n**`explain_security_model(architecture)`** -- Reference for ARM's security architecture: TrustZone (Secure/Non-secure worlds), RME (Realm Management Extension, four worlds), and Arm CCA (Confidential Compute Architecture). Includes hardware enforcement, transition mechanisms, and memory partitioning.\n\n**`explain_page_table_format(granule_size, va_bits?)`** -- Shows the AArch64 page table translation scheme for a given granule (4KB, 16KB, or 64KB) and VA width (39, 48, or 52 bits). Includes level structure, VA bit layout diagram, PTE field layouts, OA ranges, and TCR_EL1 configuration fields.\n\n**`explain_memory_attributes(topic?)`** -- Detailed reference on ARM memory attributes. Topics: `\"cacheability\"`, `\"shareability\"`, `\"device\"`, `\"permissions\"`, `\"mair\"`, `\"stage2\"`. Omit for an overview of all concepts.\n\n**`explain_extension(extension_name)`** -- Returns the full name, introducing architecture version, purpose, key registers and instructions, detection method, and practical use cases for 17 ARM extensions including SVE, MTE, PAC, BTI, TME, RME, SME, GCS, FEAT_THE, FEAT_NV2, DIT, MPAM, RAS, SPE, AMU, and BRBE.\n\n**`compare_architecture_versions(version, compare_to?)`** -- Lists mandatory and optional features for an architecture version (ARMv8.0-A through ARMv9.5-A). If `compare_to` is provided, shows a side-by-side diff of all features added between the two versions.\n\n**`lookup_core(core_name)`** -- Returns a detailed reference card for an ARM core/IP: architecture version, pipeline details, decode width, key features, target market, and notable SoCs. Covers Cortex-A, Cortex-X, Cortex-R, Cortex-M, and Neoverse series. Accepts short forms like \"A78\", \"X4\", \"M55\", \"N2\".\n\n**`compare_cores(core_a, core_b)`** -- Shows a side-by-side comparison table of two ARM cores covering architecture, pipeline, decode width, features, market, and generation.\n\n**`show_assembly_pattern(pattern_name, architecture?)`** -- Returns annotated assembly code for 12 common ARM patterns: function_prologue, function_epilogue, atomic_add, atomic_cas, spinlock_acquire, spinlock_release, context_switch, syscall, tlb_invalidate, cache_clean, enable_mmu, exception_vector. Available for both AArch32 and AArch64.\n\n**`explain_barrier(barrier_type)`** -- Explains an ARM barrier or synchronization instruction: DMB, DSB, ISB, LDAR, STLR, LDAPR, CAS/CASA/CASAL, SB, CSDB, SSBB/PSSBB. Covers ordering semantics, domain options, acquire/release patterns, and Spectre mitigation barriers. Pass `\"overview\"` for a summary of all barrier types.\n\n**`explain_neon_intrinsic(intrinsic_name)`** -- Looks up an ARM NEON/Advanced SIMD intrinsic by name (e.g., `vfmaq_f32`, `vaddq_f32`, `vld1q_f32`). Returns the C signature, equivalent AArch64 instruction, data types, category, architecture compatibility, estimated latency and throughput, and a usage example. Pass `\"list\"` to see all 40+ available intrinsics grouped by category. Critical for AI/ML inference kernel development.\n\n**`explain_sme_tile(operation)`** -- Reference for ARM's Scalable Matrix Extension (SME). Topics include `overview`, `za_storage` (ZA tile register), `outer_product` (FMOPA/FMOPS), `streaming_mode` (SMSTART/SMSTOP), `sme2` (SME2 enhancements), `programming_model`, `tile_load_store`, `mopa_fmopa`, `data_types`, and `compatibility`. Each topic covers architecture concepts, key instructions, code examples, and practical guidance.\n\n**`suggest_optimization(code_pattern, target_core?)`** -- Given a code pattern (e.g., `\"matrix_multiply\"`, `\"memcpy\"`, `\"dot_product\"`, `\"sort\"`, `\"hash\"`), suggests ARM-specific optimizations: NEON vectorization, SVE scalable loops, cache-friendly tiling, LSE atomics, and more. Optionally accepts a target core for core-specific recommendations. Pass `\"list\"` for all patterns.\n\n**`lookup_system_register(register, el?)`** -- Expanded AArch64 system register reference covering the full register space. Look up individual registers (e.g., `TCR_EL1`, `HCR_EL2`, `MAIR_EL1`) or browse by category with special queries: `\"list\"` (all registers), `\"memory\"` (MMU/translation), `\"timer\"` (generic timer), `\"id\"` (identification), `\"perf\"` (performance monitoring). Optional `el` filter restricts to a specific exception level.\n\n**`explain_performance_counter(event_name)`** -- ARM PMU event reference. Look up performance monitoring events by name (e.g., `L1D_CACHE_REFILL`, `CPU_CYCLES`, `STALL_FRONTEND`) or by hex event number (e.g., `0x03`). Returns what the event measures, when to use it, useful formulas, Linux perf command, AI/ML workload tips, and PMU register setup. Pass `\"topdown\"` for the ARM Top-Down methodology guide, `\"list\"` for all events, or a category name (e.g., `\"cache\"`) to filter.\n\n**`translate_intrinsic(intrinsic, from_arch, to_arch)`** -- Translates between x86 SSE/AVX intrinsics and ARM NEON/SVE equivalents. Supports both directions: x86-to-ARM (`_mm_add_ps` -> `vaddq_f32`) and ARM-to-x86 (`vaddq_f32` -> `_mm_add_ps`). Shows the instruction mapping, data types, porting tips, and gotchas (e.g., operand order differences for FMA). Covers SSE, SSE2, AVX, AVX2, and AVX-512 intrinsics. Pass `\"list\"` to see all available translations.\n\n---\n\n## Setup / Installation\n\n### Prerequisites\n\nYou need Python 3.10+ and either [uv](https://docs.astral.sh/uv/) (recommended) or pip installed.\n\nThis package is distributed via GitHub (not PyPI). All install methods below pull directly from the repository.\n\n---\n\n### a. Claude Code (CLI)\n\n**Route 1: Add as a standalone MCP server**\n\nUsing `uvx` to install directly from GitHub (no permanent install required):\n\n```bash\nclaude mcp add --transport stdio arm-reference -- uvx --from \"git+https://github.com/yerry262/arm-reference-mcp.git\" arm-reference-mcp\n```\n\nOr, install with pip first, then add the server:\n\n```bash\npip install \"git+https://github.com/yerry262/arm-reference-mcp.git\"\nclaude mcp add --transport stdio arm-reference -- arm-reference-mcp\n```\n\nOr, if you have cloned the repo locally and want to run from source:\n\n```bash\ngit clone https://github.com/yerry262/arm-reference-mcp.git\ncd arm-reference-mcp\npip install -e .\nclaude mcp add --transport stdio arm-reference -- python -m arm_reference_mcp.server\n```\n\nAfter adding, all 23 tools are immediately available in your Claude Code session. Ask Claude about ARM registers, instructions, calling conventions, exception levels, NEON intrinsics, SME tiles, optimization patterns, system registers, PMU events, x86-to-ARM porting, and more -- it will call the tools automatically.\n\n**Route 2: Add as a plugin via Claude Code marketplace**\n\nFirst, add this repository as a marketplace source:\n\n```\n/plugin marketplace add yerry262/arm-reference-mcp\n```\n\nThen install the plugin:\n\n```\n/plugin install arm-reference-mcp\n```\n\nThis auto-configures the MCP server for you based on the `.mcp.json` and `.claude-plugin/plugin.json` files in the repo. No manual server configuration needed.\n\n---\n\n### b. VS Code (GitHub Copilot / Continue.dev)\n\nRecent versions of VS Code support MCP servers natively through GitHub Copilot Chat. You can also use them with the [Continue.dev](https://continue.dev/) extension.\n\nCreate or edit `.vscode/mcp.json` in your workspace root:\n\n```json\n{\n  \"mcpServers\": {\n    \"arm-reference\": {\n      \"type\": \"stdio\",\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/yerry262/arm-reference-mcp.git\", \"arm-reference-mcp\"]\n    }\n  }\n}\n```\n\nAlternatively, add it to your VS Code user settings JSON (`settings.json`):\n\n```json\n{\n  \"mcp\": {\n    \"servers\": {\n      \"arm-reference\": {\n        \"type\": \"stdio\",\n        \"command\": \"uvx\",\n        \"args\": [\"--from\", \"git+https://github.com/yerry262/arm-reference-mcp.git\", \"arm-reference-mcp\"]\n      }\n    }\n  }\n}\n```\n\nOnce configured, the tools appear in Copilot Chat or Continue.dev as available MCP tools.\n\n---\n\n### c. Cursor\n\nAdd to `.cursor/mcp.json` in your project root, or configure in Cursor's global MCP settings:\n\n```json\n{\n  \"mcpServers\": {\n    \"arm-reference\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/yerry262/arm-reference-mcp.git\", \"arm-reference-mcp\"]\n    }\n  }\n}\n```\n\nRestart Cursor after saving. The tools will be available in Cursor's AI chat.\n\n---\n\n### d. Windsurf\n\nAdd to `~/.codeium/windsurf/mcp_config.json`:\n\n```json\n{\n  \"mcpServers\": {\n    \"arm-reference\": {\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/yerry262/arm-reference-mcp.git\", \"arm-reference-mcp\"]\n    }\n  }\n}\n```\n\nRestart Windsurf to pick up the new server.\n\n---\n\n### e. OpenAI Codex CLI\n\nCodex CLI supports MCP servers via its configuration. Add the server to your Codex MCP config:\n\n```json\n{\n  \"mcpServers\": {\n    \"arm-reference\": {\n      \"type\": \"stdio\",\n      \"command\": \"uvx\",\n      \"args\": [\"--from\", \"git+https://github.com/yerry262/arm-reference-mcp.git\", \"arm-reference-mcp\"]\n    }\n  }\n}\n```\n\nRefer to the [Codex CLI documentation](https://github.com/openai/codex) for the exact config file location on your platform.\n\n---\n\n### f. Generic / Other MCP Clients\n\nAny MCP-compatible client can connect to this server over **stdio** transport. The command to launch the server is:\n\n```bash\nuvx --from \"git+https://github.com/yerry262/arm-reference-mcp.git\" arm-reference-mcp\n```\n\nOr, install with pip and run directly:\n\n```bash\npip install \"git+https://github.com/yerry262/arm-reference-mcp.git\"\narm-reference-mcp\n```\n\nOr, run from a cloned checkout:\n\n```bash\ngit clone https://github.com/yerry262/arm-reference-mcp.git\ncd arm-reference-mcp\npip install -e .\npython -m arm_reference_mcp.server\n```\n\nPoint your client at whichever command above works for your setup. The transport is stdio (stdin/stdout). No HTTP server, no port configuration.\n\n---\n\n## Local Development\n\nClone the repository and install in editable mode:\n\n```bash\ngit clone https://github.com/yerry262/arm-reference-mcp.git\ncd arm-reference-mcp\npip install -e .\n```\n\nRun the server directly:\n\n```bash\narm-reference-mcp\n```\n\nOr via the module entry point:\n\n```bash\npython -m arm_reference_mcp.server\n```\n\nTo add it to Claude Code for testing during development:\n\n```bash\nclaude mcp add --transport stdio arm-reference -- python -m arm_reference_mcp.server\n```\n\n### Project structure\n\n```\narm-reference-mcp/\n  src/\n    arm_reference_mcp/\n      __init__.py\n      server.py          # MCP server with all 23 tools and inline reference data\n      data.py            # Register definitions for AArch32 and AArch64\n  tests/\n    test_tools.py        # 128 test cases covering all 23 tools\n  .claude-plugin/\n    plugin.json          # Claude Code plugin metadata\n    marketplace.json     # Plugin marketplace manifest\n  .mcp.json              # Default MCP server config (used by plugins)\n  pyproject.toml         # Package metadata and build config\n  README.md\n```\n\n### Running tests\n\n```bash\n# With the built-in runner (no dependencies beyond the package itself)\npython tests/test_tools.py\n\n# Or with pytest\npython -m pytest tests/test_tools.py -v\n```\n\n### Dependencies\n\n- Python >= 3.10\n- `mcp[cli]` >= 1.0.0 (the Model Context Protocol SDK)\n\n---\n\n## Register Coverage\n\n### AArch32 (ARMv7)\n\n| Category | Registers |\n|----------|-----------|\n| General purpose | R0-R12, R13/SP, R14/LR, R15/PC |\n| Status | CPSR (with full bit field decode: N, Z, C, V, Q, J, E, A, I, F, T, M), SPSR |\n| Floating point | S0-S31, D0-D31, FPSCR (with bit field decode: N, Z, C, V, RMode, DN, FZ) |\n\n### AArch64 (ARMv8/v9)\n\n| Category | Registers |\n|----------|-----------|\n| General purpose | X0-X30 (with W0-W30 aliases), SP/WSP, PC, XZR/WZR |\n| Status | NZCV (with bit field decode), DAIF (D, A, I, F masks), CurrentEL |\n| Floating point | FPCR (DN, FZ, RMode), FPSR (N, Z, C, V, IDC, IXC, UFC, OFC, IOC) |\n| System | VBAR_EL1, TTBR0_EL1 (ASID, BADDR, CnP), SCTLR_EL1 (M, C, I, A, EE) |\n\nRegisters with defined bit fields support the `decode_register_value` tool for interpreting raw hex dumps.\n\n### Additional reference data\n\nBeyond registers, the server includes:\n\n- **AArch32 instruction decoding** -- data processing, branch, load/store, SWI, with full field breakdowns\n- **All 15 ARM condition codes** -- EQ, NE, CS/HS, CC/LO, MI, PL, VS, VC, HI, LS, GE, LT, GT, LE, AL\n- **AAPCS32 and AAPCS64 calling conventions** -- argument/return registers, caller/callee-saved sets, stack alignment, frame pointer, platform-specific notes, HFA/HVA rules, PAC\n- **Exception levels** -- EL0-EL3 with registers, typical software, and transition mechanisms (AArch64); seven processor modes (AArch32)\n- **Security models** -- TrustZone (Secure/Non-secure), RME (four worlds), Arm CCA\n- **Page table translation** -- 4KB/16KB/64KB granules, multi-level translation, VA layout diagrams, PTE fields, TCR_EL1 config\n- **Memory attributes** -- MAIR, cacheability policies, device types, shareability domains, access permissions, Stage 1/2 combination\n- **17 architecture extensions** -- SVE, MTE, PAC, BTI, TME, RME, SME, GCS, FEAT_THE, FEAT_NV2, DIT, MPAM, RAS, SPE, AMU, BRBE, with detection methods and use cases\n- **Architecture versions** -- ARMv8.0-A through ARMv9.5-A with mandatory/optional features and example cores\n- **ARM core/IP reference** -- Cortex-A/R/M/X and Neoverse series with pipeline details, features, and comparison\n- **12 assembly patterns** -- function prologues, atomics, spinlocks, context switches, syscalls, TLB/cache maintenance, MMU enable, exception vectors (both AArch32 and AArch64)\n- **10 memory barriers** -- DMB, DSB, ISB, LDAR, STLR, LDAPR, CAS variants, SB, CSDB, SSBB/PSSBB with domain options and Spectre mitigation\n- **40+ NEON/ASIMD intrinsics** -- arithmetic (vaddq, vmulq, vfmaq), loads/stores (vld1q, vst1q, vld2q), comparisons, conversions, shuffles, and dot-product intrinsics with latency/throughput data\n- **SME tile operations** -- 10 topics covering ZA storage, outer products (FMOPA/FMOPS), streaming SVE mode, SME2 enhancements, and programming model\n- **12 optimization patterns** -- matrix multiply, memcpy, dot product, sort, hash, string search, reduction, convolution with NEON/SVE/SME techniques and code snippets\n- **50+ system registers** -- TCR, MAIR, HCR, VBAR, CNTP, ID_AA64* and more, filterable by exception level and category\n- **25+ PMU events** -- cache, branch, pipeline, memory, and TLB events with formulas, AI workload tips, and Top-Down methodology guide\n- **30+ intrinsic translations** -- SSE, SSE2, AVX, AVX2, AVX-512 to NEON/SVE mappings with porting tips and gotchas\n\n---\n\n## Summary of Each Tool\n\n1. **`lookup_register`** (`X0`)\n\n   Returns register details: architecture (aarch64), size (64-bit), aliases (W0), category (general_purpose), description, and usage notes (caller-saved, W0 zero-extends into X0).\n\n2. **`list_registers`** (`aarch64`, `general_purpose`)\n\n   Lists all 34 general-purpose AArch64 registers (X0-X30, SP, PC, XZR) in a table with width, aliases, and description.\n\n3. **`decode_instruction`** (`0xE3A01005`)\n\n   Decodes an AArch32 instruction into fields: condition code (AL), instruction type (Data Processing), mnemonic (MOV), I bit, opcode, S flag, Rn, Rd (R1), and immediate operand (5). Result: `MOV R1, #5`.\n\n4. **`explain_condition_code`** (`EQ`)\n\n   Returns full name (Equal), encoding (0b0000), flags tested (Z), flag condition (Z==1), opposite (NE), and an example with CMP/BEQ.\n\n5. **`explain_calling_convention`** (`aarch64`)\n\n   Comprehensive AAPCS64 reference: argument registers (X0-X7), return value registers (X0-X1, V0-V3), caller/callee-saved registers, stack alignment (16 bytes), frame pointer (X29), and special notes on X8, X16/X17, X18, PAC.\n\n6. **`search_registers`** (`\"stack\"`)\n\n   Found 3 matches across both architectures: R13/SP (aarch32), X29/FP (aarch64), SP (aarch64).\n\n7. **`decode_register_value`** (`CPSR`, `0x600001D3`)\n\n   Decoded all bit fields: N=0, Z=1, C=1, V=0, Q=0, J=0, E=0 (little-endian), A=1 (abort masked), I=1 (IRQ masked), F=1 (FIQ masked), T=0 (ARM state), M=0x13 (SVC mode).\n\n8. **`explain_exception_levels`** (`aarch64`)\n\n   Detailed reference on EL0-EL3: what runs at each level, accessible registers, stack pointer selection, key registers (SPSR, ELR, VBAR, ESR, HCR, SCR), exception entry/return mechanism, vector table layout (16 entries with offsets), SPSel, and all four security states (NS, Secure, Realm, Root).\n\n9. **`explain_security_model`** (`aarch64`)\n\n   Covers TrustZone (SCR_EL3.NS bit, world-switching mechanism), Secure ELs (S-EL0/1/2), and ARMv9 RME (four-world model, GPT structure, GPC checks, CCA architecture with RMM).\n\n10. **`lookup_core`** (`Cortex-A78`)\n\n    Returns: ARMv8.2-A, Hercules generation, 13-stage OoO pipeline, 4-wide decode, key features (FP16, dot-product, L1/L2/L3 sizes), target market (mobile), notable SoCs (Snapdragon 888, Exynos 2100).\n\n11. **`compare_cores`** (`Cortex-A78` vs `Cortex-X4`)\n\n    Side-by-side comparison table: architecture (v8.2 vs v9.2), decode width (4 vs 6), generation, features, and SoCs. Highlights the generational leap.\n\n12. **`explain_page_table_format`** (`4KB`, 48-bit VA)\n\n    Full translation scheme: 4 levels (L0-L3), VA bit layout diagram, descriptor types at each level (block/table/page), PTE field layout (UXN, PXN, AF, SH, AP, AttrIndx), OA range table, and TCR_EL1 configuration (T0SZ, TG0/TG1, IPS).\n\n13. **`explain_memory_attributes`** (`cacheability`)\n\n    Covers WB/WT/NC policies with MAIR nibble encodings, inner vs outer cache domains, all four device memory types (nGnRnE through GRE) with G/R/E explanations, and cache maintenance operations (DC CIVAC, DC CVAC, IC IALLU, etc.).\n\n14. **`explain_extension`** (`SVE`)\n\n    Scalable Vector Extension: purpose (vector-length-agnostic SIMD), key registers (Z0-Z31, P0-P15, FFR, ZCR), key instructions (LD1/ST1, WHILELT, gather/scatter), detection method (ID_AA64PFR0_EL1), and use cases (HPC, ML, bioinformatics).\n\n15. **`compare_architecture_versions`** (`ARMv9.0`)\n\n    Lists mandatory features (SVE2, ETE, TRBE, RME), optional features (TME, MTE, BTI, SME), notable changes (first major version since ARMv8), and example cores (A710, X2, N2).\n\n16. **`show_assembly_pattern`** (`function_prologue`, `aarch64`)\n\n    Annotated assembly: STP X29/X30 with pre-index, MOV X29/SP, STP for callee-saved registers X19-X28, with comments on alignment, PAC, and frame records.\n\n17. **`explain_barrier`** (`DMB`)\n\n    Explains Data Memory Barrier: what it does (orders memory accesses), what it doesn't do (not DSB/ISB), when to use it (locks, producer-consumer, MMIO), and all 12 domain options (SY, ST, LD, ISH, ISHST, ISHLD, NSH, OSH, etc.).\n\n18. **`explain_neon_intrinsic`** (`vfmaq_f32`)\n\n    Returns the C signature (`float32x4_t vfmaq_f32(...)`), instruction (`FMLA Vd.4S`), category (Arithmetic), architecture (AArch64), latency (4 cycles), throughput (2/cycle), and a usage example showing dot-product accumulation.\n\n19. **`explain_sme_tile`** (`outer_product`)\n\n    Explains SME outer-product instructions: FMOPA computes the outer product of two SVE vectors and accumulates into a ZA tile. Shows all variants (FP32, BF16, INT8), dual-predicate masking, and a complete GEMM code example.\n\n20. **`suggest_optimization`** (`dot_product`, `cortex-a78`)\n\n    Suggests 3+ ARM-specific optimizations for dot product: NEON FMLA with 2-4x unrolling, UDOT/SDOT for INT8 quantized inference, and SVE predicated loops. Includes core-specific notes for Cortex-A78 (2x SIMD pipes, UDOT support).\n\n21. **`lookup_system_register`** (`TCR_EL1`)\n\n    Returns full name (Translation Control Register), exception level (EL1), access type, encoding, width, category, description, and key fields (T0SZ, T1SZ, TG0, TG1, IPS) with bit positions and descriptions.\n\n22. **`explain_performance_counter`** (`L1D_CACHE_REFILL`)\n\n    Returns event number (0x03), category (Cache), what it measures, when to use it, useful formulas (L1D miss rate, MPKI), Linux perf command, AI/ML workload tips, and bare-metal PMU register setup.\n\n23. **`translate_intrinsic`** (`_mm256_fmadd_ps`, `x86`, `neon`)\n\n    Maps AVX2 FMA to ARM: NEON equivalent (`2x vfmaq_f32`), SVE equivalent (`svmla_f32_x`), data type (8x float32), porting notes, and critical gotcha (operand order reversal between x86 FMA and NEON FMA).\n\n---\n\n## Example Usage\n\nOnce the MCP server is connected, you can ask your AI assistant natural-language questions about ARM and it will call the tools automatically. Below is one example per tool showing the prompt you'd type and the actual response the tool returns.\n\n---\n\n### 1. lookup_register\n\n**Prompt:** \"Tell me about the X0 register\"\n\n**Response** (via `lookup_register(\"X0\")`):\n\n```\n## X0 (aliases: W0)\nArchitecture: aarch64  |  64-bit  |  Category: general_purpose\n\nGeneral-purpose register. First argument and return value in AAPCS64.\n\nUsage: Caller-saved. W0 is the lower 32 bits. Writing W0 zero-extends into X0.\n```\n\n---\n\n### 2. list_registers\n\n**Prompt:** \"List all AArch64 system registers\"\n\n**Response** (via `list_registers(\"aarch64\", \"system\")`):\n\n```\n# aarch64 Registers — system\n\nName         Width  Aliases          Description\n------------------------------------------------------------------------\nVBAR_EL1      64-bit  —                Vector Base Address Register (EL1). Holds the base addres...\nTTBR0_EL1     64-bit  —                Translation Table Base Register 0 (EL1). Holds the base a...\nSCTLR_EL1     64-bit  —                System Control Register (EL1). Controls MMU enable, cache...\n```\n\n---\n\n### 3. search_registers\n\n**Prompt:** \"Which registers are related to the stack?\"\n\n**Response** (via `search_registers(\"stack\")`):\n\n```\n# Search results for 'stack' across all architectures\n3 register(s) matched.\nR13 (SP)  [aarch32  |  32-bit  |  general_purpose]\n  Matched in description: \"Stack Pointer. Points to the top of the curre...\"\n\nX29 (W29, FP)  [aarch64  |  64-bit  |  general_purpose]\n  Matched in description: \"...nter. Points to the base of the current stack frame.\"\n\nSP (WSP)  [aarch64  |  64-bit  |  general_purpose]\n  Matched in description: \"Stack Pointer. Points to the top of the curre...\"\n```\n\n---\n\n### 4. decode_register_value\n\n**Prompt:** \"My debugger shows CPSR = 0x600001D3. What does that mean?\"\n\n**Response** (via `decode_register_value(\"CPSR\", \"0x600001D3\")`):\n\n```\n# CPSR  [aarch32  |  32-bit]\nRaw value : 0x600001D3\nBinary    : 0110 0000 0000 0000 0000 0001 1101 0011\n\n### Bit Field Decode\n  Field         Bits     Hex    Dec  Bin           Description\n  --------------------------------------------------------------------------------\n  N          [   31]  0x00      0  0             Negative flag\n  Z          [   30]  0x01      1  1             Zero flag\n  C          [   29]  0x01      1  1             Carry flag\n  V          [   28]  0x00      0  0             Overflow flag\n  Q          [   27]  0x00      0  0             Sticky overflow (saturating arithmetic)\n  J          [   24]  0x00      0  0             Jazelle state bit\n  E          [    9]  0x00      0  0             Endianness (0=little, 1=big)\n  A          [    8]  0x01      1  1             Asynchronous abort mask\n  I          [    7]  0x01      1  1             IRQ mask\n  F          [    6]  0x01      1  1             FIQ mask\n  T          [    5]  0x00      0  0             Thumb state bit (0=ARM, 1=Thumb)\n  M          [  4:0]  0x13     19  10011         Processor mode (e.g. 0x10=User, 0x13=SVC, ...)\n```\n\n---\n\n### 5. decode_instruction\n\n**Prompt:** \"What does the instruction 0xE3A01005 do?\"\n\n**Response** (via `decode_instruction(\"0xE3A01005\")`):\n\n```\n# ARM AArch32 Instruction Decode: 0xE3A01005\nBinary: 11100011101000000001000000000101\n\n### Condition Code\n  [31:28]  0xE (14)  →  Condition = AL (Always (unconditional))\n\nInstruction type: Data Processing (bits [27:26] = 00)\nMnemonic: MOV\n\n### Field Breakdown\n  [   25]  0x1 (1)  →  I (Immediate) = 1 (Immediate operand2)\n  [24:21]  0xD (13)  →  Opcode = MOV\n  [   20]  0x0 (0)  →  S (Set flags) = 0 (No)\n  [19:16]  0x0 (0)  →  Rn (first operand register) = R0\n  [15:12]  0x1 (1)  →  Rd (destination register) = R1\n  [ 11:0]  0x5 (5)  →  Operand2 (immediate): rotate=0, imm8=0x05 -> value = 5\n```\n\n---\n\n### 6. explain_condition_code\n\n**Prompt:** \"What does the EQ condition code mean?\"\n\n**Response** (via `explain_condition_code(\"EQ\")`):\n\n```\n# Condition Code: EQ  (0x0 / 0000)\n\nFull name: Equal\nEncoding: bits [31:28] = 0b0000 (0x0)\nFlags tested: Z\nFlag condition: Z == 1\nOpposite condition: NE\nCommon use case: Check if two values are equal (after CMP) or if a result is zero.\n\n### Example\n  CMP R0, R1         ; Compare R0 and R1, updating CPSR flags\n  BEQ label        ; Branch to 'label' if Z == 1\n```\n\n---\n\n### 7. explain_calling_convention\n\n**Prompt:** \"What's the AArch64 calling convention?\"\n\n**Response** (via `explain_calling_convention(\"aarch64\")`):\n\n```\n# Calling Convention: AARCH64\n## AAPCS64 (ARM Architecture Procedure Call Standard for AArch64)\nSpecification: IHI0055\n\n## Argument Registers\nRegisters (8):  X0, X1, X2, X3, X4, X5, X6, X7\nNotes: Integer/pointer arguments in X0-X7. 32-bit values use W-form (W0-W7).\n       Arguments beyond X7 are passed on the stack, 8-byte aligned.\n       FP/SIMD arguments use V0-V7.\n\n## Return Value Registers\nInteger/pointer:    X0, X1\nFloating-point:     V0, V1, V2, V3\n\n## Caller-Saved (Volatile)\nInteger:         X0-X17, X18 (platform-dependent)\nFloating-point:  V0-V7 (argument/result), V16-V31 (scratch)\n\n## Callee-Saved (Non-Volatile)\nInteger:         X19-X28, X29 (FP), X30 (LR) when saved\nFloating-point:  V8-V15 (low 64 bits only — D8-D15)\n\n## Stack Alignment\nAt call boundary:  16 bytes\nInternal:          16 bytes (SP must always be 16-byte aligned)\n\n## Frame Pointer\nRegister: X29 (FP)\nNotes: Frame record: STP X29, X30, [SP, #-16]! at entry.\n\n## Special Notes\n  1. X8: Indirect result register — caller passes struct return address here.\n  2. X16/IP0, X17/IP1: Linker veneer scratch.\n  3. X18: Platform register — avoid in portable code.\n  4. PAC (ARMv8.3+): Return addresses may be signed with PACIASP.\n```\n\n---\n\n### 8. explain_exception_levels\n\n**Prompt:** \"Explain AArch64 exception levels\"\n\n**Response** (via `explain_exception_levels(\"aarch64\")`):\n\n```\n# AArch64 Exception Levels (EL0-EL3)\n\nARM AArch64 defines four Exception Levels (EL0-EL3), with EL3 being the most\nprivileged. Higher ELs control and can trap operations from lower ELs.\n\n## EL0 — User / Application\n  Privilege: Unprivileged (lowest)\n  What runs here: User-space applications, unprivileged library code\n  Stack pointer: SP_EL0 (always used at EL0)\n\n## EL1 — OS Kernel\n  Privilege: Privileged (OS level)\n  What runs here: Operating system kernels (Linux, Windows, etc.)\n  Key registers: SCTLR_EL1, TTBR0_EL1, VBAR_EL1, ESR_EL1, ELR_EL1, SPSR_EL1\n\n## EL2 — Hypervisor\n  Privilege: Hypervisor (higher than OS)\n  What runs here: Hypervisors / VMMs (KVM, Xen, Hyper-V)\n  Key registers: HCR_EL2 (controls trapping, stage-2 translation), VTTBR_EL2\n\n## EL3 — Secure Monitor\n  Privilege: Highest privilege (firmware level)\n  What runs here: ARM Trusted Firmware (TF-A / BL31), SMC dispatcher\n  Key registers: SCR_EL3 (NS bit controls Secure/Non-secure world)\n\n## Vector Table Layout\n  16 entries at VBAR_ELx offsets (0x000-0x780), each 128 bytes.\n  Organized by: source (Current EL SP_EL0, Current EL SP_ELx,\n  Lower EL AArch64, Lower EL AArch32) × type (Sync, IRQ, FIQ, SError).\n\n## Security States\n  Non-secure: SCR_EL3.NS=1       — normal world\n  Secure:     SCR_EL3.NS=0       — TrustZone secure world\n  Realm:      SCR_EL3.NS=1,NSE=1 — ARMv9 RME confidential VMs\n  Root:       SCR_EL3.NS=0,NSE=1 — EL3 firmware (ARMv9 RME)\n```\n\n---\n\n### 9. explain_security_model\n\n**Prompt:** \"How does ARM TrustZone and RME work?\"\n\n**Response** (via `explain_security_model(\"aarch64\")`):\n\n```\n# AArch64 Security Model\n\n## TrustZone: Secure vs Non-secure Worlds\n  SCR_EL3.NS (bit 0) selects the world:\n    0 -> Lower ELs are in Secure state\n    1 -> Lower ELs are in Non-secure state\n\n  World-switching is mediated by EL3 firmware via SMC instruction.\n\n## Secure Exception Levels\n  S-EL0: Trusted Applications (DRM, key management)\n  S-EL1: Trusted OS (OP-TEE, Trusty)\n  S-EL2: Secure Partition Manager (ARMv8.4+, Hafnium-based)\n\n## ARMv9 Realm Management Extension (RME)\n  Four worlds: Non-secure, Secure, Realm, Root\n  Granule Protection Table (GPT): hardware-enforced per-page world assignment\n  Granule Protection Checks (GPC): MMU checks PA against GPT on every access\n\n## Confidential Compute Architecture (CCA)\n  RMM (Realm Management Monitor) at R-EL2 manages confidential Realm VMs\n  Realm VMs are isolated from hypervisor, Secure world, and other Realms\n  Hardware attestation proves Realm integrity to remote verifiers\n```\n\n---\n\n### 10. lookup_core\n\n**Prompt:** \"Tell me about the Cortex-A78\"\n\n**Response** (via `lookup_core(\"Cortex-A78\")`):\n\n```\n# ARM Cortex-A78\nSeries: Cortex-A  |  Architecture: ARMv8.2-A  |  Year: 2020\n\n## Microarchitecture\n  Generation:    Hercules\n  Pipeline:      13-stage out-of-order\n  Decode width:  4-wide\n\n## Key Features\n  - Out-of-order execution, 4-wide decode\n  - ARMv8.2-A with FP16, dot-product, optional RAS\n  - L1I 32-64 KB, L1D 32-64 KB\n  - Private L2 up to 512 KB, shared L3 via DSU-110\n  - ~20% sustained performance uplift over A77 at same power\n  - DynamIQ pairing with Cortex-A55 or Cortex-A78C\n\n## Target Market\n  Mobile (premium performance core)\n\n## Notable Products / SoCs\n  - Qualcomm Snapdragon 888\n  - Samsung Exynos 2100\n  - MediaTek Dimensity 1200\n```\n\n---\n\n### 11. compare_cores\n\n**Prompt:** \"Compare the Cortex-A78 and Cortex-X4\"\n\n**Response** (via `compare_cores(\"Cortex-A78\", \"Cortex-X4\")`):\n\n```\n# Core Comparison: ARM Cortex-A78 vs ARM Cortex-X4\n\nAttribute               ARM Cortex-A78                   ARM Cortex-X4\n---------------------------------------------------------------------------\nSeries                  Cortex-A                         Cortex-X\nArchitecture            ARMv8.2-A                        ARMv9.2-A\nYear                    2020                             2023\nPipeline Depth          13-stage out-of-order            13+ stage out-of-order\nDecode Width            4-wide                           6-wide\nTarget Market           Mobile (premium)                 Mobile (prime/peak)\n\n## Key Features Comparison\n\n### ARM Cortex-A78\n  - 4-wide decode, FP16, dot-product\n  - Private L2 up to 512 KB, shared L3 via DSU-110\n\n### ARM Cortex-X4\n  - 6-wide decode, SVE2, MTE, BRBE\n  - Private L2 up to 2 MB, shared L3 via DSU-120 (up to 16 MB)\n  - ~15% IPC uplift over X3\n\n## Notable Products / SoCs\n  Cortex-A78: Snapdragon 888, Exynos 2100, Dimensity 1200\n  Cortex-X4:  Snapdragon 8 Gen 3, Dimensity 9300\n```\n\n---\n\n### 12. explain_page_table_format\n\n**Prompt:** \"Explain the 4KB granule page table format with 48-bit VA\"\n\n**Response** (via `explain_page_table_format(\"4KB\", 48)`):\n\n```\n# AArch64 Page Table Format: 4KB Granule, 48-bit VA\n\n## Overview\n  Translation granule:       4KB (4096 bytes)\n  Virtual address bits:      48\n  Page table entry size:     8 bytes (64 bits)\n  Entries per table:         512\n  Active translation levels: 4 (L0, L1, L2, L3)\n\n## Virtual Address Bit Layout\n\n  47                                                            0\n  +-----------+-----------+-----------+-----------+--------------+\n  |    L0     |    L1     |    L2     |    L3     |    Offset    |\n  |  [47:39]  |  [38:30]  |  [29:21]  |  [20:12]  |    [11:0]    |\n  +-----------+-----------+-----------+-----------+--------------+\n\n## Translation Level Details\n  L0: VA[47:39], 512 entries — Table descriptor only\n  L1: VA[38:30], 512 entries — Block (1GB) or Table\n  L2: VA[29:21], 512 entries — Block (2MB) or Table\n  L3: VA[20:12], 512 entries — Page (4KB)\n\n## PTE Descriptor Fields\n  [54] UXN, [53] PXN, [52] Contiguous, [10] AF, [9:8] SH,\n  [7:6] AP, [4:2] AttrIndx, [1:0] Type\n\n## TCR_EL1 Configuration\n  T0SZ/T1SZ = 16 → 48-bit VA\n  TG0 = 0b00 → 4KB granule\n  IPS: controls max physical address width (32-52 bits)\n```\n\n---\n\n### 13. explain_memory_attributes\n\n**Prompt:** \"Explain ARM memory cacheability\"\n\n**Response** (via `explain_memory_attributes(\"cacheability\")`):\n\n```\n# ARM Memory Cacheability\n\n## Normal Memory Cache Policies\n\n### Write-Back (WB)\n  Writes update only the cache; dirty lines written to memory on eviction.\n  Best performance. MAIR nibble: 0b1011 = WB, Read+Write Allocate.\n\n### Write-Through (WT)\n  Writes update both cache and memory simultaneously.\n  MAIR nibble: 0b0110 = WT, Read-Allocate.\n\n### Non-cacheable (NC)\n  All accesses go directly to memory. MAIR encoding: 0x44.\n\n## Device Memory Types (Always Non-cacheable)\n\n  | Type           | Gathering | Reordering | Early Ack | MAIR  | Use Case              |\n  |----------------|-----------|------------|-----------|-------|-----------------------|\n  | Device-nGnRnE  | No        | No         | No        | 0x00  | Status registers      |\n  | Device-nGnRE   | No        | No         | Yes       | 0x04  | General MMIO          |\n  | Device-nGRE    | No        | Yes        | Yes       | 0x08  | PCIe config, DMA      |\n  | Device-GRE     | Yes       | Yes        | Yes       | 0x0C  | Framebuffers          |\n\n## Cache Maintenance Operations\n  DC CIVAC: Clean+Invalidate by VA to Point of Coherency\n  DC CVAC:  Clean by VA to Point of Coherency\n  IC IALLU: Invalidate All I-caches to PoU\n```\n\n---\n\n### 14. explain_extension\n\n**Prompt:** \"Tell me about the SVE extension\"\n\n**Response** (via `explain_extension(\"SVE\")`):\n\n```\n# Scalable Vector Extension (SVE)\nIntroduced in: ARMv8.2-A (optional)\n\n## Purpose\nProvides a vector-length-agnostic SIMD programming model for HPC and\nscientific workloads. Supports vector lengths from 128 to 2048 bits in\n128-bit increments, chosen by the hardware implementation.\n\n## Key Registers\n  - Z0-Z31: Scalable vector registers (VL bits wide, 128-2048)\n  - P0-P15: Predicate registers (VL/8 bits) for per-lane masking\n  - FFR: First Fault Register (for speculative memory access)\n  - ZCR_EL1/2/3: SVE Control Register (controls effective vector length)\n\n## Key Instructions\n  - LD1B/LD1H/LD1W/LD1D: Contiguous predicated loads\n  - ST1B/ST1H/ST1W/ST1D: Contiguous predicated stores\n  - WHILELT/WHILELE: Generate predicate for loop tails\n  - GATHER/SCATTER loads/stores for indirect access\n\n## Detection\n  Register: ID_AA64PFR0_EL1, Field: SVE (bits [35:32])\n  Linux: HWCAP_SVE in getauxval(AT_HWCAP)\n\n## Practical Use Cases\n  - HPC: Dense linear algebra, FFT, weather/climate simulation\n  - ML inference: Vectorized activation functions, quantized dot products\n  - Bioinformatics: Sequence alignment, genome assembly\n```\n\n---\n\n### 15. compare_architecture_versions\n\n**Prompt:** \"What features did ARMv9.0 introduce?\"\n\n**Response** (via `compare_architecture_versions(\"armv9.0\")`):\n\n```\n# ARMv9.0-A (2021)\n\n## Mandatory Features\n  - Everything in ARMv8.5-A (ARMv9.0 is based on ARMv8.5)\n  - FEAT_SVE2: SVE2 is mandatory (scalable vectors for all workloads)\n  - FEAT_ETE: Embedded Trace Extension (successor to ETM for trace)\n  - FEAT_TRBE: Trace Buffer Extension (self-hosted trace to memory buffer)\n  - FEAT_RME: Realm Management Extension (hardware isolation for confidential compute)\n\n## Optional Features\n  - FEAT_TME: Transactional Memory Extension\n  - FEAT_MTE / FEAT_MTE2: Memory Tagging Extension\n  - FEAT_BTI: Branch Target Identification\n  - FEAT_SME: Scalable Matrix Extension (introduced at v9.2)\n\n## Notable Changes\nARMv9 is the first major version change since ARMv8 in 2011. Makes SVE2\nmandatory, adds RME for confidential computing (ARM CCA), and introduces\nnew trace infrastructure (ETE/TRBE).\n\n## Example Cores\n  Cortex-A710, Cortex-X2, Neoverse N2 (ARMv9.0 baseline)\n```\n\n---\n\n### 16. show_assembly_pattern\n\n**Prompt:** \"Show me how to write a spinlock in AArch64\"\n\n**Response** (via `show_assembly_pattern(\"spinlock_acquire\", \"aarch64\")`):\n\n```\n# Assembly Pattern: spinlock_acquire (aarch64)\n\n// === AArch64 Spinlock Acquire ===\n// X0 = lock address (0=unlocked, 1=locked). Acquire semantics.\n\n    MOV   W2, #1                // W2 = 1 (locked value).\n    SEVL                        // Send Event Locally: first WFE won't stall.\n1:  WFE                          // Wait For Event: low-power spin wait.\n    LDAXR  W3, [X0]             // Load-Exclusive with Acquire: read lock.\n                                 //   Acquire ensures we see all writes from\n                                 //   the previous lock holder.\n    CBNZ   W3, 1b               // If locked, spin.\n    STXR   W3, W2, [X0]         // Store-Exclusive: try to set lock=1.\n    CBNZ   W3, 1b               // If store failed, retry.\n\n// Critical section begins. All subsequent accesses ordered after LDAXR.\n//\n// ARMv8.1 LSE alternative:\n// 1:  SWPA W2, W3, [X0]        // Atomic swap with Acquire\n//     CBNZ W3, 1b              // If old!=0, lock was held\n```\n\n---\n\n### 17. explain_barrier\n\n**Prompt:** \"Explain the DMB barrier\"\n\n**Response** (via `explain_barrier(\"DMB\")`):\n\n```\n# Data Memory Barrier (DMB)\nEncoding: DMB <option>  (AArch64/AArch32)\n\n## What It Does\nDMB ensures that all explicit memory accesses that appear in program order\nbefore the DMB are observed before any explicit memory accesses after the DMB.\n\nCRITICAL: DMB only orders memory accesses relative to each other. It does NOT:\n  - Wait for memory accesses to complete (use DSB for that)\n  - Flush the pipeline (use ISB for that)\n\n## When To Use It\n  1. Between a flag/lock write and subsequent data reads.\n  2. Implementing acquire/release when LDAR/STLR are not available.\n  3. Producer-consumer: write data, DMB, write flag.\n  4. Memory-mapped I/O: ordering a register write before a status read.\n\n## Domain / Shareability Options\n  SY:     Full System (default, strongest)\n  ST:     Full System, Store only\n  LD:     Full System, Load only (ARMv8.1+)\n  ISH:    Inner Shareable (most common for SMP)\n  ISHST:  Inner Shareable, Store only\n  ISHLD:  Inner Shareable, Load only (ARMv8.1+)\n  NSH:    Non-shareable (local PE only)\n  OSH:    Outer Shareable (full system including GPUs/DMA)\n  ... and NSHST, NSHLD, OSHST, OSHLD variants\n```\n\n---\n\n### 18. explain_neon_intrinsic\n\n**Prompt:** \"How do I use the fused multiply-add NEON intrinsic?\"\n\n**Response** (via `explain_neon_intrinsic(\"vfmaq_f32\")`):\n\n```\n# NEON Intrinsic: vfmaq_f32\n\nSignature: float32x4_t vfmaq_f32(float32x4_t a, float32x4_t b, float32x4_t c)\nInstruction: FMLA Vd.4S, Vn.4S, Vm.4S\nCategory: Arithmetic\nArchitecture: AArch64\n\n## Description\nFused multiply-accumulate: a + b * c. This is the preferred FMA intrinsic\non AArch64 (ARMv8.0+). Guaranteed to emit a true fused multiply-add with\na single rounding step. Critical for AI/ML inference kernels.\n\n## Performance\n  Latency: 4 cycles (Cortex-A78 class)\n  Throughput: 2 per cycle\n\n## Example\n  float32x4_t acc = vdupq_n_f32(0.0f);\n  for (int i = 0; i < N; i += 4) {\n      float32x4_t a = vld1q_f32(&src_a[i]);\n      float32x4_t b = vld1q_f32(&src_b[i]);\n      acc = vfmaq_f32(acc, a, b);  // acc += a * b\n  }\n  float32_t result = vaddvq_f32(acc);  // horizontal sum\n```\n\n---\n\n### 19. explain_sme_tile\n\n**Prompt:** \"How does the SME outer product instruction work?\"\n\n**Response** (via `explain_sme_tile(\"outer_product\")`):\n\n```\n# SME: Outer Product Operations\n\nThe core primitive in SME is the outer-product-and-accumulate instruction.\nGiven two SVE vectors, it computes their outer product and accumulates\ninto a ZA tile.\n\nFor FMOPA ZA0.S, P0/M, P1/M, Z0.S, Z1.S:\n  ZA0.S[i][j] += Z0.S[i] * Z1.S[j]\n\nOne instruction performs (SVL/32)^2 FP32 MACs -- at SVL=512, that's\n16x16 = 256 FMACs per instruction.\n\nAvailable variants:\n  FMOPA / FMOPS:  FP32/FP64 outer product add/subtract\n  BFMOPA:         BF16 inputs, FP32 accumulation (2x throughput)\n  SMOPA / UMOPA:  INT8 inputs, INT32 accumulation (4x throughput)\n```\n\n---\n\n### 20. suggest_optimization\n\n**Prompt:** \"How should I optimize a dot product on Cortex-A78?\"\n\n**Response** (via `suggest_optimization(\"dot_product\", target_core=\"cortex-a78\")`):\n\n```\n# ARM Optimization Guide: Dot Product\n\n## Optimization Techniques\n\n### 1. NEON FMLA accumulation (ARMv8.0+)\n  Load 4 FP32 values from each vector, multiply-accumulate into a NEON\n  accumulator, then reduce with FADDP. Unroll 2-4x to hide FMLA latency.\n\n### 2. UDOT/SDOT integer dot product (ARMv8.2+)\n  For quantized INT8 inference, UDOT/SDOT compute 4-element dot products\n  directly. 4x throughput vs scalar.\n\n### 3. SVE predicated loop\n  Use WHILELT for loop tail handling, FADDA for in-order reduction.\n\n## Core-Specific Notes (Cortex-A78)\n  - ARMv8.2-A: UDOT/SDOT available\n  - 2x 128-bit SIMD pipes: can sustain 2 FMLA/cycle\n```\n\n---\n\n### 21. lookup_system_register\n\n**Prompt:** \"What is the TCR_EL1 register?\"\n\n**Response** (via `lookup_system_register(\"TCR_EL1\")`):\n\n```\n# System Register: TCR_EL1\n\nFull Name: Translation Control Register\nException Level: EL1\nAccess: Read/Write\nWidth: 64-bit\nCategory: Memory Management\n\n## Description\nControls translation table walks for EL0/EL1. Configures granule size,\nregion sizes (T0SZ/T1SZ), cacheability of page-table walks, and\nintermediate physical address size.\n\n## Key Fields\n  [5:0]   T0SZ   Size offset for TTBR0_EL1 region\n  [21:16] T1SZ   Size offset for TTBR1_EL1 region\n  [15:14] TG0    Granule size for TTBR0 (00=4KB, 01=64KB, 10=16KB)\n  [31:30] TG1    Granule size for TTBR1\n  [34:32] IPS    Intermediate Physical Address Size\n```\n\n---\n\n### 22. explain_performance_counter\n\n**Prompt:** \"What PMU event should I use to measure cache misses?\"\n\n**Response** (via `explain_performance_counter(\"L1D_CACHE_REFILL\")`):\n\n```\n# PMU Event: L1D_CACHE_REFILL (0x03)\n\nCategory: Cache\nLinux perf: perf stat -e l1d_cache_refill\n\n## What It Measures\nCounts each cache line refill into the L1 data cache caused by a data\naccess that misses in L1D.\n\n## Useful Formulas\n  L1D miss rate = L1D_CACHE_REFILL / L1D_CACHE\n  MPKI = L1D_CACHE_REFILL * 1000 / INST_RETIRED\n\n## AI/ML Workload Tips\nFor ML inference, high L1D misses suggest tensor data layout is not\ncache-friendly. Consider tiling or NHWC/NCHW layout changes.\n```\n\n---\n\n### 23. translate_intrinsic\n\n**Prompt:** \"What's the ARM equivalent of _mm256_fmadd_ps?\"\n\n**Response** (via `translate_intrinsic(\"_mm256_fmadd_ps\", \"x86\", \"neon\")`):\n\n```\n# Intrinsic Translation: _mm256_fmadd_ps -> 2x vfmaq_f32\n\n## x86 (FMA/AVX2)\n  Intrinsic: _mm256_fmadd_ps\n  Instruction: VFMADD132PS / VFMADD213PS / VFMADD231PS (ymm)\n\n## ARM NEON Equivalent\n  Intrinsic: 2x vfmaq_f32 (split into high/low)\n  Instruction: FMLA Vd.4S, Vn.4S, Vm.4S (x2)\n\n## ARM SVE Equivalent\n  Intrinsic: svmla_f32_x(pg, acc, a, b)\n  Instruction: FMLA Zd.S, Pg/M, Zn.S, Zm.S\n\n## Gotchas\nOperand order differs! x86 FMA: fmadd(a,b,c) = a*b+c.\nNEON FMA: vfmaq_f32(acc,a,b) = acc+a*b. Accumulator is FIRST in NEON.\n```\n\n---\n\n## Testing\n\n### Running tests\n\nThe test suite is self-contained -- it includes its own minimal test runner so you don't need pytest or any other test framework installed. Just run:\n\n```bash\npython tests/test_tools.py\n```\n\nYou'll see output like:\n\n```\n  PASS  TestLookupRegister.test_cpsr\n  PASS  TestLookupRegister.test_x0\n  ...\n  PASS  TestTranslateIntrinsic.test_overview\n\n============================================================\nResults: 128/128 passed, 0 failed\n============================================================\n```\n\nIf you prefer pytest (and have it installed), that works too:\n\n```bash\npython -m pytest tests/test_tools.py -v\n```\n\n### What the tests cover\n\nEvery test calls the tool function directly (no MCP transport needed) and checks that:\n- The output contains expected keywords (`assert_contains`)\n- The output does not start with `\"Error\"` for valid inputs (`assert_no_error`)\n- Invalid inputs return error messages (not exceptions)\n- Case-insensitive lookups work\n- Overview/list queries return structured output\n\n### Test cases by tool\n\n| # | Tool | Test Cases |\n|---|------|------------|\n| 1 | `lookup_register` | 9 |\n| 2 | `list_registers` | 5 |\n| 3 | `decode_instruction` | 6 |\n| 4 | `explain_condition_code` | 6 |\n| 5 | `explain_calling_convention` | 3 |\n| 6 | `search_registers` | 4 |\n| 7 | `decode_register_value` | 5 |\n| 8 | `explain_exception_levels` | 4 |\n| 9 | `explain_security_model` | 4 |\n| 10 | `lookup_core` | 5 |\n| 11 | `compare_cores` | 3 |\n| 12 | `explain_page_table_format` | 4 |\n| 13 | `explain_memory_attributes` | 6 |\n| 14 | `explain_extension` | 6 |\n| 15 | `compare_architecture_versions` | 3 |\n| 16 | `show_assembly_pattern` | 5 |\n| 17 | `explain_barrier` | 6 |\n| 18 | `explain_neon_intrinsic` | 6 |\n| 19 | `explain_sme_tile` | 8 |\n| 20 | `suggest_optimization` | 6 |\n| 21 | `lookup_system_register` | 8 |\n| 22 | `explain_performance_counter` | 8 |\n| 23 | `translate_intrinsic` | 8 |\n| | **Total** | **128** |\n\n### Adding tests for new tools\n\nFollow the existing pattern in `tests/test_tools.py`:\n\n1. Import your new tool function at the top of the file:\n   ```python\n   from arm_reference_mcp.server import (\n       ...\n       your_new_tool,\n   )\n   ```\n\n2. Add a test class (one class per tool):\n   ```python\n   class TestYourNewTool:\n       def test_basic_lookup(self):\n           r = your_new_tool(\"some_input\")\n           assert_no_error(r)\n           assert_contains(r, \"expected\", \"keywords\")\n\n       def test_case_insensitive(self):\n           r = your_new_tool(\"SOME_INPUT\")\n           assert_no_error(r)\n\n       def test_not_found(self):\n           r = your_new_tool(\"nonexistent\")\n           assert \"Error\" in r\n   ```\n\n3. Register your class in the `run_all()` function's `test_classes` list:\n   ```python\n   test_classes = [\n       ...\n       TestYourNewTool,\n   ]\n   ```\n\n4. Run the tests:\n   ```bash\n   python tests/test_tools.py\n   ```\n\n---\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "arm-reference-mcp",
          "description": "ARM architecture reference -- 23 tools covering registers, instructions, calling conventions, exception levels, security models, page tables, memory attributes, extensions, assembly patterns, barriers, core/IP reference, NEON intrinsics, SME tiles, optimization, system registers, PMU events, and x86-to-ARM translation for AArch32 and AArch64.",
          "source": "./",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add yerry262/arm-reference-mcp",
            "/plugin install arm-reference-mcp@arm-reference"
          ]
        }
      ]
    }
  ]
}