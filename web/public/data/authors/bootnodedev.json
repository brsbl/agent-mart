{
  "author": {
    "id": "BootNodeDev",
    "display_name": "BootNode",
    "avatar_url": "https://avatars.githubusercontent.com/u/80694284?v=4"
  },
  "marketplaces": [
    {
      "name": "ai-dev-rails",
      "version": null,
      "description": "Context-efficient development methodology — each stage writes artifacts to disk so the next stage starts clean with exactly the right context",
      "repo_full_name": "BootNodeDev/ai-dev-rails",
      "repo_url": "https://github.com/BootNodeDev/ai-dev-rails",
      "repo_description": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-02-11T18:12:24Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"ai-dev-rails\",\n  \"owner\": {\n    \"name\": \"Bootnode\"\n  },\n  \"metadata\": {\n    \"description\": \"Context-efficient development methodology — each stage writes artifacts to disk so the next stage starts clean with exactly the right context\",\n    \"version\": \"0.1.0-beta.4\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"ai-dev-rails\",\n      \"source\": \"./\",\n      \"description\": \"Context-efficient development methodology — each stage writes artifacts to disk so the next stage starts clean with exactly the right context\",\n      \"version\": \"0.1.0-beta.4\",\n      \"author\": {\n        \"name\": \"Nicolás Domínguez\",\n        \"email\": \"nico@bootnode.dev\"\n      }\n    }\n  ]\n}",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"ai-dev-rails\",\n  \"description\": \"Context-efficient development methodology — each stage writes artifacts to disk so the next stage starts clean with exactly the right context\",\n  \"version\": \"0.1.0-beta.5\",\n  \"author\": {\n    \"name\": \"Nicolás Domínguez\",\n    \"email\": \"nico@bootnode.dev\"\n  },\n  \"homepage\": \"https://github.com/BootNodeDev/ai-dev-rails\",\n  \"repository\": \"https://github.com/BootNodeDev/ai-dev-rails\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"workflow\", \"methodology\", \"research\", \"planning\", \"implementation\"],\n  \"hooks\": {\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Bash\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"bash \\\"${CLAUDE_PLUGIN_ROOT}/hooks/compress-bash-output.sh\\\"\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "README.md": "# ai-dev-rails\n\nClaude Code is powerful, but without structure it tends to lose context between sessions, skip research, produce plans with unresolved questions, and make changes without verification.\n\n`ai-dev-rails` breaks complex tasks into focused stages — research, planning, implementation, validation — where each stage produces an artifact that feeds the next one. Instead of cramming everything into a single context window, each step starts with exactly the right context already written down. The result is better code, fewer hallucinations, and a knowledge base that compounds across sessions and team members.\n\n```\n/research_codebase  →  Research document\n         ↓\n/create_plan        →  Implementation plan with phases and success criteria\n         ↓\n/implement_plan     →  Code changes + checkboxes marked in plan\n         ↓\n/validate_plan      →  Validation report (pass/fail per phase)\n         ↓\n/commit             →  Atomic commits with user approval\n         ↓\n/describe_pr        →  PR description from plan + changes\n\n(optional, at any point)\n\n/create_handoff     →  Saves context, learnings, and next steps\n         ↓\n/resume_handoff     →  Reads handoff, validates current state, creates task list\n```\n\n## Installation\n\nAdd the marketplace and install the plugin:\n\n```\n/plugin marketplace add BootNodeDev/ai-dev-rails\n/plugin install ai-dev-rails@ai-dev-rails\n```\n\nAfter installing, you should:\n\n1. Create the `thoughts/` directory structure in your project:\n\n```bash\nmkdir -p thoughts/shared/{research,plans,tickets,prs,handoffs} thoughts/global\n```\n\n2. Add the `thoughts/` gitignore rules to your `.gitignore`:\n\n```gitignore\nthoughts/*\n!thoughts/shared/\n!thoughts/global/\n```\n\n3. Allow Claude Code to read and write in `thoughts/` without prompting — add to your `.claude/settings.json`:\n\n```json\n{\n  \"permissions\": {\n    \"allow\": [\n      \"Read(thoughts/**)\",\n      \"Edit(thoughts/**)\",\n      \"Write(thoughts/**)\"\n    ]\n  }\n}\n```\n\n4. Optionally, add a reference to the methodology in your `CLAUDE.md` so Claude Code is aware of the available commands\n\n## What You Get\n\n```\nagents/       6 specialized sub-agents\ncommands/     17 workflow commands (slash commands)\nhooks/        context-saving hooks\n```\n\n## Commands Reference\n\n### Research\n\nEach research command produces a document describing the codebase as-is (facts, not opinions). The variants differ in where the output goes:\n\n| Command                      | When to use                                                                                                                                                                                     |\n| ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/research_codebase`         | You need a persistent research document that the team can reference later. Output is saved to `thoughts/shared/research/`. Use this when starting work on a ticket that others might pick up.   |\n| `/research_codebase_nt`      | You need quick research for yourself in the current session. Output stays in the conversation only, nothing is written to disk. Use this for small tasks or when `thoughts/` is not set up yet. |\n| `/research_codebase_generic` | Same as `/research_codebase` but with a less opinionated document structure. Use this when the standard template doesn't fit your research needs.                                               |\n\n### Planning\n\n| Command                | When to use                                                                                                                                                                                                      |\n| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `/create_plan`         | You need an implementation plan with phases, success criteria, and code references. Saved to `thoughts/shared/plans/` so the team can review it. Use this for any task that touches more than a couple of files. |\n| `/create_plan_nt`      | Same structured plan, but output stays in the conversation. Use this for quick tasks where you don't need to save the plan for others.                                                                           |\n| `/create_plan_generic` | Same as `/create_plan` but with a less rigid plan structure. Use this when the standard phase/criteria template feels too heavy for your task.                                                                   |\n| `/iterate_plan`        | You have an existing plan in `thoughts/shared/plans/` and need to update it after new information, feedback, or scope changes.                                                                                   |\n| `/iterate_plan_nt`     | Same, but the plan lives in the conversation instead of `thoughts/`.                                                                                                                                             |\n\n### Implementation\n\n| Command           | When to use                                                                                                             |\n| ----------------- | ----------------------------------------------------------------------------------------------------------------------- |\n| `/implement_plan` | Execute a plan phase-by-phase. Pauses after each phase for automated verification and manual testing before continuing. |\n| `/validate_plan`  | After implementation, verify every success criterion in the plan. Produces a pass/fail report.                          |\n\n### Git & PR\n\n| Command           | When to use                                                                                                           |\n| ----------------- | --------------------------------------------------------------------------------------------------------------------- |\n| `/commit`         | Interactive commit — shows diff, drafts message, asks for approval before committing.                                 |\n| `/ci_commit`      | Same but without asking for approval. For CI/automation contexts.                                                     |\n| `/describe_pr`    | Generate a PR description from the plan and changes. Requires a team template at `thoughts/shared/pr_description.md`. |\n| `/describe_pr_nt` | Same, with a built-in template. No setup required.                                                                    |\n| `/ci_describe_pr` | CI variant of `/describe_pr`. Requires the team template.                                                             |\n\n### Session Management\n\n| Command           | When to use                                                                                                |\n| ----------------- | ---------------------------------------------------------------------------------------------------------- |\n| `/create_handoff` | Before ending a session, capture context, learnings, recent changes, and next steps in a handoff document. |\n| `/resume_handoff` | Start a new session by reading a handoff document. Validates current state and creates a task list.        |\n\n## Agents\n\nAgents are specialized sub-processes that the commands spawn internally via the `Task` tool. They follow a **locator/analyzer pair** pattern: locator first (cheap, fast scan), analyzer second (expensive, deep read). You don't invoke them directly — the commands orchestrate them as needed.\n\n| Agent                       | What it does                                                                                      |\n| --------------------------- | ------------------------------------------------------------------------------------------------- |\n| **codebase-locator**        | Finds WHERE code lives. A \"super grep\" that locates files by feature or topic.                    |\n| **codebase-analyzer**       | Understands HOW code works. Traces data flow, documents implementation with file:line references. |\n| **codebase-pattern-finder** | Finds existing patterns and concrete code examples to model new work after.                       |\n| **thoughts-locator**        | Discovers relevant documents in `thoughts/`.                                                      |\n| **thoughts-analyzer**       | Deep-dives into `thoughts/` documents to extract decisions, constraints, and actionable insights. |\n| **web-search-researcher**   | Searches the web for documentation, best practices, and technical solutions.                      |\n\n## Hooks\n\nHooks run automatically during Claude Code events to save context tokens and improve agent performance.\n\n| Hook | Event | What it does |\n| --- | --- | --- |\n| **compress-bash-output** | `PostToolUse` (Bash) | Compresses successful command output longer than 30 lines to first 5 + last 10 lines. Failed commands pass through unmodified so the agent can debug. |\n\n## The `thoughts/` Directory\n\nA shared knowledge base that persists across sessions. This is what makes the methodology work across a team — research, plans, and decisions are artifacts, not ephemeral conversation.\n\n```\nthoughts/\n├── shared/          # Team-shared (committed to git)\n│   ├── research/    # Research documents\n│   ├── plans/       # Implementation plans\n│   ├── tickets/     # Ticket context and requirements\n│   ├── prs/         # PR descriptions\n│   └── handoffs/    # Session handoff documents\n├── [username]/      # Personal notes (git-ignored, local only)\n└── global/          # Cross-repository thoughts (committed to git)\n```\n\n### Naming Conventions\n\n| Type     | Pattern                                        | Example                                        |\n| -------- | ---------------------------------------------- | ---------------------------------------------- |\n| Research | `YYYY-MM-DD-TICKET-ID-description.md`          | `2025-03-15-GH-42-auth-flow.md`               |\n| Plans    | `YYYY-MM-DD-TICKET-ID-description.md`          | `2025-03-15-GH-42-add-oauth.md`               |\n| Handoffs | `YYYY-MM-DD_HH-MM-SS_TICKET-ID_description.md` | `2025-03-15_14-30-00_GH-42_oauth-progress.md` |\n\n`TICKET-ID` is the identifier from your project tracker (e.g. `GH-42`, `JIRA-1234`). Omit it if there's no ticket.\n\n## Credits\n\nThis methodology was developed by the [HumanLayer](https://github.com/humanlayer/humanlayer) team as part of building their human-in-the-loop platform for AI agents. `ai-dev-rails` extracts and packages their internal workflow so any team can adopt it.\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "ai-dev-rails",
          "source": "./",
          "description": "Context-efficient development methodology — each stage writes artifacts to disk so the next stage starts clean with exactly the right context",
          "version": "0.1.0-beta.4",
          "author": {
            "name": "Nicolás Domínguez",
            "email": "nico@bootnode.dev"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add BootNodeDev/ai-dev-rails",
            "/plugin install ai-dev-rails@ai-dev-rails"
          ]
        }
      ]
    }
  ]
}