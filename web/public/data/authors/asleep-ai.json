{
  "author": {
    "id": "asleep-ai",
    "display_name": "Asleep",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/68939395?v=4",
    "url": "https://github.com/asleep-ai",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 4,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "sleeptrack-skills",
      "version": null,
      "description": "Skills marketplace for Asleep API integration - sleep tracking, user management, and analytics",
      "owner_info": {
        "name": "asleep-ai",
        "email": "marcus.kyung@asleep.ai"
      },
      "keywords": [],
      "repo_full_name": "asleep-ai/sleeptrack-skills",
      "repo_url": "https://github.com/asleep-ai/sleeptrack-skills",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-11-12T11:11:38Z",
        "created_at": "2025-11-12T05:29:13Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 716
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1597
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-android",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-android/SKILL.md",
          "type": "blob",
          "size": 17530
        },
        {
          "path": "skills/sleeptrack-android/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-android/references/android_architecture_patterns.md",
          "type": "blob",
          "size": 13685
        },
        {
          "path": "skills/sleeptrack-android/references/complete_viewmodel_implementation.md",
          "type": "blob",
          "size": 17999
        },
        {
          "path": "skills/sleeptrack-android/references/gradle_setup.md",
          "type": "blob",
          "size": 4062
        },
        {
          "path": "skills/sleeptrack-android/references/testing_guide.md",
          "type": "blob",
          "size": 13249
        },
        {
          "path": "skills/sleeptrack-android/references/ui_implementation_guide.md",
          "type": "blob",
          "size": 15162
        },
        {
          "path": "skills/sleeptrack-be",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-be/SKILL.md",
          "type": "blob",
          "size": 15502
        },
        {
          "path": "skills/sleeptrack-be/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-be/references/nodejs_client_implementation.md",
          "type": "blob",
          "size": 11945
        },
        {
          "path": "skills/sleeptrack-be/references/production_patterns.md",
          "type": "blob",
          "size": 20106
        },
        {
          "path": "skills/sleeptrack-be/references/python_client_implementation.md",
          "type": "blob",
          "size": 18325
        },
        {
          "path": "skills/sleeptrack-be/references/rest_api_reference.md",
          "type": "blob",
          "size": 15204
        },
        {
          "path": "skills/sleeptrack-be/references/webhook_implementation_guide.md",
          "type": "blob",
          "size": 15474
        },
        {
          "path": "skills/sleeptrack-be/references/webhook_reference.md",
          "type": "blob",
          "size": 20898
        },
        {
          "path": "skills/sleeptrack-foundation",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-foundation/SKILL.md",
          "type": "blob",
          "size": 14837
        },
        {
          "path": "skills/sleeptrack-foundation/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-foundation/references/asleep_api_reference.md",
          "type": "blob",
          "size": 6243
        },
        {
          "path": "skills/sleeptrack-ios",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-ios/SKILL.md",
          "type": "blob",
          "size": 15442
        },
        {
          "path": "skills/sleeptrack-ios/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/sleeptrack-ios/references/advanced_patterns.md",
          "type": "blob",
          "size": 11580
        },
        {
          "path": "skills/sleeptrack-ios/references/complete_viewmodel_implementation.md",
          "type": "blob",
          "size": 12270
        },
        {
          "path": "skills/sleeptrack-ios/references/ios_specific_features.md",
          "type": "blob",
          "size": 7694
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"sleeptrack-skills\",\n  \"owner\": {\n    \"name\": \"asleep-ai\",\n    \"email\": \"marcus.kyung@asleep.ai\"\n  },\n  \"metadata\": {\n    \"description\": \"Skills marketplace for Asleep API integration - sleep tracking, user management, and analytics\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"sleeptrack-skills\",\n      \"description\": \"Collection of Asleep API integration skills covering foundation concepts, Android SDK, iOS SDK, and backend REST API integration\",\n      \"source\": \"./\",\n      \"strict\": false,\n      \"skills\": [\n        \"./skills/sleeptrack-foundation\",\n        \"./skills/sleeptrack-android\",\n        \"./skills/sleeptrack-ios\",\n        \"./skills/sleeptrack-be\"\n      ]\n    }\n  ]\n}\n",
        "README.md": "# sleeptrack-skills\n\nA skills marketplace for developers building applications with the Asleep/Sleeptrack API. These skills help Claude assist with integrating sleep tracking features, implementing API endpoints, and building sleep analysis applications.\n\n## Installation\n\n### Claude Code\n\nAdd this marketplace to Claude Code:\n\n```bash\n/plugin marketplace add asleep-ai/sleeptrack-skills\n```\n\nThen browse and install individual skills, or install directly:\n\n```bash\n/plugin install <skill-name>@sleeptrack-skills\n```\n\n### Prerequisites\n\n- Claude Code CLI installed\n- Developer account with Asleep/Sleeptrack platform\n- Familiarity with sleep tracking API concepts\n\n## Available Skills\n\nSkills in this marketplace are organized by functionality:\n\n### Core Skills\n*(Skills will be added here as they are developed)*\n\n- **API Integration** - Implement Asleep API endpoints in your application\n- **Session Management** - Build features for sleep session data handling\n- **User Management** - Implement user profile and account management\n- **Statistics & Analytics** - Create sleep statistics and insights features\n\n## Usage\n\nThese skills guide Claude in helping you:\n- Design and implement Asleep API integrations\n- Structure your sleep tracking application\n- Handle authentication and API requests\n- Process and analyze sleep data\n- Follow best practices for sleep tracking apps\n\n## Documentation\n\nFor detailed information about the Asleep API:\n- [Asleep API Documentation](https://docs.asleep.ai)\n\n## Contributing\n\nSee [CLAUDE.md](./CLAUDE.md) for development guidelines and marketplace structure.\n",
        "skills/sleeptrack-android/SKILL.md": "---\nname: sleeptrack-android\ndescription: This skill helps Android developers integrate the Asleep SDK for sleep tracking functionality. Use this skill when developers ask about Android implementation, MVVM architecture patterns, permission handling, Jetpack Compose UI, Kotlin coroutines integration, or Android-specific sleep tracking features. This skill provides working code examples from the official sample app.\n---\n\n# Sleeptrack Android\n\n## Overview\n\nThis skill provides comprehensive guidance for integrating the Asleep sleep tracking SDK into Android applications. It covers Android-specific implementation details including MVVM architecture, permission handling, state management, UI patterns, and lifecycle management.\n\nUse this skill when developers need to:\n- Set up Asleep SDK in Android projects\n- Implement sleep tracking with proper Android architecture\n- Handle Android-specific permissions (microphone, notifications, battery optimization)\n- Manage tracking lifecycle with state machines\n- Build UI with ViewBinding or Jetpack Compose\n- Handle errors and edge cases in Android environment\n- Implement foreground services for background tracking\n\n**Prerequisites**: Review the `sleeptrack-foundation` skill first for core concepts including session lifecycle, error codes, and API fundamentals.\n\n## Quick Start\n\n### 1. Add Dependencies\n\nAdd to your app-level `build.gradle`:\n\n```gradle\ndependencies {\n    // Core dependencies\n    implementation 'androidx.core:core-ktx:1.12.0'\n    implementation 'androidx.appcompat:appcompat:1.6.1'\n    implementation 'androidx.lifecycle:lifecycle-service:2.7.0'\n\n    // Required for Asleep SDK\n    implementation 'com.squareup.okhttp3:okhttp:4.11.0'\n    implementation 'com.google.code.gson:gson:2.10'\n    implementation 'ai.asleep:asleepsdk:3.1.4'\n\n    // Optional: Hilt for DI\n    implementation \"com.google.dagger:hilt-android:2.48\"\n    kapt \"com.google.dagger:hilt-compiler:2.48\"\n}\n```\n\n**Minimum Requirements**:\n- minSdk: 24 (Android 7.0)\n- targetSdk: 34\n- Java: 17\n- Kotlin: 1.9.24+\n\nSee `references/gradle_setup.md` for complete Gradle configuration.\n\n### 2. Configure Permissions\n\nAdd to `AndroidManifest.xml`:\n\n```xml\n<manifest>\n    <!-- Essential permissions -->\n    <uses-permission android:name=\"android.permission.INTERNET\" />\n    <uses-permission android:name=\"android.permission.RECORD_AUDIO\" />\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE\" />\n    <uses-permission android:name=\"android.permission.FOREGROUND_SERVICE_MICROPHONE\" />\n\n    <!-- Battery optimization -->\n    <uses-permission android:name=\"android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\" />\n\n    <!-- Notifications (Android 13+) -->\n    <uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\" />\n</manifest>\n```\n\n### 3. Initialize SDK\n\n```kotlin\nAsleep.initAsleepConfig(\n    context = applicationContext,\n    apiKey = \"your_api_key_here\",\n    userId = \"unique_user_id\",\n    baseUrl = \"https://api.asleep.ai\",\n    callbackUrl = null, // Optional webhook URL\n    service = \"YourAppName\",\n    asleepConfigListener = object : Asleep.AsleepConfigListener {\n        override fun onSuccess(userId: String?, asleepConfig: AsleepConfig?) {\n            // SDK initialized successfully\n        }\n\n        override fun onFail(errorCode: Int, detail: String) {\n            Log.e(\"Asleep\", \"Init failed: $errorCode - $detail\")\n        }\n    }\n)\n```\n\n### 4. Start Sleep Tracking\n\n```kotlin\nAsleep.beginSleepTracking(\n    asleepConfig = asleepConfig,\n    asleepTrackingListener = object : Asleep.AsleepTrackingListener {\n        override fun onStart(sessionId: String) {\n            // Tracking started successfully\n        }\n\n        override fun onPerform(sequence: Int) {\n            // Called every ~30 seconds (1 sequence)\n        }\n\n        override fun onFinish(sessionId: String?) {\n            // Tracking completed\n        }\n\n        override fun onFail(errorCode: Int, detail: String) {\n            // Handle tracking errors\n        }\n    },\n    notificationTitle = \"Sleep Tracking Active\",\n    notificationText = \"Tap to return to app\",\n    notificationIcon = R.drawable.ic_notification,\n    notificationClass = MainActivity::class.java\n)\n```\n\n### 5. Stop Tracking\n\n```kotlin\nAsleep.endSleepTracking()\n```\n\n## Android Architecture Pattern (MVVM + Hilt)\n\nThe recommended architecture follows Android best practices with MVVM pattern, Hilt dependency injection, and proper state management.\n\n### State Management\n\nDefine tracking states using sealed classes:\n\n```kotlin\nsealed class AsleepState {\n    data object STATE_IDLE: AsleepState()\n    data object STATE_INITIALIZING : AsleepState()\n    data object STATE_INITIALIZED : AsleepState()\n    data object STATE_TRACKING_STARTING : AsleepState()\n    data object STATE_TRACKING_STARTED : AsleepState()\n    data object STATE_TRACKING_STOPPING : AsleepState()\n    data class STATE_ERROR(val errorCode: AsleepError) : AsleepState()\n}\n\ndata class AsleepError(val code: Int, val message: String)\n```\n\n### Basic ViewModel Pattern\n\n```kotlin\n@HiltViewModel\nclass SleepTrackingViewModel @Inject constructor(\n    @ApplicationContext private val app: Application\n) : ViewModel() {\n\n    private val _trackingState = MutableStateFlow<AsleepState>(AsleepState.STATE_IDLE)\n    val trackingState: StateFlow<AsleepState> = _trackingState\n\n    private var config: AsleepConfig? = null\n\n    fun initializeSDK(userId: String) {\n        Asleep.initAsleepConfig(\n            context = app,\n            apiKey = BuildConfig.ASLEEP_API_KEY,\n            userId = userId,\n            baseUrl = \"https://api.asleep.ai\",\n            callbackUrl = null,\n            service = \"MyApp\",\n            asleepConfigListener = object : Asleep.AsleepConfigListener {\n                override fun onSuccess(userId: String?, asleepConfig: AsleepConfig?) {\n                    config = asleepConfig\n                    _trackingState.value = AsleepState.STATE_INITIALIZED\n                }\n                override fun onFail(errorCode: Int, detail: String) {\n                    _trackingState.value = AsleepState.STATE_ERROR(AsleepError(errorCode, detail))\n                }\n            }\n        )\n    }\n\n    fun startTracking() {\n        config?.let {\n            Asleep.beginSleepTracking(\n                asleepConfig = it,\n                asleepTrackingListener = trackingListener,\n                notificationTitle = \"Sleep Tracking\",\n                notificationText = \"Active\",\n                notificationIcon = R.drawable.ic_notification,\n                notificationClass = MainActivity::class.java\n            )\n        }\n    }\n\n    fun stopTracking() {\n        Asleep.endSleepTracking()\n    }\n}\n```\n\n**For complete production-ready ViewModel with real-time data, error handling, and lifecycle management**, see `references/complete_viewmodel_implementation.md`.\n\n### Basic Activity Pattern\n\n```kotlin\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n    private val viewModel: SleepTrackingViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        // Setup button\n        binding.btnTrack.setOnClickListener {\n            when (viewModel.trackingState.value) {\n                AsleepState.STATE_INITIALIZED -> viewModel.startTracking()\n                AsleepState.STATE_TRACKING_STARTED -> viewModel.stopTracking()\n                else -> {}\n            }\n        }\n\n        // Observe state\n        lifecycleScope.launch {\n            viewModel.trackingState.collect { state ->\n                updateUI(state)\n            }\n        }\n    }\n}\n```\n\n**For complete Activity implementation with permission handling**, see `references/complete_viewmodel_implementation.md`.\n\n## Permission Handling\n\nAndroid requires multiple runtime permissions for sleep tracking:\n\n### Required Permissions\n\n1. **RECORD_AUDIO**: Microphone access for sleep sound recording\n2. **POST_NOTIFICATIONS**: Android 13+ notification permission\n3. **Battery Optimization**: Prevent app from being killed during tracking\n\n### Permission Request Flow\n\n```kotlin\n// Request permissions sequentially\nwhen {\n    !hasMicrophonePermission() -> requestMicrophone()\n    !hasNotificationPermission() -> requestNotification()\n    !isBatteryOptimizationIgnored() -> requestBatteryOptimization()\n    else -> allPermissionsGranted()\n}\n```\n\n### Best Practices\n\n1. **Request in sequence**: Request one permission at a time for better UX\n2. **Show rationale**: Explain why each permission is needed before requesting\n3. **Handle denial**: Provide fallback or guide users to settings\n4. **Check on resume**: Re-check permissions when app resumes\n\n```kotlin\noverride fun onResume() {\n    super.onResume()\n    if (!hasRequiredPermissions() && Asleep.isSleepTrackingAlive(applicationContext)) {\n        handlePermissionLoss()\n    }\n}\n```\n\n**For complete PermissionManager implementation**, see `references/complete_viewmodel_implementation.md`.\n\n## Error Handling\n\nDistinguish between critical errors and warnings:\n\n### Error Classification\n\n```kotlin\nfun isWarning(errorCode: Int): Boolean {\n    return errorCode in setOf(\n        AsleepErrorCode.ERR_AUDIO_SILENCED,\n        AsleepErrorCode.ERR_UPLOAD_FAILED\n    )\n}\n\nfun handleError(error: AsleepError) {\n    if (isWarning(error.code)) {\n        // Show warning, continue tracking\n        Toast.makeText(context, getUserFriendlyMessage(error), Toast.LENGTH_SHORT).show()\n    } else {\n        // Critical error - stop tracking\n        stopTracking()\n        showErrorDialog(getUserFriendlyMessage(error))\n    }\n}\n```\n\n## UI Patterns\n\n### ViewBinding Example\n\n```kotlin\nclass TrackingFragment : Fragment() {\n    private var _binding: FragmentTrackingBinding? = null\n    private val binding get() = _binding!!\n    private val viewModel: SleepTrackingViewModel by viewModels()\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.trackingState.collect { state ->\n                when (state) {\n                    AsleepState.STATE_TRACKING_STARTED -> {\n                        binding.btnTrack.text = \"Stop Tracking\"\n                    }\n                    AsleepState.STATE_INITIALIZED -> {\n                        binding.btnTrack.text = \"Start Tracking\"\n                    }\n                    else -> {}\n                }\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}\n```\n\n### Jetpack Compose Example\n\n```kotlin\n@Composable\nfun SleepTrackingScreen(\n    viewModel: SleepTrackingViewModel = hiltViewModel()\n) {\n    val trackingState by viewModel.trackingState.collectAsState()\n\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        when (trackingState) {\n            AsleepState.STATE_TRACKING_STARTED -> {\n                Button(onClick = { viewModel.stopTracking() }) {\n                    Text(\"Stop Tracking\")\n                }\n            }\n            AsleepState.STATE_INITIALIZED -> {\n                Button(onClick = { viewModel.startTracking() }) {\n                    Text(\"Start Sleep Tracking\")\n                }\n            }\n            is AsleepState.STATE_ERROR -> {\n                ErrorDisplay(error = (trackingState as AsleepState.STATE_ERROR).errorCode)\n            }\n            else -> {\n                CircularProgressIndicator()\n            }\n        }\n    }\n}\n```\n\n**For complete UI implementations with Material3 components**, see `references/ui_implementation_guide.md`.\n\n## Lifecycle Management\n\n### Handle App Lifecycle Events\n\n```kotlin\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    override fun onStart() {\n        super.onStart()\n        // Reconnect to existing tracking session\n        if (Asleep.isSleepTrackingAlive(applicationContext)) {\n            viewModel.reconnectToTracking()\n        }\n    }\n\n    override fun onStop() {\n        super.onStop()\n        // Tracking continues in background via foreground service\n        // No action needed\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        // Do NOT call endSleepTracking() here\n        // Service continues in background\n    }\n}\n```\n\n### Foreground Service\n\nThe Asleep SDK automatically manages a foreground service during tracking. The notification keeps the service alive:\n\n```kotlin\nAsleep.beginSleepTracking(\n    asleepConfig = config,\n    asleepTrackingListener = listener,\n    notificationTitle = \"Sleep Tracking Active\",\n    notificationText = \"Tracking your sleep patterns\",\n    notificationIcon = R.drawable.ic_sleep,\n    notificationClass = MainActivity::class.java  // Tapping notification opens this\n)\n```\n\nThe service will:\n- Keep the app alive during sleep tracking\n- Show persistent notification\n- Maintain microphone access\n- Continue even if user swipes away the app\n\n## Real-Time Sleep Data\n\nAccess preliminary sleep data during tracking:\n\n```kotlin\n// In ViewModel\noverride fun onPerform(sequence: Int) {\n    // Check after sequence 10, then every 10 sequences\n    if (sequence > 10 && sequence % 10 == 0) {\n        getCurrentSleepData()\n    }\n}\n\nprivate fun getCurrentSleepData() {\n    Asleep.getCurrentSleepData(\n        asleepSleepDataListener = object : Asleep.AsleepSleepDataListener {\n            override fun onSleepDataReceived(session: Session) {\n                val currentSleepStage = session.sleepStages?.lastOrNull()\n                val currentSnoringStage = session.snoringStages?.lastOrNull()\n\n                Log.d(\"Sleep\", \"Current stage: $currentSleepStage\")\n            }\n\n            override fun onFail(errorCode: Int, detail: String) {\n                Log.e(\"Sleep\", \"Failed to get current data: $errorCode\")\n            }\n        }\n    )\n}\n```\n\n**Note**: Real-time data is preliminary and may differ from final report after processing.\n\n## Testing\n\n### Unit Testing\n```kotlin\nclass SleepTrackingViewModelTest {\n    @get:Rule val mainDispatcherRule = MainDispatcherRule()\n\n    @Test\n    fun `startTracking should fail if not initialized`() = runTest {\n        viewModel.startTracking()\n        assertNotEquals(AsleepState.STATE_TRACKING_STARTED, viewModel.trackingState.value)\n    }\n}\n```\n\n### Integration Testing\n```kotlin\n@Test\nfun trackingFlow_complete() {\n    onView(withId(R.id.btn_start_stop)).perform(click())\n    onView(withId(R.id.tracking_indicator)).check(matches(isDisplayed()))\n}\n```\n\n**For complete testing guide with Compose UI tests and test utilities**, see `references/testing_guide.md`.\n\n## Common Issues & Solutions\n\n### Tracking stops unexpectedly\n**Causes**: Battery optimization, notification dismissed, permission revoked, microphone conflict\n\n**Solution**: Check battery optimization and permissions on resume:\n```kotlin\noverride fun onResume() {\n    super.onResume()\n    if (!hasRequiredPermissions() && Asleep.isSleepTrackingAlive(applicationContext)) {\n        handlePermissionLoss()\n    }\n}\n```\n\n### No real-time data available\n**Cause**: Checking before sequence 10\n\n**Solution**: Only call `getCurrentSleepData()` after sequence 10\n\n### ERR_UPLOAD_FORBIDDEN error\n**Cause**: Same user_id tracking on multiple devices\n\n**Solution**: Use unique user IDs per device or check for active sessions before starting\n\n## Resources\n\nThis skill includes detailed reference documentation:\n\n- `references/complete_viewmodel_implementation.md`: Complete ViewModel, Activity, and PermissionManager implementations\n- `references/ui_implementation_guide.md`: Complete ViewBinding and Jetpack Compose UI examples\n- `references/testing_guide.md`: Comprehensive unit, integration, and UI testing guides\n- `references/android_architecture_patterns.md`: Complete architecture examples from the official sample app\n- `references/gradle_setup.md`: Comprehensive Gradle configuration including dependencies and ProGuard rules\n\n### Official Documentation\n\n- **Android Getting Started**: https://docs-en.asleep.ai/docs/android-get-started.md\n- **AsleepConfig Reference**: https://docs-en.asleep.ai/docs/android-asleep-config.md\n- **SleepTrackingManager**: https://docs-en.asleep.ai/docs/android-sleep-tracking-manager.md\n- **Error Codes**: https://docs-en.asleep.ai/docs/android-error-codes.md\n\n### Android Resources\n\n- **Android Permissions**: https://developer.android.com/guide/topics/permissions/overview\n- **Foreground Services**: https://developer.android.com/develop/background-work/services/foreground-services\n- **StateFlow Guide**: https://developer.android.com/kotlin/flow/stateflow-and-sharedflow\n- **Hilt Documentation**: https://developer.android.com/training/dependency-injection/hilt-android\n\n## Next Steps\n\nAfter implementing Android sleep tracking:\n\n1. **Test thoroughly**: Test on different Android versions (especially 13+ for notifications)\n2. **Handle edge cases**: Low battery, airplane mode, app updates during tracking\n3. **Fetch reports**: Use REST API or backend integration to retrieve sleep reports\n4. **Build UI**: Create compelling visualizations of sleep data\n5. **Analytics**: Track user engagement and sleep patterns\n\nFor backend report fetching and webhook integration, use the `sleeptrack-be` skill.\n",
        "skills/sleeptrack-android/references/android_architecture_patterns.md": "# Android Architecture Patterns for Asleep SDK\n\nThis document contains key architecture patterns from the Asleep Android sample app.\n\n## 1. Application Setup with Hilt\n\n```kotlin\n@HiltAndroidApp\nclass SampleApplication : Application() {\n    companion object {\n        private lateinit var instance: SampleApplication\n        val ACTION_AUTO_TRACKING: String by lazy {\n            instance.packageName + \".ACTION_AUTO_TRACKING\"\n        }\n    }\n\n    override fun onCreate() {\n        super.onCreate()\n        instance = this\n    }\n}\n```\n\n## 2. State Management with Sealed Classes\n\n```kotlin\nsealed class AsleepState {\n    data object STATE_IDLE: AsleepState()\n    data object STATE_INITIALIZING : AsleepState()\n    data object STATE_INITIALIZED : AsleepState()\n    data object STATE_TRACKING_STARTING : AsleepState()\n    data object STATE_TRACKING_STARTED : AsleepState()\n    data object STATE_TRACKING_STOPPING : AsleepState()\n    data class STATE_ERROR(val errorCode: AsleepError) : AsleepState()\n}\n```\n\n## 3. ViewModel with Asleep Integration\n\n```kotlin\n@HiltViewModel\nclass AsleepViewModel @Inject constructor(\n    @ApplicationContext private val applicationContext: Application\n) : ViewModel() {\n\n    // State management\n    private var _asleepState = MutableStateFlow<AsleepState>(AsleepState.STATE_IDLE)\n    val asleepState: StateFlow<AsleepState> get() = _asleepState\n\n    // User and session data\n    private var _asleepUserId = MutableLiveData<String?>(null)\n    val asleepUserId: LiveData<String?> get() = _asleepUserId\n\n    private var _sessionId = MutableStateFlow<String?>(null)\n    val sessionId: StateFlow<String?> get() = _sessionId\n\n    // Initialize SDK\n    fun initAsleepConfig() {\n        if (_asleepState.value != AsleepState.STATE_IDLE) return\n\n        _asleepState.value = AsleepState.STATE_INITIALIZING\n        val storedUserId = PreferenceHelper.getAsleepUserId(applicationContext)\n\n        Asleep.initAsleepConfig(\n            context = applicationContext,\n            apiKey = Constants.ASLEEP_API_KEY,\n            userId = storedUserId,\n            baseUrl = Constants.BASE_URL,\n            callbackUrl = Constants.CALLBACK_URL,\n            service = Constants.SERVICE_NAME,\n            asleepConfigListener = object : Asleep.AsleepConfigListener {\n                override fun onFail(errorCode: Int, detail: String) {\n                    _asleepErrorCode.value = AsleepError(errorCode, detail)\n                    _asleepState.value = AsleepState.STATE_ERROR(AsleepError(errorCode, detail))\n                }\n\n                override fun onSuccess(userId: String?, asleepConfig: AsleepConfig?) {\n                    _asleepConfig.value = asleepConfig\n                    _asleepUserId.value = userId\n                    userId?.let { PreferenceHelper.putAsleepUserId(applicationContext, it) }\n                    _asleepState.value = AsleepState.STATE_INITIALIZED\n                }\n            }\n        )\n    }\n\n    // Tracking lifecycle\n    private val asleepTrackingListener = object: Asleep.AsleepTrackingListener {\n        override fun onStart(sessionId: String) {\n            _asleepState.value = AsleepState.STATE_TRACKING_STARTED\n        }\n\n        override fun onPerform(sequence: Int) {\n            _sequence.postValue(sequence)\n            if (sequence > 10 && (sequence % 10 == 1 || sequence - (_analyzedSeq ?: 0) > 10)) {\n                getCurrentSleepData(sequence)\n            }\n        }\n\n        override fun onFinish(sessionId: String?) {\n            _sessionId.value = sessionId\n            if (asleepState.value is AsleepState.STATE_ERROR) {\n                // Exit due to Error\n            } else {\n                // Successful Finish\n                _asleepState.value = AsleepState.STATE_IDLE\n            }\n        }\n\n        override fun onFail(errorCode: Int, detail: String) {\n            handleErrorOrWarning(AsleepError(errorCode, detail))\n        }\n    }\n\n    fun beginSleepTracking() {\n        if (_asleepState.value == AsleepState.STATE_INITIALIZED) {\n            _asleepState.value = AsleepState.STATE_TRACKING_STARTING\n            _asleepConfig.value?.let {\n                Asleep.beginSleepTracking(\n                    asleepConfig = it,\n                    asleepTrackingListener = asleepTrackingListener,\n                    notificationTitle = applicationContext.getString(R.string.app_name),\n                    notificationText = \"\",\n                    notificationIcon = R.mipmap.ic_app,\n                    notificationClass = MainActivity::class.java\n                )\n            }\n            PreferenceHelper.saveStartTrackingTime(applicationContext, System.currentTimeMillis())\n        }\n    }\n\n    fun endSleepTracking() {\n        if (Asleep.isSleepTrackingAlive(applicationContext)) {\n            _asleepState.value = AsleepState.STATE_TRACKING_STOPPING\n            Asleep.endSleepTracking()\n        }\n    }\n\n    fun connectSleepTracking() {\n        Asleep.connectSleepTracking(asleepTrackingListener)\n        _asleepUserId.value = PreferenceHelper.getAsleepUserId(applicationContext)\n        _asleepState.value = AsleepState.STATE_TRACKING_STARTED\n    }\n\n    // Error handling\n    fun handleErrorOrWarning(asleepError: AsleepError) {\n        val code = asleepError.code\n        val message = asleepError.message\n        if (isWarning(code)) {\n            // Log warning, continue tracking\n            _warningMessage.postValue(\"$existingMessage\\n${getCurrentTime()} $code - $message\")\n        } else {\n            // Critical error, stop tracking\n            _asleepErrorCode.postValue(asleepError)\n            _asleepState.value = AsleepState.STATE_ERROR(asleepError)\n        }\n    }\n}\n```\n\n## 4. Activity State Handling\n\n```kotlin\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n    private lateinit var binding: ActivityMainBinding\n    private lateinit var permissionManager: PermissionManager\n    private val asleepViewModel: AsleepViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        permissionManager = PermissionManager(this)\n        setPermissionObserver()\n        permissionManager.checkAllPermissions()\n\n        // State management with coroutines\n        lifecycleScope.launch {\n            asleepViewModel.asleepState.collect { state ->\n                when (state) {\n                    AsleepState.STATE_IDLE -> {\n                        checkRunningService()\n                    }\n                    AsleepState.STATE_INITIALIZING -> {\n                        binding.btnControlTracking.text = \"No user id\"\n                        binding.btnControlTracking.isEnabled = false\n                    }\n                    AsleepState.STATE_INITIALIZED -> {\n                        binding.btnControlTracking.apply {\n                            isEnabled = true\n                            text = getString(R.string.button_text_start_tracking)\n                            setOnClickListener {\n                                if (permissionManager.allPermissionsGranted.value == true) {\n                                    asleepViewModel.beginSleepTracking()\n                                } else {\n                                    permissionManager.checkAndRequestPermissions()\n                                }\n                            }\n                        }\n                    }\n                    AsleepState.STATE_TRACKING_STARTED -> {\n                        binding.btnControlTracking.apply {\n                            isEnabled = true\n                            text = getString(R.string.button_text_stop_tracking)\n                            setOnClickListener {\n                                if (asleepViewModel.isEnoughTrackingTime()) {\n                                    asleepViewModel.endSleepTracking()\n                                } else {\n                                    showInsufficientTimeDialog()\n                                }\n                            }\n                        }\n                    }\n                    is AsleepState.STATE_ERROR -> {\n                        binding.btnControlTracking.isEnabled = false\n                        showErrorDialog(supportFragmentManager)\n                    }\n                }\n            }\n        }\n    }\n\n    private fun checkRunningService() {\n        val isRunningService = Asleep.isSleepTrackingAlive(applicationContext)\n        if (isRunningService) {\n            asleepViewModel.connectSleepTracking()\n        } else {\n            asleepViewModel.initAsleepConfig()\n        }\n    }\n}\n```\n\n## 5. Permission Management\n\n```kotlin\nclass PermissionManager(private val activity: AppCompatActivity) {\n    private val context = activity.applicationContext\n\n    private val batteryOptimizationLauncher =\n        activity.registerForActivityResult(ActivityResultContracts.StartActivityForResult()) {\n            checkAndRequestPermissions()\n        }\n\n    private val micPermissionLauncher =\n        activity.registerForActivityResult(ActivityResultContracts.RequestPermission()) {\n            checkAndRequestPermissions()\n        }\n\n    private val notificationPermissionLauncher =\n        activity.registerForActivityResult(ActivityResultContracts.RequestPermission()) {\n            checkAndRequestPermissions()\n        }\n\n    private val _allPermissionsGranted = MutableLiveData(false)\n    val allPermissionsGranted: LiveData<Boolean> = _allPermissionsGranted\n\n    fun checkAndRequestPermissions() {\n        when {\n            !isBatteryOptimizationIgnored() -> {\n                val intent = Intent().apply {\n                    action = Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\n                    data = Uri.parse(\"package:${context.packageName}\")\n                }\n                batteryOptimizationLauncher.launch(intent)\n            }\n\n            context.checkSelfPermission(android.Manifest.permission.RECORD_AUDIO)\n                != android.content.pm.PackageManager.PERMISSION_GRANTED -> {\n                if (shouldShowRequestPermissionRationale(activity,\n                    android.Manifest.permission.RECORD_AUDIO)) {\n                    showPermissionDialog()\n                } else {\n                    micPermissionLauncher.launch(android.Manifest.permission.RECORD_AUDIO)\n                }\n            }\n\n            hasNotificationPermission().not() -> {\n                if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU ||\n                    shouldShowRequestPermissionRationale(activity,\n                        android.Manifest.permission.POST_NOTIFICATIONS)) {\n                    showPermissionDialog()\n                } else {\n                    notificationPermissionLauncher.launch(\n                        android.Manifest.permission.POST_NOTIFICATIONS)\n                }\n            }\n\n            else -> {\n                checkAllPermissions()\n            }\n        }\n    }\n\n    fun checkAllPermissions() {\n        _batteryOptimized.value = isBatteryOptimizationIgnored()\n        _micPermission.value = context.checkSelfPermission(\n            android.Manifest.permission.RECORD_AUDIO\n        ) == android.content.pm.PackageManager.PERMISSION_GRANTED\n        _notificationPermission.value = hasNotificationPermission()\n\n        _allPermissionsGranted.value =\n            (_batteryOptimized.value == true) &&\n            (_micPermission.value == true) &&\n            (_notificationPermission.value == true)\n    }\n\n    private fun isBatteryOptimizationIgnored(): Boolean {\n        val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager\n        val packageName = context.packageName\n        return powerManager.isIgnoringBatteryOptimizations(packageName)\n    }\n\n    private fun hasNotificationPermission(): Boolean {\n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            context.checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS)\n                == android.content.pm.PackageManager.PERMISSION_GRANTED\n        } else {\n            NotificationManagerCompat.from(context).areNotificationsEnabled()\n        }\n    }\n}\n```\n\n## 6. Error Handling Utilities\n\n```kotlin\ndata class AsleepError(val code: Int, val message: String)\n\ninternal fun isWarning(errorCode: Int): Boolean {\n    return errorCode in setOf(\n        AsleepErrorCode.ERR_AUDIO_SILENCED,\n        AsleepErrorCode.ERR_AUDIO_UNSILENCED,\n        AsleepErrorCode.ERR_UPLOAD_FAILED,\n    )\n}\n\ninternal fun getDebugMessage(errorCode: AsleepError): String {\n    if (isNetworkError(errorCode.message)) {\n        return \"Please check your network connection.\"\n    }\n    if (isMethodFormatInvalid(errorCode.message)) {\n        return \"Please check the method format, including argument values and types.\"\n    }\n\n    return when (errorCode.code) {\n        AsleepErrorCode.ERR_MIC_PERMISSION ->\n            \"The app does not have microphone access permission.\"\n        AsleepErrorCode.ERR_AUDIO ->\n            \"Another app is using the microphone, or there is an issue with the microphone settings.\"\n        AsleepErrorCode.ERR_INVALID_URL ->\n            \"Please check the URL format.\"\n        AsleepErrorCode.ERR_COMMON_EXPIRED ->\n            \"The API rate limit has been exceeded, or the plan has expired.\"\n        AsleepErrorCode.ERR_UPLOAD_FORBIDDEN ->\n            \"initAsleepConfig() was performed elsewhere with the same ID during the tracking.\"\n        AsleepErrorCode.ERR_UPLOAD_NOT_FOUND, AsleepErrorCode.ERR_CLOSE_NOT_FOUND ->\n            \"The session has already ended.\"\n        else -> \"\"\n    }\n}\n```\n",
        "skills/sleeptrack-android/references/complete_viewmodel_implementation.md": "# Complete ViewModel and Activity Implementation\n\nThis reference provides complete, production-ready implementations for Android MVVM architecture with the Asleep SDK.\n\n## Complete ViewModel with State Management\n\n```kotlin\n@HiltViewModel\nclass SleepTrackingViewModel @Inject constructor(\n    @ApplicationContext private val applicationContext: Application\n) : ViewModel() {\n\n    // State management\n    private val _trackingState = MutableStateFlow<AsleepState>(AsleepState.STATE_IDLE)\n    val trackingState: StateFlow<AsleepState> = _trackingState.asStateFlow()\n\n    private val _userId = MutableLiveData<String?>()\n    val userId: LiveData<String?> = _userId\n\n    private val _sessionId = MutableStateFlow<String?>(null)\n    val sessionId: StateFlow<String?> = _sessionId.asStateFlow()\n\n    private val _sequence = MutableLiveData<Int>()\n    val sequence: LiveData<Int> = _sequence\n\n    private var asleepConfig: AsleepConfig? = null\n\n    // Tracking listener\n    private val trackingListener = object : Asleep.AsleepTrackingListener {\n        override fun onStart(sessionId: String) {\n            _sessionId.value = sessionId\n            _trackingState.value = AsleepState.STATE_TRACKING_STARTED\n        }\n\n        override fun onPerform(sequence: Int) {\n            _sequence.postValue(sequence)\n\n            // Check real-time data every 10 sequences after sequence 10\n            if (sequence > 10 && sequence % 10 == 0) {\n                getCurrentSleepData()\n            }\n        }\n\n        override fun onFinish(sessionId: String?) {\n            _sessionId.value = sessionId\n            _trackingState.value = AsleepState.STATE_IDLE\n        }\n\n        override fun onFail(errorCode: Int, detail: String) {\n            handleError(AsleepError(errorCode, detail))\n        }\n    }\n\n    fun initializeSDK(userId: String) {\n        if (_trackingState.value != AsleepState.STATE_IDLE) return\n\n        _trackingState.value = AsleepState.STATE_INITIALIZING\n\n        Asleep.initAsleepConfig(\n            context = applicationContext,\n            apiKey = BuildConfig.ASLEEP_API_KEY,\n            userId = userId,\n            baseUrl = \"https://api.asleep.ai\",\n            callbackUrl = null,\n            service = applicationContext.getString(R.string.app_name),\n            asleepConfigListener = object : Asleep.AsleepConfigListener {\n                override fun onSuccess(userId: String?, config: AsleepConfig?) {\n                    asleepConfig = config\n                    _userId.value = userId\n                    _trackingState.value = AsleepState.STATE_INITIALIZED\n                }\n\n                override fun onFail(errorCode: Int, detail: String) {\n                    _trackingState.value = AsleepState.STATE_ERROR(\n                        AsleepError(errorCode, detail)\n                    )\n                }\n            }\n        )\n    }\n\n    fun startTracking() {\n        val config = asleepConfig ?: return\n        if (_trackingState.value != AsleepState.STATE_INITIALIZED) return\n\n        _trackingState.value = AsleepState.STATE_TRACKING_STARTING\n\n        Asleep.beginSleepTracking(\n            asleepConfig = config,\n            asleepTrackingListener = trackingListener,\n            notificationTitle = \"Sleep Tracking\",\n            notificationText = \"Recording your sleep\",\n            notificationIcon = R.drawable.ic_notification,\n            notificationClass = MainActivity::class.java\n        )\n    }\n\n    fun stopTracking() {\n        if (Asleep.isSleepTrackingAlive(applicationContext)) {\n            _trackingState.value = AsleepState.STATE_TRACKING_STOPPING\n            Asleep.endSleepTracking()\n        }\n    }\n\n    fun reconnectToTracking() {\n        if (Asleep.isSleepTrackingAlive(applicationContext)) {\n            Asleep.connectSleepTracking(trackingListener)\n            _trackingState.value = AsleepState.STATE_TRACKING_STARTED\n        }\n    }\n\n    private fun getCurrentSleepData() {\n        Asleep.getCurrentSleepData(\n            asleepSleepDataListener = object : Asleep.AsleepSleepDataListener {\n                override fun onSleepDataReceived(session: Session) {\n                    // Process real-time sleep data\n                    val currentStage = session.sleepStages?.lastOrNull()\n                    Log.d(\"Sleep\", \"Current stage: $currentStage\")\n                }\n\n                override fun onFail(errorCode: Int, detail: String) {\n                    Log.e(\"Sleep\", \"Failed to get data: $errorCode\")\n                }\n            }\n        )\n    }\n\n    private fun handleError(error: AsleepError) {\n        if (isWarning(error.code)) {\n            // Log warning but continue tracking\n            Log.w(\"Sleep\", \"Warning: ${error.code} - ${error.message}\")\n        } else {\n            // Critical error - stop tracking\n            _trackingState.value = AsleepState.STATE_ERROR(error)\n        }\n    }\n}\n```\n\n## Complete Activity Implementation\n\n```kotlin\n@AndroidEntryPoint\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n    private val viewModel: SleepTrackingViewModel by viewModels()\n    private lateinit var permissionManager: PermissionManager\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        permissionManager = PermissionManager(this)\n\n        setupUI()\n        observeState()\n        checkExistingSession()\n    }\n\n    private fun setupUI() {\n        binding.btnStartStop.setOnClickListener {\n            when (viewModel.trackingState.value) {\n                AsleepState.STATE_INITIALIZED -> {\n                    if (permissionManager.allPermissionsGranted.value == true) {\n                        viewModel.startTracking()\n                    } else {\n                        permissionManager.requestPermissions()\n                    }\n                }\n                AsleepState.STATE_TRACKING_STARTED -> {\n                    viewModel.stopTracking()\n                }\n                else -> {\n                    // Button disabled\n                }\n            }\n        }\n    }\n\n    private fun observeState() {\n        lifecycleScope.launch {\n            viewModel.trackingState.collect { state ->\n                updateUI(state)\n            }\n        }\n\n        viewModel.sequence.observe(this) { sequence ->\n            binding.tvSequence.text = \"Sequence: $sequence\"\n        }\n    }\n\n    private fun updateUI(state: AsleepState) {\n        when (state) {\n            AsleepState.STATE_IDLE -> {\n                binding.btnStartStop.isEnabled = false\n                binding.btnStartStop.text = \"Initializing...\"\n            }\n            AsleepState.STATE_INITIALIZED -> {\n                binding.btnStartStop.isEnabled = true\n                binding.btnStartStop.text = \"Start Tracking\"\n            }\n            AsleepState.STATE_TRACKING_STARTED -> {\n                binding.btnStartStop.isEnabled = true\n                binding.btnStartStop.text = \"Stop Tracking\"\n                binding.trackingIndicator.visibility = View.VISIBLE\n            }\n            AsleepState.STATE_TRACKING_STOPPING -> {\n                binding.btnStartStop.isEnabled = false\n                binding.btnStartStop.text = \"Stopping...\"\n            }\n            is AsleepState.STATE_ERROR -> {\n                showErrorDialog(state.errorCode)\n            }\n            else -> {}\n        }\n    }\n\n    private fun checkExistingSession() {\n        if (Asleep.isSleepTrackingAlive(applicationContext)) {\n            viewModel.reconnectToTracking()\n        } else {\n            viewModel.initializeSDK(getUserId())\n        }\n    }\n\n    private fun getUserId(): String {\n        // Load from SharedPreferences or generate\n        val prefs = getSharedPreferences(\"asleep\", MODE_PRIVATE)\n        return prefs.getString(\"user_id\", null) ?: run {\n            val newId = UUID.randomUUID().toString()\n            prefs.edit().putString(\"user_id\", newId).apply()\n            newId\n        }\n    }\n}\n```\n\n## Complete PermissionManager\n\n```kotlin\nclass PermissionManager(private val activity: AppCompatActivity) {\n    private val context = activity.applicationContext\n\n    // Permission launchers\n    private val batteryOptimizationLauncher =\n        activity.registerForActivityResult(\n            ActivityResultContracts.StartActivityForResult()\n        ) {\n            checkAndRequestNext()\n        }\n\n    private val micPermissionLauncher =\n        activity.registerForActivityResult(\n            ActivityResultContracts.RequestPermission()\n        ) { granted ->\n            if (granted) checkAndRequestNext()\n            else showPermissionDeniedDialog(\"Microphone\")\n        }\n\n    private val notificationPermissionLauncher =\n        activity.registerForActivityResult(\n            ActivityResultContracts.RequestPermission()\n        ) { granted ->\n            if (granted) checkAndRequestNext()\n            else showPermissionDeniedDialog(\"Notifications\")\n        }\n\n    private val _allPermissionsGranted = MutableLiveData(false)\n    val allPermissionsGranted: LiveData<Boolean> = _allPermissionsGranted\n\n    fun requestPermissions() {\n        checkAndRequestNext()\n    }\n\n    private fun checkAndRequestNext() {\n        when {\n            !isBatteryOptimizationIgnored() -> requestBatteryOptimization()\n            !hasMicrophonePermission() -> requestMicrophone()\n            !hasNotificationPermission() -> requestNotification()\n            else -> {\n                _allPermissionsGranted.value = true\n            }\n        }\n    }\n\n    private fun requestBatteryOptimization() {\n        val intent = Intent().apply {\n            action = Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\n            data = Uri.parse(\"package:${context.packageName}\")\n        }\n        batteryOptimizationLauncher.launch(intent)\n    }\n\n    private fun requestMicrophone() {\n        if (ActivityCompat.shouldShowRequestPermissionRationale(\n                activity,\n                Manifest.permission.RECORD_AUDIO\n            )) {\n            showPermissionRationale(\n                \"Microphone access is required to record sleep sounds\"\n            )\n        } else {\n            micPermissionLauncher.launch(Manifest.permission.RECORD_AUDIO)\n        }\n    }\n\n    private fun requestNotification() {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            notificationPermissionLauncher.launch(\n                Manifest.permission.POST_NOTIFICATIONS\n            )\n        } else {\n            checkAndRequestNext()\n        }\n    }\n\n    private fun isBatteryOptimizationIgnored(): Boolean {\n        val pm = context.getSystemService(Context.POWER_SERVICE) as PowerManager\n        return pm.isIgnoringBatteryOptimizations(context.packageName)\n    }\n\n    private fun hasMicrophonePermission(): Boolean {\n        return ContextCompat.checkSelfPermission(\n            context,\n            Manifest.permission.RECORD_AUDIO\n        ) == PackageManager.PERMISSION_GRANTED\n    }\n\n    private fun hasNotificationPermission(): Boolean {\n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            ContextCompat.checkSelfPermission(\n                context,\n                Manifest.permission.POST_NOTIFICATIONS\n            ) == PackageManager.PERMISSION_GRANTED\n        } else {\n            NotificationManagerCompat.from(context).areNotificationsEnabled()\n        }\n    }\n\n    private fun showPermissionRationale(message: String) {\n        AlertDialog.Builder(activity)\n            .setTitle(\"Permission Required\")\n            .setMessage(message)\n            .setPositiveButton(\"OK\") { _, _ ->\n                checkAndRequestNext()\n            }\n            .show()\n    }\n\n    private fun showPermissionDeniedDialog(permissionName: String) {\n        AlertDialog.Builder(activity)\n            .setTitle(\"Permission Denied\")\n            .setMessage(\"$permissionName permission is required for sleep tracking. Please grant it in app settings.\")\n            .setPositiveButton(\"Settings\") { _, _ ->\n                val intent = Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {\n                    data = Uri.parse(\"package:${context.packageName}\")\n                }\n                activity.startActivity(intent)\n            }\n            .setNegativeButton(\"Cancel\", null)\n            .show()\n    }\n}\n```\n\n## Minimal Production Templates\n\n### Minimal ViewModel\n\n```kotlin\n@HiltViewModel\nclass SleepTrackingViewModel @Inject constructor(\n    @ApplicationContext private val app: Application\n) : ViewModel() {\n\n    private val _trackingState = MutableStateFlow<AsleepState>(AsleepState.STATE_IDLE)\n    val trackingState: StateFlow<AsleepState> = _trackingState\n\n    private var config: AsleepConfig? = null\n\n    private val listener = object : Asleep.AsleepTrackingListener {\n        override fun onStart(sessionId: String) {\n            _trackingState.value = AsleepState.STATE_TRACKING_STARTED\n        }\n        override fun onPerform(sequence: Int) {}\n        override fun onFinish(sessionId: String?) {\n            _trackingState.value = AsleepState.STATE_IDLE\n        }\n        override fun onFail(errorCode: Int, detail: String) {\n            _trackingState.value = AsleepState.STATE_ERROR(AsleepError(errorCode, detail))\n        }\n    }\n\n    fun initializeSDK(userId: String) {\n        Asleep.initAsleepConfig(\n            context = app,\n            apiKey = BuildConfig.ASLEEP_API_KEY,\n            userId = userId,\n            baseUrl = \"https://api.asleep.ai\",\n            callbackUrl = null,\n            service = \"MyApp\",\n            asleepConfigListener = object : Asleep.AsleepConfigListener {\n                override fun onSuccess(userId: String?, asleepConfig: AsleepConfig?) {\n                    config = asleepConfig\n                    _trackingState.value = AsleepState.STATE_INITIALIZED\n                }\n                override fun onFail(errorCode: Int, detail: String) {\n                    _trackingState.value = AsleepState.STATE_ERROR(AsleepError(errorCode, detail))\n                }\n            }\n        )\n    }\n\n    fun startTracking() {\n        config?.let {\n            Asleep.beginSleepTracking(\n                asleepConfig = it,\n                asleepTrackingListener = listener,\n                notificationTitle = \"Sleep Tracking\",\n                notificationText = \"Active\",\n                notificationIcon = R.drawable.ic_notification,\n                notificationClass = SleepActivity::class.java\n            )\n        }\n    }\n\n    fun stopTracking() {\n        Asleep.endSleepTracking()\n    }\n}\n```\n\n### Minimal Activity\n\n```kotlin\n@AndroidEntryPoint\nclass SleepActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivitySleepBinding\n    private val viewModel: SleepTrackingViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivitySleepBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        // Initialize SDK\n        viewModel.initializeSDK(loadUserId())\n\n        // Setup button\n        binding.btnTrack.setOnClickListener {\n            when (viewModel.trackingState.value) {\n                AsleepState.STATE_INITIALIZED -> viewModel.startTracking()\n                AsleepState.STATE_TRACKING_STARTED -> viewModel.stopTracking()\n                else -> {}\n            }\n        }\n\n        // Observe state\n        lifecycleScope.launch {\n            viewModel.trackingState.collect { state ->\n                binding.btnTrack.text = when (state) {\n                    AsleepState.STATE_INITIALIZED -> \"Start\"\n                    AsleepState.STATE_TRACKING_STARTED -> \"Stop\"\n                    else -> \"Loading...\"\n                }\n            }\n        }\n    }\n\n    private fun loadUserId(): String {\n        val prefs = getSharedPreferences(\"app\", MODE_PRIVATE)\n        return prefs.getString(\"user_id\", null) ?: UUID.randomUUID().toString().also {\n            prefs.edit().putString(\"user_id\", it).apply()\n        }\n    }\n}\n```\n\n## State Management Pattern\n\nDefine states using sealed classes:\n\n```kotlin\nsealed class AsleepState {\n    data object STATE_IDLE: AsleepState()\n    data object STATE_INITIALIZING : AsleepState()\n    data object STATE_INITIALIZED : AsleepState()\n    data object STATE_TRACKING_STARTING : AsleepState()\n    data object STATE_TRACKING_STARTED : AsleepState()\n    data object STATE_TRACKING_STOPPING : AsleepState()\n    data class STATE_ERROR(val errorCode: AsleepError) : AsleepState()\n}\n\ndata class AsleepError(val code: Int, val message: String)\n```\n\n## Real-Time Data Access\n\n```kotlin\n// In ViewModel\nprivate var lastCheckedSequence = 0\n\nprivate val trackingListener = object : Asleep.AsleepTrackingListener {\n    override fun onPerform(sequence: Int) {\n        _sequence.postValue(sequence)\n\n        // Check after sequence 10, then every 10 sequences\n        if (sequence > 10 && sequence - lastCheckedSequence >= 10) {\n            getCurrentSleepData(sequence)\n        }\n    }\n    // ... other callbacks\n}\n\nprivate fun getCurrentSleepData(sequence: Int) {\n    Asleep.getCurrentSleepData(\n        asleepSleepDataListener = object : Asleep.AsleepSleepDataListener {\n            override fun onSleepDataReceived(session: Session) {\n                lastCheckedSequence = sequence\n\n                // Extract current data\n                val currentSleepStage = session.sleepStages?.lastOrNull()\n                val currentSnoringStage = session.snoringStages?.lastOrNull()\n\n                _currentSleepStage.postValue(currentSleepStage)\n\n                Log.d(\"Sleep\", \"Current stage: $currentSleepStage\")\n                Log.d(\"Sleep\", \"Snoring: $currentSnoringStage\")\n            }\n\n            override fun onFail(errorCode: Int, detail: String) {\n                Log.e(\"Sleep\", \"Failed to get current data: $errorCode\")\n            }\n        }\n    )\n}\n```\n",
        "skills/sleeptrack-android/references/gradle_setup.md": "# Gradle Setup for Asleep SDK\n\n## Project-level build.gradle\n\n```gradle\nbuildscript {\n    dependencies {\n        classpath 'com.google.dagger:hilt-android-gradle-plugin:2.48'\n    }\n}\n\nplugins {\n    id 'com.android.application' version '8.2.2' apply false\n    id 'com.android.library' version '8.2.2' apply false\n    id 'org.jetbrains.kotlin.android' version '1.9.24' apply false\n    id 'com.google.dagger.hilt.android' version '2.48' apply false\n}\n```\n\n## App-level build.gradle\n\n```gradle\nplugins {\n    id 'com.android.application'\n    id 'org.jetbrains.kotlin.android'\n    id 'kotlin-kapt'\n    id 'dagger.hilt.android.plugin'\n}\n\nandroid {\n    namespace 'com.example.yourapp'\n    compileSdk 34\n\n    defaultConfig {\n        applicationId \"com.example.yourapp\"\n        minSdk 24  // Minimum SDK 24 required for Asleep SDK\n        targetSdk 34\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n\n        // Store API key securely in local.properties\n        Properties properties = new Properties()\n        properties.load(project.rootProject.file('local.properties').newDataInputStream())\n        buildConfigField \"String\", \"ASLEEP_API_KEY\", properties['asleep_api_key']\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_17\n        targetCompatibility JavaVersion.VERSION_17\n    }\n\n    kotlinOptions {\n        jvmTarget = '17'\n    }\n\n    buildFeatures {\n        viewBinding true\n        buildConfig = true\n    }\n}\n\ndependencies {\n    // Core Android dependencies\n    implementation 'androidx.core:core-ktx:1.12.0'\n    implementation 'androidx.appcompat:appcompat:1.6.1'\n    implementation 'com.google.android.material:material:1.11.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'\n\n    // Hilt for dependency injection\n    implementation \"com.google.dagger:hilt-android:2.48\"\n    kapt \"com.google.dagger:hilt-compiler:2.48\"\n\n    // Activity and Fragment KTX\n    implementation 'androidx.activity:activity-ktx:1.8.2'\n    implementation 'androidx.fragment:fragment-ktx:1.6.2'\n    implementation 'androidx.lifecycle:lifecycle-service:2.7.0'\n\n    // Required for Asleep SDK\n    implementation 'com.squareup.okhttp3:okhttp:4.11.0'\n    debugImplementation 'com.squareup.okhttp3:logging-interceptor:4.10.0'\n    implementation 'com.google.code.gson:gson:2.10'\n\n    // Asleep SDK (check for latest version)\n    implementation 'ai.asleep:asleepsdk:3.1.4'\n\n    // Testing\n    testImplementation 'junit:junit:4.13.2'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'\n}\n```\n\n## local.properties\n\n```properties\n# Store your Asleep API key securely (never commit this file to version control)\nasleep_api_key=\"your_api_key_here\"\n```\n\n## Key Requirements\n\n1. **Minimum SDK**: 24 (Android 7.0)\n2. **Target SDK**: 34 recommended\n3. **Java Version**: 17\n4. **Kotlin Version**: 1.9.24 or higher\n5. **Gradle Plugin**: 8.2.2 or higher\n\n## Dependency Notes\n\n- **OkHttp**: Required for network operations\n- **Gson**: Required for JSON parsing\n- **Hilt**: Recommended for dependency injection (not strictly required)\n- **ViewBinding**: Recommended for type-safe view access\n\n## ProGuard Rules\n\nIf using ProGuard/R8, add these rules to `proguard-rules.pro`:\n\n```proguard\n# Asleep SDK\n-keep class ai.asleep.asleepsdk.** { *; }\n-dontwarn ai.asleep.asleepsdk.**\n\n# Gson\n-keepattributes Signature\n-keepattributes *Annotation*\n-dontwarn sun.misc.**\n-keep class * implements com.google.gson.TypeAdapter\n-keep class * implements com.google.gson.TypeAdapterFactory\n-keep class * implements com.google.gson.JsonSerializer\n-keep class * implements com.google.gson.JsonDeserializer\n\n# OkHttp\n-dontwarn okhttp3.**\n-dontwarn okio.**\n-keepnames class okhttp3.internal.publicsuffix.PublicSuffixDatabase\n```\n",
        "skills/sleeptrack-android/references/testing_guide.md": "# Testing Guide for Android Sleep Tracking\n\nThis guide provides comprehensive testing patterns for Android sleep tracking applications.\n\n## Unit Testing\n\n### ViewModel Testing Setup\n\n```kotlin\n@ExperimentalCoroutinesApi\nclass SleepTrackingViewModelTest {\n\n    @get:Rule\n    val instantExecutorRule = InstantTaskExecutorRule()\n\n    @get:Rule\n    val mainDispatcherRule = MainDispatcherRule()\n\n    private lateinit var viewModel: SleepTrackingViewModel\n    private lateinit var mockContext: Application\n\n    @Before\n    fun setup() {\n        mockContext = mock(Application::class.java)\n        viewModel = SleepTrackingViewModel(mockContext)\n    }\n\n    @Test\n    fun `initializeSDK should transition to INITIALIZED on success`() = runTest {\n        // Given\n        val userId = \"test_user_123\"\n\n        // When\n        viewModel.initializeSDK(userId)\n\n        // Simulate success callback\n        // (requires mocking Asleep SDK)\n\n        // Then\n        assertEquals(AsleepState.STATE_INITIALIZED, viewModel.trackingState.value)\n        assertEquals(userId, viewModel.userId.value)\n    }\n\n    @Test\n    fun `startTracking should fail if not initialized`() = runTest {\n        // When\n        viewModel.startTracking()\n\n        // Then\n        assertNotEquals(AsleepState.STATE_TRACKING_STARTED, viewModel.trackingState.value)\n    }\n\n    @Test\n    fun `stopTracking should transition state correctly`() = runTest {\n        // Given\n        viewModel.initializeSDK(\"test_user\")\n        // Simulate initialization success\n        viewModel.startTracking()\n        // Simulate tracking started\n\n        // When\n        viewModel.stopTracking()\n\n        // Then\n        assertEquals(AsleepState.STATE_TRACKING_STOPPING, viewModel.trackingState.value)\n    }\n\n    @Test\n    fun `error handling should classify warnings correctly`() = runTest {\n        // Given\n        val warningError = AsleepError(\n            AsleepErrorCode.ERR_AUDIO_SILENCED,\n            \"Microphone temporarily unavailable\"\n        )\n\n        // When\n        val isWarning = isWarning(warningError.code)\n\n        // Then\n        assertTrue(isWarning)\n    }\n}\n```\n\n### MainDispatcherRule for Coroutines\n\n```kotlin\n@ExperimentalCoroutinesApi\nclass MainDispatcherRule(\n    private val dispatcher: TestDispatcher = UnconfinedTestDispatcher()\n) : TestWatcher() {\n\n    override fun starting(description: Description) {\n        Dispatchers.setMain(dispatcher)\n    }\n\n    override fun finished(description: Description) {\n        Dispatchers.resetMain()\n    }\n}\n```\n\n### Testing StateFlow\n\n```kotlin\n@Test\nfun `trackingState should emit correct states during tracking lifecycle`() = runTest {\n    // Given\n    val states = mutableListOf<AsleepState>()\n    val job = launch {\n        viewModel.trackingState.collect { state ->\n            states.add(state)\n        }\n    }\n\n    // When\n    viewModel.initializeSDK(\"test_user\")\n    advanceUntilIdle()\n\n    // Then\n    assertTrue(states.contains(AsleepState.STATE_INITIALIZING))\n    assertTrue(states.contains(AsleepState.STATE_INITIALIZED))\n\n    job.cancel()\n}\n```\n\n## Integration Testing\n\n### Activity Testing\n\n```kotlin\n@RunWith(AndroidJUnit4::class)\nclass SleepTrackingIntegrationTest {\n\n    @get:Rule\n    val activityRule = ActivityScenarioRule(MainActivity::class.java)\n\n    @Test\n    fun trackingFlow_complete() {\n        // Check permissions granted\n        onView(withId(R.id.btn_start_stop))\n            .check(matches(isEnabled()))\n\n        // Start tracking\n        onView(withId(R.id.btn_start_stop))\n            .perform(click())\n\n        // Verify tracking started\n        onView(withId(R.id.tracking_indicator))\n            .check(matches(isDisplayed()))\n\n        // Wait for sequences\n        Thread.sleep(60000) // 1 minute\n\n        // Stop tracking\n        onView(withId(R.id.btn_start_stop))\n            .perform(click())\n\n        // Verify stopped\n        onView(withId(R.id.tracking_indicator))\n            .check(matches(not(isDisplayed())))\n    }\n\n    @Test\n    fun errorDisplay_showsCorrectMessage() {\n        // Simulate error state\n        // Verify error message displayed\n        onView(withId(R.id.error_text))\n            .check(matches(isDisplayed()))\n            .check(matches(withText(containsString(\"Microphone permission\"))))\n    }\n}\n```\n\n### Fragment Testing\n\n```kotlin\n@RunWith(AndroidJUnit4::class)\nclass TrackingFragmentTest {\n\n    @Test\n    fun fragmentLaunch_displaysCorrectUI() {\n        // Launch fragment in container\n        launchFragmentInContainer<TrackingFragment>(\n            themeResId = R.style.Theme_SleepTracking\n        )\n\n        // Verify initial UI state\n        onView(withId(R.id.btnTrack))\n            .check(matches(isDisplayed()))\n            .check(matches(withText(\"Start Tracking\")))\n    }\n\n    @Test\n    fun clickStartButton_requestsPermissions() {\n        launchFragmentInContainer<TrackingFragment>()\n\n        // Click start button\n        onView(withId(R.id.btnTrack))\n            .perform(click())\n\n        // Verify permission dialog or state change\n        // This depends on permission state\n    }\n}\n```\n\n## Compose UI Testing\n\n### Basic Compose Testing\n\n```kotlin\n@RunWith(AndroidJUnit4::class)\nclass SleepTrackingScreenTest {\n\n    @get:Rule\n    val composeTestRule = createComposeRule()\n\n    @Test\n    fun initialState_showsStartButton() {\n        // Given\n        val viewModel = mockViewModel(AsleepState.STATE_INITIALIZED)\n\n        // When\n        composeTestRule.setContent {\n            SleepTrackingScreen(viewModel = viewModel)\n        }\n\n        // Then\n        composeTestRule.onNodeWithText(\"Start Sleep Tracking\")\n            .assertIsDisplayed()\n    }\n\n    @Test\n    fun trackingActive_showsStopButton() {\n        // Given\n        val viewModel = mockViewModel(AsleepState.STATE_TRACKING_STARTED)\n\n        // When\n        composeTestRule.setContent {\n            SleepTrackingScreen(viewModel = viewModel)\n        }\n\n        // Then\n        composeTestRule.onNodeWithText(\"Stop Tracking\")\n            .assertIsDisplayed()\n        composeTestRule.onNodeWithText(\"Tracking in progress\")\n            .assertIsDisplayed()\n    }\n\n    @Test\n    fun errorState_displaysErrorMessage() {\n        // Given\n        val error = AsleepError(AsleepErrorCode.ERR_MIC_PERMISSION, \"Permission denied\")\n        val viewModel = mockViewModel(AsleepState.STATE_ERROR(error))\n\n        // When\n        composeTestRule.setContent {\n            SleepTrackingScreen(viewModel = viewModel)\n        }\n\n        // Then\n        composeTestRule.onNodeWithText(\"Microphone permission is required\")\n            .assertIsDisplayed()\n    }\n\n    private fun mockViewModel(state: AsleepState): SleepTrackingViewModel {\n        return mock(SleepTrackingViewModel::class.java).apply {\n            whenever(trackingState).thenReturn(MutableStateFlow(state))\n            whenever(sequence).thenReturn(MutableLiveData(0))\n        }\n    }\n}\n```\n\n### Testing User Interactions\n\n```kotlin\n@Test\nfun clickStartButton_startsTracking() {\n    // Given\n    val viewModel = SleepTrackingViewModel(mockContext)\n    composeTestRule.setContent {\n        SleepTrackingScreen(viewModel = viewModel)\n    }\n\n    // When\n    composeTestRule.onNodeWithText(\"Start Sleep Tracking\")\n        .performClick()\n\n    // Then\n    verify(viewModel).startTracking()\n}\n\n@Test\nfun clickStopButton_stopsTracking() {\n    // Given\n    val viewModel = mockViewModel(AsleepState.STATE_TRACKING_STARTED)\n    composeTestRule.setContent {\n        SleepTrackingScreen(viewModel = viewModel)\n    }\n\n    // When\n    composeTestRule.onNodeWithText(\"Stop Tracking\")\n        .performClick()\n\n    // Then\n    verify(viewModel).stopTracking()\n}\n```\n\n## Permission Testing\n\n### Testing Permission Manager\n\n```kotlin\n@RunWith(AndroidJUnit4::class)\nclass PermissionManagerTest {\n\n    private lateinit var activity: AppCompatActivity\n    private lateinit var permissionManager: PermissionManager\n\n    @Before\n    fun setup() {\n        val scenario = ActivityScenario.launch(TestActivity::class.java)\n        scenario.onActivity { act ->\n            activity = act\n            permissionManager = PermissionManager(activity)\n        }\n    }\n\n    @Test\n    fun requestPermissions_checksAllPermissions() {\n        // When\n        permissionManager.requestPermissions()\n\n        // Then\n        // Verify permission checks called\n        verify(permissionManager).isBatteryOptimizationIgnored()\n        verify(permissionManager).hasMicrophonePermission()\n    }\n\n    @Test\n    fun allPermissionsGranted_updatesLiveData() {\n        // Given\n        // Mock all permissions as granted\n\n        // When\n        permissionManager.checkAndRequestNext()\n\n        // Then\n        assertTrue(permissionManager.allPermissionsGranted.value == true)\n    }\n}\n```\n\n## Instrumentation Testing\n\n### Testing Foreground Service\n\n```kotlin\n@RunWith(AndroidJUnit4::class)\nclass ForegroundServiceTest {\n\n    @get:Rule\n    val serviceRule = ServiceTestRule()\n\n    @Test\n    fun trackingService_startsForeground() {\n        // Given\n        val context = InstrumentationRegistry.getInstrumentation().targetContext\n\n        // When\n        val serviceIntent = Intent(context, SleepTrackingService::class.java)\n        serviceRule.startService(serviceIntent)\n\n        // Then\n        // Verify service is in foreground\n        assertTrue(isServiceForeground(context, SleepTrackingService::class.java))\n    }\n\n    private fun isServiceForeground(context: Context, serviceClass: Class<*>): Boolean {\n        val manager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager\n        return manager.getRunningServices(Integer.MAX_VALUE)\n            .any { it.service.className == serviceClass.name && it.foreground }\n    }\n}\n```\n\n## Mock SDK Testing\n\n### Creating SDK Mocks\n\n```kotlin\nclass MockAsleepSDK {\n    companion object {\n        fun mockInitSuccess(userId: String, listener: Asleep.AsleepConfigListener) {\n            val config = mock(AsleepConfig::class.java)\n            listener.onSuccess(userId, config)\n        }\n\n        fun mockInitFail(errorCode: Int, listener: Asleep.AsleepConfigListener) {\n            listener.onFail(errorCode, \"Test error\")\n        }\n\n        fun mockTrackingStart(sessionId: String, listener: Asleep.AsleepTrackingListener) {\n            listener.onStart(sessionId)\n        }\n\n        fun mockTrackingPerform(sequence: Int, listener: Asleep.AsleepTrackingListener) {\n            listener.onPerform(sequence)\n        }\n    }\n}\n```\n\n### Using Mocks in Tests\n\n```kotlin\n@Test\nfun initializeSDK_successFlow() = runTest {\n    // Given\n    val userId = \"test_user\"\n\n    // Mock Asleep SDK\n    MockAsleepSDK.mockInitSuccess(userId, any())\n\n    // When\n    viewModel.initializeSDK(userId)\n    advanceUntilIdle()\n\n    // Then\n    assertEquals(AsleepState.STATE_INITIALIZED, viewModel.trackingState.value)\n}\n```\n\n## Test Dependencies\n\nAdd to your `build.gradle`:\n\n```gradle\ndependencies {\n    // Unit testing\n    testImplementation 'junit:junit:4.13.2'\n    testImplementation 'org.mockito:mockito-core:5.3.1'\n    testImplementation 'org.mockito.kotlin:mockito-kotlin:5.0.0'\n    testImplementation 'androidx.arch.core:core-testing:2.2.0'\n    testImplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3'\n\n    // Android instrumentation testing\n    androidTestImplementation 'androidx.test.ext:junit:1.1.5'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'\n    androidTestImplementation 'androidx.test:runner:1.5.2'\n    androidTestImplementation 'androidx.test:rules:1.5.0'\n\n    // Fragment testing\n    debugImplementation 'androidx.fragment:fragment-testing:1.6.1'\n\n    // Compose testing\n    androidTestImplementation 'androidx.compose.ui:ui-test-junit4:1.5.4'\n    debugImplementation 'androidx.compose.ui:ui-test-manifest:1.5.4'\n}\n```\n\n## Testing Best Practices\n\n1. **Unit Tests**: Test ViewModels, business logic, and state management\n2. **Integration Tests**: Test UI interactions and component integration\n3. **Use Test Rules**: Leverage JUnit rules for setup/teardown\n4. **Mock External Dependencies**: Mock Asleep SDK calls for predictable tests\n5. **Test Coroutines**: Use `runTest` and `TestDispatcher` for coroutine testing\n6. **Test Permissions**: Verify permission flows but avoid actual permission dialogs\n7. **Compose Tests**: Use semantic properties and avoid hardcoded strings\n8. **CI/CD**: Run tests in continuous integration pipeline\n\n## Debugging Tests\n\n### Enable Debug Logging\n\n```kotlin\n@Before\nfun setup() {\n    // Enable debug logging for tests\n    Log.setDebug(true)\n}\n```\n\n### Capture Screenshots on Failure\n\n```kotlin\n@Rule\nfun testRule = TestRule { base, description ->\n    object : Statement() {\n        override fun evaluate() {\n            try {\n                base.evaluate()\n            } catch (t: Throwable) {\n                // Capture screenshot\n                Screenshot.capture()\n                throw t\n            }\n        }\n    }\n}\n```\n\n## Test Coverage\n\nAim for:\n- **Unit Tests**: 80%+ coverage of ViewModels and business logic\n- **Integration Tests**: Key user flows and state transitions\n- **UI Tests**: Critical user interactions\n\nUse JaCoCo for coverage reporting:\n\n```gradle\napply plugin: 'jacoco'\n\njacoco {\n    toolVersion = \"0.8.10\"\n}\n```\n",
        "skills/sleeptrack-android/references/ui_implementation_guide.md": "# UI Implementation Guide\n\nThis guide provides complete UI implementations for Android sleep tracking with both ViewBinding and Jetpack Compose.\n\n## ViewBinding Implementation\n\n### Complete Fragment with ViewBinding\n\n```kotlin\nclass TrackingFragment : Fragment() {\n    private var _binding: FragmentTrackingBinding? = null\n    private val binding get() = _binding!!\n    private val viewModel: SleepTrackingViewModel by viewModels()\n\n    override fun onCreateView(\n        inflater: LayoutInflater,\n        container: ViewGroup?,\n        savedInstanceState: Bundle?\n    ): View {\n        _binding = FragmentTrackingBinding.inflate(inflater, container, false)\n        return binding.root\n    }\n\n    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n        super.onViewCreated(view, savedInstanceState)\n\n        binding.btnTrack.setOnClickListener {\n            viewModel.startTracking()\n        }\n\n        viewLifecycleOwner.lifecycleScope.launch {\n            viewModel.trackingState.collect { state ->\n                when (state) {\n                    AsleepState.STATE_TRACKING_STARTED -> {\n                        binding.progressIndicator.visibility = View.VISIBLE\n                        binding.btnTrack.text = \"Stop Tracking\"\n                    }\n                    AsleepState.STATE_INITIALIZED -> {\n                        binding.progressIndicator.visibility = View.GONE\n                        binding.btnTrack.text = \"Start Tracking\"\n                    }\n                    else -> {}\n                }\n            }\n        }\n    }\n\n    override fun onDestroyView() {\n        super.onDestroyView()\n        _binding = null\n    }\n}\n```\n\n### Layout XML (fragment_tracking.xml)\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<androidx.constraintlayout.widget.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:padding=\"16dp\">\n\n    <ProgressBar\n        android:id=\"@+id/progressIndicator\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:visibility=\"gone\"\n        app:layout_constraintTop_toTopOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toTopOf=\"@id/btnTrack\" />\n\n    <TextView\n        android:id=\"@+id/tvSequence\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Sequence: 0\"\n        android:textSize=\"18sp\"\n        app:layout_constraintTop_toBottomOf=\"@id/progressIndicator\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\"\n        app:layout_constraintBottom_toTopOf=\"@id/btnTrack\" />\n\n    <Button\n        android:id=\"@+id/btnTrack\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Start Tracking\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintStart_toStartOf=\"parent\"\n        app:layout_constraintEnd_toEndOf=\"parent\" />\n\n</androidx.constraintlayout.widget.ConstraintLayout>\n```\n\n## Jetpack Compose Implementation\n\n### Complete Tracking Screen\n\n```kotlin\n@Composable\nfun SleepTrackingScreen(\n    viewModel: SleepTrackingViewModel = hiltViewModel()\n) {\n    val trackingState by viewModel.trackingState.collectAsState()\n    val sequence by viewModel.sequence.observeAsState(0)\n\n    Column(\n        modifier = Modifier\n            .fillMaxSize()\n            .padding(16.dp),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        when (trackingState) {\n            AsleepState.STATE_TRACKING_STARTED -> {\n                CircularProgressIndicator()\n                Spacer(modifier = Modifier.height(16.dp))\n                Text(\"Tracking in progress\")\n                Text(\"Sequence: $sequence\")\n                Spacer(modifier = Modifier.height(32.dp))\n                Button(onClick = { viewModel.stopTracking() }) {\n                    Text(\"Stop Tracking\")\n                }\n            }\n            AsleepState.STATE_INITIALIZED -> {\n                Button(onClick = { viewModel.startTracking() }) {\n                    Text(\"Start Sleep Tracking\")\n                }\n            }\n            is AsleepState.STATE_ERROR -> {\n                val error = (trackingState as AsleepState.STATE_ERROR).errorCode\n                ErrorDisplay(error = error)\n            }\n            else -> {\n                CircularProgressIndicator()\n                Text(\"Initializing...\")\n            }\n        }\n    }\n}\n\n@Composable\nfun ErrorDisplay(error: AsleepError) {\n    Column(\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        Icon(\n            imageVector = Icons.Default.Warning,\n            contentDescription = \"Error\",\n            tint = MaterialTheme.colorScheme.error\n        )\n        Spacer(modifier = Modifier.height(8.dp))\n        Text(\n            text = getUserFriendlyMessage(error),\n            style = MaterialTheme.typography.bodyLarge,\n            textAlign = TextAlign.Center\n        )\n    }\n}\n```\n\n### Advanced Compose UI with Sleep Stages\n\n```kotlin\n@Composable\nfun DetailedTrackingScreen(\n    viewModel: SleepTrackingViewModel = hiltViewModel()\n) {\n    val trackingState by viewModel.trackingState.collectAsState()\n    val sequence by viewModel.sequence.observeAsState(0)\n    val sessionId by viewModel.sessionId.collectAsState()\n\n    Scaffold(\n        topBar = {\n            TopAppBar(\n                title = { Text(\"Sleep Tracking\") }\n            )\n        }\n    ) { padding ->\n        Column(\n            modifier = Modifier\n                .fillMaxSize()\n                .padding(padding)\n                .padding(16.dp)\n        ) {\n            when (trackingState) {\n                AsleepState.STATE_TRACKING_STARTED -> {\n                    TrackingActiveContent(\n                        sequence = sequence,\n                        sessionId = sessionId,\n                        onStop = { viewModel.stopTracking() }\n                    )\n                }\n                AsleepState.STATE_INITIALIZED -> {\n                    TrackingIdleContent(\n                        onStart = { viewModel.startTracking() }\n                    )\n                }\n                else -> {\n                    LoadingContent()\n                }\n            }\n        }\n    }\n}\n\n@Composable\nfun TrackingActiveContent(\n    sequence: Int,\n    sessionId: String?,\n    onStop: () -> Unit\n) {\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.SpaceBetween\n    ) {\n        // Status card\n        Card(\n            modifier = Modifier.fillMaxWidth(),\n            colors = CardDefaults.cardColors(\n                containerColor = MaterialTheme.colorScheme.primaryContainer\n            )\n        ) {\n            Column(\n                modifier = Modifier.padding(16.dp),\n                horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Text(\n                    text = \"Tracking Active\",\n                    style = MaterialTheme.typography.headlineSmall\n                )\n                Spacer(modifier = Modifier.height(8.dp))\n                Text(\n                    text = \"Session: ${sessionId?.take(8)}...\",\n                    style = MaterialTheme.typography.bodyMedium\n                )\n            }\n        }\n\n        Spacer(modifier = Modifier.height(24.dp))\n\n        // Progress indicator\n        Box(\n            contentAlignment = Alignment.Center\n        ) {\n            CircularProgressIndicator(\n                modifier = Modifier.size(120.dp),\n                strokeWidth = 8.dp\n            )\n            Column(\n                horizontalAlignment = Alignment.CenterHorizontally\n            ) {\n                Text(\n                    text = \"$sequence\",\n                    style = MaterialTheme.typography.headlineLarge\n                )\n                Text(\n                    text = \"sequences\",\n                    style = MaterialTheme.typography.bodySmall\n                )\n            }\n        }\n\n        Spacer(modifier = Modifier.height(24.dp))\n\n        // Duration estimate\n        val minutes = sequence / 2\n        Text(\n            text = \"Approximately $minutes minutes\",\n            style = MaterialTheme.typography.bodyLarge\n        )\n\n        Spacer(modifier = Modifier.weight(1f))\n\n        // Stop button\n        Button(\n            onClick = onStop,\n            modifier = Modifier.fillMaxWidth(),\n            colors = ButtonDefaults.buttonColors(\n                containerColor = MaterialTheme.colorScheme.error\n            )\n        ) {\n            Text(\"Stop Tracking\")\n        }\n    }\n}\n\n@Composable\nfun TrackingIdleContent(onStart: () -> Unit) {\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n        verticalArrangement = Arrangement.Center\n    ) {\n        Icon(\n            imageVector = Icons.Default.NightsStay,\n            contentDescription = \"Sleep\",\n            modifier = Modifier.size(120.dp),\n            tint = MaterialTheme.colorScheme.primary\n        )\n        Spacer(modifier = Modifier.height(24.dp))\n        Text(\n            text = \"Ready to Track Sleep\",\n            style = MaterialTheme.typography.headlineMedium\n        )\n        Spacer(modifier = Modifier.height(8.dp))\n        Text(\n            text = \"Make sure you're in a quiet environment\",\n            style = MaterialTheme.typography.bodyMedium,\n            textAlign = TextAlign.Center\n        )\n        Spacer(modifier = Modifier.height(32.dp))\n        Button(\n            onClick = onStart,\n            modifier = Modifier.fillMaxWidth(0.8f)\n        ) {\n            Text(\"Start Tracking\")\n        }\n    }\n}\n\n@Composable\nfun LoadingContent() {\n    Box(\n        modifier = Modifier.fillMaxSize(),\n        contentAlignment = Alignment.Center\n    ) {\n        Column(\n            horizontalAlignment = Alignment.CenterHorizontally\n        ) {\n            CircularProgressIndicator()\n            Spacer(modifier = Modifier.height(16.dp))\n            Text(\"Initializing SDK...\")\n        }\n    }\n}\n```\n\n## Material Design 3 Theming\n\n```kotlin\n// Theme setup for Compose\n@Composable\nfun SleepTrackingTheme(\n    darkTheme: Boolean = isSystemInDarkTheme(),\n    content: @Composable () -> Unit\n) {\n    val colorScheme = if (darkTheme) {\n        darkColorScheme(\n            primary = Color(0xFF6200EE),\n            secondary = Color(0xFF03DAC6),\n            error = Color(0xFFCF6679)\n        )\n    } else {\n        lightColorScheme(\n            primary = Color(0xFF6200EE),\n            secondary = Color(0xFF03DAC6),\n            error = Color(0xFFB00020)\n        )\n    }\n\n    MaterialTheme(\n        colorScheme = colorScheme,\n        typography = Typography,\n        content = content\n    )\n}\n```\n\n## Custom Views (XML)\n\n### CircularProgressView\n\n```kotlin\nclass CircularProgressView @JvmOverloads constructor(\n    context: Context,\n    attrs: AttributeSet? = null,\n    defStyleAttr: Int = 0\n) : View(context, attrs, defStyleAttr) {\n\n    private var progress = 0\n    private val paint = Paint().apply {\n        style = Paint.Style.STROKE\n        strokeWidth = 20f\n        color = Color.BLUE\n        isAntiAlias = true\n    }\n\n    fun setProgress(value: Int) {\n        progress = value\n        invalidate()\n    }\n\n    override fun onDraw(canvas: Canvas) {\n        super.onDraw(canvas)\n        val centerX = width / 2f\n        val centerY = height / 2f\n        val radius = (min(width, height) / 2f) - 20f\n\n        // Draw circle\n        canvas.drawCircle(centerX, centerY, radius, paint)\n\n        // Draw progress arc\n        val rectF = RectF(\n            centerX - radius,\n            centerY - radius,\n            centerX + radius,\n            centerY + radius\n        )\n        paint.style = Paint.Style.FILL\n        canvas.drawArc(rectF, -90f, (progress * 360f / 100f), true, paint)\n    }\n}\n```\n\n## Permission UI Patterns\n\n### Permission Request Dialog (Compose)\n\n```kotlin\n@Composable\nfun PermissionRequestDialog(\n    permissionName: String,\n    rationale: String,\n    onConfirm: () -> Unit,\n    onDismiss: () -> Unit\n) {\n    AlertDialog(\n        onDismissRequest = onDismiss,\n        title = { Text(\"Permission Required\") },\n        text = { Text(rationale) },\n        confirmButton = {\n            TextButton(onClick = onConfirm) {\n                Text(\"Grant Permission\")\n            }\n        },\n        dismissButton = {\n            TextButton(onClick = onDismiss) {\n                Text(\"Cancel\")\n            }\n        }\n    )\n}\n```\n\n### Using with Accompanist Permissions\n\n```kotlin\n@OptIn(ExperimentalPermissionsApi::class)\n@Composable\nfun PermissionScreen(\n    onPermissionsGranted: () -> Unit\n) {\n    val micPermissionState = rememberPermissionState(\n        Manifest.permission.RECORD_AUDIO\n    )\n\n    when {\n        micPermissionState.status.isGranted -> {\n            onPermissionsGranted()\n        }\n        micPermissionState.status.shouldShowRationale -> {\n            PermissionRequestDialog(\n                permissionName = \"Microphone\",\n                rationale = \"Microphone access is required to record sleep sounds\",\n                onConfirm = { micPermissionState.launchPermissionRequest() },\n                onDismiss = { /* Handle dismissal */ }\n            )\n        }\n        else -> {\n            Button(onClick = { micPermissionState.launchPermissionRequest() }) {\n                Text(\"Grant Microphone Permission\")\n            }\n        }\n    }\n}\n```\n\n## Navigation Integration\n\n### Jetpack Navigation with Compose\n\n```kotlin\n@Composable\nfun SleepTrackingNavHost(\n    navController: NavHostController = rememberNavController()\n) {\n    NavHost(\n        navController = navController,\n        startDestination = \"tracking\"\n    ) {\n        composable(\"tracking\") {\n            SleepTrackingScreen(\n                onSessionComplete = { sessionId ->\n                    navController.navigate(\"results/$sessionId\")\n                }\n            )\n        }\n        composable(\n            \"results/{sessionId}\",\n            arguments = listOf(navArgument(\"sessionId\") { type = NavType.StringType })\n        ) { backStackEntry ->\n            ResultsScreen(\n                sessionId = backStackEntry.arguments?.getString(\"sessionId\")\n            )\n        }\n    }\n}\n```\n\n## Best Practices\n\n1. **ViewBinding**: Always nullify binding in `onDestroyView()` for fragments\n2. **Compose**: Use `collectAsState()` for StateFlow and `observeAsState()` for LiveData\n3. **State Management**: Handle all possible states in UI, including loading and error states\n4. **Accessibility**: Add content descriptions for all interactive elements\n5. **Dark Mode**: Support both light and dark themes\n6. **Orientation**: Handle configuration changes with ViewModels\n7. **Touch Targets**: Ensure buttons are at least 48dp in size\n",
        "skills/sleeptrack-be/SKILL.md": "---\nname: sleeptrack-be\ndescription: This skill provides comprehensive backend REST API integration for Asleep sleep tracking platform. Use this skill when building server-side applications, API proxies for mobile apps, webhook event handlers, cross-platform backends (React Native, Flutter), analytics dashboards, or multi-tenant sleep tracking systems. Covers authentication, user management, session retrieval, statistics, webhook integration, and production-ready patterns with code examples in Python, Node.js, and curl.\n---\n\n# Sleeptrack Backend API Integration\n\n## Overview\n\nThis skill provides comprehensive guidance for integrating the Asleep REST API into backend applications. It covers server-side user management, session data retrieval, statistics aggregation, webhook event handling, and production-ready patterns for building robust sleep tracking backends.\n\n**Use this skill when:**\n- Building backend/server-side sleep tracking integrations\n- Creating API proxies for mobile applications\n- Implementing webhook handlers for real-time sleep data\n- Developing cross-platform backends (React Native, Flutter)\n- Building analytics dashboards and reporting systems\n- Creating multi-tenant sleep tracking applications\n- Integrating sleep data with other health platforms\n\n## Quick Start\n\n### 1. Get Your API Key\n\n1. Sign up at https://dashboard.asleep.ai\n2. Generate an API key for your application\n3. Store securely in environment variables (never commit to version control)\n\n### 2. Basic Authentication\n\nAll API requests require the `x-api-key` header:\n\n**curl:**\n```bash\ncurl -X GET \"https://api.asleep.ai/ai/v1/users/USER_ID\" \\\n  -H \"x-api-key: YOUR_API_KEY\"\n```\n\n**Python:**\n```python\nimport requests\n\nheaders = {\"x-api-key\": \"YOUR_API_KEY\"}\nresponse = requests.get(\n    \"https://api.asleep.ai/ai/v1/users/USER_ID\",\n    headers=headers\n)\n```\n\n**Node.js:**\n```javascript\nconst axios = require('axios');\n\nconst response = await axios.get(\n  'https://api.asleep.ai/ai/v1/users/USER_ID',\n  {\n    headers: { 'x-api-key': 'YOUR_API_KEY' }\n  }\n);\n```\n\n## API Client Structure\n\nBuild a reusable API client to handle authentication, error handling, and common operations.\n\n**Key Components:**\n- Base URL configuration (`https://api.asleep.ai`)\n- API key authentication in headers\n- Error handling for common HTTP status codes (401, 403, 404)\n- Request methods for all API endpoints\n- Session management with persistent connections\n\n**For complete implementations:**\n- Python: See `references/python_client_implementation.md`\n- Node.js: See `references/nodejs_client_implementation.md`\n- REST API details: See `references/rest_api_reference.md`\n\n**Basic Client Structure:**\n```python\nclass AsleepClient:\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.base_url = \"https://api.asleep.ai\"\n        self.session = requests.Session()\n        self.session.headers.update({\"x-api-key\": api_key})\n\n    def _request(self, method: str, path: str, **kwargs):\n        # Handle authentication and errors\n        # See python_client_implementation.md for full code\n        pass\n```\n\n## User Management\n\n### Creating Users\n\nCreate users before tracking sleep. User IDs are managed by your application.\n\n```python\n# Create user with metadata\nuser_id = client.create_user(metadata={\n    \"birth_year\": 1990,\n    \"gender\": \"male\",\n    \"height\": 175.5,  # cm\n    \"weight\": 70.0    # kg\n})\n```\n\n**Available Metadata Fields:**\n- `birth_year` (Integer): Birth year\n- `birth_month` (Integer): 1-12\n- `birth_day` (Integer): 1-31\n- `gender` (String): `male`, `female`, `non_binary`, `other`, `prefer_not_to_say`\n- `height` (Float): Height in cm (0-300)\n- `weight` (Float): Weight in kg (0-1000)\n\n### Retrieving User Information\n\n```python\nuser_data = client.get_user(user_id)\n# Returns: user_id, to_be_deleted status, last_session_info, metadata\n```\n\n**Response includes:**\n- User ID and deletion status\n- Last session information (if available)\n- User metadata (demographic information)\n\n### Deleting Users\n\nPermanently removes user and all associated data (sessions, reports).\n\n```python\nclient.delete_user(user_id)\n```\n\n**For detailed examples and response structures:**\n- See `references/rest_api_reference.md` (User Management section)\n- See `references/python_client_implementation.md` or `references/nodejs_client_implementation.md`\n\n## Session Management\n\n### Retrieving Session Details\n\nGet comprehensive sleep analysis for a specific session.\n\n```python\nsession = client.get_session(\n    session_id=\"session123\",\n    user_id=\"user123\",\n    timezone=\"America/New_York\"\n)\n\n# Access key metrics\nprint(f\"Sleep efficiency: {session['stat']['sleep_efficiency']:.1f}%\")\nprint(f\"Total sleep time: {session['stat']['sleep_time']}\")\nprint(f\"Sleep stages: {session['session']['sleep_stages']}\")\n```\n\n**Sleep Stage Values:**\n- `-1`: Unknown/No data\n- `0`: Wake\n- `1`: Light sleep\n- `2`: Deep sleep\n- `3`: REM sleep\n\n**Key Metrics:**\n- `sleep_efficiency`: (Total sleep time / Time in bed)  100%\n- `sleep_latency`: Time to fall asleep (seconds)\n- `waso_count`: Wake after sleep onset episodes\n- `time_in_bed`: Total time in bed (seconds)\n- `time_in_sleep`: Actual sleep time (seconds)\n- `time_in_light/deep/rem`: Stage durations (seconds)\n\n### Listing Sessions\n\nRetrieve multiple sessions with date filtering and pagination.\n\n```python\nsessions = client.list_sessions(\n    user_id=\"user123\",\n    date_gte=\"2024-01-01\",\n    date_lte=\"2024-01-31\",\n    limit=50,\n    order_by=\"DESC\"\n)\n```\n\n**Pagination Example:**\n```python\nall_sessions = []\noffset = 0\nlimit = 100\n\nwhile True:\n    result = client.list_sessions(\n        user_id=\"user123\",\n        offset=offset,\n        limit=limit\n    )\n    sessions = result['sleep_session_list']\n    all_sessions.extend(sessions)\n\n    if len(sessions) < limit:\n        break\n    offset += limit\n```\n\n### Deleting Sessions\n\n```python\nclient.delete_session(session_id=\"session123\", user_id=\"user123\")\n```\n\n**For detailed session data structures and examples:**\n- See `references/rest_api_reference.md` (Session Management section)\n- See client implementation references for language-specific examples\n\n## Statistics and Analytics\n\n### Average Statistics\n\nGet aggregated sleep metrics over a time period (max 100 days).\n\n```python\nstats = client.get_average_stats(\n    user_id=\"user123\",\n    start_date=\"2024-01-01\",\n    end_date=\"2024-01-31\",\n    timezone=\"UTC\"\n)\n\navg = stats['average_stats']\nprint(f\"Average sleep time: {avg['sleep_time']}\")\nprint(f\"Average efficiency: {avg['sleep_efficiency']:.1f}%\")\nprint(f\"Light sleep ratio: {avg['light_ratio']:.1%}\")\nprint(f\"Number of sessions: {len(stats['slept_sessions'])}\")\n```\n\n**Returned Metrics:**\n- Average sleep time, bedtime, wake time\n- Average sleep efficiency\n- Sleep stage ratios (light, deep, REM)\n- List of sessions included in calculation\n\n**For trend analysis and advanced analytics:**\n- See `references/python_client_implementation.md` (Analytics section)\n- See `references/rest_api_reference.md` (Statistics section)\n\n## Webhook Integration\n\nWebhooks enable real-time notifications for sleep session events.\n\n### Webhook Event Types\n\n1. **INFERENCE_COMPLETE**: Incremental sleep data during tracking (every 5-40 minutes)\n2. **SESSION_COMPLETE**: Final comprehensive sleep analysis when session ends\n\n### Setting Up Webhook Endpoint\n\n**Basic Structure:**\n```python\n@app.route('/asleep-webhook', methods=['POST'])\ndef asleep_webhook():\n    # 1. Verify authentication (x-api-key header)\n    # 2. Parse event data\n    # 3. Handle event type (INFERENCE_COMPLETE or SESSION_COMPLETE)\n    # 4. Process and store data\n    # 5. Return 200 response\n    pass\n```\n\n**Key Implementation Points:**\n- Verify `x-api-key` header matches your API key\n- Validate `x-user-id` header\n- Handle both INFERENCE_COMPLETE and SESSION_COMPLETE events\n- Implement idempotency (check if event already processed)\n- Process asynchronously for better performance\n- Return 200 status immediately\n\n**For complete webhook implementations:**\n- Python (Flask): See `references/webhook_implementation_guide.md`\n- Node.js (Express): See `references/webhook_implementation_guide.md`\n- Webhook payloads: See `references/webhook_reference.md`\n\n### Webhook Best Practices\n\n**Idempotency:**\nCheck if webhook event was already processed to avoid duplicates.\n\n**Asynchronous Processing:**\nQueue webhook events for background processing and respond immediately.\n\n**Error Handling:**\nReturn 200 even if processing fails internally to prevent retries.\n\n**For detailed patterns:**\n- See `references/webhook_implementation_guide.md`\n- See `references/production_patterns.md` (Background Jobs section)\n\n## Common Backend Patterns\n\n### 1. API Proxy for Mobile Apps\n\nCreate a backend proxy to:\n- Hide API keys from mobile clients\n- Add custom authentication\n- Implement business logic\n- Track usage and analytics\n\n**Key endpoints:**\n- POST `/api/users` - Create Asleep user for authenticated app user\n- GET `/api/sessions/{id}` - Proxy session retrieval with auth\n- GET `/api/sessions` - List sessions with filtering\n- GET `/api/statistics` - Get aggregated statistics\n\n**For complete implementation:**\n- See `references/python_client_implementation.md` (API Proxy section)\n\n### 2. Analytics Dashboard Backend\n\nAggregate and analyze sleep data across multiple users:\n- Calculate comprehensive sleep scores\n- Generate weekly/monthly reports\n- Analyze cohort sleep patterns\n- Provide personalized insights\n\n**Key features:**\n- Sleep score calculation (efficiency + consistency + duration)\n- Trend analysis over time\n- Multi-user aggregation\n- Report generation\n\n**For complete implementation:**\n- See `references/python_client_implementation.md` (Analytics section)\n\n### 3. Multi-Tenant Application\n\nManage sleep tracking for multiple organizations or teams:\n- Organization-level user management\n- Aggregated organization statistics\n- Role-based access control\n- Per-organization settings\n\n**For complete implementation:**\n- See `references/python_client_implementation.md` (Multi-Tenant section)\n\n## Error Handling\n\n### Common Error Codes\n\n- **401 Unauthorized**: Invalid API key\n- **403 Forbidden**: Rate limit exceeded or insufficient permissions\n- **404 Not Found**: Resource does not exist\n- **422 Unprocessable Entity**: Invalid request parameters\n\n### Retry Logic with Exponential Backoff\n\n```python\ndef retry_with_exponential_backoff(func, max_retries=3, base_delay=1.0):\n    for attempt in range(max_retries):\n        try:\n            return func()\n        except requests.exceptions.HTTPError as e:\n            if e.response.status_code == 403 and \"rate limit\" in str(e):\n                if attempt < max_retries - 1:\n                    delay = min(base_delay * (2 ** attempt), 60.0)\n                    time.sleep(delay)\n                    continue\n            raise\n```\n\n### Custom Exception Classes\n\n```python\nclass AsleepAPIError(Exception):\n    \"\"\"Base exception for Asleep API errors\"\"\"\n    pass\n\nclass RateLimitError(AsleepAPIError):\n    \"\"\"Rate limit exceeded\"\"\"\n    pass\n\nclass ResourceNotFoundError(AsleepAPIError):\n    \"\"\"Resource not found\"\"\"\n    pass\n```\n\n**For comprehensive error handling:**\n- See `references/python_client_implementation.md` or `references/nodejs_client_implementation.md`\n- See `references/production_patterns.md` (Error Recovery section)\n\n## Testing\n\n### Local Webhook Testing\n\nUse ngrok to expose local server for webhook testing:\n\n```bash\n# Start local server\npython app.py  # or npm start\n\n# Expose with ngrok\nngrok http 5000\n\n# Use ngrok URL in webhook configuration\n# Example: https://abc123.ngrok.io/asleep-webhook\n```\n\n### Mock API Responses\n\n```python\n@patch('requests.Session.request')\ndef test_create_user(mock_request):\n    mock_response = Mock()\n    mock_response.json.return_value = {\n        \"result\": {\"user_id\": \"test_user_123\"}\n    }\n    mock_request.return_value = mock_response\n\n    user_id = client.create_user()\n    assert user_id == \"test_user_123\"\n```\n\n**For complete testing examples:**\n- See `references/python_client_implementation.md` (Testing section)\n\n## Production Best Practices\n\n### Security\n\n1. **API Key Management:**\n   - Store in environment variables or secret management system\n   - Never commit to version control\n   - Rotate keys periodically\n   - Use different keys for dev/staging/production\n\n2. **Webhook Security:**\n   - Verify `x-api-key` header\n   - Use HTTPS endpoints only\n   - Implement rate limiting\n   - Log all webhook attempts\n\n3. **User Data Privacy:**\n   - Encrypt sensitive data at rest\n   - Implement proper access controls\n   - Handle data deletion requests\n   - Comply with GDPR/CCPA\n\n### Performance\n\n1. **Caching:** Cache immutable session data\n2. **Rate Limiting:** Protect your backend from overload\n3. **Connection Pooling:** Reuse HTTP connections\n4. **Batch Processing:** Process multiple requests in parallel\n\n### Monitoring\n\n1. **Logging:** Structured logging for all API requests\n2. **Metrics:** Track request duration, error rates, throughput\n3. **Health Checks:** Implement `/health`, `/ready`, `/live` endpoints\n4. **Alerting:** Alert on error rate spikes or API failures\n\n### Deployment\n\n1. **Configuration:** Environment-based settings with validation\n2. **Health Checks:** Support Kubernetes liveness/readiness probes\n3. **Graceful Shutdown:** Handle termination signals properly\n4. **Error Recovery:** Circuit breaker pattern for API failures\n\n**For comprehensive production patterns:**\n- Caching strategies: See `references/production_patterns.md`\n- Rate limiting: See `references/production_patterns.md`\n- Monitoring: See `references/production_patterns.md`\n- Deployment: See `references/production_patterns.md`\n\n## Resources\n\n### Reference Documentation\n\nThis skill includes comprehensive reference files:\n\n- `references/python_client_implementation.md`: Complete Python client with all methods, analytics classes, and examples\n- `references/nodejs_client_implementation.md`: Complete Node.js client with Express integration\n- `references/webhook_implementation_guide.md`: Full webhook handlers in Python and Node.js with best practices\n- `references/rest_api_reference.md`: Complete REST API endpoint documentation with request/response examples\n- `references/webhook_reference.md`: Webhook integration guide with payload structures\n- `references/production_patterns.md`: Caching, rate limiting, monitoring, deployment, and performance optimization\n\nTo access detailed information:\n```\nRead references/python_client_implementation.md\nRead references/nodejs_client_implementation.md\nRead references/webhook_implementation_guide.md\nRead references/rest_api_reference.md\nRead references/webhook_reference.md\nRead references/production_patterns.md\n```\n\n### Official Documentation\n\n- **Main Documentation**: https://docs-en.asleep.ai\n- **API Basics**: https://docs-en.asleep.ai/docs/api-basics.md\n- **Webhook Guide**: https://docs-en.asleep.ai/docs/webhook.md\n- **Dashboard**: https://dashboard.asleep.ai\n- **LLM-Optimized Reference**: https://docs-en.asleep.ai/llms.txt\n\n### Related Skills\n\n- **sleeptrack-foundation**: Core concepts, authentication, data structures, and platform-agnostic patterns\n- **sleeptrack-ios**: iOS SDK integration for native iOS applications\n- **sleeptrack-android**: Android SDK integration for native Android applications\n\n### Support\n\nFor technical support and API issues:\n- Check Dashboard for API usage and status\n- Review error logs and response codes\n- Contact support through Asleep Dashboard\n",
        "skills/sleeptrack-be/references/nodejs_client_implementation.md": "# Node.js Client Implementation Guide\n\nThis reference provides complete Node.js client implementations for the Asleep API, including webhook servers and production patterns.\n\n## Complete Node.js API Client\n\n```javascript\nconst axios = require('axios');\n\nclass AsleepClient {\n  constructor(apiKey, baseURL = 'https://api.asleep.ai') {\n    this.apiKey = apiKey;\n    this.baseURL = baseURL;\n    this.client = axios.create({\n      baseURL: baseURL,\n      headers: { 'x-api-key': apiKey }\n    });\n  }\n\n  async _request(method, path, options = {}) {\n    try {\n      const response = await this.client.request({\n        method,\n        url: path,\n        ...options\n      });\n      return response.data;\n    } catch (error) {\n      if (error.response) {\n        const status = error.response.status;\n        const detail = error.response.data?.detail || 'Unknown error';\n\n        if (status === 401) {\n          throw new Error('Invalid API key');\n        } else if (status === 403) {\n          throw new Error(`API access error: ${detail}`);\n        } else if (status === 404) {\n          throw new Error('Resource not found');\n        }\n      }\n      throw error;\n    }\n  }\n\n  // User management\n  async createUser(metadata = null) {\n    const data = metadata ? { metadata } : {};\n    const result = await this._request('POST', '/ai/v1/users', { data });\n    return result.result.user_id;\n  }\n\n  async getUser(userId) {\n    const result = await this._request('GET', `/ai/v1/users/${userId}`);\n    return result.result;\n  }\n\n  async deleteUser(userId) {\n    await this._request('DELETE', `/ai/v1/users/${userId}`);\n  }\n\n  // Session management\n  async getSession(sessionId, userId, timezone = 'UTC') {\n    const result = await this._request('GET', `/data/v3/sessions/${sessionId}`, {\n      headers: { 'x-user-id': userId, 'timezone': timezone }\n    });\n    return result.result;\n  }\n\n  async listSessions(userId, options = {}) {\n    const { dateGte, dateLte, offset = 0, limit = 20, orderBy = 'DESC' } = options;\n    const params = { offset, limit, order_by: orderBy };\n    if (dateGte) params.date_gte = dateGte;\n    if (dateLte) params.date_lte = dateLte;\n\n    const result = await this._request('GET', '/data/v1/sessions', {\n      headers: { 'x-user-id': userId },\n      params\n    });\n    return result.result;\n  }\n\n  async deleteSession(sessionId, userId) {\n    await this._request('DELETE', `/ai/v1/sessions/${sessionId}`, {\n      headers: { 'x-user-id': userId }\n    });\n  }\n\n  // Statistics\n  async getAverageStats(userId, startDate, endDate, timezone = 'UTC') {\n    const result = await this._request('GET', `/data/v1/users/${userId}/average-stats`, {\n      headers: { 'timezone': timezone },\n      params: { start_date: startDate, end_date: endDate }\n    });\n    return result.result;\n  }\n}\n\n// Usage\nconst client = new AsleepClient(process.env.ASLEEP_API_KEY);\n```\n\n## Express Webhook Server\n\n```javascript\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\nconst EXPECTED_API_KEY = process.env.ASLEEP_API_KEY;\n\napp.post('/asleep-webhook', async (req, res) => {\n  // Verify authentication\n  const apiKey = req.headers['x-api-key'];\n  const userId = req.headers['x-user-id'];\n\n  if (apiKey !== EXPECTED_API_KEY) {\n    console.warn('Unauthorized webhook attempt');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  const { event, session_id, stat } = req.body;\n  console.log(`Received ${event} event for user ${userId}`);\n\n  try {\n    switch (event) {\n      case 'INFERENCE_COMPLETE':\n        await handleInferenceComplete(req.body);\n        break;\n      case 'SESSION_COMPLETE':\n        await handleSessionComplete(req.body);\n        break;\n      default:\n        console.warn(`Unknown event type: ${event}`);\n    }\n\n    res.status(200).json({ status: 'success' });\n  } catch (error) {\n    console.error('Webhook processing error:', error);\n    res.status(500).json({ error: 'Processing failed' });\n  }\n});\n\nasync function handleInferenceComplete(event) {\n  const { session_id, user_id, sleep_stages } = event;\n\n  // Update real-time dashboard\n  await updateLiveDashboard(session_id, sleep_stages);\n\n  // Store incremental data\n  await db.collection('incremental_data').insertOne(event);\n\n  console.log(`Processed INFERENCE_COMPLETE for session ${session_id}`);\n}\n\nasync function handleSessionComplete(event) {\n  const { session_id, user_id, stat, session } = event;\n\n  // Store complete report\n  await db.collection('sleep_reports').insertOne({\n    user_id,\n    session_id,\n    date: session.start_time,\n    statistics: stat,\n    session_data: session,\n    created_at: new Date()\n  });\n\n  // Send user notification\n  await sendPushNotification(user_id, {\n    title: 'Sleep Report Ready',\n    body: `Sleep time: ${stat.sleep_time}, Efficiency: ${stat.sleep_efficiency.toFixed(1)}%`\n  });\n\n  // Update user statistics\n  await updateUserAggregatedStats(user_id);\n\n  console.log(`Processed SESSION_COMPLETE for session ${session_id}`);\n}\n\nconst PORT = process.env.PORT || 5000;\napp.listen(PORT, () => {\n  console.log(`Webhook server listening on port ${PORT}`);\n});\n```\n\n## Retry with Exponential Backoff\n\n```javascript\nasync function retryWithExponentialBackoff(\n  func,\n  maxRetries = 3,\n  baseDelay = 1000,\n  maxDelay = 60000\n) {\n  for (let attempt = 0; attempt < maxRetries; attempt++) {\n    try {\n      return await func();\n    } catch (error) {\n      if (error.response?.status === 403) {\n        const detail = error.response.data?.detail || '';\n        if (detail.toLowerCase().includes('rate limit')) {\n          if (attempt < maxRetries - 1) {\n            const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\n            console.log(`Rate limited, retrying in ${delay}ms...`);\n            await new Promise(resolve => setTimeout(resolve, delay));\n            continue;\n          }\n        }\n      }\n      throw error;\n    }\n  }\n}\n\n// Usage\nconst result = await retryWithExponentialBackoff(\n  () => client.getSession('session123', 'user123')\n);\n```\n\n## Basic Usage Examples\n\n### Creating Users\n\n```javascript\n// Create user with metadata\nconst userId = await client.createUser({\n  birth_year: 1990,\n  gender: 'male',\n  height: 175.5,\n  weight: 70.0\n});\nconsole.log(`Created user: ${userId}`);\n\n// Create user without metadata\nconst userId = await client.createUser();\n```\n\n### Getting Sessions\n\n```javascript\n// Get sessions for date range\nconst sessions = await client.listSessions('user123', {\n  dateGte: '2024-01-01',\n  dateLte: '2024-01-31',\n  limit: 50,\n  orderBy: 'DESC'\n});\n\nconsole.log(`Found ${sessions.sleep_session_list.length} sessions`);\n\nsessions.sleep_session_list.forEach(session => {\n  console.log(`Session ${session.session_id}: ${session.session_start_time}`);\n  console.log(`  State: ${session.state}, Time in bed: ${session.time_in_bed}s`);\n});\n```\n\n### Getting Session Details\n\n```javascript\nconst session = await client.getSession(\n  'session123',\n  'user123',\n  'America/New_York'\n);\n\nconsole.log(`Sleep efficiency: ${session.stat.sleep_efficiency.toFixed(1)}%`);\nconsole.log(`Total sleep time: ${session.stat.sleep_time}`);\nconsole.log(`Sleep stages: ${session.session.sleep_stages}`);\nconsole.log(`Sleep cycles: ${session.stat.sleep_cycle.length}`);\n```\n\n### Getting Statistics\n\n```javascript\nconst stats = await client.getAverageStats(\n  'user123',\n  '2024-01-01',\n  '2024-01-31',\n  'UTC'\n);\n\nconst avg = stats.average_stats;\nconsole.log(`Average sleep time: ${avg.sleep_time}`);\nconsole.log(`Average efficiency: ${avg.sleep_efficiency.toFixed(1)}%`);\nconsole.log(`Average bedtime: ${avg.start_time}`);\nconsole.log(`Average wake time: ${avg.end_time}`);\nconsole.log(`Light sleep ratio: ${(avg.light_ratio * 100).toFixed(1)}%`);\nconsole.log(`Deep sleep ratio: ${(avg.deep_ratio * 100).toFixed(1)}%`);\nconsole.log(`REM sleep ratio: ${(avg.rem_ratio * 100).toFixed(1)}%`);\nconsole.log(`Number of sessions: ${stats.slept_sessions.length}`);\n```\n\n## Asynchronous Webhook Processing\n\n```javascript\nconst Queue = require('bull');\n\nconst webhookQueue = new Queue('asleep-webhooks', {\n  redis: {\n    host: 'localhost',\n    port: 6379\n  }\n});\n\napp.post('/webhook', async (req, res) => {\n  const event = req.body;\n\n  // Queue for async processing\n  await webhookQueue.add(event);\n\n  // Respond immediately\n  res.status(200).json({ status: 'queued' });\n});\n\n// Process queued webhooks\nwebhookQueue.process(async (job) => {\n  const event = job.data;\n\n  if (event.event === 'SESSION_COMPLETE') {\n    await handleSessionComplete(event);\n  } else if (event.event === 'INFERENCE_COMPLETE') {\n    await handleInferenceComplete(event);\n  }\n});\n```\n\n## Idempotency Pattern\n\n```javascript\nasync function handleSessionComplete(event) {\n  const sessionId = event.session_id;\n\n  // Check if already processed\n  const existing = await db.collection('processed_webhooks').findOne({\n    session_id: sessionId,\n    event: 'SESSION_COMPLETE'\n  });\n\n  if (existing) {\n    console.log(`Session ${sessionId} already processed, skipping`);\n    return;\n  }\n\n  // Process event\n  await saveSleepReport(event);\n\n  // Mark as processed\n  await db.collection('processed_webhooks').insertOne({\n    session_id: sessionId,\n    event: 'SESSION_COMPLETE',\n    processed_at: new Date()\n  });\n}\n```\n\n## Comprehensive Error Handling\n\n```javascript\nclass AsleepAPIError extends Error {\n  constructor(message, statusCode, detail) {\n    super(message);\n    this.name = 'AsleepAPIError';\n    this.statusCode = statusCode;\n    this.detail = detail;\n  }\n}\n\nclass RateLimitError extends AsleepAPIError {\n  constructor(detail) {\n    super('Rate limit exceeded', 403, detail);\n    this.name = 'RateLimitError';\n  }\n}\n\nclass ResourceNotFoundError extends AsleepAPIError {\n  constructor(detail) {\n    super('Resource not found', 404, detail);\n    this.name = 'ResourceNotFoundError';\n  }\n}\n\nasync function safeApiRequest(requestFunc) {\n  try {\n    return await requestFunc();\n  } catch (error) {\n    if (error.response) {\n      const status = error.response.status;\n      const detail = error.response.data?.detail || 'Unknown error';\n\n      if (status === 401) {\n        throw new AsleepAPIError('Authentication failed', 401, detail);\n      } else if (status === 403) {\n        if (detail.toLowerCase().includes('rate limit')) {\n          throw new RateLimitError(detail);\n        } else {\n          throw new AsleepAPIError('Access forbidden', 403, detail);\n        }\n      } else if (status === 404) {\n        throw new ResourceNotFoundError(detail);\n      } else {\n        throw new AsleepAPIError(`API error (${status})`, status, detail);\n      }\n    }\n    throw error;\n  }\n}\n\n// Usage\ntry {\n  const user = await safeApiRequest(() => client.getUser('user123'));\n} catch (error) {\n  if (error instanceof ResourceNotFoundError) {\n    console.log('User not found, creating new user...');\n    const userId = await client.createUser();\n  } else if (error instanceof RateLimitError) {\n    console.log('Rate limited, try again later');\n  } else if (error instanceof AsleepAPIError) {\n    console.error(`API error: ${error.message}`);\n  }\n}\n```\n\n## Production Configuration\n\n```javascript\n// config.js\nrequire('dotenv').config();\n\nclass Config {\n  static get ASLEEP_API_KEY() {\n    return process.env.ASLEEP_API_KEY;\n  }\n\n  static get ASLEEP_BASE_URL() {\n    return process.env.ASLEEP_BASE_URL || 'https://api.asleep.ai';\n  }\n\n  static get DATABASE_URL() {\n    return process.env.DATABASE_URL;\n  }\n\n  static get REDIS_URL() {\n    return process.env.REDIS_URL;\n  }\n\n  static get WEBHOOK_SECRET() {\n    return process.env.WEBHOOK_SECRET;\n  }\n\n  static get ENABLE_CACHING() {\n    return process.env.ENABLE_CACHING !== 'false';\n  }\n\n  static validate() {\n    if (!this.ASLEEP_API_KEY) {\n      throw new Error('ASLEEP_API_KEY environment variable required');\n    }\n    if (!this.DATABASE_URL) {\n      throw new Error('DATABASE_URL environment variable required');\n    }\n  }\n}\n\nmodule.exports = Config;\n```\n",
        "skills/sleeptrack-be/references/production_patterns.md": "# Production Patterns and Best Practices\n\nThis reference provides comprehensive production-ready patterns for deploying and maintaining Asleep API integrations in production environments.\n\n## Caching Strategies\n\n### Session Caching\n\nSessions are immutable once complete, making them ideal for caching:\n\n```python\nfrom functools import lru_cache\nfrom datetime import datetime, timedelta\nimport json\nimport redis\n\nredis_client = redis.Redis(host='localhost', port=6379, db=0)\n\nclass CachedAsleepClient(AsleepClient):\n    \"\"\"Client with response caching\"\"\"\n\n    @lru_cache(maxsize=128)\n    def get_session_cached(self, session_id: str, user_id: str) -> Dict:\n        \"\"\"Get session with caching (sessions are immutable once complete)\"\"\"\n        return self.get_session(session_id, user_id)\n\n    def get_recent_sessions(self, user_id: str, days: int = 7) -> List[Dict]:\n        \"\"\"Get recent sessions with Redis caching\"\"\"\n        cache_key = f\"sessions:{user_id}:{days}\"\n        cached = redis_client.get(cache_key)\n\n        if cached:\n            return json.loads(cached)\n\n        end_date = datetime.now()\n        start_date = end_date - timedelta(days=days)\n\n        result = self.list_sessions(\n            user_id=user_id,\n            date_gte=start_date.strftime(\"%Y-%m-%d\"),\n            date_lte=end_date.strftime(\"%Y-%m-%d\")\n        )\n\n        # Cache for 5 minutes\n        redis_client.setex(cache_key, 300, json.dumps(result))\n\n        return result\n\n    def invalidate_user_cache(self, user_id: str):\n        \"\"\"Invalidate all caches for a user\"\"\"\n        pattern = f\"sessions:{user_id}:*\"\n        for key in redis_client.scan_iter(match=pattern):\n            redis_client.delete(key)\n```\n\n## Rate Limiting\n\n### Application-Level Rate Limiting\n\nProtect your backend from being overwhelmed:\n\n```python\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nlimiter = Limiter(\n    app,\n    key_func=get_remote_address,\n    default_limits=[\"100 per hour\"]\n)\n\n@app.route('/api/sessions/<session_id>')\n@limiter.limit(\"10 per minute\")\ndef get_session(session_id):\n    \"\"\"Rate-limited session endpoint\"\"\"\n    # Implementation\n    pass\n\n@app.route('/api/statistics')\n@limiter.limit(\"5 per minute\")\ndef get_statistics():\n    \"\"\"Statistics endpoint with stricter rate limiting\"\"\"\n    # Implementation\n    pass\n```\n\n### API Request Rate Limiting\n\nRespect Asleep API rate limits with request throttling:\n\n```python\nimport time\nfrom collections import deque\nfrom threading import Lock\n\nclass RateLimitedClient(AsleepClient):\n    \"\"\"Client with built-in rate limiting\"\"\"\n\n    def __init__(self, api_key: str, requests_per_second: int = 10):\n        super().__init__(api_key)\n        self.requests_per_second = requests_per_second\n        self.request_times = deque()\n        self.lock = Lock()\n\n    def _wait_for_rate_limit(self):\n        \"\"\"Wait if necessary to stay within rate limits\"\"\"\n        with self.lock:\n            now = time.time()\n\n            # Remove requests older than 1 second\n            while self.request_times and self.request_times[0] < now - 1:\n                self.request_times.popleft()\n\n            # If at limit, wait\n            if len(self.request_times) >= self.requests_per_second:\n                sleep_time = 1 - (now - self.request_times[0])\n                if sleep_time > 0:\n                    time.sleep(sleep_time)\n                    self.request_times.popleft()\n\n            self.request_times.append(time.time())\n\n    def _request(self, method: str, path: str, **kwargs):\n        \"\"\"Rate-limited request\"\"\"\n        self._wait_for_rate_limit()\n        return super()._request(method, path, **kwargs)\n```\n\n## Connection Pooling\n\n### HTTP Session with Connection Pool\n\nReuse connections for better performance:\n\n```python\nimport requests\nfrom requests.adapters import HTTPAdapter\nfrom urllib3.util.retry import Retry\n\ndef create_session_with_retries():\n    \"\"\"Create session with connection pooling and retries\"\"\"\n    session = requests.Session()\n\n    retry_strategy = Retry(\n        total=3,\n        backoff_factor=1,\n        status_forcelist=[429, 500, 502, 503, 504],\n        method_whitelist=[\"HEAD\", \"GET\", \"OPTIONS\", \"POST\", \"PUT\", \"DELETE\"]\n    )\n\n    adapter = HTTPAdapter(\n        max_retries=retry_strategy,\n        pool_connections=10,\n        pool_maxsize=20\n    )\n\n    session.mount(\"https://\", adapter)\n    session.mount(\"http://\", adapter)\n\n    return session\n\nclass PooledAsleepClient(AsleepClient):\n    \"\"\"Client with connection pooling\"\"\"\n\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.base_url = \"https://api.asleep.ai\"\n        self.session = create_session_with_retries()\n        self.session.headers.update({\"x-api-key\": api_key})\n```\n\n## Monitoring and Logging\n\n### Structured Logging\n\n```python\nimport logging\nimport json\nfrom datetime import datetime\n\nclass StructuredLogger:\n    \"\"\"Structured logging for API requests\"\"\"\n\n    def __init__(self, name: str):\n        self.logger = logging.getLogger(name)\n\n    def log_request(self, method: str, path: str, user_id: str = None):\n        \"\"\"Log API request\"\"\"\n        self.logger.info(json.dumps({\n            'event': 'api_request',\n            'timestamp': datetime.now().isoformat(),\n            'method': method,\n            'path': path,\n            'user_id': user_id\n        }))\n\n    def log_response(self, method: str, path: str, status_code: int, duration: float):\n        \"\"\"Log API response\"\"\"\n        self.logger.info(json.dumps({\n            'event': 'api_response',\n            'timestamp': datetime.now().isoformat(),\n            'method': method,\n            'path': path,\n            'status_code': status_code,\n            'duration_ms': duration * 1000\n        }))\n\n    def log_error(self, method: str, path: str, error: Exception, duration: float):\n        \"\"\"Log API error\"\"\"\n        self.logger.error(json.dumps({\n            'event': 'api_error',\n            'timestamp': datetime.now().isoformat(),\n            'method': method,\n            'path': path,\n            'error_type': type(error).__name__,\n            'error_message': str(error),\n            'duration_ms': duration * 1000\n        }))\n\nclass MonitoredAsleepClient(AsleepClient):\n    \"\"\"Client with comprehensive logging\"\"\"\n\n    def __init__(self, api_key: str):\n        super().__init__(api_key)\n        self.logger = StructuredLogger(__name__)\n\n    def _request(self, method: str, path: str, **kwargs):\n        \"\"\"Monitored API request\"\"\"\n        start_time = datetime.now()\n        user_id = kwargs.get('headers', {}).get('x-user-id')\n\n        self.logger.log_request(method, path, user_id)\n\n        try:\n            result = super()._request(method, path, **kwargs)\n            duration = (datetime.now() - start_time).total_seconds()\n            self.logger.log_response(method, path, 200, duration)\n            return result\n\n        except Exception as e:\n            duration = (datetime.now() - start_time).total_seconds()\n            self.logger.log_error(method, path, e, duration)\n            raise\n```\n\n### Metrics Collection\n\n```python\nfrom datadog import statsd\n\nclass MetricsClient(AsleepClient):\n    \"\"\"Client with metrics collection\"\"\"\n\n    def _request(self, method: str, path: str, **kwargs):\n        \"\"\"Request with metrics\"\"\"\n        start_time = datetime.now()\n\n        try:\n            result = super()._request(method, path, **kwargs)\n\n            duration = (datetime.now() - start_time).total_seconds()\n\n            # Record success metrics\n            statsd.increment('asleep_api.request.success')\n            statsd.timing('asleep_api.request.duration', duration)\n            statsd.histogram('asleep_api.response_time', duration)\n\n            return result\n\n        except Exception as e:\n            duration = (datetime.now() - start_time).total_seconds()\n\n            # Record error metrics\n            statsd.increment('asleep_api.request.error')\n            statsd.increment(f'asleep_api.error.{type(e).__name__}')\n            statsd.timing('asleep_api.request.duration', duration)\n\n            raise\n```\n\n## Security Best Practices\n\n### API Key Management\n\n```python\nimport os\nfrom dotenv import load_dotenv\n\nclass SecureConfig:\n    \"\"\"Secure configuration management\"\"\"\n\n    def __init__(self):\n        load_dotenv()\n        self._validate_config()\n\n    def _validate_config(self):\n        \"\"\"Validate required environment variables\"\"\"\n        required = ['ASLEEP_API_KEY', 'DATABASE_URL']\n        missing = [var for var in required if not os.getenv(var)]\n\n        if missing:\n            raise ValueError(f\"Missing required environment variables: {', '.join(missing)}\")\n\n    @property\n    def asleep_api_key(self) -> str:\n        \"\"\"Get API key from environment\"\"\"\n        return os.getenv('ASLEEP_API_KEY')\n\n    @property\n    def database_url(self) -> str:\n        \"\"\"Get database URL from environment\"\"\"\n        return os.getenv('DATABASE_URL')\n\n    @property\n    def redis_url(self) -> str:\n        \"\"\"Get Redis URL from environment\"\"\"\n        return os.getenv('REDIS_URL', 'redis://localhost:6379')\n```\n\n### Webhook Security\n\n```python\nimport hmac\nimport hashlib\n\ndef verify_webhook_signature(payload: bytes, signature: str, secret: str) -> bool:\n    \"\"\"Verify webhook payload signature\"\"\"\n    expected_signature = hmac.new(\n        secret.encode(),\n        payload,\n        hashlib.sha256\n    ).hexdigest()\n\n    return hmac.compare_digest(signature, expected_signature)\n\n@app.route('/asleep-webhook', methods=['POST'])\ndef secure_webhook():\n    \"\"\"Webhook endpoint with signature verification\"\"\"\n    # Verify API key\n    api_key = request.headers.get('x-api-key')\n    if api_key != EXPECTED_API_KEY:\n        return jsonify({\"error\": \"Unauthorized\"}), 401\n\n    # Verify signature (if implemented)\n    signature = request.headers.get('x-signature')\n    if signature:\n        if not verify_webhook_signature(request.data, signature, WEBHOOK_SECRET):\n            return jsonify({\"error\": \"Invalid signature\"}), 401\n\n    # Process webhook\n    event = request.json\n    process_webhook(event)\n\n    return jsonify({\"status\": \"success\"}), 200\n```\n\n## Deployment Configuration\n\n### Environment-Based Configuration\n\n```python\nimport os\nfrom enum import Enum\n\nclass Environment(Enum):\n    DEVELOPMENT = \"development\"\n    STAGING = \"staging\"\n    PRODUCTION = \"production\"\n\nclass Config:\n    \"\"\"Environment-based configuration\"\"\"\n\n    def __init__(self):\n        self.env = Environment(os.getenv('ENVIRONMENT', 'development'))\n        self.asleep_api_key = os.getenv('ASLEEP_API_KEY')\n        self.asleep_base_url = os.getenv('ASLEEP_BASE_URL', 'https://api.asleep.ai')\n        self.database_url = os.getenv('DATABASE_URL')\n        self.redis_url = os.getenv('REDIS_URL')\n\n        # Feature flags\n        self.enable_caching = self._parse_bool('ENABLE_CACHING', True)\n        self.enable_webhooks = self._parse_bool('ENABLE_WEBHOOKS', True)\n        self.enable_metrics = self._parse_bool('ENABLE_METRICS', True)\n\n        # Performance settings\n        self.max_connections = int(os.getenv('MAX_CONNECTIONS', '100'))\n        self.request_timeout = int(os.getenv('REQUEST_TIMEOUT', '30'))\n\n        self._validate()\n\n    def _parse_bool(self, key: str, default: bool) -> bool:\n        \"\"\"Parse boolean environment variable\"\"\"\n        value = os.getenv(key, str(default)).lower()\n        return value in ('true', '1', 'yes')\n\n    def _validate(self):\n        \"\"\"Validate configuration\"\"\"\n        if not self.asleep_api_key:\n            raise ValueError(\"ASLEEP_API_KEY is required\")\n\n        if self.env == Environment.PRODUCTION:\n            if not self.database_url:\n                raise ValueError(\"DATABASE_URL is required in production\")\n\n    @property\n    def is_production(self) -> bool:\n        return self.env == Environment.PRODUCTION\n\n    @property\n    def is_development(self) -> bool:\n        return self.env == Environment.DEVELOPMENT\n```\n\n### Health Check Endpoint\n\n```python\nfrom flask import Flask, jsonify\nimport requests\n\n@app.route('/health')\ndef health_check():\n    \"\"\"Health check endpoint for load balancers\"\"\"\n    checks = {\n        'status': 'healthy',\n        'timestamp': datetime.now().isoformat(),\n        'environment': config.env.value,\n        'checks': {}\n    }\n\n    # Check database connection\n    try:\n        db.command('ping')\n        checks['checks']['database'] = 'ok'\n    except Exception as e:\n        checks['status'] = 'unhealthy'\n        checks['checks']['database'] = f'error: {str(e)}'\n\n    # Check Redis connection\n    try:\n        redis_client.ping()\n        checks['checks']['redis'] = 'ok'\n    except Exception as e:\n        checks['status'] = 'unhealthy'\n        checks['checks']['redis'] = f'error: {str(e)}'\n\n    # Check Asleep API connectivity\n    try:\n        response = requests.get(\n            f\"{config.asleep_base_url}/health\",\n            headers={\"x-api-key\": config.asleep_api_key},\n            timeout=5\n        )\n        if response.status_code == 200:\n            checks['checks']['asleep_api'] = 'ok'\n        else:\n            checks['checks']['asleep_api'] = f'status: {response.status_code}'\n    except Exception as e:\n        checks['status'] = 'unhealthy'\n        checks['checks']['asleep_api'] = f'error: {str(e)}'\n\n    status_code = 200 if checks['status'] == 'healthy' else 503\n    return jsonify(checks), status_code\n\n@app.route('/ready')\ndef readiness_check():\n    \"\"\"Readiness check for Kubernetes\"\"\"\n    # Check if app is ready to serve traffic\n    if not app.initialized:\n        return jsonify({'status': 'not ready'}), 503\n\n    return jsonify({'status': 'ready'}), 200\n\n@app.route('/live')\ndef liveness_check():\n    \"\"\"Liveness check for Kubernetes\"\"\"\n    # Simple check that app is running\n    return jsonify({'status': 'alive'}), 200\n```\n\n## Error Recovery\n\n### Circuit Breaker Pattern\n\n```python\nfrom datetime import datetime, timedelta\n\nclass CircuitBreaker:\n    \"\"\"Circuit breaker for API calls\"\"\"\n\n    def __init__(self, failure_threshold: int = 5, timeout: int = 60):\n        self.failure_threshold = failure_threshold\n        self.timeout = timeout\n        self.failure_count = 0\n        self.last_failure_time = None\n        self.state = 'closed'  # closed, open, half_open\n\n    def call(self, func, *args, **kwargs):\n        \"\"\"Execute function with circuit breaker\"\"\"\n        if self.state == 'open':\n            if datetime.now() - self.last_failure_time > timedelta(seconds=self.timeout):\n                self.state = 'half_open'\n            else:\n                raise Exception(\"Circuit breaker is open\")\n\n        try:\n            result = func(*args, **kwargs)\n\n            if self.state == 'half_open':\n                self.state = 'closed'\n                self.failure_count = 0\n\n            return result\n\n        except Exception as e:\n            self.failure_count += 1\n            self.last_failure_time = datetime.now()\n\n            if self.failure_count >= self.failure_threshold:\n                self.state = 'open'\n\n            raise\n\nclass ResilientAsleepClient(AsleepClient):\n    \"\"\"Client with circuit breaker\"\"\"\n\n    def __init__(self, api_key: str):\n        super().__init__(api_key)\n        self.circuit_breaker = CircuitBreaker()\n\n    def _request(self, method: str, path: str, **kwargs):\n        \"\"\"Request with circuit breaker\"\"\"\n        return self.circuit_breaker.call(\n            super()._request,\n            method,\n            path,\n            **kwargs\n        )\n```\n\n## Database Patterns\n\n### Session Storage\n\n```python\nfrom pymongo import MongoClient\nfrom datetime import datetime\n\nclass SessionStore:\n    \"\"\"Store and retrieve sleep sessions\"\"\"\n\n    def __init__(self, db):\n        self.collection = db.sleep_sessions\n        self._create_indexes()\n\n    def _create_indexes(self):\n        \"\"\"Create database indexes for performance\"\"\"\n        self.collection.create_index([('user_id', 1), ('session_start_time', -1)])\n        self.collection.create_index([('session_id', 1)], unique=True)\n        self.collection.create_index([('created_at', 1)])\n\n    def store_session(self, session_data: Dict):\n        \"\"\"Store session in database\"\"\"\n        doc = {\n            'session_id': session_data['session']['id'],\n            'user_id': session_data['user_id'],\n            'session_start_time': session_data['session']['start_time'],\n            'session_end_time': session_data['session']['end_time'],\n            'statistics': session_data['stat'],\n            'sleep_stages': session_data['session']['sleep_stages'],\n            'created_at': datetime.now(),\n            'updated_at': datetime.now()\n        }\n\n        self.collection.update_one(\n            {'session_id': doc['session_id']},\n            {'$set': doc},\n            upsert=True\n        )\n\n    def get_user_sessions(self, user_id: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get recent sessions for user\"\"\"\n        return list(\n            self.collection\n            .find({'user_id': user_id})\n            .sort('session_start_time', -1)\n            .limit(limit)\n        )\n\n    def get_sessions_by_date_range(\n        self,\n        user_id: str,\n        start_date: str,\n        end_date: str\n    ) -> List[Dict]:\n        \"\"\"Get sessions within date range\"\"\"\n        return list(\n            self.collection.find({\n                'user_id': user_id,\n                'session_start_time': {\n                    '$gte': start_date,\n                    '$lte': end_date\n                }\n            })\n            .sort('session_start_time', -1)\n        )\n```\n\n## Background Job Processing\n\n### Celery Task Queue\n\n```python\nfrom celery import Celery\n\ncelery = Celery('tasks', broker='redis://localhost:6379')\n\n@celery.task(bind=True, max_retries=3)\ndef process_webhook_task(self, webhook_data: Dict):\n    \"\"\"Process webhook asynchronously\"\"\"\n    try:\n        if webhook_data['event'] == 'SESSION_COMPLETE':\n            # Store in database\n            store_session(webhook_data)\n\n            # Send notification\n            send_notification(webhook_data['user_id'], webhook_data)\n\n            # Update analytics\n            update_user_stats(webhook_data['user_id'])\n\n    except Exception as e:\n        # Retry with exponential backoff\n        raise self.retry(exc=e, countdown=2 ** self.request.retries)\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    \"\"\"Webhook endpoint with async processing\"\"\"\n    event = request.json\n\n    # Queue for background processing\n    process_webhook_task.delay(event)\n\n    # Respond immediately\n    return jsonify({\"status\": \"queued\"}), 200\n```\n\n## Performance Optimization\n\n### Batch Processing\n\n```python\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\ndef fetch_sessions_batch(client: AsleepClient, user_ids: List[str]) -> Dict[str, List]:\n    \"\"\"Fetch sessions for multiple users in parallel\"\"\"\n    results = {}\n\n    with ThreadPoolExecutor(max_workers=10) as executor:\n        future_to_user = {\n            executor.submit(client.list_sessions, user_id): user_id\n            for user_id in user_ids\n        }\n\n        for future in as_completed(future_to_user):\n            user_id = future_to_user[future]\n            try:\n                results[user_id] = future.result()\n            except Exception as e:\n                print(f\"Error fetching sessions for {user_id}: {e}\")\n                results[user_id] = []\n\n    return results\n```\n\n### Query Optimization\n\n```python\ndef get_user_summary_optimized(client: AsleepClient, user_id: str) -> Dict:\n    \"\"\"Get user summary with optimized queries\"\"\"\n    # Fetch only what's needed\n    user_data = client.get_user(user_id)\n\n    # Use average stats instead of fetching all sessions\n    stats = client.get_average_stats(\n        user_id=user_id,\n        start_date=(datetime.now() - timedelta(days=30)).strftime(\"%Y-%m-%d\"),\n        end_date=datetime.now().strftime(\"%Y-%m-%d\")\n    )\n\n    return {\n        'user_id': user_id,\n        'last_session': user_data.get('last_session_info'),\n        'monthly_average': stats['average_stats'],\n        'session_count': len(stats['slept_sessions'])\n    }\n```\n",
        "skills/sleeptrack-be/references/python_client_implementation.md": "# Python Client Implementation Guide\n\nThis reference provides complete Python client implementations for the Asleep API, including advanced patterns for analytics, production usage, and multi-tenant applications.\n\n## Complete Python API Client\n\n```python\nimport os\nimport requests\nfrom typing import Dict, Any, Optional\n\nclass AsleepClient:\n    \"\"\"Asleep API client for backend integration\"\"\"\n\n    def __init__(self, api_key: str, base_url: str = \"https://api.asleep.ai\"):\n        self.api_key = api_key\n        self.base_url = base_url\n        self.session = requests.Session()\n        self.session.headers.update({\"x-api-key\": api_key})\n\n    def _request(\n        self,\n        method: str,\n        path: str,\n        headers: Optional[Dict[str, str]] = None,\n        **kwargs\n    ) -> Dict[str, Any]:\n        \"\"\"Make authenticated API request with error handling\"\"\"\n        url = f\"{self.base_url}{path}\"\n        req_headers = self.session.headers.copy()\n        if headers:\n            req_headers.update(headers)\n\n        try:\n            response = self.session.request(method, url, headers=req_headers, **kwargs)\n            response.raise_for_status()\n            return response.json()\n        except requests.exceptions.HTTPError as e:\n            # Handle API errors\n            if e.response.status_code == 401:\n                raise ValueError(\"Invalid API key\")\n            elif e.response.status_code == 403:\n                error_detail = e.response.json().get(\"detail\", \"Access forbidden\")\n                raise ValueError(f\"API access error: {error_detail}\")\n            elif e.response.status_code == 404:\n                raise ValueError(\"Resource not found\")\n            else:\n                raise\n\n    # User management methods\n    def create_user(self, metadata: Optional[Dict[str, Any]] = None) -> str:\n        \"\"\"Create new user and return user_id\"\"\"\n        data = {\"metadata\": metadata} if metadata else {}\n        result = self._request(\"POST\", \"/ai/v1/users\", json=data)\n        return result[\"result\"][\"user_id\"]\n\n    def get_user(self, user_id: str) -> Dict[str, Any]:\n        \"\"\"Get user information\"\"\"\n        result = self._request(\"GET\", f\"/ai/v1/users/{user_id}\")\n        return result[\"result\"]\n\n    def delete_user(self, user_id: str) -> None:\n        \"\"\"Delete user and all associated data\"\"\"\n        self._request(\"DELETE\", f\"/ai/v1/users/{user_id}\")\n\n    # Session management methods\n    def get_session(self, session_id: str, user_id: str, timezone: str = \"UTC\") -> Dict[str, Any]:\n        \"\"\"Get detailed session data\"\"\"\n        headers = {\"x-user-id\": user_id, \"timezone\": timezone}\n        result = self._request(\"GET\", f\"/data/v3/sessions/{session_id}\", headers=headers)\n        return result[\"result\"]\n\n    def list_sessions(\n        self,\n        user_id: str,\n        date_gte: Optional[str] = None,\n        date_lte: Optional[str] = None,\n        offset: int = 0,\n        limit: int = 20,\n        order_by: str = \"DESC\"\n    ) -> Dict[str, Any]:\n        \"\"\"List user sessions with filtering\"\"\"\n        headers = {\"x-user-id\": user_id}\n        params = {\"offset\": offset, \"limit\": limit, \"order_by\": order_by}\n        if date_gte:\n            params[\"date_gte\"] = date_gte\n        if date_lte:\n            params[\"date_lte\"] = date_lte\n\n        result = self._request(\"GET\", \"/data/v1/sessions\", headers=headers, params=params)\n        return result[\"result\"]\n\n    def delete_session(self, session_id: str, user_id: str) -> None:\n        \"\"\"Delete session and all associated data\"\"\"\n        headers = {\"x-user-id\": user_id}\n        self._request(\"DELETE\", f\"/ai/v1/sessions/{session_id}\", headers=headers)\n\n    # Statistics methods\n    def get_average_stats(\n        self,\n        user_id: str,\n        start_date: str,\n        end_date: str,\n        timezone: str = \"UTC\"\n    ) -> Dict[str, Any]:\n        \"\"\"Get average statistics for date range (max 100 days)\"\"\"\n        headers = {\"timezone\": timezone}\n        params = {\"start_date\": start_date, \"end_date\": end_date}\n        result = self._request(\n            \"GET\",\n            f\"/data/v1/users/{user_id}/average-stats\",\n            headers=headers,\n            params=params\n        )\n        return result[\"result\"]\n\n# Usage\nclient = AsleepClient(api_key=os.getenv(\"ASLEEP_API_KEY\"))\n```\n\n## Advanced Analytics Implementation\n\n```python\nfrom typing import List, Dict\nfrom datetime import datetime, timedelta\n\nclass SleepAnalytics:\n    \"\"\"Backend analytics for sleep tracking platform\"\"\"\n\n    def __init__(self, client: AsleepClient, db):\n        self.client = client\n        self.db = db\n\n    def get_user_sleep_score(self, user_id: str, days: int = 30) -> Dict:\n        \"\"\"Calculate comprehensive sleep score for user\"\"\"\n        end_date = datetime.now()\n        start_date = end_date - timedelta(days=days)\n\n        stats = self.client.get_average_stats(\n            user_id=user_id,\n            start_date=start_date.strftime(\"%Y-%m-%d\"),\n            end_date=end_date.strftime(\"%Y-%m-%d\")\n        )\n\n        avg = stats['average_stats']\n\n        # Calculate weighted sleep score (0-100)\n        efficiency_score = avg['sleep_efficiency']  # Already 0-100\n        consistency_score = self._calculate_consistency_score(stats)\n        duration_score = self._calculate_duration_score(avg)\n\n        overall_score = (\n            efficiency_score * 0.4 +\n            consistency_score * 0.3 +\n            duration_score * 0.3\n        )\n\n        return {\n            'overall_score': round(overall_score, 1),\n            'efficiency_score': round(efficiency_score, 1),\n            'consistency_score': round(consistency_score, 1),\n            'duration_score': round(duration_score, 1),\n            'period_days': days,\n            'session_count': len(stats['slept_sessions'])\n        }\n\n    def _calculate_consistency_score(self, stats: Dict) -> float:\n        \"\"\"Score based on sleep schedule consistency\"\"\"\n        # Implement consistency scoring based on variance in sleep times\n        # Placeholder implementation\n        return 80.0\n\n    def _calculate_duration_score(self, avg: Dict) -> float:\n        \"\"\"Score based on sleep duration (7-9 hours optimal)\"\"\"\n        sleep_hours = avg['time_in_sleep'] / 3600\n\n        if 7 <= sleep_hours <= 9:\n            return 100.0\n        elif 6 <= sleep_hours < 7 or 9 < sleep_hours <= 10:\n            return 80.0\n        elif 5 <= sleep_hours < 6 or 10 < sleep_hours <= 11:\n            return 60.0\n        else:\n            return 40.0\n\n    def get_cohort_analysis(self, user_ids: List[str], days: int = 30) -> Dict:\n        \"\"\"Analyze sleep patterns across user cohort\"\"\"\n        cohort_data = []\n\n        for user_id in user_ids:\n            try:\n                score = self.get_user_sleep_score(user_id, days)\n                cohort_data.append({\n                    'user_id': user_id,\n                    'score': score['overall_score'],\n                    'efficiency': score['efficiency_score'],\n                    'sessions': score['session_count']\n                })\n            except Exception as e:\n                print(f\"Error fetching data for user {user_id}: {e}\")\n\n        if not cohort_data:\n            return {}\n\n        return {\n            'cohort_size': len(cohort_data),\n            'avg_score': sum(u['score'] for u in cohort_data) / len(cohort_data),\n            'avg_efficiency': sum(u['efficiency'] for u in cohort_data) / len(cohort_data),\n            'total_sessions': sum(u['sessions'] for u in cohort_data),\n            'users': cohort_data\n        }\n\n    def generate_weekly_report(self, user_id: str) -> Dict:\n        \"\"\"Generate comprehensive weekly sleep report\"\"\"\n        stats = self.client.get_average_stats(\n            user_id=user_id,\n            start_date=(datetime.now() - timedelta(days=7)).strftime(\"%Y-%m-%d\"),\n            end_date=datetime.now().strftime(\"%Y-%m-%d\")\n        )\n\n        avg = stats['average_stats']\n\n        return {\n            'period': 'Last 7 days',\n            'summary': {\n                'avg_sleep_time': avg['sleep_time'],\n                'avg_bedtime': avg['start_time'],\n                'avg_wake_time': avg['end_time'],\n                'avg_efficiency': avg['sleep_efficiency']\n            },\n            'sleep_stages': {\n                'light_hours': avg['time_in_light'] / 3600,\n                'deep_hours': avg['time_in_deep'] / 3600,\n                'rem_hours': avg['time_in_rem'] / 3600\n            },\n            'insights': self._generate_insights(avg),\n            'session_count': len(stats['slept_sessions'])\n        }\n\n    def _generate_insights(self, avg: Dict) -> List[str]:\n        \"\"\"Generate personalized sleep insights\"\"\"\n        insights = []\n\n        if avg['sleep_efficiency'] < 75:\n            insights.append(\"Your sleep efficiency is below average. Try establishing a consistent bedtime routine.\")\n\n        if avg['deep_ratio'] < 0.15:\n            insights.append(\"You're getting less deep sleep than optimal. Avoid caffeine after 2 PM.\")\n\n        if avg['waso_count'] > 3:\n            insights.append(\"You're waking up frequently during the night. Consider reducing screen time before bed.\")\n\n        return insights\n\n# Usage\nanalytics = SleepAnalytics(client, db)\nscore = analytics.get_user_sleep_score(\"user123\", days=30)\nprint(f\"Sleep score: {score['overall_score']}/100\")\n\nreport = analytics.generate_weekly_report(\"user123\")\nprint(f\"Weekly report: {report}\")\n```\n\n## Multi-Tenant Application Implementation\n\n```python\nclass MultiTenantSleepTracker:\n    \"\"\"Multi-tenant sleep tracking backend\"\"\"\n\n    def __init__(self, client: AsleepClient, db):\n        self.client = client\n        self.db = db\n\n    def create_organization(self, org_id: str, name: str, settings: Dict) -> Dict:\n        \"\"\"Create new organization\"\"\"\n        org = {\n            'org_id': org_id,\n            'name': name,\n            'settings': settings,\n            'created_at': datetime.now(),\n            'user_count': 0\n        }\n        self.db.organizations.insert_one(org)\n        return org\n\n    def add_user_to_organization(self, org_id: str, user_email: str, metadata: Dict = None) -> str:\n        \"\"\"Add user to organization and create Asleep user\"\"\"\n        # Verify organization exists\n        org = self.db.organizations.find_one({'org_id': org_id})\n        if not org:\n            raise ValueError(f\"Organization {org_id} not found\")\n\n        # Create Asleep user\n        asleep_user_id = self.client.create_user(metadata=metadata)\n\n        # Store user mapping\n        self.db.users.insert_one({\n            'org_id': org_id,\n            'user_email': user_email,\n            'asleep_user_id': asleep_user_id,\n            'metadata': metadata,\n            'created_at': datetime.now()\n        })\n\n        # Update organization user count\n        self.db.organizations.update_one(\n            {'org_id': org_id},\n            {'$inc': {'user_count': 1}}\n        )\n\n        return asleep_user_id\n\n    def get_organization_statistics(self, org_id: str, days: int = 30) -> Dict:\n        \"\"\"Get aggregated statistics for entire organization\"\"\"\n        # Get all users in organization\n        users = list(self.db.users.find({'org_id': org_id}))\n\n        end_date = datetime.now()\n        start_date = end_date - timedelta(days=days)\n\n        org_stats = {\n            'org_id': org_id,\n            'user_count': len(users),\n            'period_days': days,\n            'users_data': []\n        }\n\n        total_efficiency = 0\n        total_sleep_time = 0\n        total_sessions = 0\n\n        for user in users:\n            try:\n                stats = self.client.get_average_stats(\n                    user_id=user['asleep_user_id'],\n                    start_date=start_date.strftime(\"%Y-%m-%d\"),\n                    end_date=end_date.strftime(\"%Y-%m-%d\")\n                )\n\n                avg = stats['average_stats']\n                session_count = len(stats['slept_sessions'])\n\n                org_stats['users_data'].append({\n                    'user_email': user['user_email'],\n                    'efficiency': avg['sleep_efficiency'],\n                    'sleep_time': avg['sleep_time'],\n                    'session_count': session_count\n                })\n\n                total_efficiency += avg['sleep_efficiency']\n                total_sleep_time += avg['time_in_sleep']\n                total_sessions += session_count\n\n            except Exception as e:\n                print(f\"Error fetching stats for user {user['user_email']}: {e}\")\n\n        if users:\n            org_stats['avg_efficiency'] = total_efficiency / len(users)\n            org_stats['avg_sleep_hours'] = (total_sleep_time / len(users)) / 3600\n            org_stats['total_sessions'] = total_sessions\n\n        return org_stats\n\n# Usage\ntracker = MultiTenantSleepTracker(client, db)\n\n# Create organization\ntracker.create_organization(\n    org_id=\"acme-corp\",\n    name=\"Acme Corporation\",\n    settings={'timezone': 'America/New_York'}\n)\n\n# Add users\ntracker.add_user_to_organization(\"acme-corp\", \"john@acme.com\")\ntracker.add_user_to_organization(\"acme-corp\", \"jane@acme.com\")\n\n# Get organization stats\norg_stats = tracker.get_organization_statistics(\"acme-corp\", days=30)\nprint(f\"Organization average efficiency: {org_stats['avg_efficiency']:.1f}%\")\n```\n\n## FastAPI Backend Example\n\n```python\nfrom fastapi import FastAPI, HTTPException, Depends, Header\nfrom typing import Optional\nimport os\n\napp = FastAPI()\nasleep_client = AsleepClient(api_key=os.getenv(\"ASLEEP_API_KEY\"))\n\n# Authentication dependency\nasync def verify_app_token(authorization: str = Header(...)):\n    \"\"\"Verify mobile app authentication\"\"\"\n    if not authorization.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401, detail=\"Invalid authorization header\")\n\n    token = authorization[7:]\n    # Verify token with your auth system\n    user = verify_jwt_token(token)\n    if not user:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n    return user\n\n# Proxy endpoints\n@app.post(\"/api/users\")\nasync def create_user(\n    metadata: Optional[dict] = None,\n    user: dict = Depends(verify_app_token)\n):\n    \"\"\"Create Asleep user for authenticated app user\"\"\"\n    try:\n        # Create user in Asleep\n        asleep_user_id = asleep_client.create_user(metadata=metadata)\n\n        # Store mapping in your database\n        db.user_mappings.insert_one({\n            'app_user_id': user['id'],\n            'asleep_user_id': asleep_user_id,\n            'created_at': datetime.now()\n        })\n\n        return {\"user_id\": asleep_user_id}\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@app.get(\"/api/sessions/{session_id}\")\nasync def get_session(\n    session_id: str,\n    user: dict = Depends(verify_app_token)\n):\n    \"\"\"Get session data for authenticated user\"\"\"\n    # Get Asleep user ID from mapping\n    mapping = db.user_mappings.find_one({'app_user_id': user['id']})\n    if not mapping:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    asleep_user_id = mapping['asleep_user_id']\n\n    # Fetch session from Asleep\n    try:\n        session = asleep_client.get_session(session_id, asleep_user_id)\n        return session\n    except ValueError as e:\n        raise HTTPException(status_code=404, detail=str(e))\n\n@app.get(\"/api/sessions\")\nasync def list_sessions(\n    date_gte: Optional[str] = None,\n    date_lte: Optional[str] = None,\n    user: dict = Depends(verify_app_token)\n):\n    \"\"\"List sessions for authenticated user\"\"\"\n    mapping = db.user_mappings.find_one({'app_user_id': user['id']})\n    if not mapping:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    asleep_user_id = mapping['asleep_user_id']\n\n    sessions = asleep_client.list_sessions(\n        user_id=asleep_user_id,\n        date_gte=date_gte,\n        date_lte=date_lte\n    )\n\n    return sessions\n\n@app.get(\"/api/statistics\")\nasync def get_statistics(\n    start_date: str,\n    end_date: str,\n    user: dict = Depends(verify_app_token)\n):\n    \"\"\"Get average statistics for authenticated user\"\"\"\n    mapping = db.user_mappings.find_one({'app_user_id': user['id']})\n    if not mapping:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n\n    asleep_user_id = mapping['asleep_user_id']\n\n    stats = asleep_client.get_average_stats(\n        user_id=asleep_user_id,\n        start_date=start_date,\n        end_date=end_date\n    )\n\n    return stats\n```\n\n## Monthly Trends Analysis\n\n```python\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict\n\ndef get_monthly_trends(client, user_id: str, months: int = 6) -> List[Dict]:\n    \"\"\"Get monthly sleep trends for the past N months\"\"\"\n    trends = []\n    today = datetime.now()\n\n    for i in range(months):\n        # Calculate month boundaries\n        end_date = today.replace(day=1) - timedelta(days=i * 30)\n        start_date = end_date - timedelta(days=30)\n\n        try:\n            stats = client.get_average_stats(\n                user_id=user_id,\n                start_date=start_date.strftime(\"%Y-%m-%d\"),\n                end_date=end_date.strftime(\"%Y-%m-%d\")\n            )\n\n            trends.append({\n                'month': end_date.strftime(\"%Y-%m\"),\n                'avg_sleep_time': stats['average_stats']['sleep_time'],\n                'avg_efficiency': stats['average_stats']['sleep_efficiency'],\n                'session_count': len(stats['slept_sessions'])\n            })\n        except Exception as e:\n            print(f\"Error fetching stats for {end_date.strftime('%Y-%m')}: {e}\")\n\n    return trends\n\n# Usage\ntrends = get_monthly_trends(client, \"user123\", months=6)\nfor trend in trends:\n    print(f\"{trend['month']}: {trend['avg_sleep_time']} sleep, \"\n          f\"{trend['avg_efficiency']:.1f}% efficiency, \"\n          f\"{trend['session_count']} sessions\")\n```\n\n## Pagination Pattern\n\n```python\n# Fetch all sessions with pagination\nall_sessions = []\noffset = 0\nlimit = 100\n\nwhile True:\n    result = client.list_sessions(\n        user_id=\"user123\",\n        date_gte=\"2024-01-01\",\n        date_lte=\"2024-12-31\",\n        offset=offset,\n        limit=limit\n    )\n\n    sessions = result['sleep_session_list']\n    all_sessions.extend(sessions)\n\n    if len(sessions) < limit:\n        break\n\n    offset += limit\n\nprint(f\"Total sessions: {len(all_sessions)}\")\n```\n",
        "skills/sleeptrack-be/references/rest_api_reference.md": "# Asleep REST API Reference\n\nThis reference provides comprehensive documentation for the Asleep REST API endpoints.\n\n## Base URL\n\n```\nhttps://api.asleep.ai\n```\n\n## Authentication\n\nAll API requests require authentication via the `x-api-key` header:\n\n```http\nx-api-key: YOUR_API_KEY\n```\n\nObtain your API key from the [Asleep Dashboard](https://dashboard.asleep.ai).\n\n## Common Headers\n\n| Header | Type | Required | Description |\n|--------|------|----------|-------------|\n| x-api-key | String | Yes | API authentication key |\n| x-user-id | String | Conditional | Required for session operations |\n| timezone | String | No | Response timezone (default: UTC) |\n\n## Response Format\n\nAll responses follow this structure:\n\n```json\n{\n  \"detail\": \"message about the result\",\n  \"result\": { /* response data */ }\n}\n```\n\n## Common Error Codes\n\n| Status | Error | Description |\n|--------|-------|-------------|\n| 401 | Unauthorized | API Key missing or invalid |\n| 403 | Plan expired | Subscription period ended |\n| 403 | Rate limit exceeded | Request quota temporarily exceeded |\n| 403 | Quota exceeded | Total usage limit surpassed |\n| 404 | Not Found | Resource doesn't exist |\n\n---\n\n## User Management APIs\n\n### [POST] Create User\n\nCreates a new user for sleep tracking.\n\n**Endpoint:**\n```\nPOST https://api.asleep.ai/ai/v1/users\n```\n\n**Headers:**\n```\nx-api-key: YOUR_API_KEY\n```\n\n**Request Body (Optional):**\n```json\n{\n  \"metadata\": {\n    \"birth_year\": 1990,\n    \"birth_month\": 5,\n    \"birth_day\": 15,\n    \"gender\": \"male\",\n    \"height\": 175.5,\n    \"weight\": 70.0\n  }\n}\n```\n\n**Metadata Fields:**\n- `birth_year` (Integer): User's birth year\n- `birth_month` (Integer): User's birth month (1-12)\n- `birth_day` (Integer): User's birth day (1-31)\n- `gender` (String): One of: `male`, `female`, `non_binary`, `other`, `prefer_not_to_say`\n- `height` (Float): Height in cm (0-300)\n- `weight` (Float): Weight in kg (0-1000)\n\n**Response (201 Created):**\n```json\n{\n  \"detail\": \"success\",\n  \"result\": {\n    \"user_id\": \"550e8400-e29b-41d4-a716-446655440000\"\n  }\n}\n```\n\n**Example (curl):**\n```bash\ncurl -X POST \"https://api.asleep.ai/ai/v1/users\" \\\n  -H \"x-api-key: YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"metadata\": {\n      \"birth_year\": 1990,\n      \"gender\": \"male\",\n      \"height\": 175.5,\n      \"weight\": 70.0\n    }\n  }'\n```\n\n**Example (Python):**\n```python\nimport requests\n\nresponse = requests.post(\n    \"https://api.asleep.ai/ai/v1/users\",\n    headers={\"x-api-key\": \"YOUR_API_KEY\"},\n    json={\n        \"metadata\": {\n            \"birth_year\": 1990,\n            \"gender\": \"male\",\n            \"height\": 175.5,\n            \"weight\": 70.0\n        }\n    }\n)\nuser_id = response.json()[\"result\"][\"user_id\"]\n```\n\n---\n\n### [GET] Get User\n\nRetrieves user information and last session data.\n\n**Endpoint:**\n```\nGET https://api.asleep.ai/ai/v1/users/{user_id}\n```\n\n**Headers:**\n```\nx-api-key: YOUR_API_KEY\n```\n\n**Path Parameters:**\n- `user_id` (String): User identifier\n\n**Response (200 OK):**\n```json\n{\n  \"detail\": \"success\",\n  \"result\": {\n    \"user_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"to_be_deleted\": false,\n    \"last_session_info\": {\n      \"session_id\": \"abc123\",\n      \"state\": \"COMPLETE\",\n      \"session_start_time\": \"2024-01-20T22:00:00+00:00\",\n      \"session_end_time\": \"2024-01-21T06:30:00+00:00\"\n    },\n    \"metadata\": {\n      \"birth_year\": 1990,\n      \"birth_month\": 5,\n      \"birth_day\": 15,\n      \"gender\": \"male\",\n      \"height\": 175.5,\n      \"weight\": 70.0\n    }\n  }\n}\n```\n\n**Session States:**\n- `OPEN`: Session in progress, audio uploads available\n- `CLOSED`: Session terminated, analysis in progress\n- `COMPLETE`: All analysis completed\n\n**Error Response (404):**\n```json\n{\n  \"detail\": \"user does not exist\"\n}\n```\n\n**Example (curl):**\n```bash\ncurl -X GET \"https://api.asleep.ai/ai/v1/users/USER_ID\" \\\n  -H \"x-api-key: YOUR_API_KEY\"\n```\n\n**Example (Python):**\n```python\nimport requests\n\nresponse = requests.get(\n    f\"https://api.asleep.ai/ai/v1/users/{user_id}\",\n    headers={\"x-api-key\": \"YOUR_API_KEY\"}\n)\nuser_data = response.json()[\"result\"]\n```\n\n---\n\n### [DELETE] Delete User\n\nPermanently removes a user and all associated data.\n\n**Endpoint:**\n```\nDELETE https://api.asleep.ai/ai/v1/users/{user_id}\n```\n\n**Headers:**\n```\nx-api-key: YOUR_API_KEY\n```\n\n**Path Parameters:**\n- `user_id` (String): User identifier\n\n**Response (204 No Content):**\nUser information successfully deleted.\n\n**Error Responses:**\n\n401 Unauthorized:\n```json\n{\n  \"detail\": \"user_id is invalid\"\n}\n```\n\n404 Not Found:\n```json\n{\n  \"detail\": \"user does not exist\"\n}\n```\n\n**Example (curl):**\n```bash\ncurl -X DELETE \"https://api.asleep.ai/ai/v1/users/USER_ID\" \\\n  -H \"x-api-key: YOUR_API_KEY\"\n```\n\n**Example (Python):**\n```python\nimport requests\n\nresponse = requests.delete(\n    f\"https://api.asleep.ai/ai/v1/users/{user_id}\",\n    headers={\"x-api-key\": \"YOUR_API_KEY\"}\n)\n# 204 No Content on success\n```\n\n---\n\n## Session Management APIs\n\n### [GET] Get Session\n\nRetrieves comprehensive sleep analysis data for a specific session.\n\n**Endpoint:**\n```\nGET https://api.asleep.ai/data/v3/sessions/{session_id}\n```\n\n**Headers:**\n```\nx-api-key: YOUR_API_KEY\nx-user-id: USER_ID\ntimezone: Asia/Seoul  # Optional, defaults to UTC\n```\n\n**Path Parameters:**\n- `session_id` (String): Session identifier\n\n**Query Parameters:**\nNone\n\n**Response (200 OK):**\n```json\n{\n  \"detail\": \"success\",\n  \"result\": {\n    \"timezone\": \"UTC\",\n    \"peculiarities\": [],\n    \"missing_data_ratio\": 0.0,\n    \"session\": {\n      \"id\": \"session123\",\n      \"state\": \"COMPLETE\",\n      \"start_time\": \"2024-01-20T22:00:00+00:00\",\n      \"end_time\": \"2024-01-21T06:30:00+00:00\",\n      \"sleep_stages\": [0, 0, 1, 1, 2, 3, 2, 1, 0],\n      \"snoring_stages\": [0, 0, 0, 1, 1, 0, 0, 0, 0]\n    },\n    \"stat\": {\n      \"sleep_time\": \"06:30:00\",\n      \"sleep_index\": 85.5,\n      \"sleep_latency\": 900,\n      \"time_in_bed\": 30600,\n      \"time_in_sleep\": 27000,\n      \"time_in_light\": 13500,\n      \"time_in_deep\": 6750,\n      \"time_in_rem\": 6750,\n      \"sleep_efficiency\": 88.24,\n      \"waso_count\": 2,\n      \"longest_waso\": 300,\n      \"sleep_cycle\": [\n        {\n          \"order\": 1,\n          \"start_time\": \"2024-01-20T22:15:00+00:00\",\n          \"end_time\": \"2024-01-21T01:30:00+00:00\"\n        }\n      ]\n    }\n  }\n}\n```\n\n**Sleep Stages Values:**\n- `-1`: Unknown/No data\n- `0`: Wake\n- `1`: Light sleep\n- `2`: Deep sleep\n- `3`: REM sleep\n\n**Snoring Stages Values:**\n- `0`: No snoring\n- `1`: Snoring detected\n\n**Peculiarities:**\n- `IN_PROGRESS`: Session still being analyzed\n- `NEVER_SLEPT`: No sleep detected in session\n- `TOO_SHORT_FOR_ANALYSIS`: Session duration < 5 minutes\n\n**Error Responses:**\n\n400 Bad Request:\n```json\n{\n  \"detail\": \"Invalid timezone format\"\n}\n```\n\n404 Not Found:\n```json\n{\n  \"detail\": \"Session not found\"\n}\n```\n\n**Example (curl):**\n```bash\ncurl -X GET \"https://api.asleep.ai/data/v3/sessions/SESSION_ID\" \\\n  -H \"x-api-key: YOUR_API_KEY\" \\\n  -H \"x-user-id: USER_ID\" \\\n  -H \"timezone: UTC\"\n```\n\n**Example (Python):**\n```python\nimport requests\n\nresponse = requests.get(\n    f\"https://api.asleep.ai/data/v3/sessions/{session_id}\",\n    headers={\n        \"x-api-key\": \"YOUR_API_KEY\",\n        \"x-user-id\": user_id,\n        \"timezone\": \"UTC\"\n    }\n)\nsession_data = response.json()[\"result\"]\n```\n\n---\n\n### [GET] List Sessions\n\nRetrieves multiple sessions with filtering and pagination.\n\n**Endpoint:**\n```\nGET https://api.asleep.ai/data/v1/sessions\n```\n\n**Headers:**\n```\nx-api-key: YOUR_API_KEY\nx-user-id: USER_ID\ntimezone: UTC  # Optional\n```\n\n**Query Parameters:**\n| Parameter | Type | Required | Default | Description |\n|-----------|------|----------|---------|-------------|\n| date_gte | String (YYYY-MM-DD) | No | - | Sessions on or after this date |\n| date_lte | String (YYYY-MM-DD) | No | - | Sessions on or before this date |\n| order_by | String (ASC/DESC) | No | DESC | Sort direction by start time |\n| offset | Integer | No | 0 | Number of records to skip |\n| limit | Integer (0-100) | No | 20 | Maximum records per request |\n\n**Response (200 OK):**\n```json\n{\n  \"detail\": \"success\",\n  \"result\": {\n    \"timezone\": \"UTC\",\n    \"sleep_session_list\": [\n      {\n        \"session_id\": \"session123\",\n        \"state\": \"COMPLETE\",\n        \"session_start_time\": \"2024-01-20T22:00:00+00:00\",\n        \"session_end_time\": \"2024-01-21T06:30:00+00:00\",\n        \"created_timezone\": \"UTC\",\n        \"unexpected_end_time\": null,\n        \"last_received_seq_num\": 156,\n        \"time_in_bed\": 30600\n      }\n    ]\n  }\n}\n```\n\n**Error Response (400):**\n```json\n{\n  \"detail\": \"Invalid timezone\"\n}\n```\n\n**Example (curl):**\n```bash\ncurl -X GET \"https://api.asleep.ai/data/v1/sessions?date_gte=2024-01-01&limit=10\" \\\n  -H \"x-api-key: YOUR_API_KEY\" \\\n  -H \"x-user-id: USER_ID\"\n```\n\n**Example (Python):**\n```python\nimport requests\n\nresponse = requests.get(\n    \"https://api.asleep.ai/data/v1/sessions\",\n    headers={\n        \"x-api-key\": \"YOUR_API_KEY\",\n        \"x-user-id\": user_id\n    },\n    params={\n        \"date_gte\": \"2024-01-01\",\n        \"date_lte\": \"2024-01-31\",\n        \"limit\": 50,\n        \"order_by\": \"DESC\"\n    }\n)\nsessions = response.json()[\"result\"][\"sleep_session_list\"]\n```\n\n---\n\n### [DELETE] Delete Session\n\nPermanently removes a session and all associated data.\n\n**Endpoint:**\n```\nDELETE https://api.asleep.ai/ai/v1/sessions/{session_id}\n```\n\n**Headers:**\n```\nx-api-key: YOUR_API_KEY\nx-user-id: USER_ID\n```\n\n**Path Parameters:**\n- `session_id` (String): Session identifier\n\n**Response (204 No Content):**\nSession, uploaded audio, and analysis data successfully deleted.\n\n**Error Responses:**\n\n401 Unauthorized:\n```json\n{\n  \"detail\": \"x-user-id is invalid\"\n}\n```\n\n404 Not Found (User):\n```json\n{\n  \"detail\": \"user does not exist\"\n}\n```\n\n404 Not Found (Session):\n```json\n{\n  \"detail\": \"session does not exist\"\n}\n```\n\n**Example (curl):**\n```bash\ncurl -X DELETE \"https://api.asleep.ai/ai/v1/sessions/SESSION_ID\" \\\n  -H \"x-api-key: YOUR_API_KEY\" \\\n  -H \"x-user-id: USER_ID\"\n```\n\n**Example (Python):**\n```python\nimport requests\n\nresponse = requests.delete(\n    f\"https://api.asleep.ai/ai/v1/sessions/{session_id}\",\n    headers={\n        \"x-api-key\": \"YOUR_API_KEY\",\n        \"x-user-id\": user_id\n    }\n)\n# 204 No Content on success\n```\n\n---\n\n## Statistics APIs\n\n### [GET] Get Average Stats\n\nRetrieves average sleep metrics over a specified time period (up to 100 days).\n\n**Endpoint:**\n```\nGET https://api.asleep.ai/data/v1/users/{user_id}/average-stats\n```\n\n**Headers:**\n```\nx-api-key: YOUR_API_KEY\ntimezone: UTC  # Optional\n```\n\n**Path Parameters:**\n- `user_id` (String): User identifier\n\n**Query Parameters:**\n| Parameter | Type | Required | Description |\n|-----------|------|----------|-------------|\n| start_date | String (YYYY-MM-DD) | Yes | Period start date |\n| end_date | String (YYYY-MM-DD) | Yes | Period end date (max 100 days from start) |\n\n**Response (200 OK):**\n```json\n{\n  \"detail\": \"success\",\n  \"result\": {\n    \"period\": {\n      \"start_date\": \"2024-01-01\",\n      \"end_date\": \"2024-01-31\",\n      \"days\": 31\n    },\n    \"peculiarities\": [],\n    \"average_stats\": {\n      \"start_time\": \"22:30:00\",\n      \"end_time\": \"06:45:00\",\n      \"sleep_time\": \"07:15:00\",\n      \"wake_time\": \"06:45:00\",\n      \"sleep_latency\": 900,\n      \"wakeup_latency\": 300,\n      \"time_in_bed\": 30600,\n      \"time_in_sleep_period\": 29700,\n      \"time_in_sleep\": 26100,\n      \"time_in_wake\": 3600,\n      \"time_in_light\": 13050,\n      \"time_in_deep\": 6525,\n      \"time_in_rem\": 6525,\n      \"time_in_snoring\": 1800,\n      \"time_in_no_snoring\": 24300,\n      \"sleep_efficiency\": 85.29,\n      \"wake_ratio\": 0.12,\n      \"sleep_ratio\": 0.88,\n      \"light_ratio\": 0.50,\n      \"deep_ratio\": 0.25,\n      \"rem_ratio\": 0.25,\n      \"snoring_ratio\": 0.07,\n      \"no_snoring_ratio\": 0.93,\n      \"waso_count\": 2.5,\n      \"longest_waso\": 420,\n      \"sleep_cycle_count\": 4.2,\n      \"snoring_count\": 15.3\n    },\n    \"never_slept_sessions\": [],\n    \"slept_sessions\": [\n      {\n        \"session_id\": \"session123\",\n        \"session_start_time\": \"2024-01-20T22:00:00+00:00\"\n      }\n    ]\n  }\n}\n```\n\n**Metrics Explanation:**\n\n**Time Metrics** (HH:MM:SS format or seconds):\n- `start_time`: Average bedtime\n- `end_time`: Average wake time\n- `sleep_time`: Average time of falling asleep\n- `wake_time`: Average time of waking up\n- `sleep_latency`: Average time to fall asleep (seconds)\n- `wakeup_latency`: Average time from wake to getting up (seconds)\n- `time_in_bed`: Average total time in bed (seconds)\n- `time_in_sleep_period`: Average time from sleep onset to wake (seconds)\n- `time_in_sleep`: Average actual sleep time (seconds)\n- `time_in_wake`: Average wake time during sleep period (seconds)\n\n**Sleep Stage Durations** (seconds):\n- `time_in_light`: Average light sleep duration\n- `time_in_deep`: Average deep sleep duration\n- `time_in_rem`: Average REM sleep duration\n\n**Snoring Metrics** (seconds):\n- `time_in_snoring`: Average snoring duration\n- `time_in_no_snoring`: Average non-snoring duration\n\n**Ratio Metrics** (0-1 decimal):\n- `sleep_efficiency`: Sleep time / Time in bed\n- `wake_ratio`, `sleep_ratio`: Wake/sleep proportions\n- `light_ratio`, `deep_ratio`, `rem_ratio`: Sleep stage proportions\n- `snoring_ratio`, `no_snoring_ratio`: Snoring proportions\n\n**Event Counts**:\n- `waso_count`: Average wake after sleep onset episodes\n- `longest_waso`: Average longest wake episode (seconds)\n- `sleep_cycle_count`: Average number of sleep cycles\n- `snoring_count`: Average snoring episodes\n\n**Peculiarities:**\n- `NO_BREATHING_STABILITY`: Inconsistent breathing data\n\n**Error Responses:**\n\n400 Bad Request:\n```json\n{\n  \"detail\": \"The period should be less than or equal to 100 days\"\n}\n```\n\n404 Not Found:\n```json\n{\n  \"detail\": \"Unable to find the user of id {user_id}\"\n}\n```\n\n**Example (curl):**\n```bash\ncurl -X GET \"https://api.asleep.ai/data/v1/users/USER_ID/average-stats?start_date=2024-01-01&end_date=2024-01-31\" \\\n  -H \"x-api-key: YOUR_API_KEY\" \\\n  -H \"timezone: UTC\"\n```\n\n**Example (Python):**\n```python\nimport requests\n\nresponse = requests.get(\n    f\"https://api.asleep.ai/data/v1/users/{user_id}/average-stats\",\n    headers={\n        \"x-api-key\": \"YOUR_API_KEY\",\n        \"timezone\": \"UTC\"\n    },\n    params={\n        \"start_date\": \"2024-01-01\",\n        \"end_date\": \"2024-01-31\"\n    }\n)\nstats = response.json()[\"result\"]\n```\n\n---\n\n## Rate Limiting\n\nThe Asleep API implements rate limiting to ensure fair usage:\n\n- **Rate Limit Exceeded (403)**: Temporary quota exceeded\n- **Quota Exceeded (403)**: Total usage limit reached\n- **Plan Expired (403)**: Subscription period ended\n\nMonitor your usage in the [Asleep Dashboard](https://dashboard.asleep.ai).\n\n**Best Practices:**\n- Implement exponential backoff for retries\n- Cache responses when appropriate\n- Batch requests when possible\n- Monitor usage proactively\n\n---\n\n## API Versioning\n\nThe Asleep API uses versioned endpoints (e.g., `/v1/`, `/v3/`). Version upgrades occur when:\n\n- Renaming response object fields\n- Modifying data types or enum values\n- Restructuring response objects\n- Introducing breaking changes\n\nNon-breaking changes (like adding new fields) don't trigger version upgrades.\n\n**Current Versions:**\n- User Management: `/ai/v1/`\n- Session Data: `/data/v3/` (Get Session), `/data/v1/` (List Sessions)\n- Statistics: `/data/v1/`\n",
        "skills/sleeptrack-be/references/webhook_implementation_guide.md": "# Webhook Implementation Guide\n\nThis reference provides complete webhook handler implementations for both Python and Node.js, including best practices and payload examples.\n\n## Flask Webhook Handler (Python)\n\n```python\nfrom flask import Flask, request, jsonify\nimport os\nimport logging\n\napp = Flask(__name__)\nlogger = logging.getLogger(__name__)\n\nEXPECTED_API_KEY = os.getenv(\"ASLEEP_API_KEY\")\n\n@app.route('/asleep-webhook', methods=['POST'])\ndef asleep_webhook():\n    \"\"\"Handle Asleep webhook events\"\"\"\n\n    # Verify authentication\n    api_key = request.headers.get('x-api-key')\n    user_id = request.headers.get('x-user-id')\n\n    if api_key != EXPECTED_API_KEY:\n        logger.warning(f\"Unauthorized webhook attempt from {request.remote_addr}\")\n        return jsonify({\"error\": \"Unauthorized\"}), 401\n\n    # Parse event\n    event = request.json\n    event_type = event.get('event')\n\n    logger.info(f\"Received {event_type} event for user {user_id}\")\n\n    try:\n        if event_type == 'INFERENCE_COMPLETE':\n            handle_inference_complete(event)\n        elif event_type == 'SESSION_COMPLETE':\n            handle_session_complete(event)\n        else:\n            logger.warning(f\"Unknown event type: {event_type}\")\n\n        return jsonify({\"status\": \"success\"}), 200\n\n    except Exception as e:\n        logger.error(f\"Webhook processing error: {e}\", exc_info=True)\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 500\n\ndef handle_inference_complete(event):\n    \"\"\"Process incremental sleep data\"\"\"\n    session_id = event['session_id']\n    user_id = event['user_id']\n    sleep_stages = event['sleep_stages']\n\n    # Update real-time dashboard\n    update_live_dashboard(session_id, sleep_stages)\n\n    # Store incremental data\n    db.incremental_data.insert_one(event)\n\n    logger.info(f\"Processed INFERENCE_COMPLETE for session {session_id}\")\n\ndef handle_session_complete(event):\n    \"\"\"Process complete sleep report\"\"\"\n    session_id = event['session_id']\n    user_id = event['user_id']\n    stat = event['stat']\n\n    # Store complete report\n    db.sleep_reports.insert_one({\n        'user_id': user_id,\n        'session_id': session_id,\n        'date': event['session']['start_time'],\n        'statistics': stat,\n        'session_data': event['session'],\n        'created_at': datetime.now()\n    })\n\n    # Send user notification\n    send_push_notification(user_id, {\n        'title': 'Sleep Report Ready',\n        'body': f\"Sleep time: {stat['sleep_time']}, Efficiency: {stat['sleep_efficiency']:.1f}%\"\n    })\n\n    # Update user statistics\n    update_user_aggregated_stats(user_id)\n\n    logger.info(f\"Processed SESSION_COMPLETE for session {session_id}\")\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```\n\n## Express Webhook Handler (Node.js)\n\n```javascript\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\nconst EXPECTED_API_KEY = process.env.ASLEEP_API_KEY;\n\napp.post('/asleep-webhook', async (req, res) => {\n  // Verify authentication\n  const apiKey = req.headers['x-api-key'];\n  const userId = req.headers['x-user-id'];\n\n  if (apiKey !== EXPECTED_API_KEY) {\n    console.warn('Unauthorized webhook attempt');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  const { event, session_id, stat } = req.body;\n  console.log(`Received ${event} event for user ${userId}`);\n\n  try {\n    switch (event) {\n      case 'INFERENCE_COMPLETE':\n        await handleInferenceComplete(req.body);\n        break;\n      case 'SESSION_COMPLETE':\n        await handleSessionComplete(req.body);\n        break;\n      default:\n        console.warn(`Unknown event type: ${event}`);\n    }\n\n    res.status(200).json({ status: 'success' });\n  } catch (error) {\n    console.error('Webhook processing error:', error);\n    res.status(500).json({ error: 'Processing failed' });\n  }\n});\n\nasync function handleInferenceComplete(event) {\n  const { session_id, user_id, sleep_stages } = event;\n\n  // Update real-time dashboard\n  await updateLiveDashboard(session_id, sleep_stages);\n\n  // Store incremental data\n  await db.collection('incremental_data').insertOne(event);\n\n  console.log(`Processed INFERENCE_COMPLETE for session ${session_id}`);\n}\n\nasync function handleSessionComplete(event) {\n  const { session_id, user_id, stat, session } = event;\n\n  // Store complete report\n  await db.collection('sleep_reports').insertOne({\n    user_id,\n    session_id,\n    date: session.start_time,\n    statistics: stat,\n    session_data: session,\n    created_at: new Date()\n  });\n\n  // Send user notification\n  await sendPushNotification(user_id, {\n    title: 'Sleep Report Ready',\n    body: `Sleep time: ${stat.sleep_time}, Efficiency: ${stat.sleep_efficiency.toFixed(1)}%`\n  });\n\n  // Update user statistics\n  await updateUserAggregatedStats(user_id);\n\n  console.log(`Processed SESSION_COMPLETE for session ${session_id}`);\n}\n\nconst PORT = process.env.PORT || 5000;\napp.listen(PORT, () => {\n  console.log(`Webhook server listening on port ${PORT}`);\n});\n```\n\n## Webhook Event Payloads\n\n### INFERENCE_COMPLETE Event\n\nSent every 5-40 minutes during sleep tracking with incremental data.\n\n```json\n{\n  \"event\": \"INFERENCE_COMPLETE\",\n  \"version\": \"V3\",\n  \"timestamp\": \"2024-01-21T06:15:00Z\",\n  \"user_id\": \"user123\",\n  \"session_id\": \"session123\",\n  \"seq_num\": 60,\n  \"inference_seq_num\": 12,\n  \"sleep_stages\": [1, 1, 2, 2, 2],\n  \"snoring_stages\": [0, 0, 1, 1, 0]\n}\n```\n\n**Fields:**\n- `event`: Event type identifier\n- `version`: API version (V3)\n- `timestamp`: Event timestamp in ISO 8601 format\n- `user_id`: User identifier\n- `session_id`: Sleep session identifier\n- `seq_num`: Sequence number for raw data\n- `inference_seq_num`: Sequence number for inference results\n- `sleep_stages`: Array of sleep stage values (see sleep stages reference)\n- `snoring_stages`: Array of snoring detection values (0 = no snoring, 1 = snoring)\n\n### SESSION_COMPLETE Event\n\nSent when sleep session ends with complete analysis.\n\n```json\n{\n  \"event\": \"SESSION_COMPLETE\",\n  \"version\": \"V3\",\n  \"timestamp\": \"2024-01-21T06:30:00Z\",\n  \"user_id\": \"user123\",\n  \"session_id\": \"session123\",\n  \"session\": {\n    \"id\": \"session123\",\n    \"state\": \"COMPLETE\",\n    \"start_time\": \"2024-01-20T22:00:00+00:00\",\n    \"end_time\": \"2024-01-21T06:30:00+00:00\",\n    \"sleep_stages\": [0, 0, 1, 1, 2, 3, 2, 1, 0],\n    \"snoring_stages\": [0, 0, 0, 1, 1, 0, 0, 0, 0]\n  },\n  \"stat\": {\n    \"sleep_time\": \"06:30:00\",\n    \"sleep_efficiency\": 88.24,\n    \"time_in_bed\": 30600,\n    \"time_in_sleep\": 27000,\n    \"time_in_wake\": 3600,\n    \"time_in_light\": 14400,\n    \"time_in_deep\": 7200,\n    \"time_in_rem\": 5400,\n    \"waso_count\": 2,\n    \"sleep_latency\": 900,\n    \"sleep_cycle\": [\n      {\n        \"index\": 0,\n        \"start_time\": \"2024-01-20T22:15:00+00:00\",\n        \"end_time\": \"2024-01-21T01:45:00+00:00\"\n      },\n      {\n        \"index\": 1,\n        \"start_time\": \"2024-01-21T01:45:00+00:00\",\n        \"end_time\": \"2024-01-21T05:15:00+00:00\"\n      }\n    ]\n  }\n}\n```\n\n**Sleep Stage Values:**\n- `-1`: Unknown/No data\n- `0`: Wake\n- `1`: Light sleep\n- `2`: Deep sleep\n- `3`: REM sleep\n\n## Webhook Best Practices\n\n### 1. Idempotency\n\nHandle duplicate webhook deliveries gracefully:\n\n**Python:**\n```python\ndef handle_session_complete(event):\n    session_id = event['session_id']\n\n    # Check if already processed\n    if db.processed_webhooks.find_one({'session_id': session_id, 'event': 'SESSION_COMPLETE'}):\n        logger.info(f\"Session {session_id} already processed, skipping\")\n        return\n\n    # Process event\n    save_sleep_report(event)\n\n    # Mark as processed\n    db.processed_webhooks.insert_one({\n        'session_id': session_id,\n        'event': 'SESSION_COMPLETE',\n        'processed_at': datetime.now()\n    })\n```\n\n**Node.js:**\n```javascript\nasync function handleSessionComplete(event) {\n  const sessionId = event.session_id;\n\n  // Check if already processed\n  const existing = await db.collection('processed_webhooks').findOne({\n    session_id: sessionId,\n    event: 'SESSION_COMPLETE'\n  });\n\n  if (existing) {\n    console.log(`Session ${sessionId} already processed, skipping`);\n    return;\n  }\n\n  // Process event\n  await saveSleepReport(event);\n\n  // Mark as processed\n  await db.collection('processed_webhooks').insertOne({\n    session_id: sessionId,\n    event: 'SESSION_COMPLETE',\n    processed_at: new Date()\n  });\n}\n```\n\n### 2. Asynchronous Processing\n\nProcess webhooks asynchronously to respond quickly:\n\n**Python (Celery):**\n```python\nfrom celery import Celery\n\ncelery = Celery('tasks', broker='redis://localhost:6379')\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    event = request.json\n\n    # Queue for async processing\n    process_webhook_async.delay(event)\n\n    # Respond immediately\n    return jsonify({\"status\": \"queued\"}), 200\n\n@celery.task\ndef process_webhook_async(event):\n    \"\"\"Process webhook asynchronously\"\"\"\n    if event['event'] == 'SESSION_COMPLETE':\n        handle_session_complete(event)\n```\n\n**Node.js (Bull):**\n```javascript\nconst Queue = require('bull');\n\nconst webhookQueue = new Queue('asleep-webhooks', {\n  redis: { host: 'localhost', port: 6379 }\n});\n\napp.post('/webhook', async (req, res) => {\n  const event = req.body;\n\n  // Queue for async processing\n  await webhookQueue.add(event);\n\n  // Respond immediately\n  res.status(200).json({ status: 'queued' });\n});\n\n// Process queued webhooks\nwebhookQueue.process(async (job) => {\n  const event = job.data;\n\n  if (event.event === 'SESSION_COMPLETE') {\n    await handleSessionComplete(event);\n  }\n});\n```\n\n### 3. Security\n\nAlways verify webhook authenticity:\n\n```python\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    # Verify API key\n    api_key = request.headers.get('x-api-key')\n    if api_key != EXPECTED_API_KEY:\n        logger.warning(f\"Unauthorized webhook from {request.remote_addr}\")\n        return jsonify({\"error\": \"Unauthorized\"}), 401\n\n    # Verify user ID presence\n    user_id = request.headers.get('x-user-id')\n    if not user_id:\n        logger.warning(\"Missing x-user-id header\")\n        return jsonify({\"error\": \"Missing user ID\"}), 400\n\n    # Process webhook\n    # ...\n```\n\n### 4. Error Handling\n\nImplement robust error handling:\n\n```python\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    try:\n        event = request.json\n        event_type = event.get('event')\n\n        if event_type == 'SESSION_COMPLETE':\n            handle_session_complete(event)\n        elif event_type == 'INFERENCE_COMPLETE':\n            handle_inference_complete(event)\n        else:\n            logger.warning(f\"Unknown event type: {event_type}\")\n            return jsonify({\"error\": \"Unknown event type\"}), 400\n\n        return jsonify({\"status\": \"success\"}), 200\n\n    except ValueError as e:\n        logger.error(f\"Validation error: {e}\")\n        return jsonify({\"error\": str(e)}), 400\n    except Exception as e:\n        logger.error(f\"Processing error: {e}\", exc_info=True)\n        return jsonify({\"error\": \"Internal server error\"}), 500\n```\n\n### 5. Logging\n\nLog all webhook events for debugging:\n\n```python\nimport logging\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('webhooks.log'),\n        logging.StreamHandler()\n    ]\n)\n\nlogger = logging.getLogger(__name__)\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    user_id = request.headers.get('x-user-id')\n    event = request.json\n    event_type = event.get('event')\n\n    logger.info(f\"Webhook received - Type: {event_type}, User: {user_id}, Session: {event.get('session_id')}\")\n\n    try:\n        # Process webhook\n        # ...\n        logger.info(f\"Webhook processed successfully - Session: {event.get('session_id')}\")\n    except Exception as e:\n        logger.error(f\"Webhook processing failed - Session: {event.get('session_id')}, Error: {e}\", exc_info=True)\n```\n\n## Testing Webhooks Locally\n\n### Using ngrok\n\n```bash\n# Start your local server\npython app.py  # or npm start\n\n# In another terminal, expose with ngrok\nngrok http 5000\n\n# Use the ngrok URL as webhook URL in Asleep Dashboard\n# Example: https://abc123.ngrok.io/asleep-webhook\n```\n\n### Mock Webhook for Testing\n\n**Python:**\n```python\nimport requests\nimport json\n\ndef send_test_webhook(url, event_type='SESSION_COMPLETE'):\n    \"\"\"Send test webhook to local server\"\"\"\n\n    if event_type == 'SESSION_COMPLETE':\n        payload = {\n            \"event\": \"SESSION_COMPLETE\",\n            \"version\": \"V3\",\n            \"timestamp\": \"2024-01-21T06:30:00Z\",\n            \"user_id\": \"test_user\",\n            \"session_id\": \"test_session\",\n            \"session\": {\n                \"id\": \"test_session\",\n                \"state\": \"COMPLETE\",\n                \"start_time\": \"2024-01-20T22:00:00+00:00\",\n                \"end_time\": \"2024-01-21T06:30:00+00:00\",\n                \"sleep_stages\": [0, 1, 2, 3, 2, 1, 0]\n            },\n            \"stat\": {\n                \"sleep_time\": \"06:30:00\",\n                \"sleep_efficiency\": 88.24,\n                \"time_in_bed\": 30600,\n                \"time_in_sleep\": 27000\n            }\n        }\n    else:\n        payload = {\n            \"event\": \"INFERENCE_COMPLETE\",\n            \"version\": \"V3\",\n            \"timestamp\": \"2024-01-21T06:15:00Z\",\n            \"user_id\": \"test_user\",\n            \"session_id\": \"test_session\",\n            \"seq_num\": 60,\n            \"inference_seq_num\": 12,\n            \"sleep_stages\": [1, 1, 2, 2, 2]\n        }\n\n    headers = {\n        'x-api-key': 'your_api_key',\n        'x-user-id': 'test_user',\n        'Content-Type': 'application/json'\n    }\n\n    response = requests.post(url, headers=headers, json=payload)\n    print(f\"Status: {response.status_code}\")\n    print(f\"Response: {response.json()}\")\n\n# Test locally\nsend_test_webhook('http://localhost:5000/asleep-webhook')\n```\n\n## Common Webhook Patterns\n\n### Real-time Dashboard Updates\n\n```python\ndef handle_inference_complete(event):\n    \"\"\"Update real-time dashboard with incremental data\"\"\"\n    session_id = event['session_id']\n    user_id = event['user_id']\n    sleep_stages = event['sleep_stages']\n\n    # Broadcast to connected clients via WebSocket\n    socketio.emit('sleep_update', {\n        'session_id': session_id,\n        'sleep_stages': sleep_stages,\n        'timestamp': event['timestamp']\n    }, room=user_id)\n```\n\n### Sleep Report Notifications\n\n```python\ndef handle_session_complete(event):\n    \"\"\"Send notification when sleep report is ready\"\"\"\n    user_id = event['user_id']\n    stat = event['stat']\n\n    # Send push notification\n    send_push_notification(user_id, {\n        'title': 'Your Sleep Report is Ready',\n        'body': f\"You slept for {stat['sleep_time']} with {stat['sleep_efficiency']:.1f}% efficiency\",\n        'data': {\n            'session_id': event['session_id'],\n            'action': 'view_report'\n        }\n    })\n```\n\n### Data Aggregation\n\n```python\ndef handle_session_complete(event):\n    \"\"\"Update aggregated user statistics\"\"\"\n    user_id = event['user_id']\n    stat = event['stat']\n\n    # Update rolling averages\n    db.user_stats.update_one(\n        {'user_id': user_id},\n        {\n            '$inc': {\n                'total_sessions': 1,\n                'total_sleep_time': stat['time_in_sleep']\n            },\n            '$push': {\n                'recent_efficiency': {\n                    '$each': [stat['sleep_efficiency']],\n                    '$slice': -30  # Keep last 30 sessions\n                }\n            }\n        },\n        upsert=True\n    )\n```\n",
        "skills/sleeptrack-be/references/webhook_reference.md": "# Asleep Webhook Reference\n\nThis reference provides comprehensive documentation for implementing Asleep webhooks in backend applications.\n\n## Overview\n\nAsleep webhooks enable real-time notifications about sleep session events. The system sends HTTP POST requests to your configured callback URL when specific events occur.\n\n## Webhook Configuration\n\nWebhooks are configured by providing a callback URL during session operations (via SDK) or through the Asleep Dashboard.\n\n**Callback URL Requirements:**\n- Must be publicly accessible HTTPS endpoint\n- Should respond with 2xx status code\n- Should handle requests within 30 seconds\n\n## Authentication\n\nWebhook requests include authentication headers:\n\n```http\nx-api-key: YOUR_API_KEY\nx-user-id: USER_ID\n```\n\n**Security Best Practices:**\n- Verify the `x-api-key` matches your expected API key\n- Validate the `x-user-id` belongs to your system\n- Use HTTPS for your webhook endpoint\n- Implement request signing if needed\n- Log all webhook attempts for audit\n\n## Supported Events\n\nAsleep webhooks support two primary event types:\n\n### 1. INFERENCE_COMPLETE\n\nTriggered during sleep session analysis at regular intervals (every 5 or 40 minutes).\n\n**Use Cases:**\n- Real-time sleep stage monitoring\n- Live dashboard updates\n- Progressive data analysis\n- User notifications during tracking\n\n**Timing:**\n- Fires every 5 minutes during active tracking\n- May also fire at 40-minute intervals\n- Multiple events per session\n\n### 2. SESSION_COMPLETE\n\nTriggered when complete sleep session analysis finishes.\n\n**Use Cases:**\n- Final report generation\n- User notifications\n- Data storage\n- Statistics calculation\n- Integration with other systems\n\n**Timing:**\n- Fires once per session\n- Occurs after session end\n- Contains complete analysis\n\n## Webhook Payload Schemas\n\n### INFERENCE_COMPLETE Payload\n\nProvides incremental sleep analysis data.\n\n**Structure:**\n```json\n{\n  \"event\": \"INFERENCE_COMPLETE\",\n  \"version\": \"V3\",\n  \"timestamp\": \"2024-01-21T06:15:00Z\",\n  \"user_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"session_id\": \"session123\",\n  \"seq_num\": 60,\n  \"inference_seq_num\": 12,\n  \"sleep_stages\": [1, 1, 2, 2, 2],\n  \"breath_stages\": [0, 0, 0, 0, 0],\n  \"snoring_stages\": [0, 0, 1, 1, 0],\n  \"time_window\": {\n    \"start\": \"2024-01-21T06:10:00Z\",\n    \"end\": \"2024-01-21T06:15:00Z\"\n  }\n}\n```\n\n**Field Descriptions:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| event | String | Always \"INFERENCE_COMPLETE\" |\n| version | String | API version (V1, V2, V3) |\n| timestamp | String (ISO 8601) | Event generation time |\n| user_id | String | User identifier |\n| session_id | String | Session identifier |\n| seq_num | Integer | Audio data upload sequence number |\n| inference_seq_num | Integer | Analysis sequence (5-minute increments) |\n| sleep_stages | Array[Integer] | Sleep stage values for time window |\n| breath_stages | Array[Integer] | Breathing stability indicators |\n| snoring_stages | Array[Integer] | Snoring detection values |\n| time_window | Object | Time range for this analysis chunk |\n\n**Sleep Stage Values:**\n- `-1`: Unknown/No data\n- `0`: Wake\n- `1`: Light sleep\n- `2`: Deep sleep\n- `3`: REM sleep\n\n**Snoring Stage Values:**\n- `0`: No snoring\n- `1`: Snoring detected\n\n**Example Handler (Python):**\n```python\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/webhook', methods=['POST'])\ndef handle_inference():\n    # Verify authentication\n    api_key = request.headers.get('x-api-key')\n    user_id = request.headers.get('x-user-id')\n\n    if api_key != EXPECTED_API_KEY:\n        return jsonify({\"error\": \"Unauthorized\"}), 401\n\n    # Parse payload\n    data = request.json\n\n    if data['event'] == 'INFERENCE_COMPLETE':\n        session_id = data['session_id']\n        sleep_stages = data['sleep_stages']\n\n        # Process incremental data\n        update_live_dashboard(session_id, sleep_stages)\n\n        # Store for real-time analysis\n        store_incremental_data(data)\n\n    return jsonify({\"status\": \"received\"}), 200\n```\n\n**Example Handler (Node.js):**\n```javascript\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/webhook', async (req, res) => {\n  // Verify authentication\n  const apiKey = req.headers['x-api-key'];\n  const userId = req.headers['x-user-id'];\n\n  if (apiKey !== process.env.ASLEEP_API_KEY) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  const { event, session_id, sleep_stages } = req.body;\n\n  if (event === 'INFERENCE_COMPLETE') {\n    // Update real-time dashboard\n    await updateLiveDashboard(session_id, sleep_stages);\n\n    // Store incremental data\n    await storeIncrementalData(req.body);\n  }\n\n  res.status(200).json({ status: 'received' });\n});\n```\n\n---\n\n### SESSION_COMPLETE Payload\n\nProvides comprehensive final sleep analysis.\n\n**Structure:**\n```json\n{\n  \"event\": \"SESSION_COMPLETE\",\n  \"version\": \"V3\",\n  \"timestamp\": \"2024-01-21T06:30:00Z\",\n  \"user_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"session_id\": \"session123\",\n  \"session\": {\n    \"id\": \"session123\",\n    \"state\": \"COMPLETE\",\n    \"start_time\": \"2024-01-20T22:00:00+00:00\",\n    \"end_time\": \"2024-01-21T06:30:00+00:00\",\n    \"timezone\": \"UTC\",\n    \"sleep_stages\": [0, 0, 1, 1, 2, 3, 2, 1, 0],\n    \"snoring_stages\": [0, 0, 0, 1, 1, 0, 0, 0, 0]\n  },\n  \"stat\": {\n    \"sleep_time\": \"06:30:00\",\n    \"sleep_index\": 85.5,\n    \"sleep_latency\": 900,\n    \"time_in_bed\": 30600,\n    \"time_in_sleep\": 27000,\n    \"time_in_light\": 13500,\n    \"time_in_deep\": 6750,\n    \"time_in_rem\": 6750,\n    \"sleep_efficiency\": 88.24,\n    \"waso_count\": 2,\n    \"longest_waso\": 300,\n    \"sleep_cycle\": [\n      {\n        \"order\": 1,\n        \"start_time\": \"2024-01-20T22:15:00+00:00\",\n        \"end_time\": \"2024-01-21T01:30:00+00:00\"\n      }\n    ]\n  },\n  \"peculiarities\": []\n}\n```\n\n**Field Descriptions:**\n\n| Field | Type | Description |\n|-------|------|-------------|\n| event | String | Always \"SESSION_COMPLETE\" |\n| version | String | API version (V1, V2, V3) |\n| timestamp | String (ISO 8601) | Event generation time |\n| user_id | String | User identifier |\n| session_id | String | Session identifier |\n| session | Object | Complete session data |\n| stat | Object | Comprehensive sleep statistics |\n| peculiarities | Array[String] | Special session conditions |\n\n**Session Object Fields:**\n- `id`: Session identifier\n- `state`: Always \"COMPLETE\" for this event\n- `start_time`, `end_time`: Session timestamps (ISO 8601)\n- `timezone`: Timezone of the session\n- `sleep_stages`: Complete sleep stage timeline\n- `snoring_stages`: Complete snoring timeline\n\n**Stat Object Fields:**\n- `sleep_time`: Total sleep duration (HH:MM:SS)\n- `sleep_index`: Overall sleep quality score (0-100)\n- `sleep_latency`: Time to fall asleep (seconds)\n- `time_in_bed`: Total time in bed (seconds)\n- `time_in_sleep`: Total actual sleep time (seconds)\n- `time_in_light/deep/rem`: Stage durations (seconds)\n- `sleep_efficiency`: Percentage of time spent sleeping\n- `waso_count`: Wake after sleep onset episodes\n- `longest_waso`: Longest wake episode (seconds)\n- `sleep_cycle`: Array of sleep cycle objects\n\n**Peculiarities:**\n- `IN_PROGRESS`: Analysis still ongoing (shouldn't occur for COMPLETE)\n- `NEVER_SLEPT`: No sleep detected\n- `TOO_SHORT_FOR_ANALYSIS`: Session < 5 minutes\n- `NO_BREATHING_STABILITY`: Inconsistent breathing data\n\n**Example Handler (Python):**\n```python\nfrom flask import Flask, request, jsonify\nimport logging\n\napp = Flask(__name__)\nlogger = logging.getLogger(__name__)\n\n@app.route('/webhook', methods=['POST'])\ndef handle_session_complete():\n    # Verify authentication\n    api_key = request.headers.get('x-api-key')\n    user_id = request.headers.get('x-user-id')\n\n    if api_key != EXPECTED_API_KEY:\n        logger.warning(f\"Unauthorized webhook attempt from {request.remote_addr}\")\n        return jsonify({\"error\": \"Unauthorized\"}), 401\n\n    # Parse payload\n    data = request.json\n\n    if data['event'] == 'SESSION_COMPLETE':\n        session_id = data['session_id']\n        stat = data['stat']\n\n        # Store complete report\n        save_sleep_report(user_id, session_id, data)\n\n        # Send user notification\n        notify_user(user_id, {\n            'session_id': session_id,\n            'sleep_time': stat['sleep_time'],\n            'sleep_efficiency': stat['sleep_efficiency'],\n            'sleep_index': stat['sleep_index']\n        })\n\n        # Update user statistics\n        update_user_statistics(user_id)\n\n        # Trigger integrations\n        sync_to_health_platform(user_id, data)\n\n        logger.info(f\"Processed SESSION_COMPLETE for {session_id}\")\n\n    return jsonify({\"status\": \"processed\"}), 200\n```\n\n**Example Handler (Node.js):**\n```javascript\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\napp.post('/webhook', async (req, res) => {\n  // Verify authentication\n  const apiKey = req.headers['x-api-key'];\n  const userId = req.headers['x-user-id'];\n\n  if (apiKey !== process.env.ASLEEP_API_KEY) {\n    console.warn('Unauthorized webhook attempt');\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  const { event, session_id, stat } = req.body;\n\n  if (event === 'SESSION_COMPLETE') {\n    try {\n      // Store complete report\n      await saveSleepReport(userId, session_id, req.body);\n\n      // Send user notification\n      await notifyUser(userId, {\n        sessionId: session_id,\n        sleepTime: stat.sleep_time,\n        sleepEfficiency: stat.sleep_efficiency,\n        sleepIndex: stat.sleep_index\n      });\n\n      // Update statistics\n      await updateUserStatistics(userId);\n\n      // Sync to integrations\n      await syncToHealthPlatform(userId, req.body);\n\n      console.log(`Processed SESSION_COMPLETE for ${session_id}`);\n\n      res.status(200).json({ status: 'processed' });\n    } catch (error) {\n      console.error('Webhook processing error:', error);\n      res.status(500).json({ error: 'Processing failed' });\n    }\n  } else {\n    res.status(200).json({ status: 'received' });\n  }\n});\n```\n\n---\n\n## Webhook Versioning\n\nWebhooks support three format versions for backward compatibility:\n\n### V1 (Legacy)\nOriginal webhook format. Use V3 for new implementations.\n\n### V2 (Legacy)\nUpdated format with additional fields. Use V3 for new implementations.\n\n### V3 (Current)\nLatest format with comprehensive data structures. Recommended for all new integrations.\n\n**Version Selection:**\nConfigure webhook version through SDK initialization or Dashboard settings.\n\n---\n\n## Implementation Guide\n\n### 1. Set Up Webhook Endpoint\n\nCreate a public HTTPS endpoint to receive webhook events:\n\n**Python (Flask):**\n```python\nfrom flask import Flask, request, jsonify\nimport hmac\nimport hashlib\n\napp = Flask(__name__)\n\n@app.route('/asleep-webhook', methods=['POST'])\ndef asleep_webhook():\n    # Verify authentication\n    if not verify_webhook(request):\n        return jsonify({\"error\": \"Unauthorized\"}), 401\n\n    # Parse event\n    event = request.json\n    event_type = event.get('event')\n\n    # Route to appropriate handler\n    if event_type == 'INFERENCE_COMPLETE':\n        handle_inference_complete(event)\n    elif event_type == 'SESSION_COMPLETE':\n        handle_session_complete(event)\n\n    return jsonify({\"status\": \"success\"}), 200\n\ndef verify_webhook(request):\n    api_key = request.headers.get('x-api-key')\n    return api_key == EXPECTED_API_KEY\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=443, ssl_context='adhoc')\n```\n\n**Node.js (Express):**\n```javascript\nconst express = require('express');\nconst https = require('https');\nconst fs = require('fs');\n\nconst app = express();\napp.use(express.json());\n\napp.post('/asleep-webhook', async (req, res) => {\n  // Verify authentication\n  if (!verifyWebhook(req)) {\n    return res.status(401).json({ error: 'Unauthorized' });\n  }\n\n  const { event } = req.body;\n\n  try {\n    switch (event) {\n      case 'INFERENCE_COMPLETE':\n        await handleInferenceComplete(req.body);\n        break;\n      case 'SESSION_COMPLETE':\n        await handleSessionComplete(req.body);\n        break;\n      default:\n        console.warn(`Unknown event type: ${event}`);\n    }\n\n    res.status(200).json({ status: 'success' });\n  } catch (error) {\n    console.error('Webhook error:', error);\n    res.status(500).json({ error: 'Processing failed' });\n  }\n});\n\nfunction verifyWebhook(req) {\n  const apiKey = req.headers['x-api-key'];\n  return apiKey === process.env.ASLEEP_API_KEY;\n}\n\n// HTTPS server\nconst options = {\n  key: fs.readFileSync('private-key.pem'),\n  cert: fs.readFileSync('certificate.pem')\n};\n\nhttps.createServer(options, app).listen(443);\n```\n\n### 2. Configure Webhook URL\n\nConfigure your webhook URL through:\n- SDK initialization (for mobile apps)\n- Asleep Dashboard (for backend integrations)\n\n**SDK Example (Android):**\n```kotlin\nAsleepConfig.init(\n    apiKey = \"YOUR_API_KEY\",\n    userId = \"user123\",\n    callbackUrl = \"https://your-domain.com/asleep-webhook\"\n)\n```\n\n### 3. Handle Webhook Events\n\nImplement handlers for each event type:\n\n**Python Example:**\n```python\ndef handle_inference_complete(event):\n    \"\"\"Process incremental sleep data\"\"\"\n    session_id = event['session_id']\n    sleep_stages = event['sleep_stages']\n\n    # Update real-time dashboard\n    redis_client.set(f\"session:{session_id}:latest\", json.dumps(sleep_stages))\n\n    # Notify connected clients via WebSocket\n    websocket_broadcast(session_id, sleep_stages)\n\n    # Store for analysis\n    db.incremental_data.insert_one(event)\n\ndef handle_session_complete(event):\n    \"\"\"Process complete sleep report\"\"\"\n    user_id = event['user_id']\n    session_id = event['session_id']\n    stat = event['stat']\n\n    # Store complete report\n    db.sleep_reports.insert_one({\n        'user_id': user_id,\n        'session_id': session_id,\n        'date': event['session']['start_time'],\n        'statistics': stat,\n        'created_at': datetime.now()\n    })\n\n    # Update user's latest statistics\n    update_user_stats(user_id)\n\n    # Send push notification\n    send_notification(user_id, {\n        'title': 'Sleep Report Ready',\n        'body': f\"Sleep time: {stat['sleep_time']}, Efficiency: {stat['sleep_efficiency']:.1f}%\"\n    })\n\n    # Trigger downstream processes\n    calculate_weekly_trends(user_id)\n    check_sleep_goals(user_id, stat)\n```\n\n### 4. Error Handling\n\nImplement robust error handling:\n\n**Retry Logic:**\n```python\nfrom tenacity import retry, stop_after_attempt, wait_exponential\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))\ndef process_webhook(event):\n    \"\"\"Process webhook with automatic retry\"\"\"\n    # Your processing logic here\n    pass\n\n@app.route('/webhook', methods=['POST'])\ndef webhook_endpoint():\n    try:\n        event = request.json\n        process_webhook(event)\n        return jsonify({\"status\": \"success\"}), 200\n    except Exception as e:\n        logger.error(f\"Webhook processing failed: {e}\")\n        return jsonify({\"status\": \"error\", \"message\": str(e)}), 500\n```\n\n**Idempotency:**\n```python\ndef handle_session_complete(event):\n    session_id = event['session_id']\n\n    # Check if already processed\n    if db.processed_webhooks.find_one({'session_id': session_id}):\n        logger.info(f\"Session {session_id} already processed\")\n        return\n\n    # Process event\n    save_sleep_report(event)\n\n    # Mark as processed\n    db.processed_webhooks.insert_one({\n        'session_id': session_id,\n        'processed_at': datetime.now()\n    })\n```\n\n### 5. Testing\n\nTest webhook handling locally:\n\n**ngrok for Local Testing:**\n```bash\n# Start your local server\npython app.py\n\n# In another terminal, expose with ngrok\nngrok http 5000\n\n# Use the ngrok URL as your webhook URL\n# Example: https://abc123.ngrok.io/webhook\n```\n\n**Mock Webhook Requests:**\n```bash\n# Test INFERENCE_COMPLETE\ncurl -X POST http://localhost:5000/webhook \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-api-key: YOUR_API_KEY\" \\\n  -H \"x-user-id: test_user\" \\\n  -d '{\n    \"event\": \"INFERENCE_COMPLETE\",\n    \"version\": \"V3\",\n    \"session_id\": \"test123\",\n    \"sleep_stages\": [1, 1, 2]\n  }'\n\n# Test SESSION_COMPLETE\ncurl -X POST http://localhost:5000/webhook \\\n  -H \"Content-Type: application/json\" \\\n  -H \"x-api-key: YOUR_API_KEY\" \\\n  -H \"x-user-id: test_user\" \\\n  -d '{\n    \"event\": \"SESSION_COMPLETE\",\n    \"version\": \"V3\",\n    \"session_id\": \"test123\",\n    \"stat\": {\n      \"sleep_time\": \"07:30:00\",\n      \"sleep_efficiency\": 88.5\n    }\n  }'\n```\n\n---\n\n## Best Practices\n\n### Security\n- Always verify `x-api-key` header\n- Use HTTPS for webhook endpoints\n- Implement request signing if handling sensitive data\n- Rate limit webhook endpoint\n- Log all webhook attempts\n\n### Reliability\n- Respond quickly (< 5 seconds ideal)\n- Process asynchronously if needed\n- Implement idempotency checks\n- Handle duplicate events gracefully\n- Return 2xx status even if processing fails (retry logic)\n\n### Performance\n- Use message queues for heavy processing\n- Implement caching where appropriate\n- Batch database operations\n- Monitor webhook response times\n- Scale horizontally if needed\n\n### Monitoring\n- Log all webhook events\n- Track processing success/failure rates\n- Monitor response times\n- Set up alerts for failures\n- Dashboard for webhook metrics\n\n### Error Handling\n- Catch and log all exceptions\n- Return appropriate HTTP status codes\n- Implement exponential backoff\n- Dead letter queue for failed events\n- Manual review process for failures\n\n---\n\n## Common Use Cases\n\n### Real-Time Dashboard Updates\n\n```python\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    event = request.json\n\n    if event['event'] == 'INFERENCE_COMPLETE':\n        # Broadcast to connected WebSocket clients\n        socketio.emit('sleep_update', {\n            'session_id': event['session_id'],\n            'sleep_stages': event['sleep_stages'],\n            'timestamp': event['timestamp']\n        }, room=event['user_id'])\n\n    return jsonify({\"status\": \"success\"}), 200\n```\n\n### User Notifications\n\n```python\ndef handle_session_complete(event):\n    user_id = event['user_id']\n    stat = event['stat']\n\n    # Generate insights\n    insights = generate_sleep_insights(stat)\n\n    # Send push notification\n    send_push_notification(user_id, {\n        'title': 'Your Sleep Report is Ready!',\n        'body': f\"You slept for {stat['sleep_time']} with {stat['sleep_efficiency']:.0f}% efficiency\",\n        'data': {\n            'session_id': event['session_id'],\n            'insights': insights\n        }\n    })\n```\n\n### Data Analytics Pipeline\n\n```python\ndef handle_session_complete(event):\n    # Store in data warehouse\n    bigquery_client.insert_rows_json('sleep_data.sessions', [{\n        'user_id': event['user_id'],\n        'session_id': event['session_id'],\n        'date': event['session']['start_time'],\n        'statistics': json.dumps(event['stat']),\n        'ingested_at': datetime.now().isoformat()\n    }])\n\n    # Trigger analytics jobs\n    trigger_weekly_report_job(event['user_id'])\n    update_cohort_analysis()\n```\n\n### Integration with Other Systems\n\n```python\ndef handle_session_complete(event):\n    user_id = event['user_id']\n    stat = event['stat']\n\n    # Sync to Apple Health\n    sync_to_apple_health(user_id, {\n        'sleep_analysis': stat,\n        'date': event['session']['start_time']\n    })\n\n    # Update CRM\n    update_crm_profile(user_id, {\n        'last_sleep_date': event['session']['start_time'],\n        'avg_sleep_efficiency': calculate_avg_efficiency(user_id)\n    })\n```\n\n---\n\n## Troubleshooting\n\n### Webhook Not Received\n\n**Check:**\n- Endpoint is publicly accessible\n- HTTPS is properly configured\n- Firewall allows incoming requests\n- Webhook URL is correctly configured\n- Server is running and healthy\n\n### Authentication Failures\n\n**Check:**\n- `x-api-key` validation logic\n- API key matches dashboard\n- Headers are correctly parsed\n- Case sensitivity of header names\n\n### Duplicate Events\n\n**Solution:**\n```python\ndef handle_webhook(event):\n    event_id = f\"{event['session_id']}:{event['event']}:{event['timestamp']}\"\n\n    # Check if already processed\n    if redis_client.exists(f\"processed:{event_id}\"):\n        return\n\n    # Process event\n    process_event(event)\n\n    # Mark as processed (expire after 24 hours)\n    redis_client.setex(f\"processed:{event_id}\", 86400, \"1\")\n```\n\n### Processing Delays\n\n**Solution:**\n```python\nfrom celery import Celery\n\ncelery = Celery('tasks', broker='redis://localhost:6379')\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    event = request.json\n\n    # Queue for async processing\n    process_webhook_async.delay(event)\n\n    # Respond immediately\n    return jsonify({\"status\": \"queued\"}), 200\n\n@celery.task\ndef process_webhook_async(event):\n    # Heavy processing here\n    pass\n```\n\n---\n\n## Resources\n\n- **Official Documentation**: https://docs-en.asleep.ai/docs/webhook.md\n- **API Basics**: https://docs-en.asleep.ai/docs/api-basics.md\n- **Dashboard**: https://dashboard.asleep.ai\n",
        "skills/sleeptrack-foundation/SKILL.md": "---\nname: sleeptrack-foundation\ndescription: This skill provides foundational knowledge about Asleep sleep tracking platform, covering core concepts, authentication, data structures, error handling, and platform-agnostic best practices. Use this skill when developers ask about Asleep fundamentals, API concepts, error codes, sleep data structures, or need to understand how the platform works before implementing platform-specific integration. This skill serves as prerequisite knowledge for sleeptrack-ios, sleeptrack-android, and sleeptrack-be skills.\n---\n\n# Sleeptrack Foundation\n\n## Overview\n\nThis skill provides essential foundational knowledge for integrating the Asleep sleep tracking platform. It covers core concepts, authentication patterns, data structures, error handling, and platform-agnostic best practices that apply across all implementation approaches (iOS, Android, and backend API).\n\nUse this skill when developers need to understand:\n- What Asleep is and how sleep tracking works\n- API authentication and key management\n- Sleep session concepts and lifecycle\n- Data structures (Sessions, Reports, Statistics)\n- Error codes and troubleshooting\n- Platform-agnostic integration patterns\n\n## Core Concepts\n\n### What is Asleep?\n\nAsleep is a sleep tracking platform that analyzes sleep using audio-based monitoring through device microphones. The platform provides:\n\n- **Real-time sleep stage analysis**: Wake, Light, Deep, REM detection\n- **Comprehensive sleep metrics**: Efficiency, latency, total sleep time, wake after sleep onset\n- **Snoring detection and analysis**: Snoring stages and patterns\n- **Multi-platform SDKs**: Native iOS and Android SDKs plus REST API\n- **Dashboard analytics**: Web-based analytics and user management\n\n### User Management\n\nEach application user must be registered with Asleep before tracking sleep.\n\n**Key Points**:\n- User ID is managed by the host application (not generated by Asleep)\n- One user can have multiple sleep sessions\n- User data persists across sessions for trend analysis\n- Users can be created, retrieved, updated, and deleted via API\n\n**Example User ID Schemes**:\n```\n- UUID: \"550e8400-e29b-41d4-a716-446655440000\"\n- Email-based: \"user@example.com\"\n- App-specific: \"app_user_12345\"\n```\n\n### Sleep Sessions\n\nA session represents one complete sleep tracking period from start to stop.\n\n**Session Lifecycle States**:\n1. **IDLE**: No tracking in progress\n2. **INITIALIZING**: SDK preparing resources\n3. **INITIALIZED**: Ready to start tracking\n4. **TRACKING_STARTED**: Active tracking in progress\n5. **TRACKING_STOPPING**: Ending session and uploading data\n\n**Session Requirements**:\n- Minimum tracking duration: 5 minutes for valid session\n- Microphone access required throughout tracking\n- Network connectivity needed for data upload\n- One active session per user at a time\n\n**Real-time Data Access**:\n- Available after sequence 10\n- Check every 10 sequences thereafter\n- Provides preliminary sleep stage data during tracking\n\n### Sleep Reports\n\nReports contain comprehensive analysis of completed sleep sessions.\n\n**Report Structure**:\n```\nReport\n Session Metadata\n    session_id\n    user_id\n    start_time\n    end_time\n Sleep Stages Timeline\n    Wake periods\n    Light sleep periods\n    Deep sleep periods\n    REM sleep periods\n Sleep Statistics\n    Total sleep time\n    Time in bed\n    Sleep efficiency (%)\n    Sleep latency (time to fall asleep)\n    Wake after sleep onset (WASO)\n    Sleep stage durations\n    Sleep stage ratios\n Snoring Analysis\n     Snoring detected (yes/no)\n     Snoring stages timeline\n     Snoring statistics\n```\n\n**Key Metrics Explained**:\n\n- **Sleep Efficiency**: (Total sleep time / Time in bed)  100%\n  - Good: > 85%\n  - Fair: 75-85%\n  - Poor: < 75%\n\n- **Sleep Latency**: Time from lying down to falling asleep\n  - Normal: 10-20 minutes\n  - Fast: < 10 minutes (may indicate sleep deprivation)\n  - Slow: > 20 minutes (may indicate insomnia)\n\n- **WASO**: Total wake time after initial sleep onset\n  - Lower is better (indicates fewer disruptions)\n\n### Statistics\n\nAggregated metrics across multiple sessions for trend analysis.\n\n**Available Statistics**:\n- Average sleep duration over time range\n- Average sleep efficiency\n- Sleep stage distribution averages\n- Trends and patterns\n\n**Statistics API**:\n```\nGET /users/{user_id}/statistics/average?from={date}&to={date}\n```\n\n## Authentication\n\n### API Key Management\n\nAll Asleep integrations require an API key for authentication.\n\n**Obtaining an API Key**:\n1. Sign up at https://dashboard.asleep.ai\n2. Navigate to API key generation section\n3. Create API key for the application\n4. Store securely (never commit to version control)\n\n**Using API Keys**:\n\nFor SDK Integration (iOS/Android):\n```kotlin\n// Android\nAsleepConfig.init(\n    apiKey = \"your_api_key_here\",\n    userId = \"user_unique_id\",\n    ...\n)\n```\n\n```swift\n// iOS\nAsleepConfig.init(\n    apiKey: \"your_api_key_here\",\n    userId: \"user_unique_id\",\n    ...\n)\n```\n\nFor REST API Integration:\n```http\nGET /sessions/{session_id}\nX-API-Key: your_api_key_here\n```\n\n**Security Best Practices**:\n- Store API keys in environment variables or secure storage\n- Never hardcode keys in source code\n- Use different keys for development and production\n- Rotate keys periodically\n- Monitor usage in Dashboard to detect unauthorized access\n- Revoke compromised keys immediately\n\n## Error Handling\n\nUnderstanding error codes is critical for robust integration.\n\n### Error Categories\n\n**Critical Errors** (must stop tracking):\nThese errors indicate conditions that prevent continued tracking and require user intervention or code fixes.\n\n**Warning Errors** (can continue tracking):\nThese are transient issues that the SDK handles automatically while tracking continues.\n\n### Error Code Reference\n\n#### Critical Errors\n\n**ERR_MIC_PERMISSION**\n- **Cause**: App lacks microphone access permission\n- **Action**: Request microphone permission from user\n- **Platform Notes**:\n  - Android: Check RECORD_AUDIO permission\n  - iOS: Check NSMicrophoneUsageDescription and authorization status\n\n**ERR_AUDIO**\n- **Cause**: Microphone unavailable or in use by another app\n- **Action**:\n  - Close conflicting apps using microphone\n  - Check microphone hardware functionality\n  - Verify no audio conflicts in device settings\n\n**ERR_INVALID_URL**\n- **Cause**: Malformed API endpoint URL in configuration\n- **Action**: Verify AsleepConfig URL format\n- **Example Fix**: Ensure base URL is valid HTTPS endpoint\n\n**ERR_COMMON_EXPIRED**\n- **Cause**: API rate limit exceeded or subscription plan expired\n- **Action**:\n  - Check Dashboard for plan status\n  - Review API usage patterns\n  - Upgrade plan if needed\n  - Implement rate limiting in application\n\n**ERR_UPLOAD_FORBIDDEN**\n- **Cause**: Multiple simultaneous tracking attempts with same user_id\n- **Action**:\n  - Ensure only one device tracks per user at a time\n  - Check for orphaned sessions\n  - Implement proper session cleanup\n\n**ERR_UPLOAD_NOT_FOUND** / **ERR_CLOSE_NOT_FOUND**\n- **Cause**: Attempting to interact with non-existent or already-ended session\n- **Action**:\n  - Verify session exists before operations\n  - Handle session expiration properly\n  - Implement session state management\n\n#### Warning Errors\n\n**ERR_AUDIO_SILENCED**\n- **Cause**: Audio temporarily unavailable but tracking continues\n- **Impact**: Minimal, SDK handles gracefully\n- **Action**: Log for monitoring, tracking continues\n\n**ERR_AUDIO_UNSILENCED**\n- **Cause**: Audio restored after silence period\n- **Impact**: Tracking resumes normally\n- **Action**: Log for monitoring\n\n**ERR_UPLOAD_FAILED**\n- **Cause**: Network connectivity issue during data upload\n- **Impact**: SDK will retry automatically\n- **Action**:\n  - Verify network connectivity\n  - Check for firewall/proxy issues\n  - Monitor retry success\n\n### Error Handling Patterns\n\n**Distinguish Error Severity**:\n```kotlin\n// Android example\nwhen (errorCode) {\n    in criticalErrors -> {\n        // Stop tracking, notify user\n        stopTracking()\n        showErrorDialog(errorCode)\n    }\n    in warningErrors -> {\n        // Log and continue\n        logWarning(errorCode)\n    }\n}\n```\n\n**Provide User-Friendly Messages**:\n```kotlin\nfun getUserFriendlyMessage(errorCode: AsleepErrorCode): String {\n    return when (errorCode) {\n        ERR_MIC_PERMISSION -> \"Please allow microphone access to track sleep\"\n        ERR_AUDIO -> \"Another app is using the microphone. Please close it and try again\"\n        ERR_COMMON_EXPIRED -> \"Your subscription has expired. Please renew to continue tracking\"\n        // ... more mappings\n    }\n}\n```\n\n**Implement Retry Logic**:\n```kotlin\n// For network-related errors\nsuspend fun uploadWithRetry(maxRetries: Int = 3) {\n    repeat(maxRetries) { attempt ->\n        try {\n            upload()\n            return\n        } catch (e: NetworkException) {\n            if (attempt == maxRetries - 1) throw e\n            delay(2.0.pow(attempt) * 1000) // Exponential backoff\n        }\n    }\n}\n```\n\n## Data Plan Considerations\n\nAsleep operates on different data plans that affect API usage.\n\n**Plan Limits**:\n- Request rate limits\n- Total sessions per month\n- Data retention periods\n- Feature availability\n\n**Monitoring Usage**:\n- Check Dashboard regularly\n- Implement usage tracking in application\n- Set up alerts for approaching limits\n- Plan capacity for user growth\n\n## Integration Workflows\n\n### Typical Integration Flow\n\n1. **Setup Phase**:\n   - Obtain API key from Dashboard\n   - Install SDK (iOS/Android) or configure REST API client\n   - Configure authentication\n\n2. **User Registration**:\n   - Create user in Asleep system\n   - Store user_id mapping in application\n\n3. **Sleep Tracking Session**:\n   - Request necessary permissions\n   - Initialize SDK with user credentials\n   - Start tracking session\n   - Monitor session state\n   - Handle real-time data (optional)\n   - Stop tracking session\n\n4. **Report Generation**:\n   - Wait for report processing (automatic)\n   - Fetch completed report\n   - Display sleep analysis to user\n\n5. **Statistics & Trends**:\n   - Query historical sessions\n   - Calculate aggregated statistics\n   - Display trends over time\n\n### Common Integration Scenarios\n\n**Scenario 1: First-Time User Setup**\n```\nUser downloads app\n   Request microphone permission\n   Create Asleep user (POST /users)\n   Initialize SDK with API key + user_id\n   Guide user through first tracking session\n```\n\n**Scenario 2: Returning User**\n```\nUser opens app\n   Load user_id from local storage\n   Initialize SDK with credentials\n   Check for existing running session (reconnect if found)\n   Display previous sleep reports\n```\n\n**Scenario 3: Background Tracking**\n```\nUser starts tracking before sleep\n   Start foreground service (Android) / background mode (iOS)\n   Maintain microphone access\n   Handle app lifecycle events\n   Continue tracking through sleep\n   Stop tracking in morning\n   Process and display report\n```\n\n## Platform Selection Guide\n\nChoose the appropriate integration approach based on application type:\n\n**Use iOS SDK (sleeptrack-ios)**:\n- Native iOS application\n- Need deep iOS integration (Siri, HealthKit, etc.)\n- Require iOS-specific UI patterns\n- Swift/SwiftUI development\n\n**Use Android SDK (sleeptrack-android)**:\n- Native Android application\n- Need Android-specific features (foreground service, etc.)\n- Require Android UI patterns\n- Kotlin/Jetpack Compose development\n\n**Use REST API (sleeptrack-be)**:\n- Backend/server-side integration\n- Multi-platform web application\n- Data aggregation and analytics\n- Webhook-based event processing\n- Cross-platform mobile framework (React Native, Flutter) with custom bridge\n\n## Resources\n\n### Official Documentation\n\n- **Main Documentation**: https://docs-en.asleep.ai\n- **LLM-Optimized Reference**: https://docs-en.asleep.ai/llms.txt\n- **Dashboard**: https://dashboard.asleep.ai\n\n### Key Documentation Pages\n\n- **QuickStart Guide**: https://docs-en.asleep.ai/docs/quickstart.md\n- **Sleep Data Overview**: https://docs-en.asleep.ai/docs/sleep-data.md\n- **System Overview**: https://docs-en.asleep.ai/docs/system-overview.md\n- **API Basics**: https://docs-en.asleep.ai/docs/api-basics.md\n- **Webhook Guide**: https://docs-en.asleep.ai/docs/webhook.md\n- **Sleep Environment Guidelines**: https://docs-en.asleep.ai/docs/sleep-environment-guideline.md\n\n### Platform-Specific Documentation\n\n**Android**:\n- Get Started: https://docs-en.asleep.ai/docs/android-get-started.md\n- Error Codes: https://docs-en.asleep.ai/docs/android-error-codes.md\n- AsleepConfig: https://docs-en.asleep.ai/docs/android-asleep-config.md\n- SleepTrackingManager: https://docs-en.asleep.ai/docs/android-sleep-tracking-manager.md\n\n**iOS**:\n- Get Started: https://docs-en.asleep.ai/docs/ios-get-started.md\n- Error Codes: https://docs-en.asleep.ai/docs/ios-error-codes.md\n- AsleepConfig: https://docs-en.asleep.ai/docs/ios-asleep-config.md\n- SleepTrackingManager: https://docs-en.asleep.ai/docs/ios-sleep-tracking-manager.md\n\n### Reference Files\n\nThis skill includes detailed API reference documentation:\n\n- `references/asleep_api_reference.md`: Comprehensive API endpoint reference, data structures, and integration patterns\n\nTo load this reference for detailed API information:\n```\nRead references/asleep_api_reference.md\n```\n\n## Best Practices Summary\n\n### Security\n- Never expose API keys in client code\n- Implement secure storage for credentials\n- Use HTTPS for all API communications\n- Validate user permissions before operations\n\n### Performance\n- Cache reports when appropriate\n- Batch API requests to respect rate limits\n- Implement efficient session state management\n- Monitor real-time data access patterns\n\n### User Experience\n- Provide clear permission rationales\n- Show friendly error messages\n- Display progress during tracking\n- Handle app lifecycle gracefully\n\n### Reliability\n- Implement comprehensive error handling\n- Add retry logic for transient failures\n- Log errors for debugging\n- Test edge cases (interruptions, low battery, etc.)\n\n### Data Management\n- Clean up old sessions appropriately\n- Respect user privacy and data retention\n- Implement proper user deletion flows\n- Backup critical session data\n\n## Next Steps\n\nAfter understanding these foundational concepts, proceed to platform-specific skills:\n\n- **iOS Development**: Use `sleeptrack-ios` skill\n- **Android Development**: Use `sleeptrack-android` skill\n- **Backend API Integration**: Use `sleeptrack-be` skill\n\nEach platform-specific skill builds on this foundation with implementation details, code examples, and platform-specific patterns.\n",
        "skills/sleeptrack-foundation/references/asleep_api_reference.md": "# Asleep API Reference\n\n## Official Documentation\n\n- **Main Documentation**: https://docs-en.asleep.ai\n- **LLM-Optimized Docs**: https://docs-en.asleep.ai/llms.txt\n- **Dashboard**: https://dashboard.asleep.ai\n\n## API Authentication\n\nAll Asleep API requests require authentication using an API key.\n\n### Getting an API Key\n\n1. Sign up for the Asleep Dashboard at https://dashboard.asleep.ai\n2. Navigate to the API key generation section\n3. Generate your API key for your application\n4. Store the API key securely (never commit to version control)\n\n### Authentication Method\n\nInclude the API key in request headers:\n```\nX-API-Key: your_api_key_here\n```\n\n## Core Concepts\n\n### User Management\n\nEach application user must be registered with Asleep before tracking sleep data.\n\n- **User ID**: Unique identifier for each user (managed by your application)\n- User data is associated with sessions and reports\n- Users can have multiple sleep tracking sessions\n\n### Sleep Sessions\n\nA sleep session represents one tracking period from start to stop.\n\n**Session States**:\n- IDLE: Not tracking\n- INITIALIZING: Preparing to track\n- INITIALIZED: Ready to track\n- TRACKING_STARTED: Active tracking in progress\n- TRACKING_STOPPING: Ending tracking session\n\n**Key Session Characteristics**:\n- Minimum tracking time: 5 minutes for valid session\n- Real-time data available after sequence 10, then every 10 sequences\n- Each session generates a comprehensive sleep report\n\n### Sleep Reports\n\nReports contain detailed analysis of a completed sleep session.\n\n**Core Metrics**:\n- Sleep stages: Wake, Light, Deep, REM\n- Sleep efficiency: Percentage of time actually sleeping\n- Sleep latency: Time to fall asleep\n- Total sleep time\n- Time in bed\n- Wake after sleep onset (WASO)\n- Sleep stage ratios and durations\n- Snoring detection and analysis\n\n### Statistics\n\nAggregated sleep metrics across multiple sessions.\n\n**Available Statistics**:\n- Average sleep duration\n- Average sleep efficiency\n- Sleep stage distribution\n- Trends over time periods\n\n## Error Codes\n\n### Critical Errors (Stop Tracking)\n\n- **ERR_MIC_PERMISSION**: Microphone access permission denied\n- **ERR_AUDIO**: Microphone in use by another app or hardware issue\n- **ERR_INVALID_URL**: Malformed API endpoint URL\n- **ERR_COMMON_EXPIRED**: API rate limit exceeded or plan expired\n- **ERR_UPLOAD_FORBIDDEN**: Multiple simultaneous tracking attempts with same user ID\n- **ERR_UPLOAD_NOT_FOUND**: Session does not exist or already ended\n- **ERR_CLOSE_NOT_FOUND**: Attempted to close non-existent session\n\n### Warning Errors (Continue Tracking)\n\n- **ERR_AUDIO_SILENCED**: Audio temporarily unavailable but tracking continues\n- **ERR_AUDIO_UNSILENCED**: Audio restored after silence\n- **ERR_UPLOAD_FAILED**: Network issue during upload, will retry\n\n## REST API Endpoints\n\n### User Management\n\n**Create User**\n```\nPOST /users\nBody: { \"user_id\": \"string\" }\n```\n\n**Get User**\n```\nGET /users/{user_id}\n```\n\n**Update User**\n```\nPUT /users/{user_id}\nBody: { /* user properties */ }\n```\n\n**Delete User**\n```\nDELETE /users/{user_id}\n```\n\n### Session Management\n\n**Get Session**\n```\nGET /sessions/{session_id}\n```\n\n**List Sessions**\n```\nGET /sessions?user_id={user_id}&from={date}&to={date}\n```\n\n**Delete Session**\n```\nDELETE /sessions/{session_id}\n```\n\n### Statistics\n\n**Get Average Stats**\n```\nGET /users/{user_id}/statistics/average?from={date}&to={date}\n```\n\n## Webhooks\n\nAsleep supports webhooks for real-time event notifications.\n\n**Supported Events**:\n- Session started\n- Session completed\n- Report generated\n- User created/updated/deleted\n\n**Webhook Configuration**:\nConfigure webhook URLs in the Asleep Dashboard.\n\n## Platform SDKs\n\n### Android SDK\n\n- **Language**: Kotlin\n- **Minimum SDK**: Check latest documentation\n- **Key Classes**: AsleepConfig, SleepTrackingManager\n- **Architecture**: MVVM patterns, Hilt dependency injection\n- **Permissions Required**:\n  - RECORD_AUDIO (microphone)\n  - POST_NOTIFICATIONS\n  - REQUEST_IGNORE_BATTERY_OPTIMIZATIONS\n  - FOREGROUND_SERVICE\n\n### iOS SDK\n\n- **Language**: Swift\n- **Minimum iOS Version**: Check latest documentation\n- **Key Classes**: AsleepConfig, SleepTrackingManager\n- **Architecture**: Delegate patterns, Combine framework\n- **Permissions Required**:\n  - Microphone access (NSMicrophoneUsageDescription)\n  - Notifications\n  - Background modes\n\n## Data Structures\n\n### Session\n\nRepresents a sleep tracking session with metadata and tracking state information.\n\n### Report\n\nComprehensive sleep analysis including:\n- Sleep stages timeline\n- Statistical metrics\n- Snoring analysis\n- Quality indicators\n\n### Statistics\n\nAggregated metrics across multiple sessions for trend analysis.\n\n## Best Practices\n\n### API Key Security\n\n- Never hardcode API keys in source code\n- Use environment variables or secure storage\n- Rotate keys periodically\n- Monitor usage in Dashboard\n\n### User ID Management\n\n- Use consistent user IDs across sessions\n- Consider user privacy in ID scheme\n- Implement proper user consent flows\n\n### Error Handling\n\n- Distinguish between critical errors (stop tracking) and warnings (continue)\n- Provide user-friendly error messages\n- Implement retry logic for network failures\n- Log errors for debugging\n\n### Session Management\n\n- Validate minimum tracking time (5 minutes)\n- Handle app lifecycle properly (don't lose sessions)\n- Implement reconnection logic for interrupted sessions\n- Clean up resources when stopping tracking\n\n### Performance\n\n- Check real-time data appropriately (after sequence 10, every 10 sequences)\n- Cache reports when appropriate\n- Batch API requests when possible\n- Monitor API rate limits\n\n## Common Use Cases\n\n### Health & Fitness Apps\n\nIntegrate sleep tracking alongside activity tracking for comprehensive health insights.\n\n### Healthcare & Wellness\n\nClinical-grade sleep monitoring for patient care and wellness programs.\n\n### Sleep Tech\n\nDedicated sleep improvement applications with detailed analysis and recommendations.\n\n### Smart Home & IoT\n\nIntegrate sleep data with smart home automation for optimized sleep environment.\n\n## Support & Resources\n\n- **Documentation**: https://docs-en.asleep.ai\n- **Dashboard**: https://dashboard.asleep.ai\n- **Email**: Contact through dashboard for technical support\n",
        "skills/sleeptrack-ios/SKILL.md": "---\nname: sleeptrack-ios\ndescription: This skill helps iOS developers integrate the Asleep SDK for sleep tracking functionality. Use this skill when building native iOS apps with Swift/SwiftUI that need sleep tracking capabilities, implementing delegate patterns, configuring iOS permissions (microphone, notifications, background modes), managing tracking lifecycle, integrating Siri Shortcuts, or working with Combine framework for reactive state management.\n---\n\n# Sleeptrack iOS\n\n## Overview\n\nThis skill provides comprehensive guidance for integrating the Asleep SDK into native iOS applications using Swift and SwiftUI. It covers SDK setup, iOS-specific permissions, delegate-based architecture, tracking lifecycle management, Combine framework integration, and Siri Shortcuts support.\n\nUse this skill when:\n- Building native iOS sleep tracking applications\n- Implementing SwiftUI-based tracking interfaces\n- Managing iOS permissions and background modes\n- Working with delegate patterns for SDK callbacks\n- Integrating Siri Shortcuts for voice-activated tracking\n- Using Combine framework for reactive state management\n\n**Prerequisites**: Developers should first review the `sleeptrack-foundation` skill to understand core Asleep concepts, authentication, data structures, and error handling before implementing iOS-specific integration.\n\n## Quick Start\n\n### 1. Installation\n\nAdd AsleepSDK to your Xcode project using Swift Package Manager:\n\n```swift\n// In Xcode: File  Add Packages\n// Enter package URL: https://github.com/asleep-ai/asleep-sdk-ios\n```\n\nOr add to `Package.swift`:\n\n```swift\ndependencies: [\n    .package(url: \"https://github.com/asleep-ai/asleep-sdk-ios\", from: \"2.0.0\")\n]\n```\n\n### 2. Configure iOS Permissions\n\nAdd required permissions to `Info.plist`:\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <!-- Microphone access for audio-based sleep tracking -->\n    <key>NSMicrophoneUsageDescription</key>\n    <string>This app uses your microphone to track sleep stages and detect snoring during sleep.</string>\n\n    <!-- Background audio mode for continuous tracking -->\n    <key>UIBackgroundModes</key>\n    <array>\n        <string>audio</string>\n    </array>\n\n    <!-- Optional: For notification reminders -->\n    <key>NSUserNotificationsUsageDescription</key>\n    <string>Get reminders to start and stop sleep tracking.</string>\n</dict>\n</plist>\n```\n\n### 3. Basic Setup\n\n```swift\nimport SwiftUI\nimport AsleepSDK\n\n@main\nstruct SleepTrackerApp: App {\n    var body: some Scene {\n        WindowGroup {\n            MainView()\n        }\n    }\n}\n```\n\n## SDK Architecture\n\nThe Asleep iOS SDK follows a delegate-based architecture with three main components:\n\n### 1. AsleepConfig - Configuration and User Management\n\n**Purpose**: Initialize SDK with API credentials and manage user lifecycle.\n\n**Key Delegate**: `AsleepConfigDelegate`\n\n```swift\nprotocol AsleepConfigDelegate {\n    func userDidJoin(userId: String, config: Asleep.Config)\n    func didFailUserJoin(error: Asleep.AsleepError)\n    func userDidDelete(userId: String)\n}\n```\n\n### 2. SleepTrackingManager - Tracking Lifecycle\n\n**Purpose**: Control sleep tracking start, stop, and monitor session state.\n\n**Key Delegate**: `AsleepSleepTrackingManagerDelegate`\n\n```swift\nprotocol AsleepSleepTrackingManagerDelegate {\n    func didCreate()                          // Session created\n    func didUpload(sequence: Int)             // Data uploaded\n    func didClose(sessionId: String)          // Tracking stopped\n    func didFail(error: Asleep.AsleepError)  // Error occurred\n    func didInterrupt()                       // Interrupted (e.g., phone call)\n    func didResume()                          // Resumed after interruption\n    func micPermissionWasDenied()             // Mic permission denied\n    func analysing(session: Asleep.Model.Session) // Real-time data (optional)\n}\n```\n\n### 3. Reports - Retrieving Sleep Data\n\n**Purpose**: Fetch sleep reports and session lists after tracking completes.\n\n```swift\n// Reports API is async/await based, not delegate-driven\nlet reports = Asleep.createReports(config: config)\n\n// Get single report\nlet report = try await reports.report(sessionId: \"session_id\")\n\n// Get report list\nlet reportList = try await reports.reports(\n    fromDate: \"2024-01-01\",\n    toDate: \"2024-01-31\"\n)\n```\n\n## Implementation Overview\n\n### Minimal ViewModel Example\n\n```swift\nimport Foundation\nimport Combine\nimport AsleepSDK\n\nfinal class SleepTrackingViewModel: ObservableObject {\n    private(set) var trackingManager: Asleep.SleepTrackingManager?\n    private(set) var reports: Asleep.Reports?\n\n    @Published var isTracking = false\n    @Published var error: String?\n    @Published private(set) var config: Asleep.Config?\n\n    func initAsleepConfig(apiKey: String, userId: String) {\n        Asleep.initAsleepConfig(\n            apiKey: apiKey,\n            userId: userId,\n            delegate: self\n        )\n    }\n\n    func startTracking() {\n        trackingManager?.startTracking()\n    }\n\n    func stopTracking() {\n        trackingManager?.stopTracking()\n    }\n}\n\n// Implement delegates\nextension SleepTrackingViewModel: AsleepConfigDelegate {\n    func userDidJoin(userId: String, config: Asleep.Config) {\n        Task { @MainActor in\n            self.config = config\n            self.trackingManager = Asleep.createSleepTrackingManager(\n                config: config,\n                delegate: self\n            )\n        }\n    }\n\n    func didFailUserJoin(error: Asleep.AsleepError) {\n        Task { @MainActor in\n            self.error = error.localizedDescription\n        }\n    }\n\n    func userDidDelete(userId: String) {\n        // Handle user deletion\n    }\n}\n\nextension SleepTrackingViewModel: AsleepSleepTrackingManagerDelegate {\n    func didCreate() {\n        Task { @MainActor in\n            self.isTracking = true\n        }\n    }\n\n    func didClose(sessionId: String) {\n        Task { @MainActor in\n            self.isTracking = false\n            // Initialize reports to fetch session data\n            self.reports = Asleep.createReports(config: config!)\n        }\n    }\n\n    func didFail(error: Asleep.AsleepError) {\n        Task { @MainActor in\n            self.error = error.localizedDescription\n        }\n    }\n\n    // Implement other delegate methods as needed\n}\n```\n\nFor complete ViewModel implementation with all delegate methods, see [references/complete_viewmodel_implementation.md](references/complete_viewmodel_implementation.md)\n\n## iOS-Specific Features\n\n### 1. Siri Shortcuts\n\nEnable voice-activated tracking with App Intents (iOS 16+). Users can say \"Hey Siri, start sleep\" or \"Hey Siri, stop sleep\".\n\nFor complete Siri Shortcuts implementation, see [references/ios_specific_features.md](references/ios_specific_features.md#siri-shortcuts-integration)\n\n### 2. Background Audio Mode\n\nConfigure background audio to maintain tracking during sleep. Simply add `audio` to `UIBackgroundModes` in Info.plist - iOS handles the rest automatically.\n\nFor details, see [references/ios_specific_features.md](references/ios_specific_features.md#background-audio-mode)\n\n### 3. Microphone Permission\n\nRequest microphone permission before starting tracking:\n\n```swift\nimport AVFoundation\n\nfunc requestMicrophonePermission() async -> Bool {\n    switch AVAudioSession.sharedInstance().recordPermission {\n    case .granted: return true\n    case .denied: return false\n    case .undetermined:\n        return await AVAudioSession.sharedInstance().requestRecordPermission()\n    @unknown default: return false\n    }\n}\n```\n\nFor complete permission handling, see [references/ios_specific_features.md](references/ios_specific_features.md#microphone-permission-handling)\n\n### 4. App Lifecycle Management\n\nHandle app state transitions using SwiftUI's `scenePhase`:\n\n```swift\nstruct SleepTrackingView: View {\n    @Environment(\\.scenePhase) private var scenePhase\n\n    var body: some View {\n        // ... view content ...\n        .onChange(of: scenePhase) { newPhase in\n            switch newPhase {\n            case .active: print(\"App is active\")\n            case .inactive: print(\"App is inactive\")\n            case .background: print(\"App in background - tracking continues\")\n            @unknown default: break\n            }\n        }\n    }\n}\n```\n\nFor advanced lifecycle patterns, see [references/ios_specific_features.md](references/ios_specific_features.md#app-lifecycle-management)\n\n### 5. Persistent Storage\n\nStore configuration using AppStorage:\n\n```swift\nstruct SleepTrackingView: View {\n    @AppStorage(\"sleepapp+apikey\") private var apiKey = \"\"\n    @AppStorage(\"sleepapp+userid\") private var userId = \"\"\n    // Values automatically persist across app launches\n}\n```\n\n## Error Handling\n\n### Common Error Patterns\n\n```swift\nfunc handleError(_ error: Asleep.AsleepError) {\n    switch error {\n    case .micPermission:\n        // Guide user to Settings\n        showMicPermissionAlert()\n\n    case .audioSessionError:\n        // Another app is using microphone\n        showAudioUnavailableAlert()\n\n    case let .httpStatus(code, _, message):\n        switch code {\n        case 403: // Session already active on another device\n        case 404: // Session not found\n        default: break\n        }\n\n    default:\n        showGenericError(error.localizedDescription)\n    }\n}\n```\n\n### Retry with Exponential Backoff\n\n```swift\nfunc startTrackingWithRetry() {\n    trackingManager?.startTracking()\n}\n\nfunc didFail(error: Asleep.AsleepError) {\n    if isTransientError(error) && retryCount < maxRetries {\n        retryCount += 1\n        DispatchQueue.main.asyncAfter(deadline: .now() + pow(2.0, Double(retryCount))) {\n            self.startTrackingWithRetry()\n        }\n    } else {\n        handleError(error)\n    }\n}\n```\n\nFor comprehensive error handling patterns, see [references/advanced_patterns.md](references/advanced_patterns.md#error-recovery-patterns)\n\n## Best Practices\n\n### 1. State Management\n\nUse `@Published` properties for reactive UI updates:\n\n```swift\nfinal class SleepTrackingViewModel: ObservableObject {\n    @Published var isTracking = false\n    @Published var error: String?\n    // UI automatically updates when values change\n}\n```\n\n### 2. Main Thread Safety\n\nAlways update UI on main thread:\n\n```swift\nfunc didCreate() {\n    Task { @MainActor in  // Ensures main thread\n        self.isTracking = true\n    }\n}\n```\n\n### 3. Resource Cleanup\n\n```swift\nfinal class SleepTrackingViewModel: ObservableObject {\n    deinit {\n        trackingManager = nil\n        reports = nil\n    }\n}\n```\n\n### 4. User Experience\n\nProvide clear visual feedback with loading states, progress indicators, and error messages. Disable controls appropriately during tracking.\n\n### 5. Testing Considerations\n\nUse dependency injection for testable code:\n\n```swift\nprotocol SleepTrackingManagerProtocol {\n    func startTracking()\n    func stopTracking()\n}\n\n// Production and mock implementations\n```\n\nFor complete testing patterns, see [references/advanced_patterns.md](references/advanced_patterns.md#testing-patterns)\n\n## Common Integration Patterns\n\n### Pattern 1: Simple Single-View App\n\nBest for basic sleep tracking with minimal features. Single view with tracking controls.\n\n### Pattern 2: Multi-View App with Navigation\n\nBest for apps with reports, settings, and history. Uses TabView for navigation between Track, History, and Settings.\n\n### Pattern 3: Centralized SDK Manager\n\nBest for complex apps sharing SDK instance across views. Single source of truth with `AsleepSDKManager.shared`.\n\nFor complete implementation of all patterns, see [references/advanced_patterns.md](references/advanced_patterns.md)\n\n## Real-time Data Access\n\nAccess preliminary sleep data during tracking (available after sequence 10):\n\n```swift\nfunc analysing(session: Asleep.Model.Session) {\n    Task { @MainActor in\n        if let sleepStages = session.sleepStages {\n            updateRealtimeChart(stages: sleepStages)\n        }\n    }\n}\n\nfunc didUpload(sequence: Int) {\n    // Real-time data available every 10 sequences after sequence 10\n    if sequence >= 10 && sequence % 10 == 0 {\n        // SDK automatically calls analysing() delegate\n    }\n}\n```\n\n## Fetching Reports\n\nRetrieve sleep session data after tracking:\n\n```swift\nfunc fetchReport(sessionId: String) async {\n    do {\n        let report = try await reports?.report(sessionId: sessionId)\n        // Process report data\n    } catch {\n        // Handle error\n    }\n}\n\n// Fetch multiple sessions\nfunc fetchReportList() async {\n    let reportList = try await reports?.reports(\n        fromDate: \"2024-01-01\",\n        toDate: \"2024-01-31\"\n    )\n}\n```\n\n## Troubleshooting\n\n### Tracking Doesn't Start\n\n**Causes**: Missing microphone permission, empty API key/user ID, another app using microphone\n\n**Solution**: Validate configuration and check microphone permission before starting\n\n### Background Tracking Stops\n\n**Causes**: Background audio mode not configured, memory pressure, force-closed app\n\n**Solution**: Ensure `UIBackgroundModes` includes `audio` in Info.plist\n\n### Reports Not Available\n\n**Causes**: Session processing incomplete (takes time), minimum duration not met (5 minutes), network issues\n\n**Solution**: Implement retry logic with exponential backoff when fetching reports\n\nFor detailed troubleshooting, see the complete implementation examples in references/\n\n## Sample Code Reference\n\nThis skill is based on the official Asleep iOS sample app:\n\n- **MainViewModel.swift**: Complete ViewModel with all delegates\n- **MainView.swift**: SwiftUI view with tracking controls\n- **StartSleepIntent.swift / StopSleepIntent.swift**: Siri Shortcuts\n- **ReportView.swift**: Sleep report display\n- **Info.plist**: Required iOS permissions\n\nSample app: [Asleep iOS Sample App](https://github.com/asleep-ai/asleep-sdk-ios-sampleapp-public)\n\n## Resources\n\n### Official Documentation\n\n- **iOS Get Started**: https://docs-en.asleep.ai/docs/ios-get-started.md\n- **iOS Error Codes**: https://docs-en.asleep.ai/docs/ios-error-codes.md\n- **AsleepConfig Reference**: https://docs-en.asleep.ai/docs/ios-asleep-config.md\n- **SleepTrackingManager Reference**: https://docs-en.asleep.ai/docs/ios-sleep-tracking-manager.md\n- **Sample App Guide**: https://docs-en.asleep.ai/docs/sample-app.md\n\n### Apple Documentation\n\n- **SwiftUI**: https://developer.apple.com/documentation/swiftui\n- **Combine**: https://developer.apple.com/documentation/combine\n- **AVAudioSession**: https://developer.apple.com/documentation/avfaudio/avaudiosession\n- **App Intents**: https://developer.apple.com/documentation/appintents\n- **Background Modes**: https://developer.apple.com/documentation/xcode/configuring-background-execution-modes\n\n### Related Skills\n\n- **sleeptrack-foundation**: Core Asleep concepts, authentication, and data structures\n- **sleeptrack-android**: Android-specific implementation guide\n- **sleeptrack-be**: Backend API integration\n\n## Next Steps\n\nAfter integrating the iOS SDK:\n\n1. Test thoroughly across different iOS devices and versions\n2. Implement proper error handling for all edge cases\n3. Add user-friendly error messages and recovery flows\n4. Consider HealthKit integration for data export\n5. Implement notification reminders for tracking\n6. Add data visualization for sleep trends\n7. Consider Apple Watch companion app\n8. Submit to App Store with proper privacy declarations\n",
        "skills/sleeptrack-ios/references/advanced_patterns.md": "# Advanced Integration Patterns\n\nComprehensive patterns for different app architectures and advanced error handling strategies.\n\n## Pattern 1: Simple Single-View App\n\nBest for: Basic sleep tracking app with minimal features.\n\n```swift\n@main\nstruct SimpleSleepApp: App {\n    var body: some Scene {\n        WindowGroup {\n            SleepTrackingView()\n        }\n    }\n}\n```\n\n### Advantages\n\n- Simple architecture\n- Easy to understand and maintain\n- Minimal code overhead\n- Fast development\n\n### Use Cases\n\n- MVP or prototype apps\n- Single-purpose sleep trackers\n- Learning/demo applications\n\n## Pattern 2: Multi-View App with Navigation\n\nBest for: Apps with reports, settings, and history.\n\n```swift\nstruct ContentView: View {\n    var body: some View {\n        TabView {\n            SleepTrackingView()\n                .tabItem {\n                    Label(\"Track\", systemImage: \"moon.zzz\")\n                }\n\n            ReportHistoryView()\n                .tabItem {\n                    Label(\"History\", systemImage: \"chart.bar\")\n                }\n\n            SettingsView()\n                .tabItem {\n                    Label(\"Settings\", systemImage: \"gear\")\n                }\n        }\n    }\n}\n```\n\n### Supporting Views\n\n```swift\nstruct ReportHistoryView: View {\n    @StateObject private var viewModel = ReportHistoryViewModel()\n\n    var body: some View {\n        NavigationView {\n            List(viewModel.sessions) { session in\n                NavigationLink {\n                    ReportDetailView(sessionId: session.id)\n                } label: {\n                    SessionRow(session: session)\n                }\n            }\n            .navigationTitle(\"Sleep History\")\n            .onAppear {\n                viewModel.loadSessions()\n            }\n        }\n    }\n}\n\nstruct SettingsView: View {\n    @AppStorage(\"sleepapp+apikey\") private var apiKey = \"\"\n    @AppStorage(\"sleepapp+userid\") private var userId = \"\"\n    @AppStorage(\"sleepapp+notifications\") private var notificationsEnabled = false\n\n    var body: some View {\n        NavigationView {\n            Form {\n                Section(\"Account\") {\n                    TextField(\"User ID\", text: $userId)\n                    SecureField(\"API Key\", text: $apiKey)\n                }\n\n                Section(\"Preferences\") {\n                    Toggle(\"Enable Notifications\", isOn: $notificationsEnabled)\n                }\n            }\n            .navigationTitle(\"Settings\")\n        }\n    }\n}\n```\n\n### Advantages\n\n- Clear separation of concerns\n- Scalable for additional features\n- Familiar tab-based navigation\n- Easy to add new sections\n\n## Pattern 3: Centralized SDK Manager\n\nBest for: Complex apps sharing SDK instance across views.\n\n```swift\nfinal class AsleepSDKManager: ObservableObject {\n    static let shared = AsleepSDKManager()\n\n    @Published var config: Asleep.Config?\n    @Published var isInitialized = false\n    @Published var error: String?\n\n    private var trackingManager: Asleep.SleepTrackingManager?\n    private var reports: Asleep.Reports?\n\n    private init() {}\n\n    func initialize(apiKey: String, userId: String) {\n        Asleep.initAsleepConfig(\n            apiKey: apiKey,\n            userId: userId,\n            delegate: self\n        )\n    }\n\n    func getTrackingManager() -> Asleep.SleepTrackingManager? {\n        guard let config else { return nil }\n        if trackingManager == nil {\n            trackingManager = Asleep.createSleepTrackingManager(\n                config: config,\n                delegate: self\n            )\n        }\n        return trackingManager\n    }\n\n    func getReports() -> Asleep.Reports? {\n        guard let config else { return nil }\n        if reports == nil {\n            reports = Asleep.createReports(config: config)\n        }\n        return reports\n    }\n\n    func reset() {\n        trackingManager = nil\n        reports = nil\n        config = nil\n        isInitialized = false\n    }\n}\n\n// MARK: - Delegates\nextension AsleepSDKManager: AsleepConfigDelegate {\n    func userDidJoin(userId: String, config: Asleep.Config) {\n        Task { @MainActor in\n            self.config = config\n            self.isInitialized = true\n        }\n    }\n\n    func didFailUserJoin(error: Asleep.AsleepError) {\n        Task { @MainActor in\n            self.error = \"Failed to join: \\(error.localizedDescription)\"\n        }\n    }\n\n    func userDidDelete(userId: String) {\n        Task { @MainActor in\n            reset()\n        }\n    }\n}\n\n// Usage in views\nstruct SleepTrackingView: View {\n    @ObservedObject var sdkManager = AsleepSDKManager.shared\n    @StateObject private var trackingState = TrackingStateViewModel()\n\n    var body: some View {\n        VStack {\n            if sdkManager.isInitialized {\n                TrackingControls(manager: sdkManager.getTrackingManager())\n            } else {\n                ConfigurationView()\n            }\n        }\n    }\n}\n\nstruct ReportHistoryView: View {\n    @ObservedObject var sdkManager = AsleepSDKManager.shared\n\n    var body: some View {\n        NavigationView {\n            if sdkManager.isInitialized {\n                ReportList(reports: sdkManager.getReports())\n            } else {\n                Text(\"Please configure the app first\")\n            }\n        }\n    }\n}\n```\n\n### Advantages\n\n- Single source of truth for SDK state\n- Prevents duplicate SDK instances\n- Centralized error handling\n- Easy to manage lifecycle across app\n\n### Testing Strategy\n\n```swift\nprotocol AsleepSDKManagerProtocol {\n    var config: Asleep.Config? { get }\n    var isInitialized: Bool { get }\n    func initialize(apiKey: String, userId: String)\n    func getTrackingManager() -> Asleep.SleepTrackingManager?\n}\n\n// For testing\nclass MockSDKManager: AsleepSDKManagerProtocol, ObservableObject {\n    @Published var config: Asleep.Config?\n    @Published var isInitialized = false\n\n    func initialize(apiKey: String, userId: String) {\n        isInitialized = true\n    }\n\n    func getTrackingManager() -> Asleep.SleepTrackingManager? {\n        nil\n    }\n}\n```\n\n## Error Recovery Patterns\n\n### Automatic Retry with Exponential Backoff\n\n```swift\nfinal class SleepTrackingViewModel: ObservableObject {\n    private var retryCount = 0\n    private let maxRetries = 3\n\n    func startTrackingWithRetry() {\n        trackingManager?.startTracking()\n    }\n\n    func didFail(error: Asleep.AsleepError) {\n        if isTransientError(error) && retryCount < maxRetries {\n            retryCount += 1\n            let delay = pow(2.0, Double(retryCount))\n\n            DispatchQueue.main.asyncAfter(deadline: .now() + delay) { [weak self] in\n                self?.startTrackingWithRetry()\n            }\n        } else {\n            retryCount = 0\n            handleError(error)\n        }\n    }\n\n    private func isTransientError(_ error: Asleep.AsleepError) -> Bool {\n        switch error {\n        case .networkError, .uploadFailed:\n            return true\n        default:\n            return false\n        }\n    }\n}\n```\n\n### Error Categorization and Handling\n\n```swift\nextension SleepTrackingViewModel {\n    func handleError(_ error: Asleep.AsleepError) {\n        switch error {\n        case .micPermission:\n            showAlert(\n                title: \"Microphone Access Required\",\n                message: \"Please enable microphone access in Settings to track sleep.\",\n                action: openSettings\n            )\n\n        case .audioSessionError:\n            showAlert(\n                title: \"Audio Unavailable\",\n                message: \"Another app is using the microphone. Please close it and try again.\"\n            )\n\n        case let .httpStatus(code, _, message):\n            switch code {\n            case 403:\n                showAlert(\n                    title: \"Session Already Active\",\n                    message: \"Another device is tracking with this user ID.\"\n                )\n            case 404:\n                showAlert(\n                    title: \"Session Not Found\",\n                    message: \"The tracking session could not be found.\"\n                )\n            default:\n                showAlert(\n                    title: \"Error \\(code)\",\n                    message: message ?? \"An unknown error occurred\"\n                )\n            }\n\n        default:\n            showAlert(\n                title: \"Error\",\n                message: error.localizedDescription\n            )\n        }\n    }\n\n    private func openSettings() {\n        if let url = URL(string: UIApplication.openSettingsURLString) {\n            UIApplication.shared.open(url)\n        }\n    }\n}\n```\n\n### Report Fetching with Retry\n\n```swift\nfunc fetchReportWithRetry(sessionId: String, maxAttempts: Int = 5) async {\n    for attempt in 1...maxAttempts {\n        do {\n            let report = try await reports?.report(sessionId: sessionId)\n            await MainActor.run {\n                self.currentReport = report\n            }\n            return\n        } catch {\n            if attempt < maxAttempts {\n                // Wait before retrying (exponential backoff)\n                let delay = UInt64(pow(2.0, Double(attempt))) * 1_000_000_000\n                try? await Task.sleep(nanoseconds: delay)\n            } else {\n                await MainActor.run {\n                    self.error = \"Report not ready. Please try again later.\"\n                }\n            }\n        }\n    }\n}\n```\n\n### Graceful Degradation\n\n```swift\nstruct SleepTrackingView: View {\n    @StateObject private var viewModel = SleepTrackingViewModel()\n    @State private var offlineMode = false\n\n    var body: some View {\n        VStack {\n            if offlineMode {\n                OfflineModeView()\n            } else {\n                OnlineModeView(viewModel: viewModel)\n            }\n        }\n        .onReceive(viewModel.$error) { error in\n            if let error = error, isNetworkError(error) {\n                offlineMode = true\n            }\n        }\n    }\n\n    private func isNetworkError(_ error: String) -> Bool {\n        error.contains(\"network\") || error.contains(\"connection\")\n    }\n}\n\nstruct OfflineModeView: View {\n    var body: some View {\n        VStack(spacing: 20) {\n            Image(systemName: \"wifi.slash\")\n                .font(.system(size: 60))\n                .foregroundColor(.secondary)\n\n            Text(\"Offline Mode\")\n                .font(.headline)\n\n            Text(\"Sleep tracking data will sync when connection is restored\")\n                .font(.caption)\n                .foregroundColor(.secondary)\n                .multilineTextAlignment(.center)\n                .padding(.horizontal)\n        }\n    }\n}\n```\n\n## Testing Patterns\n\n### Dependency Injection for Testing\n\n```swift\nprotocol SleepTrackingManagerProtocol {\n    func startTracking()\n    func stopTracking()\n}\n\nfinal class SleepTrackingViewModel: ObservableObject {\n    private let trackingManager: SleepTrackingManagerProtocol\n\n    init(trackingManager: SleepTrackingManagerProtocol) {\n        self.trackingManager = trackingManager\n    }\n\n    func startTracking() {\n        trackingManager.startTracking()\n    }\n}\n\n// For testing\nclass MockTrackingManager: SleepTrackingManagerProtocol {\n    var startTrackingCalled = false\n    var stopTrackingCalled = false\n\n    func startTracking() {\n        startTrackingCalled = true\n    }\n\n    func stopTracking() {\n        stopTrackingCalled = true\n    }\n}\n\n// Usage in tests\nfunc testStartTracking() {\n    let mockManager = MockTrackingManager()\n    let viewModel = SleepTrackingViewModel(trackingManager: mockManager)\n\n    viewModel.startTracking()\n\n    XCTAssertTrue(mockManager.startTrackingCalled)\n}\n```\n",
        "skills/sleeptrack-ios/references/complete_viewmodel_implementation.md": "# Complete ViewModel Implementation\n\nThis reference provides full implementation examples for iOS sleep tracking using Combine and SwiftUI.\n\n## Full ViewModel with Combine\n\n```swift\nimport Foundation\nimport Combine\nimport AsleepSDK\n\nfinal class SleepTrackingViewModel: ObservableObject {\n    // MARK: - SDK Components\n    private(set) var trackingManager: Asleep.SleepTrackingManager?\n    private(set) var reports: Asleep.Reports?\n\n    // MARK: - Published State\n    @Published var userId: String?\n    @Published var sessionId: String?\n    @Published var sequenceNumber: Int?\n    @Published var error: String?\n    @Published var isTracking = false\n    @Published var currentReport: Asleep.Model.Report?\n    @Published var reportList: [Asleep.Model.SleepSession]?\n    @Published private(set) var config: Asleep.Config?\n\n    // MARK: - Initialization\n    func initAsleepConfig(\n        apiKey: String,\n        userId: String,\n        baseUrl: URL? = nil,\n        callbackUrl: URL? = nil\n    ) {\n        Asleep.initAsleepConfig(\n            apiKey: apiKey,\n            userId: userId.isEmpty ? nil : userId,\n            baseUrl: baseUrl,\n            callbackUrl: callbackUrl,\n            delegate: self\n        )\n\n        // Optional: Enable debug logging\n        Asleep.setDebugLoggerDelegate(self)\n    }\n\n    func initSleepTrackingManager() {\n        guard let config else { return }\n        trackingManager = Asleep.createSleepTrackingManager(\n            config: config,\n            delegate: self\n        )\n    }\n\n    func initReports() {\n        guard let config else { return }\n        reports = Asleep.createReports(config: config)\n    }\n\n    // MARK: - Tracking Control\n    func startTracking() {\n        trackingManager?.startTracking()\n    }\n\n    func stopTracking() {\n        trackingManager?.stopTracking()\n        initReports()\n    }\n}\n\n// MARK: - AsleepConfigDelegate\nextension SleepTrackingViewModel: AsleepConfigDelegate {\n    func userDidJoin(userId: String, config: Asleep.Config) {\n        Task { @MainActor in\n            self.config = config\n            self.userId = userId\n            initSleepTrackingManager()\n        }\n    }\n\n    func didFailUserJoin(error: Asleep.AsleepError) {\n        Task { @MainActor in\n            self.error = \"Failed to join: \\(error.localizedDescription)\"\n        }\n    }\n\n    func userDidDelete(userId: String) {\n        Task { @MainActor in\n            self.userId = nil\n            self.config = nil\n        }\n    }\n}\n\n// MARK: - AsleepSleepTrackingManagerDelegate\nextension SleepTrackingViewModel: AsleepSleepTrackingManagerDelegate {\n    func didCreate() {\n        Task { @MainActor in\n            self.isTracking = true\n            self.error = nil\n        }\n    }\n\n    func didUpload(sequence: Int) {\n        Task { @MainActor in\n            self.sequenceNumber = sequence\n        }\n    }\n\n    func didClose(sessionId: String) {\n        Task { @MainActor in\n            self.isTracking = false\n            self.sessionId = sessionId\n        }\n    }\n\n    func didFail(error: Asleep.AsleepError) {\n        switch error {\n        case let .httpStatus(code, _, message) where code == 403 || code == 404:\n            Task { @MainActor in\n                self.isTracking = false\n                self.error = \"\\(code): \\(message ?? \"Unknown error\")\"\n            }\n        default:\n            Task { @MainActor in\n                self.error = error.localizedDescription\n            }\n        }\n    }\n\n    func didInterrupt() {\n        Task { @MainActor in\n            self.error = \"Tracking interrupted (e.g., phone call)\"\n        }\n    }\n\n    func didResume() {\n        Task { @MainActor in\n            self.error = nil\n        }\n    }\n\n    func micPermissionWasDenied() {\n        Task { @MainActor in\n            self.isTracking = false\n            self.error = \"Microphone permission denied. Please enable in Settings.\"\n        }\n    }\n\n    func analysing(session: Asleep.Model.Session) {\n        // Optional: Handle real-time analysis data\n        print(\"Real-time analysis:\", session)\n    }\n}\n\n// MARK: - AsleepDebugLoggerDelegate (Optional)\nextension SleepTrackingViewModel: AsleepDebugLoggerDelegate {\n    func didPrint(message: String) {\n        print(\"[Asleep SDK]\", message)\n    }\n}\n```\n\n## Complete SwiftUI View\n\n```swift\nimport SwiftUI\n\nstruct SleepTrackingView: View {\n    @StateObject private var viewModel = SleepTrackingViewModel()\n    @AppStorage(\"sampleapp+apikey\") private var apiKey = \"\"\n    @AppStorage(\"sampleapp+userid\") private var userId = \"\"\n\n    @State private var startTime: Date?\n    @State private var showingReport = false\n\n    var body: some View {\n        VStack(spacing: 20) {\n            // Configuration Section\n            VStack(alignment: .leading, spacing: 8) {\n                Text(\"Configuration\")\n                    .font(.headline)\n\n                TextField(\"API Key\", text: $apiKey)\n                    .textFieldStyle(.roundedBorder)\n                    .disabled(viewModel.isTracking)\n\n                TextField(\"User ID\", text: $userId)\n                    .textFieldStyle(.roundedBorder)\n                    .disabled(viewModel.isTracking)\n            }\n            .padding()\n\n            // Status Section\n            VStack(alignment: .leading, spacing: 8) {\n                Text(\"Status\")\n                    .font(.headline)\n\n                if let error = viewModel.error {\n                    Text(\"Error: \\(error)\")\n                        .foregroundColor(.red)\n                        .font(.caption)\n                }\n\n                if viewModel.isTracking {\n                    HStack {\n                        ProgressView()\n                        Text(\"Tracking...\")\n                    }\n\n                    if let sequence = viewModel.sequenceNumber {\n                        Text(\"Sequence: \\(sequence)\")\n                            .font(.caption)\n                    }\n                }\n\n                if let sessionId = viewModel.sessionId {\n                    Text(\"Session ID: \\(sessionId)\")\n                        .font(.caption)\n                        .lineLimit(1)\n                }\n            }\n            .padding()\n\n            // Tracking Control\n            Button(action: {\n                if viewModel.isTracking {\n                    stopTracking()\n                } else {\n                    startTracking()\n                }\n            }) {\n                Text(viewModel.isTracking ? \"Stop Tracking\" : \"Start Tracking\")\n                    .frame(maxWidth: .infinity)\n                    .padding()\n                    .background(viewModel.isTracking ? Color.red : Color.blue)\n                    .foregroundColor(.white)\n                    .cornerRadius(10)\n            }\n            .disabled(apiKey.isEmpty || userId.isEmpty)\n            .padding(.horizontal)\n\n            // Report Access\n            if viewModel.sessionId != nil {\n                Button(\"View Report\") {\n                    fetchReport()\n                }\n                .padding()\n            }\n\n            Spacer()\n        }\n        .padding()\n        .sheet(isPresented: $showingReport) {\n            ReportView(report: viewModel.currentReport)\n        }\n    }\n\n    private func startTracking() {\n        viewModel.sessionId = nil\n        viewModel.sequenceNumber = nil\n\n        if viewModel.config == nil {\n            viewModel.initAsleepConfig(\n                apiKey: apiKey,\n                userId: userId\n            )\n        } else {\n            viewModel.startTracking()\n        }\n\n        startTime = Date()\n    }\n\n    private func stopTracking() {\n        viewModel.stopTracking()\n    }\n\n    private func fetchReport() {\n        guard let sessionId = viewModel.sessionId else { return }\n\n        Task {\n            do {\n                let report = try await viewModel.reports?.report(sessionId: sessionId)\n                await MainActor.run {\n                    viewModel.currentReport = report\n                    showingReport = true\n                }\n            } catch {\n                await MainActor.run {\n                    viewModel.error = \"Failed to fetch report: \\(error.localizedDescription)\"\n                }\n            }\n        }\n    }\n}\n```\n\n## Complete Report View\n\n```swift\nimport SwiftUI\nimport AsleepSDK\n\nstruct ReportView: View {\n    @Environment(\\.dismiss) private var dismiss\n    let report: Asleep.Model.Report?\n\n    var body: some View {\n        NavigationView {\n            ScrollView {\n                if let report = report {\n                    VStack(alignment: .leading, spacing: 16) {\n                        // Session Information\n                        Section(\"Session Information\") {\n                            InfoRow(label: \"Session ID\", value: report.session.id)\n                            InfoRow(label: \"Start Time\", value: report.session.startTime.formatted())\n                            if let endTime = report.session.endTime {\n                                InfoRow(label: \"End Time\", value: endTime.formatted())\n                            }\n                            InfoRow(label: \"State\", value: report.session.state.rawValue)\n                        }\n\n                        Divider()\n\n                        // Sleep Statistics\n                        if let stat = report.stat {\n                            Section(\"Sleep Statistics\") {\n                                StatRow(label: \"Sleep Efficiency\", value: stat.sleepEfficiency, unit: \"%\")\n                                StatRow(label: \"Sleep Latency\", value: stat.sleepLatency, unit: \"min\")\n                                StatRow(label: \"Total Sleep Time\", value: stat.sleepTime, unit: \"min\")\n                                StatRow(label: \"Time in Bed\", value: stat.timeInBed, unit: \"min\")\n                            }\n\n                            Divider()\n\n                            Section(\"Sleep Stages\") {\n                                StatRow(label: \"Deep Sleep\", value: stat.timeInDeep, unit: \"min\")\n                                StatRow(label: \"Light Sleep\", value: stat.timeInLight, unit: \"min\")\n                                StatRow(label: \"REM Sleep\", value: stat.timeInRem, unit: \"min\")\n                                StatRow(label: \"Wake Time\", value: stat.timeInWake, unit: \"min\")\n                            }\n\n                            Divider()\n\n                            Section(\"Snoring Analysis\") {\n                                StatRow(label: \"Time Snoring\", value: stat.timeInSnoring, unit: \"min\")\n                                StatRow(label: \"Snoring Count\", value: stat.snoringCount, unit: \"times\")\n                            }\n                        }\n                    }\n                    .padding()\n                } else {\n                    Text(\"No report available\")\n                        .foregroundColor(.secondary)\n                }\n            }\n            .navigationTitle(\"Sleep Report\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct InfoRow: View {\n    let label: String\n    let value: String\n\n    var body: some View {\n        HStack {\n            Text(label)\n                .foregroundColor(.secondary)\n            Spacer()\n            Text(value)\n        }\n    }\n}\n\nstruct StatRow: View {\n    let label: String\n    let value: Int?\n    let unit: String\n\n    var body: some View {\n        HStack {\n            Text(label)\n                .foregroundColor(.secondary)\n            Spacer()\n            if let value = value {\n                Text(\"\\(value) \\(unit)\")\n            } else {\n                Text(\"N/A\")\n                    .foregroundColor(.secondary)\n            }\n        }\n    }\n}\n\nstruct Section<Content: View>: View {\n    let title: String\n    let content: Content\n\n    init(_ title: String, @ViewBuilder content: () -> Content) {\n        self.title = title\n        self.content = content()\n    }\n\n    var body: some View {\n        VStack(alignment: .leading, spacing: 8) {\n            Text(title)\n                .font(.headline)\n            content\n        }\n    }\n}\n```\n",
        "skills/sleeptrack-ios/references/ios_specific_features.md": "# iOS-Specific Features\n\nDetailed implementation guides for iOS platform features including Siri Shortcuts, background modes, permissions, lifecycle management, and persistent storage.\n\n## Siri Shortcuts Integration\n\nEnable voice-activated tracking with App Intents (iOS 16+):\n\n```swift\n// StartSleepIntent.swift\nimport AppIntents\n\n@available(iOS 16, *)\nstruct StartSleepIntent: AppIntent {\n    static var title: LocalizedStringResource = \"Start Sleep\"\n    static var description = IntentDescription(\"Start Sleep Tracking\")\n\n    func perform() async throws -> some IntentResult {\n        NotificationCenter.default.post(name: .startSleep, object: nil)\n        return .result()\n    }\n}\n\n// StopSleepIntent.swift\n@available(iOS 16, *)\nstruct StopSleepIntent: AppIntent {\n    static var title: LocalizedStringResource = \"Stop Sleep\"\n    static var description = IntentDescription(\"Stop Sleep Tracking\")\n\n    func perform() async throws -> some IntentResult {\n        NotificationCenter.default.post(name: .stopSleep, object: nil)\n        return .result()\n    }\n}\n\n// Notification extensions\nextension Notification.Name {\n    static let startSleep = Notification.Name(\"startSleep\")\n    static let stopSleep = Notification.Name(\"stopSleep\")\n}\n```\n\n### Handling Shortcuts in Views\n\n```swift\nstruct SleepTrackingView: View {\n    @StateObject private var viewModel = SleepTrackingViewModel()\n\n    var body: some View {\n        // ... view content ...\n        .onReceive(NotificationCenter.default.publisher(for: .startSleep)) { _ in\n            if !viewModel.isTracking {\n                startTracking()\n            }\n        }\n        .onReceive(NotificationCenter.default.publisher(for: .stopSleep)) { _ in\n            if viewModel.isTracking {\n                stopTracking()\n            }\n        }\n    }\n}\n```\n\nUsers can then say: \"Hey Siri, start sleep\" or \"Hey Siri, stop sleep\"\n\n## Background Audio Mode\n\nConfigure background audio to maintain tracking during sleep.\n\n### Info.plist Configuration\n\n```xml\n<key>UIBackgroundModes</key>\n<array>\n    <string>audio</string>\n</array>\n```\n\n### Implementation Notes\n\n- iOS automatically maintains background audio session during tracking\n- App remains active in background while microphone is in use\n- User sees audio indicator (red bar/pill) showing active recording\n- No additional code needed beyond Info.plist configuration\n- System handles audio session management automatically\n\n### Best Practices\n\n1. Inform users why the app needs background audio mode\n2. Display clear status indicators when tracking is active\n3. Handle audio interruptions gracefully (phone calls, other apps)\n4. Test background behavior thoroughly on physical devices\n\n## Microphone Permission Handling\n\nRequest and handle microphone permission properly:\n\n```swift\nimport AVFoundation\n\nfunc requestMicrophonePermission() async -> Bool {\n    switch AVAudioSession.sharedInstance().recordPermission {\n    case .granted:\n        return true\n    case .denied:\n        return false\n    case .undetermined:\n        return await AVAudioSession.sharedInstance().requestRecordPermission()\n    @unknown default:\n        return false\n    }\n}\n\n// Usage in SwiftUI\nButton(\"Start Tracking\") {\n    Task {\n        let hasPermission = await requestMicrophonePermission()\n        if hasPermission {\n            startTracking()\n        } else {\n            showPermissionAlert = true\n        }\n    }\n}\n```\n\n### Permission Alert Handling\n\n```swift\nstruct PermissionAlert: ViewModifier {\n    @Binding var showAlert: Bool\n\n    func body(content: Content) -> some View {\n        content\n            .alert(\"Microphone Access Required\", isPresented: $showAlert) {\n                Button(\"Open Settings\") {\n                    if let url = URL(string: UIApplication.openSettingsURLString) {\n                        UIApplication.shared.open(url)\n                    }\n                }\n                Button(\"Cancel\", role: .cancel) {}\n            } message: {\n                Text(\"Please enable microphone access in Settings to track sleep.\")\n            }\n    }\n}\n```\n\n### Checking Permission Status\n\n```swift\nfunc checkMicrophonePermission() -> Bool {\n    let status = AVAudioSession.sharedInstance().recordPermission\n    return status == .granted\n}\n```\n\n## App Lifecycle Management\n\nHandle app state transitions gracefully:\n\n```swift\nstruct SleepTrackingView: View {\n    @Environment(\\.scenePhase) private var scenePhase\n\n    var body: some View {\n        // ... view content ...\n        .onChange(of: scenePhase) { newPhase in\n            switch newPhase {\n            case .active:\n                print(\"App is active\")\n                // Refresh UI state if needed\n            case .inactive:\n                print(\"App is inactive\")\n                // Prepare for potential backgrounding\n            case .background:\n                // Tracking continues in background with audio mode\n                print(\"App is in background\")\n                // Minimal operations only\n            @unknown default:\n                break\n            }\n        }\n    }\n}\n```\n\n### Advanced Lifecycle Handling\n\n```swift\nclass AppLifecycleObserver: ObservableObject {\n    @Published var isActive = true\n    private var cancellables = Set<AnyCancellable>()\n\n    init() {\n        NotificationCenter.default.publisher(for: UIApplication.didEnterBackgroundNotification)\n            .sink { [weak self] _ in\n                self?.handleEnterBackground()\n            }\n            .store(in: &cancellables)\n\n        NotificationCenter.default.publisher(for: UIApplication.willEnterForegroundNotification)\n            .sink { [weak self] _ in\n                self?.handleEnterForeground()\n            }\n            .store(in: &cancellables)\n    }\n\n    private func handleEnterBackground() {\n        isActive = false\n        // Save state, reduce operations\n    }\n\n    private func handleEnterForeground() {\n        isActive = true\n        // Refresh state, resume operations\n    }\n}\n```\n\n## Persistent Storage with AppStorage\n\nStore configuration persistently across app launches:\n\n```swift\nstruct SleepTrackingView: View {\n    @AppStorage(\"sleepapp+apikey\") private var apiKey = \"\"\n    @AppStorage(\"sleepapp+userid\") private var userId = \"\"\n    @AppStorage(\"sleepapp+baseurl\") private var baseUrl = \"\"\n\n    // Values automatically persist across app launches\n    // Uses UserDefaults under the hood\n}\n```\n\n### Custom Storage Keys\n\n```swift\nextension String {\n    static let apiKeyStorage = \"sleepapp+apikey\"\n    static let userIdStorage = \"sleepapp+userid\"\n    static let baseUrlStorage = \"sleepapp+baseurl\"\n}\n\nstruct SleepTrackingView: View {\n    @AppStorage(.apiKeyStorage) private var apiKey = \"\"\n    @AppStorage(.userIdStorage) private var userId = \"\"\n    @AppStorage(.baseUrlStorage) private var baseUrl = \"\"\n}\n```\n\n### Advanced Persistent Storage\n\n```swift\nclass PersistentSettings: ObservableObject {\n    @AppStorage(\"sleepapp+apikey\") var apiKey = \"\"\n    @AppStorage(\"sleepapp+userid\") var userId = \"\"\n    @AppStorage(\"sleepapp+baseurl\") var baseUrl = \"\"\n    @AppStorage(\"sleepapp+notifications\") var notificationsEnabled = false\n    @AppStorage(\"sleepapp+lastSessionId\") var lastSessionId = \"\"\n\n    func clearAll() {\n        apiKey = \"\"\n        userId = \"\"\n        baseUrl = \"\"\n        notificationsEnabled = false\n        lastSessionId = \"\"\n    }\n}\n\n// Usage\nstruct SettingsView: View {\n    @StateObject private var settings = PersistentSettings()\n\n    var body: some View {\n        Form {\n            TextField(\"API Key\", text: $settings.apiKey)\n            TextField(\"User ID\", text: $settings.userId)\n            Toggle(\"Notifications\", isOn: $settings.notificationsEnabled)\n        }\n    }\n}\n```\n"
      },
      "plugins": [
        {
          "name": "sleeptrack-skills",
          "description": "Collection of Asleep API integration skills covering foundation concepts, Android SDK, iOS SDK, and backend REST API integration",
          "source": "./",
          "strict": false,
          "skills": [
            "./skills/sleeptrack-foundation",
            "./skills/sleeptrack-android",
            "./skills/sleeptrack-ios",
            "./skills/sleeptrack-be"
          ],
          "categories": [],
          "install_commands": [
            "/plugin marketplace add asleep-ai/sleeptrack-skills",
            "/plugin install sleeptrack-skills@sleeptrack-skills"
          ]
        }
      ]
    }
  ]
}