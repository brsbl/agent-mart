{
  "author": {
    "id": "OthmanAdi",
    "display_name": "Ahmad Othman Ammar Adi.",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/78882424?u=0799871dc576e27a4ae3780bbbbc23f5f41e69dd&v=4",
    "url": "https://github.com/OthmanAdi",
    "bio": "Dedicated educator, fostering future tech innovators & critical thinkers through codingğŸŒŸ Empowering students with knowledge & passionâ„ï¸",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 2,
      "total_skills": 12,
      "total_stars": 11767,
      "total_forks": 1082
    }
  },
  "marketplaces": [
    {
      "name": "planning-with-files",
      "version": null,
      "description": "Manus-style persistent markdown files for planning, progress tracking, and knowledge storage. Now with hooks integration.",
      "owner_info": {
        "name": "Ahmad Othman Ammar Adi",
        "url": "https://github.com/OthmanAdi"
      },
      "keywords": [],
      "repo_full_name": "OthmanAdi/planning-with-files",
      "repo_url": "https://github.com/OthmanAdi/planning-with-files",
      "repo_description": "Claude Code skill implementing Manus-style persistent markdown planning â€” the workflow pattern behind the $2B acquisition.",
      "homepage": "https://www.aikux.ai",
      "signals": {
        "stars": 11767,
        "forks": 1082,
        "pushed_at": "2026-01-27T21:22:59Z",
        "created_at": "2026-01-03T07:37:28Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".adal",
          "type": "tree",
          "size": null
        },
        {
          "path": ".adal/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".adal/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".adal/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 5361
        },
        {
          "path": ".adal/skills/planning-with-files/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".adal/skills/planning-with-files/references/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".adal/skills/planning-with-files/references/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".adal/skills/planning-with-files/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".adal/skills/planning-with-files/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".adal/skills/planning-with-files/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".adal/skills/planning-with-files/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".agent",
          "type": "tree",
          "size": null
        },
        {
          "path": ".agent/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".agent/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".agent/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 3462
        },
        {
          "path": ".agent/skills/planning-with-files/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".agent/skills/planning-with-files/references.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".agent/skills/planning-with-files/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".agent/skills/planning-with-files/references/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".agent/skills/planning-with-files/references/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".agent/skills/planning-with-files/references/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 396
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 774
        },
        {
          "path": ".codebuddy",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codebuddy/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codebuddy/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codebuddy/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 7836
        },
        {
          "path": ".codebuddy/skills/planning-with-files/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codebuddy/skills/planning-with-files/assets/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codebuddy/skills/planning-with-files/assets/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".codebuddy/skills/planning-with-files/assets/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".codebuddy/skills/planning-with-files/assets/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".codebuddy/skills/planning-with-files/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codebuddy/skills/planning-with-files/references/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".codebuddy/skills/planning-with-files/references/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".codex",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 7832
        },
        {
          "path": ".codex/skills/planning-with-files/assets",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/skills/planning-with-files/assets/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/skills/planning-with-files/assets/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".codex/skills/planning-with-files/assets/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".codex/skills/planning-with-files/assets/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".codex/skills/planning-with-files/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/skills/planning-with-files/references/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".codex/skills/planning-with-files/references/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".continue",
          "type": "tree",
          "size": null
        },
        {
          "path": ".continue/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".continue/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".continue/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 2591
        },
        {
          "path": ".continue/skills/planning-with-files/examples.md",
          "type": "blob",
          "size": 4422
        },
        {
          "path": ".continue/skills/planning-with-files/reference.md",
          "type": "blob",
          "size": 7979
        },
        {
          "path": ".cursor",
          "type": "tree",
          "size": null
        },
        {
          "path": ".cursor/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".cursor/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".cursor/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 7833
        },
        {
          "path": ".cursor/skills/planning-with-files/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".cursor/skills/planning-with-files/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".cursor/skills/planning-with-files/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".cursor/skills/planning-with-files/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".cursor/skills/planning-with-files/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".cursor/skills/planning-with-files/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".factory",
          "type": "tree",
          "size": null
        },
        {
          "path": ".factory/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".factory/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".factory/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 4353
        },
        {
          "path": ".factory/skills/planning-with-files/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".factory/skills/planning-with-files/references.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".factory/skills/planning-with-files/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".factory/skills/planning-with-files/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".factory/skills/planning-with-files/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".factory/skills/planning-with-files/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".gemini",
          "type": "tree",
          "size": null
        },
        {
          "path": ".gemini/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".gemini/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".gemini/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 5418
        },
        {
          "path": ".gemini/skills/planning-with-files/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".gemini/skills/planning-with-files/references/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".gemini/skills/planning-with-files/references/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".gemini/skills/planning-with-files/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".gemini/skills/planning-with-files/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".gemini/skills/planning-with-files/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".gemini/skills/planning-with-files/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".kilocode",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kilocode/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kilocode/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kilocode/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 7835
        },
        {
          "path": ".kilocode/skills/planning-with-files/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".kilocode/skills/planning-with-files/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".kilocode/skills/planning-with-files/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kilocode/skills/planning-with-files/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".kilocode/skills/planning-with-files/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".kilocode/skills/planning-with-files/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".moltbot",
          "type": "tree",
          "size": null
        },
        {
          "path": ".moltbot/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".moltbot/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".moltbot/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 5572
        },
        {
          "path": ".moltbot/skills/planning-with-files/references",
          "type": "tree",
          "size": null
        },
        {
          "path": ".moltbot/skills/planning-with-files/references/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".moltbot/skills/planning-with-files/references/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".moltbot/skills/planning-with-files/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".moltbot/skills/planning-with-files/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".moltbot/skills/planning-with-files/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".moltbot/skills/planning-with-files/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": ".opencode",
          "type": "tree",
          "size": null
        },
        {
          "path": ".opencode/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".opencode/skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": ".opencode/skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 7835
        },
        {
          "path": ".opencode/skills/planning-with-files/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": ".opencode/skills/planning-with-files/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": ".opencode/skills/planning-with-files/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".opencode/skills/planning-with-files/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": ".opencode/skills/planning-with-files/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": ".opencode/skills/planning-with-files/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 16459
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/plan.md",
          "type": "blob",
          "size": 508
        },
        {
          "path": "commands/start.md",
          "type": "blob",
          "size": 417
        },
        {
          "path": "examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/README.md",
          "type": "blob",
          "size": 17749
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/planning-with-files",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/planning-with-files/SKILL.md",
          "type": "blob",
          "size": 7853
        },
        {
          "path": "skills/planning-with-files/examples.md",
          "type": "blob",
          "size": 4426
        },
        {
          "path": "skills/planning-with-files/reference.md",
          "type": "blob",
          "size": 8066
        },
        {
          "path": "skills/planning-with-files/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/planning-with-files/templates/findings.md",
          "type": "blob",
          "size": 3561
        },
        {
          "path": "skills/planning-with-files/templates/progress.md",
          "type": "blob",
          "size": 4001
        },
        {
          "path": "skills/planning-with-files/templates/task_plan.md",
          "type": "blob",
          "size": 4613
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"planning-with-files\",\n  \"owner\": {\n    \"name\": \"Ahmad Othman Ammar Adi\",\n    \"url\": \"https://github.com/OthmanAdi\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"planning-with-files\",\n      \"source\": \"./\",\n      \"description\": \"Manus-style persistent markdown files for planning, progress tracking, and knowledge storage. Now with hooks integration.\",\n      \"version\": \"2.0.0\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"planning-with-files\",\n  \"version\": \"2.11.0\",\n  \"description\": \"Manus-style persistent markdown files for planning, progress tracking, and knowledge storage. Works with Claude Code, Kiro, Clawd CLI, Gemini CLI, Cursor, Continue, and 11+ AI coding assistants.\",\n  \"author\": {\n    \"name\": \"OthmanAdi\",\n    \"url\": \"https://github.com/OthmanAdi\"\n  },\n  \"repository\": \"https://github.com/OthmanAdi/planning-with-files\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"planning\",\n    \"manus\",\n    \"workflow\",\n    \"markdown\",\n    \"context-engineering\",\n    \"task-management\",\n    \"templates\",\n    \"clawd\",\n    \"clawdbot\",\n    \"clawdhub\",\n    \"kiro\",\n    \"kiro-steering\",\n    \"amazon-kiro\",\n    \"gemini\",\n    \"cursor\",\n    \"continue\",\n    \"multi-ide\",\n    \"agent-skills\"\n  ]\n}\n",
        ".adal/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls.\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation (execute via bash):\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n- `scripts/session-catchup.py` â€” Recover context from previous session\n\nTo use scripts:\n```bash\nbash scripts/init-session.sh\nbash scripts/check-complete.sh\npython scripts/session-catchup.py $(pwd)\n```\n\n## Advanced Topics\n\n- **Manus Principles:** See [references/reference.md](references/reference.md)\n- **Real Examples:** See [references/examples.md](references/examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| Use TodoWrite for persistence | Create task_plan.md file |\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        ".adal/skills/planning-with-files/references/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".adal/skills/planning-with-files/references/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".adal/skills/planning-with-files/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".adal/skills/planning-with-files/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".adal/skills/planning-with-files/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".agent/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls.\nlicense: MIT\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## Core Principle\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## Quick Start\n\nBefore ANY complex task, create these three files:\n\n1. **task_plan.md** â€” Track phases and progress\n2. **findings.md** â€” Store research and discoveries\n3. **progress.md** â€” Session log and test results\n\nSee references/ for starting templates.\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\n- references/task_plan.md â€” Phase tracking template\n- references/findings.md â€” Research storage template\n- references/progress.md â€” Session logging template\n\n## Advanced Topics\n\n- **Manus Principles:** See references.md for complete context engineering patterns\n- **Real Examples:** See examples.md for practical implementations\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n\n---\n\n**This pattern is why Manus went from launch to $2B acquisition in 8 months.**\n",
        ".agent/skills/planning-with-files/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".agent/skills/planning-with-files/references.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".agent/skills/planning-with-files/references/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".agent/skills/planning-with-files/references/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".agent/skills/planning-with-files/references/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".codebuddy/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\nversion: \"2.10.0\"\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls. Now with automatic session recovery after /clear.\nuser-invocable: true\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Glob\n  - Grep\n  - WebFetch\n  - WebSearch\nhooks:\n  PreToolUse:\n    - matcher: \"Write|Edit|Bash|Read|Glob|Grep\"\n      hooks:\n        - type: command\n          command: \"cat task_plan.md 2>/dev/null | head -30 || true\"\n  PostToolUse:\n    - matcher: \"Write|Edit\"\n      hooks:\n        - type: command\n          command: \"echo '[planning-with-files] File updated. If this completes a phase, update task_plan.md status.'\"\n  Stop:\n    - hooks:\n        - type: command\n          command: |\n            SCRIPT_DIR=\"${CLAUDE_PLUGIN_ROOT:-$HOME/.claude/plugins/planning-with-files}/scripts\"\n\n            IS_WINDOWS=0\n            if [ \"${OS-}\" = \"Windows_NT\" ]; then\n              IS_WINDOWS=1\n            else\n              UNAME_S=\"$(uname -s 2>/dev/null || echo '')\"\n              case \"$UNAME_S\" in\n                CYGWIN*|MINGW*|MSYS*) IS_WINDOWS=1 ;;\n              esac\n            fi\n\n            if [ \"$IS_WINDOWS\" -eq 1 ]; then\n              if command -v pwsh >/dev/null 2>&1; then\n                pwsh -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              else\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              fi\n            else\n              sh \"$SCRIPT_DIR/check-complete.sh\"\n            fi\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## FIRST: Check for Previous Session (v2.2.0)\n\n**Before starting work**, check for unsynced context from a previous session:\n\n```bash\n# Linux/macOS (auto-detects python3 or python)\n$(command -v python3 || command -v python) ${CLAUDE_PLUGIN_ROOT}/scripts/session-catchup.py \"$(pwd)\"\n```\n\n```powershell\n# Windows PowerShell\npython \"$env:USERPROFILE\\.codebuddy\\skills\\planning-with-files\\scripts\\session-catchup.py\" (Get-Location)\n```\n\nIf catchup report shows unsynced context:\n1. Run `git diff --stat` to see actual code changes\n2. Read current planning files\n3. Update planning files based on catchup + git diff\n4. Then proceed with task\n\n## Important: Where Files Go\n\n- **Templates** are in `${CLAUDE_PLUGIN_ROOT}/templates/`\n- **Your planning files** go in **your project directory**\n\n| Location | What Goes There |\n|----------|-----------------|\n| Skill directory (`${CLAUDE_PLUGIN_ROOT}/`) | Templates, scripts, reference docs |\n| Your project directory | `task_plan.md`, `findings.md`, `progress.md` |\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation:\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n- `scripts/session-catchup.py` â€” Recover context from previous session (v2.2.0)\n\n## Advanced Topics\n\n- **Manus Principles:** See [reference.md](reference.md)\n- **Real Examples:** See [examples.md](examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| Use TodoWrite for persistence | Create task_plan.md file |\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        ".codebuddy/skills/planning-with-files/assets/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".codebuddy/skills/planning-with-files/assets/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".codebuddy/skills/planning-with-files/assets/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".codebuddy/skills/planning-with-files/references/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".codebuddy/skills/planning-with-files/references/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".codex/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\nversion: \"2.10.0\"\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls. Now with automatic session recovery after /clear.\nuser-invocable: true\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Glob\n  - Grep\n  - WebFetch\n  - WebSearch\nhooks:\n  PreToolUse:\n    - matcher: \"Write|Edit|Bash|Read|Glob|Grep\"\n      hooks:\n        - type: command\n          command: \"cat task_plan.md 2>/dev/null | head -30 || true\"\n  PostToolUse:\n    - matcher: \"Write|Edit\"\n      hooks:\n        - type: command\n          command: \"echo '[planning-with-files] File updated. If this completes a phase, update task_plan.md status.'\"\n  Stop:\n    - hooks:\n        - type: command\n          command: |\n            SCRIPT_DIR=\"${CLAUDE_PLUGIN_ROOT:-$HOME/.claude/plugins/planning-with-files}/scripts\"\n\n            IS_WINDOWS=0\n            if [ \"${OS-}\" = \"Windows_NT\" ]; then\n              IS_WINDOWS=1\n            else\n              UNAME_S=\"$(uname -s 2>/dev/null || echo '')\"\n              case \"$UNAME_S\" in\n                CYGWIN*|MINGW*|MSYS*) IS_WINDOWS=1 ;;\n              esac\n            fi\n\n            if [ \"$IS_WINDOWS\" -eq 1 ]; then\n              if command -v pwsh >/dev/null 2>&1; then\n                pwsh -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              else\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              fi\n            else\n              sh \"$SCRIPT_DIR/check-complete.sh\"\n            fi\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## FIRST: Check for Previous Session (v2.2.0)\n\n**Before starting work**, check for unsynced context from a previous session:\n\n```bash\n# Linux/macOS (auto-detects python3 or python)\n$(command -v python3 || command -v python) ${CLAUDE_PLUGIN_ROOT}/scripts/session-catchup.py \"$(pwd)\"\n```\n\n```powershell\n# Windows PowerShell\npython \"$env:USERPROFILE\\.codex\\skills\\planning-with-files\\scripts\\session-catchup.py\" (Get-Location)\n```\n\nIf catchup report shows unsynced context:\n1. Run `git diff --stat` to see actual code changes\n2. Read current planning files\n3. Update planning files based on catchup + git diff\n4. Then proceed with task\n\n## Important: Where Files Go\n\n- **Templates** are in `${CLAUDE_PLUGIN_ROOT}/templates/`\n- **Your planning files** go in **your project directory**\n\n| Location | What Goes There |\n|----------|-----------------|\n| Skill directory (`${CLAUDE_PLUGIN_ROOT}/`) | Templates, scripts, reference docs |\n| Your project directory | `task_plan.md`, `findings.md`, `progress.md` |\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation:\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n- `scripts/session-catchup.py` â€” Recover context from previous session (v2.2.0)\n\n## Advanced Topics\n\n- **Manus Principles:** See [reference.md](reference.md)\n- **Real Examples:** See [examples.md](examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| Use TodoWrite for persistence | Create task_plan.md file |\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        ".codex/skills/planning-with-files/assets/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".codex/skills/planning-with-files/assets/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".codex/skills/planning-with-files/assets/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".codex/skills/planning-with-files/references/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".codex/skills/planning-with-files/references/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".continue/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\nversion: \"2.10.0\"\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls. Now with automatic session recovery after /clear.\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## FIRST: Check for Previous Session (v2.2.0)\n\nBefore starting work, check for unsynced context from a previous session:\n\n```bash\npython3 .continue/skills/planning-with-files/scripts/session-catchup.py \"$(pwd)\" || python .continue/skills/planning-with-files/scripts/session-catchup.py \"$(pwd)\"\n```\n\nIf catchup report shows unsynced context:\n1. Run `git diff --stat` to see actual code changes\n2. Read current planning files\n3. Update planning files based on catchup + git diff\n4. Then proceed with task\n\n## Quick Start\n\nBefore any complex task:\n\n1. Create `task_plan.md`, `findings.md`, `progress.md` in your project root\n2. If they don't exist yet, initialize them using:\n   - macOS/Linux: `bash .continue/skills/planning-with-files/scripts/init-session.sh`\n   - Windows: `powershell -ExecutionPolicy Bypass -File .continue/skills/planning-with-files/scripts/init-session.ps1`\n3. Re-read `task_plan.md` before major decisions\n4. Update `task_plan.md` after each phase completes\n5. Write discoveries to `findings.md` (especially after web/search/image/PDF viewing)\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After any discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\n\nNever start a complex task without `task_plan.md`.\n\n### 2. The 2-Action Rule\n\nAfter every 2 view/browser/search operations, save key findings to text files.\n\n### 3. Read Before Decide\n\nBefore major decisions, read `task_plan.md` to refresh goals.\n\n### 4. Update After Act\n\nAfter completing any phase, update statuses and log errors in `task_plan.md`.\n\n### 5. Log ALL Errors\n\nEvery error goes in the plan file so you don't repeat it.\n\n### 6. Never Repeat Failures\n\nIf an action failed, the next action must be different.\n\n## References\n\n- [reference.md](reference.md)\n- [examples.md](examples.md)\n",
        ".continue/skills/planning-with-files/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\nAlways read your plan before major decisions:\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".continue/skills/planning-with-files/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After any discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- Single-action execution: one tool call per turn\n- Plan is required: always know goal, current phase, remaining phases\n- Files are memory: context is volatile; filesystem is persistent\n- Never repeat failures: if action failed, next action must be different\n- Communication is a tool: message types include info, ask, result\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".cursor/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\nversion: \"2.10.0\"\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls. Now with automatic session recovery after /clear.\nuser-invocable: true\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Glob\n  - Grep\n  - WebFetch\n  - WebSearch\nhooks:\n  PreToolUse:\n    - matcher: \"Write|Edit|Bash|Read|Glob|Grep\"\n      hooks:\n        - type: command\n          command: \"cat task_plan.md 2>/dev/null | head -30 || true\"\n  PostToolUse:\n    - matcher: \"Write|Edit\"\n      hooks:\n        - type: command\n          command: \"echo '[planning-with-files] File updated. If this completes a phase, update task_plan.md status.'\"\n  Stop:\n    - hooks:\n        - type: command\n          command: |\n            SCRIPT_DIR=\"${CLAUDE_PLUGIN_ROOT:-$HOME/.claude/plugins/planning-with-files}/scripts\"\n\n            IS_WINDOWS=0\n            if [ \"${OS-}\" = \"Windows_NT\" ]; then\n              IS_WINDOWS=1\n            else\n              UNAME_S=\"$(uname -s 2>/dev/null || echo '')\"\n              case \"$UNAME_S\" in\n                CYGWIN*|MINGW*|MSYS*) IS_WINDOWS=1 ;;\n              esac\n            fi\n\n            if [ \"$IS_WINDOWS\" -eq 1 ]; then\n              if command -v pwsh >/dev/null 2>&1; then\n                pwsh -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              else\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              fi\n            else\n              sh \"$SCRIPT_DIR/check-complete.sh\"\n            fi\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## FIRST: Check for Previous Session (v2.2.0)\n\n**Before starting work**, check for unsynced context from a previous session:\n\n```bash\n# Linux/macOS (auto-detects python3 or python)\n$(command -v python3 || command -v python) ${CLAUDE_PLUGIN_ROOT}/scripts/session-catchup.py \"$(pwd)\"\n```\n\n```powershell\n# Windows PowerShell\npython \"$env:USERPROFILE\\.cursor\\skills\\planning-with-files\\scripts\\session-catchup.py\" (Get-Location)\n```\n\nIf catchup report shows unsynced context:\n1. Run `git diff --stat` to see actual code changes\n2. Read current planning files\n3. Update planning files based on catchup + git diff\n4. Then proceed with task\n\n## Important: Where Files Go\n\n- **Templates** are in `${CLAUDE_PLUGIN_ROOT}/templates/`\n- **Your planning files** go in **your project directory**\n\n| Location | What Goes There |\n|----------|-----------------|\n| Skill directory (`${CLAUDE_PLUGIN_ROOT}/`) | Templates, scripts, reference docs |\n| Your project directory | `task_plan.md`, `findings.md`, `progress.md` |\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation:\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n- `scripts/session-catchup.py` â€” Recover context from previous session (v2.2.0)\n\n## Advanced Topics\n\n- **Manus Principles:** See [reference.md](reference.md)\n- **Real Examples:** See [examples.md](examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| Use TodoWrite for persistence | Create task_plan.md file |\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        ".cursor/skills/planning-with-files/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".cursor/skills/planning-with-files/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".cursor/skills/planning-with-files/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".cursor/skills/planning-with-files/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".cursor/skills/planning-with-files/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".factory/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls.\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## Core Principle\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## Quick Start\n\nBefore ANY complex task, create these three files:\n\n1. **task_plan.md** â€” Track phases and progress\n2. **findings.md** â€” Store research and discoveries\n3. **progress.md** â€” Session log and test results\n\nSee [templates/](./templates/) for starting templates.\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n\n## Advanced Topics\n\n- **Manus Principles:** See [references.md](./references.md)\n- **Real Examples:** See [examples.md](./examples.md)\n\n---\n\n**This pattern is why Manus went from launch to $2B acquisition in 8 months.**\n",
        ".factory/skills/planning-with-files/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".factory/skills/planning-with-files/references.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".factory/skills/planning-with-files/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".factory/skills/planning-with-files/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".factory/skills/planning-with-files/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".gemini/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls.\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## Important: Where Files Go\n\n- **Templates** are in this skill's `templates/` folder\n- **Your planning files** go in **your project directory**\n\n| Location | What Goes There |\n|----------|-----------------|\n| Skill directory | Templates, scripts, reference docs |\n| Your project directory | `task_plan.md`, `findings.md`, `progress.md` |\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation:\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n\n## Advanced Topics\n\n- **Manus Principles:** See [references/reference.md](references/reference.md)\n- **Real Examples:** See [references/examples.md](references/examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        ".gemini/skills/planning-with-files/references/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".gemini/skills/planning-with-files/references/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".gemini/skills/planning-with-files/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".gemini/skills/planning-with-files/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".gemini/skills/planning-with-files/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".kilocode/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\nversion: \"2.10.0\"\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls. Now with automatic session recovery after /clear.\nuser-invocable: true\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Glob\n  - Grep\n  - WebFetch\n  - WebSearch\nhooks:\n  PreToolUse:\n    - matcher: \"Write|Edit|Bash|Read|Glob|Grep\"\n      hooks:\n        - type: command\n          command: \"cat task_plan.md 2>/dev/null | head -30 || true\"\n  PostToolUse:\n    - matcher: \"Write|Edit\"\n      hooks:\n        - type: command\n          command: \"echo '[planning-with-files] File updated. If this completes a phase, update task_plan.md status.'\"\n  Stop:\n    - hooks:\n        - type: command\n          command: |\n            SCRIPT_DIR=\"${CLAUDE_PLUGIN_ROOT:-$HOME/.claude/plugins/planning-with-files}/scripts\"\n\n            IS_WINDOWS=0\n            if [ \"${OS-}\" = \"Windows_NT\" ]; then\n              IS_WINDOWS=1\n            else\n              UNAME_S=\"$(uname -s 2>/dev/null || echo '')\"\n              case \"$UNAME_S\" in\n                CYGWIN*|MINGW*|MSYS*) IS_WINDOWS=1 ;;\n              esac\n            fi\n\n            if [ \"$IS_WINDOWS\" -eq 1 ]; then\n              if command -v pwsh >/dev/null 2>&1; then\n                pwsh -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              else\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              fi\n            else\n              sh \"$SCRIPT_DIR/check-complete.sh\"\n            fi\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## FIRST: Check for Previous Session (v2.2.0)\n\n**Before starting work**, check for unsynced context from a previous session:\n\n```bash\n# Linux/macOS (auto-detects python3 or python)\n$(command -v python3 || command -v python) ${CLAUDE_PLUGIN_ROOT}/scripts/session-catchup.py \"$(pwd)\"\n```\n\n```powershell\n# Windows PowerShell\npython \"$env:USERPROFILE\\.kilocode\\skills\\planning-with-files\\scripts\\session-catchup.py\" (Get-Location)\n```\n\nIf catchup report shows unsynced context:\n1. Run `git diff --stat` to see actual code changes\n2. Read current planning files\n3. Update planning files based on catchup + git diff\n4. Then proceed with task\n\n## Important: Where Files Go\n\n- **Templates** are in `${CLAUDE_PLUGIN_ROOT}/templates/`\n- **Your planning files** go in **your project directory**\n\n| Location | What Goes There |\n|----------|-----------------|\n| Skill directory (`${CLAUDE_PLUGIN_ROOT}/`) | Templates, scripts, reference docs |\n| Your project directory | `task_plan.md`, `findings.md`, `progress.md` |\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation:\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n- `scripts/session-catchup.py` â€” Recover context from previous session (v2.2.0)\n\n## Advanced Topics\n\n- **Manus Principles:** See [reference.md](reference.md)\n- **Real Examples:** See [examples.md](examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| Use TodoWrite for persistence | Create task_plan.md file |\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        ".kilocode/skills/planning-with-files/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".kilocode/skills/planning-with-files/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".kilocode/skills/planning-with-files/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".kilocode/skills/planning-with-files/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".kilocode/skills/planning-with-files/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".moltbot/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\nversion: \"2.10.0\"\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls.\nhomepage: https://github.com/OthmanAdi/planning-with-files\nuser-invocable: true\nmetadata: {\"moltbot\":{\"os\":[\"darwin\",\"linux\",\"win32\"]}}\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## Important: Where Files Go\n\n- **Templates** are in this skill's `templates/` folder\n- **Your planning files** go in **your project directory**\n\n| Location | What Goes There |\n|----------|-----------------|\n| Skill directory | Templates, scripts, reference docs |\n| Your project directory | `task_plan.md`, `findings.md`, `progress.md` |\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation:\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n\n## Advanced Topics\n\n- **Manus Principles:** See [references/reference.md](references/reference.md)\n- **Real Examples:** See [references/examples.md](references/examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        ".moltbot/skills/planning-with-files/references/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".moltbot/skills/planning-with-files/references/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".moltbot/skills/planning-with-files/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".moltbot/skills/planning-with-files/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".moltbot/skills/planning-with-files/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        ".opencode/skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\nversion: \"2.10.0\"\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls. Now with automatic session recovery after /clear.\nuser-invocable: true\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Glob\n  - Grep\n  - WebFetch\n  - WebSearch\nhooks:\n  PreToolUse:\n    - matcher: \"Write|Edit|Bash|Read|Glob|Grep\"\n      hooks:\n        - type: command\n          command: \"cat task_plan.md 2>/dev/null | head -30 || true\"\n  PostToolUse:\n    - matcher: \"Write|Edit\"\n      hooks:\n        - type: command\n          command: \"echo '[planning-with-files] File updated. If this completes a phase, update task_plan.md status.'\"\n  Stop:\n    - hooks:\n        - type: command\n          command: |\n            SCRIPT_DIR=\"${CLAUDE_PLUGIN_ROOT:-$HOME/.claude/plugins/planning-with-files}/scripts\"\n\n            IS_WINDOWS=0\n            if [ \"${OS-}\" = \"Windows_NT\" ]; then\n              IS_WINDOWS=1\n            else\n              UNAME_S=\"$(uname -s 2>/dev/null || echo '')\"\n              case \"$UNAME_S\" in\n                CYGWIN*|MINGW*|MSYS*) IS_WINDOWS=1 ;;\n              esac\n            fi\n\n            if [ \"$IS_WINDOWS\" -eq 1 ]; then\n              if command -v pwsh >/dev/null 2>&1; then\n                pwsh -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              else\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              fi\n            else\n              sh \"$SCRIPT_DIR/check-complete.sh\"\n            fi\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## FIRST: Check for Previous Session (v2.2.0)\n\n**Before starting work**, check for unsynced context from a previous session:\n\n```bash\n# Linux/macOS (auto-detects python3 or python)\n$(command -v python3 || command -v python) ${CLAUDE_PLUGIN_ROOT}/scripts/session-catchup.py \"$(pwd)\"\n```\n\n```powershell\n# Windows PowerShell\npython \"$env:USERPROFILE\\.opencode\\skills\\planning-with-files\\scripts\\session-catchup.py\" (Get-Location)\n```\n\nIf catchup report shows unsynced context:\n1. Run `git diff --stat` to see actual code changes\n2. Read current planning files\n3. Update planning files based on catchup + git diff\n4. Then proceed with task\n\n## Important: Where Files Go\n\n- **Templates** are in `${CLAUDE_PLUGIN_ROOT}/templates/`\n- **Your planning files** go in **your project directory**\n\n| Location | What Goes There |\n|----------|-----------------|\n| Skill directory (`${CLAUDE_PLUGIN_ROOT}/`) | Templates, scripts, reference docs |\n| Your project directory | `task_plan.md`, `findings.md`, `progress.md` |\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation:\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n- `scripts/session-catchup.py` â€” Recover context from previous session (v2.2.0)\n\n## Advanced Topics\n\n- **Manus Principles:** See [reference.md](reference.md)\n- **Real Examples:** See [examples.md](examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| Use TodoWrite for persistence | Create task_plan.md file |\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        ".opencode/skills/planning-with-files/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        ".opencode/skills/planning-with-files/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        ".opencode/skills/planning-with-files/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        ".opencode/skills/planning-with-files/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        ".opencode/skills/planning-with-files/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n",
        "README.md": "# Planning with Files\n\n> **Work like Manus** â€” the AI agent company Meta acquired for **$2 billion**.\n\n## Thank You\n\nTo everyone who starred, forked, and shared this skill â€” thank you. This project blew up in less than 24 hours, and the support from the community has been incredible.\n\nIf this skill helps you work smarter, that's all I wanted.\n\n---\n\nA Claude Code plugin that transforms your workflow to use persistent markdown files for planning, progress tracking, and knowledge storage â€” the exact pattern that made Manus worth billions.\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Claude Code Plugin](https://img.shields.io/badge/Claude%20Code-Plugin-blue)](https://code.claude.com/docs/en/plugins)\n[![Claude Code Skill](https://img.shields.io/badge/Claude%20Code-Skill-green)](https://code.claude.com/docs/en/skills)\n[![Cursor Skills](https://img.shields.io/badge/Cursor-Skills-purple)](https://docs.cursor.com/context/skills)\n[![Kilocode Skills](https://img.shields.io/badge/Kilocode-Skills-orange)](https://kilo.ai/docs/agent-behavior/skills)\n[![Gemini CLI](https://img.shields.io/badge/Gemini%20CLI-Skills-4285F4)](https://geminicli.com/docs/cli/skills/)\n[![Moltbot](https://img.shields.io/badge/Moltbot-Skills-FF6B6B)](https://docs.molt.bot/tools/skills)\n[![Kiro](https://img.shields.io/badge/Kiro-Steering-00D4AA)](https://kiro.dev/docs/cli/steering/)\n[![AdaL CLI](https://img.shields.io/badge/AdaL%20CLI-Skills-9B59B6)](https://docs.sylph.ai/features/plugins-and-skills)\n[![Version](https://img.shields.io/badge/version-2.13.0-brightgreen)](https://github.com/OthmanAdi/planning-with-files/releases)\n[![SkillCheck Validated](https://img.shields.io/badge/SkillCheck-Validated-4c1)](https://getskillcheck.com)\n\n## Quick Install\n\n```bash\n# Install the plugin\nclaude plugins install OthmanAdi/planning-with-files\n```\n\nThat's it! Now use one of these commands in Claude Code:\n\n| Command | Autocomplete | Description |\n|---------|--------------|-------------|\n| `/planning-with-files:plan` | Type `/plan` | Shorter command (v2.11.0+) |\n| `/planning-with-files:start` | Type `/planning` | Original command |\n\n**Alternative:** If you want `/planning-with-files` (without prefix), copy skills to your local folder:\n\n```bash\n# Optional: Copy skills for /planning-with-files command\ncp -r ~/.claude/plugins/cache/planning-with-files/planning-with-files/*/skills/planning-with-files ~/.claude/skills/\n```\n\n**Windows (PowerShell):**\n```powershell\n# Install the plugin\nclaude plugins install OthmanAdi/planning-with-files\n\n# Optional: Copy skills for /planning-with-files command\nCopy-Item -Recurse -Path \"$env:USERPROFILE\\.claude\\plugins\\cache\\planning-with-files\\planning-with-files\\*\\skills\\planning-with-files\" -Destination \"$env:USERPROFILE\\.claude\\skills\\\"\n```\n\nSee [docs/installation.md](docs/installation.md) for all installation methods.\n\n## Supported IDEs\n\n| IDE | Status | Installation Guide | Format |\n|-----|--------|-------------------|--------|\n| Claude Code | âœ… Full Support | [Installation](docs/installation.md) | Plugin + SKILL.md |\n| Gemini CLI | âœ… Full Support | [Gemini Setup](docs/gemini.md) | Agent Skills |\n| Moltbot | âœ… Full Support | [Moltbot Setup](docs/moltbot.md) | Workspace/Local Skills |\n| Kiro | âœ… Full Support | [Kiro Setup](docs/kiro.md) | Steering Files |\n| Cursor | âœ… Full Support | [Cursor Setup](docs/cursor.md) | Skills |\n| Continue | âœ… Full Support | [Continue Setup](docs/continue.md) | Skills + Prompt files |\n| Kilocode | âœ… Full Support | [Kilocode Setup](docs/kilocode.md) | Skills |\n| OpenCode | âœ… Full Support | [OpenCode Setup](docs/opencode.md) | Personal/Project Skill |\n| Codex | âœ… Full Support | [Codex Setup](docs/codex.md) | Personal Skill |\n| FactoryAI Droid | âœ… Full Support | [Factory Setup](docs/factory.md) | Workspace/Personal Skill |\n| Antigravity | âœ… Full Support | [Antigravity Setup](docs/antigravity.md) | Workspace/Personal Skill |\n| CodeBuddy | âœ… Full Support | [CodeBuddy Setup](docs/codebuddy.md) | Workspace/Personal Skill |\n| AdaL CLI (Sylph AI) | âœ… Full Support | [AdaL Setup](docs/adal.md) | Personal/Project Skills |\n\n> **Note:** If your IDE uses the legacy Rules system instead of Skills, see the [`legacy-rules-support`](https://github.com/OthmanAdi/planning-with-files/tree/legacy-rules-support) branch.\n\n## Documentation\n\n| Document | Description |\n|----------|-------------|\n| [Installation Guide](docs/installation.md) | All installation methods (plugin, manual, Cursor, Windows) |\n| [Quick Start](docs/quickstart.md) | 5-step guide to using the pattern |\n| [Workflow Diagram](docs/workflow.md) | Visual diagram of how files and hooks interact |\n| [Troubleshooting](docs/troubleshooting.md) | Common issues and solutions |\n| [Gemini CLI Setup](docs/gemini.md) | Google Gemini CLI integration guide |\n| [Moltbot Setup](docs/moltbot.md) | Moltbot integration guide |\n| [Kiro Setup](docs/kiro.md) | Kiro steering files integration |\n| [Cursor Setup](docs/cursor.md) | Cursor IDE-specific instructions |\n| [Continue Setup](docs/continue.md) | Continue integration guide (skills + slash prompt) |\n| [Windows Setup](docs/windows.md) | Windows-specific notes |\n| [Kilo Code Support](docs/kilocode.md) | Kilo Code integration guide |\n| [Codex Setup](docs/codex.md) | Codex IDE installation and usage |\n| [OpenCode Setup](docs/opencode.md) | OpenCode IDE installation, oh-my-opencode config |\n| [FactoryAI Droid Setup](docs/factory.md) | FactoryAI Droid integration guide |\n| [Antigravity Setup](docs/antigravity.md) | Antigravity IDE integration guide |\n| [CodeBuddy Setup](docs/codebuddy.md) | CodeBuddy IDE integration guide |\n| [AdaL CLI Setup](docs/adal.md) | AdaL CLI / Sylph AI integration guide |\n\n## Versions\n\n| Version | Features | Install |\n|---------|----------|---------|\n| **v2.13.0** (current) | Moltbot rebrand (formerly Clawd CLI) | `claude plugins install OthmanAdi/planning-with-files` |\n| **v2.12.0** | AdaL CLI / Sylph AI support | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.11.0** | `/plan` command for easier autocomplete | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.10.0** | Kiro steering files support | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.9.0** | Moltbot (formerly Clawd CLI) support | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.8.0** | Continue IDE support, POSIX sh compatibility fix | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.7.1** | Dynamic Python detection fix | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.7.0** | Gemini CLI support | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.6.0** | Start command (`/planning-with-files:start`), path resolution fix | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.5.0** | Fixed autocomplete - SKILL.md matches Anthropic format | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.3.0** | Codex & OpenCode IDE support | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.2.2** | Restored skill activation language | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.2.1** | Session recovery after /clear, enhanced PreToolUse hook | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.2.0** | Kilo Code IDE support, Windows PowerShell support, OS-aware hooks | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.1.2** | Fix template cache issue (Issue #18) | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.1.0** | Claude Code v2.1 compatible, PostToolUse hook, user-invocable | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v2.0.x** | Hooks, templates, scripts | See [releases](https://github.com/OthmanAdi/planning-with-files/releases) |\n| **v1.0.0** (legacy) | Core 3-file pattern | `git clone -b legacy` |\n\nSee [CHANGELOG.md](CHANGELOG.md) for details.\n\n## Why This Skill?\n\nOn December 29, 2025, [Meta acquired Manus for $2 billion](https://techcrunch.com/2025/12/29/meta-just-bought-manus-an-ai-startup-everyone-has-been-talking-about/). In just 8 months, Manus went from launch to $100M+ revenue. Their secret? **Context engineering**.\n\n> \"Markdown is my 'working memory' on disk. Since I process information iteratively and my active context has limits, Markdown files serve as scratch pads for notes, checkpoints for progress, building blocks for final deliverables.\"\n> â€” Manus AI\n\n## The Problem\n\nClaude Code (and most AI agents) suffer from:\n\n- **Volatile memory** â€” TodoWrite tool disappears on context reset\n- **Goal drift** â€” After 50+ tool calls, original goals get forgotten\n- **Hidden errors** â€” Failures aren't tracked, so the same mistakes repeat\n- **Context stuffing** â€” Everything crammed into context instead of stored\n\n## The Solution: 3-File Pattern\n\nFor every complex task, create THREE files:\n\n```\ntask_plan.md      â†’ Track phases and progress\nfindings.md       â†’ Store research and findings\nprogress.md       â†’ Session log and test results\n```\n\n### The Core Principle\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## Usage\n\nOnce installed, Claude will automatically:\n\n1. **Create `task_plan.md`** before starting complex tasks\n2. **Re-read plan** before major decisions (via PreToolUse hook)\n3. **Remind you** to update status after file writes (via PostToolUse hook)\n4. **Store findings** in `findings.md` instead of stuffing context\n5. **Log errors** for future reference\n6. **Verify completion** before stopping (via Stop hook)\n\nOr invoke manually:\n- `/planning-with-files:plan` - Type `/plan` to find in autocomplete (v2.11.0+)\n- `/planning-with-files:start` - Type `/planning` to find in autocomplete\n- `/planning-with-files` - Only if you copied skills to `~/.claude/skills/`\n\nSee [docs/quickstart.md](docs/quickstart.md) for the full 5-step guide.\n\n## Session Recovery (NEW in v2.2.0)\n\nWhen your context window fills up and you run `/clear`, this skill automatically recovers unsynced work from your previous session.\n\n### Optimal Workflow\n\nFor the best experience, we recommend:\n\n1. **Disable auto-compact** in Claude Code settings (use full context window)\n2. **Start a fresh session** in your project\n3. **Run `/planning-with-files`** when ready to work on a complex task\n4. **Work until context fills up** (Claude will warn you)\n5. **Run `/clear`** to start fresh\n6. **Run `/planning-with-files`** again â€” it will automatically recover where you left off\n\n### How Recovery Works\n\nWhen you invoke `/planning-with-files`, the skill:\n\n1. Checks for previous session data (stored in `~/.claude/projects/`)\n2. Finds the last time planning files were updated\n3. Extracts conversation that happened after (potentially lost context)\n4. Shows a catchup report so you can sync planning files\n\nThis means even if context filled up before you could update your planning files, the skill will recover that context in your next session.\n\n### Disabling Auto-Compact\n\nTo use the full context window without automatic compaction:\n\n```bash\n# In your Claude Code settings or .claude/settings.json\n{\n  \"autoCompact\": false\n}\n```\n\nThis lets you maximize context usage before manually clearing with `/clear`.\n\n## Key Rules\n\n1. **Create Plan First** â€” Never start without `task_plan.md`\n2. **The 2-Action Rule** â€” Save findings after every 2 view/browser operations\n3. **Log ALL Errors** â€” They help avoid repetition\n4. **Never Repeat Failures** â€” Track attempts, mutate approach\n\n## File Structure\n\n```\nplanning-with-files/\nâ”œâ”€â”€ commands/                # Plugin commands\nâ”‚   â”œâ”€â”€ plan.md              # /planning-with-files:plan command (v2.11.0+)\nâ”‚   â””â”€â”€ start.md             # /planning-with-files:start command\nâ”œâ”€â”€ templates/               # Root-level templates (for CLAUDE_PLUGIN_ROOT)\nâ”œâ”€â”€ scripts/                 # Root-level scripts (for CLAUDE_PLUGIN_ROOT)\nâ”œâ”€â”€ docs/                    # Documentation\nâ”‚   â”œâ”€â”€ installation.md\nâ”‚   â”œâ”€â”€ quickstart.md\nâ”‚   â”œâ”€â”€ workflow.md\nâ”‚   â”œâ”€â”€ troubleshooting.md\nâ”‚   â”œâ”€â”€ gemini.md            # Gemini CLI setup\nâ”‚   â”œâ”€â”€ cursor.md\nâ”‚   â”œâ”€â”€ windows.md\nâ”‚   â”œâ”€â”€ kilocode.md\nâ”‚   â”œâ”€â”€ codex.md\nâ”‚   â””â”€â”€ opencode.md\nâ”œâ”€â”€ planning-with-files/     # Plugin skill folder\nâ”‚   â”œâ”€â”€ SKILL.md\nâ”‚   â”œâ”€â”€ templates/\nâ”‚   â””â”€â”€ scripts/\nâ”œâ”€â”€ skills/                  # Legacy skill folder\nâ”‚   â””â”€â”€ planning-with-files/\nâ”‚       â”œâ”€â”€ SKILL.md\nâ”‚       â”œâ”€â”€ examples.md\nâ”‚       â”œâ”€â”€ reference.md\nâ”‚       â”œâ”€â”€ templates/\nâ”‚       â””â”€â”€ scripts/\nâ”‚           â”œâ”€â”€ init-session.sh\nâ”‚           â”œâ”€â”€ check-complete.sh\nâ”‚           â”œâ”€â”€ init-session.ps1   # Windows PowerShell\nâ”‚           â””â”€â”€ check-complete.ps1 # Windows PowerShell\nâ”œâ”€â”€ .gemini/                 # Gemini CLI skills\nâ”‚   â””â”€â”€ skills/\nâ”‚       â””â”€â”€ planning-with-files/\nâ”œâ”€â”€ .codex/                  # Codex IDE skills\nâ”‚   â””â”€â”€ skills/\nâ”œâ”€â”€ .opencode/               # OpenCode IDE skills\nâ”‚   â””â”€â”€ skills/\nâ”œâ”€â”€ .claude-plugin/          # Plugin manifest\nâ”œâ”€â”€ .cursor/                 # Cursor skills\nâ”‚   â””â”€â”€ skills/\nâ”œâ”€â”€ .kilocode/               # Kilo Code skills\nâ”‚   â””â”€â”€ skills/\nâ”œâ”€â”€ .adal/                   # AdaL CLI / Sylph AI skills\nâ”‚   â””â”€â”€ skills/\nâ”œâ”€â”€ CHANGELOG.md\nâ”œâ”€â”€ LICENSE\nâ””â”€â”€ README.md\n```\n\n## The Manus Principles\n\n| Principle | Implementation |\n|-----------|----------------|\n| Filesystem as memory | Store in files, not context |\n| Attention manipulation | Re-read plan before decisions (hooks) |\n| Error persistence | Log failures in plan file |\n| Goal tracking | Checkboxes show progress |\n| Completion verification | Stop hook checks all phases |\n\n## When to Use\n\n**Use this pattern for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Kilo Code Support\n\nThis skill also supports Kilo Code AI through the `.kilocode/rules/` directory.\n\nThe [`.kilocode/rules/planning-with-files.md`](.kilocode/rules/planning-with-files.md) file contains all the planning guidelines formatted for Kilo Code's rules system, providing the same Manus-style planning workflow for Kilo Code users.\n\n**Windows users:** The skill now includes PowerShell scripts ([`init-session.ps1`](skills/planning-with-files/scripts/init-session.ps1) and [`check-complete.ps1`](skills/planning-with-files/scripts/check-complete.ps1)) for native Windows support.\n\nSee [docs/kilocode.md](docs/kilocode.md) for detailed Kilo Code integration guide.\n\n## Community Forks\n\n| Fork | Author | Features |\n|------|--------|----------|\n| [devis](https://github.com/st01cs/devis) | [@st01cs](https://github.com/st01cs) | Interview-first workflow, `/devis:intv` and `/devis:impl` commands, guaranteed activation |\n| [multi-manus-planning](https://github.com/kmichels/multi-manus-planning) | [@kmichels](https://github.com/kmichels) | Multi-project support, SessionStart git sync |\n\n*Built something? Open an issue to get listed!*\n\n## Acknowledgments\n\n- **Manus AI** â€” For pioneering context engineering patterns\n- **Anthropic** â€” For Claude Code, Agent Skills, and the Plugin system\n- **Lance Martin** â€” For the detailed Manus architecture analysis\n- Based on [Context Engineering for AI Agents](https://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus)\n\n## Contributing\n\nContributions welcome! Please:\n1. Fork the repository\n2. Create a feature branch\n3. Submit a pull request\n\n## License\n\nMIT License â€” feel free to use, modify, and distribute.\n\n---\n\n**Author:** [Ahmad Othman Ammar Adi](https://github.com/OthmanAdi)\n\n## Star History\n\n[![Star History Chart](https://api.star-history.com/svg?repos=OthmanAdi/planning-with-files&type=Date)](https://star-history.com/#OthmanAdi/planning-with-files&Date)\n",
        "commands/plan.md": "---\ndescription: \"Start Manus-style file-based planning. Creates task_plan.md, findings.md, progress.md for complex tasks.\"\n---\n\nInvoke the planning-with-files:planning-with-files skill and follow it exactly as presented to you.\n\nCreate the three planning files in the current project directory if they don't exist:\n- task_plan.md â€” for phases, progress, and decisions\n- findings.md â€” for research and discoveries\n- progress.md â€” for session logging\n\nThen guide the user through the planning workflow.\n",
        "commands/start.md": "---\ndescription: \"Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls. Now with automatic session recovery after /clear\"\ndisable-model-invocation: true\n---\n\nInvoke the planning-with-files:planning-with-files skill and follow it exactly as presented to you\n",
        "examples/README.md": "# Examples: Planning with Files in Action\n\nThis directory contains real-world examples showing how the 3-file planning pattern works in practice.\n\n## Example: Building a Todo App\n\nThis walkthrough demonstrates a complete task from start to finish, showing how `task_plan.md`, `findings.md`, and `progress.md` evolve together.\n\n### The Task\n\n**User Request:** \"Build a simple command-line todo app in Python that can add, list, and delete tasks.\"\n\n---\n\n## Phase 1: Initial Planning (Task Start)\n\n### task_plan.md (Initial State)\n\n```markdown\n# Task Plan: Build Command-Line Todo App\n\n## Goal\nCreate a Python CLI todo app with add, list, and delete functionality.\n\n## Current Phase\nPhase 1\n\n## Phases\n\n### Phase 1: Requirements & Discovery\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n\n### Phase 2: Planning & Structure\n- [ ] Define technical approach\n- [ ] Create project structure\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n- [ ] Write todo.py with core functions\n- [ ] Implement add functionality\n- [ ] Implement list functionality\n- [ ] Implement delete functionality\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n- [ ] Test add operation\n- [ ] Test list operation\n- [ ] Test delete operation\n- [ ] Verify error handling\n- **Status:** pending\n\n### Phase 5: Delivery\n- [ ] Review code quality\n- [ ] Ensure all features work\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n1. Should tasks persist between sessions? (Yes - need file storage)\n2. What format for storing tasks? (JSON file)\n3. Command-line interface style? (Simple argparse)\n\n## Decisions Made\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n```\n\n### findings.md (Initial State)\n\n```markdown\n# Findings & Decisions\n\n## Requirements\n- Command-line interface\n- Add tasks\n- List all tasks\n- Delete tasks\n- Python implementation\n- Tasks should persist (survive app restart)\n\n## Research Findings\n- (To be filled as we explore)\n\n## Technical Decisions\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n- Python argparse documentation (to be referenced)\n\n## Visual/Browser Findings\n- (To be updated after research)\n\n---\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n```\n\n### progress.md (Initial State)\n\n```markdown\n# Progress Log\n\n## Session: 2026-01-15\n\n### Phase 1: Requirements & Discovery\n- **Status:** in_progress\n- **Started:** 2026-01-15 10:00\n- Actions taken:\n  - Created task_plan.md\n  - Created findings.md\n  - Created progress.md\n- Files created/modified:\n  - task_plan.md (created)\n  - findings.md (created)\n  - progress.md (created)\n\n### Phase 2: Planning & Structure\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase 1 - Requirements & Discovery |\n| Where am I going? | Phase 2-5: Planning, Implementation, Testing, Delivery |\n| What's the goal? | Build Python CLI todo app with add/list/delete |\n| What have I learned? | See findings.md |\n| What have I done? | Created planning files |\n\n---\n*Update after completing each phase or encountering errors*\n```\n\n---\n\n## Phase 2: After Research & Planning\n\n### task_plan.md (Updated)\n\n```markdown\n# Task Plan: Build Command-Line Todo App\n\n## Goal\nCreate a Python CLI todo app with add, list, and delete functionality.\n\n## Current Phase\nPhase 2\n\n## Phases\n\n### Phase 1: Requirements & Discovery\n- [x] Understand user intent âœ“\n- [x] Identify constraints and requirements âœ“\n- [x] Document findings in findings.md âœ“\n- **Status:** complete\n\n### Phase 2: Planning & Structure\n- [x] Define technical approach âœ“\n- [x] Create project structure âœ“\n- [x] Document decisions with rationale âœ“\n- **Status:** complete\n\n### Phase 3: Implementation\n- [ ] Write todo.py with core functions\n- [ ] Implement add functionality\n- [ ] Implement list functionality\n- [ ] Implement delete functionality\n- **Status:** in_progress\n\n### Phase 4: Testing & Verification\n- [ ] Test add operation\n- [ ] Test list operation\n- [ ] Test delete operation\n- [ ] Verify error handling\n- **Status:** pending\n\n### Phase 5: Delivery\n- [ ] Review code quality\n- [ ] Ensure all features work\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n1. Should tasks persist between sessions? âœ“ Yes - using JSON file\n2. What format for storing tasks? âœ“ JSON file (todos.json)\n3. Command-line interface style? âœ“ argparse with subcommands\n\n## Decisions Made\n| Decision | Rationale |\n|----------|-----------|\n| Use JSON for storage | Simple, human-readable, built-in Python support |\n| argparse with subcommands | Clean CLI: `python todo.py add \"task\"`, `python todo.py list` |\n| Store in todos.json | Standard location, easy to find and debug |\n\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n```\n\n### findings.md (Updated)\n\n```markdown\n# Findings & Decisions\n\n## Requirements\n- Command-line interface\n- Add tasks\n- List all tasks\n- Delete tasks\n- Python implementation\n- Tasks should persist (survive app restart)\n\n## Research Findings\n- Python's `argparse` module is perfect for CLI subcommands\n- `json` module handles file persistence easily\n- Standard pattern: `python todo.py <command> [args]`\n- File structure: Single `todo.py` file is sufficient for this scope\n\n## Technical Decisions\n| Decision | Rationale |\n|----------|-----------|\n| Use JSON for storage | Simple, human-readable, built-in Python support |\n| argparse with subcommands | Clean CLI: `python todo.py add \"task\"`, `python todo.py list` |\n| Store in todos.json | Standard location, easy to find and debug |\n| Single file structure | Simple enough for one file, can refactor later if needed |\n\n## Issues Encountered\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n- Python argparse documentation: https://docs.python.org/3/library/argparse.html\n- Python json module: https://docs.python.org/3/library/json.html\n\n## Visual/Browser Findings\n- Reviewed argparse examples - subcommand pattern is straightforward\n- JSON file format: array of objects with `id` and `task` fields\n\n---\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n```\n\n### progress.md (Updated)\n\n```markdown\n# Progress Log\n\n## Session: 2026-01-15\n\n### Phase 1: Requirements & Discovery\n- **Status:** complete\n- **Started:** 2026-01-15 10:00\n- **Completed:** 2026-01-15 10:15\n- Actions taken:\n  - Created task_plan.md\n  - Created findings.md\n  - Created progress.md\n  - Researched Python CLI patterns\n  - Decided on JSON storage\n- Files created/modified:\n  - task_plan.md (created, updated)\n  - findings.md (created, updated)\n  - progress.md (created)\n\n### Phase 2: Planning & Structure\n- **Status:** complete\n- **Started:** 2026-01-15 10:15\n- **Completed:** 2026-01-15 10:20\n- Actions taken:\n  - Defined technical approach (argparse + JSON)\n  - Documented decisions in findings.md\n  - Updated task_plan.md with decisions\n- Files created/modified:\n  - task_plan.md (updated)\n  - findings.md (updated)\n\n### Phase 3: Implementation\n- **Status:** in_progress\n- **Started:** 2026-01-15 10:20\n- Actions taken:\n  - Starting to write todo.py\n- Files created/modified:\n  - (todo.py will be created)\n\n## Test Results\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase 3 - Implementation |\n| Where am I going? | Phase 4-5: Testing, Delivery |\n| What's the goal? | Build Python CLI todo app with add/list/delete |\n| What have I learned? | argparse subcommands, JSON storage pattern (see findings.md) |\n| What have I done? | Completed planning, starting implementation |\n\n---\n*Update after completing each phase or encountering errors*\n```\n\n---\n\n## Phase 3: During Implementation (With Error)\n\n### task_plan.md (After Error Encountered)\n\n```markdown\n# Task Plan: Build Command-Line Todo App\n\n## Goal\nCreate a Python CLI todo app with add, list, and delete functionality.\n\n## Current Phase\nPhase 3\n\n## Phases\n\n### Phase 1: Requirements & Discovery\n- [x] Understand user intent âœ“\n- [x] Identify constraints and requirements âœ“\n- [x] Document findings in findings.md âœ“\n- **Status:** complete\n\n### Phase 2: Planning & Structure\n- [x] Define technical approach âœ“\n- [x] Create project structure âœ“\n- [x] Document decisions with rationale âœ“\n- **Status:** complete\n\n### Phase 3: Implementation\n- [x] Write todo.py with core functions âœ“\n- [x] Implement add functionality âœ“\n- [ ] Implement list functionality (CURRENT)\n- [ ] Implement delete functionality\n- **Status:** in_progress\n\n### Phase 4: Testing & Verification\n- [ ] Test add operation\n- [ ] Test list operation\n- [ ] Test delete operation\n- [ ] Verify error handling\n- **Status:** pending\n\n### Phase 5: Delivery\n- [ ] Review code quality\n- [ ] Ensure all features work\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n1. Should tasks persist between sessions? âœ“ Yes - using JSON file\n2. What format for storing tasks? âœ“ JSON file (todos.json)\n3. Command-line interface style? âœ“ argparse with subcommands\n\n## Decisions Made\n| Decision | Rationale |\n|----------|-----------|\n| Use JSON for storage | Simple, human-readable, built-in Python support |\n| argparse with subcommands | Clean CLI: `python todo.py add \"task\"`, `python todo.py list` |\n| Store in todos.json | Standard location, easy to find and debug |\n| Use incremental IDs | Simple counter, easier than UUIDs for this use case |\n\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError when reading todos.json | 1 | Check if file exists, create empty list if not |\n| JSONDecodeError on empty file | 2 | Handle empty file case explicitly |\n\n## Notes\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n```\n\n### progress.md (With Error Logged)\n\n```markdown\n# Progress Log\n\n## Session: 2026-01-15\n\n### Phase 1: Requirements & Discovery\n- **Status:** complete\n- **Started:** 2026-01-15 10:00\n- **Completed:** 2026-01-15 10:15\n- Actions taken:\n  - Created task_plan.md\n  - Created findings.md\n  - Created progress.md\n  - Researched Python CLI patterns\n  - Decided on JSON storage\n- Files created/modified:\n  - task_plan.md (created, updated)\n  - findings.md (created, updated)\n  - progress.md (created)\n\n### Phase 2: Planning & Structure\n- **Status:** complete\n- **Started:** 2026-01-15 10:15\n- **Completed:** 2026-01-15 10:20\n- Actions taken:\n  - Defined technical approach (argparse + JSON)\n  - Documented decisions in findings.md\n  - Updated task_plan.md with decisions\n- Files created/modified:\n  - task_plan.md (updated)\n  - findings.md (updated)\n\n### Phase 3: Implementation\n- **Status:** in_progress\n- **Started:** 2026-01-15 10:20\n- Actions taken:\n  - Created todo.py with basic structure\n  - Implemented add functionality\n  - Encountered FileNotFoundError (handled)\n  - Encountered JSONDecodeError on empty file (handled)\n  - Working on list functionality\n- Files created/modified:\n  - todo.py (created, modified)\n  - todos.json (created by app)\n\n## Test Results\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n| Add task | `python todo.py add \"Buy milk\"` | Task added to todos.json | Task added successfully | âœ“ |\n| List tasks | `python todo.py list` | Shows all tasks | FileNotFoundError (fixed) | Fixed |\n\n## Error Log\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n| 2026-01-15 10:35 | FileNotFoundError when reading todos.json | 1 | Added file existence check, create empty list if not exists |\n| 2026-01-15 10:37 | JSONDecodeError on empty file | 2 | Added explicit empty file handling before json.load() |\n\n## 5-Question Reboot Check\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase 3 - Implementation (working on list functionality) |\n| Where am I going? | Phase 4-5: Testing, Delivery |\n| What's the goal? | Build Python CLI todo app with add/list/delete |\n| What have I learned? | Need to handle file not existing, empty file edge cases (see findings.md) |\n| What have I done? | Completed add functionality, fixed file handling errors, working on list |\n\n---\n*Update after completing each phase or encountering errors*\n```\n\n---\n\n## Phase 4: Task Complete\n\n### task_plan.md (Final State)\n\n```markdown\n# Task Plan: Build Command-Line Todo App\n\n## Goal\nCreate a Python CLI todo app with add, list, and delete functionality.\n\n## Current Phase\nPhase 5 (Complete)\n\n## Phases\n\n### Phase 1: Requirements & Discovery\n- [x] Understand user intent âœ“\n- [x] Identify constraints and requirements âœ“\n- [x] Document findings in findings.md âœ“\n- **Status:** complete\n\n### Phase 2: Planning & Structure\n- [x] Define technical approach âœ“\n- [x] Create project structure âœ“\n- [x] Document decisions with rationale âœ“\n- **Status:** complete\n\n### Phase 3: Implementation\n- [x] Write todo.py with core functions âœ“\n- [x] Implement add functionality âœ“\n- [x] Implement list functionality âœ“\n- [x] Implement delete functionality âœ“\n- **Status:** complete\n\n### Phase 4: Testing & Verification\n- [x] Test add operation âœ“\n- [x] Test list operation âœ“\n- [x] Test delete operation âœ“\n- [x] Verify error handling âœ“\n- **Status:** complete\n\n### Phase 5: Delivery\n- [x] Review code quality âœ“\n- [x] Ensure all features work âœ“\n- [x] Deliver to user âœ“\n- **Status:** complete\n\n## Key Questions\n1. Should tasks persist between sessions? âœ“ Yes - using JSON file\n2. What format for storing tasks? âœ“ JSON file (todos.json)\n3. Command-line interface style? âœ“ argparse with subcommands\n\n## Decisions Made\n| Decision | Rationale |\n|----------|-----------|\n| Use JSON for storage | Simple, human-readable, built-in Python support |\n| argparse with subcommands | Clean CLI: `python todo.py add \"task\"`, `python todo.py list` |\n| Store in todos.json | Standard location, easy to find and debug |\n| Use incremental IDs | Simple counter, easier than UUIDs for this use case |\n\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError when reading todos.json | 1 | Check if file exists, create empty list if not |\n| JSONDecodeError on empty file | 2 | Handle empty file case explicitly |\n\n## Notes\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n```\n\n---\n\n## Key Takeaways\n\n### How Files Work Together\n\n1. **task_plan.md** = Your roadmap\n   - Created first, before any work begins\n   - Updated after each phase completes\n   - Re-read before major decisions (automatic via hooks)\n   - Tracks what's done, what's next, what went wrong\n\n2. **findings.md** = Your knowledge base\n   - Captures research and discoveries\n   - Stores technical decisions with rationale\n   - Updated after every 2 view/browser operations (2-Action Rule)\n   - Prevents losing important information\n\n3. **progress.md** = Your session log\n   - Records what you did and when\n   - Tracks test results\n   - Logs ALL errors (even ones you fixed)\n   - Answers the \"5-Question Reboot Test\"\n\n### The Workflow Pattern\n\n```\nSTART TASK\n  â†“\nCreate task_plan.md (NEVER skip this!)\n  â†“\nCreate findings.md\n  â†“\nCreate progress.md\n  â†“\n[Work on task]\n  â†“\nUpdate files as you go:\n  - task_plan.md: Mark phases complete, log errors\n  - findings.md: Save discoveries (especially after 2 view/browser ops)\n  - progress.md: Log actions, tests, errors\n  â†“\nRe-read task_plan.md before major decisions\n  â†“\nCOMPLETE TASK\n```\n\n### Common Patterns\n\n- **Error occurs?** â†’ Log it in `task_plan.md` AND `progress.md`\n- **Made a decision?** â†’ Document in `findings.md` with rationale\n- **Viewed 2 things?** â†’ Save findings to `findings.md` immediately\n- **Starting new phase?** â†’ Update status in `task_plan.md` and `progress.md`\n- **Uncertain what to do?** â†’ Re-read `task_plan.md` to refresh goals\n\n---\n\n## More Examples\n\nWant to see more examples? Check out:\n- [examples.md](../skills/planning-with-files/examples.md) - Additional patterns and use cases\n\n---\n\n*Want to contribute an example? Open a PR!*\n",
        "skills/planning-with-files/SKILL.md": "---\nname: planning-with-files\nversion: \"2.10.0\"\ndescription: Implements Manus-style file-based planning for complex tasks. Creates task_plan.md, findings.md, and progress.md. Use when starting complex multi-step tasks, research projects, or any task requiring >5 tool calls. Now with automatic session recovery after /clear.\nuser-invocable: true\nallowed-tools:\n  - Read\n  - Write\n  - Edit\n  - Bash\n  - Glob\n  - Grep\n  - WebFetch\n  - WebSearch\nhooks:\n  PreToolUse:\n    - matcher: \"Write|Edit|Bash|Read|Glob|Grep\"\n      hooks:\n        - type: command\n          command: \"cat task_plan.md 2>/dev/null | head -30 || true\"\n  PostToolUse:\n    - matcher: \"Write|Edit\"\n      hooks:\n        - type: command\n          command: \"echo '[planning-with-files] File updated. If this completes a phase, update task_plan.md status.'\"\n  Stop:\n    - hooks:\n        - type: command\n          command: |\n            SCRIPT_DIR=\"${CLAUDE_PLUGIN_ROOT:-$HOME/.claude/plugins/planning-with-files}/scripts\"\n\n            IS_WINDOWS=0\n            if [ \"${OS-}\" = \"Windows_NT\" ]; then\n              IS_WINDOWS=1\n            else\n              UNAME_S=\"$(uname -s 2>/dev/null || echo '')\"\n              case \"$UNAME_S\" in\n                CYGWIN*|MINGW*|MSYS*) IS_WINDOWS=1 ;;\n              esac\n            fi\n\n            if [ \"$IS_WINDOWS\" -eq 1 ]; then\n              if command -v pwsh >/dev/null 2>&1; then\n                pwsh -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              else\n                powershell -ExecutionPolicy Bypass -File \"$SCRIPT_DIR/check-complete.ps1\" 2>/dev/null ||\n                sh \"$SCRIPT_DIR/check-complete.sh\"\n              fi\n            else\n              sh \"$SCRIPT_DIR/check-complete.sh\"\n            fi\n---\n\n# Planning with Files\n\nWork like Manus: Use persistent markdown files as your \"working memory on disk.\"\n\n## FIRST: Check for Previous Session (v2.2.0)\n\n**Before starting work**, check for unsynced context from a previous session:\n\n```bash\n# Linux/macOS\n$(command -v python3 || command -v python) ${CLAUDE_PLUGIN_ROOT}/scripts/session-catchup.py \"$(pwd)\"\n```\n\n```powershell\n# Windows PowerShell\n& (Get-Command python -ErrorAction SilentlyContinue).Source \"$env:USERPROFILE\\.claude\\skills\\planning-with-files\\scripts\\session-catchup.py\" (Get-Location)\n```\n\nIf catchup report shows unsynced context:\n1. Run `git diff --stat` to see actual code changes\n2. Read current planning files\n3. Update planning files based on catchup + git diff\n4. Then proceed with task\n\n## Important: Where Files Go\n\n- **Templates** are in `${CLAUDE_PLUGIN_ROOT}/templates/`\n- **Your planning files** go in **your project directory**\n\n| Location | What Goes There |\n|----------|-----------------|\n| Skill directory (`${CLAUDE_PLUGIN_ROOT}/`) | Templates, scripts, reference docs |\n| Your project directory | `task_plan.md`, `findings.md`, `progress.md` |\n\n## Quick Start\n\nBefore ANY complex task:\n\n1. **Create `task_plan.md`** â€” Use [templates/task_plan.md](templates/task_plan.md) as reference\n2. **Create `findings.md`** â€” Use [templates/findings.md](templates/findings.md) as reference\n3. **Create `progress.md`** â€” Use [templates/progress.md](templates/progress.md) as reference\n4. **Re-read plan before decisions** â€” Refreshes goals in attention window\n5. **Update after each phase** â€” Mark complete, log errors\n\n> **Note:** Planning files go in your project root, not the skill installation folder.\n\n## The Core Pattern\n\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n\nâ†’ Anything important gets written to disk.\n```\n\n## File Purposes\n\n| File | Purpose | When to Update |\n|------|---------|----------------|\n| `task_plan.md` | Phases, progress, decisions | After each phase |\n| `findings.md` | Research, discoveries | After ANY discovery |\n| `progress.md` | Session log, test results | Throughout session |\n\n## Critical Rules\n\n### 1. Create Plan First\nNever start a complex task without `task_plan.md`. Non-negotiable.\n\n### 2. The 2-Action Rule\n> \"After every 2 view/browser/search operations, IMMEDIATELY save key findings to text files.\"\n\nThis prevents visual/multimodal information from being lost.\n\n### 3. Read Before Decide\nBefore major decisions, read the plan file. This keeps goals in your attention window.\n\n### 4. Update After Act\nAfter completing any phase:\n- Mark phase status: `in_progress` â†’ `complete`\n- Log any errors encountered\n- Note files created/modified\n\n### 5. Log ALL Errors\nEvery error goes in the plan file. This builds knowledge and prevents repetition.\n\n```markdown\n## Errors Encountered\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n| FileNotFoundError | 1 | Created default config |\n| API timeout | 2 | Added retry logic |\n```\n\n### 6. Never Repeat Failures\n```\nif action_failed:\n    next_action != same_action\n```\nTrack what you tried. Mutate the approach.\n\n## The 3-Strike Error Protocol\n\n```\nATTEMPT 1: Diagnose & Fix\n  â†’ Read error carefully\n  â†’ Identify root cause\n  â†’ Apply targeted fix\n\nATTEMPT 2: Alternative Approach\n  â†’ Same error? Try different method\n  â†’ Different tool? Different library?\n  â†’ NEVER repeat exact same failing action\n\nATTEMPT 3: Broader Rethink\n  â†’ Question assumptions\n  â†’ Search for solutions\n  â†’ Consider updating the plan\n\nAFTER 3 FAILURES: Escalate to User\n  â†’ Explain what you tried\n  â†’ Share the specific error\n  â†’ Ask for guidance\n```\n\n## Read vs Write Decision Matrix\n\n| Situation | Action | Reason |\n|-----------|--------|--------|\n| Just wrote a file | DON'T read | Content still in context |\n| Viewed image/PDF | Write findings NOW | Multimodal â†’ text before lost |\n| Browser returned data | Write to file | Screenshots don't persist |\n| Starting new phase | Read plan/findings | Re-orient if context stale |\n| Error occurred | Read relevant file | Need current state to fix |\n| Resuming after gap | Read all planning files | Recover state |\n\n## The 5-Question Reboot Test\n\nIf you can answer these, your context management is solid:\n\n| Question | Answer Source |\n|----------|---------------|\n| Where am I? | Current phase in task_plan.md |\n| Where am I going? | Remaining phases |\n| What's the goal? | Goal statement in plan |\n| What have I learned? | findings.md |\n| What have I done? | progress.md |\n\n## When to Use This Pattern\n\n**Use for:**\n- Multi-step tasks (3+ steps)\n- Research tasks\n- Building/creating projects\n- Tasks spanning many tool calls\n- Anything requiring organization\n\n**Skip for:**\n- Simple questions\n- Single-file edits\n- Quick lookups\n\n## Templates\n\nCopy these templates to start:\n\n- [templates/task_plan.md](templates/task_plan.md) â€” Phase tracking\n- [templates/findings.md](templates/findings.md) â€” Research storage\n- [templates/progress.md](templates/progress.md) â€” Session logging\n\n## Scripts\n\nHelper scripts for automation:\n\n- `scripts/init-session.sh` â€” Initialize all planning files\n- `scripts/check-complete.sh` â€” Verify all phases complete\n- `scripts/session-catchup.py` â€” Recover context from previous session (v2.2.0)\n\n## Advanced Topics\n\n- **Manus Principles:** See [reference.md](reference.md)\n- **Real Examples:** See [examples.md](examples.md)\n\n## Anti-Patterns\n\n| Don't | Do Instead |\n|-------|------------|\n| Use TodoWrite for persistence | Create task_plan.md file |\n| State goals once and forget | Re-read plan before decisions |\n| Hide errors and retry silently | Log errors to plan file |\n| Stuff everything in context | Store large content in files |\n| Start executing immediately | Create plan file FIRST |\n| Repeat failed actions | Track attempts, mutate approach |\n| Create files in skill directory | Create files in your project |\n",
        "skills/planning-with-files/examples.md": "# Examples: Planning with Files in Action\n\n## Example 1: Research Task\n\n**User Request:** \"Research the benefits of morning exercise and write a summary\"\n\n### Loop 1: Create Plan\n```bash\nWrite task_plan.md\n```\n\n```markdown\n# Task Plan: Morning Exercise Benefits Research\n\n## Goal\nCreate a research summary on the benefits of morning exercise.\n\n## Phases\n- [ ] Phase 1: Create this plan âœ“\n- [ ] Phase 2: Search and gather sources\n- [ ] Phase 3: Synthesize findings\n- [ ] Phase 4: Deliver summary\n\n## Key Questions\n1. What are the physical health benefits?\n2. What are the mental health benefits?\n3. What scientific studies support this?\n\n## Status\n**Currently in Phase 1** - Creating plan\n```\n\n### Loop 2: Research\n```bash\nRead task_plan.md           # Refresh goals\nWebSearch \"morning exercise benefits\"\nWrite notes.md              # Store findings\nEdit task_plan.md           # Mark Phase 2 complete\n```\n\n### Loop 3: Synthesize\n```bash\nRead task_plan.md           # Refresh goals\nRead notes.md               # Get findings\nWrite morning_exercise_summary.md\nEdit task_plan.md           # Mark Phase 3 complete\n```\n\n### Loop 4: Deliver\n```bash\nRead task_plan.md           # Verify complete\nDeliver morning_exercise_summary.md\n```\n\n---\n\n## Example 2: Bug Fix Task\n\n**User Request:** \"Fix the login bug in the authentication module\"\n\n### task_plan.md\n```markdown\n# Task Plan: Fix Login Bug\n\n## Goal\nIdentify and fix the bug preventing successful login.\n\n## Phases\n- [x] Phase 1: Understand the bug report âœ“\n- [x] Phase 2: Locate relevant code âœ“\n- [ ] Phase 3: Identify root cause (CURRENT)\n- [ ] Phase 4: Implement fix\n- [ ] Phase 5: Test and verify\n\n## Key Questions\n1. What error message appears?\n2. Which file handles authentication?\n3. What changed recently?\n\n## Decisions Made\n- Auth handler is in src/auth/login.ts\n- Error occurs in validateToken() function\n\n## Errors Encountered\n- [Initial] TypeError: Cannot read property 'token' of undefined\n  â†’ Root cause: user object not awaited properly\n\n## Status\n**Currently in Phase 3** - Found root cause, preparing fix\n```\n\n---\n\n## Example 3: Feature Development\n\n**User Request:** \"Add a dark mode toggle to the settings page\"\n\n### The 3-File Pattern in Action\n\n**task_plan.md:**\n```markdown\n# Task Plan: Dark Mode Toggle\n\n## Goal\nAdd functional dark mode toggle to settings.\n\n## Phases\n- [x] Phase 1: Research existing theme system âœ“\n- [x] Phase 2: Design implementation approach âœ“\n- [ ] Phase 3: Implement toggle component (CURRENT)\n- [ ] Phase 4: Add theme switching logic\n- [ ] Phase 5: Test and polish\n\n## Decisions Made\n- Using CSS custom properties for theme\n- Storing preference in localStorage\n- Toggle component in SettingsPage.tsx\n\n## Status\n**Currently in Phase 3** - Building toggle component\n```\n\n**notes.md:**\n```markdown\n# Notes: Dark Mode Implementation\n\n## Existing Theme System\n- Located in: src/styles/theme.ts\n- Uses: CSS custom properties\n- Current themes: light only\n\n## Files to Modify\n1. src/styles/theme.ts - Add dark theme colors\n2. src/components/SettingsPage.tsx - Add toggle\n3. src/hooks/useTheme.ts - Create new hook\n4. src/App.tsx - Wrap with ThemeProvider\n\n## Color Decisions\n- Dark background: #1a1a2e\n- Dark surface: #16213e\n- Dark text: #eaeaea\n```\n\n**dark_mode_implementation.md:** (deliverable)\n```markdown\n# Dark Mode Implementation\n\n## Changes Made\n\n### 1. Added dark theme colors\nFile: src/styles/theme.ts\n...\n\n### 2. Created useTheme hook\nFile: src/hooks/useTheme.ts\n...\n```\n\n---\n\n## Example 4: Error Recovery Pattern\n\nWhen something fails, DON'T hide it:\n\n### Before (Wrong)\n```\nAction: Read config.json\nError: File not found\nAction: Read config.json  # Silent retry\nAction: Read config.json  # Another retry\n```\n\n### After (Correct)\n```\nAction: Read config.json\nError: File not found\n\n# Update task_plan.md:\n## Errors Encountered\n- config.json not found â†’ Will create default config\n\nAction: Write config.json (default config)\nAction: Read config.json\nSuccess!\n```\n\n---\n\n## The Read-Before-Decide Pattern\n\n**Always read your plan before major decisions:**\n\n```\n[Many tool calls have happened...]\n[Context is getting long...]\n[Original goal might be forgotten...]\n\nâ†’ Read task_plan.md          # This brings goals back into attention!\nâ†’ Now make the decision       # Goals are fresh in context\n```\n\nThis is why Manus can handle ~50 tool calls without losing track. The plan file acts as a \"goal refresh\" mechanism.\n",
        "skills/planning-with-files/reference.md": "# Reference: Manus Context Engineering Principles\n\nThis skill is based on context engineering principles from Manus, the AI agent company acquired by Meta for $2 billion in December 2025.\n\n## The 6 Manus Principles\n\n### Principle 1: Design Around KV-Cache\n\n> \"KV-cache hit rate is THE single most important metric for production AI agents.\"\n\n**Statistics:**\n- ~100:1 input-to-output token ratio\n- Cached tokens: $0.30/MTok vs Uncached: $3/MTok\n- 10x cost difference!\n\n**Implementation:**\n- Keep prompt prefixes STABLE (single-token change invalidates cache)\n- NO timestamps in system prompts\n- Make context APPEND-ONLY with deterministic serialization\n\n### Principle 2: Mask, Don't Remove\n\nDon't dynamically remove tools (breaks KV-cache). Use logit masking instead.\n\n**Best Practice:** Use consistent action prefixes (e.g., `browser_`, `shell_`, `file_`) for easier masking.\n\n### Principle 3: Filesystem as External Memory\n\n> \"Markdown is my 'working memory' on disk.\"\n\n**The Formula:**\n```\nContext Window = RAM (volatile, limited)\nFilesystem = Disk (persistent, unlimited)\n```\n\n**Compression Must Be Restorable:**\n- Keep URLs even if web content is dropped\n- Keep file paths when dropping document contents\n- Never lose the pointer to full data\n\n### Principle 4: Manipulate Attention Through Recitation\n\n> \"Creates and updates todo.md throughout tasks to push global plan into model's recent attention span.\"\n\n**Problem:** After ~50 tool calls, models forget original goals (\"lost in the middle\" effect).\n\n**Solution:** Re-read `task_plan.md` before each decision. Goals appear in the attention window.\n\n```\nStart of context: [Original goal - far away, forgotten]\n...many tool calls...\nEnd of context: [Recently read task_plan.md - gets ATTENTION!]\n```\n\n### Principle 5: Keep the Wrong Stuff In\n\n> \"Leave the wrong turns in the context.\"\n\n**Why:**\n- Failed actions with stack traces let model implicitly update beliefs\n- Reduces mistake repetition\n- Error recovery is \"one of the clearest signals of TRUE agentic behavior\"\n\n### Principle 6: Don't Get Few-Shotted\n\n> \"Uniformity breeds fragility.\"\n\n**Problem:** Repetitive action-observation pairs cause drift and hallucination.\n\n**Solution:** Introduce controlled variation:\n- Vary phrasings slightly\n- Don't copy-paste patterns blindly\n- Recalibrate on repetitive tasks\n\n---\n\n## The 3 Context Engineering Strategies\n\nBased on Lance Martin's analysis of Manus architecture.\n\n### Strategy 1: Context Reduction\n\n**Compaction:**\n```\nTool calls have TWO representations:\nâ”œâ”€â”€ FULL: Raw tool content (stored in filesystem)\nâ””â”€â”€ COMPACT: Reference/file path only\n\nRULES:\n- Apply compaction to STALE (older) tool results\n- Keep RECENT results FULL (to guide next decision)\n```\n\n**Summarization:**\n- Applied when compaction reaches diminishing returns\n- Generated using full tool results\n- Creates standardized summary objects\n\n### Strategy 2: Context Isolation (Multi-Agent)\n\n**Architecture:**\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚         PLANNER AGENT           â”‚\nâ”‚  â””â”€ Assigns tasks to sub-agents â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚       KNOWLEDGE MANAGER         â”‚\nâ”‚  â””â”€ Reviews conversations       â”‚\nâ”‚  â””â”€ Determines filesystem store â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚      EXECUTOR SUB-AGENTS        â”‚\nâ”‚  â””â”€ Perform assigned tasks      â”‚\nâ”‚  â””â”€ Have own context windows    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Key Insight:** Manus originally used `todo.md` for task planning but found ~33% of actions were spent updating it. Shifted to dedicated planner agent calling executor sub-agents.\n\n### Strategy 3: Context Offloading\n\n**Tool Design:**\n- Use <20 atomic functions total\n- Store full results in filesystem, not context\n- Use `glob` and `grep` for searching\n- Progressive disclosure: load information only as needed\n\n---\n\n## The Agent Loop\n\nManus operates in a continuous 7-step loop:\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  1. ANALYZE CONTEXT                      â”‚\nâ”‚     - Understand user intent             â”‚\nâ”‚     - Assess current state               â”‚\nâ”‚     - Review recent observations         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  2. THINK                                â”‚\nâ”‚     - Should I update the plan?          â”‚\nâ”‚     - What's the next logical action?    â”‚\nâ”‚     - Are there blockers?                â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  3. SELECT TOOL                          â”‚\nâ”‚     - Choose ONE tool                    â”‚\nâ”‚     - Ensure parameters available        â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  4. EXECUTE ACTION                       â”‚\nâ”‚     - Tool runs in sandbox               â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  5. RECEIVE OBSERVATION                  â”‚\nâ”‚     - Result appended to context         â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  6. ITERATE                              â”‚\nâ”‚     - Return to step 1                   â”‚\nâ”‚     - Continue until complete            â”‚\nâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\nâ”‚  7. DELIVER OUTCOME                      â”‚\nâ”‚     - Send results to user               â”‚\nâ”‚     - Attach all relevant files          â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n---\n\n## File Types Manus Creates\n\n| File | Purpose | When Created | When Updated |\n|------|---------|--------------|--------------|\n| `task_plan.md` | Phase tracking, progress | Task start | After completing phases |\n| `findings.md` | Discoveries, decisions | After ANY discovery | After viewing images/PDFs |\n| `progress.md` | Session log, what's done | At breakpoints | Throughout session |\n| Code files | Implementation | Before execution | After errors |\n\n---\n\n## Critical Constraints\n\n- **Single-Action Execution:** ONE tool call per turn. No parallel execution.\n- **Plan is Required:** Agent must ALWAYS know: goal, current phase, remaining phases\n- **Files are Memory:** Context = volatile. Filesystem = persistent.\n- **Never Repeat Failures:** If action failed, next action MUST be different\n- **Communication is a Tool:** Message types: `info` (progress), `ask` (blocking), `result` (terminal)\n\n---\n\n## Manus Statistics\n\n| Metric | Value |\n|--------|-------|\n| Average tool calls per task | ~50 |\n| Input-to-output token ratio | 100:1 |\n| Acquisition price | $2 billion |\n| Time to $100M revenue | 8 months |\n| Framework refactors since launch | 5 times |\n\n---\n\n## Key Quotes\n\n> \"Context window = RAM (volatile, limited). Filesystem = Disk (persistent, unlimited). Anything important gets written to disk.\"\n\n> \"if action_failed: next_action != same_action. Track what you tried. Mutate the approach.\"\n\n> \"Error recovery is one of the clearest signals of TRUE agentic behavior.\"\n\n> \"KV-cache hit rate is the single most important metric for a production-stage AI agent.\"\n\n> \"Leave the wrong turns in the context.\"\n\n---\n\n## Source\n\nBased on Manus's official context engineering documentation:\nhttps://manus.im/blog/Context-Engineering-for-AI-Agents-Lessons-from-Building-Manus\n",
        "skills/planning-with-files/templates/findings.md": "# Findings & Decisions\n<!-- \n  WHAT: Your knowledge base for the task. Stores everything you discover and decide.\n  WHY: Context windows are limited. This file is your \"external memory\" - persistent and unlimited.\n  WHEN: Update after ANY discovery, especially after 2 view/browser/search operations (2-Action Rule).\n-->\n\n## Requirements\n<!-- \n  WHAT: What the user asked for, broken down into specific requirements.\n  WHY: Keeps requirements visible so you don't forget what you're building.\n  WHEN: Fill this in during Phase 1 (Requirements & Discovery).\n  EXAMPLE:\n    - Command-line interface\n    - Add tasks\n    - List all tasks\n    - Delete tasks\n    - Python implementation\n-->\n<!-- Captured from user request -->\n-\n\n## Research Findings\n<!-- \n  WHAT: Key discoveries from web searches, documentation reading, or exploration.\n  WHY: Multimodal content (images, browser results) doesn't persist. Write it down immediately.\n  WHEN: After EVERY 2 view/browser/search operations, update this section (2-Action Rule).\n  EXAMPLE:\n    - Python's argparse module supports subcommands for clean CLI design\n    - JSON module handles file persistence easily\n    - Standard pattern: python script.py <command> [args]\n-->\n<!-- Key discoveries during exploration -->\n-\n\n## Technical Decisions\n<!-- \n  WHAT: Architecture and implementation choices you've made, with reasoning.\n  WHY: You'll forget why you chose a technology or approach. This table preserves that knowledge.\n  WHEN: Update whenever you make a significant technical choice.\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n    | argparse with subcommands | Clean CLI: python todo.py add \"task\" |\n-->\n<!-- Decisions made with rationale -->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Issues Encountered\n<!-- \n  WHAT: Problems you ran into and how you solved them.\n  WHY: Similar to errors in task_plan.md, but focused on broader issues (not just code errors).\n  WHEN: Document when you encounter blockers or unexpected challenges.\n  EXAMPLE:\n    | Empty file causes JSONDecodeError | Added explicit empty file check before json.load() |\n-->\n<!-- Errors and how they were resolved -->\n| Issue | Resolution |\n|-------|------------|\n|       |            |\n\n## Resources\n<!-- \n  WHAT: URLs, file paths, API references, documentation links you've found useful.\n  WHY: Easy reference for later. Don't lose important links in context.\n  WHEN: Add as you discover useful resources.\n  EXAMPLE:\n    - Python argparse docs: https://docs.python.org/3/library/argparse.html\n    - Project structure: src/main.py, src/utils.py\n-->\n<!-- URLs, file paths, API references -->\n-\n\n## Visual/Browser Findings\n<!-- \n  WHAT: Information you learned from viewing images, PDFs, or browser results.\n  WHY: CRITICAL - Visual/multimodal content doesn't persist in context. Must be captured as text.\n  WHEN: IMMEDIATELY after viewing images or browser results. Don't wait!\n  EXAMPLE:\n    - Screenshot shows login form has email and password fields\n    - Browser shows API returns JSON with \"status\" and \"data\" keys\n-->\n<!-- CRITICAL: Update after every 2 view/browser operations -->\n<!-- Multimodal content must be captured as text immediately -->\n-\n\n---\n<!-- \n  REMINDER: The 2-Action Rule\n  After every 2 view/browser/search operations, you MUST update this file.\n  This prevents visual information from being lost when context resets.\n-->\n*Update this file after every 2 view/browser/search operations*\n*This prevents visual information from being lost*\n",
        "skills/planning-with-files/templates/progress.md": "# Progress Log\n<!-- \n  WHAT: Your session log - a chronological record of what you did, when, and what happened.\n  WHY: Answers \"What have I done?\" in the 5-Question Reboot Test. Helps you resume after breaks.\n  WHEN: Update after completing each phase or encountering errors. More detailed than task_plan.md.\n-->\n\n## Session: [DATE]\n<!-- \n  WHAT: The date of this work session.\n  WHY: Helps track when work happened, useful for resuming after time gaps.\n  EXAMPLE: 2026-01-15\n-->\n\n### Phase 1: [Title]\n<!-- \n  WHAT: Detailed log of actions taken during this phase.\n  WHY: Provides context for what was done, making it easier to resume or debug.\n  WHEN: Update as you work through the phase, or at least when you complete it.\n-->\n- **Status:** in_progress\n- **Started:** [timestamp]\n<!-- \n  STATUS: Same as task_plan.md (pending, in_progress, complete)\n  TIMESTAMP: When you started this phase (e.g., \"2026-01-15 10:00\")\n-->\n- Actions taken:\n  <!-- \n    WHAT: List of specific actions you performed.\n    EXAMPLE:\n      - Created todo.py with basic structure\n      - Implemented add functionality\n      - Fixed FileNotFoundError\n  -->\n  -\n- Files created/modified:\n  <!-- \n    WHAT: Which files you created or changed.\n    WHY: Quick reference for what was touched. Helps with debugging and review.\n    EXAMPLE:\n      - todo.py (created)\n      - todos.json (created by app)\n      - task_plan.md (updated)\n  -->\n  -\n\n### Phase 2: [Title]\n<!-- \n  WHAT: Same structure as Phase 1, for the next phase.\n  WHY: Keep a separate log entry for each phase to track progress clearly.\n-->\n- **Status:** pending\n- Actions taken:\n  -\n- Files created/modified:\n  -\n\n## Test Results\n<!-- \n  WHAT: Table of tests you ran, what you expected, what actually happened.\n  WHY: Documents verification of functionality. Helps catch regressions.\n  WHEN: Update as you test features, especially during Phase 4 (Testing & Verification).\n  EXAMPLE:\n    | Add task | python todo.py add \"Buy milk\" | Task added | Task added successfully | âœ“ |\n    | List tasks | python todo.py list | Shows all tasks | Shows all tasks | âœ“ |\n-->\n| Test | Input | Expected | Actual | Status |\n|------|-------|----------|--------|--------|\n|      |       |          |        |        |\n\n## Error Log\n<!-- \n  WHAT: Detailed log of every error encountered, with timestamps and resolution attempts.\n  WHY: More detailed than task_plan.md's error table. Helps you learn from mistakes.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | 2026-01-15 10:35 | FileNotFoundError | 1 | Added file existence check |\n    | 2026-01-15 10:37 | JSONDecodeError | 2 | Added empty file handling |\n-->\n<!-- Keep ALL errors - they help avoid repetition -->\n| Timestamp | Error | Attempt | Resolution |\n|-----------|-------|---------|------------|\n|           |       | 1       |            |\n\n## 5-Question Reboot Check\n<!-- \n  WHAT: Five questions that verify your context is solid. If you can answer these, you're on track.\n  WHY: This is the \"reboot test\" - if you can answer all 5, you can resume work effectively.\n  WHEN: Update periodically, especially when resuming after a break or context reset.\n  \n  THE 5 QUESTIONS:\n  1. Where am I? â†’ Current phase in task_plan.md\n  2. Where am I going? â†’ Remaining phases\n  3. What's the goal? â†’ Goal statement in task_plan.md\n  4. What have I learned? â†’ See findings.md\n  5. What have I done? â†’ See progress.md (this file)\n-->\n<!-- If you can answer these, context is solid -->\n| Question | Answer |\n|----------|--------|\n| Where am I? | Phase X |\n| Where am I going? | Remaining phases |\n| What's the goal? | [goal statement] |\n| What have I learned? | See findings.md |\n| What have I done? | See above |\n\n---\n<!-- \n  REMINDER: \n  - Update after completing each phase or encountering errors\n  - Be detailed - this is your \"what happened\" log\n  - Include timestamps for errors to track when issues occurred\n-->\n*Update after completing each phase or encountering errors*\n",
        "skills/planning-with-files/templates/task_plan.md": "# Task Plan: [Brief Description]\n<!-- \n  WHAT: This is your roadmap for the entire task. Think of it as your \"working memory on disk.\"\n  WHY: After 50+ tool calls, your original goals can get forgotten. This file keeps them fresh.\n  WHEN: Create this FIRST, before starting any work. Update after each phase completes.\n-->\n\n## Goal\n<!-- \n  WHAT: One clear sentence describing what you're trying to achieve.\n  WHY: This is your north star. Re-reading this keeps you focused on the end state.\n  EXAMPLE: \"Create a Python CLI todo app with add, list, and delete functionality.\"\n-->\n[One sentence describing the end state]\n\n## Current Phase\n<!-- \n  WHAT: Which phase you're currently working on (e.g., \"Phase 1\", \"Phase 3\").\n  WHY: Quick reference for where you are in the task. Update this as you progress.\n-->\nPhase 1\n\n## Phases\n<!-- \n  WHAT: Break your task into 3-7 logical phases. Each phase should be completable.\n  WHY: Breaking work into phases prevents overwhelm and makes progress visible.\n  WHEN: Update status after completing each phase: pending â†’ in_progress â†’ complete\n-->\n\n### Phase 1: Requirements & Discovery\n<!-- \n  WHAT: Understand what needs to be done and gather initial information.\n  WHY: Starting without understanding leads to wasted effort. This phase prevents that.\n-->\n- [ ] Understand user intent\n- [ ] Identify constraints and requirements\n- [ ] Document findings in findings.md\n- **Status:** in_progress\n<!-- \n  STATUS VALUES:\n  - pending: Not started yet\n  - in_progress: Currently working on this\n  - complete: Finished this phase\n-->\n\n### Phase 2: Planning & Structure\n<!-- \n  WHAT: Decide how you'll approach the problem and what structure you'll use.\n  WHY: Good planning prevents rework. Document decisions so you remember why you chose them.\n-->\n- [ ] Define technical approach\n- [ ] Create project structure if needed\n- [ ] Document decisions with rationale\n- **Status:** pending\n\n### Phase 3: Implementation\n<!-- \n  WHAT: Actually build/create/write the solution.\n  WHY: This is where the work happens. Break into smaller sub-tasks if needed.\n-->\n- [ ] Execute the plan step by step\n- [ ] Write code to files before executing\n- [ ] Test incrementally\n- **Status:** pending\n\n### Phase 4: Testing & Verification\n<!-- \n  WHAT: Verify everything works and meets requirements.\n  WHY: Catching issues early saves time. Document test results in progress.md.\n-->\n- [ ] Verify all requirements met\n- [ ] Document test results in progress.md\n- [ ] Fix any issues found\n- **Status:** pending\n\n### Phase 5: Delivery\n<!-- \n  WHAT: Final review and handoff to user.\n  WHY: Ensures nothing is forgotten and deliverables are complete.\n-->\n- [ ] Review all output files\n- [ ] Ensure deliverables are complete\n- [ ] Deliver to user\n- **Status:** pending\n\n## Key Questions\n<!-- \n  WHAT: Important questions you need to answer during the task.\n  WHY: These guide your research and decision-making. Answer them as you go.\n  EXAMPLE: \n    1. Should tasks persist between sessions? (Yes - need file storage)\n    2. What format for storing tasks? (JSON file)\n-->\n1. [Question to answer]\n2. [Question to answer]\n\n## Decisions Made\n<!-- \n  WHAT: Technical and design decisions you've made, with the reasoning behind them.\n  WHY: You'll forget why you made choices. This table helps you remember and justify decisions.\n  WHEN: Update whenever you make a significant choice (technology, approach, structure).\n  EXAMPLE:\n    | Use JSON for storage | Simple, human-readable, built-in Python support |\n-->\n| Decision | Rationale |\n|----------|-----------|\n|          |           |\n\n## Errors Encountered\n<!-- \n  WHAT: Every error you encounter, what attempt number it was, and how you resolved it.\n  WHY: Logging errors prevents repeating the same mistakes. This is critical for learning.\n  WHEN: Add immediately when an error occurs, even if you fix it quickly.\n  EXAMPLE:\n    | FileNotFoundError | 1 | Check if file exists, create empty list if not |\n    | JSONDecodeError | 2 | Handle empty file case explicitly |\n-->\n| Error | Attempt | Resolution |\n|-------|---------|------------|\n|       | 1       |            |\n\n## Notes\n<!-- \n  REMINDERS:\n  - Update phase status as you progress: pending â†’ in_progress â†’ complete\n  - Re-read this plan before major decisions (attention manipulation)\n  - Log ALL errors - they help avoid repetition\n  - Never repeat a failed action - mutate your approach instead\n-->\n- Update phase status as you progress: pending â†’ in_progress â†’ complete\n- Re-read this plan before major decisions (attention manipulation)\n- Log ALL errors - they help avoid repetition\n"
      },
      "plugins": [
        {
          "name": "planning-with-files",
          "source": "./",
          "description": "Manus-style persistent markdown files for planning, progress tracking, and knowledge storage. Now with hooks integration.",
          "version": "2.0.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add OthmanAdi/planning-with-files",
            "/plugin install planning-with-files@planning-with-files"
          ]
        }
      ]
    }
  ]
}