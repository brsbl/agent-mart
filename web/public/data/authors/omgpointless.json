{
  "author": {
    "id": "omgpointless",
    "display_name": "Pointless",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/2750716?v=4",
    "url": "https://github.com/omgpointless",
    "bio": "I'm a cross-stack developer that's passionate about creating and developing great products for desktop, web and mobile devices.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 9,
      "total_skills": 1,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "aspy",
      "version": null,
      "description": "Plugin marketplace for Aspy - a TUI observability proxy for Claude Code",
      "owner_info": {
        "name": "aspy contributors",
        "url": "https://github.com/omgpointless/aspy"
      },
      "keywords": [],
      "repo_full_name": "omgpointless/aspy",
      "repo_url": "https://github.com/omgpointless/aspy",
      "repo_description": "Real-time TUI proxy to visualize Claude Code tool calls, thinking blocks, and token usage",
      "homepage": "https://omgpointless.github.io/aspy/",
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-11T20:19:08Z",
        "created_at": "2025-11-24T10:58:54Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 823
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 635
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/README.md",
          "type": "blob",
          "size": 5623
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3872
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/recover.md",
          "type": "blob",
          "size": 3809
        },
        {
          "path": "agents/summarize.md",
          "type": "blob",
          "size": 2502
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/events.md",
          "type": "blob",
          "size": 758
        },
        {
          "path": "commands/lifestats.md",
          "type": "blob",
          "size": 405
        },
        {
          "path": "commands/search-prompts.md",
          "type": "blob",
          "size": 325
        },
        {
          "path": "commands/search-responses.md",
          "type": "blob",
          "size": 373
        },
        {
          "path": "commands/search-thinking.md",
          "type": "blob",
          "size": 390
        },
        {
          "path": "commands/search.md",
          "type": "blob",
          "size": 556
        },
        {
          "path": "commands/stats.md",
          "type": "blob",
          "size": 460
        },
        {
          "path": "commands/summarize.md",
          "type": "blob",
          "size": 3398
        },
        {
          "path": "commands/window.md",
          "type": "blob",
          "size": 505
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 1325
        },
        {
          "path": "hooks/spy",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/spy/README.md",
          "type": "blob",
          "size": 2528
        },
        {
          "path": "hooks/spy/cargo-fmt.js",
          "type": "blob",
          "size": 2052
        },
        {
          "path": "hooks/spy/pre-compact.js",
          "type": "blob",
          "size": 2113
        },
        {
          "path": "hooks/spy/session-end.js",
          "type": "blob",
          "size": 1834
        },
        {
          "path": "hooks/spy/session-start.js",
          "type": "blob",
          "size": 2404
        },
        {
          "path": "hooks/spy/user-prompt.js",
          "type": "blob",
          "size": 2763
        },
        {
          "path": "mcp-server",
          "type": "tree",
          "size": null
        },
        {
          "path": "mcp-server/README.md",
          "type": "blob",
          "size": 3469
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/context-recovery",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/context-recovery/SKILL.md",
          "type": "blob",
          "size": 2712
        },
        {
          "path": "skills/context-recovery/advanced-strategies.md",
          "type": "blob",
          "size": 2497
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"aspy\",\n  \"owner\": {\n    \"name\": \"aspy contributors\",\n    \"url\": \"https://github.com/omgpointless/aspy\"\n  },\n  \"metadata\": {\n    \"description\": \"Plugin marketplace for Aspy - a TUI observability proxy for Claude Code\",\n    \"version\": \"0.2.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"aspy\",\n      \"source\": \"./\",\n      \"description\": \"Observability and development tools for Claude Code sessions\",\n      \"version\": \"0.2.0\",\n      \"author\": {\n        \"name\": \"aspy contributors\",\n        \"url\": \"https://github.com/omgpointless/aspy\"\n      },\n      \"homepage\": \"https://github.com/omgpointless/aspy\",\n      \"repository\": \"https://github.com/omgpointless/aspy\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"observability\", \"proxy\", \"tui\", \"statistics\", \"cost-tracking\"],\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"aspy\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Observability and development tools for Claude Code sessions\",\n  \"author\": {\n    \"name\": \"aspy contributors\",\n    \"url\": \"https://github.com/omgpointless/aspy\"\n  },\n  \"homepage\": \"https://github.com/omgpointless/aspy\",\n  \"repository\": \"https://github.com/omgpointless/aspy\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"observability\", \"proxy\", \"tui\", \"statistics\", \"cost-tracking\"],\n  \"commands\": \"./commands/\",\n  \"mcpServers\": {\n    \"aspy\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"aspy-mcp\"],\n      \"env\": {\n        \"ASPY_CLIENT_ID\": \"${ASPY_CLIENT_ID}\"\n      }\n    }\n  }\n}\n",
        ".claude/README.md": "# .claude/ Directory Structure\n\nThis directory contains project documentation, reference materials, and Claude Code configuration for the Aspy project.\n\n## Purpose\n\nThe `.claude/` directory serves dual purposes:\n\n1. **Version-Controlled Knowledge** - Stable architectural docs, vision, API references, and default commands\n2. **Local Workspace** - Session-specific notes, temporal context, and personal learning scratchpads (ignored by git)\n\n## What Gets Committed\n\nThese files are tracked in version control as they benefit all contributors:\n\n### Core Documentation\n- `EXTENSIONS_VISION.md` - Future extensibility roadmap (HTTP API, MCP, hooks)\n- `PROJECT_STATUS.md` - Current development phase and roadmap\n- `impl-plans/` - RFC-style implementation plans for upcoming features\n\n### Deprecated (Moved to docs/)\nThe following have been superseded by documentation in `docs/`:\n- `ARCHITECTURE.md` - **Deprecated**: See `docs/architecture.md`\n- `DEVELOPMENT_PHILOSOPHY.md` - **Deprecated**: See `docs/architecture.md` and `AGENTS.md`\n- `TONE_GUIDE.md` - **Deprecated**: See `AGENTS.md`\n\n**Note:** The root `CLAUDE.md` is the primary project documentation. Use `docs/` for detailed reference docs.\n\n### Claude Code Plugin\n- `.claude-plugin/` - Optional development tooling (committed)\n  - Provides `/aspy:stats` and `/aspy:tempcontext` slash commands\n  - Automatic `cargo fmt` hooks for Rust files\n  - Install with: `/plugin marketplace add /path/to/aspy`\n\n### Meta\n- `README.md` - This file\n- `.gitignore` - Controls what gets committed vs. ignored\n\n## What Gets Ignored\n\nThese files are kept local as they're session-specific or personal workspace material:\n\n### Session Context\n- `SESSION_*.md` - Session-specific notes and handoffs\n- `temporal-context/` - Timestamped session logs (e.g., `2025-11-30-theme-system.md`)\n- `snapshots/` - Session state snapshots\n\n### Exploratory Work\n- `roadmap-brainstorms/` - Early-stage ideation and planning\n- `*LEARNING*.md` - Personal learning notes (Rust, Docker, etc.)\n- `*PRICING*.md` - Pricing references that change over time\n\n### Temporal Planning\n- `RELEASE_PLAN*.md` - Version-specific release planning docs\n- `QUICK_REFERENCE.md` - Session-specific quick references\n- `START_HERE.md` - Session entry points\n\n### User Customizations (Future)\n- `hooks/` - User-provided hook scripts (see EXTENSIONS_VISION.md Phase 4)\n- `*.local.md` - Local overrides to documentation\n- `.state/`, `.cache/` - Runtime state\n\n## Directory Layout\n\n```\n.claude/\n‚îú‚îÄ‚îÄ README.md                    # This file (committed)\n‚îú‚îÄ‚îÄ .gitignore                   # Controls commit/ignore (committed)\n‚îÇ\n‚îú‚îÄ‚îÄ CLAUDE.md                    # Main instructions (committed)\n‚îú‚îÄ‚îÄ EXTENSIONS_VISION.md         # Extensibility roadmap (committed)\n‚îú‚îÄ‚îÄ ARCHITECTURE.md              # System design (committed)\n‚îú‚îÄ‚îÄ DEVELOPMENT_PHILOSOPHY.md    # Rust patterns (committed)\n‚îú‚îÄ‚îÄ PROJECT_STATUS.md            # Current phase (committed)\n‚îú‚îÄ‚îÄ TONE_GUIDE.md                # Messaging guide (committed)\n‚îÇ\n‚îú‚îÄ‚îÄ SESSION_*.md                 # Session notes (ignored)\n‚îú‚îÄ‚îÄ temporal-context/            # Session logs (ignored)\n‚îú‚îÄ‚îÄ snapshots/                   # Session snapshots (ignored)\n‚îú‚îÄ‚îÄ roadmap-brainstorms/         # Exploratory notes (ignored)\n‚îî‚îÄ‚îÄ [other ignored patterns]     # See .gitignore\n```\n\n## For Contributors\n\n### Adding Stable Documentation\n\nIf you're adding architectural docs, vision statements, or reference materials that benefit all contributors:\n\n1. Create the file in `.claude/` root or appropriate subdirectory\n2. Ensure it's NOT matched by `.claude/.gitignore` patterns\n3. Commit with: `git add .claude/<filename>`\n4. Include in PR for review\n\n### Working with Session Context\n\nFor session-specific notes, temporal context, or personal learning:\n\n1. Use naming patterns that match `.claude/.gitignore` (e.g., `SESSION_*.md`)\n2. Or place in ignored directories (`temporal-context/`, `snapshots/`, etc.)\n3. These files stay local, never commit them\n\n### Installing Slash Commands\n\nSlash commands in `commands/spy/*.md` are examples. To use them:\n\n1. Symlink or copy to your local `.claude/commands/` if using Claude Code\n2. Or reference them when creating custom commands\n3. See EXTENSIONS_VISION.md for the full vision\n\n## For Users\n\n### Finding Documentation\n\n- **\"How should I architect this?\"** ‚Üí `ARCHITECTURE.md`, `DEVELOPMENT_PHILOSOPHY.md`\n- **\"What's the vision for extensions?\"** ‚Üí `EXTENSIONS_VISION.md`\n- **\"What Rust patterns do we use?\"** ‚Üí `DEVELOPMENT_PHILOSOPHY.md`\n- **\"Where are we in development?\"** ‚Üí `PROJECT_STATUS.md`\n\n### Session Notes\n\nFeel free to create session-specific notes using these patterns (auto-ignored):\n\n- `SESSION_<topic>.md` - Handoff notes\n- `temporal-context/YYYY-MM-DD-<topic>.md` - Timestamped context\n- `snapshots/YYYY-MM-DD-<description>.md` - State snapshots\n- `*LEARNING*.md` - Personal learning notes\n\nThese won't pollute the repo, but stay in your local checkout.\n\n## Alignment with EXTENSIONS_VISION.md\n\nThis structure supports the extensions vision:\n\n- **Plugin system** in `.claude-plugin/` provides opt-in tooling (slash commands + hooks)\n- **Architectural docs** ensure extensions follow composition patterns\n- **User customizations** in `.claude/hooks/` stay local (ignored by git)\n\nSee `EXTENSIONS_VISION.md` for the full roadmap of HTTP API, MCP server, and hook integration.\n\n## Questions?\n\n- Check `.claude/.gitignore` for the full list of ignore patterns\n- See `CLAUDE.md` for main project instructions\n- Review `EXTENSIONS_VISION.md` for future directions\n",
        "README.md": "![Aspy (Anthropic Spy)](docs/images/aspy-logo-v4.png)\n\n[![CI](https://github.com/omgpointless/aspy/actions/workflows/ci.yml/badge.svg)](https://github.com/omgpointless/aspy/actions/workflows/ci.yml)\n[![Release](https://img.shields.io/github/v/release/omgpointless/aspy?include_prereleases)](https://github.com/omgpointless/aspy/releases)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![npm](https://img.shields.io/npm/v/aspy-mcp)](https://www.npmjs.com/package/aspy-mcp)\n\n**Observability proxy for Claude Code** ‚Äî see what's happening between Claude and the Anthropic API.\n\n![Demo](demo.gif)\n\n## What is Aspy?\n\nAspy sits between Claude Code and the Anthropic API, intercepting all traffic and giving you visibility into tool calls, thinking blocks, token usage, and costs. Run it as a TUI proxy, integrate via MCP, or install the Claude Code plugin.\n\n## What It Does\n\n- **Real-time TUI** ‚Äî Watch tool calls, thinking blocks, and API responses as they stream\n- **Token & cost tracking** ‚Äî Cumulative session statistics with per-model pricing\n- **Thinking capture** ‚Äî Dedicated panel showing Claude's reasoning in real-time\n- **Structured logs** ‚Äî JSON Lines format for analysis with `jq`\n- **Multi-client routing** ‚Äî Track multiple Claude Code instances through one proxy\n- **REST API & MCP** ‚Äî Programmatic access to session data\n\n## Get Started\n\n### Option 1: TUI Proxy (Binary)\n\nDownload from [GitHub Releases](https://github.com/omgpointless/aspy/releases) or build from source:\n\n```bash\ncargo install --git https://github.com/omgpointless/aspy\n```\n\nRun the proxy:\n```bash\n# Windows\n.\\aspy.exe\n\n# macOS/Linux\n./aspy\n```\n\nPoint Claude Code at it:\n```bash\n# In a new terminal\nexport ANTHROPIC_BASE_URL=http://127.0.0.1:8080\nclaude\n```\n\n### Optionally: MCP Server\n\nAdd aspy to Claude Code's MCP servers:\n\n```bash\nclaude mcp add aspy -- npx -y aspy-mcp\n```\n\nThis gives Claude Code access to:\n- **Current session**: `aspy_stats`, `aspy_events`, `aspy_context`\n- **Lifetime history**: `aspy_recall`, `aspy_lifetime` (semantic + keyword search)\n- **Context recovery**: Search past thinking blocks, prompts, and responses across all sessions\n\n> **Note**: Requires the TUI proxy running to collect data.\n\n### Optionally: Claude Code Plugin\n\nInstall the plugin for slash commands:\n\n```bash\n/plugin marketplace add omgpointless/aspy\n```\n\nAfter restarting Claude Code, use `/aspy:stats` to query session metrics. The plugin also includes automatic `cargo fmt` hooks for Rust projects.\n\n## Demo Mode\n\nTry the TUI without Claude Code:\n\n```bash\nASPY_DEMO=1 ./aspy\n```\n\nGenerates mock events to showcase the interface.\n\n## Documentation\n\n| Topic | Description |\n|-------|-------------|\n| [Features](docs/features.md) | Deep dive into all capabilities |\n| [Quick Start](QUICKSTART.md) | Step-by-step setup walkthrough |\n| [CLI Reference](docs/cli-reference.md) | Commands, config options, env vars |\n| [Log Analysis](docs/log-analysis.md) | jq queries for session profiling |\n| [Themes](docs/themes.md) | 32 bundled themes + custom TOML |\n| [Multi-Client Routing](docs/sessions.md) | Track multiple Claude instances |\n| [REST API](docs/api-reference.md) | Programmatic endpoints |\n| [Semantic Search](docs/semantic-search-guide.md) | Configure embeddings for hybrid search |\n| [Request Transformers](docs/transformers.md) | Edit XML tags, inject context conditionally |\n| [API Translation](docs/api-translation-guide.md) | Use Claude Code with any OpenAI-compatible backend |\n| [Architecture](docs/architecture.md) | For contributors |\n\n## Package Managers\n\nHomebrew, Scoop, and Chocolatey packages will be available when the project stabilizes.\n\n## About\n\nMaintainer's first Rust project. Learning journey together with Claude Code which is the whole reason I built this tool to start with.\n\n## License\n\nMIT\n",
        "agents/recover.md": "---\nname: recover\ndescription: Recover lost context from compacted sessions by searching Aspy logs\ntools: mcp__plugin_aspy_aspy__aspy_recall, mcp__plugin_aspy_aspy__aspy_recall_thinking, mcp__plugin_aspy_aspy__aspy_recall_prompts, mcp__plugin_aspy_aspy__aspy_recall_responses\nmodel: haiku\n---\n\nYou are a context recovery specialist for Aspy session logs.\n\n## Your Mission\n\nWhen a Claude Code session gets compacted and loses context, you help recover lost discussions, decisions, and reasoning by intelligently searching through historical session data.\n\n**The Challenge**: Logs can contain meta-discussions (talking *about* searching) mixed with real work (actual implementation discussions). Your job is to surface high-signal results.\n\n## Available Tools\n\n| Tool | Best For |\n|------|----------|\n| `aspy_recall` | **PRIMARY** - Semantic + keyword search (handles fuzzy queries) |\n| `aspy_recall_thinking` | Finding Claude's internal reasoning/analysis (WHY) |\n| `aspy_recall_prompts` | Finding what the user asked |\n| `aspy_recall_responses` | Finding Claude's answers and code |\n\n## Search Strategy\n\n### Phase 1: Use aspy_recall (Primary)\n\n1. **Parse Query Intent**\n   - \"what did we decide\" / \"why did we choose\" ‚Üí Decision query\n   - \"how did we implement\" / \"what's the approach\" ‚Üí Implementation query\n   - \"that thing about golf?\" ‚Üí Fuzzy query (semantic handles this!)\n\n2. **Execute Search**\n   ```\n   Tool: aspy_recall\n   Parameters:\n   - query: <term from user query>\n   - limit: 10\n   ```\n\n   `aspy_recall` automatically uses:\n   - **Semantic similarity** via embeddings (finds conceptually related content)\n   - **Keyword matching** via FTS5 (finds exact terminology)\n   - Falls back to keyword-only if embeddings not configured\n\n3. **Interpret Results by Match Type**\n\n   Results include `match_type` field:\n   - `thinking` (üí≠) - Claude's internal reasoning - HIGH VALUE for \"why\"\n   - `user_prompt` (üë§) - User's original questions/requests\n   - `assistant_response` (ü§ñ) - Claude's visible responses\n\n4. **Apply Signal Strength Filter**\n\n   **HIGH SIGNAL (prioritize)**:\n   - Contains code references (file:line, function names, `src/...`)\n   - Action words: \"implemented X\", \"added X\", \"fixed X\", \"decided on X\"\n   - Technical specifics: version numbers, config settings, error messages\n\n   **LOW SIGNAL (deprioritize)**:\n   - Metalinguistic: \"you can search\", \"the log shows\"\n   - Instructional: \"for example\", \"try this\"\n   - Past references: \"that discussion about X\"\n\n### Phase 2: Targeted Search (If Needed)\n\nIf `aspy_recall` returns too much noise, use specialized tools:\n- `aspy_recall_thinking` for WHY questions\n- `aspy_recall_prompts` for \"what did I ask about...\"\n- `aspy_recall_responses` for \"what did you say about...\"\n\n## Result Format\n\n```\nüîç Searched for: \"<query>\"\nFound <N> matches\n\nHIGH SIGNAL:\nüí≠ **Thinking [2025-12-01]** (session: abc123)\n  \"For streaming responses, we need to tee the stream...\"\n\nüë§ **User [2025-12-01]** (session: abc123)\n  \"How should we handle SSE streaming?\"\n\nü§ñ **Assistant [2025-11-30]** (session: def456)\n  \"The proxy implements stream-through by...\"\n```\n\n## CRITICAL: Division of Labor\n\nYou are **retrieval + ranking**, NOT synthesis:\n- ‚úÖ Find matches\n- ‚úÖ Rank by signal strength\n- ‚úÖ Provide context previews\n- ‚ùå DO NOT summarize or interpret\n- ‚ùå DO NOT synthesize across matches\n- ‚ùå DO NOT answer the user's question\n\nThe main agent (Opus) will read and synthesize. You're the librarian.\n\n## When to Give Up\n\nIf searches return <2 matches or all low-signal:\n1. Report what you searched\n2. Suggest refinements: \"Try different keywords or broader terms\"\n3. Don't invent results\n\nRemember: You're Haiku (fast + cheap). Main agent is Opus (smart + expensive). You find the needles, they understand the haystack.\n",
        "agents/summarize.md": "---\nname: summarize\ndescription: Gather current session context for compact survival using Aspy data\ntools: mcp__plugin_aspy_aspy__aspy_events, mcp__plugin_aspy_aspy__aspy_todos, mcp__plugin_aspy_aspy__aspy_stats\nmodel: haiku\n---\n\nYou are a session context gatherer for compact preparation.\n\n## Your Mission\n\nCollect structured data from the **current session only** to support compact survival document creation. You gather the factual backbone (todos, files, thinking, metrics); the main agent (Opus) combines this with conversation context to generate the temporal context file.\n\n## CRITICAL: Session Scope\n\nYou ONLY use tools that return **current session** data:\n- `aspy_events` - Events from THIS session's in-memory buffer\n- `aspy_todos` - Todo state from THIS session\n- `aspy_stats` - Stats from THIS session\n\nDo NOT use `aspy_recall*` tools - those search ALL historical sessions and would pull in irrelevant old context.\n\n## Data Collection Steps\n\nExecute these in order:\n\n### 1. Current Todo State\n```\nTool: aspy_todos\n```\nThis shows what tasks are pending, in-progress, or completed RIGHT NOW.\n\n### 2. Recent Thinking Blocks\n```\nTool: aspy_events\nParameters:\n  limit: 50\n  type: Thinking\n```\nExtract key reasoning and decisions from Claude's thinking this session.\n\n### 3. Recent Tool Activity\n```\nTool: aspy_events\nParameters:\n  limit: 30\n  type: ToolCall\n```\nIdentify which files are actively being modified.\n\n### 4. Session Stats\n```\nTool: aspy_stats\n```\nGet token usage, costs, tool call counts for context.\n\n## Output Format\n\nReturn a structured summary:\n\n```markdown\n## Session Data for Compact Survival\n\n### Current Task State\n[From aspy_todos - list pending/in-progress/completed]\n\n### Key Decisions Made (from Thinking)\n[Extract 3-5 important decisions or conclusions from thinking blocks]\n\n### Active Files\n[List files from ToolCall events - focus on Write/Edit targets]\n\n### Session Metrics\n- Duration: X\n- Tokens: X input / X output\n- Tool calls: X\n\n### Suggested Keywords for Post-Compact Recovery\n[3-5 searchable terms: feature names, file paths, concepts]\n```\n\n## Division of Labor\n\n- **You (Haiku)**: Fast data gathering, basic extraction\n- **Main agent (Opus)**: Synthesis, temporal context file generation\n\nDo NOT:\n- Generate the temporal context file yourself\n- Summarize or interpret beyond basic extraction\n- Use `aspy_recall` or other cross-session tools\n- Add analysis or recommendations\n\nYou're the data gatherer. Return raw structured data and let Opus synthesize.\n",
        "commands/events.md": "---\ndescription: \"View Aspy session events\"\nargument-hint: \"[limit] [type]\"\n---\n\nUse the `aspy_events` MCP tool to query recent events from the current session.\n\n**Arguments:**\n- First argument: `limit` - Max events to return (default: 10, max: 500)\n- Second argument: `type` - Filter by event type (optional)\n\n**Event types:** `ToolCall`, `ToolResult`, `ApiUsage`, `Thinking`, `Request`, `Response`\n\n**Usage examples:**\n- `/aspy:events` - Last 10 events (any type)\n- `/aspy:events 20` - Last 20 events\n- `/aspy:events 5 ToolCall` - Last 5 tool calls only\n- `/aspy:events 100 Thinking` - Last 100 thinking blocks\n\nDisplay results showing timestamp, type, and relevant details for each event.\n\n**Note:** Requires Aspy proxy to be running (default port 8080).\n",
        "commands/lifestats.md": "---\ndescription: \"View lifetime usage statistics across all sessions\"\n---\n\nUse the `aspy_lifetime` MCP tool to get all-time statistics from Aspy.\n\nDisplay results showing:\n- Total sessions, tokens, and cost\n- Model breakdown (tokens and cost per model)\n- Tool usage stats (calls, avg duration, success rate)\n- Time range (first to last session)\n\nFormat large numbers readably (e.g., 1.2M tokens, $12.34).\n",
        "commands/search-prompts.md": "---\ndescription: \"Search past user prompts\"\n---\n\nUse the `aspy_recall_prompts` MCP tool to search for: $ARGUMENTS\n\nIf no search terms were provided, ask the user: \"What past questions or requests would you like to find?\"\n\nUse this when you need to find what YOU asked previously.\n\nShow relevant prompts with session context.\n",
        "commands/search-responses.md": "---\ndescription: \"Search past assistant responses\"\n---\n\nUse the `aspy_recall_responses` MCP tool to search for: $ARGUMENTS\n\nIf no search terms were provided, ask the user: \"What past explanations or code would you like to find?\"\n\nUse this when you need to find previous answers, explanations, or code Claude provided.\n\nShow relevant response excerpts with session context.\n",
        "commands/search-thinking.md": "---\ndescription: \"Search Claude's past thinking blocks\"\n---\n\nUse the `aspy_recall_thinking` MCP tool to search for: $ARGUMENTS\n\nIf no search terms were provided, ask the user: \"What reasoning or analysis would you like to find in past sessions?\"\n\nUse this when you need to find WHY something was decided or HOW a problem was analyzed.\n\nShow relevant thinking excerpts with session context.\n",
        "commands/search.md": "---\ndescription: \"Search past sessions (thinking, prompts, responses)\"\n---\n\nUse the `aspy_recall` MCP tool to search for: $ARGUMENTS\n\nIf no search terms were provided, ask the user: \"What would you like to search for across your past sessions?\"\n\nThis tool uses semantic search (if embeddings enabled) combined with keyword matching. It can handle:\n- Exact queries: \"ContextState refactor\"\n- Fuzzy queries: \"that thing about golf and nature\"\n\nShow relevant matches with their source type (üí≠ thinking / üë§ prompt / ü§ñ response) and session timestamp.\n",
        "commands/stats.md": "---\ndescription: \"View Aspy session statistics\"\n---\n\nUse the `aspy_stats` MCP tool to get current session statistics from Aspy.\n\nDisplay the results in a clear format showing:\n- Session duration and event count\n- Token usage (input, output, cached) with cache ratio\n- Cost breakdown (total spent, savings from caching)\n- Request success rate\n- Top 5 most-used tools\n- Thinking block statistics\n\n**Note:** Requires Aspy proxy to be running (default port 8080).\n",
        "commands/summarize.md": "---\ndescription: \"Generate context file before /compact to ensure smooth transition after compaction. Use this template to structure your file and provide a recommended compact message to the user.\"\n---\n\n# Temporal Context Export for Compact Survival\n\nGenerate a compact survival document using real session data from Aspy.\n\n## Phase 1: Gather Session Data\n\n**FIRST**, spawn the `summarize` agent (Haiku) to collect current session data:\n\n```\nAgent: summarize\n```\n\nThis agent will return structured data including:\n- Current todo state (pending/in-progress/completed tasks)\n- Key thinking blocks from this session\n- Recent tool activity (files being modified)\n- Session metrics (tokens, costs, duration)\n\n**Wait for the agent to return before proceeding to Phase 2.**\n\n## Phase 2: Generate Context File\n\nUsing the data from Phase 1 **combined with your own conversation context**, generate a context file at:\n```\n.claude/temporal-context/YYYY-MM-DD-HH-MM-<slug>.md\n```\n\nWhere `<slug>` is a 2-4 word kebab-case summary (e.g., `plugin-summarize-agent`)\n\n### Template Structure\n\n```markdown\n# Temporal Context: <Topic>\n\n**Generated:** YYYY-MM-DD HH:MM\n**Purpose:** Compact survival - resume without context loss\n\n---\n\n## Active Work Thread\n\nWhat is actively being worked on RIGHT NOW. Be specific:\n- Current task/feature (from todo state)\n- Where we left off (file:line if applicable)\n- Immediate next step\n\n## Recent Decisions\n\nKey decisions made this session that inform ongoing work:\n- Decision ‚Üí Rationale (extract from thinking blocks)\n\n## User Direction & Intent\n\nWhat the user is trying to achieve (may be broader than current task):\n- Stated goals\n- Implicit preferences observed\n- \"Vibe\" of the session (exploratory? focused? debugging?)\n\n## Files in Play\n\nFiles actively being modified or referenced (from tool activity):\n- `path` - what's happening there\n\n## Do NOT Forget\n\nCritical items that must survive compact:\n- Unfinished work (from pending todos)\n- Promised follow-ups\n- User-stated priorities\n\n---\n\n## Resume Prompt\n\n[One paragraph: exactly what a post-compact Claude needs to know to continue seamlessly]\n\n## Recovery Keywords\n\n[3-5 searchable terms for `aspy_recall` post-compact: feature names, file paths, concepts]\n```\n\n## Phase 3: Provide Compact Recommendation\n\nReply with a recommended `/compact` message:\n\n```\nReady for compact. Recommended message:\n\n/compact Continue the session documented in .claude/temporal-context/<generated-filename>.md - we were [brief current state]. Key context: [1-2 critical points that must survive].\n```\n\n## Style Guidelines\n\n- **Ground in Aspy data** - Use todos, thinking blocks, and tool activity as the factual backbone\n- **Augment with conversation context** - Fill gaps the data misses: user intent, promises, session vibe\n- The thinking blocks contain Claude's reasoning; interpret them to extract decisions\n- Prioritize RECENT context over session history\n- Be terse‚Äîthis survives compact, not archives\n- Capture intent, not just actions\n- Include recovery keywords for post-compact `aspy_recall` searches\n\n## What Goes Where\n\n| Source | Best For |\n|--------|----------|\n| `aspy_todos` | Active Work Thread, Do NOT Forget |\n| `aspy_events(Thinking)` | Recent Decisions, reasoning behind choices |\n| `aspy_events(ToolCall)` | Files in Play |\n| Conversation analysis | User Direction & Intent, Tangents That Matter, session vibe |\n",
        "commands/window.md": "---\ndescription: \"Check context window usage %\"\n---\n\nUse the `aspy_window` MCP tool to check current context window usage.\n\nDisplay results with:\n- Status indicator based on warning level:\n  - üü¢ **NORMAL** - Under 70% (safe)\n  - üü° **WARNING** - 70-85% (approaching limit)\n  - üü† **HIGH** - 85-95% (high risk)\n  - üî¥ **CRITICAL** - Over 95% (imminent compact)\n- Usage percentage and token counts\n- Number of compacts this session\n\n**Note:** Requires Aspy proxy to be running (default port 8080).\n",
        "hooks/hooks.json": "{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"startup|resume|clear|compact\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/spy/session-start.js\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"UserPromptSubmit\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/spy/user-prompt.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"SessionEnd\": [\n      {\n        \"matcher\": \"clear|logout|prompt_input_exit|other\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/spy/session-end.js\",\n            \"timeout\": 5\n          }\n        ]\n      }\n    ],\n    \"PreCompact\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/spy/pre-compact.js\",\n            \"timeout\": 10\n          }\n        ]\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"matcher\": \"Write|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"node ${CLAUDE_PLUGIN_ROOT}/hooks/spy/cargo-fmt.js\",\n            \"timeout\": 30\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "hooks/spy/README.md": "# Project Hooks\n\nThis directory contains Claude Code hooks for the aspy plugin. All hooks are written in Node.js for cross-platform compatibility (Windows, macOS, Linux).\n\n## Active Hooks\n\n### `session-start.js` - Session Registration\n\n**Trigger:** SessionStart (startup, resume, clear, compact)\n**Action:** Registers the session with aspy proxy for tracking\n**Timeout:** 10 seconds\n\nWhen Claude Code starts a session:\n1. Hook receives session_id and source from Claude Code\n2. Computes user_id by hashing ANTHROPIC_API_KEY (SHA-256, first 16 chars)\n3. POSTs to `http://127.0.0.1:8080/api/session/start`\n4. Proxy supersedes any previous session for this user\n\n**Configuration:** Set `ASPY_API_URL` env var to override proxy address.\n\n---\n\n### `session-end.js` - Session Archival\n\n**Trigger:** SessionEnd (clear, logout, prompt_input_exit, other)\n**Action:** Notifies proxy that session has ended\n**Timeout:** 5 seconds (fire-and-forget)\n\nWhen Claude Code ends:\n1. Hook receives session_id and reason\n2. POSTs to `http://127.0.0.1:8080/api/session/end`\n3. Proxy archives the session for history\n\n---\n\n### `cargo-fmt.js` - Automatic Rust Formatting\n\n**Trigger:** After Write or Edit tool calls on `.rs` files\n**Action:** Runs `cargo fmt` on the modified file\n**Timeout:** 30 seconds\n\nWhen Claude Code writes or edits a Rust file:\n1. The PostToolUse hook fires automatically\n2. The hook script receives tool call data via stdin\n3. Script extracts the file path and checks if it's a `.rs` file\n4. If yes, runs `cargo fmt` on that specific file\n5. Formatting errors are logged but don't block (non-fatal)\n\n---\n\n## Multi-User Session Tracking\n\nThe session hooks enable multi-user tracking:\n\n```\nUser A (api_key_hash: a3f2c91b)\n‚îú‚îÄ‚îÄ Session 1: 14:30-15:45 ‚Üí tracked, archived\n‚îî‚îÄ‚îÄ Session 2: 16:00-...   ‚Üí active\n\nUser B (api_key_hash: 7e1d04fa)\n‚îî‚îÄ‚îÄ Session 1: 15:00-...   ‚Üí active\n```\n\nQuery sessions via API:\n```bash\ncurl http://127.0.0.1:8080/api/sessions\n```\n\n---\n\n## Testing Hooks\n\n```bash\n# Test session-start hook\necho '{\"session_id\":\"test-123\",\"source\":\"startup\"}' | \\\n  ANTHROPIC_API_KEY=\"sk-ant-test\" node session-start.js\n\n# Test session-end hook\necho '{\"session_id\":\"test-123\",\"reason\":\"logout\"}' | \\\n  ANTHROPIC_API_KEY=\"sk-ant-test\" node session-end.js\n\n# Test cargo-fmt hook\necho '{\"name\":\"Write\",\"input\":{\"file_path\":\"src/main.rs\"}}' | \\\n  node cargo-fmt.js\n```\n\n---\n\n## Resources\n\n- [Claude Code Hooks Guide](https://docs.anthropic.com/en/docs/claude-code/hooks)\n- [aspy README](../../README.md)\n",
        "hooks/spy/cargo-fmt.js": "#!/usr/bin/env node\n/**\n * Post-tool-use hook: Automatic cargo fmt on Rust file modifications\n *\n * This hook runs after Write or Edit tool calls and formats Rust files using cargo fmt.\n * It ensures all Rust code stays formatted according to project standards.\n *\n * Input (stdin): JSON with tool input containing file_path\n * Output: JSON with systemMessage on success/failure\n */\n\nimport { spawn } from 'child_process';\nimport { join } from 'path';\n\nasync function main() {\n  // Read stdin\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = Buffer.concat(chunks).toString('utf8');\n\n  let toolData;\n  try {\n    toolData = JSON.parse(input);\n  } catch {\n    process.exit(0);\n  }\n\n  // Extract file path from tool call\n  const filePath = toolData?.input?.file_path;\n\n  if (!filePath) {\n    process.exit(0);\n  }\n\n  // Check if it's a Rust file\n  if (!filePath.endsWith('.rs')) {\n    process.exit(0);\n  }\n\n  // Build cargo fmt command\n  const projectDir = process.env.CLAUDE_PROJECT_DIR;\n  const args = ['fmt', '--'];\n\n  if (projectDir) {\n    args.splice(1, 0, '--manifest-path', join(projectDir, 'Cargo.toml'));\n  }\n\n  args.push(filePath);\n\n  // Run cargo fmt\n  const result = await new Promise((resolve) => {\n    const proc = spawn('cargo', args, {\n      stdio: ['ignore', 'pipe', 'pipe'],\n      shell: process.platform === 'win32',\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    proc.stdout?.on('data', (data) => { stdout += data; });\n    proc.stderr?.on('data', (data) => { stderr += data; });\n\n    proc.on('error', (err) => {\n      resolve({ code: 1, output: err.message });\n    });\n\n    proc.on('close', (code) => {\n      resolve({ code: code || 0, output: stderr || stdout });\n    });\n  });\n\n  if (result.code === 0) {\n    console.log(JSON.stringify({\n      systemMessage: `‚úì Formatted ${filePath}`,\n    }));\n  } else {\n    console.log(JSON.stringify({\n      systemMessage: `‚ö† cargo fmt issues with ${filePath}: ${result.output}`,\n    }));\n  }\n\n  process.exit(0);\n}\n\nmain();\n",
        "hooks/spy/pre-compact.js": "#!/usr/bin/env node\n/**\n * PreCompact hook: Notify aspy proxy before context compaction\n *\n * Called when Claude Code is about to compact (manual /compact or auto).\n * Creates a timeline marker event in aspy's TUI for tracking compact flow.\n *\n * Input (stdin): JSON with trigger, session_id, transcript_path, etc.\n * Output: JSON (optional, not blocking)\n */\n\nimport { createHash } from 'crypto';\n\nconst ASPY_API_URL = process.env.ASPY_API_URL || 'http://127.0.0.1:8080';\n\nasync function main() {\n  // Read stdin\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = Buffer.concat(chunks).toString('utf8');\n\n  let hookData = {};\n  try {\n    hookData = JSON.parse(input);\n  } catch {\n    // Use defaults if parse fails\n  }\n\n  const trigger = hookData.trigger || 'manual';\n\n  // Compute user_id from API key or OAuth token (SHA-256, first 16 chars)\n  let userId = process.env.ASPY_CLIENT_ID;\n\n  if (!userId) {\n    const apiKey = process.env.ANTHROPIC_API_KEY;\n    const authToken = process.env.ANTHROPIC_AUTH_TOKEN;\n\n    if (apiKey) {\n      userId = createHash('sha256').update(apiKey).digest('hex').slice(0, 16);\n    } else if (authToken) {\n      userId = createHash('sha256').update(authToken).digest('hex').slice(0, 16);\n    }\n  }\n\n  if (!userId) {\n    // Can't determine user, skip silently\n    process.exit(0);\n  }\n\n  // Send precompact notification to proxy\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 5000);\n\n    const response = await fetch(`${ASPY_API_URL}/api/hook/precompact`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ user_id: userId, trigger }),\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeout);\n\n    if (response.ok) {\n      // Output message for user (shown in Claude Code)\n      console.log(JSON.stringify({\n        systemMessage: `Aspy: PreCompact (${trigger})`,\n      }));\n    }\n  } catch {\n    // Silently ignore - don't block compact if proxy is down\n  }\n\n  process.exit(0);\n}\n\nmain();\n",
        "hooks/spy/session-end.js": "#!/usr/bin/env node\n/**\n * SessionEnd hook: Notify aspy proxy that session ended\n *\n * Called when Claude Code session ends (quit, clear, logout, etc).\n * Archives the session in the proxy for history tracking.\n *\n * Input (stdin): JSON with session_id, reason, etc.\n * Output: None needed (session is ending anyway)\n */\n\nimport { createHash } from 'crypto';\n\nconst ASPY_API_URL = process.env.ASPY_API_URL || 'http://127.0.0.1:8080';\n\nasync function main() {\n  // Read stdin\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = Buffer.concat(chunks).toString('utf8');\n\n  let sessionData;\n  try {\n    sessionData = JSON.parse(input);\n  } catch {\n    process.exit(0);\n  }\n\n  const sessionId = sessionData.session_id;\n  const reason = sessionData.reason || 'other';\n\n  if (!sessionId) {\n    process.exit(0);\n  }\n\n  // Compute user_id from API key (SHA-256, first 16 chars)\n  let userId = 'unknown';\n  const apiKey = process.env.ANTHROPIC_API_KEY;\n  const authToken = process.env.ANTHROPIC_AUTH_TOKEN;\n\n  if (apiKey) {\n    userId = createHash('sha256').update(apiKey).digest('hex').slice(0, 16);\n  } else if (authToken) {\n    userId = createHash('sha256').update(authToken).digest('hex').slice(0, 16);\n  }\n\n  // Send session end to proxy (fire-and-forget, very short timeout)\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 2000);\n\n    fetch(`${ASPY_API_URL}/api/session/end`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ session_id: sessionId, user_id: userId, reason }),\n      signal: controller.signal,\n    }).catch(() => {});\n\n    clearTimeout(timeout);\n  } catch {\n    // Silently ignore - session is ending anyway\n  }\n\n  process.exit(0);\n}\n\nmain();\n",
        "hooks/spy/session-start.js": "#!/usr/bin/env node\n/**\n * SessionStart hook: Register session with aspy proxy\n *\n * Called when Claude Code starts a new session. Sends session info to the\n * proxy so it can track sessions per-user and provide filtered stats.\n *\n * Input (stdin): JSON with session_id, source, etc.\n * Output: JSON with optional systemMessage\n */\n\nimport { createHash } from 'crypto';\n\nconst ASPY_API_URL = process.env.ASPY_API_URL || 'http://127.0.0.1:8080';\n\nasync function main() {\n  // Read stdin\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = Buffer.concat(chunks).toString('utf8');\n\n  let sessionData;\n  try {\n    sessionData = JSON.parse(input);\n  } catch {\n    process.exit(0);\n  }\n\n  const sessionId = sessionData.session_id;\n  const source = sessionData.source || 'startup';\n  const transcriptPath = sessionData.transcript_path || null;\n\n  if (!sessionId) {\n    process.exit(0);\n  }\n\n  // Compute user_id from API key or OAuth token (SHA-256, first 16 chars)\n  let userId = 'unknown';\n  const apiKey = process.env.ANTHROPIC_API_KEY;\n  const authToken = process.env.ANTHROPIC_AUTH_TOKEN;\n\n  if (apiKey) {\n    userId = createHash('sha256').update(apiKey).digest('hex').slice(0, 16);\n  } else if (authToken) {\n    userId = createHash('sha256').update(authToken).digest('hex').slice(0, 16);\n  }\n\n  // Send session start to proxy (fire-and-forget, don't block on failure)\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 5000);\n\n    const response = await fetch(`${ASPY_API_URL}/api/session/start`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        session_id: sessionId,\n        user_id: userId,\n        source: 'hook',\n        transcript_path: transcriptPath,\n      }),\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeout);\n\n    if (response.ok) {\n      const data = await response.json();\n      if (data.success) {\n        // Return context for Claude\n        console.log(JSON.stringify({\n          hookSpecificOutput: {\n            hookEventName: 'SessionStart',\n            additionalContext: `Session tracked by aspy (user: ${userId.slice(0, 8)})`,\n          },\n        }));\n      }\n    }\n  } catch {\n    // Silently ignore - don't block Claude Code if proxy is down\n  }\n\n  process.exit(0);\n}\n\nmain();\n",
        "hooks/spy/user-prompt.js": "#!/usr/bin/env node\n/**\n * UserPromptSubmit hook: Reconnect session on first message after proxy restart\n *\n * This hook fires on every user message. Its main purpose is to send the\n * transcript_path to Aspy, enabling session reconnection when the proxy\n * restarts while Claude Code is still running.\n *\n * Flow:\n * 1. Proxy restarts (CC still running, no SessionStart hook fires)\n * 2. User sends message\n * 3. This hook fires with transcript_path\n * 4. Aspy checks DB: \"Have I seen this transcript before?\"\n * 5. If yes: reconnect to existing session instead of creating new implicit one\n *\n * Input (stdin): JSON with session_id, transcript_path, prompt, etc.\n * Output: JSON (optional systemMessage)\n */\n\nimport { createHash } from 'crypto';\n\nconst ASPY_API_URL = process.env.ASPY_API_URL || 'http://127.0.0.1:8080';\n\nasync function main() {\n  // Read stdin\n  const chunks = [];\n  for await (const chunk of process.stdin) {\n    chunks.push(chunk);\n  }\n  const input = Buffer.concat(chunks).toString('utf8');\n\n  let hookData;\n  try {\n    hookData = JSON.parse(input);\n  } catch {\n    process.exit(0);\n  }\n\n  const transcriptPath = hookData.transcript_path;\n  const sessionId = hookData.session_id;\n\n  if (!transcriptPath) {\n    // No transcript path, nothing to reconnect\n    process.exit(0);\n  }\n\n  // Compute user_id from API key (same as session-start.js)\n  let userId = 'unknown';\n  const apiKey = process.env.ANTHROPIC_API_KEY;\n  const authToken = process.env.ANTHROPIC_AUTH_TOKEN;\n\n  if (apiKey) {\n    userId = createHash('sha256').update(apiKey).digest('hex').slice(0, 16);\n  } else if (authToken) {\n    userId = createHash('sha256').update(authToken).digest('hex').slice(0, 16);\n  }\n\n  // Send reconnect request to Aspy (fire-and-forget, don't block Claude)\n  try {\n    const controller = new AbortController();\n    const timeout = setTimeout(() => controller.abort(), 3000);\n\n    const response = await fetch(`${ASPY_API_URL}/api/session/reconnect`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        user_id: userId,\n        transcript_path: transcriptPath,\n        session_id: sessionId,\n      }),\n      signal: controller.signal,\n    });\n\n    clearTimeout(timeout);\n\n    if (response.ok) {\n      const data = await response.json();\n      if (data.reconnected) {\n        // Optionally inform Claude about reconnection\n        console.log(JSON.stringify({\n          hookSpecificOutput: {\n            hookEventName: 'UserPromptSubmit',\n            additionalContext: `Session reconnected: ${data.session_id} (${data.message})`,\n          },\n        }));\n      }\n    }\n  } catch {\n    // Silently ignore - don't block Claude if proxy is down or slow\n  }\n\n  process.exit(0);\n}\n\nmain();\n",
        "mcp-server/README.md": "# aspy-mcp\n\nMCP server for [Aspy](https://github.com/omgpointless/aspy) ‚Äî exposes session stats, context window, and memory recall to Claude Code.\n\n## Installation\n\n```bash\nclaude mcp add aspy -- npx -y aspy-mcp\n```\n\nOr with a custom proxy URL:\n\n```bash\nclaude mcp add aspy -e ASPY_URL=http://192.168.1.100:8080 -- npx -y aspy-mcp\n```\n\n## Requirements\n\n- [Aspy](https://github.com/omgpointless/aspy) running locally (default: `http://127.0.0.1:8080`)\n- Node.js 18+\n\n## Available Tools\n\n### Session Tools (Current Session)\n\n| Tool | Description |\n|------|-------------|\n| `aspy_stats` | Session statistics ‚Äî tokens, costs, tool calls |\n| `aspy_events` | Recent events ‚Äî tool calls, thinking, API usage |\n| `aspy_window` | Context window gauge ‚Äî % full, warning level |\n| `aspy_sessions` | List all active sessions |\n\n### Memory Tools (Cross-Session Recall)\n\n| Tool | Description |\n|------|-------------|\n| `aspy_recall` | **PRIMARY** ‚Äî Search all past sessions (semantic + keyword) |\n| `aspy_recall_thinking` | Search Claude's past reasoning |\n| `aspy_recall_prompts` | Search your past questions |\n| `aspy_recall_responses` | Search Claude's past answers |\n\n### Lifetime Tools\n\n| Tool | Description |\n|------|-------------|\n| `aspy_lifetime` | All-time usage stats across all sessions |\n| `aspy_embeddings` | Semantic search indexer status |\n\n## Usage\n\n```\n\"How many tokens have I used?\"     ‚Üí aspy_stats\n\"Am I running out of context?\"     ‚Üí aspy_window\n\"That thing about golf and nature\" ‚Üí aspy_recall (semantic handles fuzzy!)\n\"All-time usage\"                   ‚Üí aspy_lifetime\n```\n\n---\n\n## For Claude: Tool Selection Guide\n\n> This section is for you, Claude. Follow these guidelines.\n\n### Quick Reference\n\n| Need | Use |\n|------|-----|\n| Check context window % | `aspy_window` |\n| Session token/cost summary | `aspy_stats` |\n| Recent tool calls | `aspy_events` |\n| **Recover lost context** | `aspy_recall` ‚Üê Use this for memory! |\n| Find WHY something was decided | `aspy_recall_thinking` |\n| All-time usage summary | `aspy_lifetime` |\n\n### Memory Recall\n\n`aspy_recall` is THE tool for recovering lost context. It handles:\n- **Exact queries**: \"ContextState refactor\"\n- **Fuzzy queries**: \"that thing about golf and nature?\"\n\nIt automatically uses semantic search if embeddings are enabled, falling back to keyword-only if not.\n\n### Specialized Recall (When Needed)\n\nIf `aspy_recall` returns too much noise, narrow with:\n- `aspy_recall_thinking` ‚Äî \"You noticed this pattern was meta...\"\n- `aspy_recall_prompts` ‚Äî \"I said something about exhaustive patterns...\"\n- `aspy_recall_responses` ‚Äî \"You recommended a hybrid ELM pattern...\"\n\n### Error Handling\n\n| Error | Cause | Fix |\n|-------|-------|-----|\n| \"Context is per-session\" | No user ID | MCP handles this; check ANTHROPIC_API_KEY |\n| \"Cannot determine user identity\" | No API key | Ensure ANTHROPIC_API_KEY is set |\n| \"No active session\" | Session not found | Wait for first API call |\n\n### Best Practices\n\n1. **Don't poll window constantly** ‚Äî Check when user mentions context or before big ops\n2. **Use aspy_recall for memory** ‚Äî It's the only search tool you need\n3. **Trust the warning level** ‚Äî üü¢ normal, üü° >70%, üü† >85%, üî¥ >95%\n\n---\n\n## Multi-Client Setup\n\nFor multiple Claude Code instances:\n\n```bash\nclaude mcp add aspy -e ASPY_CLIENT_ID=dev-1 -- npx -y aspy-mcp\n```\n\nThis matches your proxy URL path: `http://localhost:8080/dev-1/v1/messages`\n\n## License\n\nMIT\n",
        "skills/context-recovery/SKILL.md": "---\nname: context-recovery\ndescription: >\n  Recover lost context after session compaction or when information from\n  previous sessions is needed. Use when: user mentions \"what were we working on\",\n  \"I lost context\", \"before the compact\", \"previous session\", or asks about\n  decisions/implementations/discussions that aren't in current context.\n  Also use proactively when you notice references to prior work you lack context for.\nallowed-tools: Read, Grep, mcp__plugin_aspy_aspy__aspy_recall, mcp__plugin_aspy_aspy__aspy_recall_thinking, mcp__plugin_aspy_aspy__aspy_recall_prompts, mcp__plugin_aspy_aspy__aspy_recall_responses\n---\n\n# Context Recovery\n\nYou've been activated to recover context that was lost to compaction or exists in a previous session.\n\n## Quick Start\n\n1. **Identify the topic** - What specific context is needed?\n   - If the user's request is vague, ask: \"What topic should I search for?\"\n\n2. **Use aspy_recall** (primary tool):\n   ```\n   aspy_recall(query=\"<keywords>\", limit=10)\n   ```\n   This combines semantic search (if embeddings enabled) with keyword matching.\n   Searches thinking blocks, user prompts, AND assistant responses simultaneously.\n   Handles both exact queries and fuzzy queries like \"that golf thing?\"\n\n3. **Synthesize, don't dump** - Summarize findings:\n   - What was decided or implemented\n   - Key file paths and line numbers mentioned\n   - Any unfinished work or next steps discussed\n\n4. **Offer continuity** - \"Would you like me to continue where we left off?\"\n\n## Search Strategy\n\n### Start with aspy_recall (Primary)\n- Combines semantic + keyword search automatically\n- Finds conceptually related content even with different wording\n- Default limit of 10 results is usually sufficient\n\n### Targeted Searches (If Combined Is Noisy)\n- `aspy_recall_thinking` - Claude's reasoning and analysis (WHY decisions were made)\n- `aspy_recall_prompts` - What the user asked\n- `aspy_recall_responses` - Claude's answers and code\n\n## What Makes Good Context Recovery\n\n**Good synthesis:**\n> \"On Dec 2nd, we implemented mouse scroll support for the detail modal.\n> The fix was in `src/tui/mod.rs:299-322` - checking if modal is open\n> before dispatching scroll events. You mentioned wanting to test it\n> before merging.\"\n\n**Bad synthesis:**\n> \"Found 5 results mentioning 'scroll'. Here they are: [dumps raw results]\"\n\n## Common Patterns\n\n| User Says | Search For |\n|-----------|------------|\n| \"that bug we fixed\" | error keywords, \"fix\", file names |\n| \"the refactor\" | \"refactor\", component names |\n| \"what we decided\" | \"decided\", \"approach\", \"pattern\" |\n| \"before compact\" | recent topics from today |\n| \"something about golf?\" | just search it - semantic will handle fuzzy |\n",
        "skills/context-recovery/advanced-strategies.md": "# Advanced Context Recovery Strategies\n\nRead this when basic searches aren't finding what you need.\n\n## Hybrid vs FTS-Only\n\n**Hybrid search** (`aspy_recall`) should be your first choice:\n- Combines semantic embeddings (understands meaning) with FTS5 (matches keywords)\n- Finds results even when terminology differs from what you're searching\n- Uses Reciprocal Rank Fusion (RRF) to merge both result sets\n\n**Fall back to FTS-only** (`aspy_recall_thinking`, `aspy_recall_prompts`, `aspy_recall_responses`) when:\n- Embeddings aren't available or not yet indexed\n- You need exact phrase matching with specific operators\n- Debugging why certain results aren't appearing\n\n## The Banana Problem\n\nIf the user previously asked \"search for banana\", that meta-question is now in the logs. Searching for \"banana\" will match both:\n1. The actual banana discussion (signal)\n2. The \"search for banana\" request (noise)\n\n**Mitigation:** Look for structural signals in results:\n- Code references (`file.rs:123`, function names)\n- Action language (\"implemented\", \"fixed\", \"decided\")\n- Technical specifics (versions, configs, error messages)\n\nResults with these markers are more likely to be substantive.\n\n## Time-Based Filtering\n\nUse `time_range` parameter when you know roughly when something happened:\n- `\"today\"` - Current day only\n- `\"last_3_days\"` - Recent work\n- `\"last_7_days\"` - This week\n- `\"last_30_days\"` - This month\n\n## Multi-Keyword Strategies\n\n**Phrase mode (default):** Exact phrase match\n```\ntopic: \"mouse scroll modal\"  // Finds exact phrase\n```\n\n**Natural mode:** OR-style, any keyword\n```\ntopic: \"scroll OR mouse OR modal\", mode: \"natural\"\n```\n\n**Raw FTS5 mode:** Full control\n```\ntopic: \"scroll NEAR/5 modal\", mode: \"raw\"  // Within 5 words\n```\n\n## When Combined Search Is Noisy\n\nSplit into targeted searches:\n\n1. **Search thinking first** - Claude's reasoning often has the most context\n2. **Search prompts** - What did the user actually ask?\n3. **Search responses** - What did Claude say/implement?\n\nCross-reference results to find the full picture.\n\n## Session Filtering\n\nIf you know which session to search:\n```\naspy_search(keyword: \"topic\", session: \"partial-session-id\")\n```\n\nPartial matches work - use first few characters of session ID.\n\n## Recovery from Nothing\n\nIf searches return empty:\n1. Ask user for ANY keyword they remember\n2. Try broader terms (component names, file names)\n3. Check if Aspy proxy was running during that session\n4. Consider the work might predate cortex storage\n"
      },
      "plugins": [
        {
          "name": "aspy",
          "source": "./",
          "description": "Observability and development tools for Claude Code sessions",
          "version": "0.2.0",
          "author": {
            "name": "aspy contributors",
            "url": "https://github.com/omgpointless/aspy"
          },
          "homepage": "https://github.com/omgpointless/aspy",
          "repository": "https://github.com/omgpointless/aspy",
          "license": "MIT",
          "keywords": [
            "observability",
            "proxy",
            "tui",
            "statistics",
            "cost-tracking"
          ],
          "category": "development",
          "categories": [
            "cost-tracking",
            "development",
            "observability",
            "proxy",
            "statistics",
            "tui"
          ],
          "install_commands": [
            "/plugin marketplace add omgpointless/aspy",
            "/plugin install aspy@aspy"
          ]
        }
      ]
    }
  ]
}