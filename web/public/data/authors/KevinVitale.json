{
  "author": {
    "id": "KevinVitale",
    "display_name": "Kevin Vitale",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/276137?v=4",
    "url": "https://github.com/KevinVitale",
    "bio": "A veteran of the mobile development community, now coding and designing our onchain future.\r\n\r\n#Ethereum",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 4,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "context-commit-marketplace",
      "version": null,
      "description": "Git-based context management plugin for Claude Code",
      "owner_info": {
        "name": "Kevin Vitale"
      },
      "keywords": [],
      "repo_full_name": "KevinVitale/context-commit",
      "repo_url": "https://github.com/KevinVitale/context-commit",
      "repo_description": "Persist your AI agent's session state entirely in git comments üìùü§ñ",
      "homepage": "",
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-13T04:06:43Z",
        "created_at": "2026-01-12T20:16:50Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 653
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 227
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 7713
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/README.md",
          "type": "blob",
          "size": 8118
        },
        {
          "path": "hooks/auto-extract-progress.sh",
          "type": "blob",
          "size": 8340
        },
        {
          "path": "hooks/capture-session.sh",
          "type": "blob",
          "size": 4689
        },
        {
          "path": "hooks/commit-msg",
          "type": "blob",
          "size": 688
        },
        {
          "path": "hooks/generate-progress-html.sh",
          "type": "blob",
          "size": 10073
        },
        {
          "path": "hooks/install-hooks.sh",
          "type": "blob",
          "size": 1479
        },
        {
          "path": "hooks/post-commit",
          "type": "blob",
          "size": 1911
        },
        {
          "path": "hooks/pre-commit",
          "type": "blob",
          "size": 3728
        },
        {
          "path": "hooks/pre-push",
          "type": "blob",
          "size": 1533
        },
        {
          "path": "hooks/prepare-commit-msg",
          "type": "blob",
          "size": 1116
        },
        {
          "path": "hooks/recover-context-progress.sh",
          "type": "blob",
          "size": 2443
        },
        {
          "path": "hooks/safe-context-update.sh",
          "type": "blob",
          "size": 1612
        },
        {
          "path": "hooks/update-progress.sh",
          "type": "blob",
          "size": 9555
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/context-add",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/context-add/SKILL.md",
          "type": "blob",
          "size": 5444
        },
        {
          "path": "skills/context-init",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/context-init/SKILL.md",
          "type": "blob",
          "size": 5395
        },
        {
          "path": "skills/context-progress",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/context-progress/SKILL.md",
          "type": "blob",
          "size": 9786
        },
        {
          "path": "skills/context-read",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/context-read/SKILL.md",
          "type": "blob",
          "size": 7626
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"context-commit-marketplace\",\n  \"description\": \"Git-based context management plugin for Claude Code\",\n  \"owner\": {\n    \"name\": \"Kevin Vitale\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"context-commit\",\n      \"source\": \"./\",\n      \"description\": \"Git-based context management workflow using commit messages for project documentation and progress tracking\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Kevin Vitale\"\n      },\n      \"repository\": \"https://github.com/KevinVitale/context-commit\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"git\", \"context\", \"documentation\", \"workflow\", \"commit\", \"project-management\"]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"context-commit\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Git-based context management workflow using commit messages for project documentation and progress tracking\",\n  \"author\": {\n    \"name\": \"Kevin Vitale\"\n  }\n}\n",
        "README.md": "# Context Commit\n\n**Git-native project documentation that Claude reads automatically.**\n\nStore requirements, workflows, and progress in git commits. No external docs. No sync issues. Claude loads everything on session start and resumes exactly where you left off.\n\n## Why This Matters\n\n- **Zero Setup Per Session**: Claude reads your project context automatically\n- **Auto Session Resume**: Every commit captures your work state - new sessions know exactly what you were doing\n- **Version Controlled**: Documentation evolves with your code\n- **Team Shareable**: Context lives in the repository\n\n## Quick Start\n\n```bash\n# 1. Install from marketplace\n/plugin marketplace add KevinVitale/context-commit\n/plugin install context-commit@context-commit-marketplace\n\n# 2. Initialize in your project\n# Claude: \"Initialize context workflow\"\n\n# 3. Install hooks for automatic session capture\n~/.claude/plugins/marketplaces/context-commit-marketplace/hooks/install-hooks.sh\n\n# Done. Work normally - context is captured automatically.\n```\n\n## How It Works\n\n**Three components:**\n\n1. **CLAUDE.md** - Index file that Claude reads automatically\n2. **[CONTEXT] commits** - Documentation stored in git commits with `[CONTEXT]` prefix\n3. **context-progress branch** - Mutable progress tracking with auto-captured session state\n\n**On every commit, the pre-commit hook automatically:**\n- Captures what you're working on (commit message, files modified, recent work)\n- Updates `context-progress` with a \"Current Session\" section\n- Runs tests and keeps branches synchronized\n\n**Result:** New Claude sessions instantly resume your work. No manual notes needed.\n\n## Skills\n\nUse these slash commands to manage your project context:\n\n- `/context-init` - Set up the workflow in a repository\n- `/context-add` - Add documentation (requirements, architecture, workflows)\n- `/context-progress` - Manually update progress (hooks handle this automatically)\n- `/context-read` - View all project context and current session\n\n## Example CLAUDE.md\n\n```markdown\nREAD THESE COMMIT MESSAGES FOR CONTEXT:\n 1. [e7b0129] Project requirements and technical specifications\n 2. [ae291fc] Development workflow and TDD practices\n 3. [context-progress] Current project progress (branch reference)\n\nSESSION INITIALIZATION:\n- Read the context-progress commit message using: `git log context-progress -1 --format=%B`\n- Acknowledge that you have read and understood the project context\n- Wait for the user's specific task request\n```\n\nClaude reads this automatically and loads all referenced commits.\n\n## Automatic Session Capture\n\n**Default behavior** (no action required):\n```bash\ngit commit -m \"Add JWT authentication\"\n# Hook automatically captures session state in context-progress\n```\n\n**Detailed notes** (for end-of-day commits):\n```bash\nCONTEXT_SESSION_PROMPT=1 git commit -m \"Complete auth system\"\n# Prompts for accomplishments, next steps, blockers\n```\n\n**What gets captured:**\n- Latest commit message and modified files\n- Recent work (last 3 commits)\n- Timestamp\n\n**Example captured session:**\n```markdown\n## Current Session (2026-01-12 17:45)\n**Latest Commit:** Add JWT token generation\n**Files Modified:**\n  - src/auth.ts\n  - src/middleware/auth.ts\n\n**Recent Work:**\n- Add JWT token generation (abc1234)\n- Update auth middleware (def5678)\n```\n\nNew sessions read this and know exactly what you were doing.\n\n## Git Hooks\n\nInstall with: `~/.claude/plugins/context-commit/hooks/install-hooks.sh`\n\n**Included hooks:**\n- `pre-commit` - Auto-captures session state, runs tests, enforces sync\n- `commit-msg` - Validates [CONTEXT] commit format\n- `post-commit` - Auto-generates progress.html visualization\n- `pre-push` - Ensures context-progress is synced\n- `prepare-commit-msg` - Provides templates\n\nSee `hooks/README.md` for details.\n\n## Best Practices\n\n**Creating [CONTEXT] commits:**\n```bash\ngit commit --allow-empty -m \"[CONTEXT] API Authentication Design\n\nUses JWT tokens with 15-minute expiry and refresh tokens.\n\n## Implementation\n- Access tokens in Authorization header\n- Refresh tokens in httpOnly cookies\n- Token rotation on refresh\n\n## Security\n- bcrypt for password hashing\n- Rate limiting on auth endpoints\n\"\n```\n\nThen update CLAUDE.md to reference the commit hash.\n\n**What belongs in [CONTEXT] commits:**\n- Requirements and specifications (immutable)\n- Architecture decisions (immutable)\n- Workflows and standards (immutable)\n\n**What belongs in context-progress:**\n- Task checklists (mutable)\n- Current session state (auto-captured)\n- Work-in-progress notes (mutable)\n\n## Auto-Extraction (New!)\n\nAutomatically extract structured progress from git history, inspired by `/compact`:\n\n```bash\n# Preview what will be extracted\n~/.claude/plugins/context-commit/hooks/update-progress.sh --preview\n\n# Update context-progress with auto-extracted content\n~/.claude/plugins/context-commit/hooks/update-progress.sh\n\n# Non-interactive mode (for CI/automation)\nCONTEXT_SKIP_EDIT=1 ~/.claude/plugins/context-commit/hooks/update-progress.sh\n```\n\n**What gets auto-extracted:**\n\n| Category | Description |\n|----------|-------------|\n| **Commits** | Categorized by type (feature, fix, test, refactor) |\n| **File Changes** | Added, modified, deleted files |\n| **Issues Resolved** | Commits containing \"fix\", \"resolve\", etc. |\n| **Key References** | Functions, classes, structs added |\n\n**Merge modes:**\n- `smart` (default): Preserve your manual \"In Progress\" and \"Planned\" edits\n- `replace`: Use only auto-extracted content\n- `append`: Add auto-extracted as new section\n\n```bash\nCONTEXT_MERGE_MODE=replace ./update-progress.sh\n```\n\n## Manual Progress Updates (Optional)\n\nHooks handle this automatically. For manual control:\n\n```bash\ngit checkout context-progress\ngit rebase master\ngit commit --amend  # Edit checklist\ngit checkout master\n```\n\n## Installation Methods\n\n**Marketplace (Recommended):**\n```bash\n/plugin marketplace add KevinVitale/context-commit\n/plugin install context-commit@context-commit-marketplace\n```\n\n**Git Clone:**\n```bash\nmkdir -p ~/.claude/plugins\ngit clone https://github.com/KevinVitale/context-commit.git ~/.claude/plugins/context-commit\n```\n\n## Team Collaboration\n\n- Push [CONTEXT] commits normally - they're immutable\n- Force-push `context-progress` branch - it's safe and expected\n- Never force-push main/master\n- Coordinate CLAUDE.md updates to avoid conflicts\n\n## Troubleshooting\n\n**CLAUDE.md not found:**\nRun `/context-init` to create it.\n\n**Missing commit hash:**\n```bash\ngit log --oneline --grep=\"^\\[CONTEXT\\]\"\n```\n\n**Missing context-progress branch:**\n```bash\ngit checkout -b context-progress\ngit commit --allow-empty -m \"[CONTEXT] Project Progress\n\n## Completed ‚úì\n- [x] Initial setup\n\n## In Progress\n- [ ] Your tasks\n\n## Planned\n- [ ] Future tasks\n\"\ngit checkout master\n```\n\n**Merge conflicts on rebase:**\n```bash\ngit status  # See conflicts\n# Resolve manually\ngit add .\ngit rebase --continue\ngit commit --amend\n```\n\n## Advanced Usage\n\n**Multiple progress branches:**\n```markdown\n - [context-progress-backend] Backend progress\n - [context-progress-frontend] Frontend progress\n```\n\n**Progress snapshots:**\n```bash\ngit commit --allow-empty -m \"[PROGRESS-SNAPSHOT] 2026-01-12\n\nMilestone: MVP complete\n\"\n```\n\n**Categorized context:**\n```markdown\n 1. [abc123] [REQ] User authentication requirements\n 2. [def456] [WORKFLOW] TDD practices\n 3. [ghi789] [ARCH] Database schema decisions\n```\n\n## Templates\n\nSee `templates/` directory:\n- `CLAUDE.md.template` - Starting template\n- `context-commit-template.md` - [CONTEXT] commit template\n- `progress-template.md` - Progress tracking template\n\n## License\n\nMIT License\n\n## Support\n\n- GitHub Issues: Report bugs or request features\n- Documentation: `hooks/README.md`\n\n---\n\nMade with Claude Code\n",
        "hooks/README.md": "# [CONTEXT] Git Hooks\n\nThis directory contains git hooks that enforce the project's development workflows.\n\n## ‚ú® New: Automatic Session Capture\n\nEvery commit now automatically captures your session state in context-progress, making sessions **resumable** for AI assistants!\n\n**What gets captured:**\n- üìù Latest commit message\n- üìÅ Files you modified\n- üîÑ Recent work history\n- ‚è∞ Timestamp\n\n**Result:** New Claude sessions can instantly resume where you left off by reading the \"Current Session\" section in context-progress.\n\n**Enable interactive mode for detailed notes:**\n```bash\nCONTEXT_SESSION_PROMPT=1 git commit -m \"Your message\"\n```\n\nSee [capture-session.sh](#capture-sessionsh) for details.\n\n## üõ°Ô∏è IMPORTANT: context-progress Branch Protection\n\nThe `context-progress` branch is **protected** against accidental destruction. Multiple safety mechanisms prevent data loss.\n\n### Automatic Protections\n\n1. **Pre-commit Hook Protection**\n   - Prevents non-[CONTEXT] commits on context-progress\n   - Creates automatic backup tags before any commit\n   - Enforces synchronization with master\n\n2. **Automatic Backups**\n   - Every commit on context-progress creates a timestamped backup tag\n   - Format: `context-progress-backup-YYYYMMDD-HHMMSS`\n   - Can be restored using `hooks/recover-context-progress.sh`\n\n### Safe Workflows\n\n**‚úÖ CORRECT: Update context-progress**\n```bash\n# Use the safe update script\n./hooks/safe-context-update.sh\n\n# Or manually with safety checks:\ngit checkout master              # Start on master\ngit checkout context-progress    # Switch to context-progress\ngit rebase master                # Rebase (safe - preserves progress commit)\ngit commit --amend              # Update progress checklist\ngit checkout master             # Return to master\n```\n\n**‚ùå DANGEROUS: Never do these on context-progress**\n```bash\ngit reset --hard master         # DESTROYS progress commit!\ngit reset --hard HEAD~1         # DESTROYS progress commit!\ngit rebase -i master            # Can accidentally drop progress commit\n```\n\n### Recovery from Accidents\n\nIf context-progress is accidentally destroyed:\n\n```bash\n# Run the recovery script\n./hooks/recover-context-progress.sh\n\n# It will show available backups and let you restore\n```\n\nView available backups:\n```bash\ngit tag -l \"context-progress-backup-*\"\n```\n\nManually restore from a backup:\n```bash\ngit branch -f context-progress context-progress-backup-YYYYMMDD-HHMMSS\n```\n\n---\n\n## Installation\n\nRun the installation script from the project root:\n\n```bash\n./hooks/install-hooks.sh\n```\n\nThis creates symlinks from `.git/hooks/` to the versioned hooks in this directory.\n\n## Hooks Overview\n\n### pre-commit\n**Purpose**: Enforce TDD workflow and automatic session capture\n\n**Checks**:\n- On master branch: Ensures `context-progress` is synchronized (not behind master)\n- **NEW**: Automatically captures session state when context-progress is behind\n- Runs all tests with strict concurrency (`swift test -Xswiftc -strict-concurrency=complete`)\n- Blocks commit if tests fail\n\n**Automatic Session Capture**:\n- When context-progress is behind, automatically runs `capture-session.sh`\n- Captures: latest commit message, modified files, recent work\n- Updates context-progress with \"Current Session\" section\n- Makes sessions resumable for new Claude sessions\n\n**Interactive Mode**:\nSet `CONTEXT_SESSION_PROMPT=1` to enable interactive prompts:\n```bash\nCONTEXT_SESSION_PROMPT=1 git commit -m \"Your commit message\"\n```\nYou'll be prompted for:\n- What you accomplished this session\n- Next steps\n- Blockers/questions\n\n**Why**: Guarantees that every commit has passing tests AND captures resumable session context.\n\n### commit-msg\n**Purpose**: Validate commit message format\n\n**Checks**:\n- `[CONTEXT]` commits must have at least 5 lines\n- Ensures documentation commits contain substantial content\n\n**Why**: Maintains quality of project knowledge base stored in git commits.\n\n### post-commit\n**Purpose**: Auto-generate progress visualization and provide reminders\n\n**Behavior on `context-progress` branch**:\n- Auto-generates `progress.html` from the [CONTEXT] commit message\n- Parses markdown checkboxes and creates styled HTML\n- Amends commit to include the generated HTML file\n\n**Behavior on `master` branch**:\n- Shows reminder to update `context-progress` branch after commits\n\n**Why**: Keeps progress tracking automated and visual.\n\n### prepare-commit-msg\n**Purpose**: Provide commit message guidance\n\n**Behavior**:\n- Populates editor with commit message template\n- Shows examples and formatting guidelines\n- Reminds about TDD requirements\n\n**Why**: Helps maintain consistent commit message style.\n\n### capture-session.sh\n**Purpose**: Automatic session state capture for resumable workflows\n\n**Behavior**:\n- Auto-captures current git state (files, commits, messages)\n- Updates context-progress with \"Current Session\" section\n- Preserves existing Completed/In Progress/Planned sections\n- Rebases context-progress and amends commit\n- Supports interactive mode via `CONTEXT_SESSION_PROMPT=1`\n\n**Auto-Captured Data**:\n- Latest commit message\n- Modified files (from staging area)\n- Recent commits (last 3)\n- Timestamp\n\n**Interactive Mode Additions**:\n- Custom accomplishments summary\n- Next steps\n- Blockers/questions\n\n**Why**: Makes every commit a potential session resumption point for AI assistants. New Claude sessions can read \"Current Session\" and immediately understand what was being worked on, what was accomplished, and what's next.\n\n### generate-progress-html.sh\n**Purpose**: Helper script for HTML generation\n\n**Behavior**:\n- Converts markdown from [CONTEXT] commit to styled HTML\n- Handles checkboxes `[x]` and `[ ]`, headers, lists, inline code\n- Adds timestamp and styling\n\n**Why**: Provides visual progress tracking that can be viewed in a browser.\n\n## Workflow\n\n### Making Changes on Master (With Automatic Session Capture)\n\n1. Make your changes\n2. Write tests (TDD workflow)\n3. Stage and commit:\n   ```bash\n   git add .\n   git commit -m \"Your commit message\"\n   ```\n4. Pre-commit hook automatically:\n   - Detects context-progress is behind\n   - **Captures session state** (files, commit msg, recent work)\n   - Updates context-progress with \"Current Session\" section\n   - Rebases context-progress onto current commit\n   - Runs tests\n5. Commit succeeds - **session is now resumable!**\n\n**Interactive Session Capture:**\nFor detailed session notes:\n```bash\nCONTEXT_SESSION_PROMPT=1 git commit -m \"Your commit message\"\n```\nYou'll be prompted to add:\n- Custom accomplishments\n- Next steps\n- Blockers/questions\n\n### Making Changes on Master (Manual Mode - Old Workflow)\n\nStill works if you prefer manual control:\n\n1. Make your changes\n2. Write tests (TDD workflow)\n3. Try to commit\n4. If `context-progress` is behind ‚Üí Hook auto-updates it\n5. Or update manually:\n   ```bash\n   git checkout context-progress\n   git rebase master\n   git commit --amend  # Edit progress checklist in commit message\n   git checkout master\n   ```\n6. Commit now succeeds (tests pass, progress synced)\n\n### Updating Progress\n\nWhen on `context-progress` and amending the [CONTEXT] commit:\n- Edit the markdown checklist in the commit message\n- Save and commit\n- `progress.html` is automatically generated and included\n- No manual HTML editing needed!\n\n## Bypassing Hooks\n\n**Not recommended**, but hooks can be bypassed with:\n```bash\ngit commit --no-verify\n```\n\nOnly use this for emergencies or when you understand the implications.\n\n## Uninstalling\n\nRemove the symlinks:\n```bash\nrm .git/hooks/pre-commit\nrm .git/hooks/commit-msg\nrm .git/hooks/post-commit\nrm .git/hooks/prepare-commit-msg\nrm .git/hooks/generate-progress-html.sh\n```\n\n## Troubleshooting\n\n**Hook doesn't run:**\n- Ensure hooks are executable: `chmod +x hooks/*`\n- Verify symlinks exist: `ls -la .git/hooks/`\n\n**Tests fail unexpectedly:**\n- Run tests manually: `swift test -Xswiftc -strict-concurrency=complete`\n- Check for uncommitted changes affecting tests\n\n**context-progress out of sync:**\n- Follow the workflow above to sync it\n- Check how many commits behind: `git rev-list context-progress..master --count`\n",
        "hooks/auto-extract-progress.sh": "#!/bin/bash\n# Auto-extract progress from git history\n# Generates structured progress content inspired by /compact's extraction patterns\n\nset -e\n\n# Configuration\nMAIN_BRANCH=\"${CONTEXT_MAIN_BRANCH:-master}\"\nPROGRESS_BRANCH=\"context-progress\"\nOUTPUT_FORMAT=\"${1:-markdown}\"  # markdown or json\n\n# Colors for terminal output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nNC='\\033[0m' # No Color\n\n# Check if context-progress exists\nif ! git rev-parse --verify \"$PROGRESS_BRANCH\" >/dev/null 2>&1; then\n    echo -e \"${RED}Error: $PROGRESS_BRANCH branch does not exist${NC}\" >&2\n    exit 1\nfi\n\n# Get the base commit (where context-progress diverged from main)\nget_base_commit() {\n    git merge-base \"$MAIN_BRANCH\" \"$PROGRESS_BRANCH\" 2>/dev/null || echo \"\"\n}\n\n# Get commits since last progress update\nget_new_commits() {\n    local base_commit\n    base_commit=$(get_base_commit)\n\n    if [ -z \"$base_commit\" ]; then\n        git log \"$MAIN_BRANCH\" --oneline -20\n    else\n        git log \"$base_commit\"..\"$MAIN_BRANCH\" --oneline\n    fi\n}\n\n# Categorize a commit by its message\ncategorize_commit() {\n    local msg=\"$1\"\n    local msg_lower\n    msg_lower=$(echo \"$msg\" | tr '[:upper:]' '[:lower:]')\n\n    # Priority order matters - check most specific first\n    if echo \"$msg_lower\" | grep -qE '\\[context\\]|context-progress'; then\n        echo \"context\"\n    elif echo \"$msg_lower\" | grep -qE '^fix|bug|resolve|patch|hotfix'; then\n        echo \"fix\"\n    elif echo \"$msg_lower\" | grep -qE '^test|add.*test|spec|coverage'; then\n        echo \"test\"\n    elif echo \"$msg_lower\" | grep -qE '^refactor|cleanup|reorganize|restructure'; then\n        echo \"refactor\"\n    elif echo \"$msg_lower\" | grep -qE '^doc|readme|comment|changelog'; then\n        echo \"docs\"\n    elif echo \"$msg_lower\" | grep -qE '^add|implement|create|new|feature|enhance'; then\n        echo \"feature\"\n    elif echo \"$msg_lower\" | grep -qE '^update|improve|modify|change|adjust'; then\n        echo \"update\"\n    elif echo \"$msg_lower\" | grep -qE '^remove|delete|deprecate'; then\n        echo \"remove\"\n    else\n        echo \"other\"\n    fi\n}\n\n# Extract file changes with stats\nget_file_changes() {\n    local base_commit\n    base_commit=$(get_base_commit)\n\n    if [ -z \"$base_commit\" ]; then\n        git diff --stat HEAD~10..HEAD 2>/dev/null | head -20\n    else\n        git diff --stat \"$base_commit\"..\"$MAIN_BRANCH\" 2>/dev/null | head -30\n    fi\n}\n\n# Get detailed file change list\nget_file_list() {\n    local base_commit\n    base_commit=$(get_base_commit)\n\n    if [ -z \"$base_commit\" ]; then\n        git diff --name-status HEAD~10..HEAD 2>/dev/null\n    else\n        git diff --name-status \"$base_commit\"..\"$MAIN_BRANCH\" 2>/dev/null\n    fi\n}\n\n# Extract issues/fixes from commit messages\nextract_issues_resolved() {\n    local commits\n    commits=$(get_new_commits)\n\n    echo \"$commits\" | while read -r line; do\n        local hash msg\n        hash=$(echo \"$line\" | cut -d' ' -f1)\n        msg=$(echo \"$line\" | cut -d' ' -f2-)\n\n        # Look for fix-related commits\n        if echo \"$msg\" | grep -qiE 'fix|resolve|patch|bug|issue|error'; then\n            echo \"- [$hash] $msg\"\n        fi\n    done\n}\n\n# Extract key code references from recent diffs\nextract_key_references() {\n    local base_commit\n    base_commit=$(get_base_commit)\n\n    if [ -z \"$base_commit\" ]; then\n        return\n    fi\n\n    # Find files with significant changes (functions/classes added)\n    git diff \"$base_commit\"..\"$MAIN_BRANCH\" --unified=0 2>/dev/null | \\\n        grep -E '^\\+\\+\\+|^\\+.*(func |class |struct |enum |protocol )' | \\\n        head -20 | while read -r line; do\n            if [[ \"$line\" == \"+++\"* ]]; then\n                current_file=\"${line#+++\\ }\"\n                current_file=\"${current_file#b/}\"\n            elif [[ -n \"$current_file\" ]]; then\n                # Extract function/class name\n                name=$(echo \"$line\" | grep -oE '(func|class|struct|enum|protocol) [a-zA-Z_][a-zA-Z0-9_]*' | head -1)\n                if [ -n \"$name\" ]; then\n                    echo \"- $current_file: $name\"\n                fi\n            fi\n        done\n}\n\n# Build categorized commit sections\n# Outputs: category|[hash] message (one per line)\n# Compatible with bash 3.x (no associative arrays)\nbuild_commit_sections() {\n    local commits\n    commits=$(get_new_commits)\n\n    # Categorize each commit and output as category|message\n    echo \"$commits\" | while read -r line; do\n        if [ -z \"$line\" ]; then continue; fi\n\n        local hash msg category\n        hash=$(echo \"$line\" | cut -d' ' -f1)\n        msg=$(echo \"$line\" | cut -d' ' -f2-)\n        category=$(categorize_commit \"$msg\")\n\n        echo \"$category|[$hash] $msg\"\n    done\n}\n\n# Generate markdown output\ngenerate_markdown() {\n    local timestamp\n    timestamp=$(date \"+%Y-%m-%d %H:%M\")\n\n    echo \"[CONTEXT] Project Progress\"\n    echo \"\"\n    echo \"Auto-extracted progress as of $timestamp\"\n    echo \"\"\n\n    # Recent Commits Section (categorized)\n    echo \"## Recent Commits\"\n    echo \"\"\n\n    local commits_data\n    commits_data=$(build_commit_sections)\n\n    # Group by category\n    local features fixes tests refactors updates others\n    features=$(echo \"$commits_data\" | grep \"^feature|\" | cut -d'|' -f2)\n    fixes=$(echo \"$commits_data\" | grep \"^fix|\" | cut -d'|' -f2)\n    tests=$(echo \"$commits_data\" | grep \"^test|\" | cut -d'|' -f2)\n    refactors=$(echo \"$commits_data\" | grep \"^refactor|\" | cut -d'|' -f2)\n    updates=$(echo \"$commits_data\" | grep \"^update|\" | cut -d'|' -f2)\n    others=$(echo \"$commits_data\" | grep -E \"^(other|docs|remove|context)\\|\" | cut -d'|' -f2)\n\n    if [ -n \"$features\" ]; then\n        echo \"### Features\"\n        echo \"$features\" | sed 's/^/- [x] /'\n        echo \"\"\n    fi\n\n    if [ -n \"$fixes\" ]; then\n        echo \"### Fixes\"\n        echo \"$fixes\" | sed 's/^/- [x] /'\n        echo \"\"\n    fi\n\n    if [ -n \"$tests\" ]; then\n        echo \"### Tests\"\n        echo \"$tests\" | sed 's/^/- [x] /'\n        echo \"\"\n    fi\n\n    if [ -n \"$refactors\" ]; then\n        echo \"### Refactoring\"\n        echo \"$refactors\" | sed 's/^/- [x] /'\n        echo \"\"\n    fi\n\n    if [ -n \"$updates\" ]; then\n        echo \"### Updates\"\n        echo \"$updates\" | sed 's/^/- [x] /'\n        echo \"\"\n    fi\n\n    if [ -n \"$others\" ]; then\n        echo \"### Other\"\n        echo \"$others\" | sed 's/^/- [x] /'\n        echo \"\"\n    fi\n\n    # File Changes Section\n    echo \"## File Changes\"\n    echo \"\"\n    echo \"\\`\\`\\`\"\n    get_file_list | head -20\n    echo \"\\`\\`\\`\"\n    echo \"\"\n\n    # Issues Resolved Section\n    local issues\n    issues=$(extract_issues_resolved)\n    if [ -n \"$issues\" ]; then\n        echo \"## Issues Resolved\"\n        echo \"\"\n        echo \"$issues\"\n        echo \"\"\n    fi\n\n    # Key References Section\n    local refs\n    refs=$(extract_key_references)\n    if [ -n \"$refs\" ]; then\n        echo \"## Key Code References\"\n        echo \"\"\n        echo \"$refs\"\n        echo \"\"\n    fi\n\n    # Placeholder sections for manual editing\n    echo \"## In Progress\"\n    echo \"\"\n    echo \"- [ ] (add current work here)\"\n    echo \"\"\n    echo \"## Planned\"\n    echo \"\"\n    echo \"- [ ] (add planned items here)\"\n    echo \"\"\n    echo \"---\"\n    echo \"Auto-extracted by context-commit. Review and edit before committing.\"\n}\n\n# Generate JSON output (for programmatic use)\ngenerate_json() {\n    local commits_json file_changes_json issues_json refs_json\n\n    # Build commits JSON\n    commits_json=\"[\"\n    local first=true\n    get_new_commits | while read -r line; do\n        if [ -z \"$line\" ]; then continue; fi\n\n        local hash msg category\n        hash=$(echo \"$line\" | cut -d' ' -f1)\n        msg=$(echo \"$line\" | cut -d' ' -f2- | sed 's/\"/\\\\\"/g')\n        category=$(categorize_commit \"$msg\")\n\n        if [ \"$first\" = true ]; then\n            first=false\n        else\n            echo \",\"\n        fi\n        echo \"    {\\\"hash\\\": \\\"$hash\\\", \\\"message\\\": \\\"$msg\\\", \\\"category\\\": \\\"$category\\\"}\"\n    done\n    commits_json=\"$commits_json]\"\n\n    cat <<EOF\n{\n  \"extracted_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\n  \"main_branch\": \"$MAIN_BRANCH\",\n  \"commits\": $commits_json,\n  \"file_count\": $(get_file_list | wc -l | tr -d ' '),\n  \"issues_resolved\": $(extract_issues_resolved | wc -l | tr -d ' ')\n}\nEOF\n}\n\n# Main execution\ncase \"$OUTPUT_FORMAT\" in\n    json)\n        generate_json\n        ;;\n    markdown|md|*)\n        generate_markdown\n        ;;\nesac\n",
        "hooks/capture-session.sh": "#!/bin/bash\n# Capture session state for resumable [CONTEXT] workflow\n# Auto-captures git state with optional interactive mode\n\nset -e\n\n# Configuration\nINTERACTIVE_MODE=\"${CONTEXT_SESSION_PROMPT:-0}\"\nCURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\nTIMESTAMP=$(date \"+%Y-%m-%d %H:%M\")\n\n# Check if context-progress exists\nif ! git rev-parse --verify context-progress >/dev/null 2>&1; then\n    echo \"‚ö†Ô∏è  context-progress branch does not exist. Skipping session capture.\"\n    exit 0\nfi\n\n# Auto-capture git state\necho \"üì∏ Capturing session state...\"\n\n# Get the commit message being made (from staged commit)\nCOMMIT_MSG_FILE=\".git/COMMIT_EDITMSG\"\nLATEST_COMMIT_MSG=\"\"\nif [ -f \"$COMMIT_MSG_FILE\" ]; then\n    LATEST_COMMIT_MSG=$(head -n 1 \"$COMMIT_MSG_FILE\")\nfi\n\n# Get files that will be in this commit\nSTAGED_FILES=$(git diff --cached --name-only | head -10)\nif [ -z \"$STAGED_FILES\" ]; then\n    STAGED_FILES=\"(no files staged)\"\nfi\n\n# Get recent commits (last 3)\nRECENT_COMMITS=$(git log --oneline -3 --format=\"- %s (commit: %h)\" 2>/dev/null || echo \"- Initial commit\")\n\n# Interactive mode: prompt for additional context\nNEXT_STEPS=\"\"\nBLOCKERS=\"\"\nACCOMPLISHMENTS=\"\"\n\nif [ \"$INTERACTIVE_MODE\" = \"1\" ]; then\n    echo \"\"\n    echo \"üìù Session Capture (Interactive Mode)\"\n    echo \"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\"\n    echo \"\"\n\n    # Accomplishments\n    echo \"What did you accomplish this session?\"\n    echo \"(Press Enter to use commit message: \\\"$LATEST_COMMIT_MSG\\\")\"\n    read -r input\n    if [ -n \"$input\" ]; then\n        ACCOMPLISHMENTS=\"$input\"\n    else\n        ACCOMPLISHMENTS=\"$LATEST_COMMIT_MSG\"\n    fi\n\n    # Next steps\n    echo \"\"\n    echo \"Next steps? (Press Enter to skip)\"\n    read -r NEXT_STEPS\n\n    # Blockers\n    echo \"\"\n    echo \"Any blockers or questions? (Press Enter to skip)\"\n    read -r BLOCKERS\n\n    echo \"\"\nfi\n\n# Checkout context-progress and rebase\necho \"üîÑ Updating context-progress branch...\"\nORIGINAL_BRANCH=\"$CURRENT_BRANCH\"\ngit checkout context-progress -q\n\n# Rebase onto the branch we came from\nif ! git rebase \"$ORIGINAL_BRANCH\" -q; then\n    echo \"‚ùå Failed to rebase context-progress. Resolve conflicts manually.\"\n    exit 1\nfi\n\n# Read existing progress commit\nEXISTING_COMMIT=$(git log -1 --format=%B)\n\n# Extract existing sections (preserve Completed, In Progress, Planned sections)\nCOMPLETED_SECTION=\"\"\nIN_PROGRESS_SECTION=\"\"\nPLANNED_SECTION=\"\"\n\n# Simple extraction - look for major sections\nif echo \"$EXISTING_COMMIT\" | grep -q \"## Completed\"; then\n    COMPLETED_SECTION=$(echo \"$EXISTING_COMMIT\" | sed -n '/## Completed/,/^##/p' | sed '$d')\nfi\n\nif echo \"$EXISTING_COMMIT\" | grep -q \"## In Progress\"; then\n    IN_PROGRESS_SECTION=$(echo \"$EXISTING_COMMIT\" | sed -n '/## In Progress/,/^##/p' | sed '$d')\nfi\n\nif echo \"$EXISTING_COMMIT\" | grep -q \"## Planned\"; then\n    PLANNED_SECTION=$(echo \"$EXISTING_COMMIT\" | sed -n '/## Planned/,/^##/p' | sed '$d')\nfi\n\n# If sections are empty, use defaults\nif [ -z \"$COMPLETED_SECTION\" ]; then\n    COMPLETED_SECTION=\"## Completed ‚úì\n- [x] Initial setup\"\nfi\n\nif [ -z \"$IN_PROGRESS_SECTION\" ]; then\n    IN_PROGRESS_SECTION=\"## In Progress\n- [ ] Current work\"\nfi\n\nif [ -z \"$PLANNED_SECTION\" ]; then\n    PLANNED_SECTION=\"## Planned\n- [ ] Future items\"\nfi\n\n# Build new Current Session section\nSESSION_SECTION=\"## Current Session ($TIMESTAMP)\"\n\nif [ -n \"$LATEST_COMMIT_MSG\" ]; then\n    SESSION_SECTION=\"$SESSION_SECTION\n**Latest Commit:** $LATEST_COMMIT_MSG\"\nfi\n\nSESSION_SECTION=\"$SESSION_SECTION\n**Files Modified:**\n$(echo \"$STAGED_FILES\" | sed 's/^/  - /')\"\n\nif [ \"$INTERACTIVE_MODE\" = \"1\" ] && [ -n \"$ACCOMPLISHMENTS\" ]; then\n    SESSION_SECTION=\"$SESSION_SECTION\n\n**This Session:**\n- $ACCOMPLISHMENTS\"\nelse\n    SESSION_SECTION=\"$SESSION_SECTION\n\n**Recent Work:**\n$RECENT_COMMITS\"\nfi\n\nif [ -n \"$NEXT_STEPS\" ]; then\n    SESSION_SECTION=\"$SESSION_SECTION\n\n**Next Steps:**\n- $NEXT_STEPS\"\nfi\n\nif [ -n \"$BLOCKERS\" ]; then\n    SESSION_SECTION=\"$SESSION_SECTION\n\n**Questions/Blockers:**\n- $BLOCKERS\"\nfi\n\n# Build complete commit message\nNEW_COMMIT_MSG=\"[CONTEXT] Project Progress\n\n$SESSION_SECTION\n\n---\n\n$COMPLETED_SECTION\n\n$IN_PROGRESS_SECTION\n\n$PLANNED_SECTION\"\n\n# Amend the commit with new session info\ngit commit --amend -m \"$NEW_COMMIT_MSG\" --no-verify -q\n\necho \"‚úÖ Session captured in context-progress\"\n\n# Return to original branch\ngit checkout \"$ORIGINAL_BRANCH\" -q\n\n# Verify synchronization\nBEHIND=$(git rev-list context-progress..\"$ORIGINAL_BRANCH\" --count 2>/dev/null)\nif [ \"$BEHIND\" -eq 0 ]; then\n    echo \"‚úÖ context-progress is synchronized\"\nelse\n    echo \"‚ö†Ô∏è  Warning: context-progress still behind by $BEHIND commits\"\nfi\n\nexit 0\n",
        "hooks/commit-msg": "#!/bin/bash\n# [CONTEXT] commit-msg hook\n# Validates [CONTEXT] commits are properly formatted\n\nCOMMIT_MSG_FILE=$1\nCOMMIT_MSG=$(cat \"$COMMIT_MSG_FILE\")\n\n# Check if this is a [CONTEXT] commit\nif [[ \"$COMMIT_MSG\" =~ ^\\[CONTEXT\\] ]]; then\n    # Ensure [CONTEXT] commits have substantial content\n    LINE_COUNT=$(echo \"$COMMIT_MSG\" | wc -l)\n    if [ \"$LINE_COUNT\" -lt 5 ]; then\n        echo \"\"\n        echo \"‚ùå [CONTEXT] commits must contain detailed information\"\n        echo \"   Current commit has only $LINE_COUNT lines\"\n        echo \"   Add more context to explain the purpose and details.\"\n        echo \"\"\n        exit 1\n    fi\n    echo \"‚úÖ [CONTEXT] commit format validated\"\nfi\n\nexit 0\n",
        "hooks/generate-progress-html.sh": "#!/bin/bash\n# Generates progress.html from the current [CONTEXT] commit message\n\n# Get the current commit message\nCOMMIT_MSG=$(git log -1 --pretty=%B)\n\n# Check if this is a [CONTEXT] commit\nif [[ ! \"$COMMIT_MSG\" =~ ^\\[CONTEXT\\] ]]; then\n    echo \"Not a [CONTEXT] commit, skipping HTML generation\"\n    exit 0\nfi\n\n# Get git info\nGIT_COMMIT=$(git rev-parse HEAD)\nGIT_AUTHOR=$(git log -1 --format='%an <%ae>')\nGIT_DATE=$(git log -1 --format=%cd --date=format:'%Y-%m-%d %H:%M:%S')\n\n# Generate HTML from markdown commit message\ncat > progress.html << 'HTML_START'\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>[CONTEXT] Project Progress</title>\n    <style>\n        * {\n            box-sizing: border-box;\n        }\n\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n            line-height: 1.6;\n            max-width: 1000px;\n            margin: 0 auto;\n            padding: 40px 20px;\n            background: #f5f7fa;\n            min-height: 100vh;\n        }\n\n        .container {\n            background: white;\n            padding: 50px;\n            border-radius: 4px;\n            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n            border: 1px solid #e5e7eb;\n        }\n\n        h1 {\n            color: #1a1a1a;\n            font-size: 2.5em;\n            font-weight: 700;\n            margin: 0 0 10px 0;\n        }\n\n        h1 + p {\n            color: #666;\n            font-size: 1.05em;\n            margin-bottom: 30px;\n            padding-bottom: 20px;\n            border-bottom: 1px solid #e5e7eb;\n        }\n\n        h2 {\n            color: #1a1a1a;\n            font-size: 1.6em;\n            font-weight: 700;\n            margin: 40px 0 20px 0;\n            padding: 12px 16px;\n            background: #fafafa;\n            border-left: 4px solid #3b82f6;\n            border-radius: 2px;\n        }\n\n        h3 {\n            color: #374151;\n            font-size: 1.15em;\n            font-weight: 600;\n            margin: 25px 0 15px 0;\n            padding-left: 12px;\n            border-left: 2px solid #d1d5db;\n        }\n\n        ul {\n            list-style: none;\n            padding-left: 0;\n            margin: 15px 0;\n        }\n\n        li {\n            margin: 8px 0;\n            padding: 10px 12px 10px 35px;\n            position: relative;\n            border-radius: 2px;\n            transition: background 0.15s ease;\n            background: transparent;\n            border-left: 2px solid transparent;\n        }\n\n        li:hover {\n            background: #f9fafb;\n        }\n\n        .completed {\n            border-left-color: #10b981;\n        }\n\n        .completed::before {\n            content: \"‚úì\";\n            position: absolute;\n            left: 10px;\n            top: 10px;\n            color: #10b981;\n            font-weight: 600;\n            font-size: 1em;\n        }\n\n        .pending {\n            border-left-color: #f59e0b;\n        }\n\n        .pending::before {\n            content: \"‚óã\";\n            position: absolute;\n            left: 10px;\n            top: 10px;\n            color: #f59e0b;\n            font-weight: 600;\n            font-size: 1em;\n        }\n\n        code {\n            background: #f1f5f9;\n            color: #e11d48;\n            padding: 3px 8px;\n            border-radius: 4px;\n            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;\n            font-size: 0.9em;\n            border: 1px solid #e2e8f0;\n        }\n\n        p {\n            color: #4a5568;\n            margin: 12px 0;\n            line-height: 1.8;\n        }\n\n        .summary {\n            background: #f0f9ff;\n            padding: 20px;\n            border-left: 3px solid #0ea5e9;\n            border-radius: 2px;\n            margin: 24px 0;\n            border: 1px solid #bae6fd;\n        }\n\n        .summary p {\n            margin: 8px 0;\n        }\n\n        .summary ul {\n            margin-top: 12px;\n        }\n\n        .summary li {\n            background: transparent;\n            border-left-color: #0ea5e9;\n        }\n\n        .git-info {\n            background: #1f2937;\n            color: #f9fafb;\n            padding: 16px 20px;\n            border-radius: 2px;\n            margin: 20px 0 30px 0;\n            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;\n            font-size: 0.9em;\n            line-height: 1.8;\n        }\n\n        .git-info-line {\n            margin: 4px 0;\n        }\n\n        .git-info-label {\n            color: #fbbf24;\n            font-weight: 600;\n        }\n\n        .git-info-value {\n            color: #f9fafb;\n        }\n\n        .section-card {\n            background: #fafafa;\n            border-radius: 2px;\n            padding: 24px;\n            margin: 24px 0;\n            border: 1px solid #e5e7eb;\n        }\n\n        .section-card.completed {\n            background: #f0fdf4;\n            border-color: #86efac;\n            border-left: 3px solid #10b981;\n        }\n\n        .section-card.in-progress {\n            background: #fffbeb;\n            border-color: #fde047;\n            border-left: 3px solid #f59e0b;\n        }\n\n        .footer {\n            margin-top: 50px;\n            padding-top: 24px;\n            border-top: 1px solid #e5e7eb;\n        }\n\n        .footer-text {\n            color: #6b7280;\n            font-size: 0.9em;\n            margin-bottom: 8px;\n        }\n\n        .footer-command {\n            background: #1f2937;\n            color: #f9fafb;\n            padding: 12px 16px;\n            border-radius: 2px;\n            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;\n            font-size: 0.85em;\n            margin: 12px 0;\n            border-left: 3px solid #3b82f6;\n        }\n\n        .timestamp {\n            color: #9ca3af;\n            font-size: 0.85em;\n            margin-top: 16px;\n            text-align: right;\n        }\n\n        @media (max-width: 768px) {\n            body {\n                padding: 20px 10px;\n            }\n\n            .container {\n                padding: 30px 20px;\n            }\n\n            h1 {\n                font-size: 2em;\n            }\n\n            h2 {\n                font-size: 1.5em;\n            }\n\n            h3 {\n                font-size: 1.2em;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\nHTML_START\n\n# Parse and convert markdown to HTML\necho \"$COMMIT_MSG\" | awk -v commit=\"$GIT_COMMIT\" -v author=\"$GIT_AUTHOR\" -v date=\"$GIT_DATE\" '\nBEGIN {\n    in_list = 0\n    in_section = 0\n    git_info_printed = 0\n    skip_rest = 0\n}\n\n# Convert [CONTEXT] title to h1\nNR == 1 {\n    title = substr($0, 11)  # Remove \"[CONTEXT] \" prefix\n    print \"<h1>\" title \"</h1>\"\n    next\n}\n\n# Print git info after title (git log style)\nNR == 2 && !git_info_printed {\n    print \"<div class=\\\"git-info\\\">\"\n    print \"  <div class=\\\"git-info-line\\\"><span class=\\\"git-info-label\\\">commit</span> <span class=\\\"git-info-value\\\">\" commit \"</span></div>\"\n    print \"  <div class=\\\"git-info-line\\\"><span class=\\\"git-info-label\\\">Author:</span> <span class=\\\"git-info-value\\\">\" author \"</span></div>\"\n    print \"  <div class=\\\"git-info-line\\\"><span class=\\\"git-info-label\\\">Date:</span>   <span class=\\\"git-info-value\\\">\" date \"</span></div>\"\n    print \"</div>\"\n    git_info_printed = 1\n}\n\n# Skip blank lines at start\n/^[[:space:]]*$/ && NR <= 3 { next }\n\n# Headers with section cards\n/^## / {\n    if (in_list) {\n        print \"</ul>\"\n        in_list = 0\n    }\n    if (in_section) {\n        print \"</div>\"  # Close previous section card\n    }\n    title = substr($0, 4)\n\n    # Determine section type for styling\n    if (title ~ /Completed/) {\n        print \"<div class=\\\"section-card completed\\\">\"\n    } else if (title ~ /In Progress/ || title ~ /To Do/) {\n        print \"<div class=\\\"section-card in-progress\\\">\"\n    } else if (title ~ /Current State/) {\n        print \"<div class=\\\"summary\\\">\"\n        in_section = 0  # Summary uses its own div, not section-card\n    } else {\n        print \"<div class=\\\"section-card\\\">\"\n    }\n\n    print \"<h2>\" title \"</h2>\"\n    if (title !~ /Current State/) {\n        in_section = 1\n    }\n    next\n}\n\n/^### / {\n    if (in_list) {\n        print \"</ul>\"\n        in_list = 0\n    }\n    title = substr($0, 5)\n    print \"<h3>\" title \"</h3>\"\n    next\n}\n\n# Checkboxes\n/^[[:space:]]*- \\[x\\]/ {\n    if (!in_list) {\n        print \"<ul>\"\n        in_list = 1\n    }\n    text = substr($0, index($0, \"]\") + 2)\n    print \"<li class=\\\"completed\\\">\" text \"</li>\"\n    next\n}\n\n/^[[:space:]]*- \\[ \\]/ {\n    if (!in_list) {\n        print \"<ul>\"\n        in_list = 1\n    }\n    text = substr($0, index($0, \"]\") + 2)\n    print \"<li class=\\\"pending\\\">\" text \"</li>\"\n    next\n}\n\n# Regular list items\n/^[[:space:]]*- / {\n    if (!in_list) {\n        print \"<ul>\"\n        in_list = 1\n    }\n    text = substr($0, index($0, \"- \") + 2)\n    # Check for inline code\n    gsub(/`([^`]+)`/, \"<code>\\\\1</code>\", text)\n    print \"<li>\" text \"</li>\"\n    next\n}\n\n# Horizontal rule - skip footer content\n/^---/ {\n    if (in_list) {\n        print \"</ul>\"\n        in_list = 0\n    }\n    # Set flag to skip remaining lines (footer content)\n    skip_rest = 1\n    next\n}\n\n# Skip lines after horizontal rule\nskip_rest {\n    next\n}\n\n# Paragraphs\n/./ {\n    if (in_list) {\n        print \"</ul>\"\n        in_list = 0\n    }\n    line = $0\n    # Check for inline code\n    gsub(/`([^`]+)`/, \"<code>\\\\1</code>\", line)\n    print \"<p>\" line \"</p>\"\n}\n\nEND {\n    if (in_list) {\n        print \"</ul>\"\n    }\n    if (in_section) {\n        print \"</div>\"  # Close last section card\n    }\n}\n' >> progress.html\n\n# Add footer with git update instructions\ncat >> progress.html << HTML_END\n        <div class=\"footer\">\n            <div class=\"footer-text\">Update this commit via rebase as work progresses.</div>\n            <div class=\"footer-command\">git branch -f context-progress HEAD</div>\n            <div class=\"timestamp\">Generated: $(date '+%Y-%m-%d %H:%M:%S')</div>\n        </div>\n    </div>\n</body>\n</html>\nHTML_END\n\necho \"‚úÖ Generated progress.html\"\n",
        "hooks/install-hooks.sh": "#!/bin/bash\n# [CONTEXT] Git Hooks Installation Script\n# Run this script to install the project's git hooks\n\nHOOKS_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nGIT_HOOKS_DIR=\"$(git rev-parse --git-dir)/hooks\"\n\necho \"Installing [CONTEXT] git hooks...\"\necho \"\"\n\n# Create symlinks for each hook\nfor hook in pre-commit commit-msg post-commit prepare-commit-msg pre-push; do\n    if [ -f \"$HOOKS_DIR/$hook\" ]; then\n        # Remove existing hook if it exists\n        if [ -e \"$GIT_HOOKS_DIR/$hook\" ]; then\n            echo \"  Removing existing $hook hook\"\n            rm \"$GIT_HOOKS_DIR/$hook\"\n        fi\n\n        # Create symlink\n        ln -s \"$HOOKS_DIR/$hook\" \"$GIT_HOOKS_DIR/$hook\"\n        echo \"  ‚úì Installed $hook\"\n    fi\ndone\n\n# Copy the helper script (not a hook itself)\nif [ -f \"$HOOKS_DIR/generate-progress-html.sh\" ]; then\n    cp \"$HOOKS_DIR/generate-progress-html.sh\" \"$GIT_HOOKS_DIR/generate-progress-html.sh\"\n    chmod +x \"$GIT_HOOKS_DIR/generate-progress-html.sh\"\n    echo \"  ‚úì Installed generate-progress-html.sh\"\nfi\n\necho \"\"\necho \"‚úÖ Git hooks installed successfully!\"\necho \"\"\necho \"Hooks enforce:\"\necho \"  - All tests must pass before commits (pre-commit)\"\necho \"  - context-progress must stay synchronized before commits (pre-commit)\"\necho \"  - context-progress must stay synchronized before pushes (pre-push)\"\necho \"  - [CONTEXT] commits must be detailed (5+ lines) (commit-msg)\"\necho \"  - Auto-generation of progress.html from context-progress (post-commit)\"\necho \"\"\n",
        "hooks/post-commit": "#!/bin/bash\n# [CONTEXT] post-commit hook\n# Auto-generates progress.html on context-progress branch\n# Reminds to update context-progress branch after master commits\n\n# Prevent infinite loop when amending\nif [ \"$CONTEXT_AMENDING_PROGRESS\" = \"1\" ]; then\n    exit 0\nfi\n\nCURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\nHOOK_DIR=\"$(dirname \"$0\")\"\n\n# On context-progress branch: auto-generate progress.html\nif [ \"$CURRENT_BRANCH\" = \"context-progress\" ]; then\n    COMMIT_MSG=$(git log -1 --pretty=%B)\n\n    # Only process [CONTEXT] commits\n    if [[ \"$COMMIT_MSG\" =~ ^\\[CONTEXT\\] ]]; then\n        echo \"\"\n        echo \"üìä Auto-generating progress.html from commit message...\"\n\n        # Generate progress.html\n        bash \"$HOOK_DIR/generate-progress-html.sh\"\n\n        # Check if progress.html was created/modified\n        if [ -f \"progress.html\" ]; then\n            # Stage the file\n            git add progress.html\n\n            # Check if there are changes to commit\n            if ! git diff --cached --quiet; then\n                # Amend the commit to include progress.html (set flag to prevent loop)\n                CONTEXT_AMENDING_PROGRESS=1 git commit --amend --no-edit --no-verify\n\n                echo \"‚úÖ progress.html added to commit\"\n            else\n                echo \"‚ÑπÔ∏è  progress.html unchanged\"\n            fi\n        fi\n        echo \"\"\n    fi\nfi\n\n# On master branch: remind to update context-progress\nif [ \"$CURRENT_BRANCH\" = \"master\" ]; then\n    COMMIT_MSG=$(git log -1 --pretty=%B)\n\n    # Skip reminder for [CONTEXT] commits\n    if [[ ! \"$COMMIT_MSG\" =~ ^\\[CONTEXT\\] ]]; then\n        echo \"\"\n        echo \"üìù Reminder: Consider updating context-progress branch\"\n        echo \"   git checkout context-progress\"\n        echo \"   git rebase master\"\n        echo \"   git commit --amend  # Update progress checklist\"\n        echo \"   git checkout master\"\n        echo \"\"\n    fi\nfi\n\nexit 0\n",
        "hooks/pre-commit": "#!/bin/bash\n# [CONTEXT] pre-commit hook\n# Enforces TDD workflow and context-progress synchronization\n\nCURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\n\n# PROTECTION: Prevent destructive commits on context-progress\nif [ \"$CURRENT_BRANCH\" = \"context-progress\" ]; then\n    # Backup context-progress before any commit\n    BACKUP_TAG=\"context-progress-backup-$(date +%s)\"\n    git tag \"$BACKUP_TAG\" context-progress 2>/dev/null\n\n    # Only allow [CONTEXT] commits on context-progress\n    COMMIT_MSG_FILE=\".git/COMMIT_EDITMSG\"\n    if [ -f \"$COMMIT_MSG_FILE\" ]; then\n        COMMIT_MSG=$(cat \"$COMMIT_MSG_FILE\")\n        if [[ ! \"$COMMIT_MSG\" =~ ^\\[CONTEXT\\] ]]; then\n            echo \"\"\n            echo \"‚ùå Direct commits on context-progress must be [CONTEXT] commits\"\n            echo \"   Current branch: context-progress\"\n            echo \"\"\n            echo \"   This branch is for progress tracking only.\"\n            echo \"   To make regular commits:\"\n            echo \"\"\n            echo \"   git checkout master\"\n            echo \"   # make your commits on master\"\n            echo \"   # then update context-progress via rebase + amend\"\n            echo \"\"\n            echo \"‚ö†Ô∏è  If you accidentally switched to this branch, run:\"\n            echo \"   git checkout master\"\n            echo \"\"\n            exit 1\n        fi\n    fi\nfi\n\n# Check context-progress synchronization (only on master)\nif [ \"$CURRENT_BRANCH\" = \"master\" ]; then\n    # Check if context-progress branch exists\n    if git rev-parse --verify context-progress >/dev/null 2>&1; then\n        # Count commits in master that aren't in context-progress\n        BEHIND=$(git rev-list context-progress..master --count 2>/dev/null)\n\n        if [ \"$BEHIND\" -gt 0 ]; then\n            echo \"\"\n            echo \"‚ö†Ô∏è  context-progress branch is out of date (behind by $BEHIND commits)\"\n            echo \"\"\n\n            # Auto-update context-progress with session capture\n            HOOK_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\n\n            if [ -x \"$HOOK_DIR/capture-session.sh\" ]; then\n                echo \"ü§ñ Auto-updating context-progress with session capture...\"\n                echo \"   (Set CONTEXT_SESSION_PROMPT=1 for interactive mode)\"\n                echo \"\"\n\n                # Call capture-session helper script\n                if ! \"$HOOK_DIR/capture-session.sh\"; then\n                    echo \"\"\n                    echo \"‚ùå Session capture failed. Update manually:\"\n                    echo \"\"\n                    echo \"   git checkout context-progress\"\n                    echo \"   git rebase master\"\n                    echo \"   git commit --amend  # Update progress checklist\"\n                    echo \"   git checkout master\"\n                    echo \"\"\n                    exit 1\n                fi\n                echo \"\"\n            else\n                echo \"‚ùå capture-session.sh not found or not executable\"\n                echo \"   Update progress manually:\"\n                echo \"\"\n                echo \"   git checkout context-progress\"\n                echo \"   git rebase master\"\n                echo \"   git commit --amend  # Update progress checklist\"\n                echo \"   git checkout master\"\n                echo \"\"\n                exit 1\n            fi\n        else\n            echo \"‚úÖ context-progress is synchronized\"\n        fi\n    else\n        echo \"‚ö†Ô∏è  context-progress branch does not exist\"\n    fi\nfi\n\necho \"üß™ Running tests with strict concurrency...\"\nswift test -Xswiftc -strict-concurrency=complete\n\nif [ $? -ne 0 ]; then\n    echo \"\"\n    echo \"‚ùå Tests failed. Commit rejected per TDD workflow.\"\n    echo \"   Fix failing tests before committing.\"\n    echo \"\"\n    exit 1\nfi\n\necho \"‚úÖ All tests passed\"\nexit 0\n",
        "hooks/pre-push": "#!/bin/bash\n# [CONTEXT] pre-push hook\n# Enforces context-progress synchronization before pushing\n\n# Read from stdin: <local ref> <local sha1> <remote ref> <remote sha1>\nwhile read local_ref local_sha remote_ref remote_sha; do\n    # Only check when pushing to master\n    if [[ \"$local_ref\" == \"refs/heads/master\" ]]; then\n        # Check if context-progress branch exists\n        if git rev-parse --verify context-progress >/dev/null 2>&1; then\n            # Count commits in master that aren't in context-progress\n            BEHIND=$(git rev-list context-progress..master --count 2>/dev/null)\n\n            if [ \"$BEHIND\" -gt 0 ]; then\n                echo \"\"\n                echo \"‚ùå Cannot push to master: context-progress branch is out of sync\"\n                echo \"   context-progress is behind master by $BEHIND commit(s)\"\n                echo \"\"\n                echo \"   Update context-progress before pushing:\"\n                echo \"\"\n                echo \"   git checkout context-progress\"\n                echo \"   git rebase master\"\n                echo \"   git commit --amend  # Update progress checklist\"\n                echo \"   git checkout master\"\n                echo \"   git push origin context-progress --force\"\n                echo \"   git push  # Now you can push master\"\n                echo \"\"\n                exit 1\n            fi\n            echo \"‚úÖ context-progress is synchronized with master\"\n        else\n            echo \"‚ö†Ô∏è  context-progress branch does not exist\"\n        fi\n    fi\ndone\n\nexit 0\n",
        "hooks/prepare-commit-msg": "#!/bin/bash\n# [CONTEXT] prepare-commit-msg hook\n# Auto-populates commit message templates with guidance\n\nCOMMIT_MSG_FILE=$1\nCOMMIT_SOURCE=$2\n\n# Only run for regular commits (not merges, amendments, etc.)\nif [ -z \"$COMMIT_SOURCE\" ]; then\n    CURRENT_MSG=$(cat \"$COMMIT_MSG_FILE\")\n\n    # If message is empty or just comments, offer template\n    if [[ \"$CURRENT_MSG\" =~ ^[[:space:]]*# ]] || [ -z \"$CURRENT_MSG\" ]; then\n        cat > \"$COMMIT_MSG_FILE\" << 'EOF'\n\n# [CONTEXT] Commit Message Guide:\n#\n# For [CONTEXT] commits (project documentation):\n#   [CONTEXT] Brief descriptive title\n#\n#   Detailed explanation of the context, workflow, or pattern.\n#   Must be at least 5 lines to pass commit-msg validation.\n#\n# For regular commits (code changes):\n#   - Use present tense: \"Add feature\" not \"Added feature\"\n#   - Be specific and concise\n#   - Reference tests added/modified per TDD workflow\n#   - All tests must pass (pre-commit hook enforces this)\n#\n# Examples:\n#   \"Add 3-component query support with tests\"\n#   \"Implement system execution ordering\"\n#   \"Fix component removal race condition\"\nEOF\n    fi\nfi\n\nexit 0\n",
        "hooks/recover-context-progress.sh": "#!/bin/bash\n# Recovery script for context-progress branch\n# Restores from backup tags if accidentally destroyed\n\nset -e\n\necho \"üîç Searching for context-progress backup tags...\"\necho \"\"\n\n# Find all backup tags\nBACKUPS=$(git tag -l \"context-progress-backup-*\" | sort -r)\n\nif [ -z \"$BACKUPS\" ]; then\n    echo \"‚ùå No backup tags found\"\n    echo \"\"\n    echo \"   Backup tags are created automatically by:\"\n    echo \"   - pre-commit hook (before any commit on context-progress)\"\n    echo \"   - safe-context-update.sh script\"\n    echo \"\"\n    echo \"   If you've never committed on context-progress, no backups exist.\"\n    exit 1\nfi\n\necho \"üì¶ Available backups:\"\necho \"\"\n\n# Display backups with dates\nCOUNT=1\ndeclare -a TAG_ARRAY\nwhile IFS= read -r tag; do\n    TAG_ARRAY[$COUNT]=\"$tag\"\n    COMMIT_DATE=$(git log -1 --format=\"%ai\" \"$tag\" 2>/dev/null)\n    COMMIT_MSG=$(git log -1 --format=\"%s\" \"$tag\" 2>/dev/null | head -1)\n    echo \"  $COUNT. $tag\"\n    echo \"     Date: $COMMIT_DATE\"\n    echo \"     Message: $COMMIT_MSG\"\n    echo \"\"\n    COUNT=$((COUNT + 1))\ndone <<< \"$BACKUPS\"\n\necho \"Select a backup to restore (1-$((COUNT-1))), or 0 to cancel:\"\nread -r SELECTION\n\nif [ \"$SELECTION\" = \"0\" ]; then\n    echo \"‚ùå Cancelled\"\n    exit 0\nfi\n\nif [ \"$SELECTION\" -lt 1 ] || [ \"$SELECTION\" -ge \"$COUNT\" ]; then\n    echo \"‚ùå Invalid selection\"\n    exit 1\nfi\n\nSELECTED_TAG=\"${TAG_ARRAY[$SELECTION]}\"\n\necho \"\"\necho \"‚ö†Ô∏è  This will restore context-progress to: $SELECTED_TAG\"\necho \"   Current context-progress will be backed up first.\"\necho \"\"\necho \"Continue? (y/N):\"\nread -r CONFIRM\n\nif [ \"$CONFIRM\" != \"y\" ] && [ \"$CONFIRM\" != \"Y\" ]; then\n    echo \"‚ùå Cancelled\"\n    exit 0\nfi\n\n# Backup current state if context-progress exists\nif git rev-parse --verify context-progress >/dev/null 2>&1; then\n    CURRENT_BACKUP=\"context-progress-backup-before-restore-$(date +%Y%m%d-%H%M%S)\"\n    git tag \"$CURRENT_BACKUP\" context-progress\n    echo \"‚úÖ Current state backed up to: $CURRENT_BACKUP\"\nfi\n\n# Restore from backup tag\ngit branch -f context-progress \"$SELECTED_TAG\"\n\necho \"\"\necho \"‚úÖ context-progress restored from $SELECTED_TAG\"\necho \"\"\necho \"üìã Next steps:\"\necho \"   1. Verify the restored commit:\"\necho \"      git show context-progress\"\necho \"\"\necho \"   2. If correct, you may want to clean up old backups:\"\necho \"      git tag -d context-progress-backup-*\"\necho \"\"\necho \"   3. Force push if needed:\"\necho \"      git push origin context-progress --force\"\n",
        "hooks/safe-context-update.sh": "#!/bin/bash\n# Safe wrapper for updating context-progress branch\n# Prevents accidental data loss\n\nset -e\n\nCURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)\n\n# Ensure we're on master\nif [ \"$CURRENT_BRANCH\" != \"master\" ]; then\n    echo \"‚ùå Must be on master branch to update context-progress\"\n    echo \"   Current branch: $CURRENT_BRANCH\"\n    echo \"\"\n    echo \"   Run: git checkout master\"\n    exit 1\nfi\n\n# Ensure master is clean\nif ! git diff-index --quiet HEAD --; then\n    echo \"‚ùå Working directory has uncommitted changes\"\n    echo \"   Commit or stash changes before updating context-progress\"\n    exit 1\nfi\n\necho \"üîÑ Updating context-progress branch...\"\necho \"\"\n\n# Create backup tag before any operations\nBACKUP_TAG=\"context-progress-backup-$(date +%Y%m%d-%H%M%S)\"\ngit tag \"$BACKUP_TAG\" context-progress 2>/dev/null || true\necho \"‚úÖ Created backup tag: $BACKUP_TAG\"\n\n# Switch to context-progress\ngit checkout context-progress\n\n# Rebase onto master (safe - preserves progress commit)\necho \"üìù Rebasing context-progress onto master...\"\nif ! git rebase master; then\n    echo \"\"\n    echo \"‚ùå Rebase failed!\"\n    echo \"   Aborting rebase and returning to master...\"\n    git rebase --abort\n    git checkout master\n    exit 1\nfi\n\necho \"\"\necho \"‚úÖ context-progress successfully updated\"\necho \"\"\necho \"üìã Next steps:\"\necho \"   1. Edit the commit message to update progress:\"\necho \"      git commit --amend\"\necho \"\"\necho \"   2. Return to master:\"\necho \"      git checkout master\"\necho \"\"\necho \"üí° Backup tag available: $BACKUP_TAG\"\necho \"   (Delete old backups with: git tag -d context-progress-backup-*)\"\n",
        "hooks/update-progress.sh": "#!/bin/bash\n# Update context-progress with auto-extracted content\n# Combines auto-extraction (inspired by /compact) with safe git workflow\n\nset -e\n\n# Configuration\nMAIN_BRANCH=\"${CONTEXT_MAIN_BRANCH:-master}\"\nPROGRESS_BRANCH=\"context-progress\"\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\nAUTO_EXTRACT=\"$SCRIPT_DIR/auto-extract-progress.sh\"\n\n# Colors\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nBLUE='\\033[0;34m'\nCYAN='\\033[0;36m'\nBOLD='\\033[1m'\nNC='\\033[0m'\n\n# Flags\nSKIP_EDIT=\"${CONTEXT_SKIP_EDIT:-0}\"\nPREVIEW_ONLY=\"${1:-}\"\nMERGE_MODE=\"${CONTEXT_MERGE_MODE:-smart}\"  # smart, replace, append\n\nprint_header() {\n    echo \"\"\n    echo -e \"${BOLD}${CYAN}=== Context Progress Auto-Update ===${NC}\"\n    echo \"\"\n}\n\nprint_step() {\n    echo -e \"${BLUE}>>>${NC} $1\"\n}\n\nprint_success() {\n    echo -e \"${GREEN}[OK]${NC} $1\"\n}\n\nprint_warning() {\n    echo -e \"${YELLOW}[!]${NC} $1\"\n}\n\nprint_error() {\n    echo -e \"${RED}[X]${NC} $1\" >&2\n}\n\n# Check prerequisites\ncheck_prerequisites() {\n    # Check we're in a git repo\n    if ! git rev-parse --git-dir >/dev/null 2>&1; then\n        print_error \"Not in a git repository\"\n        exit 1\n    fi\n\n    # Check context-progress exists\n    if ! git rev-parse --verify \"$PROGRESS_BRANCH\" >/dev/null 2>&1; then\n        print_error \"$PROGRESS_BRANCH branch does not exist\"\n        echo \"\"\n        echo \"Initialize with: /context-init\"\n        exit 1\n    fi\n\n    # Check auto-extract script exists\n    if [ ! -x \"$AUTO_EXTRACT\" ]; then\n        print_error \"Auto-extract script not found: $AUTO_EXTRACT\"\n        exit 1\n    fi\n}\n\n# Get existing progress content\nget_existing_progress() {\n    git log \"$PROGRESS_BRANCH\" -1 --format=%B 2>/dev/null || echo \"\"\n}\n\n# Extract a section from existing progress\nextract_section() {\n    local content=\"$1\"\n    local section=\"$2\"\n\n    echo \"$content\" | awk -v section=\"$section\" '\n        $0 ~ \"^## \" section { found=1; next }\n        found && /^## / { found=0 }\n        found { print }\n    '\n}\n\n# Smart merge: preserve manual edits while adding new auto-extracted content\nsmart_merge() {\n    local auto_content=\"$1\"\n    local existing_content=\"$2\"\n\n    # Extract sections from existing content worth preserving\n    local existing_in_progress existing_planned existing_notes\n    existing_in_progress=$(extract_section \"$existing_content\" \"In Progress\")\n    existing_planned=$(extract_section \"$existing_content\" \"Planned\")\n    existing_notes=$(extract_section \"$existing_content\" \"Notes\")\n\n    # Start with auto-extracted content\n    local merged=\"$auto_content\"\n\n    # Replace placeholder \"In Progress\" if user has real content\n    if [ -n \"$existing_in_progress\" ] && ! echo \"$existing_in_progress\" | grep -q \"(add current work here)\"; then\n        merged=$(echo \"$merged\" | awk -v section=\"$existing_in_progress\" '\n            /^## In Progress/ { print; getline; print section; skip=1; next }\n            skip && /^## / { skip=0 }\n            !skip { print }\n        ')\n    fi\n\n    # Replace placeholder \"Planned\" if user has real content\n    if [ -n \"$existing_planned\" ] && ! echo \"$existing_planned\" | grep -q \"(add planned items here)\"; then\n        merged=$(echo \"$merged\" | awk -v section=\"$existing_planned\" '\n            /^## Planned/ { print; getline; print section; skip=1; next }\n            skip && /^## / { skip=0 }\n            !skip { print }\n        ')\n    fi\n\n    # Append Notes section if it exists\n    if [ -n \"$existing_notes\" ]; then\n        merged=\"$merged\n\n## Notes\n\n$existing_notes\"\n    fi\n\n    echo \"$merged\"\n}\n\n# Main update workflow\nupdate_progress() {\n    local current_branch\n    current_branch=$(git rev-parse --abbrev-ref HEAD)\n\n    # Ensure we're on main branch\n    if [ \"$current_branch\" != \"$MAIN_BRANCH\" ]; then\n        print_warning \"Not on $MAIN_BRANCH branch (current: $current_branch)\"\n        echo \"\"\n        read -p \"Switch to $MAIN_BRANCH? [Y/n] \" -n 1 -r\n        echo \"\"\n        if [[ $REPLY =~ ^[Nn]$ ]]; then\n            print_error \"Aborting. Switch to $MAIN_BRANCH first.\"\n            exit 1\n        fi\n        git checkout \"$MAIN_BRANCH\"\n    fi\n\n    # Check for uncommitted changes\n    if ! git diff-index --quiet HEAD -- 2>/dev/null; then\n        print_warning \"You have uncommitted changes\"\n        echo \"\"\n        git status --short\n        echo \"\"\n        read -p \"Continue anyway? [y/N] \" -n 1 -r\n        echo \"\"\n        if [[ ! $REPLY =~ ^[Yy]$ ]]; then\n            print_error \"Commit or stash changes first\"\n            exit 1\n        fi\n    fi\n\n    print_step \"Extracting progress from git history...\"\n    local auto_content\n    auto_content=$(\"$AUTO_EXTRACT\" markdown)\n\n    print_step \"Reading existing progress...\"\n    local existing_content\n    existing_content=$(get_existing_progress)\n\n    print_step \"Merging content (mode: $MERGE_MODE)...\"\n    local final_content\n    case \"$MERGE_MODE\" in\n        replace)\n            final_content=\"$auto_content\"\n            ;;\n        append)\n            final_content=\"$existing_content\n\n---\n## Auto-Extracted Update ($(date '+%Y-%m-%d'))\n\n$auto_content\"\n            ;;\n        smart|*)\n            final_content=$(smart_merge \"$auto_content\" \"$existing_content\")\n            ;;\n    esac\n\n    # Preview mode: just show content and exit\n    if [ \"$PREVIEW_ONLY\" = \"--preview\" ] || [ \"$PREVIEW_ONLY\" = \"-p\" ]; then\n        echo \"\"\n        echo -e \"${BOLD}=== Preview of auto-extracted progress ===${NC}\"\n        echo \"\"\n        echo \"$final_content\"\n        echo \"\"\n        print_success \"Preview complete. Run without --preview to apply.\"\n        exit 0\n    fi\n\n    # Create backup\n    local backup_tag=\"context-progress-backup-$(date +%Y%m%d-%H%M%S)\"\n    git tag \"$backup_tag\" \"$PROGRESS_BRANCH\" 2>/dev/null || true\n    print_success \"Created backup: $backup_tag\"\n\n    # Switch to context-progress\n    print_step \"Switching to $PROGRESS_BRANCH...\"\n    git checkout \"$PROGRESS_BRANCH\" -q\n\n    # Rebase onto main\n    print_step \"Rebasing onto $MAIN_BRANCH...\"\n    if ! git rebase \"$MAIN_BRANCH\" -q 2>/dev/null; then\n        print_warning \"Rebase conflict - attempting auto-resolution...\"\n        git rebase --abort 2>/dev/null || true\n        git reset --hard \"$MAIN_BRANCH\" -q\n        print_success \"Reset to $MAIN_BRANCH (progress will be regenerated)\"\n    fi\n\n    # Write content to temp file for editing\n    local tmpfile\n    tmpfile=$(mktemp)\n    echo \"$final_content\" > \"$tmpfile\"\n\n    if [ \"$SKIP_EDIT\" = \"1\" ]; then\n        # Non-interactive: commit directly\n        git commit --amend -m \"$final_content\" --no-verify -q\n        print_success \"Progress updated (non-interactive mode)\"\n    else\n        # Interactive: open editor\n        print_step \"Opening editor for review...\"\n        echo \"\"\n        echo -e \"${YELLOW}Review the auto-extracted progress and make any edits.${NC}\"\n        echo -e \"${YELLOW}The file will be used as the new progress commit message.${NC}\"\n        echo \"\"\n\n        # Use git's configured editor\n        local editor=\"${GIT_EDITOR:-${VISUAL:-${EDITOR:-vi}}}\"\n        \"$editor\" \"$tmpfile\"\n\n        # Commit with edited content\n        local edited_content\n        edited_content=$(cat \"$tmpfile\")\n        git commit --amend -m \"$edited_content\" --no-verify -q\n        print_success \"Progress updated with your edits\"\n    fi\n\n    rm -f \"$tmpfile\"\n\n    # Return to main branch\n    print_step \"Returning to $MAIN_BRANCH...\"\n    git checkout \"$MAIN_BRANCH\" -q\n\n    echo \"\"\n    print_success \"Context progress updated successfully!\"\n    echo \"\"\n    echo -e \"${CYAN}View progress:${NC} git log context-progress -1 --format=%B\"\n    echo -e \"${CYAN}Delete backup:${NC} git tag -d $backup_tag\"\n}\n\n# Show help\nshow_help() {\n    echo -e \"${BOLD}Context Progress Auto-Update${NC}\"\n    echo \"\"\n    echo \"Automatically extracts progress from git history and updates the\"\n    echo \"context-progress branch. Inspired by /compact's extraction patterns.\"\n    echo \"\"\n    echo -e \"${BOLD}Usage:${NC}\"\n    echo \"    update-progress.sh [OPTIONS]\"\n    echo \"\"\n    echo -e \"${BOLD}Options:${NC}\"\n    echo \"    --preview, -p    Show extracted content without applying\"\n    echo \"    --help, -h       Show this help message\"\n    echo \"\"\n    echo -e \"${BOLD}Environment Variables:${NC}\"\n    echo \"    CONTEXT_MAIN_BRANCH    Main branch name (default: master)\"\n    echo \"    CONTEXT_SKIP_EDIT      Skip editor, commit directly (default: 0)\"\n    echo \"    CONTEXT_MERGE_MODE     How to merge with existing content:\"\n    echo \"                           - smart: preserve manual edits (default)\"\n    echo \"                           - replace: use only auto-extracted content\"\n    echo \"                           - append: append to existing content\"\n    echo \"\"\n    echo -e \"${BOLD}What Gets Extracted:${NC}\"\n    echo \"    - Commits since last progress update (categorized)\"\n    echo \"    - File changes with status\"\n    echo \"    - Issues/fixes from commit messages\"\n    echo \"    - Key code references (functions, classes added)\"\n    echo \"\"\n    echo -e \"${BOLD}Examples:${NC}\"\n    echo \"    # Preview what will be extracted\"\n    echo \"    ./update-progress.sh --preview\"\n    echo \"\"\n    echo \"    # Update with editor review\"\n    echo \"    ./update-progress.sh\"\n    echo \"\"\n    echo \"    # Update without editor (CI/automation)\"\n    echo \"    CONTEXT_SKIP_EDIT=1 ./update-progress.sh\"\n    echo \"\"\n    echo \"    # Full replace mode\"\n    echo \"    CONTEXT_MERGE_MODE=replace ./update-progress.sh\"\n}\n\n# Main\nprint_header\n\ncase \"$1\" in\n    --help|-h)\n        show_help\n        ;;\n    *)\n        check_prerequisites\n        update_progress\n        ;;\nesac\n",
        "skills/context-add/SKILL.md": "---\nname: context-add\ndescription: Add new [CONTEXT] commits to document workflows, requirements, or architectural decisions, then update CLAUDE.md references\n---\n\n# Add Context Commits\n\nThis skill guides you through creating new [CONTEXT] commits to document project knowledge and updating CLAUDE.md to reference them.\n\n## When to Use\n\nUse this skill when:\n- Adding new project requirements or specifications\n- Documenting a new workflow or process\n- Recording architectural decisions\n- Adding coding standards or conventions\n- The user requests to \"add context\" or \"document workflow\"\n\n## Steps to Add Context\n\n### 1. Determine Context Type\n\nAsk the user what type of context they want to add:\n- **Requirements/Specifications**: Project goals, features, technical requirements\n- **Workflows**: Development processes, TDD practices, deployment procedures\n- **Architecture**: Design decisions, patterns, trade-offs, technical choices\n- **Standards**: Coding conventions, style guides, best practices\n- **Domain Knowledge**: Business logic, domain concepts, terminology\n\n### 2. Create the [CONTEXT] Commit\n\nCreate an empty commit with [CONTEXT] prefix and detailed message:\n\n```bash\ngit commit --allow-empty -m \"[CONTEXT] Brief title here\n\nDetailed explanation of the context.\n\n## Section 1\n- Point 1\n- Point 2\n\n## Section 2\n- More details\n- Guidelines\n- Examples\n\n## Notes\nAdditional information or rationale.\n\"\n```\n\n**Important**: Use `--allow-empty` to create documentation commits without file changes.\n\n### 3. Get the Commit Hash\n\nRetrieve the hash of the newly created commit:\n\n```bash\ngit log -1 --format=%H\n```\n\nOr for abbreviated hash:\n\n```bash\ngit log -1 --format=%h\n```\n\n### 4. Update CLAUDE.md\n\nRead the current CLAUDE.md and add the new commit reference:\n\n```bash\n# Read current CLAUDE.md\ncat CLAUDE.md\n```\n\nAdd a new line to the context list with format:\n```\n N. [commit-hash] Brief description\n```\n\nMaintain numbering sequence and keep context-progress as the last item.\n\n### 5. Verify the Addition\n\nConfirm the new context is accessible:\n\n```bash\n# Read the new context commit\ngit log [new-commit-hash] -1 --format=%B\n\n# Verify CLAUDE.md updated\ncat CLAUDE.md\n```\n\n## Best Practices\n\n### Context Commit Guidelines\n\n1. **Use [CONTEXT] Prefix**: Always start the commit message with `[CONTEXT]`\n2. **Descriptive Titles**: First line should briefly summarize the context topic\n3. **Structured Content**: Use markdown sections (##) to organize information\n4. **Self-Contained**: Each commit should be complete and understandable on its own\n5. **Immutable**: Once created, context commits should not be amended (create new ones instead)\n\n### CLAUDE.md Organization\n\n1. **Logical Ordering**: Group related context commits together\n2. **Brief Descriptions**: Keep the reference line concise but clear\n3. **Progress Last**: Always keep context-progress branch as the last reference\n4. **Session Instructions**: Maintain clear SESSION INITIALIZATION section\n\n### When to Create New vs Update Existing\n\n**Create New Context Commit When:**\n- Adding completely new topic or workflow\n- Context represents a significant change in approach\n- Want to preserve history of decision changes\n\n**Update Existing (via new commit):**\n- Refining or expanding existing context\n- Correcting outdated information\n- Evolution of a process or pattern\n\n## Example Context Commit Types\n\n### Requirements Example\n\n```bash\ngit commit --allow-empty -m \"[CONTEXT] API Authentication Requirements\n\nThe application must support multiple authentication methods:\n\n## Supported Methods\n- OAuth 2.0 (Google, GitHub)\n- JWT tokens for API access\n- API keys for service-to-service\n\n## Security Requirements\n- All tokens must expire within 24 hours\n- Refresh tokens valid for 30 days\n- Rate limiting: 1000 requests/hour per user\n\n## Implementation Notes\n- Use industry-standard libraries\n- Store tokens securely (encrypted at rest)\n- Implement token rotation\n\"\n```\n\n### Workflow Example\n\n```bash\ngit commit --allow-empty -m \"[CONTEXT] Code Review Process\n\nAll code changes must follow this review process:\n\n## Steps\n1. Create feature branch from main\n2. Implement with tests (TDD required)\n3. Self-review checklist before PR\n4. Submit PR with description and test evidence\n5. Address review feedback\n6. Require 2 approvals before merge\n7. Squash commits on merge\n\n## Review Focus Areas\n- Test coverage (minimum 80%)\n- Code clarity and documentation\n- Performance implications\n- Security considerations\n\n## Timeline\n- Reviews should complete within 24 hours\n- PRs open longer than 3 days need re-review\n\"\n```\n\n### Architecture Example\n\n```bash\ngit commit --allow-empty -m \"[CONTEXT] Database Architecture Decision\n\nWe chose PostgreSQL with the following schema design:\n\n## Decision Rationale\n- Need for complex queries and joins\n- ACID compliance required\n- Strong typing and constraints\n- JSON support for flexible data\n\n## Schema Pattern\n- Normalized relational design for core entities\n- JSONB columns for extensible metadata\n- Separate schemas for multi-tenancy\n\n## Trade-offs\n- More complex migrations vs MongoDB flexibility\n- Better data integrity vs NoSQL scalability\n- Chose consistency over eventual consistency\n\"\n```\n\n## After Adding Context\n\nRemind the user that:\n- New context is immediately available via git log\n- Claude will see it on next session (reads CLAUDE.md)\n- Context commits are immutable - create new ones to update\n- Push commits to share with team\n",
        "skills/context-init/SKILL.md": "---\nname: context-init\ndescription: Initialize the [CONTEXT] commit workflow in a git repository by creating CLAUDE.md and setting up the context-progress branch\n---\n\n# Context Commit Initialization\n\nThis skill helps you set up the [CONTEXT] commit workflow in a git repository. The workflow uses git commits with [CONTEXT] prefixes to store project documentation and instructions.\n\n## When to Use\n\nUse this skill when:\n- Starting a new project that needs structured context management\n- Converting an existing project to use the [CONTEXT] workflow\n- The user requests to \"initialize context workflow\" or \"set up CLAUDE.md\"\n\n## Initialization Steps\n\nWhen initializing the [CONTEXT] workflow, follow these steps:\n\n### 1. Create CLAUDE.md\n\nCreate a `CLAUDE.md` file in the repository root with the following structure:\n\n```markdown\nREAD THESE COMMIT MESSAGES FOR CONTEXT:\n 1. [commit-hash] Brief description of context topic\n 2. [commit-hash] Another context topic\n 3. [context-progress] Current project progress (branch reference)\n\nSESSION INITIALIZATION:\n- Read the context-progress commit message using: `git log context-progress -1 --format=%B`\n- Acknowledge that you have read and understood the project context\n- Wait for the user's specific task request\n- [Add any project-specific initialization instructions]\n```\n\n### 2. Create Initial [CONTEXT] Commits\n\nGuide the user to create initial context commits for:\n- **Project requirements and technical specifications** - Core project goals, technical stack, requirements\n- **Development workflows** - TDD practices, code standards, review processes\n- **Architecture decisions** - Design patterns, architectural choices, trade-offs\n\nFor each context commit:\n```bash\ngit commit --allow-empty -m \"[CONTEXT] Topic name\n\nDetailed context content goes here.\nCan span multiple lines and sections.\n\n## Example Section\n- Bullet points\n- Guidelines\n- Requirements\n\"\n```\n\n### 3. Create context-progress Branch\n\nCreate an orphan branch for progress tracking:\n\n```bash\n# Create orphan branch (no history)\ngit checkout --orphan context-progress\n\n# Remove all files from staging\ngit rm -rf .\n\n# Create the initial progress commit\ngit commit --allow-empty -m \"[CONTEXT] Project Progress\n\nThis commit tracks the current state of the project.\n\n## Completed ‚úì\n- [x] [CONTEXT] workflow initialized\n- [x] CLAUDE.md created\n\n## In Progress\n- [ ] (Add current work here)\n\n## Planned\n- [ ] (Add future tasks here)\n\n---\nUpdate this commit via: git commit --amend\n\"\n\n# Return to main branch\ngit checkout master  # or main\n```\n\n### 4. Update CLAUDE.md with Commit References\n\nAfter creating context commits, update CLAUDE.md with the actual commit hashes:\n\n```bash\n# Get the commit hash\ngit log --oneline -1 [commit-containing-context]\n\n# Update CLAUDE.md with the hash\n```\n\n### 5. Install Git Hooks (Recommended)\n\nInstall the workflow enforcement hooks:\n\n```bash\n# Run the hook installer from the plugin directory\n~/.claude/plugins/context-commit/hooks/install-hooks.sh\n```\n\nThe hooks will:\n- Run tests before commits (TDD enforcement)\n- Validate [CONTEXT] commit format\n- Keep context-progress synchronized\n- Auto-generate progress.html visualization\n- Protect against accidental data loss\n\n### 6. Verify Setup\n\nConfirm the setup works:\n\n```bash\n# Read CLAUDE.md\ncat CLAUDE.md\n\n# Read a context commit\ngit log [commit-hash] -1 --format=%B\n\n# Read progress\ngit log context-progress -1 --format=%B\n\n# Verify hooks are installed\nls -la .git/hooks/ | grep -E \"(pre-commit|commit-msg|post-commit|pre-push)\"\n```\n\n## Key Principles\n\n1. **Commit Messages as Documentation**: Use [CONTEXT] prefix for commits that contain instructions or documentation\n2. **CLAUDE.md as Index**: Keep CLAUDE.md lightweight - it just references commits\n3. **Branch-based Progress**: Use context-progress branch for mutable state (progress tracking)\n4. **Hash-based Context**: Use commit hashes for immutable context (requirements, workflows)\n5. **Version Controlled**: All context travels with the repository\n\n## Benefits\n\n- No external documentation files to maintain\n- Context is version controlled alongside code\n- Claude automatically reads CLAUDE.md on session start\n- Progress updates don't change CLAUDE.md (stable reference)\n- Shareable across teams and repositories\n\n## Example CLAUDE.md\n\n```markdown\nREAD THESE COMMIT MESSAGES FOR CONTEXT:\n 1. [abc1234] Project requirements and technical specifications\n 2. [def5678] Development workflow and TDD practices\n 3. [ghi9012] Architecture decisions and patterns\n 4. [context-progress] Current project progress (branch reference)\n\nSESSION INITIALIZATION:\n- Read the context-progress commit message using: `git log context-progress -1 --format=%B`\n- Acknowledge that you have read and understood the project context\n- Wait for the user's specific task request\n```\n\n## After Initialization\n\nOnce setup is complete, remind the user they can:\n- Use the `context-add` skill to add new context commits\n- Use the `context-progress` skill to update progress\n- Use the `context-read` skill to review current context\n- Install git hooks for workflow enforcement (see step 5 above)\n- Use helper scripts in `~/.claude/plugins/context-commit/hooks/`:\n  - `safe-context-update.sh` - Safe progress update workflow\n  - `recover-context-progress.sh` - Recover from accidental data loss\n  - `generate-progress-html.sh` - Generate browser-viewable progress\n",
        "skills/context-progress/SKILL.md": "---\nname: context-progress\ndescription: Update the context-progress branch to track project status, completed tasks, and current work using git commit --amend\n---\n\n# Update Project Progress\n\nThis skill guides you through updating the context-progress branch to reflect current project status.\n\n## When to Use\n\nUse this skill when:\n- Completing a significant task or milestone\n- Starting new work that should be tracked\n- Updating project status after a development session\n- The user requests to \"update progress\" or \"track status\"\n\n## Why context-progress Branch?\n\nThe context-progress branch uses a unique approach:\n- **Stable Reference**: CLAUDE.md references the branch name, not a commit hash\n- **Mutable State**: Progress changes frequently, so we amend one commit rather than creating many\n- **No Hash Updates**: Avoids needing to update CLAUDE.md constantly\n- **Clean History**: Keeps the main branch clean from progress tracking commits\n\n## Auto-Extraction (Recommended)\n\nThe auto-extraction feature automatically generates structured progress content from your git history,\ninspired by the `/compact` tool's extraction patterns.\n\n### Quick Start\n\n```bash\n# Preview what will be extracted (no changes made)\n~/.claude/plugins/context-commit/hooks/update-progress.sh --preview\n\n# Update with auto-extraction (opens editor for review)\n~/.claude/plugins/context-commit/hooks/update-progress.sh\n\n# Update without editor (for CI/automation)\nCONTEXT_SKIP_EDIT=1 ~/.claude/plugins/context-commit/hooks/update-progress.sh\n```\n\n### What Gets Auto-Extracted\n\n| Category | Description | Source |\n|----------|-------------|--------|\n| **Commits** | Categorized by type (feature, fix, test, refactor) | `git log` since last update |\n| **File Changes** | Added, modified, deleted files with stats | `git diff --name-status` |\n| **Issues Resolved** | Commits containing \"fix\", \"resolve\", etc. | Commit message parsing |\n| **Key References** | Functions, classes, structs added | Diff analysis |\n\n### Merge Modes\n\nControl how auto-extracted content merges with existing progress:\n\n```bash\n# Smart merge (default): preserve your manual \"In Progress\" and \"Planned\" edits\nCONTEXT_MERGE_MODE=smart ./update-progress.sh\n\n# Replace: use only auto-extracted content\nCONTEXT_MERGE_MODE=replace ./update-progress.sh\n\n# Append: add auto-extracted as new section\nCONTEXT_MERGE_MODE=append ./update-progress.sh\n```\n\n### Auto-Extracted Output Format\n\n```markdown\n[CONTEXT] Project Progress\n\nAuto-extracted progress as of 2026-01-12 15:30\n\n## Recent Commits\n\n### Features\n- [x] [abc1234] Add user authentication endpoint\n- [x] [def5678] Implement dark mode toggle\n\n### Fixes\n- [x] [ghi9012] Fix race condition in data loader\n\n### Tests\n- [x] [jkl3456] Add unit tests for auth module\n\n## File Changes\n\nM  src/auth/login.swift\nA  src/ui/darkmode.swift\nD  src/deprecated/oldauth.swift\n\n## Issues Resolved\n\n- [ghi9012] Fix race condition in data loader\n\n## Key Code References\n\n- src/auth/login.swift: func authenticate\n- src/ui/darkmode.swift: class ThemeManager\n\n## In Progress\n\n- [ ] (preserved from your previous edits)\n\n## Planned\n\n- [ ] (preserved from your previous edits)\n```\n\n### Standalone Extraction\n\nFor programmatic use or custom workflows:\n\n```bash\n# Generate markdown output\n~/.claude/plugins/context-commit/hooks/auto-extract-progress.sh markdown\n\n# Generate JSON output\n~/.claude/plugins/context-commit/hooks/auto-extract-progress.sh json\n```\n\n## Manual Update Workflow\n\nFor cases where auto-extraction isn't suitable, use manual methods:\n\n### Method 1: Simple Amend (Recommended)\n\nUse this when the context-progress branch is already on the latest work:\n\n```bash\n# Switch to context-progress branch\ngit checkout context-progress\n\n# Amend the progress commit with updated status\ngit commit --amend\n\n# This opens your editor to update the commit message\n\n# Switch back to main working branch\ngit checkout master  # or main\n```\n\n### Method 2: Rebase and Amend\n\nUse this when you've made new commits on master that should be included in progress:\n\n```bash\n# Ensure you're on your working branch (master/main)\ngit checkout master\n\n# Switch to context-progress\ngit checkout context-progress\n\n# Rebase onto master to include new work\ngit rebase master\n\n# Amend the progress commit with updated checklist\ngit commit --amend\n\n# Switch back to master\ngit checkout master\n```\n\n### Method 3: Force Update from Master\n\nUse this to reset context-progress to current master state, then update progress:\n\n```bash\n# On master after new work is committed\ngit checkout master\n\n# Force context-progress to match master\ngit branch -f context-progress master\n\n# Switch to context-progress\ngit checkout context-progress\n\n# Amend to update progress\ngit commit --amend\n\n# Back to master\ngit checkout master\n```\n\n## Progress Commit Structure\n\nThe progress commit should follow this template:\n\n```\n[CONTEXT] Project Name Progress\n\nThis commit tracks the current state of project development.\n\n## Completed ‚úì\n\n### Category 1\n- [x] Completed task 1\n- [x] Completed task 2\n- [x] Completed task 3\n\n### Category 2\n- [x] Another completed task\n- [x] More completed work\n\n## In Progress\n\n- [ ] Current task being worked on\n- [ ] Another active task\n\n## Planned\n\n- [ ] Future task 1\n- [ ] Future task 2\n- [ ] Future enhancement\n\n## Metrics (Optional)\n\n- Test Coverage: 85%\n- Performance: 1.2ms average\n- Build Status: Passing\n\n---\nUpdate this commit via: git commit --amend\nUpdate from master via: git rebase master && git commit --amend\n```\n\n## Best Practices\n\n### Checklist Guidelines\n\n1. **Use Markdown Checkboxes**: `- [x]` for done, `- [ ]` for pending\n2. **Group by Category**: Organize tasks into logical sections\n3. **Be Specific**: \"Implement user authentication\" not just \"Auth\"\n4. **Include Context**: Add enough detail to understand what was done\n5. **Update Regularly**: Keep progress current (daily or per session)\n\n### What to Track\n\n**Completed Section:**\n- Features implemented\n- Bugs fixed\n- Tests added\n- Documentation written\n- Performance improvements\n\n**In Progress Section:**\n- Current active work (1-3 tasks max)\n- Blocked tasks with blockers noted\n- Tasks started but not finished\n\n**Planned Section:**\n- Next tasks in the queue\n- Future features or improvements\n- Technical debt items\n- Nice-to-have enhancements\n\n### What NOT to Track\n\n- Minute-by-minute changes (too granular)\n- Temporary debugging steps\n- Work-in-progress that's not committed\n- Personal notes (use a separate system)\n\n## Updating After Completing Tasks\n\nWhen you complete tasks, follow this flow:\n\n```bash\n# 1. On master, do your work and commit normally\ngit add .\ngit commit -m \"Implement feature X\"\n\n# 2. Switch to context-progress\ngit checkout context-progress\n\n# 3. Rebase to include new work\ngit rebase master\n\n# 4. Amend the progress commit\ngit commit --amend\n# In editor, move completed tasks from \"In Progress\" to \"Completed ‚úì\"\n# Add new tasks to \"In Progress\" or \"Planned\"\n\n# 5. Back to master\ngit checkout master\n```\n\n## Reading Current Progress\n\nTo view current progress without switching branches:\n\n```bash\n# View the full progress commit\ngit log context-progress -1 --format=%B\n\n# Or just the commit message\ngit show context-progress --format=%B --no-patch\n```\n\n## Handling Conflicts\n\nIf rebase causes conflicts:\n\n```bash\n# On context-progress branch after rebase conflict\ngit status  # See conflicting files\n\n# Resolve conflicts in files\n# Then continue rebase\ngit add .\ngit rebase --continue\n\n# Amend progress commit\ngit commit --amend\n```\n\n## Sharing Progress\n\nThe context-progress branch can be pushed to share status with team:\n\n```bash\n# Push progress branch\ngit push origin context-progress --force\n\n# Force is needed because we amend the commit\n# This is safe because context-progress is a tracking branch, not a code branch\n```\n\n**Warning**: Only force-push the context-progress branch, never main/master!\n\n## Integration with Claude Sessions\n\nClaude reads progress automatically:\n1. CLAUDE.md references `context-progress` branch\n2. On session start, Claude runs `git log context-progress -1 --format=%B`\n3. Claude sees current status and completed work\n4. Can pick up where previous session left off\n\n## Example Progress Update Session\n\n```bash\n# Scenario: Just finished implementing authentication\n\n# 1. Commit the work on master\ngit add .\ngit commit -m \"Implement JWT authentication with refresh tokens\"\n\n# 2. Update progress\ngit checkout context-progress\ngit rebase master\ngit commit --amend\n\n# In the editor, update:\n# Move \"- [ ] Implement authentication\" to Completed ‚úì section\n# Change to \"- [x] Implement JWT authentication with refresh tokens\"\n# Add \"- [ ] Add rate limiting to auth endpoints\" to Planned\n\n# 3. Return to master\ngit checkout master\n```\n\n## Troubleshooting\n\n**Lost context-progress branch:**\n```bash\n# Recreate from master\ngit checkout -b context-progress master\ngit commit --allow-empty -m \"[CONTEXT] Project Progress\n\n## Completed ‚úì\n(Add items here)\n\n## In Progress\n(Add items here)\n\n## Planned\n(Add items here)\n\"\n```\n\n**Progress out of sync with master:**\n```bash\n# Reset context-progress to master, then amend\ngit branch -f context-progress master\ngit checkout context-progress\ngit commit --amend\n```\n\n**Want to keep progress history:**\n```bash\n# Don't use context-progress for historical tracking\n# Instead, create dated snapshot commits:\ngit commit --allow-empty -m \"[PROGRESS-SNAPSHOT] 2026-01-12 Status\n\n(Copy of progress at this point in time)\n\"\n```\n\n## Summary\n\n- context-progress is a special mutable branch for tracking status\n- Use `git commit --amend` to update progress without creating new commits\n- Rebase onto master to include new work before amending\n- Keep progress current and organized by category\n- Claude automatically reads progress on session start\n",
        "skills/context-read/SKILL.md": "---\nname: context-read\ndescription: Read and display project context from CLAUDE.md and all referenced [CONTEXT] commits for session initialization or review\n---\n\n# Read Project Context\n\nThis skill guides you through reading and understanding all project context stored in [CONTEXT] commits.\n\n## When to Use\n\nUse this skill when:\n- Starting a new Claude session with a project\n- User requests to \"show context\" or \"review project docs\"\n- Need to refresh understanding of project requirements\n- Verifying context setup is working correctly\n- Onboarding to an unfamiliar project\n\n## Context Reading Workflow\n\n### 1. Read CLAUDE.md\n\nStart by reading the context index:\n\n```bash\ncat CLAUDE.md\n```\n\nThis shows you:\n- List of context commit references\n- Session initialization instructions\n- Any project-specific guidance\n\n### 2. Extract Context References\n\nParse CLAUDE.md to identify:\n- Commit hashes that need to be read\n- Branch names (like context-progress)\n- Number and description of each context entry\n\nExample CLAUDE.md format:\n```\nREAD THESE COMMIT MESSAGES FOR CONTEXT:\n 1. [abc1234] Project requirements\n 2. [def5678] TDD workflow\n 3. [context-progress] Current progress\n```\n\n### 3. Read Each Context Commit\n\nFor each referenced commit, retrieve the full message:\n\n```bash\n# For commit hash references\ngit log [commit-hash] -1 --format=%B\n\n# For branch references (like context-progress)\ngit log [branch-name] -1 --format=%B\n\n# Example\ngit log abc1234 -1 --format=%B\ngit log context-progress -1 --format=%B\n```\n\n### 4. Organize and Summarize\n\nAfter reading all context, provide a summary organized by type:\n\n- **Requirements**: What the project needs to accomplish\n- **Technical Specs**: Technologies, platforms, versions\n- **Workflows**: Development processes, TDD, review practices\n- **Architecture**: Design decisions, patterns, trade-offs\n- **Progress**: Current status, completed work, next tasks\n\n### 5. Acknowledge Understanding\n\nConfirm you've read and understood the context:\n\n\"I've read all context commits and understand:\n- Project goals and requirements\n- Development workflow and TDD practices\n- Current progress and next tasks\n- [Any other key context areas]\n\nReady to assist with specific tasks.\"\n\n## Complete Read Example\n\nHere's a complete context reading flow:\n\n```bash\n# 1. Read the index\ncat CLAUDE.md\n\n# Output shows:\n# READ THESE COMMIT MESSAGES FOR CONTEXT:\n#  1. [e7b0129] Project requirements\n#  2. [ae291fc] Context pattern explanation\n#  3. [7cc3e39] TDD workflow\n#  4. [c8da0e3] Progress tracking workflow\n#  5. [context-progress] Current project progress\n\n# 2. Read each context commit\ngit log e7b0129 -1 --format=%B\ngit log ae291fc -1 --format=%B\ngit log 7cc3e39 -1 --format=%B\ngit log c8da0e3 -1 --format=%B\ngit log context-progress -1 --format=%B\n\n# 3. Summarize understanding\n# (Provide organized summary to user)\n```\n\n## Batch Reading Command\n\nTo read all context at once, use this helper:\n\n```bash\n# For a CLAUDE.md with known structure\nfor hash in e7b0129 ae291fc 7cc3e39 c8da0e3; do\n  echo \"=== Context: $(git log $hash -1 --format=%s) ===\"\n  git log $hash -1 --format=%B\n  echo \"\"\ndone\n\n# Read progress\necho \"=== Current Progress ===\"\ngit log context-progress -1 --format=%B\n```\n\n## Automated Context Loading\n\nClaude Code automatically reads CLAUDE.md on session start. This skill is useful for:\n- Manual verification\n- Re-reading during a session\n- Understanding unfamiliar projects\n- Debugging context setup\n\n## Context Types and What to Extract\n\n### From Requirements Context\n\nExtract:\n- Project goals and objectives\n- Target platforms and environments\n- Key features and functionality\n- Technical constraints\n- Success criteria\n\n### From Workflow Context\n\nExtract:\n- Development process (TDD, reviews, etc.)\n- Testing requirements\n- Code quality standards\n- Commit and PR conventions\n- Timeline expectations\n\n### From Architecture Context\n\nExtract:\n- Technology stack\n- Design patterns in use\n- Key architectural decisions\n- Trade-offs and rationale\n- Performance requirements\n\n### From Progress Context\n\nExtract:\n- Completed features/tasks\n- Current work in progress\n- Blocking issues\n- Next planned tasks\n- Status metrics (tests, coverage, etc.)\n\n## Verifying Context Integrity\n\nCheck that context setup is valid:\n\n```bash\n# 1. Verify CLAUDE.md exists\ntest -f CLAUDE.md && echo \"‚úì CLAUDE.md exists\" || echo \"‚úó CLAUDE.md missing\"\n\n# 2. Verify referenced commits exist\ngit log e7b0129 -1 --oneline > /dev/null 2>&1 && echo \"‚úì Commit exists\" || echo \"‚úó Commit not found\"\n\n# 3. Verify context-progress branch exists\ngit rev-parse --verify context-progress > /dev/null 2>&1 && echo \"‚úì context-progress branch exists\" || echo \"‚úó Branch missing\"\n\n# 4. Check commit messages have [CONTEXT] prefix\ngit log abc1234 -1 --format=%s | grep -q \"^\\[CONTEXT\\]\" && echo \"‚úì Has [CONTEXT] prefix\" || echo \"‚úó Missing [CONTEXT]\"\n```\n\n## Presenting Context to User\n\nWhen reading context for the user, structure the output:\n\n```\nüìã Project Context Summary\n\n## Requirements\n[Summary of project goals, features, technical specs]\n\n## Development Workflow\n[Summary of TDD, code standards, review process]\n\n## Architecture\n[Summary of design decisions, patterns, tech stack]\n\n## Current Progress\n[Summary of completed work, current tasks, next steps]\n\n## Key Takeaways\n- [Important point 1]\n- [Important point 2]\n- [Important point 3]\n\nI'm ready to help with specific tasks!\n```\n\n## Common Context Reading Patterns\n\n### Session Start Pattern\n\n```bash\n# Quick context refresh at session start\ncat CLAUDE.md\ngit log context-progress -1 --format=%B\n\n# Focus on progress to see where to pick up\n```\n\n### Deep Dive Pattern\n\n```bash\n# Read all context for complete understanding\ncat CLAUDE.md\n\n# Read each commit in detail\nfor ref in [list of all refs]; do\n  git log $ref -1 --format=%B\ndone\n\n# Summarize and ask clarifying questions\n```\n\n### Verification Pattern\n\n```bash\n# Check context setup is correct\ncat CLAUDE.md\ngit log context-progress -1 --oneline\ngit log [each-hash] -1 --oneline\n\n# Verify all references are valid\n```\n\n## Troubleshooting\n\n**CLAUDE.md not found:**\n```bash\n# Project may not have context workflow initialized\n# Recommend using context-init skill\n```\n\n**Commit hash not found:**\n```bash\n# Hash may be incorrect or from different repository\ngit log --oneline | grep CONTEXT  # Find actual context commits\n```\n\n**context-progress branch missing:**\n```bash\n# Check if it exists\ngit branch -a | grep context-progress\n\n# May need to initialize it\n# Use context-init skill\n```\n\n**Empty context commit:**\n```bash\n# Verify it's a [CONTEXT] commit\ngit log [hash] -1 --format=%s\n\n# Check the full message\ngit log [hash] -1 --format=%B\n```\n\n## Quick Reference Commands\n\n```bash\n# Read index\ncat CLAUDE.md\n\n# Read specific context commit\ngit log [hash] -1 --format=%B\n\n# Read progress\ngit log context-progress -1 --format=%B\n\n# List all [CONTEXT] commits\ngit log --oneline --grep=\"^\\[CONTEXT\\]\"\n\n# Show commit subject only\ngit log [hash] -1 --format=%s\n\n# Show commit body only\ngit log [hash] -1 --format=%b\n```\n\n## Integration with Other Skills\n\n- **After context-init**: Read context to verify setup\n- **After context-add**: Read new context commit to confirm\n- **Before context-progress**: Read current progress before updating\n- **Session start**: Always read to understand current state\n\n## Summary\n\nThe context-read skill helps you:\n- Efficiently load all project context\n- Verify context setup is working\n- Summarize and understand requirements, workflows, and progress\n- Get up to speed on unfamiliar projects\n- Provide clear acknowledgment of understanding to the user\n"
      },
      "plugins": [
        {
          "name": "context-commit",
          "source": "./",
          "description": "Git-based context management workflow using commit messages for project documentation and progress tracking",
          "version": "1.0.0",
          "author": {
            "name": "Kevin Vitale"
          },
          "repository": "https://github.com/KevinVitale/context-commit",
          "license": "MIT",
          "keywords": [
            "git",
            "context",
            "documentation",
            "workflow",
            "commit",
            "project-management"
          ],
          "categories": [
            "commit",
            "context",
            "documentation",
            "git",
            "project-management",
            "workflow"
          ],
          "install_commands": [
            "/plugin marketplace add KevinVitale/context-commit",
            "/plugin install context-commit@context-commit-marketplace"
          ]
        }
      ]
    }
  ]
}