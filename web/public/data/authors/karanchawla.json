{
  "author": {
    "id": "karanchawla",
    "display_name": "Karan Chawla",
    "avatar_url": "https://avatars.githubusercontent.com/u/15241546?u=c49cd5a2d3383ee98b81870c9bcd48529c135bf1&v=4"
  },
  "marketplaces": [
    {
      "name": "vvm",
      "version": null,
      "description": "A language for agentic programs where the LLM is the runtime",
      "repo_full_name": "karanchawla/vvm",
      "repo_url": "https://github.com/karanchawla/vvm",
      "repo_description": "vibe virtual machine",
      "signals": {
        "stars": 68,
        "forks": 47,
        "pushed_at": "2026-02-04T05:49:11Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"vvm\",\n  \"owner\": {\n    \"name\": \"Karan Chawla\",\n    \"url\": \"https://github.com/karanchawla\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"vvm\",\n      \"source\": \"./\",\n      \"description\": \"A language for agentic programs where the LLM is the runtime\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n    \"name\": \"vvm\",\n    \"description\": \"A language for agentic programs where the LLM is the runtime\",\n    \"version\": \"0.0.4\",\n    \"author\": {\n        \"name\": \"Karan Chawla\",\n        \"url\": \"https://github.com/karanchawla\"\n    },\n    \"repository\": \"https://github.com/karanchawla/vvm\",\n    \"keywords\": [\n        \"ai\",\n        \"agents\",\n        \"orchestration\",\n        \"dsl\",\n        \"vvm\",\n        \"workflow\",\n        \"multi-agent\",\n        \"llm\",\n        \"agentic\"\n    ]\n}",
        "README.md": "# VVM\n\n**Vibe Virtual Machine** — A language for agentic programs where the LLM is the runtime.\n\n```vvm\n# A code review bot that iteratively improves until approved\nagent coder(model=\"sonnet\", prompt=\"Write clean, well-tested code.\")\nagent reviewer(model=\"opus\", prompt=\"Review code critically. Find bugs and issues.\")\n\ndef is_approved(code, i):\n  review = @reviewer `Review this code. Say APPROVED if production-ready.`(code)\n  return ?`contains APPROVED`(review)\n\ndef improve(code, i):\n  feedback = @reviewer `List specific issues with this code.`(code)\n  return @coder `Fix these issues: {feedback}`(pack(code, feedback))\n\nfinal_code = refine(initial_code, max=5, done=is_approved, step=improve)\n\nconstrain final_code():\n  require ?`has error handling`\n  require ?`includes unit tests`\n\nexport final_code\n```\n\n---\n\n## The Insight\n\nA language model with tool access is a general-purpose computer. Not metaphorically. Literally.\n\nEvery time you use Claude Code, Cursor, or Codex, you're instructing a machine that reads files, writes code, executes commands, and iterates on its outputs. We've been calling these \"assistants\" because we didn't have better words. But assistants don't spawn subprocesses or manage their own control flow.\n\n**The problem with English.** Simple tasks work fine—\"refactor this function\" needs no specification. Complex tasks fall apart. You want three analyses to run in parallel, feed into a synthesis, retry on failure, and only proceed if the output meets a quality bar. You can say that in English. But which parts are instructions and which are suggestions? Which are hard constraints and which are preferences? English handles intent well. It can't handle structure.\n\n**Inversion.** Most frameworks (LangChain, etc.) put orchestration in your code and treat the model as a function to call. VVM inverts this. You write a program, hand it to the model, and the model becomes the runtime. The intelligence doesn't just execute steps—it interprets the program, manages dependencies, decides how to proceed when things go wrong.\n\n**Predicates that understand.** When orchestration lives in Python, conditions must be things Python can compute—proxy metrics like `if confidence_score > 0.8`. When orchestration lives in the model, conditions can be semantic. \"Is this production ready?\" isn't a threshold. It's a question the runtime answers by reading and judging. The program operates in meaning-space.\n\nVVM is open source and runtime-agnostic. Today it runs on Claude Code. Codex, Amp, and OpenCode support is planned.\n\n---\n\n## Installation\n\nVVM runs as a Claude Code plugin. To install:\n\n```bash\n# Add the plugin marketplace\nclaude plugin marketplace add https://github.com/karanchawla/vvm.git\n\n# Install the plugin\nclaude plugin install vvm@vvm\n```\n\nAfter installation, ask Claude to help you get started:\n\n> \"Run my first VVM example and teach me how it works\"\n\nClaude will walk you through the language, run an example program, and explain the execution.\n\n---\n\n## The Language\n\n### Agents\n\nNamed agents with models and system prompts:\n\n```vvm\nagent researcher(model=\"sonnet\", prompt=\"Research expert. Always cite sources.\")\nagent writer(model=\"opus\", prompt=\"Technical writer. Clear and concise.\")\n\nresearch = @researcher `Find papers on quantum error correction.`(())\nreport = @writer `Summarize the key findings.`(research)\n```\n\n### Agent Memory\n\nPortable, file-backed persistence for stateful agents:\n\n```vvm\nagent assistant(\n  model=\"sonnet\",\n  prompt=\"Helpful assistant.\",\n  memory={ scope: \"project\", key: \"user:alice\" },\n)\n\nreply = @assistant `Continue helping @Alice.`(request)\ndry = @assistant `Use memory but don't write.`(request, memory_mode=\"dry_run\")\nfresh = @assistant `Ignore memory.`(request, memory_mode=\"fresh\")\n```\n\n### Semantic Predicates\n\nConditions evaluated by the runtime's judgment, not regex:\n\n```vvm\nif ?`contains sensitive information`(document):\n  document = @redactor `Remove PII and confidential data.`(document)\n```\n\n### Pattern Matching\n\nRoute based on meaning:\n\n```vvm\nmatch ticket:\n  case ?`billing or payment issue`:\n    team = \"billing\"\n  case ?`security concern`:\n    team = \"security\"\n  case _:\n    team = \"general\"\n```\n\n### Constraints\n\nRequirements with automatic retry on failure:\n\n```vvm\nconstrain draft(attempts=3):\n  require ?`cites at least 3 sources`\n  require ?`no unsubstantiated claims`\n  require ?`professional tone`\n```\n\n### Parallelism\n\nExplicit, never implicit:\n\n```vvm\ndef translate(text):\n  return @translator `Translate to French.`(text)\n\ntranslations = pmap(documents, translate)  # Runs in parallel\n```\n\n### Refinement Loops\n\nIterate until done:\n\n```vvm\nfinal = refine(\n  seed=first_draft,\n  max=5,\n  done=is_publication_ready,\n  step=incorporate_feedback\n)\n```\n\n---\n\n## Execution Model\n\n1. **Parse** — Read `.vvm`, build AST\n2. **Validate** — Check syntax, resolve references, verify constraints\n3. **Execute** — Run statements top-to-bottom, eagerly\n4. **Spawn** — Agent calls (`@agent`) spawn subagents via Task tool\n5. **Evaluate** — Semantic predicates (`?`...``) judged by the runtime\n6. **Export** — Return declared exports\n\n```\n┌─────────────────────────────────────────────────┐\n│                   VVM Runtime                   │\n│                  (Claude LLM)                   │\n├─────────────────────────────────────────────────┤\n│  .vvm Program                                   │\n│  ├── agent definitions                          │\n│  ├── function definitions                       │\n│  └── top-level statements                       │\n├─────────────────────────────────────────────────┤\n│  Execution                                      │\n│  ├── @agent calls → spawn subagent (Task tool) │\n│  ├── ?`predicate` → local semantic judgment    │\n│  └── control flow → sequential, explicit       │\n└─────────────────────────────────────────────────┘\n```\n\n---\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/vvm-boot` | Initialize VVM, create first program |\n| `/vvm-compile <file>` | Validate without running |\n| `/vvm-run <file>` | Execute a program |\n\n---\n\n## Examples\n\nThe `examples/` directory has 28 programs, progressively introducing features:\n\n- **01-08**: Basics (agents, predicates, control flow)\n- **09-15**: Intermediate (parallelism, modules, error handling)\n- **16-23**: Advanced (constraints, refinement loops, full pipelines)\n- **24-28**: Agent memory (persistent agents + concurrency rules)\n\n---\n\n## Caveats\n\n**This is experimental.** The language spec will change. Breaking changes are likely. Pin versions if you care about stability.\n\n**You own your agents.** VVM programs spawn AI agents that can read files, make network requests, and execute code. Review what you're running. Test in sandboxes first. The authors disclaim liability for agent behavior—this is on you.\n\n---\n\n## Repository Structure\n\nThis repository contains the core VVM language:\n\n```\nvvm/\n├── skills/vvm/     # Language specification (spec.md, vvm.md)\n├── examples/       # 28 tutorial programs\n├── commands/       # Claude Code slash commands\n├── .claude/        # Claude Code integration\n└── .claude-plugin/ # Plugin manifest\n```\n\nThe website and application live in a separate repository: [vvm-app](https://github.com/karanchawla/vvm-app)\n\n---\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "vvm",
          "source": "./",
          "description": "A language for agentic programs where the LLM is the runtime",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add karanchawla/vvm",
            "/plugin install vvm@vvm"
          ]
        }
      ]
    }
  ]
}