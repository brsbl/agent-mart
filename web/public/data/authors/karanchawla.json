{
  "author": {
    "id": "karanchawla",
    "display_name": "Karan Chawla",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/15241546?u=c49cd5a2d3383ee98b81870c9bcd48529c135bf1&v=4",
    "url": "https://github.com/karanchawla",
    "bio": "Software Engineer, Zipline",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 1,
      "total_stars": 65,
      "total_forks": 46
    }
  },
  "marketplaces": [
    {
      "name": "vvm",
      "version": null,
      "description": "A language for agentic programs where the LLM is the runtime",
      "owner_info": {
        "name": "Karan Chawla",
        "url": "https://github.com/karanchawla"
      },
      "keywords": [],
      "repo_full_name": "karanchawla/vvm",
      "repo_url": "https://github.com/karanchawla/vvm",
      "repo_description": "vibe virtual machine",
      "homepage": null,
      "signals": {
        "stars": 65,
        "forks": 46,
        "pushed_at": "2026-01-28T07:05:00Z",
        "created_at": "2026-01-09T03:17:14Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 269
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 475
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 7827
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/vvm-boot.md",
          "type": "blob",
          "size": 339
        },
        {
          "path": "commands/vvm-compile.md",
          "type": "blob",
          "size": 1057
        },
        {
          "path": "commands/vvm-generate.md",
          "type": "blob",
          "size": 5678
        },
        {
          "path": "commands/vvm-run.md",
          "type": "blob",
          "size": 1943
        },
        {
          "path": "examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/README.md",
          "type": "blob",
          "size": 5130
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/vvm",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/vvm/SKILL.md",
          "type": "blob",
          "size": 7236
        },
        {
          "path": "skills/vvm/antipatterns.md",
          "type": "blob",
          "size": 13021
        },
        {
          "path": "skills/vvm/memory-spec.md",
          "type": "blob",
          "size": 14883
        },
        {
          "path": "skills/vvm/patterns.md",
          "type": "blob",
          "size": 11012
        },
        {
          "path": "skills/vvm/spec.md",
          "type": "blob",
          "size": 67202
        },
        {
          "path": "skills/vvm/vvm.md",
          "type": "blob",
          "size": 24863
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"vvm\",\n  \"owner\": {\n    \"name\": \"Karan Chawla\",\n    \"url\": \"https://github.com/karanchawla\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"vvm\",\n      \"source\": \"./\",\n      \"description\": \"A language for agentic programs where the LLM is the runtime\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n    \"name\": \"vvm\",\n    \"description\": \"A language for agentic programs where the LLM is the runtime\",\n    \"version\": \"0.0.4\",\n    \"author\": {\n        \"name\": \"Karan Chawla\",\n        \"url\": \"https://github.com/karanchawla\"\n    },\n    \"repository\": \"https://github.com/karanchawla/vvm\",\n    \"keywords\": [\n        \"ai\",\n        \"agents\",\n        \"orchestration\",\n        \"dsl\",\n        \"vvm\",\n        \"workflow\",\n        \"multi-agent\",\n        \"llm\",\n        \"agentic\"\n    ]\n}",
        "README.md": "# VVM\n\n**Vibe Virtual Machine** ‚Äî A language for agentic programs where the LLM is the runtime.\n\n```vvm\n# A code review bot that iteratively improves until approved\nagent coder(model=\"sonnet\", prompt=\"Write clean, well-tested code.\")\nagent reviewer(model=\"opus\", prompt=\"Review code critically. Find bugs and issues.\")\n\ndef is_approved(code, i):\n  review = @reviewer `Review this code. Say APPROVED if production-ready.`(code)\n  return ?`contains APPROVED`(review)\n\ndef improve(code, i):\n  feedback = @reviewer `List specific issues with this code.`(code)\n  return @coder `Fix these issues: {feedback}`(pack(code, feedback))\n\nfinal_code = refine(initial_code, max=5, done=is_approved, step=improve)\n\nconstrain final_code():\n  require ?`has error handling`\n  require ?`includes unit tests`\n\nexport final_code\n```\n\n---\n\n## The Insight\n\nA language model with tool access is a general-purpose computer. Not metaphorically. Literally.\n\nEvery time you use Claude Code, Cursor, or Codex, you're instructing a machine that reads files, writes code, executes commands, and iterates on its outputs. We've been calling these \"assistants\" because we didn't have better words. But assistants don't spawn subprocesses or manage their own control flow.\n\n**The problem with English.** Simple tasks work fine‚Äî\"refactor this function\" needs no specification. Complex tasks fall apart. You want three analyses to run in parallel, feed into a synthesis, retry on failure, and only proceed if the output meets a quality bar. You can say that in English. But which parts are instructions and which are suggestions? Which are hard constraints and which are preferences? English handles intent well. It can't handle structure.\n\n**Inversion.** Most frameworks (LangChain, etc.) put orchestration in your code and treat the model as a function to call. VVM inverts this. You write a program, hand it to the model, and the model becomes the runtime. The intelligence doesn't just execute steps‚Äîit interprets the program, manages dependencies, decides how to proceed when things go wrong.\n\n**Predicates that understand.** When orchestration lives in Python, conditions must be things Python can compute‚Äîproxy metrics like `if confidence_score > 0.8`. When orchestration lives in the model, conditions can be semantic. \"Is this production ready?\" isn't a threshold. It's a question the runtime answers by reading and judging. The program operates in meaning-space.\n\nVVM is open source and runtime-agnostic. Today it runs on Claude Code. Codex, Amp, and OpenCode support is planned.\n\n---\n\n## Installation\n\nVVM runs as a Claude Code plugin. To install:\n\n```bash\n# Add the plugin marketplace\nclaude plugin marketplace add https://github.com/karanchawla/vvm.git\n\n# Install the plugin\nclaude plugin install vvm@vvm\n```\n\nAfter installation, ask Claude to help you get started:\n\n> \"Run my first VVM example and teach me how it works\"\n\nClaude will walk you through the language, run an example program, and explain the execution.\n\n---\n\n## The Language\n\n### Agents\n\nNamed agents with models and system prompts:\n\n```vvm\nagent researcher(model=\"sonnet\", prompt=\"Research expert. Always cite sources.\")\nagent writer(model=\"opus\", prompt=\"Technical writer. Clear and concise.\")\n\nresearch = @researcher `Find papers on quantum error correction.`(())\nreport = @writer `Summarize the key findings.`(research)\n```\n\n### Agent Memory\n\nPortable, file-backed persistence for stateful agents:\n\n```vvm\nagent assistant(\n  model=\"sonnet\",\n  prompt=\"Helpful assistant.\",\n  memory={ scope: \"project\", key: \"user:alice\" },\n)\n\nreply = @assistant `Continue helping @Alice.`(request)\ndry = @assistant `Use memory but don't write.`(request, memory_mode=\"dry_run\")\nfresh = @assistant `Ignore memory.`(request, memory_mode=\"fresh\")\n```\n\n### Semantic Predicates\n\nConditions evaluated by the runtime's judgment, not regex:\n\n```vvm\nif ?`contains sensitive information`(document):\n  document = @redactor `Remove PII and confidential data.`(document)\n```\n\n### Pattern Matching\n\nRoute based on meaning:\n\n```vvm\nmatch ticket:\n  case ?`billing or payment issue`:\n    team = \"billing\"\n  case ?`security concern`:\n    team = \"security\"\n  case _:\n    team = \"general\"\n```\n\n### Constraints\n\nRequirements with automatic retry on failure:\n\n```vvm\nconstrain draft(attempts=3):\n  require ?`cites at least 3 sources`\n  require ?`no unsubstantiated claims`\n  require ?`professional tone`\n```\n\n### Parallelism\n\nExplicit, never implicit:\n\n```vvm\ndef translate(text):\n  return @translator `Translate to French.`(text)\n\ntranslations = pmap(documents, translate)  # Runs in parallel\n```\n\n### Refinement Loops\n\nIterate until done:\n\n```vvm\nfinal = refine(\n  seed=first_draft,\n  max=5,\n  done=is_publication_ready,\n  step=incorporate_feedback\n)\n```\n\n---\n\n## Execution Model\n\n1. **Parse** ‚Äî Read `.vvm`, build AST\n2. **Validate** ‚Äî Check syntax, resolve references, verify constraints\n3. **Execute** ‚Äî Run statements top-to-bottom, eagerly\n4. **Spawn** ‚Äî Agent calls (`@agent`) spawn subagents via Task tool\n5. **Evaluate** ‚Äî Semantic predicates (`?`...``) judged by the runtime\n6. **Export** ‚Äî Return declared exports\n\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ                   VVM Runtime                   ‚îÇ\n‚îÇ                  (Claude LLM)                   ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ  .vvm Program                                   ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ agent definitions                          ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ function definitions                       ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ top-level statements                       ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ  Execution                                      ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ @agent calls ‚Üí spawn subagent (Task tool) ‚îÇ\n‚îÇ  ‚îú‚îÄ‚îÄ ?`predicate` ‚Üí local semantic judgment    ‚îÇ\n‚îÇ  ‚îî‚îÄ‚îÄ control flow ‚Üí sequential, explicit       ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n---\n\n## Commands\n\n| Command | Description |\n|---------|-------------|\n| `/vvm-boot` | Initialize VVM, create first program |\n| `/vvm-compile <file>` | Validate without running |\n| `/vvm-run <file>` | Execute a program |\n\n---\n\n## Examples\n\nThe `examples/` directory has 28 programs, progressively introducing features:\n\n- **01-08**: Basics (agents, predicates, control flow)\n- **09-15**: Intermediate (parallelism, modules, error handling)\n- **16-23**: Advanced (constraints, refinement loops, full pipelines)\n- **24-28**: Agent memory (persistent agents + concurrency rules)\n\n---\n\n## Caveats\n\n**This is experimental.** The language spec will change. Breaking changes are likely. Pin versions if you care about stability.\n\n**You own your agents.** VVM programs spawn AI agents that can read files, make network requests, and execute code. Review what you're running. Test in sandboxes first. The authors disclaim liability for agent behavior‚Äîthis is on you.\n\n---\n\n## Repository Structure\n\nThis repository contains the core VVM language:\n\n```\nvvm/\n‚îú‚îÄ‚îÄ skills/vvm/     # Language specification (spec.md, vvm.md)\n‚îú‚îÄ‚îÄ examples/       # 28 tutorial programs\n‚îú‚îÄ‚îÄ commands/       # Claude Code slash commands\n‚îú‚îÄ‚îÄ .claude/        # Claude Code integration\n‚îî‚îÄ‚îÄ .claude-plugin/ # Plugin manifest\n```\n\nThe website and application live in a separate repository: [vvm-app](https://github.com/karanchawla/vvm-app)\n\n---\n\n## License\n\nMIT\n",
        "commands/vvm-boot.md": "---\ndescription: Initialize VVM and guide the user\n---\n\n# VVM Boot\n\nRead `skills/vvm/SKILL.md` for activation triggers, quick reference, and examples.\n\nThen:\n1. Search for `.vvm` files in the current directory\n2. If found, list them and offer to run or create new\n3. If none found, ask what the user wants to build and generate an example\n",
        "commands/vvm-compile.md": "---\ndescription: Validate and compile a VVM program\nargument-hint: <file.vvm>\n---\n\n# VVM Compile\n\nValidate a VVM program without executing it. This is static analysis only.\n\n## Phases\n\n1. **Parse** ‚Äî Tokenize and build AST per grammar (E001-E005)\n2. **Load Imports** ‚Äî Resolve `from \"path\" import ...`, check files exist (E090, E032)\n3. **Collect Declarations** ‚Äî Gather agents, functions, skill imports, exports (E010-E031)\n4. **Validate References** ‚Äî Check `@agent` refs, `{placeholders}`, variables (E040-E052)\n5. **Validate Control Flow** ‚Äî Check return/break/continue/try structure (E050-E082)\n6. **Warnings** ‚Äî Non-blocking issues like unused variables (W001-W031)\n\n## Output\n\n**Success:**\n```\n‚úÖ <file.vvm> is valid\n\nAgents: <count>\nFunctions: <count>\nExports: <list>\n```\n\n**Error:**\n```\n‚ùå Validation failed\n\nE0XX line N col C: description\n  <source line>\n  ^\n```\n\nIf no file specified, search for `.vvm` files and prompt user to select.\n\n## Files to Read\n\n- `skills/vvm/spec.md` - Complete grammar and error definitions (Section 16)\n",
        "commands/vvm-generate.md": "---\ndescription: Generate VVM programs from natural language descriptions\nargument-hint: <description of what you want to build>\n---\n\n# VVM Generate\n\nGenerate well-structured VVM programs from natural language descriptions. This command helps users transition from natural language prompting to VVM's structured agent orchestration.\n\n## Phases\n\n### Phase 1: Understand Intent\n\nRead the user's natural language description and infer:\n- The core goal (what should the program accomplish?)\n- Input requirements (what data does it need?)\n- Output expectations (what should it produce?)\n- Quality requirements (any constraints or standards?)\n\n**Do not ask clarifying questions.** Make reasonable assumptions based on the description and generate the program immediately.\n\n### Phase 2: Analyze Requirements\n\nMap the user's intent to VVM constructs:\n\n| User Intent | VVM Construct |\n|-------------|---------------|\n| \"Call an AI to do X\" | `@agent \\`prompt\\`(input)` |\n| \"Check if X is true\" | `?\\`condition\\`(value)` |\n| \"Route based on content type\" | `match value: case ?\\`pattern\\`:` |\n| \"AI picks best approach\" | `choose value by ?\\`criterion\\` as choice:` |\n| \"If X then Y else Z\" | `if`/`elif`/`else` |\n| \"Repeat until done\" | `while` with bounds or `refine()` |\n| \"Process each item\" | `for item in items:` |\n| \"Process items in parallel\" | `pmap(items, function)` |\n| \"Set context for operations\" | `with input value:` |\n| \"Handle failures gracefully\" | `match` on `error(_)` |\n| \"Guaranteed cleanup\" | `try`/`except`/`finally` |\n| \"Create agent variants\" | `.with()` or inline `@{...}` |\n| \"Reuse logic\" | `def function(params):` |\n| \"Use external tools\" | `import` + `skills=` + `permissions=` |\n| \"Transform a list\" | `map(items, fn)` |\n| \"Filter a list\" | `filter(items, predicate)` |\n| \"Aggregate results\" | `reduce(items, fn, init=value)` |\n| \"Combine multiple values\" | `pack(a, b, c)` |\n| \"Iteratively improve\" | `refine(seed, max=N, done=check, step=improve)` |\n| \"Enforce quality standards\" | `constrain value(): require ?\\`criterion\\`` |\n\n### Phase 3: Design Architecture\n\n1. **Identify agent roles** ‚Äî Each agent should have focused expertise\n2. **Choose model tiers** ‚Äî Match model to task complexity:\n   - `haiku`: Simple formatting, validation, extraction, classification\n   - `sonnet`: Research, analysis, standard generation (default)\n   - `opus`: Complex reasoning, synthesis, critical decisions\n3. **Plan data flow** ‚Äî How does data move between stages?\n4. **Identify parallelism** ‚Äî Which tasks are independent? Use `pmap()`\n5. **Plan error handling** ‚Äî What can fail? Add `retry=`, match on `error()`\n6. **Add quality gates** ‚Äî Use `constrain`/`require` for critical outputs\n\n### Phase 4: Generate Code\n\n**Apply these patterns** (from `skills/vvm/patterns.md`):\n- Agent Specialization: Each agent has one clear purpose\n- Pipeline Composition: Clear I/O at each stage\n- Model Tiering: Right model for task complexity\n- Explicit Data Flow: Don't over-rely on implicit `it`\n- Graceful Degradation: Handle failures with fallbacks\n- Bounded Iteration: Always set max limits on loops\n\n**Avoid these anti-patterns** (from `skills/vvm/antipatterns.md`):\n- God Agent: One agent doing everything (split into specialists)\n- Context Explosion: Passing all data everywhere (pass only what's needed)\n- Unbounded Loops: No max iterations (always add bounds)\n- Model Inflation: Using opus for simple tasks (tier appropriately)\n- Silent Failures: Not handling errors (match on `error(_)`)\n\n**Code structure:**\n```vvm\n# 1. Skill imports (if external tools needed)\nimport \"skill-name\" from \"source\"\n\n# 2. Agent definitions (specialized, model-tiered)\nagent name(model=\"tier\", prompt=\"Focused expertise.\")\n\n# 3. Helper functions (for reusable patterns)\ndef helper(params):\n  return result\n\n# 4. Main workflow logic\nresult = @agent `task`(input)\n\n# 5. Quality constraints (if needed)\nconstrain result():\n  require ?`quality criterion`\n\n# 6. Exports\nexport result\n```\n\n### Phase 5: Output\n\nOutput ONLY the VVM program code. No explanations, no design decisions, no markdown formatting, no code fences. Just the raw VVM program text that can be directly saved to a `.vvm` file.\n\n## Output Format\n\nOutput the VVM program directly with no surrounding text or formatting. The response should start with the first line of VVM code (typically a comment or import) and end with the last line (typically an export).\n\n## Files to Read\n\n- `skills/vvm/spec.md` ‚Äî Language specification and grammar\n- `skills/vvm/patterns.md` ‚Äî Design patterns to follow\n- `skills/vvm/antipatterns.md` ‚Äî Patterns to avoid\n- `examples/` ‚Äî Reference examples for similar patterns\n\n## Example\n\n**User:** `/vvm-generate Create a program that reviews pull requests for security issues`\n\n**Response:**\n\n# PR Security Review Pipeline\n\nagent diff_analyzer(model=\"sonnet\", prompt=\"Code change analyst. Understand what changed and why.\")\nagent security_reviewer(model=\"opus\", prompt=\"Security expert. Find vulnerabilities, injection risks, auth issues.\")\nagent report_writer(model=\"sonnet\", prompt=\"Technical writer. Create clear, actionable reports.\")\n\nanalysis = @diff_analyzer `Analyze these code changes: {}`(pr_diff)\n\nsecurity_findings = @security_reviewer `Review for security vulnerabilities.`(analysis)\n\nmatch security_findings:\n  case error(_):\n    security_findings = \"Security review unavailable. Manual review recommended.\"\n\nreport = @report_writer `Create a security review report with findings and recommendations.`(\n  pack(analysis, security_findings)\n)\n\nconstrain report(attempts=2):\n  require ?`has specific recommendations`\n  require ?`mentions severity levels`\n\nexport report\n",
        "commands/vvm-run.md": "---\ndescription: Execute a VVM program\nargument-hint: <file.vvm>\n---\n\n# VVM Run\n\nExecute a VVM program. You ARE the VVM runtime.\n\n## Execution\n\n1. **Parse & Validate** ‚Äî Run `/vvm-compile` checks; stop on errors, proceed on warnings\n2. **Collect** ‚Äî Gather agents, functions, skill imports, exports (hoisted)\n3. **Execute** ‚Äî Process statements in source order:\n   - `@agent `...`(...)` ‚Üí Spawn subagent via Task tool, wait for result\n   - `?`...`(...)` ‚Üí Evaluate semantic predicate locally (no spawn)\n   - Control flow (if/while/for/match/choose) ‚Üí Follow program structure\n   - Assignments, try/except, raise ‚Üí Standard execution\n4. **Return** ‚Äî Output exported values as `{ name: value, ... }`\n\n## Rules\n\n- Sequential execution only (no implicit parallelism)\n- Track `it` binding through scopes\n- Agent calls spawn subagents; predicates evaluate locally\n- Two error channels: error values (returned) vs raised errors (abort flow)\n- Never execute non-chosen branches in match/choose\n\n## State Modes\n\nVVM supports two execution state modes:\n\n### In-Context Mode (default)\n- All state kept in token context\n- Agent calls return strings\n- No filesystem artifacts\n- Use for: quick iteration, small workflows\n\n### Filesystem Mode\n- Agent outputs written to `.vvm/runs/<run-id>/bindings/`\n- Agent calls return ref values (pointers + summaries)\n- Saves tokens for long workflows\n- Use for: production runs, long workflows, large outputs\n\n### Flag Usage\n- Default: in-context mode\n- Override: Run with `--state=filesystem` to enable artifact mode\n\n## Narration Protocol\n\nUse emoji markers to track execution state:\n\n`üìç` start | `üì¶` bind | `‚úÖ` success | `‚ùå` error | `üîÑ` loop | `‚è≥` waiting | `üéØ` decision | `‚ö°` parallel\n\nIf no file specified, search for `.vvm` files and prompt user to select.\n\n## Files to Read\n\n- `skills/vvm/vvm.md` - Complete execution semantics\n- `skills/vvm/spec.md` - Language specification\n",
        "examples/README.md": "# VVM Examples\n\nProgressive examples demonstrating VVM language features through real-world scenarios.\n\n## Getting Started\n\nRun any example with:\n```\n/vvm-run examples/01-hello-world.vvm\n```\n\nValidate without running:\n```\n/vvm-compile examples/01-hello-world.vvm\n```\n\n## Examples by Category\n\n### Basics (01-08)\n\n| # | Example | Scenario | Concepts |\n|---|---------|----------|----------|\n| 01 | [hello-world](01-hello-world.vvm) | Commit message generator | Agent definition, basic call |\n| 02 | [simple-agent-call](02-simple-agent-call.vvm) | Explain Like I'm 5 | Input passing, interpolation |\n| 03 | [semantic-predicate](03-semantic-predicate.vvm) | Spam detector | `?` predicates, boolean ops |\n| 04 | [match-statement](04-match-statement.vvm) | Support ticket router | Pattern matching |\n| 05 | [if-elif-else](05-if-elif-else.vvm) | Content moderator | Conditional branching |\n| 06 | [while-loop](06-while-loop.vvm) | Tweet shortener | While loops, iteration bounds |\n| 07 | [for-loop](07-for-loop.vvm) | Receipt summarizer | For loops, range() |\n| 08 | [with-input](08-with-input.vvm) | Contract analyzer | Context passing with `it` |\n\n### Intermediate (09-15)\n\n| # | Example | Scenario | Concepts |\n|---|---------|----------|----------|\n| 09 | [agent-options](09-agent-options.vvm) | Flaky API caller | retry, timeout, backoff |\n| 10 | [derived-agents](10-derived-agents.vvm) | Tone adapters | .with() and inline agents |\n| 11 | [parallel-pmap](11-parallel-pmap.vvm) | Multi-language translator | Parallel execution |\n| 12 | [functions](12-functions.vvm) | Email processor | def and return |\n| 13 | [skill-imports](13-skill-imports.vvm) | Fact checker | Skills, permissions |\n| 14 | [module-imports](14-module-imports.vvm) | Team config | Importing modules |\n| 15 | [error-values](15-error-values.vvm) | Payment failover | Error matching, fallbacks |\n\n### Advanced (16-23)\n\n| # | Example | Scenario | Concepts | Agent Pattern |\n|---|---------|----------|----------|---------------|\n| 16 | [try-except-finally](16-try-except-finally.vvm) | Database transactions | Exception handling | - |\n| 17 | [choose-statement](17-choose-statement.vvm) | Customer router | AI-selected branching | Routing |\n| 18 | [constrain-require](18-constrain-require.vvm) | Press release gate | Quality constraints | - |\n| 19 | [refine-loop](19-refine-loop.vvm) | Code review bot | Iterative improvement | Evaluator-Optimizer |\n| 20 | [collection-helpers](20-collection-helpers.vvm) | Sentiment analyzer | map, filter, reduce, voting | Parallelization |\n| 21 | [pack-helper](21-pack-helper.vvm) | RPG character creator | Fan-in synthesis | Orchestrator-Workers |\n| 22 | [full-pipeline](22-full-research-pipeline.vvm) | PR review pipeline | Multi-agent workflow | Prompt Chaining |\n| 23 | [ralph-wiggum-loop](23-ralph-wiggum-loop.vvm) | Ship the feature | Continuous improvement | Autonomous Agent |\n\n### Agent Memory (24-28)\n\n| # | Example | Scenario | Concepts |\n|---|---------|----------|----------|\n| 24 | [agent-memory-basic](24-agent-memory-basic.vvm) | Mission control shift handoff | `memory`, digest+ledger, `vvm-memory` patch, W/B/O/N |\n| 25 | [agent-memory-modes](25-agent-memory-modes.vvm) | Negotiation what-if simulation | `memory_mode`: continue/dry_run/fresh |\n| 26 | [agent-memory-multi-tenant](26-agent-memory-multi-tenant.vvm) | Two story bibles, no collision | per-key isolation, `.with(memory=...)` |\n| 27 | [agent-memory-parallel-safe](27-agent-memory-parallel-safe.vvm) | Parallel incident triage ‚Üí runbook update | `pmap` + `memory_mode=\"fresh\"` + merge |\n| 28 | [agent-memory-escape-room](28-agent-memory-escape-room.vvm) | Escape room that remembers state | persistent game state, inspectable digest |\n\n## Agent Patterns\n\nThese examples demonstrate the agent patterns from [Building Effective Agents](https://www.anthropic.com/engineering/building-effective-agents):\n\n| Pattern | Example | Description |\n|---------|---------|-------------|\n| **Augmented LLM** | 13 | Base building block with skills/tools |\n| **Prompt Chaining** | 22 | Sequential steps, output‚Üíinput |\n| **Routing** | 04, 17 | Classify and direct to handlers |\n| **Parallelization** | 11, 20 | Concurrent execution, voting |\n| **Orchestrator-Workers** | 21 | Dynamic task delegation |\n| **Evaluator-Optimizer** | 19 | Generate‚Üíevaluate‚Üírefine loop |\n| **Autonomous Agent** | 23 | Full autonomy (Ralph Wiggum Loop) |\n\n## Key Syntax\n\n```vvm\n# Agent definition\nagent name(model=\"sonnet\", prompt=\"...\")\n\n# Agent call\nresult = @agent `template with {variable}`(input)\n\n# Agent memory\nagent name(model=\"sonnet\", prompt=\"...\", memory={ scope: \"project\", key: \"user:alice\" })\nresult = @agent `Answer without writing memory.`(input, memory_mode=\"dry_run\")\n\n# Semantic predicate\nif ?`criteria`(value):\n\n# Pattern matching\nmatch value:\n  case ?`pattern`: ...\n  case _: ...\n\n# AI-selected branching\nchoose value by ?`criteria` as choice:\n  option \"name\": ...\n\n# Quality constraints\nconstrain output():\n  require ?`condition`\n\n# Parallel execution\nresults = pmap(items, func)\n\n# Iterative refinement\nfinal = refine(initial, max=5, done=check, step=improve)\n```\n",
        "skills/vvm/SKILL.md": "---\nname: vvm\ndescription: |\n  VVM (Vibe Virtual Machine) is a language for agentic programs where the LLM is the runtime.\n\n  Activate when: running .vvm files, mentioning VVM, calling /vvm-boot, /vvm-run, /vvm-compile,\n  /vvm-generate, or orchestrating multi-agent workflows. Read spec.md for the language specification\n  and vvm.md for execution semantics.\n---\n\n# VVM Skill\n\nVVM (Vibe Virtual Machine) is a language for writing agentic programs where the LLM acts as the runtime.\n\n---\n\n## When to Activate\n\nActivate this skill when:\n\n1. User runs `/vvm-boot`, `/vvm-compile`, `/vvm-run`, or `/vvm-generate`\n2. User opens or references a `.vvm` file\n3. User asks about VVM syntax, semantics, or patterns\n4. User wants to create an AI-powered workflow\n\n---\n\n## Documentation Files\n\n| File              | Role                      | When to Read                    |\n| ----------------- | ------------------------- | ------------------------------- |\n| `SKILL.md`        | Quick reference, triggers | Always first                    |\n| `vvm.md`          | Execution semantics       | When running programs           |\n| `spec.md`         | Language specification    | For syntax/validation questions |\n| `memory-spec.md`  | Agent memory (portable)   | When using persistent agents    |\n| `patterns.md`     | Design patterns           | When writing programs           |\n| `antipatterns.md` | Anti-patterns             | When reviewing programs         |\n\n---\n\n## Quick Reference\n\n### Agent Definition\n\n```vvm\nagent researcher(\n  model=\"sonnet\",\n  prompt=\"thorough, cite sources\",\n  skills=[\"web-search\"],\n  permissions=perm(network=\"allow\", bash=\"deny\"),\n)\n```\n\n### Agent Call\n\n```vvm\nresult = @researcher `Find papers on {topic}.`(topic)\nresult = @researcher `Summarize.`(topic, retry=3, timeout=\"30s\")\n```\n\n### Agent Memory\n\n```vvm\nagent assistant(model=\"sonnet\", prompt=\"Helpful.\", memory={ scope: \"project\", key: \"user:alice\" })\nreply = @assistant `Continue.`(request)  # default: memory_mode=\"continue\"\ndry = @assistant `Read-only run.`(request, memory_mode=\"dry_run\")\nfresh = @assistant `Stateless run.`(request, memory_mode=\"fresh\")\n```\n\n### Semantic Predicate\n\n```vvm\nready = ?`production ready`(code)\n\nif ?`needs more work`(draft):\n  draft = @writer `Improve.`(draft)\n```\n\n### Pattern Matching\n\n```vvm\nmatch result:\n  case ?`high quality`:\n    publish(result)\n  case error(kind=\"timeout\"):\n    result = @backup `Retry.`(request)\n  case error(_):\n    log_error(result)\n  case _:\n    pass\n```\n\n### Choice\n\n```vvm\nchoose analysis by ?`best approach` as choice:\n  option \"quick\":\n    plan = @planner `Minimal plan.`()\n  option \"thorough\":\n    plan = @planner `Full plan.`()\n```\n\n### Control Flow\n\n```vvm\n# If/elif/else\nif condition:\n  do_something()\nelif other:\n  do_other()\nelse:\n  do_default()\n\n# While loop\nwhile not ?`done`(result):\n  result = @worker `Improve.`(result)\n\n# For loop\nfor item in items:\n  process(item)\n```\n\n### Context Passing\n\n```vvm\n# Implicit input (it)\nwith input data:\n  result = @agent `Process.`()  # uses it == data\n\n# Explicit input\nresult = @agent `Process.`(data)\n```\n\n### Functions\n\n```vvm\ndef analyze(topic):\n  research = @researcher `Find info on {topic}.`(topic)\n  return @analyst `Analyze.`(research)\n\nresult = analyze(\"AI safety\")\n```\n\n### Error Handling\n\n```vvm\n# Error values (match)\nmatch result:\n  case error(_):\n    handle_error(result)\n\n# Raised errors (try/except)\ntry:\n  if ?`invalid`(input):\n    raise \"Invalid input\"\nexcept as err:\n  log(err)\nfinally:\n  cleanup()\n```\n\n### Constraints\n\n```vvm\ndraft = @writer `Write report.`(data)\n\nconstrain draft(attempts=3):\n  require ?`has citations`\n  require ?`no hallucinations`\n```\n\n### Imports/Exports\n\n```vvm\n# Skill imports\nimport \"web-search\" from \"github:anthropic/skills\"\n\n# Module imports\nfrom \"./lib/research.vvm\" import deep_research\nfrom \"./lib/agents.vvm\" import @researcher\n\n# Exports\nexport result\nexport @researcher\n```\n\n### Standard Library\n\n```vvm\n# Parallel map\nresults = pmap(items, process)\n\n# Sequential map/filter/reduce\nmapped = map(items, transform)\nfiltered = filter(items, predicate)\ndef add(a, b):\n  return a + b\ntotal = reduce(items, add, init=0)\n\n# Iterative refinement\nfinal = refine(initial, max=5, done=is_ready, step=improve)\n\n# Named fan-in\nctx = pack(research, analysis, topic=topic)\n\n# Range\nfor i in range(10):\n  process(i)\n```\n\n---\n\n## Examples\n\n| #   | Name                   | Concepts                |\n| --- | ---------------------- | ----------------------- |\n| 01  | hello-world            | Minimal program         |\n| 02  | simple-agent-call      | Agent with input        |\n| 03  | semantic-predicate     | `?` predicates          |\n| 04  | match-statement        | Pattern matching        |\n| 05  | if-elif-else           | Conditionals            |\n| 06  | while-loop             | While loops             |\n| 07  | for-loop               | For loops               |\n| 08  | with-input             | Context passing         |\n| 09  | agent-options          | retry, timeout, backoff |\n| 10  | derived-agents         | .with() and inline      |\n| 11  | parallel-pmap          | Parallel execution      |\n| 12  | functions              | def and return          |\n| 13  | skill-imports          | Skill imports           |\n| 14  | module-imports         | Module imports          |\n| 15  | error-values           | Error value matching    |\n| 16  | try-except-finally     | Raised errors           |\n| 17  | choose-statement       | AI-selected branching   |\n| 18  | constrain-require      | Quality constraints     |\n| 19  | refine-loop            | Iterative improvement   |\n| 20  | collection-helpers     | map, filter, reduce     |\n| 21  | pack-helper            | Named fan-in            |\n| 22  | full-research-pipeline | Complex workflow        |\n| 23  | ralph-wiggum-loop      | Continuous improvement  |\n| 24  | agent-memory-basic     | Memory binding + digest/ledger |\n| 25  | agent-memory-modes     | memory_mode: continue/dry_run/fresh |\n| 26  | agent-memory-multi-tenant | Per-key isolation |\n| 27  | agent-memory-parallel-safe | pmap-safe persistence |\n| 28  | agent-memory-escape-room | Demo: persistent game state |\n\n---\n\n## Commands\n\n### /vvm-boot\n\nInitialize VVM for new or returning users. Detects existing files and provides onboarding.\n\n### /vvm-compile <file.vvm>\n\nValidate a VVM program without executing. Reports errors and warnings with line numbers.\n\n### /vvm-run <file.vvm>\n\nExecute a VVM program. You become the VVM runtime and execute statements sequentially, spawning subagents for agent calls.\n\n### /vvm-generate <description>\n\nGenerate a VVM program from a natural language description. Analyzes intent, maps to VVM constructs, applies best practices, and produces well-structured code. Asks clarifying questions if the request is ambiguous.\n\n---\n\n## Key Principles\n\n1. **Minimal syntax** - Familiar indentation-based blocks\n2. **Explicit AI boundary** - Agent calls are syntactically distinct (`@agent`)\n3. **Eager execution** - No lazy evaluation, sequential by default\n4. **Semantic control flow** - Branch on meaning, not just booleans\n5. **Two error channels** - Values (match) vs raised (try/except)\n6. **Explicit parallelism** - Only `pmap` runs concurrently\n",
        "skills/vvm/antipatterns.md": "---\nrole: antipatterns\nsummary: |\n  Common mistakes and anti-patterns to avoid when writing VVM programs.\nsee-also:\n  - patterns.md: Design patterns (what TO do)\n  - spec.md: Language specification\n  - vvm.md: Execution semantics\n---\n\n# VVM Anti-Patterns\n\nThis document describes common mistakes and anti-patterns to avoid when writing VVM programs.\n\n---\n\n## Structural Anti-Patterns\n\n### God Agent\n\n**Problem:** A single agent definition that tries to do everything.\n\n```vvm\n# Bad: One agent handles all tasks\nagent universal(\n  model=\"opus\",\n  prompt=\"You are an expert at everything: research, writing, coding, analysis, design...\"\n)\n\nresearch = @universal `Research AI.`(())\ncode = @universal `Write Python code.`(spec)\nreview = @universal `Review the code.`(code)\n```\n\n**Why it's bad:**\n- Prompts become unfocused\n- Hard to tune for specific tasks\n- Expensive model used even for simple tasks\n\n**Solution:** Use specialized agents (see Agent Specialization pattern).\n\n```vvm\n# Good: Specialized agents\nagent researcher(model=\"sonnet\", prompt=\"Research expert\")\nagent coder(model=\"sonnet\", prompt=\"Python developer\")\nagent reviewer(model=\"sonnet\", prompt=\"Code reviewer\")\n```\n\n---\n\n### Context Explosion\n\n**Problem:** Passing everything to every agent call.\n\n```vvm\n# Bad: Passing entire accumulated context everywhere\nall_data = pack(research, analysis, code, tests, docs, config, history)\nresult = @agent `Do something.`(all_data)\nnext = @agent `Do next thing.`(pack(all_data, result))\n```\n\n**Why it's bad:**\n- Wastes tokens/budget\n- Confuses agents with irrelevant context\n- Slows down responses\n\n**Solution:** Pass only what's needed.\n\n```vvm\n# Good: Pass relevant context only\nresult = @agent `Analyze the research.`(research)\nnext = @agent `Build on analysis.`(result)\n```\n\n---\n\n### Implicit Dependency\n\n**Problem:** Over-relying on `it` makes data flow unclear.\n\n```vvm\n# Bad: Too much implicit context\nwith input data:\n  with input @agent `Process.`():\n    with input @agent `Transform.`():\n      with input @agent `Finalize.`():\n        result = @agent `Complete.`()\n```\n\n**Why it's bad:**\n- Hard to trace data flow\n- Easy to lose track of what `it` is\n- Debugging is difficult\n\n**Solution:** Use explicit input for complex flows.\n\n```vvm\n# Good: Explicit data flow\nprocessed = @agent `Process.`(data)\ntransformed = @agent `Transform.`(processed)\nfinalized = @agent `Finalize.`(transformed)\nresult = @agent `Complete.`(finalized)\n```\n\n---\n\n### Spaghetti Matching\n\n**Problem:** Deeply nested match statements.\n\n```vvm\n# Bad: Nested matches\nmatch result1:\n  case ?`condition1`:\n    match result2:\n      case ?`condition2`:\n        match result3:\n          case ?`condition3`:\n            do_something()\n```\n\n**Why it's bad:**\n- Hard to read and maintain\n- Easy to miss cases\n- Difficult to test\n\n**Solution:** Flatten with early returns or separate functions.\n\n```vvm\n# Good: Flat structure\nif not ?`condition1`(result1):\n  handle_not_condition1()\n  return\n\nif not ?`condition2`(result2):\n  handle_not_condition2()\n  return\n\nif ?`condition3`(result3):\n  do_something()\n```\n\n---\n\n## Cost/Performance Anti-Patterns\n\n### Model Inflation\n\n**Problem:** Using expensive models for simple tasks.\n\n```vvm\n# Bad: Opus for everything\nagent formatter(model=\"opus\", prompt=\"Format this text\")\nagent validator(model=\"opus\", prompt=\"Check for typos\")\nagent counter(model=\"opus\", prompt=\"Count the words\")\n```\n\n**Why it's bad:**\n- Wasted budget\n- Slower responses\n- No quality improvement for simple tasks\n\n**Solution:** Match model to task complexity.\n\n```vvm\n# Good: Right model for the job\nagent formatter(model=\"haiku\", prompt=\"Format this text\")\nagent validator(model=\"haiku\", prompt=\"Check for typos\")\nagent synthesizer(model=\"opus\", prompt=\"Complex synthesis\")\n```\n\n---\n\n### Unbounded Loops\n\n**Problem:** Loops without termination guarantees.\n\n```vvm\n# Bad: No maximum iterations\nwhile not ?`perfect`(result):\n  result = @improver `Keep improving.`(result)\n  # Could run forever!\n```\n\n**Why it's bad:**\n- Could run indefinitely\n- Unpredictable cost\n- No timeout protection\n\n**Solution:** Use `refine` with max iterations or add counters.\n\n```vvm\n# Good: Bounded iteration\ndef is_done(result, i):\n  return ?`good enough`(result) or i >= 10\n\nfinal = refine(initial, max=10, done=is_done, step=improve)\n```\n\n---\n\n### Redundant Computation\n\n**Problem:** Repeating expensive operations.\n\n```vvm\n# Bad: Same research done multiple times\nreport1 = @writer `Write about AI.`(@researcher `Research AI.`(()))\nreport2 = @writer `Another view on AI.`(@researcher `Research AI.`(()))\n```\n\n**Why it's bad:**\n- Wasted tokens and time\n- Inconsistent results between calls\n- Unnecessary cost\n\n**Solution:** Cache and reuse results.\n\n```vvm\n# Good: Research once, reuse\nresearch = @researcher `Research AI.`(())\nreport1 = @writer `Write about AI.`(research)\nreport2 = @writer `Another view on AI.`(research)\n```\n\n---\n\n### Sequential When Parallel\n\n**Problem:** Running independent tasks sequentially.\n\n```vvm\n# Bad: Sequential independent work\nresult1 = @agent `Task 1.`(data)\nresult2 = @agent `Task 2.`(data)\nresult3 = @agent `Task 3.`(data)\n# Total time: T1 + T2 + T3\n```\n\n**Why it's bad:**\n- Wasted time\n- Poor user experience\n- Underutilizes available concurrency\n\n**Solution:** Use `pmap` for independent work.\n\n```vvm\n# Good: Parallel execution\ndef process(task):\n  return @agent `{task}`(data)\n\nresults = pmap([\"Task 1\", \"Task 2\", \"Task 3\"], process)\n# Total time: max(T1, T2, T3)\n```\n\n---\n\n## Reliability Anti-Patterns\n\n### Transcript Stuffing into Memory\n\n**Problem:** Prompting a persistent agent to store full transcripts (or large artifacts) in memory.\n\n```vvm\n# Bad: Encourages unbounded, low-signal memory writes\nagent assistant(\n  model=\"sonnet\",\n  prompt=\"After every reply, append the full conversation to memory.\",\n  memory={ scope: \"project\", key: \"user:alice\" },\n)\n\nreply = @assistant `Help me debug this.`(issue)\n```\n\n**Why it's bad:**\n- Bloats the injected context on every call (cost + confusion)\n- Increases risk of persisting sensitive data\n- Produces memory that‚Äôs hard to compaction/edit\n\n**Solution:** Use digest as a compact working set, and retain only short narrative facts.\n\n```vvm\n# Good: Explicit, bounded memory updates\nagent assistant(\n  model=\"sonnet\",\n  prompt=\"Use vvm-memory patches to maintain a small digest + short retain facts. Never store secrets.\",\n  memory={ scope: \"project\", key: \"user:alice\" },\n)\n```\n\n---\n\n### Persisting Secrets\n\n**Problem:** Treating agent memory as a credential store.\n\n```vvm\n# Bad: Encourages persisting secrets\nagent deployer(\n  model=\"sonnet\",\n  prompt=\"Remember any API keys or tokens you see so you can reuse them later.\",\n  memory={ scope: \"project\", key: \"deploy\" },\n)\n```\n\n**Why it's bad:**\n- Secrets leak into inspectable files (`digest.md`, `ledger.jsonl`)\n- Increases blast radius (shared keys, backups, logs)\n- Violates ‚Äúsafety by default‚Äù and complicates audits\n\n**Solution:** Keep secrets out of memory; use env vars/secret stores, and prefer stateless calls when handling credentials.\n\n```vvm\n# Good: Treat secret handling as ephemeral\nagent deployer(\n  model=\"sonnet\",\n  prompt=\"Never store secrets in memory. Ask to use env vars or a secret manager.\",\n  memory={ scope: \"project\", key: \"deploy\" },\n)\n\ndry = @deployer `Describe the deployment steps without storing any credentials.`(req, memory_mode=\"fresh\")\n```\n\n---\n\n### Shared Memory Key Under `pmap`\n\n**Problem:** Parallel calls share the same memory key and try to write concurrently.\n\n```vvm\nagent helper(model=\"sonnet\", prompt=\"Helpful.\", memory={ scope: \"project\", key: \"team\" })\n\ndef work(item):\n  return @helper `Process {item}.`(item)  # default: memory_mode=\"continue\"\n\nresults = pmap(items, work)\n```\n\n**Why it's bad:**\n- Causes lock contention (or races if a runtime is buggy)\n- Serializes the parallel map (or returns `error(kind=\"locked\")`)\n- Makes memory evolution depend on scheduling order\n\n**Solution:** Use `memory_mode=\"fresh\"` (or per-item keys) for parallel map work, then do one sequential memory update.\n\n```vvm\ndef work(item):\n  return @helper `Process {item}.`(item, memory_mode=\"fresh\")\n\nresults = pmap(items, work)\nsummary = @helper `Summarize and update team memory.`(results)  # single writer\n```\n\n### Silent Failures\n\n**Problem:** Ignoring error values.\n\n```vvm\n# Bad: Errors ignored\nresult = @agent `Might fail.`(data, timeout=\"5s\")\n# If timeout occurs, result is an error value but we proceed anyway\nfinal = @agent `Use result.`(result)\n```\n\n**Why it's bad:**\n- Errors propagate silently\n- Downstream failures are confusing\n- Hard to diagnose issues\n\n**Solution:** Always match on potential errors.\n\n```vvm\n# Good: Handle errors explicitly\nresult = @agent `Might fail.`(data, timeout=\"5s\")\n\nmatch result:\n  case error(_):\n    result = fallback(data)\n  case _:\n    pass\n\nfinal = @agent `Use result.`(result)\n```\n\n---\n\n### Fire and Forget\n\n**Problem:** Agent calls without any error handling.\n\n```vvm\n# Bad: No error handling\n@notifier `Send notification.`(event)\n@logger `Log event.`(event)\n# If these fail, we never know\n```\n\n**Why it's bad:**\n- Failures go unnoticed\n- No retry logic\n- No fallback behavior\n\n**Solution:** Handle or at least log errors.\n\n```vvm\n# Good: Check for errors\nnotification = @notifier `Send notification.`(event)\nmatch notification:\n  case error(_):\n    @backup_notifier `Backup notification.`(event)\n  case _:\n    pass\n```\n\n---\n\n### Overly Broad Exception Handling\n\n**Problem:** Catching all errors without distinction.\n\n```vvm\n# Bad: Blanket error handling\ntry:\n  result = complex_workflow(data)\nexcept as err:\n  result = \"default\"  # All errors get same treatment\n```\n\n**Why it's bad:**\n- Masks different failure modes\n- Can't handle specific errors appropriately\n- Loses error context\n\n**Solution:** Handle specific error types.\n\n```vvm\n# Good: Specific error handling\nresult = complex_workflow(data)\n\nmatch result:\n  case error(kind=\"timeout\"):\n    result = @fast_fallback `Quick alternative.`(data)\n  case error(kind=\"rejected\"):\n    raise \"Service unavailable\"\n  case error(_):\n    result = @general_fallback `Best effort.`(data)\n  case _:\n    pass\n```\n\n---\n\n### Constraint Overload\n\n**Problem:** Too many constraints in one block.\n\n```vvm\n# Bad: Overwhelming constraints\nconstrain output():\n  require ?`grammatically correct`\n  require ?`no spelling errors`\n  require ?`professional tone`\n  require ?`under 500 words`\n  require ?`includes introduction`\n  require ?`includes conclusion`\n  require ?`cites at least 3 sources`\n  require ?`no passive voice`\n  require ?`readable by 8th grader`\n  require ?`no jargon`\n```\n\n**Why it's bad:**\n- Hard to satisfy all constraints\n- Unclear which failed\n- Difficult to prioritize fixes\n\n**Solution:** Group related constraints or prioritize.\n\n```vvm\n# Good: Focused constraints\nconstrain output():\n  require ?`grammatically correct with no spelling errors`\n  require ?`professional tone appropriate for executives`\n  require ?`properly structured with intro and conclusion`\n```\n\n---\n\n### Circular Dependencies\n\n**Problem:** Functions that call each other indefinitely.\n\n```vvm\n# Bad: Circular calls\ndef improve(draft):\n  if not ?`good`(draft):\n    return refine(draft)\n  return draft\n\ndef refine(draft):\n  critique = @critic `Critique.`(draft)\n  return improve(@writer `Fix issues.`([draft, critique]))\n```\n\n**Why it's bad:**\n- Potential infinite recursion\n- No termination guarantee\n- Stack overflow risk\n\n**Solution:** Use explicit iteration with bounds.\n\n```vvm\n# Good: Bounded iteration\ndef is_done(draft, i):\n  return ?`good`(draft)\n\ndef step(draft, i):\n  critique = @critic `Critique.`(draft)\n  return @writer `Fix issues.`([draft, critique])\n\nfinal = refine(initial, max=5, done=is_done, step=step)\n```\n\n---\n\n## Summary\n\n| Anti-Pattern | Problem | Solution |\n|--------------|---------|----------|\n| God Agent | One agent does everything | Specialized agents |\n| Context Explosion | Passing everything everywhere | Pass only what's needed |\n| Implicit Dependency | Over-relying on `it` | Explicit input passing |\n| Spaghetti Matching | Deeply nested matches | Flatten with early returns |\n| Model Inflation | Expensive models for simple tasks | Match model to task |\n| Unbounded Loops | No termination guarantee | Use refine with max |\n| Redundant Computation | Repeating expensive work | Cache and reuse |\n| Sequential When Parallel | Independent tasks in sequence | Use pmap |\n| Transcript Stuffing | Unbounded, low-signal memory | Digest + retain conventions |\n| Persisting Secrets | Secrets leak into memory files | Keep secrets out of memory |\n| Shared Memory Key | Parallel writes/lock contention | Fresh/per-key + merge |\n| Silent Failures | Ignoring error values | Match on errors |\n| Fire and Forget | No error handling | Handle or log errors |\n| Overly Broad Handling | Catching all errors same way | Handle specific errors |\n| Constraint Overload | Too many constraints | Group and prioritize |\n| Circular Dependencies | Infinite recursion risk | Bounded iteration |\n",
        "skills/vvm/memory-spec.md": "---\nrole: spec-extension\nsummary: |\n  Minimal, VVM-native semantics for agent memory (persistent agents) with\n  portable behavior, explicit controls, inspectable files, and safe concurrency.\nsee-also:\n  - spec.md\n  - vvm.md\n  - patterns.md\n---\n\n# Agent Memory (MVP Spec): Digest + Ledger\n\nThis is the **final MVP design** for persistent agents in VVM.\n\nVVM programs run as prompts: there is no background process, ‚Äúsleep‚Äù, or daemon. So persistence must be realized via **explicit file-backed memory** that the runtime loads into each agent call, and updates after the call.\n\n---\n\n## Goals (MVP)\n\n- **Portable semantics**: persistence works regardless of whether the host has native persistent subagents.\n- **Explicitness**: authors can see when memory is used vs ignored.\n- **Inspectable state**: memory is readable/editable outside the runtime.\n- **Boundedness**: memory grows, but the system remains usable (compaction, segmentation).\n- **Safety by default**: hard to accidentally persist secrets; easy to scope memory.\n- **Concurrency rules**: avoid corrupting memory under `pmap` and future parallelism.\n\n## Non-goals (MVP)\n\n- Solving long-term memory *retrieval* optimally (vector DB, KG, etc.) in the spec.\n- Perfect reproducibility across models (persistent state is inherently history-dependent).\n- A full durable-execution system for *resuming a program counter* (separate feature; LangGraph territory).\n\n---\n\n## 1. Core model (conceptual)\n\nAgent memory is a durable directory with two layers:\n- **Digest** (`digest.md`): small, editable, token-bounded ‚Äúcore memory‚Äù (the compact state you actually want injected).\n- **Ledger** (`ledger.jsonl`): append-only history of memory updates (‚Äúwhat we decided to remember‚Äù), rebuildable views, and diagnostics.\n\nThe runtime always injects **Digest** (and optionally a bounded slice of Ledger-derived facts) into the prompt for stateful calls.\nThe runtime only updates memory via an **explicit memory patch** emitted by the agent.\n\nDesign intent:\n- Digest is what you want the model to ‚Äúbe‚Äù next time.\n- Ledger is why Digest is that way (and a place to store additional retained facts safely).\n\n### 1.1 What goes in `digest.md` (guidance)\n\n`digest.md` is the **working set**: information you want injected on every stateful call because it has high expected value.\n\nPut in the digest:\n- **Stable facts** that will matter repeatedly (high signal, low volatility).\n- **Preferences / norms** (e.g., formatting, tone, strictness) that should apply by default.\n- **Constraints** (policies, invariants, ‚Äúdo not do X‚Äù) that should be present every time.\n- **Current focus + what‚Äôs next**: a small, current list of open loops / next actions.\n\nKeep out of the digest:\n- raw transcripts, long chat logs, or large copied artifacts\n- time-sensitive details that will go stale quickly (unless they‚Äôre part of ‚Äúcurrent focus‚Äù)\n- secrets / tokens / credentials / private keys\n\nRule of thumb (‚Äúpromotion‚Äù):\n- If you want it **always loaded**, it belongs in `digest.md`.\n- If you want it **findable later** but not always loaded, it belongs in `retain` ‚Üí `ledger.jsonl`.\n\nRecommended structure (optional, not required):\n\n```md\n## Stable\n- W ... (durable facts)\n\n## Preferences\n- O(c=...) ... (preferences/norms)\n\n## Next\n- N ... (open loops / follow-ups)\n\n## Notes\n- Short glossary / constraints / pointers\n```\n\n### 1.2 What goes in `ledger.jsonl` (guidance)\n\n`ledger.jsonl` is the **audit trail + long tail**: an append-only record of what was retained and how the digest evolved.\n\nPut in the ledger (via `retain`):\n- narrative, self-contained facts (W/B/O/N) with `@Entity` mentions\n- ‚Äúwhy‚Äù behind digest changes (captured implicitly because the patch that changed digest is logged)\n- short-lived items that are useful for near-term continuity but shouldn‚Äôt live forever in the digest\n\nKeep out of the ledger (MVP):\n- raw user inputs and raw agent outputs (the spec explicitly avoids transcript persistence)\n- secrets (patches containing likely secrets must be rejected)\n\nThis is inspired by prior art, but deliberately VVM-shaped: minimal syntax, explicit evaluation, and no hidden background work.\n\nNon-normative inspirations:\n- Prose: inspectable, scoped persistence.\n- Letta: small pinned ‚Äúcore‚Äù memory; explicit writes.\n- Hindsight: retain/recall/reflect framing and evidence mindset (not mandated here).\n- Clawdbot notes: Markdown-first workflows + rebuildable derived index.\n\n---\n\n## 2. Language surface (minimal)\n\n### 2.1 Agent key: `memory=...`\n\nAgents MAY specify a `memory` binding:\n\n```vvm\nagent helper(\n  model=\"sonnet\",\n  prompt=\"Helpful, practical.\",\n  memory={ scope: \"project\", key: \"user:alice\" },\n)\n```\n\n`memory` is an object with keys:\n- `scope`: `\"project\" | \"user\" | \"path\"`\n- `key`: a string identifying the durable memory instance\n- `path`: required iff `scope==\"path\"` (string path to the memory directory root)\n\nNotes:\n- The **agent name is not memory identity**. Identity is `(scope, key)` so one agent template can serve many users/tenants safely.\n\n### 2.2 Call option: `memory_mode=...`\n\nStateful agent calls accept an override option:\n\n```vvm\nreply = @helper `Help with {}.`(question)  # default: uses memory (continue)\ntemp  = @helper `Try a fresh approach.`(question, memory_mode=\"fresh\")\naudit = @helper `Answer without updating memory.`(question, memory_mode=\"dry_run\")\n```\n\nValid values:\n- `memory_mode=\"continue\"` (default): read memory, then write updates\n- `memory_mode=\"dry_run\"`: read memory, do not write anything\n- `memory_mode=\"fresh\"`: do not read and do not write memory (equivalent to stateless execution)\n\n`memory_mode` is only meaningful if a `memory` binding exists (either on the agent or via host-defined mechanisms). If no memory is bound, runtimes SHOULD ignore `memory_mode`.\n\n---\n\n## 3. Runtime semantics (normative)\n\n### 3.1 Memory directory resolution\n\nGiven `memory={scope:S, key:K, path:P?}`, the runtime resolves a memory directory `D`:\n- `S==\"project\"` ‚Üí `D = <project>/.vvm/memory/<escape(K)>`\n- `S==\"user\"`    ‚Üí `D = ~/.vvm/memory/<escape(K)>`\n- `S==\"path\"`    ‚Üí `D = P/<escape(K)>` (or `D=P` if `P` is already key-specific; host-defined)\n\n`escape(K)` MUST be a reversible encoding that is safe for filesystem paths.\n\n### 3.2 Memory files (portable minimum)\n\nThe portable minimum representation is:\n- `D/digest.md` (UTF-8 text; may be empty)\n- `D/ledger.jsonl` (append-only JSON Lines)\n- `D/meta.json` (optional; schema version, created_at, last_used_at)\n- `D/lock` (optional; for single-writer locking; see Section 6)\n\nRuntimes MAY add derived files, including (examples):\n- `D/journal/YYYY-MM-DD.md` (optional human-readable view of the ledger)\n\nRuntimes MUST preserve the meaning of the portable minimum files.\n\n### 3.3 Loading memory into an agent call\n\nWhen evaluating an agent call with `memory_mode=\"continue\"` or `\"dry_run\"`:\n1. Load `digest.md` (or treat as empty if missing).\n2. Optionally load a **token-budgeted** slice of memory facts derived from `ledger.jsonl` (at minimum, a recent tail of `retain` items if present).\n3. Construct a **Memory Context** string:\n   - include the digest verbatim\n   - include the selected retained facts in a compact, readable form\n4. Prepend the Memory Context to the call‚Äôs rendered task prompt.\n\nErgonomics: the Memory Context MUST include a short reminder of the `vvm-memory` patch format so authors don‚Äôt need to repeat the protocol in every agent prompt.\n\nThe retrieval algorithm beyond ‚Äúrecent tail‚Äù is intentionally unspecified. Implementations MAY do keyword/semantic retrieval, but the spec only requires:\n- **bounded size** (token-budgeted),\n- **deterministic enough** to be debuggable (inspectable inputs),\n- **bias toward recency** (to preserve conversational continuity).\n\nSafety note: the runtime MUST NOT persist raw user input or raw agent output by default (see Section 5).\n\n### 3.4 Applying a memory update\n\nFor `memory_mode=\"continue\"` only, after the subagent returns:\n1. Extract any memory patch (Section 4) and separate **user-visible output** from patch data.\n2. Validate the patch (size limits; secret scanning; schema).\n3. If valid, apply it:\n   - update `digest.md` (atomic write)\n   - append a ledger entry capturing the patch (append-only)\n4. Update `meta.json` (best-effort): `last_used_at`, `last_mode`.\n\nFor `memory_mode=\"dry_run\"` and `\"fresh\"`, runtimes MUST NOT write to `digest.md` or `ledger.jsonl` (but MAY update `meta.json` with `last_used_at` / `last_mode`).\n\n---\n\n## 4. Memory patches (tiny, safe channel)\n\nMemory updates are not ‚Äúthe agent edits files‚Äù. Memory updates are a **single structured block** that the runtime can validate and apply.\n\n### 4.1 Patch envelope\n\nIf the agent output contains a fenced code block with info string `vvm-memory`, the runtime MUST treat its contents as a JSON object:\n\n````text\n...user visible text...\n\n```vvm-memory\n{\n  \"digest\": \"...\",\n  \"retain\": [\n    \"O(c=0.95) @Peter: Prefers concise replies; long content goes into files.\",\n    \"N @Peter: Keep replies under ~1500 chars; write longer content into a file.\"\n  ]\n}\n```\n````\n\nRules:\n- The runtime MUST strip the entire `vvm-memory` block from the returned string value of the agent call.\n- If the JSON is invalid, runtimes SHOULD ignore it and still return the user-visible text (and SHOULD record a warning in the ledger entry if writing).\n\n### 4.2 Patch schema (MVP)\n\nSupported keys (all optional):\n- `digest` (string): the new full digest contents to write to `digest.md`\n- `retain` (list of strings): 0‚ÄìN ‚Äúnarrative facts‚Äù to attach to the current ledger entry for later recall\n\nThat‚Äôs it for MVP. Everything else belongs in the ledger (ground truth) or in future extensions.\n\n### 4.3 Safety requirements (MVP)\n\nRuntimes MUST enforce:\n- a maximum digest size (token or byte limit)\n- a maximum retain size (count and per-item size)\n- atomic write semantics for digest updates (write temp + rename)\n- single-writer behavior for a given `D` (lock or best-effort; see Section 6)\n\nRuntimes SHOULD enforce:\n- refusal to store obvious secrets (API keys, private keys, tokens) in `digest` or `retain`\n- schema versioning via `meta.json`\n\n---\n\n## 5. Safety by default (normative)\n\n### 5.1 Explicit memory, not transcript persistence\n\nTo make it hard to accidentally persist secrets:\n- The runtime MUST NOT persist raw call inputs or raw agent outputs as part of this memory system.\n- The only durable writes in MVP are `digest.md` updates and `ledger.jsonl` entries derived from the `vvm-memory` patch.\n\nIf an application wants transcript logging, it should implement it separately with explicit opt-in and its own security model.\n\n### 5.2 Scoping is the primary safety mechanism\n\nAuthors SHOULD scope memory narrowly by choosing keys intentionally:\n- per-user: `key=\"user:alice\"`\n- per-ticket/thread: `key=\"user:alice/ticket:INC-1234\"`\n- per-project role: `key=\"project:my-repo/reviewer\"`\n\n### 5.3 Secret scanning behavior\n\nIf the runtime detects likely secrets inside a proposed patch, it MUST reject the patch (write nothing) and still return the user-visible output.\nIt SHOULD append a ledger warning entry if doing so does not leak the secret itself.\n\n---\n\n## 6. Concurrency rules (normative)\n\n### 6.1 Single-writer discipline\n\nFor a given memory directory `D`, the runtime MUST prevent concurrent writes that can corrupt state.\n\nMinimum requirement:\n- `memory_mode=\"continue\"` MUST acquire an exclusive lock for `D` across the whole operation (load ‚Üí run agent ‚Üí validate patch ‚Üí apply patch).\n\nRecommended:\n- `memory_mode=\"dry_run\"` SHOULD also acquire a lock (shared if available; exclusive otherwise) to avoid reading half-written state.\n\n### 6.2 Lock failure behavior\n\nIf the runtime cannot acquire the lock within an implementation-defined timeout, it MUST return an error value (e.g., `error(kind=\"locked\")`) rather than proceeding unsafely.\n\n### 6.3 Parallelism guidance\n\nUnder `pmap`, authors SHOULD avoid sharing a single memory key across parallel calls unless they intentionally want serialization.\nUse one of:\n- distinct `memory.key` per parallel worker,\n- `memory_mode=\"fresh\"` for parallel ‚Äúmap‚Äù work,\n- an explicit merge step that writes a single patch after parallel computation.\n\n---\n\n## 7. Boundedness (normative)\n\n### 7.1 What‚Äôs bounded\n\nRuntimes MUST keep:\n- injected memory context token-bounded,\n- `digest.md` size-bounded,\n- patch size bounded (`digest` + `retain`).\n\n### 7.2 Compaction via digest\n\nCompaction is ‚Äúrewrite the digest to be smaller and more useful‚Äù.\nIn MVP, compaction is achieved by:\n- the agent emitting a new `digest` (explicit),\n- or humans editing `digest.md` directly (inspectable).\n\n### 7.3 Segmentation via ledger\n\nThe Digest/Ledger split is the primary segmentation mechanism.\nRuntimes MAY additionally rotate `ledger.jsonl` into segments (e.g., per-day files under `journal/`), as long as `ledger.jsonl` remains the authoritative append-only record or can be reconstructed.\n\n---\n\n## 8. Usage patterns (informative)\n\n### 8.1 Multi-tenant agents\n\n```vvm\nagent tutor(model=\"sonnet\", prompt=\"Socratic, patient.\", memory={ scope: \"project\", key: \"user:alice\" })\nagent tutor_bob(model=\"sonnet\", prompt=\"Socratic, patient.\", memory={ scope: \"project\", key: \"user:bob\" })\n\na = @tutor `Help me learn Rust borrowing.`(it)\nb = @tutor_bob `Help me learn Rust borrowing.`(it)\n```\n\n### 8.2 ‚ÄúNew thread‚Äù without new features\n\nThreads are just keys:\n\n```vvm\nagent support(model=\"sonnet\", prompt=\"Support agent.\", memory={ scope: \"project\", key: \"user:alice/ticket:INC-1234\" })\nreply = @support `Resolve this ticket.`(ticket)\n```\n\nIf you want a new conversation, pick a new key. If you want long-term continuity, reuse the key.\n\n### 8.3 Retain bullets (recommended convention)\n\nIf you use `retain`, keep each item:\n- self-contained (reads sensibly out of context),\n- narrative (captures the ‚Äúwhy‚Äù, not just a keyword),\n- attributable (mention entities; avoid ambiguous pronouns).\n\nA lightweight, Markdown-friendly convention (inspired by the Clawdbot notes) is:\n- `W ‚Ä¶` for ‚Äúworld fact‚Äù\n- `B ‚Ä¶` for ‚Äúwhat happened / what we did‚Äù\n- `O(c=0.0..1.0) ‚Ä¶` for ‚Äúopinion/preference with confidence‚Äù\n- `N ‚Ä¶` for ‚Äúwhat‚Äôs next / follow-up‚Äù (open loop; keep current ones in the digest)\n- `@Entity` mentions for entity-centric recall\n\n---\n\n## 9. Notes on retrieval (non-normative)\n\nThis spec intentionally does NOT standardize vector DBs, knowledge graphs, or ‚Äúoptimal recall‚Äù.\nHowever, it is compatible with simple, portable approaches such as:\n- scanning `ledger.jsonl` / `journal/` for matches (lexical) and injecting a bounded slice\n- maintaining a host-specific derived index (rebuildable) to speed up lexical/semantic recall\n\nWhatever the host does, it must still produce a bounded, inspectable Memory Context and preserve the canonical Digest/Ledger files.\n",
        "skills/vvm/patterns.md": "---\nrole: best-practices\nsummary: |\n  Design patterns for writing robust, efficient, and maintainable VVM programs.\nsee-also:\n  - antipatterns.md: Anti-patterns to avoid\n  - spec.md: Language specification\n  - vvm.md: Execution semantics\n---\n\n# VVM Design Patterns\n\nThis document describes proven patterns for writing effective VVM programs.\n\n---\n\n## Structural Patterns\n\n### Agent Specialization\n\n**Problem:** A single agent trying to do too many different tasks produces inconsistent results.\n\n**Solution:** Define focused agents with specific expertise.\n\n```vvm\n# Bad: One agent does everything\nagent do_everything(model=\"opus\", prompt=\"You do everything\")\n\n# Good: Specialized agents\nagent researcher(model=\"sonnet\", prompt=\"Research expert. Cite sources.\")\nagent writer(model=\"opus\", prompt=\"Technical writer. Clear and concise.\")\nagent reviewer(model=\"sonnet\", prompt=\"Code reviewer. Find bugs and issues.\")\n```\n\n**Benefits:**\n- Better prompt engineering per task\n- Easier to tune model selection\n- Clearer cost attribution\n\n---\n\n### Pipeline Composition\n\n**Problem:** Complex workflows become hard to follow and maintain.\n\n**Solution:** Chain transformations in clear stages.\n\n```vvm\nagent collector(model=\"sonnet\")\nagent analyzer(model=\"sonnet\")\nagent synthesizer(model=\"opus\")\n\n# Clear pipeline stages\nraw_data = @collector `Gather data on {topic}.`(topic)\nanalysis = @analyzer `Analyze the data.`(raw_data)\nreport = @synthesizer `Synthesize into executive summary.`(analysis)\n\nexport report\n```\n\n**Benefits:**\n- Each stage has clear input/output\n- Easy to debug intermediate results\n- Stages can be tested independently\n\n---\n\n### Parallel Independent Work\n\n**Problem:** Independent tasks run sequentially, wasting time.\n\n**Solution:** Use `pmap` for parallel execution.\n\n```vvm\nagent researcher(model=\"sonnet\")\n\ntopics = [\"AI safety\", \"quantum computing\", \"climate tech\"]\n\n# Sequential (slow)\n# for topic in topics:\n#   result = @researcher `Research {topic}.`(topic)\n\n# Parallel (fast)\ndef research_topic(topic):\n  return @researcher `Research {topic}.`(topic)\n\nresults = pmap(topics, research_topic)\n```\n\n**When to use:**\n- Tasks are independent (no shared state)\n- Order doesn't matter\n- Side effects are safe to interleave\n\n---\n\n### Fan-Out Fan-In\n\n**Problem:** Need multiple perspectives on the same input, then combine them.\n\n**Solution:** Parallel analysis with aggregation.\n\n```vvm\nagent analyst(model=\"sonnet\")\nagent synthesizer(model=\"opus\")\n\n# Define perspectives as data\nperspectives = [\n  {view: \"technical\", focus: \"architecture and performance\"},\n  {view: \"business\", focus: \"market impact and ROI\"}\n]\n\n# Fan out: parallel analysis from different perspectives\ndef analyze_perspective(p):\n  return @analyst `Analyze from a {p.view} perspective, focusing on {p.focus}.`(research)\n\nanalyses = pmap(perspectives, analyze_perspective)\n\n# Fan in: combine results\nreport = @synthesizer `Combine these analyses into a unified report.`(analyses)\n```\n\n---\n\n### Reusable Functions\n\n**Problem:** Same workflow pattern repeated in multiple places.\n\n**Solution:** Extract to a function.\n\n```vvm\nagent researcher(model=\"sonnet\")\nagent writer(model=\"opus\")\n\ndef research_and_write(topic):\n  \"\"\"Research a topic and produce a report.\"\"\"\n  research = @researcher `Find key information on {topic}.`(topic)\n  return @writer `Write a clear summary.`(research)\n\n# Reuse across the program\nai_report = research_and_write(\"AI trends\")\nquantum_report = research_and_write(\"quantum computing\")\n```\n\n---\n\n## Cost/Performance Patterns\n\n### Model Tiering\n\n**Problem:** Using expensive models for simple tasks wastes budget.\n\n**Solution:** Match model capability to task complexity.\n\n```vvm\n# Tier 1: Simple tasks (haiku)\nagent formatter(model=\"haiku\", prompt=\"Format text clearly\")\nagent validator(model=\"haiku\", prompt=\"Check for errors\")\n\n# Tier 2: Standard tasks (sonnet)\nagent researcher(model=\"sonnet\", prompt=\"Research thoroughly\")\nagent analyzer(model=\"sonnet\", prompt=\"Analyze data\")\n\n# Tier 3: Complex tasks (opus)\nagent architect(model=\"opus\", prompt=\"Design complex systems\")\nagent synthesizer(model=\"opus\", prompt=\"Synthesize multiple sources\")\n```\n\n**Guidelines:**\n- haiku: Formatting, validation, simple extraction\n- sonnet: Research, analysis, standard generation\n- opus: Complex reasoning, synthesis, creative work\n\n---\n\n### Early Termination\n\n**Problem:** Loops continue even when work is complete.\n\n**Solution:** Check completion conditions and exit early.\n\n```vvm\nagent improver(model=\"sonnet\")\n\ndef is_done(draft, iteration):\n  return ?`production ready with no issues`(draft)\n\ndef improve(draft, iteration):\n  return @improver `Find and fix the most important issue.`(draft)\n\n# Stops as soon as is_done returns true\nfinal = refine(initial_draft, max=10, done=is_done, step=improve)\n```\n\n---\n\n### Context Minimization\n\n**Problem:** Passing entire context bloats prompts and costs.\n\n**Solution:** Pass only what's needed.\n\n```vvm\nagent summarizer(model=\"haiku\")\nagent analyzer(model=\"sonnet\")\n\n# Bad: Pass everything\n# analysis = @analyzer `Analyze.`(huge_document)\n\n# Good: Summarize first, then analyze summary\nsummary = @summarizer `Extract key points only.`(huge_document)\nanalysis = @analyzer `Analyze these key points.`(summary)\n```\n\n**Techniques:**\n- Summarize before passing\n- Extract relevant sections\n- Use `pack()` to select specific fields\n\n---\n\n## Reliability Patterns\n\n### Persistent Agent Memory (Digest + Ledger)\n\n**Problem:** You want continuity across runs, but you don‚Äôt want to re-pass huge context or accidentally persist sensitive data.\n\n**Solution:** Bind `memory` to the agent. When memory is enabled, the runtime injects memory context and a short reminder of the `vvm-memory` patch channel, so you usually don‚Äôt need to restate the protocol in every agent prompt.\n\n```vvm\nagent coach(\n  model=\"sonnet\",\n  prompt=\"\"\"\nYou are a coaching assistant.\n\nHard rules:\n- Never store secrets, tokens, credentials, or private keys.\n - Keep advice concise and actionable.\n\"\"\",\n  memory={ scope: \"project\", key: \"user:alice\" },\n)\n\nreply = @coach `Help me plan my week.`(request)\naudit = @coach `Answer, but don't update memory.`(request, memory_mode=\"dry_run\")\n```\n\n**Benefits:**\n- Continuity without passing full history\n- Inspectable, editable memory on disk\n- Bounded growth (digest stays small; ledger is append-only)\n\n### Graceful Degradation\n\n**Problem:** Single failure breaks entire workflow.\n\n**Solution:** Match on errors and provide fallbacks.\n\n```vvm\nagent primary(model=\"sonnet\")\nagent backup(model=\"haiku\")\n\nresult = @primary `Process request.`(request, timeout=\"30s\")\n\nmatch result:\n  case error(kind=\"timeout\"):\n    result = @backup `Quick fallback.`(request)\n  case error(kind=\"rejected\"):\n    result = { status: \"unavailable\", reason: \"service rejected\" }\n  case error(_):\n    result = @backup `Best effort.`(request)\n  case _:\n    pass  # Success, keep result\n\nexport result\n```\n\n---\n\n### Retry with Backoff\n\n**Problem:** Transient failures cause unnecessary failures.\n\n**Solution:** Use retry with exponential backoff.\n\n```vvm\nagent api_caller(model=\"sonnet\")\n\n# Retry up to 3 times with exponential backoff\nresult = @api_caller `Call external API.`(\n  request,\n  retry=3,\n  backoff=\"exponential\",\n  timeout=\"30s\"\n)\n\n# Still handle final failure\nmatch result:\n  case error(_):\n    result = cached_fallback(request)\n  case _:\n    pass\n```\n\n---\n\n### Constraint Validation\n\n**Problem:** Output quality varies unpredictably.\n\n**Solution:** Use `constrain` blocks to enforce requirements.\n\n```vvm\nagent writer(model=\"opus\")\n\ndraft = @writer `Write technical documentation.`(spec)\n\nconstrain draft(attempts=3):\n  require ?`includes code examples`\n  require ?`covers all API endpoints`\n  require ?`no placeholder text like TODO or TBD`\n\nmatch draft:\n  case error(kind=\"constraint_violation\"):\n    # Handle failed constraints\n    draft = @writer `Fix these issues: {draft.error.data.violations}`(draft)\n  case _:\n    pass\n```\n\n---\n\n### Defensive Validation\n\n**Problem:** Bad input causes cryptic failures deep in workflow.\n\n**Solution:** Validate inputs early.\n\n```vvm\nagent validator(model=\"haiku\")\nagent processor(model=\"sonnet\")\n\ndef process_safely(input):\n  # Validate first\n  if not ?`valid JSON with required fields`(input):\n    raise \"Invalid input format\"\n\n  if not ?`contains necessary data`(input):\n    raise \"Missing required data\"\n\n  # Now process with confidence\n  return @processor `Process validated input.`(input)\n```\n\n---\n\n## Composition Patterns\n\n### Conditional Branching\n\n**Problem:** Different inputs need different processing paths.\n\n**Solution:** Use `choose` for semantic branching.\n\n```vvm\nagent quick_handler(model=\"haiku\")\nagent complex_handler(model=\"opus\")\n\nchoose request by ?`complexity level` as complexity:\n  option \"simple\":\n    result = @quick_handler `Handle quickly.`(request)\n  option \"complex\":\n    result = @complex_handler `Handle thoroughly.`(request)\n\nexport result\n```\n\n---\n\n### Iterative Refinement\n\n**Problem:** First attempt rarely produces best result.\n\n**Solution:** Use `refine` for iterative improvement.\n\n```vvm\nagent writer(model=\"opus\")\nagent critic(model=\"sonnet\")\n\ninitial = @writer `Draft a report on {topic}.`(topic)\n\ndef is_done(draft, i):\n  return ?`ready for publication`(draft) or i >= 5\n\ndef improve(draft, i):\n  critique = @critic `Find issues.`(draft)\n  return @writer `Address these issues.`([draft, critique])\n\nfinal = refine(initial, max=10, done=is_done, step=improve)\n```\n\n---\n\n### Module Organization\n\n**Problem:** Large programs become unwieldy.\n\n**Solution:** Split into focused modules.\n\n```vvm\n# lib/agents.vvm\nagent researcher(model=\"sonnet\", prompt=\"Research expert\")\nagent writer(model=\"opus\", prompt=\"Technical writer\")\nexport @researcher\nexport @writer\n\n# lib/workflows.vvm\nfrom \"./agents.vvm\" import @researcher\nfrom \"./agents.vvm\" import @writer\n\ndef research_and_report(topic):\n  research = @researcher `Research {topic}.`(topic)\n  return @writer `Write report.`(research)\n\nexport research_and_report\n\n# main.vvm\nfrom \"./lib/workflows.vvm\" import research_and_report\n\nreport = research_and_report(\"AI safety\")\nexport report\n```\n\n---\n\n## Summary\n\n| Pattern | When to Use |\n|---------|-------------|\n| Agent Specialization | Multiple distinct task types |\n| Pipeline Composition | Multi-stage transformations |\n| Parallel Independent Work | Independent tasks, `pmap` |\n| Fan-Out Fan-In | Multiple perspectives + aggregation |\n| Reusable Functions | Repeated workflow patterns |\n| Model Tiering | Optimizing cost/capability |\n| Early Termination | Avoiding unnecessary work |\n| Context Minimization | Large inputs |\n| Persistent Agent Memory | Cross-run continuity |\n| Graceful Degradation | Handling failures |\n| Retry with Backoff | Transient failures |\n| Constraint Validation | Quality enforcement |\n| Defensive Validation | Input checking |\n| Conditional Branching | Different processing paths |\n| Iterative Refinement | Quality improvement |\n| Module Organization | Large programs |\n",
        "skills/vvm/spec.md": "---\nrole: language-specification\nsummary: |\n  Complete normative specification for VVM - syntax, semantics, validation rules, and grammar.\nsee-also:\n  - vvm.md: Execution semantics (how to BE the VM)\n  - patterns.md: Design patterns for VVM programs\n  - antipatterns.md: Anti-patterns to avoid\n  - SKILL.md: Skill metadata and quick reference\n---\n\n# VVM\n\n**Vibe Virtual Machine**\n\n*A language for agentic programs where the LLM is the runtime.*\n\nStatus: draft\nVersion: 0.0.4\n\n---\n\n## 0. About This Document (Normative)\n\nThis file is the **language reference** for VVM and the **normative specification** for any VVM runtime.\n\nIn VVM, the ‚Äúruntime‚Äù is typically an AI session in an agentic tool. A conforming runtime must be able to:\n1. Parse a program\n2. Validate it (errors + warnings)\n3. Execute it according to the semantics here\n\n### 0.1 Normative language\n\nThis spec uses:\n- **MUST** / **MUST NOT** for required behavior\n- **SHOULD** / **SHOULD NOT** for strong guidance\n- **MAY** for optional behavior\n\nIf a host tool cannot implement a MUST exactly (due to platform constraints), it SHOULD surface a clear error value rather than silently changing semantics.\n\n### 0.2 Reading guide\n\n- **Authors**: read Sections 1‚Äì14.\n- **Runtime implementers**: read Sections 0, 12, 15, 16.\n- **When uncertain**: prefer conservative behavior that preserves safety (e.g. do not claim a semantic predicate is true if it is unclear).\n\n---\n\n## 0.3 File Format\n\n| Property         | Value                      |\n| ---------------- | -------------------------- |\n| Extension        | `.vvm` (convention)        |\n| Encoding         | UTF-8                      |\n| Case sensitivity | Case-sensitive             |\n| Indentation      | Spaces only (Python-like)  |\n| Line endings     | LF or CRLF                 |\n\nVVM programs are intended to be pasted directly into an AI session along with this spec, but the file format rules make them portable and toolable.\n\n---\n\n## 0.4 Lexical Structure\n\n### 0.4.1 Whitespace and indentation\n\n- Indentation is significant only after `:` (block introducers): `if`, `while`, `for`, `match`, `choose`, `try`, `except`, `finally`, `with input`, and `constrain`.\n- Tabs MUST NOT be used for indentation.\n- A blank line is allowed anywhere and has no effect.\n\n### 0.4.2 Statement boundaries\n\n- A statement normally ends at a newline.\n- Newlines inside `(...)`, `[...]`, `{...}`, or inside string/template literals do not end a statement (implicit line continuation).\n- Trailing commas are allowed in multi-line argument lists, list literals, and object literals.\n\n### 0.4.3 Comments\n\nComments begin with `#` and extend to end of line. Comments are ignored by execution.\n\nRules:\n- `#` inside a string literal (`\"...\"` or `\"\"\"...\"\"\"`) is not a comment.\n- `#` inside a template literal (backticks) is part of the template text, not a comment.\n\n### 0.4.4 Identifiers\n\nIdentifiers match `/[a-zA-Z_][a-zA-Z0-9_]*/`.\n\nReserved keywords MUST NOT be used as **user-defined names** (variables, functions, agents, parameters, import aliases). See Validation Rules.\n\n---\n\n## 0.5 Literals and Templates\n\nVVM has two different ‚Äútext‚Äù syntaxes:\n- **String literals** (`\"...\"`, `\"\"\"...\"\"\"`) are ordinary values.\n- **Template literals** (`` `...` ``) are used for prompts and semantic criteria and support `{...}` placeholders.\n\n### 0.5.1 String literals\n\nSyntax:\n- `\"single line\"`\n- `\"\"\"multi\\nline\"\"\"`\n\nRules (portable):\n- Strings support JSON-style escapes at minimum: `\\\\`, `\\\"`, `\\n`, `\\t`.\n- Unknown escape sequences are validation errors.\n- String literals do not perform interpolation.\n\n### 0.5.2 Template literals (backticks)\n\nTemplate literals are used in:\n- agent calls: `@agent `prompt`(...)`\n- semantic predicates: `?`criteria`(...)` (including in `require ?`...`` and `choose ... by ?`...``)\n\nRules (portable):\n- Templates may be multiline.\n- To include a literal backtick inside a template, escape as ``\\` ``.\n- Backslash has no other special meaning inside templates.\n- Placeholders are `{name}` and `{}` (see Section 5.2). To include literal braces, write `{{` or `}}`.\n\n## 1. Philosophy\n\nVVM is a language for writing programs that run **inside** a modern agentic tool (Claude Code, OpenCode, Amp, etc.). The ‚Äúinterpreter‚Äù is the AI session itself: when you provide a `.vvm` program and this spec, the session simulates the VVM virtual machine and executes the program.\n\nVVM is designed for **human authors**, but with semantics that are executable and portable across tools.\n\nKey design principles:\n- **Minimal syntax**: indentation blocks, familiar control flow, minimal ceremony.\n- **Explicit AI boundary**: LLM invocations are syntactically explicit (`@agent `prompt`(...)`).\n- **Eager and deterministic**: programs run top-to-bottom; parallelism is explicit (e.g. `pmap`).\n- **Semantic control flow**: branching can use semantic predicates and semantic pattern matching (the VM judges meaning, not only booleans).\n- **Portable and conservative**: if uncertain, the VM should prefer safe defaults (avoid claiming success/quality without support).\n\n---\n\n## 2. At a Glance\n\n### 2.1 Minimal research ‚Üí synthesize\n\n```vvm\nimport \"web-search\" from \"github:example/skills\"\n\nagent researcher(model=\"sonnet\", skills=[\"web-search\"])\nagent analyst(model=\"sonnet\")\nagent writer(model=\"opus\")\n\ntopic = \"quantum computing\"\n\nresearch = @researcher `Find 8-12 recent papers on {topic}. Return a bulleted list with links.`(topic)\ntech = @analyst `Technical analysis of the papers.`(research)\nbiz = @analyst `Business analysis and market implications.`(research)\n\nreport = @writer `Write an executive summary combining the technical and business analysis.`([tech, biz])\n\nexport report\n```\n\nThis executes sequentially by default. Use `pmap` (or other explicit helpers) when you know work is safely parallel.\n\n### 2.2 Less boilerplate input passing (implicit `it`)\n\n```vvm\nagent writer(model=\"opus\")\nagent critic(model=\"sonnet\")\n\ndraft = @writer `Draft the report.`()\n\nmatch draft:\n  case ?`needs_work`:\n    critique = @critic `Critique and suggest concrete fixes.`()   # uses implicit input: it == draft\n    draft = @writer `Revise using critique.`([draft, critique])   # overrides input explicitly\n  case ?`ready`:\n    pass\n  case _:\n    draft = @writer `Make it clearer and more structured.`()\n\nexport draft\n```\n\nInside `match draft:`, the VM binds `it = draft` for each arm, so `@critic ... ()` defaults to the matched value.\n\n---\n\n## 3. Core Concepts\n\n### 3.1 Values\n\nVVM is dynamically typed. Values flow between agent calls, control flow, and the standard library.\n\n#### 3.1.1 Literal syntax (portable)\n\n- Unit: `()`\n- Boolean: `true | false`\n- Number: `123`, `3.14` (portable minimum: integers; floats optional)\n- String: `\"...\"` and multiline `\"\"\"...\"\"\"`\n- List: `[v1, v2, ...]` (trailing comma allowed)\n- Object: `{ key: value, ... }` where `key` is an identifier or string (trailing comma allowed)\n- Error (conventional): `{ error: { kind: \"...\", message: \"...\", data?: {...} } }`\n\n#### 3.1.2 Object keys\n\n- Object literal keys are either identifiers (`{ a: 1 }`) or strings (`{ \"a\": 1 }`).\n- If an identifier is used as a key, it is treated as a string key with that spelling.\n\n#### 3.1.3 Equality and truthiness\n\n- `if`/`while` conditions require a boolean `true` or `false`. VVM does not have truthiness; other values are an error (Section 8.1).\n- Equality operators:\n  - `==` and `!=` are defined for `()`, booleans, numbers, strings, lists, and objects using structural equality.\n  - If operand types differ, `==` is `false` and `!=` is `true`.\n  - Comparing functions or agents raises a `thrown` error.\n- Ordering operators (`<`, `<=`, `>`, `>=`) are defined only for numbers; other uses raise a `thrown` error.\n\n### 3.2 Errors (value-based)\n\nErrors are values. VVM distinguishes:\n- **Error values**: ordinary values that represent failure (handled with `match`)\n- **Raised errors**: control-flow abort via `raise` (handled with `try/except`)\n\n#### 3.2.1 Error value recognition (normative)\n\nA value is an error value iff it is an object with a top-level `error` field whose value is an object.\n\nRuntimes MUST NOT treat error values as exceptions. They only affect control flow if your program branches on them.\n\nCommon `kind` values (non-exhaustive):\n- `spawn_failed`\n- `timeout`\n- `rejected` (policy/permissions/host constraints)\n- `constraint_violation`\n- `cancelled`\n- `locked` (could not acquire a required lock, e.g. memory key in use)\n- `thrown`\n\n`thrown` is used for explicit `raise` and for runtime type errors in stdlib helpers. Canonical shape:\n\n```vvm\n{ error: { kind: \"thrown\", message: \"...\" } }\n```\n\nError handling is typically done with `match`:\n\n```vvm\n# assumes @backup is defined\nmatch resp:\n  case error(kind=\"timeout\"):\n    resp = @backup `Use cached response.`(request)\n  case error(_):\n    resp = @backup `Try a different provider.`(request)\n  case _:\n    pass\n```\n\n### 3.2.5 Ref Values (artifact-backed outputs)\n\nA value is a **ref value** iff it is an object with a top-level `ref` field whose value is a string.\n\nRecommended portable shape:\n\n```vvm\n{\n  ref: \".vvm/runs/<run-id>/bindings/b000123.md\",\n  summary: \"1‚Äì3 sentence summary (bounded)\",\n  mime: \"text/markdown\",\n  bytes: 12345\n}\n```\n\nNotes:\n- Only `ref` is required; other keys are optional.\n- This is parallel to how error values are recognized by shape (Section 3.2).\n- Ref values are returned by agent calls in **filesystem state mode** (Section 3.4.2A).\n- The `summary` field MUST be bounded (1‚Äì3 sentences) to prevent token bloat.\n\n### 3.3 Agents\n\nAgents are named configuration templates. They live in an **agent namespace**, referenced with `@name` in calls.\n\n#### 3.3.1 Definition syntax\n\n```vvm\nagent researcher(\n  model=\"sonnet\",\n  skills=[\"web-search\"],\n  prompt=\"thorough, cite sources\",\n  permissions=perm(network=\"allow\", read=[\"**/*\"], write=[], bash=\"deny\"),\n)\n```\n\n#### 3.3.2 Standard agent keys (portable)\n\nAgent config keys are host/tooling-dependent, but VVM standardizes a small portable subset:\n- `model`: model tier/name\n- `prompt`: system/persona guidance (agent-level)\n- `skills`: skill identifiers (strings; see Section 11.2)\n- `permissions`: sandbox permissions (see `perm(...)`)\n- `memory`: agent memory binding (see Section 3.5)\n\nTerminology:\n- `agent(..., prompt=\"...\")` is the agent‚Äôs **system/policy** prompt.\n- The backtick template in `@agent `...`(...)` is the call‚Äôs **task prompt**.\n\nOther agent config keys are host-defined. VVM intentionally does not standardize a `tools` key in MVP; prefer `skills` + `permissions` for portability.\n\nFor readability, parenthesized argument lists may span multiple lines and may include trailing commas (Python style).\n\n#### 3.3.3 Permissions (portable)\n\n`permissions` is an object (often created with `perm(...)`) that the runtime passes to the host tool so the subagent is sandboxed.\n\nPortable permission keys and value shapes:\n- `read`, `write`, `execute`: lists of glob patterns (empty list means no access)\n- `bash`, `network`: `\"allow\" | \"deny\" | \"prompt\"`\n\nIf the host tool cannot enforce a permission rule, the runtime SHOULD treat attempted access as rejected and return an error value of kind `rejected` rather than silently allowing it.\n\n#### 3.3.4 Skills (portable)\n\n`skills=[...]` is an array of skill names (strings). Skills are declared via module-scope skill imports (Section 11.2).\n\nThe runtime passes the selected skills to the host tool. The meaning of a skill is host-defined (often: tool integrations + conventions).\n\n#### 3.3.5 Validation\n\n- Agent declarations should be configuration only: values must be literals/lists/objects (and helper constructors like `perm(...)`).\n- Agent declarations must not contain agent calls; if you need runtime-dependent configuration, derive an agent at the call site with `.with(...)` or use an inline agent literal.\n- If `skills=[...]` is present, each element should be a string skill name. Empty `skills=[]` should warn.\n- If an agent references a skill name that is not imported in the same module, the runtime should warn (best-effort).\n- If `memory=...` is present, it should be an object literal with the shape described in Section 3.5 (portable).\n\n#### Derived agents (`.with(...)`)\n\n`@agent.with(...)` creates a derived agent with overrides:\n\n```vvm\nsummary = @researcher.with(model=\"haiku\", prompt=\"brief\") `Summarize key points.`(research)\n```\n\nMerge rules:\n- scalars override\n- objects shallow-merge\n- lists replace (no implicit concatenation)\n\n#### Inline agent literals\n\n```vvm\nanswer = @{model=\"haiku\", prompt=\"brief\"} `Answer concisely.`(question)\n```\n\nInline agent literals use `key=value` (like function arguments), not object-literal `key: value`.\n\n### 3.4 The AI Boundary (Agent Calls)\n\nAgent calls are the boundary between ‚Äúnormal evaluation‚Äù and ‚Äúdelegate work to an LLM subagent‚Äù. They are the only construct that requires spawning a subagent.\n\n#### 3.4.1 Syntax\n\nThe core executable primitive is an **agent call**:\n\n```\n@agent `task template`(input?, retry=..., timeout=..., backoff=..., name=..., memory_mode=...)\n```\n\nEvaluating an agent call expression executes the call immediately (spawns a subagent) and yields a concrete value (or an error value).\n\n#### 3.4.2 Execution semantics (portable)\n\nTo evaluate `@agent `template`(...)`:\n1. Resolve the agent reference (`@name`, `@name.with(...)`, or inline `@{...}`) to an agent configuration object\n2. Determine the call input value: the first positional argument if present, otherwise the current `it`\n3. Evaluate option expressions (`retry`, `timeout`, `backoff`, `name`, `memory_mode`, plus any unknown option values)\n4. Render the template to a task prompt string (Section 5), using `{}` as the call input and `{name}` from the current environment\n5. If the agent has `memory=...` and `memory_mode!=\"fresh\"`, load and inject memory context as described in Section 3.5\n6. Spawn the subagent with (agent config, task prompt string, structured input value) and wait for completion\n7. If the host reports success:\n   - extract and apply any memory patch as described in Section 3.5 (depending on `memory_mode`)\n   - return the subagent's **user-visible output** as a VVM value (a string)\n8. If the host reports failure, return an error value (Section 3.2) and do not modify memory.\n\n#### 3.4.2A State Mode and Output Type\n\nThe runtime operates in one of two **state modes**:\n\n| Mode | Agent call returns | State storage |\n|------|-------------------|---------------|\n| **in-context** (default) | string | Token context only |\n| **filesystem** | ref value | `.vvm/runs/<run-id>/` |\n\nIn **in-context mode** (today's default), agent calls return a **string** (the subagent's final response text).\n\nIn **filesystem state mode**, agent calls return a **ref value** (Section 3.2.5). The VM instructs subagents to write full output to a binding file and return only a confirmation + bounded summary.\n\nMode selection:\n- Default: in-context (backward compatible)\n- Override: `--state=filesystem` flag\n\n#### 3.4.3 Result value\n\nFor portability (Prose-like), a successful agent call yields a **string**: the subagent's final response text.\n\nNotes:\n- Hosts/tools may provide richer result objects; runtimes SHOULD extract the human-visible final output text.\n- VVM 0.0.1 does not automatically parse JSON or VVM literals out of that text. If you want structured outputs, ask the agent to return a structured format and treat it as text (future versions may add parsing helpers).\n\n#### 3.4.3A Template Interpolation of Ref Values\n\nWhen interpolating a ref value into a template (e.g., `{}` or `{name}`), the VM MUST use a **small, safe preview**, not the full artifact content.\n\nRequired interpolation format:\n\n```text\n[ref: .vvm/runs/<run-id>/bindings/b000123.md]\nsummary: <summary text>\n```\n\nThis ensures:\n- The VM's own context stays bounded even when passing large intermediates.\n- Downstream agents see a pointer they can read if needed.\n\nExample:\n\n```vvm\nresearch = @researcher `Research {topic}.`(topic)   # returns ref value\nreport = @writer `Write a report about {research}.`(research)\n# The {research} interpolation produces:\n#   [ref: .vvm/runs/.../bindings/b000001.md]\n#   summary: Found 3 papers on quantum computing...\n```\n\n#### Required delimiter\n\nAgent calls MUST use parentheses `(...)` (even if empty) to avoid ambiguity and keep the surface predictable for humans and for the VM.\n\n#### Input is the first positional argument\n\nThe first positional argument is the **structured input context**.\n\nExamples:\n\n```vvm\n@writer `Write a summary.`()            # uses implicit input `it`\n@writer `Write a summary.`(doc)         # explicit input\n@writer `Compare.`([a, b])              # multiple inputs (list)\n@writer `Explain.`(pack(a=a, b=b))      # named fan-in (object)\n@writer `Start fresh.`(())              # explicit empty context\n```\n\nYou can always override the implicit input by passing an explicit first argument.\n\nNote: `@agent `...`()`` means \"use `it`\", not \"empty input\". Use `@agent `...`(())` to explicitly pass empty input.\n\n#### Structured Input Passing with Ref Values\n\nWhen passing structured input to a subagent that contains ref values, the VM MUST:\n\n1. **Pass the ref object itself** (not expanded file contents).\n2. **Include a \"Ref Reading Protocol\" instruction** telling the subagent how to access full content if needed.\n\nRef Reading Protocol snippet (included in subagent context):\n\n```text\n## Ref Reading Protocol\nSome inputs are ref values (objects with a `ref` field pointing to a file path).\n- The `summary` field provides a bounded preview.\n- If you need full content, read the file at the `ref` path (requires read permission).\n- Cite by path when referencing specific content.\n```\n\nThis ensures:\n- Subagents receive pointers, not megatext.\n- Subagents can access full content when genuinely needed.\n- Token usage scales with actual need, not worst-case output size.\n\n#### Call options (portable subset)\n\nCall options are keyword arguments after the (optional) first positional input:\n- `retry=<int>`: retry on `spawn_failed`, `timeout`, and transient `rejected` best-effort\n- `backoff=\"fixed\" | \"exponential\"`: optional retry backoff hint\n- `timeout=\"<duration>\"`: e.g. `\"30s\"`, `\"5m\"`\n- `name=\"<string>\"`: a stable label for logs/tracing\n- `memory_mode=\"continue\" | \"dry_run\" | \"fresh\"`: agent memory usage (Section 3.5)\n\nRuntimes may support additional options, but should ignore unknown keys conservatively rather than reinterpret them.\n\n`memory_mode=` semantics:\n- `continue` (default if `memory` is bound): read memory context and apply valid memory patches after success\n- `dry_run`: read memory context but do not apply any memory patch (no writes)\n- `fresh`: do not read memory and do not apply any memory patch (stateless call)\n\n`retry=` semantics:\n- `retry=n` means ‚Äútry the call up to `1 + n` times‚Äù.\n- Retries occur only if the previous attempt returned an error value of kind `spawn_failed`, `timeout`, or `rejected`.\n- Each retry reuses the same agent configuration, rendered prompt, and input value.\n- The final result is the first non-error value, or the last error value if all attempts fail.\n\n`timeout=` semantics:\n- If an attempt exceeds `timeout`, it returns an error value of kind `timeout` (and may be retried if `retry` is set).\n\nExamples:\n\n```vvm\nwith input request:\n  # assumes @api is defined\n  resp = @api `Call service.`(retry=3, backoff=\"exponential\", timeout=\"30s\")\n```\n\n#### Input passing (structured, not string-based)\n\nSemantically, an agent call has **two channels**:\n1. **Prompt text**: the rendered template (after interpolation)\n2. **Input value**: the call input (explicit first argument, or implicit `it`)\n\nThe runtime MUST pass the input value to the subagent as **structured context** if the host tool supports it (e.g. a dedicated context parameter or a separate input message). In that case, the VM should treat prompt and input as distinct‚Äîdo not ‚Äúsmuggle‚Äù input by interpolating it into the task template.\n\nThis spec describes how the subagent should conceptually receive the input, not a requirement that the runtime literally concatenates strings.\n\n#### Text encoding fallback (interoperability)\n\nIf the host tool only supports a single text prompt (no separate context channel), the VM MUST encode the input value into the text using a clear delimiter:\n\nCanonical encoding:\n\n```text\n<rendered prompt>\n\nInput:\n---\n<serialized value>\n---\n```\n\nSize-based serialization guidance:\n- `< 2k chars`: inject verbatim\n- `2k‚Äì8k`: summarize + include key excerpts\n- `> 8k`: extract essentials only + include stable references/handles if available\n\nIf the call input is `()`, the VM may omit the `Input:` section entirely.\n\n#### Why this exists\n\nEven on tools with subagents, the subagent ultimately sees tokens. A portable spec needs a canonical, tool-agnostic representation of ‚Äúthe input‚Äù (with summarization rules) so different runtimes converge on similar behavior.\n\n#### Canonical value serialization (portable)\n\nWhen the VM needs to serialize a value to text (for fallback input encoding or for interpolation summaries), it should use a JSON-like representation:\n- Lists serialize as JSON arrays.\n- Objects serialize as JSON objects with string keys.\n- Object keys should be serialized in a stable order (lexicographic by key) to reduce nondeterminism across runtimes.\n- Error values serialize like any other object.\n\n---\n\n## 3.5 Agent Memory\n\nVVM provides **portable, file-backed agent memory** that works even when the host tool has no native ‚Äúpersistent subagents‚Äù.\n\nDesign goals:\n- explicit when memory is used vs ignored\n- inspectable/editable outside the runtime\n- bounded context injection (no ‚Äúload everything forever‚Äù)\n- safety by default (avoid persisting secrets)\n- clear concurrency rules (safe under explicit parallelism like `pmap`)\n\n### 3.5.1 Agent key: `memory=...` (portable)\n\nAgents MAY include a `memory` binding:\n\n```vvm\nagent helper(\n  model=\"sonnet\",\n  prompt=\"Helpful, practical.\",\n  memory={ scope: \"project\", key: \"user:alice\" },\n)\n```\n\n`memory` is an object with keys:\n- `scope`: `\"project\" | \"user\" | \"path\"`\n- `key`: string (memory identity; must not collide unintentionally)\n- `path`: required iff `scope==\"path\"` (string path to a memory directory root)\n\nNotes:\n- The agent‚Äôs name is not the memory identity; `(scope, key)` is.\n- Use separate keys to isolate users/threads/tenants (e.g., `user:alice/ticket:INC-1234`).\n\n### 3.5.2 Call option: `memory_mode=...` (portable)\n\nAgent calls MAY set:\n- `memory_mode=\"continue\"` (default if `memory` is bound): read memory and apply valid memory patches after success\n- `memory_mode=\"dry_run\"`: read memory but do not apply any memory patch (no writes)\n- `memory_mode=\"fresh\"`: do not read memory and do not apply any memory patch (stateless)\n\nIf no `memory` binding exists, `memory_mode` has no effect.\n\n### 3.5.3 Filesystem layout (portable minimum)\n\nGiven `memory={scope:S, key:K, path:P?}`, the runtime resolves a memory directory `D`:\n- `S==\"project\"` ‚Üí `D = <project>/.vvm/memory/<escape(K)>`\n- `S==\"user\"`    ‚Üí `D = ~/.vvm/memory/<escape(K)>`\n- `S==\"path\"`    ‚Üí `D = P/<escape(K)>` (or `D=P` if `P` is already key-specific; host-defined)\n\n`<project>` is the directory containing the program‚Äôs entry module (the file executed by the host). If the host has no entry file (e.g. pasted program), it SHOULD treat the current working directory as `<project>`; if no such directory exists, it SHOULD return an error value of kind `rejected` for `scope=\"project\"`.\n\n`escape(K)` MUST be reversible and safe for filesystem paths. Runtimes SHOULD document the exact encoding and SHOULD encourage human-friendly keys (e.g., ASCII).\n\nPortable minimum files under `D`:\n- `digest.md` (UTF-8 text; may be empty)\n- `ledger.jsonl` (append-only JSON Lines; may be empty)\n- `meta.json` (optional; schema version, timestamps)\n- `lock` (optional; for single-writer locking)\n\nRuntimes MAY add derived views (e.g., `journal/YYYY-MM-DD.md`) as long as `digest.md` + `ledger.jsonl` remain the canonical durable memory.\n\n### 3.5.4 Loading memory into an agent call (portable)\n\nIf `memory_mode` is `continue` or `dry_run`, the runtime MUST:\n1. load `digest.md` (or treat as empty)\n2. optionally select a **token-budgeted** recent tail of retained facts from `ledger.jsonl`\n3. inject a **memory context** into the call prompt (usually by prepending a clearly delimited section)\n\nThe retrieval strategy beyond ‚Äúrecent tail‚Äù is intentionally unspecified in MVP.\n\nTo avoid authors re-stating the memory patch protocol in every agent prompt, the injected memory context MUST include a short ‚ÄúMemory Update Protocol‚Äù instruction snippet describing how to emit a `vvm-memory` block (Section 3.5.5) and noting that patches are ignored when `memory_mode=\"dry_run\"`.\n\n### 3.5.5 Memory patch channel (portable)\n\nAgents update memory via a reserved fenced block in their output:\n\n````text\n...user-visible response...\n\n```vvm-memory\n{ \"digest\": \"...\", \"retain\": [\"W @X: ...\", \"N @X: ...\"] }\n```\n````\n\nPatch parsing rules:\n- If a `vvm-memory` block is present, the runtime MUST remove it from the returned string value of the agent call.\n- The block contents MUST be parsed as a JSON object. If parsing fails, the runtime SHOULD ignore the patch (no writes).\n\nPatch schema:\n- `digest` (string, optional): full replacement contents for `digest.md`\n- `retain` (list of strings, optional): narrative facts to append to the ledger for later recall\n\nApplying patches:\n- In `memory_mode=\"continue\"`: if the patch is valid and passes safety checks, the runtime MUST:\n  - update `digest.md` atomically (write temp + rename)\n  - append a JSONL ledger entry capturing at least `{ ts, digest?, retain? }`\n- In `memory_mode=\"dry_run\"` or `\"fresh\"`: the runtime MUST NOT write to `digest.md` or `ledger.jsonl` (it still strips the patch block from output).\n\n### 3.5.6 What goes in `digest.md` vs `retain` (guidance)\n\n`digest.md` should contain the **working set**: things you want injected on every stateful call because they have high expected value:\n- stable facts and preferences\n- constraints/invariants\n- a small ‚Äúwhat‚Äôs next‚Äù list (open loops)\n\n`retain` items should be **findable later**, but not always loaded:\n- narrative, self-contained facts about what happened or what was learned\n- longer-tail details that support recall, debugging, and future compaction\n\nRecommended conventions for `retain` lines (optional, for interoperability):\n- `W ‚Ä¶` world facts\n- `B ‚Ä¶` what happened / what we did\n- `O(c=0.0..1.0) ‚Ä¶` opinions/preferences with confidence\n- `N ‚Ä¶` what‚Äôs next / follow-up (keep current ones in the digest)\n- `@Entity` mentions to make recall entity-centric\n\n### 3.5.7 Safety by default (portable)\n\nTo reduce accidental secret persistence:\n- The runtime MUST NOT persist raw call inputs or raw agent outputs as part of this memory system.\n- The only durable writes are `digest.md` updates and `ledger.jsonl` entries derived from the `vvm-memory` patch.\n- Runtimes SHOULD reject patches that appear to contain secrets (API keys, tokens, private keys) and apply no writes in that case.\n\n### 3.5.8 Concurrency rules (portable)\n\nFor a given memory directory `D`, the runtime MUST prevent concurrent writes that can corrupt state.\n\nMinimum requirement:\n- `memory_mode=\"continue\"` MUST acquire an exclusive lock for `D` across the whole operation (load ‚Üí run agent ‚Üí validate patch ‚Üí apply patch).\n\nIf the lock cannot be acquired within an implementation-defined timeout, the runtime SHOULD return an error value (e.g., `error(kind=\"locked\")`) rather than proceeding unsafely.\n\nGuidance under `pmap`:\n- avoid sharing the same `memory.key` across parallel calls unless you intentionally want serialization\n- prefer `memory_mode=\"fresh\"` for parallel map work, then do a single sequential memory update\n\n---\n\n## 4. Implicit Input (`it`) and Context Passing\n\nVVM keeps context passing explicit (the first call argument), but provides a convenience binding: `it`.\n\n### 4.1 What is `it`?\n\n`it` is an implicit, lexically-scoped value that acts as the **default input** for:\n- agent calls with no positional input: `@a `...`()`\n- semantic predicates with no input (see `?` below)\n\nAt top-level, `it` starts as `()`.\n\n### 4.2 Setting `it` with `with input`\n\n```vvm\nwith input draft:\n  critique = @critic `Critique.`()\n  revised = @writer `Revise using critique.`([draft, critique])\n```\n\nInside the block, `it = draft`. The input expression is evaluated once at block entry. You can still override per call by passing an explicit first argument.\n\n### 4.3 `match` also sets `it`\n\nIn `match value:`, each arm runs with `it = value`.\n\n### 4.4 Interpolation is not context passing\n\n`{name}` interpolation inserts a summary into the prompt text. It is not a substitute for structured input.\n\nPrefer passing structured input as the first argument in `(...)` for large/structured values.\n\n### 4.5 Names, Scope, and Mutability (Normative)\n\nVVM follows Python-like execution and scoping rules, with one special-case: `it`.\n\n#### Variables\n\n- `name = expr` creates or updates a variable binding in the **current function scope**.\n- There is no `let`/`const` in MVP; variables are mutable by reassignment.\n- Blocks (`if`, `while`, `for`, `match`, `choose`, `try`) do **not** introduce a new variable scope (like Python). Assignments inside these blocks affect the surrounding function scope.\n- Each `def` has a local scope. The set of **local names** for a function is:\n  - its parameter names\n  - any name that appears as an assignment/binding target anywhere in the function body:\n    - `name = expr`\n    - `for name in items:`\n    - `except as name:`\n    - `choose ... as name:`\n  (This is Python-like: assignment anywhere makes the name local.)\n- Evaluating an identifier `name` inside a function:\n  1. If `name` is in the function‚Äôs local-name set:\n     - if `name` is currently bound, return its value\n     - otherwise, raise a `thrown` error (‚Äúunbound local‚Äù)\n  2. Otherwise, resolve `name` in module scope (including imported values and hoisted `def`s).\n  3. Otherwise, resolve `name` in the standard library.\n  4. Otherwise, raise a `thrown` error (‚Äúunbound name‚Äù).\n\n#### The special binding `it`\n\n- `it` is **lexically scoped** and is pushed/popped by `with input ...:` and by `match`/`choose` arms/options.\n- After leaving a `with input` block or a `case`/`option` body, `it` is restored to its previous value.\n- Ordinary assignments cannot rebind `it` directly.\n- `it` MUST NOT be used as a user-defined name (variable/function/agent/parameter/import alias).\n\n#### Namespaces\n\n- Agents live in an agent namespace and are referenced with `@name` (or `@{...}` inline).\n- Functions and variables share a namespace; `f(...)` calls `f` if it is a function, otherwise the VM raises a `thrown` error.\n\n---\n\n## 5. Prompts, Templates, and Interpolation\n\n### 5.1 Template literal: `` `...` ``\n\nVVM uses backtick templates for prompts and semantic criteria:\n\n```vvm\ntopic = \"AI safety\"\n@researcher `Research {topic}.`(topic)\n```\n\nTemplates can be multiline. To include a literal backtick, escape as ``\\` ``.\n\nTemplates are used in:\n- agent calls (`@agent `...``)\n- semantic predicates (`?`...``) including `require ?`...`` and `choose ... by ?`...``\n\n### 5.2 Placeholders\n\nTemplates support two placeholder forms:\n- `{}`: the template's **primary input**\n- `{name}`: a lookup of an in-scope binding by identifier\n\nPrimary input depends on where the template appears:\n- agent call template: the call input (explicit first positional argument, or `it` if omitted)\n- semantic predicate template: the predicate input (explicit argument, or `it` if omitted); for `require` and `choose by`, this is always `it`\n\n#### Escapes\n\n- To write a literal `{` or `}` in a template, escape by doubling: `{{` and `}}`.\n- To write a literal `{}` sequence, use `{{}}`.\n\n#### Template parsing (portable)\n\nThe VM MUST parse templates left-to-right:\n- `{{` becomes a literal `{`\n- `}}` becomes a literal `}`\n- `{}` becomes the primary-input placeholder\n- `{name}` becomes a name placeholder where `name` matches the identifier regex\n\nAny other unescaped `{` or `}` is a validation error.\n\n#### Placeholder validation\n\nTo catch typos early (Prose-like), runtimes MUST validate every `{name}` placeholder:\n- `name` MUST be a valid identifier and MUST NOT be a reserved keyword.\n- If `name` does not refer to any statically-known binding and is not a stdlib identifier, it is a validation error.\n  - In a `def`, ‚Äústatically-known‚Äù means: a parameter name, or a name in the function‚Äôs local-name set (Section 4.5), or an imported/hoisted module value (`from ... import name`, `def name(...)`).\n  - At module top-level, ‚Äústatically-known‚Äù means: an imported/hoisted module value, or a name assigned somewhere in the module.\n\nThis validation is intentionally conservative and does not prove ‚Äúassigned before use‚Äù.\n\n#### Placeholder resolution at runtime (portable)\n\nWhen rendering a template:\n- `{}` uses the primary input value.\n- `{name}` is resolved using the normal identifier lookup rules (Section 4.5).\n- If `{name}` is not bound at render time, the VM raises a `thrown` error.\n\nIf template rendering raises, the enclosing operation raises and does not proceed:\n- In an agent call, the VM MUST NOT spawn the subagent.\n- In a semantic predicate (`?`), predicate evaluation raises.\n\n### 5.3 Formatting rules (portable)\n\nWhen interpolating values into template text:\n- short strings are inserted verbatim\n- long strings/lists/objects are summarized to 1‚Äì3 lines and include a stable reference label like `[see input]`\n\nThe full value should be provided via structured input whenever possible.\n\n---\n\n## 6. Semantic Predicates (`?`)\n\nVVM has a semantic predicate form evaluated **locally by the VM** (no subagent):\n\n```vvm\nok = ?`high_quality`(draft)\n```\n\nSyntax:\n- `?`template`` uses implicit input `it`\n- `?`template``(input)` uses explicit input\n\nReturn value:\n- Semantic predicates normally evaluate to a boolean `true` or `false`.\n- If evaluation fails (e.g. template rendering fails), the predicate raises a `thrown` error.\n\nPurity rule (portable):\n- Predicate evaluation MUST NOT call tools, read files, or spawn subagents. It is a local judgment by the VM.\n\nExamples:\n\n```vvm\nwith input draft:\n  if ?`ready to publish`:\n    pass\n```\n\nPortability rule: if uncertain, return `false`.\n\nTemplate rendering:\n- The predicate template is rendered using the same placeholder rules as task templates (`{name}`, `{}`), then evaluated semantically.\n- The predicate input is evaluated before semantic judgment.\n\n---\n\n## 7. Semantic Pattern Matching (`match`)\n\n`match` is VVM‚Äôs primary semantic control flow.\n\n```vvm\n# assumes @publisher, @backup, @worker are defined\nmatch result:\n  case ?`ready and high_quality`:\n    publish = @publisher `Publish.`()\n  case error(kind=\"timeout\"):\n    result = @backup `Use cached value.`(request)\n  case _:\n    result = @worker `Improve and retry.`()\n```\n\n### 7.1 Match semantics\n\n1. Evaluate the scrutinee (`result`) to a value and bind `it` to it for case selection/execution\n2. Check cases top-to-bottom\n   - If evaluating a semantic-predicate `case` pattern raises, the `match` statement raises.\n3. Execute only the first matching case body\n\nNon-chosen cases MUST NOT be executed.\n\n### 7.2 Patterns\n\nSupported pattern forms:\n- `_` wildcard\n- `error(_)` any error\n- `error(kind=\"timeout\")` error kind match\n- semantic predicates: `?` + template literal (evaluated against the scrutinee via implicit `it`)\n\nIn a `match`, each case body runs with `it = <scrutinee>`, so semantic cases typically omit the input:\n\n```vvm\nmatch draft:\n  case ?`needs_work`:\n    draft = @writer `Revise.`()\n  case _:\n    pass\n```\n\nThe VM evaluates `?` predicates semantically and locally, using `it` (the scrutinee) as context.\n\nFor portability and clarity, `case ?`template`(input):` is not allowed. If you want to predicate on a different value, write `match` on that value or use an `if` inside the case body.\n\n---\n\n## 8. Control Flow\n\n### 8.1 `if / elif / else`\n\n`if` conditions are boolean expressions. Semantic conditions are expressed via `?`:\n\nBoolean operators:\n- `and` / `or` are short-circuiting.\n- `not` negates a boolean.\n\nIn MVP:\n- Arithmetic operators `+` and `-` are defined only for numbers; other uses raise a `thrown` error.\n- Ordering operators (`<`, `<=`, `>`, `>=`) are defined only for numbers; other uses raise a `thrown` error.\n- Equality operators (`==`, `!=`) follow Section 3.1.3.\n\nIn `if`/`while`, the condition expression is evaluated and must produce a boolean; otherwise the VM raises a `thrown` error.\n\n```vvm\n# assumes @deploy and @fixer are defined\nif ?`the code is production ready`(code):\n  ship = @deploy `Deploy.`(code)\nelse:\n  code = @fixer `Improve the code.`(code)\n```\n\n### 8.2 `while`\n\n```vvm\n# assumes @critic and @writer are defined\ni = 0\nwhile i < 3 and not ?`ready`(draft):\n  critique = @critic `Critique.`(draft)\n  draft = @writer `Revise.`([draft, critique])\n  i = i + 1\n```\n\nSemantics (MVP):\n- Evaluate the condition expression before each iteration; it MUST produce a boolean, otherwise raise a `thrown` error.\n- If the condition is `false`, exit the loop.\n- If the condition is `true`, execute the loop body, then repeat.\n- `break` exits the nearest enclosing loop; `continue` skips to the next iteration.\n\n### 8.3 `for`\n\n```vvm\n# assumes @worker is defined\nfor item in items:\n  with input item:\n    out = @worker `Process this.`()\n```\n\nVVM also provides collection helpers in the standard library (`map`, `pmap`, `filter`, `reduce`) to reduce boilerplate.\n\nSemantics (MVP):\n- The `items` expression is evaluated and must be a list; otherwise the VM raises a `thrown` error.\n- The loop variable (`item`) is assigned for each iteration in the surrounding function scope (like Python).\n- `break` and `continue` affect the nearest enclosing loop.\n\n### 8.4 `pass`, `break`, `continue`\n\n- `pass` is a no-op.\n- `break` exits the nearest enclosing loop.\n- `continue` skips to the next loop iteration.\n\n---\n\n## 9. Constraints (`constrain`) and Requirements (`require`)\n\nConstraints are a standard way to turn fuzzy quality requirements into explicit, portable checks.\n\n### 9.1 `constrain <name>(...)`\n\n`constrain` attaches requirements to an existing binding and rewrites it to an error on violation.\n\n```vvm\ndraft = @writer `Draft a report with citations.`(research)\n\nconstrain draft(attempts=3, time=\"10m\"):\n  require ?`citations >= 5`\n  require ?`no hallucinations`\n  require ?`reading level: executive`\n```\n\nSemantics:\n1. Evaluate `draft` to a value `v`\n2. Evaluate each `require ?`template`` as a semantic predicate against `it = v`; `it` is restored after constraint evaluation\n   - If any `require` evaluation raises, the `constrain` statement raises.\n3. If all pass: rebind `draft = v`\n4. Else: rebind `draft` to:\n\nPortability rule: if a requirement is uncertain, treat it as violated.\n\n```vvm\n{\n  error: {\n    kind: \"constraint_violation\",\n    message: \"Constraints not satisfied\",\n    data: {\n      value: <original_value>,\n      violations: [...],\n      requirements: [...]\n    }\n  }\n}\n```\n\n### 9.2 Resource bounds (best-effort)\n\n`constrain name(...)` may include:\n- `attempts=<int>`: guidance for refinement loops\n- `time=\"<duration>\"`: time budget hint\n- `budget=<number>`: cost/token budget hint (tooling-dependent)\n\nThese do not automatically retry; they provide machine-readable bounds for helper loops like `refine`.\n\n---\n\n## 10. Choice (`choose`)\n\n`choose` selects one option among alternatives, based on a semantic criterion. It is like `match`, but comparative.\n\n```vvm\n# assumes @planner is defined\nchoose analysis by ?`best approach given the constraints` as choice:\n  option \"quick\":\n    plan = @planner `Make a minimal plan.`()\n  option \"thorough\":\n    plan = @planner `Make a thorough plan with risks.`()\n\nexport choice\nexport plan\n```\n\nSemantics:\n1. Evaluate the scrutinee (`analysis`) to a value and bind `it` to it for selection/execution\n2. Evaluate the semantic predicate `?`...`` against `it`\n   - If evaluation raises, the `choose` statement raises.\n3. Select an option label using the criterion, conservatively, **without executing any option bodies**\n4. Assign the chosen option label (a string) to the `as <name>` variable (`choice` in this example)\n5. Execute only the chosen option body\n\nWithin each option body, `it` remains bound to the scrutinee.\n\nTie-break rule: if multiple options are equally plausible, choose the first option in source order.\n\nPurity rule (portable):\n- Option selection MUST NOT call tools, read files, or spawn subagents. It is a local judgment by the VM.\n\n---\n\n## 11. Functions, Skills, and Modules\n\n### 11.1 `def`\n\nFunctions are reusable subgraphs and can call agents.\n\nSemantics:\n- Arguments are evaluated at call time and passed by value.\n- A function body executes sequentially like top-level code.\n- `return expr` returns the value of `expr`.\n- `return` (without a value) returns `()`.\n- If control reaches the end of the function, it returns `()`.\n- The implicit input `it` is inherited from the caller (and can be overridden with `with input ...:` inside the function).\n- Functions are first-class values: referencing a function name yields a callable that can be passed to stdlib helpers like `map`/`pmap`.\n- Top-level `def` declarations are hoisted at module load time (so functions may be called before their textual definition).\n\nFunction call argument binding:\n- Positional arguments bind left-to-right to parameters.\n- Keyword arguments bind by parameter name.\n- The VM raises a `thrown` error if:\n  - too many positional arguments are provided,\n  - a keyword does not match any parameter,\n  - the same parameter is provided twice (positional + keyword, or duplicate keyword),\n  - a required parameter is missing.\n\n```vvm\n# assumes @researcher and @analyst are defined\ndef deep_research(topic):\n  papers = @researcher `Find papers on {topic}.`(topic)\n  return @analyst `Extract key insights.`(papers)\n```\n\n### 11.2 Skill imports\n\nSkills are host-defined extensions (often tool integrations + conventions) that can be assigned to agents via `skills=[...]`.\n\nVVM uses a Prose-like skill import statement:\n\n```vvm\nimport \"web-search\" from \"github:anthropic/skills\"\nimport \"summarizer\" from \"npm:@example/summarizer\"\nimport \"file-writer\" from \"./local-skills/file-writer\"\n```\n\nSupported source forms:\n- GitHub: `github:user/repo`\n- NPM: `npm:package`\n- Local path: `./path` or `../path`\n\nSemantics:\n- Skill imports are **module-scope only** and processed before agent calls execute.\n- `import \"<skill-name>\" from \"<source>\"` registers `<skill-name>` in the module‚Äôs imported-skill set.\n- Duplicate imports of the same `<skill-name>` within a module are a validation error.\n- If multiple modules in the same program import the same `<skill-name>`, they must agree on `<source>`; otherwise it is a validation error.\n- If `<source>` has an unknown format, the runtime should warn (best-effort) and still register the skill name (the host may still be able to resolve it).\n- If an agent‚Äôs `skills=[...]` references a skill name that is not imported in the same module, the runtime should warn (best-effort). The program may still run if the host provides that skill by default.\n\nSkill imports do not introduce value bindings (there is no identifier created). They exist to make dependencies explicit and portable.\n\n### 11.3 Module imports\n\n```vvm\nfrom \"./lib/research.vvm\" import deep_research\nfrom \"./lib/research.vvm\" import @researcher as researcher_agent\n```\n\nModule imports are processed before execution.\n\nSemantics:\n- If the import string starts with `./` or `../`, it is resolved relative to the directory of the importing module file (not the process CWD).\n- Otherwise, the import string is interpreted as a host-defined module identifier (future: registries); MVP runtimes may restrict this to local file paths only.\n- After resolution, the runtime computes a canonical module identity (lexically normalize `.`/`..` segments). Importing the same canonical module multiple times refers to the same module.\n- A module‚Äôs exports are declared by `export ...` statements in that module.\n- Importing `name` imports a value/function export into the value namespace.\n- Importing `@name` imports an agent export into the agent namespace (accessible as `@alias`).\n- If the referenced module or exported name cannot be resolved, it is a validation error.\n\n#### Module resolution procedure (normative)\n\nWhen encountering `from \"path\" import ...`:\n\n1. **Compute resolved path**: If `path` starts with `./` or `../`, resolve relative to the directory containing the importing file. Otherwise, treat as host-defined identifier.\n\n2. **Verify file exists**: The runtime MUST use `test -f <resolved_path>` (via Bash tool) to verify the file exists. The runtime MUST NOT assume a file exists without verification.\n\n3. **On file not found**: If `test -f` returns non-zero (file does not exist), emit error E090 with message: `Module not found: {resolved_path}`. Halt validation.\n\n4. **Read and parse module**: If file exists, use the Read tool to load the file contents, then parse as a VVM module. Syntax errors are reported with the imported file's path.\n\n5. **Resolve exports**: After parsing, verify the requested export (`name` or `@name`) exists in the module's export list. If not found, emit E090 with message: `Export '{name}' not found in module '{path}'`.\n\n### 11.4 Exports\n\n```vvm\nexport report\nexport deep_research\nexport @researcher\n```\n\nExports define the program‚Äôs public API. For a script-style program, a runtime should:\n- execute top-level control flow (the script)\n- at the end of execution, return the exported **values** (exported agents are configuration, not run targets)\n\nExport declarations are hoisted at module load time. Exporting the same name multiple times is allowed and has no additional effect.\n\n---\n\n## 12. Execution Model (Eager, Sequential)\n\nVVM uses **strict (eager) evaluation**. Agent calls block until they return a value (or an error value). There are no futures/tasks in VVM 0.3.\n\n### 12.1 Program order\n\n- After imports and hoisted declarations are processed (see Compilation and Validation), top-level statements execute in source order.\n- Each statement fully completes before the next statement begins.\n- Control flow bodies (`if`, `while`, `for`, `match`, `choose`, `try`) execute sequentially.\n\n### 12.2 Expression evaluation order (portable)\n\nTo avoid ambiguity when expressions contain agent calls, VVM defines a left-to-right order:\n\n- `a and b` / `a or b` evaluate the left operand first and short-circuit.\n- List literals evaluate elements left-to-right.\n- Object literals evaluate values left-to-right in source order.\n- Function calls `f(...)` evaluate:\n  1. `f`\n  2. positional argument expressions left-to-right\n  3. keyword argument value expressions left-to-right as written\n- Agent calls `@agent `...`(...)` evaluate:\n  1. the agent reference (including `.with(...)` override expressions)\n  2. the primary input (first positional argument), or else read `it`\n  3. option argument values (`retry`, `timeout`, `backoff`, `name`, plus any unknown options)\n  4. render the task template (using `{}` as the primary input and `{name}` lookups from the current environment)\n  5. spawn the subagent and wait for completion\n\n### 12.3 Non-chosen branches\n\nAgent calls may have side effects. Therefore:\n- In `match`, only the first matching `case` body executes; all other case bodies MUST NOT be executed.\n- In `choose`, option bodies MUST NOT be executed during selection; only the chosen option body executes.\n\n### 12.4 Parallelism (explicit only)\n\nThe core language is sequential. The runtime MUST NOT infer parallelism between independent agent calls.\n\nSome stdlib helpers (currently `pmap`) may evaluate work concurrently as an explicit opt-in. Programs that use such helpers should only parallelize independent work and must tolerate interleaving.\n\n---\n\n## 13. Error Handling\n\nVVM primarily uses **error values** + `match` for recovery. It also supports `raise` and `try/except/finally` as an escape hatch for aborting control flow.\n\n### 13.1 Two failure channels\n\nVVM has two distinct failure mechanisms:\n\n1. **Error values** (Section 3.2): returned like any other value (e.g. an agent call result). These do not change control flow automatically.\n2. **Raised errors** (`raise`): abort the current control-flow path until caught by `try/except`.\n\nIn addition to explicit `raise`, the VM MAY raise `thrown` errors for runtime failures (e.g. unbound names, type errors, malformed templates). These raised errors are catchable by `try/except` the same way.\n\nGuidance:\n- Prefer **error values + `match`** for expected failures (timeouts, retries, policy rejections).\n- Use **`raise`** for ‚Äúthis path cannot continue‚Äù inside helper functions or to enforce invariants.\n\n### 13.2 `raise`\n\nSyntax:\n- `raise`\n- `raise \"message\"`\n\nSemantics:\n- `raise \"message\"` constructs an error value `{ error: { kind: \"thrown\", message: <message> } }` and raises it as control flow.\n- `raise` (no message):\n  - inside an `except as err:` block: re-raises the currently caught error value (the value bound to `err`)\n  - otherwise: raises a new `thrown` error with an empty message\n- If there is an enclosing `try/except`, control transfers to its `except` block and binds the error value to the `except as <name>` variable.\n- If there is no enclosing `try/except`, the program terminates with that thrown error value.\n\n### 13.3 `try / except / finally`\n\nSyntax (MVP grammar):\n\n```vvm\ntry:\n  ...\nexcept as err:\n  ...\nfinally:\n  ...\n```\n\nSemantics:\n- `except` and `finally` are each optional, but at least one MUST be present.\n- The `try` block executes.\n- If a raised error occurs inside the `try` block:\n  - if an `except as err:` block is present, execution jumps to it and binds `err` to the raised error value\n  - otherwise, the raised error propagates outward (after running `finally` if present)\n- The `finally` block (if present) executes after the `try`/`except` path completes, whether it completed normally or via a raised error.\n- If the `finally` block raises, that raised error propagates outward (it overrides any previous raised error from the `try`/`except` path).\n\n`try/except` only catches **raised** errors. It does not automatically catch ordinary error values; use `match` for those.\n\n```vvm\n# assumes @backup and @logger are defined\ntry:\n  if ?`request is invalid`(request):\n    raise \"Invalid request\"\nexcept as err:\n  resp = @backup `Recover from error.`(err)\nfinally:\n  @logger `Record completion.`(())\n```\n\nRules:\n- `raise \"msg\"` aborts the current block unless caught; the caught value is an error object of kind `thrown`.\n- `raise` (without a message) re-raises the currently caught error inside an `except as err:` block; otherwise it raises a new `thrown` error with an empty message.\n- `except as err:` catches only raised errors (not ordinary error values returned by agent calls).\n- Prefer `match` for ordinary recovery from agent-call failures.\n- An uncaught `raise` terminates program execution; if the runtime returns a script result, it should return the thrown error value.\n\n---\n\n## 14. Standard Library (Normative)\n\nVVM ships with a small, portable stdlib. Runtimes may implement these as intrinsics as long as behavior matches.\n\nStdlib identifiers are in scope in every module by default (no import required).\n\n### 14.0 `perm(...)` and `range(...)` (portable helpers)\n\n`perm(...)` is a convenience constructor for permission objects used in agent configs:\n\n```vvm\npermissions = perm(\n  read=[\"src/**\", \"*.md\"],\n  write=[\"docs/**\"],\n  execute=[],\n  bash=\"deny\",\n  network=\"prompt\",\n)\n```\n\nPortable permission keys and value shapes:\n- `read`, `write`, `execute`: lists of glob patterns (empty list means no access)\n- `bash`, `network`: `\"allow\" | \"deny\" | \"prompt\"`\n\nDefaults (portable):\n- `read=[]`, `write=[]`, `execute=[]`\n- `bash=\"deny\"`, `network=\"deny\"`\n\n`range(n)` produces the list `[0, 1, ..., n-1]` (integers).\n\n### 14.1 `pack(...)`\n\n`pack` builds objects for named fan-in:\n\n```vvm\nctx = pack(research, analysis, topic=topic)\n```\n\nSemantics:\n- `pack(x)` (positional) uses the variable name as the key: `{ \"x\": <value of x> }`\n- `pack(k=v)` (keyword) uses the provided key\n\nValidation:\n- Positional arguments must be simple identifiers (e.g. `pack(research)`). Use keywords for computed expressions (e.g. `pack(result=deep_research(topic))`).\n\n### 14.2 `refine(...)` (expressible with loops)\n\n`refine` is a conventional agentic improvement loop. It is specified as library code, not a primitive.\n\nSignature:\n\n```text\nrefine(seed, max, done, step) -> value\n```\n\n- `seed`: initial candidate value\n- `max`: max iterations\n- `done(current, i) -> bool`: termination predicate (often uses `?`)\n- `step(current, i) -> value`: produces the next candidate (often uses agents)\n\nReference implementation (informative VVM):\n\n```vvm\ndef refine(seed, max, done, step):\n  current = seed\n  for i in range(max):\n    if done(current, i):\n      return current\n    current = step(current, i)\n  return current\n```\n\n### 14.3 Collection helpers\n\nThe collection helpers operate on lists and call user functions eagerly. Any agent calls inside `f`/`pred` run immediately.\n\n#### `map(items, f)`\n\n- Evaluates `items` and requires it to be a list.\n- For each item (in order):\n  - evaluate `f(item)`\n  - if evaluation raises, propagate the raised error\n  - if the result is an error value, return it immediately (fail-fast)\n- Returns the list of results.\n\n#### `pmap(items, f)`\n\nLike `map`, but the runtime MAY evaluate `f(item)` for multiple items concurrently, and MUST return results in the original item order.\n\nPortability notes:\n- Runtimes may implement `pmap` sequentially.\n- If any invocation raises, `pmap` raises (recommended: the first raised error in input order).\n- If any invocation returns an error value, `pmap` returns the first such error in input order (even if other invocations also errored).\n- Programs should only use `pmap` when invocations are independent and side effects are safe to interleave.\n\n#### `filter(items, pred)`\n\n- Evaluates `items` and requires it to be a list.\n- For each item (in order):\n  - evaluate `pred(item)`\n  - if evaluation raises, propagate the raised error\n  - if the result is an error value, return it immediately (fail-fast)\n  - require the result to be a boolean\n  - keep the item if `true`\n- Returns the filtered list (preserving relative order).\n\n#### `reduce(items, f, init=...)`\n\n- Evaluates `items` and requires it to be a list.\n- If `init` is provided, it becomes the initial accumulator; otherwise the first item is used (error on empty list).\n- For each remaining item (in order):\n  - evaluate `f(acc, item)`\n  - if evaluation raises, propagate the raised error\n  - if the result is an error value, return it immediately (fail-fast)\n  - set `acc` to that result\n- Returns `acc`.\n\n#### Error semantics (portable)\n\n- If `items` is not a list, raise a `thrown` error.\n- If `pred(...)` does not evaluate to a boolean, raise a `thrown` error.\n\nTo get ‚Äúcontinue on error‚Äù behavior, handle errors inside `f`/`pred` with `match`.\n\n---\n\n## 15. Compilation and Validation (Normative)\n\nThis section defines what it means for a runtime to ‚Äúcompile‚Äù and ‚Äúrun‚Äù VVM without ambiguity.\n\n### 15.1 Phases\n\n1. **Parse**\n   - Tokenize, respecting indentation (`INDENT`/`DEDENT`) and comments.\n   - Parse into an AST according to the Grammar.\n\n2. **Load module imports and skill imports**\n  - Resolve `from \"path\" import ...` recursively.\n  - Relative paths (`./`, `../`) are resolved relative to the importing file‚Äôs directory.\n  - Each imported module is loaded and executed exactly once (by canonical module identity) before the importing module‚Äôs top-level statements execute.\n  - As each module is loaded, collect its module-scope skill imports (`import \"skill\" from \"source\"`) and build a program-wide skill registry mapping `skill-name -> source`.\n  - If a later module imports the same skill name from a different source, it is a validation error.\n  - Cyclic imports are a validation error.\n\n3. **Collect module declarations (hoisted)**\n   - Collect all top-level `import \"skill\" from \"source\"`, `agent ...`, `def ...`, and `export ...` declarations into the module environment before running imperative statements.\n   - Duplicate agent names or duplicate function names are validation errors.\n   - `import ... from ...`, `agent`, `def`, `export`, and `from ... import ...` are **module-scope only**; using them inside blocks or inside a `def` is a validation error.\n   - Validate template literals (Section 5.2): malformed placeholders are errors, and unknown placeholder names are errors.\n\n4. **Execute the script**\n   - Execute all remaining top-level statements in source order.\n   - Statement execution is sequential.\n\n5. **Materialize exports**\n   - The module‚Äôs public API is the set of exported names (values/functions/agents).\n   - If the program is run as a script, the runtime should return exported **values**.\n   - Exported agents are configuration objects and are not run targets.\n\n### 15.2 Diagnostics\n\nVVM runtimes report:\n- **Errors**: block execution (do not run the program)\n- **Warnings**: non-blocking guidance (the program may still run)\n\nRuntimes SHOULD report a location (line/column) when practical.\n\n#### 15.2.1 Reserved keywords\n\nThese identifiers MUST NOT be used as user-defined names (variables, functions, agents, parameters, import aliases):\n\n`import`, `from`, `as`, `export`, `agent`, `def`, `return`, `match`, `case`, `choose`, `by`, `option`, `constrain`, `require`, `with`, `input`, `if`, `elif`, `else`, `while`, `for`, `in`, `try`, `except`, `finally`, `raise`, `pass`, `break`, `continue`, `and`, `or`, `not`, `it`, `true`, `false`, `error`\n\n#### 15.2.2 Error codes (blocking)\n\n| Code  | Description |\n| ----- | ----------- |\n| E001  | Syntax error (unexpected token / invalid form) |\n| E002  | Inconsistent indentation (bad INDENT/DEDENT) |\n| E003  | Unterminated string literal |\n| E004  | Unterminated template literal |\n| E005  | Unknown escape sequence in string literal |\n| E010  | Reserved keyword used as identifier |\n| E020  | Duplicate agent definition |\n| E021  | Duplicate function definition |\n| E030  | Skill import has empty name or source |\n| E031  | Duplicate skill import within a module |\n| E032  | Conflicting skill imports across modules (same name, different source) |\n| E040  | Unknown agent reference `@name` (unless inline `@{...}`) |\n| E041  | Non-literal agent configuration in `agent name(...)` |\n| E050  | Invalid `case` pattern (not `_`, `error(_)`, `error(kind=\\\"...\\\")`, or `?`template``) |\n| E051  | Unknown template placeholder name (`{name}` does not refer to any declared/builtin binding) |\n| E052  | Malformed template placeholder (unescaped `{` or `}`) |\n| E060  | Assignment to `it` |\n| E070  | `constrain name(...):` where `name` is not bound before the statement |\n| E080  | `return` used outside `def` |\n| E081  | `break`/`continue` used outside a loop |\n| E082  | `try:` without `except` or `finally` |\n| E090  | Module import/export cannot be resolved (missing module or missing exported name) |\n\n#### 15.2.3 Warning codes (non-blocking)\n\n| Code  | Description |\n| ----- | ----------- |\n| W001  | Unknown skill import source format (host may still resolve it) |\n| W010  | Agent references a skill that is not imported in the same module |\n| W011  | Empty `skills=[]` on an agent declaration |\n| W020  | Unknown agent configuration key (host-defined; portability risk) |\n| W030  | Unused variable (best-effort) |\n| W031  | Exported value never assigned (may fail at runtime) |\n\n#### 15.2.4 Runtime errors vs validation errors\n\nSome failures are inherently dynamic and occur during execution as **raised errors** of kind `thrown` (catchable by `try/except`) rather than as validation errors. Examples:\n- calling a non-function value (`f(...)` when `f` is not a function)\n- `if`/`while` condition that is not boolean\n- iterating a non-list in `for`\n- unresolved template placeholder when rendering a template literal\n- arithmetic/comparison on unsupported types\n\n#### 15.2.5 Diagnostic message shape (recommended)\n\nRecommended format:\n\n```\nE004 line 12 col 18: unterminated template literal\n  title = @writer `Draft the report.\n                   ^\n```\n\n---\n\n## 16. Grammar (Reference)\n\nThis grammar is intentionally approximate: VVM is designed to be simulated by an LLM, not to require a heavy external compiler.\n\nLexical notes:\n- indentation uses Python-like `INDENT` / `DEDENT`\n- comments start with `#` to end of line\n- backtick templates support escapes\n- runtimes should reject tabs for indentation (spaces only)\n\n```ebnf\nprogram        = stmt* ;\n\nstmt           = comment\n               | skill_import_stmt\n               | module_import_stmt\n               | export_stmt\n               | agent_stmt\n               | def_stmt\n               | return_stmt\n               | match_stmt\n               | choose_stmt\n               | constrain_stmt\n               | with_input_stmt\n               | if_stmt\n               | while_stmt\n               | for_stmt\n               | try_stmt\n               | raise_stmt\n               | pass_stmt\n               | break_stmt\n               | continue_stmt\n               | assign_stmt\n               | expr_stmt ;\n\nexpr_stmt      = expr newline ;\ncomment        = \"#\" { not_nl } newline ;\n\nagent_stmt     = \"agent\" ident \"(\" [kw_args] \")\" newline ;\n\nassign_stmt    = ident \"=\" expr newline ;\n\ndef_stmt       = \"def\" ident \"(\" [ident_list] \")\" \":\" newline INDENT stmt* DEDENT ;\nreturn_stmt    = \"return\" [expr] newline ;\n\nskill_import_stmt = \"import\" string \"from\" string newline ;\nmodule_import_stmt= \"from\" string \"import\" import_name [ \"as\" ident ] newline ;\nimport_name    = ident | \"@\" ident ;\nexport_stmt    = \"export\" export_name newline ;\nexport_name    = ident | \"@\" ident ;\n\nwith_input_stmt= \"with\" \"input\" expr \":\" newline INDENT stmt* DEDENT ;\n\nmatch_stmt     = \"match\" expr \":\" newline INDENT case_stmt+ DEDENT ;\ncase_stmt      = \"case\" pattern \":\" newline INDENT stmt* DEDENT ;\n\nchoose_stmt    = \"choose\" expr \"by\" sem_pred_case \"as\" ident \":\" newline INDENT option_stmt+ DEDENT ;\noption_stmt    = \"option\" string \":\" newline INDENT stmt* DEDENT ;\n\nconstrain_stmt = \"constrain\" ident \"(\" [kw_args] \")\" \":\" newline INDENT require_stmt+ DEDENT ;\nrequire_stmt   = \"require\" sem_pred_case newline ;\n\nif_stmt        = \"if\" expr \":\" newline INDENT stmt* DEDENT [ \"elif\" expr \":\" newline INDENT stmt* DEDENT ]* [ \"else\" \":\" newline INDENT stmt* DEDENT ] ;\nwhile_stmt     = \"while\" expr \":\" newline INDENT stmt* DEDENT ;\nfor_stmt       = \"for\" ident \"in\" expr \":\" newline INDENT stmt* DEDENT ;\n\n\ttry_stmt       = \"try\" \":\" newline INDENT stmt* DEDENT [except_block] [finally_block] ;\n\texcept_block   = \"except\" \"as\" ident \":\" newline INDENT stmt* DEDENT ;\n\tfinally_block  = \"finally\" \":\" newline INDENT stmt* DEDENT ;\nraise_stmt     = \"raise\" [string] newline ;\npass_stmt      = \"pass\" newline ;\nbreak_stmt     = \"break\" newline ;\ncontinue_stmt  = \"continue\" newline ;\n\nexpr           = or_expr ;\n\nor_expr        = and_expr ( \"or\" and_expr )* ;\nand_expr       = not_expr ( \"and\" not_expr )* ;\nnot_expr       = [ \"not\" ] cmp_expr ;\ncmp_expr       = add_expr ( cmp_op add_expr )* ;\ncmp_op         = \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" ;\nadd_expr       = primary ( (\"+\" | \"-\") primary )* ;\n\nprimary        = literal\n               | ident\n               | list\n               | object\n               | call\n               | agent_call\n               | sem_pred\n               | \"(\" expr \")\" ;\n\nagent_call     = agent_ref template \"(\" [agent_args] \")\" ;\nagent_args     = kw_args | expr [\",\" kw_args] ;\nagent_ref      = \"@\" ident [ \".with\" \"(\" [kw_args] \")\" ]\n               | \"@{\" [kw_args] \"}\" ;\n\n\tsem_pred       = \"?\" template [ \"(\" expr \")\" ] ;\n\ncall           = ident \"(\" [call_args] \")\" ;\ncall_args      = kw_args | expr (\",\" expr)* [\",\" kw_args] ;\nkw_args        = kw_arg (\",\" kw_arg)* [\",\"] ;\nkw_arg         = ident \"=\" expr ;\n\npattern        = \"_\" | error_pat | sem_pred_case ;\nerror_pat      = \"error\" \"(\" ( \"_\" | \"kind\" \"=\" string ) \")\" ;\nsem_pred_case  = \"?\" template ;\n\ntemplate       = \"`\" { any_char_except_unescaped_backtick } \"`\" ;\n\n\tliteral        = \"()\" | \"true\" | \"false\" | number | string ;\nstring         = quoted_string | triple_quoted_string ;\nquoted_string  = /\"([^\"\\\\\\\\]|\\\\\\\\.)*\"/ ;\ntriple_quoted_string = /\\\"\\\"\\\"(.|\\\\n)*?\\\"\\\"\\\"/ ;\nexpr_list      = expr (\",\" expr)* [\",\"] ;\nlist           = \"[\" [expr_list] \"]\" ;\nobject         = \"{\" [kv_list] \"}\" ;\nkv_list        = kv (\",\" kv)* [\",\"] ;\nkv             = (ident | string) \":\" expr ;\n\nident_list     = ident (\",\" ident)* ;\nident          = /[a-zA-Z_][a-zA-Z0-9_]*/ ;\nnumber         = /[0-9]+(\\\\.[0-9]+)?/ ;\nnewline        = \"\\\\n\" ;\nnot_nl         = ? any char except newline ? ;\n```\n\n---\n\n## 17. Examples (Informative)\n\nThese examples are complete VVM programs you can paste into a runtime.\n\n### 17.1 Minimal ‚Äúhello‚Äù\n\n```vvm\nagent greeter(model=\"haiku\", prompt=\"Be concise.\")\n\nmsg = @greeter `Say hello.`(())\nexport msg\n```\n\n### 17.2 Skills + permissions (least privilege)\n\n```vvm\nimport \"web-search\" from \"github:example/skills\"\n\nagent researcher(\n  model=\"sonnet\",\n  prompt=\"Research thoroughly and cite sources.\",\n  skills=[\"web-search\"],\n  permissions=perm(\n    read=[],\n    write=[],\n    execute=[],\n    bash=\"deny\",\n    network=\"allow\",\n  ),\n)\n\ntopic = \"AI safety\"\nresearch = @researcher `Find 5-8 high-quality sources on {topic}.`(topic)\nexport research\n```\n\n### 17.3 Retry + error-value recovery\n\n```vvm\nagent api(model=\"sonnet\")\nagent backup(model=\"sonnet\", prompt=\"Use an offline fallback approach.\")\n\nreq = pack(endpoint=\"https://example.com\", query=\"status\")\nresp = @api `Call the API and return JSON.`(req, retry=2, timeout=\"30s\")\n\nmatch resp:\n  case error(kind=\"timeout\"):\n    resp = @backup `Provide best-effort cached status.`(req)\n  case error(_):\n    resp = @backup `Provide best-effort fallback status.`(req)\n  case _:\n    pass\n\nexport resp\n```\n\n### 17.4 Constrain + refine (expressible with loops)\n\n```vvm\nagent writer(model=\"opus\")\nagent critic(model=\"sonnet\")\n\nseed = @writer `Draft a short report with citations.`(())\n\ndef done(draft, i):\n  with input draft:\n    return ?`citations >= 3 and no hallucinations`\n\ndef step(draft, i):\n  critique = @critic `Critique and suggest fixes.`(draft)\n  return @writer `Revise using critique.`([draft, critique])\n\ndraft = refine(seed, 3, done, step)\n\nconstrain draft():\n  require ?`citations >= 3`\n  require ?`no hallucinations`\n\nexport draft\n```\n\n### 17.5 Module imports + exports\n\n`lib/research.vvm`:\n\n```vvm\nexport deep_research\n\nagent researcher(model=\"sonnet\")\n\ndef deep_research(topic):\n  return @researcher `Research {topic}.`(topic)\n```\n\n`main.vvm`:\n\n```vvm\nfrom \"./lib/research.vvm\" import deep_research\n\ntopic = \"quantum computing\"\nout = deep_research(topic)\nexport out\n```\n",
        "skills/vvm/vvm.md": "---\nrole: execution-semantics\nsummary: |\n  How to embody the VVM runtime and execute programs.\nsee-also:\n  - spec.md: Complete language specification\n  - patterns.md: Design patterns\n  - antipatterns.md: Anti-patterns to avoid\n---\n\n# VVM Execution Semantics\n\nThis document describes **how to execute VVM programs**. It is written for the AI runtime (you) to embody the VVM when running programs.\n\n---\n\n## 1. You ARE the VVM\n\nWhen executing a VVM program, you are not simulating a virtual machine‚Äîyou ARE the virtual machine. This is not a metaphor. VVM is designed so that a sufficiently detailed specification causes an LLM to **become** the runtime through simulation.\n\n**What this means in practice:**\n\n- You execute statements sequentially, top to bottom\n- You evaluate expressions eagerly (no lazy evaluation)\n- You spawn subagents for agent calls via the Task tool\n- You make semantic judgments for predicates (`?`) locally\n- You track state via the narration protocol\n- You handle errors according to the two-channel model\n\n---\n\n## 2. Core Execution Principles\n\n### 2.1 Eager, Sequential Execution\n\nVVM uses **strict (eager) evaluation**. Every expression is evaluated immediately when encountered.\n\n```\nresult = @agent `Do something.`(input)  # Blocks until complete\nnext_step = @agent `Use result.`(result) # Only runs after result is available\n```\n\nThere are no futures, promises, or lazy values. Each statement fully completes before the next begins.\n\n### 2.2 Explicit Parallelism Only\n\nThe runtime MUST NOT infer parallelism. Independent agent calls do NOT run concurrently unless explicitly requested via `pmap`.\n\n```vvm\n# These run SEQUENTIALLY (not in parallel)\na = @agent `Task A.`(())\nb = @agent `Task B.`(())\nc = @agent `Task C.`(())\n\n# This runs in PARALLEL\nresults = pmap([x, y, z], process)\n```\n\n### 2.3 The Implicit Input (`it`)\n\n`it` is a lexically-scoped binding that provides default input context:\n\n- At top-level: `it = ()`\n- Inside `with input expr:`: `it = expr`\n- Inside `match value:` cases: `it = value`\n- Inside `choose value by:` options: `it = value`\n\n`it` is restored after leaving its scope.\n\n---\n\n## 3. Statement Execution\n\nExecute each statement type as follows:\n\n### 3.1 Assignment (`name = expr`)\n\n1. Evaluate `expr` to a value\n2. Bind `name` to that value in current scope\n\n### 3.2 Agent Call (`@agent `template`(input, options...)`)\n\n1. Resolve the agent reference (named, `.with()`, or inline `@{...}`)\n2. Determine input: explicit first argument, or implicit `it`\n3. Evaluate option arguments (`retry`, `timeout`, `memory_mode`, etc.)\n4. Render the template (substitute `{}` with input, `{name}` with bindings)\n5. If the resolved agent config has `memory=...` and `memory_mode!=\"fresh\"`:\n   - Resolve the memory directory per `spec.md` Section 3.5\n   - Acquire a single-writer lock for that memory key (or return `error(kind=\"locked\")`)\n   - Read `digest.md` and (optionally) a bounded recent tail from `ledger.jsonl`\n   - Construct a **Memory Context** prelude (clearly delimited) and prepend it to the rendered task prompt\n   - Include a short ‚ÄúMemory Update Protocol‚Äù snippet describing the `vvm-memory` patch channel\n6. **Spawn a subagent** via the Task tool with:\n   - Agent configuration (model, prompt, skills, permissions)\n   - Rendered task prompt (including Memory Context prelude when applicable)\n   - Structured input value\n7. Wait for completion\n8. If the subagent fails: release any held lock and return an error value (no memory writes).\n9. If the subagent succeeds:\n   - Strip any fenced ```vvm-memory``` block from the response (always strip; it is a reserved channel)\n   - If `memory_mode==\"continue\"` and `memory=...` is bound:\n     - Parse the block as JSON; validate size + secret-safety\n     - If valid, apply atomically:\n       - overwrite `digest.md` (write temp + rename)\n       - append a JSONL entry to `ledger.jsonl` containing `{ts, digest?, retain?}`\n     - If invalid/unsafe, apply no writes\n   - If `memory_mode==\"dry_run\"` or `\"fresh\"`, apply no writes\n   - Release any held lock\n   - Return the user-visible output string\n\n**Spawning subagents:** Use the Task tool to spawn subagents. The agent configuration maps to the task parameters.\n\n### 3.3 Semantic Predicate (`?`template`(input)`)\n\n1. Determine input: explicit argument, or implicit `it`\n2. Render the template\n3. **Evaluate locally** (no subagent spawn) whether the input satisfies the criterion\n4. Return `true` or `false`\n5. If uncertain, return `false` (conservative default)\n\n**Critical:** Predicates are pure local judgments. They MUST NOT spawn subagents, read files, or call tools.\n\n### 3.4 `if / elif / else`\n\n1. Evaluate condition expression\n2. Condition MUST be a boolean (`true` or `false`)\n3. If `true`, execute the corresponding block\n4. Otherwise, try the next `elif` or `else`\n\n### 3.5 `while`\n\n1. Evaluate condition\n2. If `false`, exit loop\n3. If `true`, execute body, then repeat from step 1\n4. Handle `break` (exit loop) and `continue` (next iteration)\n\n### 3.6 `for`\n\n1. Evaluate the iterable expression (must be a list)\n2. For each item:\n   - Bind the loop variable to the item\n   - Execute the body\n3. Handle `break` and `continue`\n\n### 3.7 `match`\n\n1. Evaluate the scrutinee to a value\n2. Bind `it` to the scrutinee\n3. Check cases top-to-bottom:\n   - `_`: always matches\n   - `error(_)`: matches any error value\n   - `error(kind=\"...\")`: matches error with specific kind\n   - `?`template``: evaluate semantic predicate against `it`\n4. Execute ONLY the first matching case body\n5. Restore `it` after match\n\n**Critical:** Non-matching cases MUST NOT execute.\n\n### 3.8 `choose`\n\n1. Evaluate the scrutinee to a value\n2. Bind `it` to the scrutinee\n3. Render the criterion template\n4. **Select an option label** (without executing any option bodies)\n5. Assign the chosen label to the `as` variable\n6. Execute ONLY the chosen option body\n7. Restore `it` after choose\n\n**Critical:** Option selection is a pure local judgment. Bodies MUST NOT execute during selection.\n\n### 3.9 `constrain`\n\n1. Evaluate the bound variable\n2. For each `require` line:\n   - Evaluate as semantic predicate against the value\n   - If uncertain, treat as violated\n3. If all pass: keep the value\n4. If any fail: rebind to constraint_violation error value\n\n### 3.10 `with input`\n\n1. Evaluate the expression\n2. Push a new `it` binding with that value\n3. Execute the block\n4. Pop `it` (restore previous value)\n\n### 3.11 `try / except / finally`\n\n1. Execute `try` block\n2. If a raised error occurs:\n   - If `except as err:` exists, bind `err` and execute `except` block\n   - Otherwise, propagate the error (after `finally`)\n3. Execute `finally` block (always)\n4. If `finally` raises, that error propagates\n\n### 3.12 `raise`\n\n1. If `raise \"message\"`: create thrown error and abort\n2. If `raise` (no message):\n   - Inside `except as err:`: re-raise `err`\n   - Otherwise: raise new thrown error with empty message\n\n### 3.13 `def` (Function Definition)\n\nFunction definitions are hoisted. When called:\n\n1. Bind parameters to argument values\n2. Inherit `it` from caller\n3. Execute body sequentially\n4. Return via `return expr` or `()` at end\n\n### 3.14 `return`\n\n1. Evaluate the expression (if any)\n2. Exit the current function with that value\n\n---\n\n## 4. Agent Call Mechanics\n\n### 4.1 Input Passing\n\nAgent calls have two channels:\n\n1. **Prompt text**: The rendered template\n2. **Input value**: Structured context (first argument or `it`)\n\nPass input as **structured context** when possible. If the host only supports text:\n\n```\n<rendered prompt>\n\nInput:\n---\n<serialized value>\n---\n```\n\n### 4.2 Retry Semantics\n\n`retry=n` means try up to `1 + n` times. Retry on:\n- `spawn_failed`\n- `timeout`\n- `rejected` (transient)\n\nThe final result is the first success or the last error.\n\n### 4.3 Result Handling\n\nSuccessful agent calls return strings (the subagent's response). Failed calls return error values:\n\n```vvm\n{ error: { kind: \"timeout\", message: \"...\" } }\n```\n\n### 4.4 Module Loading\n\nWhen you encounter a module import (`from \"path\" import ...`):\n\n1. **Compute the resolved path** relative to the current file's directory\n2. **Check file exists** using Bash: `test -f <resolved_path> && echo \"exists\" || echo \"not found\"`\n3. **If file not found**, emit E090 and halt:\n   ```\n   ‚ùå E090: Module not found: ./team-agents.vvm\n      Resolved from: examples/14-module-imports.vvm\n   ```\n4. **If file exists**, use Read tool to load the contents, then parse and extract exports\n5. **If export not found**, emit E090 and halt:\n   ```\n   ‚ùå E090: Export 'process_ticket' not found in module './team-agents.vvm'\n   ```\n\n**Critical**: You MUST verify file existence with `test -f` before proceeding. Do not infer module contents from comments, variable names, or context. The file must exist on disk.\n\n### 4.5 Run State Management (Filesystem State Mode)\n\nWhen operating in **filesystem state mode**, the VM creates a run directory for each execution:\n\n```\n.vvm/\n  runs/\n    <run-id>/\n      program.vvm         # Copy of entry program\n      state.md            # VM-owned trace + binding index (small)\n      bindings/           # Agent output artifacts\n        b000001.md\n        b000002.md\n        ...\n      imports/            # Reserved for nested workflow executions\n```\n\n**Ownership rules:**\n- **VM owns**: `program.vvm`, `state.md`, directory creation\n- **Subagents write**: `bindings/b<counter>.md` (write-only, one file per call)\n- **Reserved**: `imports/` (for nested workflow executions)\n\n**Binding file naming:**\n- Files named by monotonic call counter: `b000001`, `b000002`, ...\n- NOT by variable name (avoids collisions in loops/functions)\n- VM maintains name‚Üíref mapping in `state.md`\n\n#### 4.5.1 Run ID Generation\n\nGenerate run-id with format: `YYYYMMDD-HHMMSS-<rand6>`\n\nExample: `20260127-143052-a7f3b2`\n\nProperties:\n- Sortable by time (lexicographic = chronological)\n- Unique (6 random chars prevent collisions for concurrent runs)\n- Human-readable (date visible at glance)\n\n#### 4.5.2 state.md Format\n\nThe `state.md` file is the VM's execution trace and binding index. It MUST remain small.\n\n**Required sections:**\n\n```markdown\n# VVM Run: <run-id>\n\nProgram: <program-path>\nStarted: <ISO timestamp>\nUpdated: <ISO timestamp>\nStatus: running | completed | failed\n\n## Binding Index\n\n| Name | Ref Path | Summary |\n|------|----------|---------|\n| research | .vvm/runs/.../bindings/b000001.md | Found 3 papers... |\n| report | .vvm/runs/.../bindings/b000002.md | 2500-word report... |\n\n## Execution Trace\n\n- [timestamp] Started execution\n- [timestamp] research = @researcher (b000001)\n- [timestamp] report = @writer (b000002)\n- [timestamp] Completed with 2 exports\n```\n\n**MUST NOT contain:**\n- Full prompts or responses\n- Megatext dumps\n- Sensitive data (credentials, secrets)\n\n**Purpose:**\n- Quick inspection: \"what happened in this run?\"\n- Debugging: find which binding has which output\n- NOT for full transcript replay\n\n#### 4.5.3 Program Start Algorithm\n\nWhen you start executing a program in filesystem state mode:\n\n1. Generate a run-id (format: `YYYYMMDD-HHMMSS-<rand6>`)\n2. Create the run directory: `.vvm/runs/<run-id>/`\n3. Create the bindings directory: `.vvm/runs/<run-id>/bindings/`\n4. Copy the entry program to: `.vvm/runs/<run-id>/program.vvm`\n5. Initialize `state.md` with metadata header (status: running)\n6. Initialize the binding counter to 0\n\nExample narration:\n\n```\nüìç Filesystem state mode\nüìç Run: 20260127-143052-a7f3b2\nüìç Created .vvm/runs/20260127-143052-a7f3b2/\n```\n\n#### 4.5.4 Agent Call Algorithm\n\nFor each agent call in filesystem state mode:\n\n```vvm\nresult = @agent `Task prompt.`(input)\n```\n\nExecute these steps:\n\n1. **Allocate binding path**\n   - Increment binding counter\n   - Path: `.vvm/runs/<run-id>/bindings/b<counter padded to 6 digits>.md`\n\n2. **Spawn subagent**\n   - Render the task prompt template\n   - Include the binding contract (Section 4.5.5)\n   - Pass structured input (may contain refs from prior calls)\n   - Specify the write target path\n\n3. **Wait for completion**\n\n4. **Verify the binding file**\n   - File exists at the allocated path\n   - File is non-empty\n   - On failure: return `error(kind=\"binding_failed\")`, apply `retry=` if specified\n\n5. **Construct the ref value**\n\n   ```vvm\n   {\n     ref: \".vvm/runs/<run-id>/bindings/b000001.md\",\n     summary: \"<from subagent confirmation>\",\n     mime: \"text/markdown\"\n   }\n   ```\n\n6. **Bind the variable**\n   - `result` now holds the ref value\n\n7. **Update state.md**\n   - Add to binding index: name ‚Üí path ‚Üí summary\n   - Append to trace: `[timestamp] result = @agent (b000001)`\n\nExample narration:\n\n```\nüìç result = @researcher `Find papers on {topic}.`(topic)\n‚è≥ Allocated: b000001.md\n‚è≥ Spawning subagent...\nüì¶ Binding written: b000001.md\nüì¶ Summary: Found 3 papers on quantum computing\n‚úÖ result bound\n```\n\n#### 4.5.5 Subagent Binding Contract\n\nWhen spawning a subagent, include this contract in the spawn instruction:\n\n```text\n## Binding Contract\n\nWrite your complete output to:\n  .vvm/runs/<run-id>/bindings/b<counter>.md\n\nThen return ONLY this confirmation:\n\n  Binding written: b<counter>\n  Path: .vvm/runs/<run-id>/bindings/b<counter>.md\n  Summary: <1-3 sentences describing what you produced>\n\nYour chat response contains only the confirmation above.\nAll substantive output goes in the file.\n```\n\n**Responsibility table:**\n\n| Actor | Writes | Returns |\n|-------|--------|---------|\n| VM | binding path allocation, state.md | ref value to caller |\n| Subagent | full output to binding file | confirmation + summary only |\n\n**Why this matters:**\n- Large outputs stay out of chat context\n- VM can orchestrate arbitrarily large workflows\n- Summaries provide enough info for routing decisions\n\n#### 4.5.6 Downstream Ref Passing\n\nWhen input to an agent call contains ref values:\n\n```vvm\nresearch = @researcher `Research topic.`(topic)\nreport = @writer `Write report.`(research)   # research is a ref\n```\n\nThe VM passes ref objects as-is, not expanded file contents. Include this protocol snippet in the subagent spawn:\n\n```text\n## Ref Reading Protocol\n\nYour input may contain ref values. A ref value looks like:\n\n  {\n    ref: \".vvm/runs/<run-id>/bindings/b000001.md\",\n    summary: \"Brief description\",\n    mime: \"text/markdown\"\n  }\n\nWorking with refs:\n- Use the summary for routing decisions when possible\n- Read the file at the ref path if you need full content\n- You have read permission for .vvm/runs/<run-id>/bindings/**\n- Cite by filename when referencing content (e.g., \"per b000001.md\")\n```\n\n**Good vs Bad:**\n\n```vvm\n# Good: Pass ref, let downstream decide\nreport = @writer `Summarize the research.`(research)\n\n# Bad: VM expands ref contents into prompt (defeats the purpose)\n# (The VM never does this ‚Äî refs stay as refs)\n```\n\n#### 4.5.7 Unassigned Agent Calls\n\nAgent calls without assignment still produce bindings:\n\n```vvm\n@notifier `Send alert.`(data)   # no variable assigned\n```\n\nThe VM:\n1. Allocates a binding file (same as assigned calls)\n2. Spawns the subagent with binding contract\n3. Records in state.md with synthetic name `_anon_<counter>`\n\nThis ensures all agent outputs are captured and inspectable.\n\nExample state.md entry:\n\n| Name | Ref Path | Summary |\n|------|----------|---------|\n| _anon_001 | .vvm/runs/.../bindings/b000003.md | Alert sent |\n\n#### 4.5.8 Materializer Pattern\n\nRefs keep content out of context. If you genuinely need file contents in the VM's context, use an explicit materializer agent:\n\n```vvm\nagent reader(\n  model=\"haiku\",\n  permissions=perm(read=[\".vvm/runs/**\"], write=[], bash=\"deny\", network=\"deny\")\n)\n\nresearch = @researcher `Research quantum computing.`(topic)\n\n# Explicitly pull excerpts into context\nexcerpts = @reader `Extract the 3 most relevant quotes.`(research)\n```\n\n**When to use:**\n- You need specific excerpts for a semantic predicate\n- You're debugging and want to see intermediate content\n- A downstream agent cannot read files (unusual)\n\n**When NOT to use:**\n- Default case: let agents read refs directly\n- Passing between agents: use refs\n- Large intermediates: keep as refs\n\nThe materializer pattern makes costs explicit: reading a file is a visible agent call, not hidden IO.\n\n### 4.6 Debugging with Run Artifacts\n\nWhen a workflow fails or produces unexpected results, inspect the run artifacts.\n\n#### Finding Your Run\n\nRun directories are at `.vvm/runs/<run-id>/`. The most recent run has the latest timestamp:\n\n```bash\nls -lt .vvm/runs/ | head -5\n```\n\n#### Reading state.md\n\nOpen `.vvm/runs/<run-id>/state.md` to see:\n- **Status**: Did the run complete, fail, or get interrupted?\n- **Binding Index**: Which variables were bound to which files?\n- **Execution Trace**: What happened in what order?\n\nExample state.md:\n\n```markdown\n# VVM Run: 20260127-143052-a7f3b2\n\nStatus: completed\n\n## Binding Index\n\n| Name | Ref Path | Summary |\n|------|----------|---------|\n| research | .../bindings/b000001.md | Found 3 papers |\n| report | .../bindings/b000002.md | 2500-word report |\n\n## Execution Trace\n\n- [14:30:52] Started\n- [14:30:55] research = @researcher (b000001)\n- [14:31:02] report = @writer (b000002)\n- [14:31:05] Completed\n```\n\n#### Inspecting Binding Files\n\nEach agent output is in `.vvm/runs/<run-id>/bindings/b<counter>.md`. Open these to see the full output:\n\n```bash\ncat .vvm/runs/20260127-143052-a7f3b2/bindings/b000001.md\n```\n\n#### Common Issues\n\n| Symptom | Check |\n|---------|-------|\n| Missing binding file | Subagent may have failed to write; check for error in trace |\n| state.md very large | May have accidentally logged full outputs; check safety defaults |\n| Unexpected output | Read the binding file to see what the agent actually produced |\n\n#### Sharing Runs for Debugging\n\nTo share a run for debugging:\n1. Copy the entire `.vvm/runs/<run-id>/` directory\n2. Include `program.vvm`, `state.md`, and `bindings/`\n3. Do NOT share if bindings contain sensitive data\n\n### 4.7 Choosing a State Mode\n\nVVM supports two state modes. Choose based on your workflow characteristics.\n\n#### In-Context Mode (Default)\n\nAll state stays in token context. Agent calls return strings.\n\n**Use when:**\n- Quick prototyping and iteration\n- Small programs (< 10 agent calls)\n- Outputs are small (< 1KB each)\n- You don't need to inspect intermediate outputs\n- Tools/file access unavailable\n\n**Characteristics:**\n- No filesystem artifacts created\n- All outputs visible in conversation\n- Context grows with each agent call\n- May hit token limits on long workflows\n\n#### Filesystem Mode\n\nAgent outputs written to `.vvm/runs/<run-id>/bindings/`. Agent calls return ref values.\n\n**Use when:**\n- Production workflows\n- Long pipelines (10+ agent calls)\n- Large intermediate outputs\n- You want to inspect/debug artifacts\n- Reproducibility matters\n\n**Characteristics:**\n- Creates run directory with artifacts\n- Context stays bounded (refs are small)\n- Can inspect any intermediate output\n- Supports very long workflows\n\n#### Switching Modes\n\n```bash\n# Default: in-context mode\n/vvm-run examples/my-program.vvm\n\n# Explicit filesystem mode\n/vvm-run examples/my-program.vvm --state=filesystem\n```\n\n#### Decision Table\n\n| Factor | In-Context | Filesystem |\n|--------|------------|------------|\n| Agent calls | < 10 | 10+ |\n| Output sizes | Small | Any size |\n| Debugging | Limited | Full artifacts |\n| Token usage | Grows | Bounded |\n| File access | Not needed | Required |\n\n### 4.8 Scope and Limitations\n\nFilesystem state mode provides artifact-backed agent outputs. The following are explicitly out of scope:\n\n#### Database Backends\n\nState is stored in the local filesystem only. Database backends (SQLite, PostgreSQL) are not supported. For distributed or persistent state, copy run directories manually.\n\n#### Binary and Large Attachments\n\nBinding files are markdown text. Binary files (images, PDFs) and very large outputs (> 10MB) should be handled by the agent writing to a separate location and including a path reference.\n\n#### Durable Resume\n\nRuns cannot be resumed after interruption. If a run fails partway through, you must re-run from the beginning. The `state.md` trace helps identify where failure occurred.\n\n#### Ref URI Scheme\n\nRefs use filesystem paths (`.vvm/runs/<id>/bindings/b000001.md`). There is no URI scheme (`vvm://...`) for cross-machine or network references.\n\n#### Transcript Logging\n\nFull prompts and responses are not logged by default. This is intentional for safety. If you need full transcripts for debugging, implement custom logging in your agents.\n\n---\n\n## 5. Narration Protocol\n\nTrack execution state using emoji markers:\n\n| Marker | Meaning |\n|--------|---------|\n| üìç | Starting statement/block |\n| üì¶ | Value bound/returned |\n| ‚úÖ | Success/completion |\n| ‚ùå | Error/failure |\n| üîÑ | Loop iteration |\n| ‚è≥ | Waiting for subagent |\n| üéØ | Match/choose decision |\n| ‚ö° | Parallel execution |\n\nExample narration:\n\n```\nüìç Executing: research = @researcher `Find papers.`(topic)\n‚è≥ Spawning subagent: researcher (model=sonnet)\nüì¶ Result: [3 papers found...]\n‚úÖ research bound\n\nüìç Executing: match research:\nüéØ Checking case: ?`has enough sources`\nüéØ Match: true\nüìç Executing case body...\n```\n\n---\n\n## 6. Error Handling\n\nVVM has two error channels:\n\n### 6.1 Error Values\n\nReturned like normal values. Handle with `match`:\n\n```vvm\nmatch result:\n  case error(kind=\"timeout\"):\n    result = @backup `Fallback.`(request)\n  case error(_):\n    result = @backup `Generic fallback.`(request)\n  case _:\n    pass\n```\n\n### 6.2 Raised Errors\n\nAbort control flow. Handle with `try/except`:\n\n```vvm\ntry:\n  if ?`invalid`(input):\n    raise \"Invalid input\"\nexcept as err:\n  @logger `Log error.`(err)\n```\n\n**Runtime errors** (unbound names, type errors, etc.) are raised as `thrown` errors.\n\n---\n\n## 7. Context Passing Rules\n\n### 7.1 Explicit Input (First Argument)\n\n```vvm\n@agent `Process this.`(data)  # data is the input\n```\n\n### 7.2 Implicit Input (`it`)\n\n```vvm\nwith input data:\n  @agent `Process this.`()    # uses it == data\n```\n\n### 7.3 Empty Input\n\n```vvm\n@agent `Start fresh.`(())     # explicit empty input\n```\n\n### 7.4 `{}` in Templates\n\n`{}` interpolates the call's input (explicit first arg or `it`):\n\n```vvm\n@agent `Summarize: {}`(document)  # {} becomes document summary\n```\n\n### 7.5 `{name}` in Templates\n\n`{name}` interpolates a binding from scope:\n\n```vvm\ntopic = \"AI safety\"\n@agent `Research {topic}.`(data)  # {topic} becomes \"AI safety\"\n```\n\n---\n\n## 8. Standard Library\n\nThese functions are always available:\n\n### 8.1 Core Helpers\n\n- `perm(...)` - Build permission objects\n- `range(n)` - Produce `[0, 1, ..., n-1]`\n- `pack(...)` - Build objects from bindings\n\n### 8.2 Collection Helpers\n\n- `map(items, f)` - Apply `f` to each item (sequential)\n- `pmap(items, f)` - Apply `f` to each item (parallel)\n- `filter(items, pred)` - Keep items where `pred` is true\n- `reduce(items, f, init=...)` - Fold items with `f`\n- `refine(seed, max, done, step)` - Iterative improvement loop\n\n### 8.3 Error Behavior\n\n- Non-list input raises `thrown` error\n- Non-boolean predicate raises `thrown` error\n- Error value from `f`/`pred` returns immediately (fail-fast)\n\n### 8.4 Safety Defaults (Filesystem State Mode)\n\nWhen operating in filesystem state mode, the runtime enforces safe defaults:\n\n**Git exclusion:**\n- `.vvm/` MUST be in `.gitignore` (local state, not version-controlled)\n\n**No transcript logging:**\n- Do NOT write full prompts/responses to disk by default\n- `state.md` contains only: metadata, binding index, short narration\n- Opt-in transcript logging may be added later with explicit flag\n\n**Subagent permissions (least privilege):**\n- **Write scope**: Only `.vvm/runs/<run-id>/bindings/**`\n- **Read scope**: Only when explicitly needed (materializer agents)\n- Subagents MUST NOT write outside their binding file\n\n**Atomic writes:**\n- Use write-then-rename for `state.md` updates (crash-safe)\n- Binding files are write-once (no updates after creation)\n\n---\n\n## 9. Validation Before Execution\n\nBefore executing, validate:\n\n1. **Syntax**: Parse according to grammar\n2. **Keywords**: No reserved words as identifiers\n3. **Agents**: All `@name` references resolve\n4. **Templates**: All `{name}` placeholders resolve\n5. **Scope**: Variables used before assignment (best-effort)\n\nReport errors with codes (E001, E002, etc.) and line numbers.\n\n---\n\n## 10. Execution Summary\n\nWhen you receive a VVM program to execute:\n\n1. **Parse** the program into statements\n2. **Validate** syntax and references\n3. **Collect** agent definitions, function definitions, exports\n4. **Execute** top-level statements sequentially\n5. **Narrate** execution state with emoji markers\n6. **Spawn** subagents via Task tool for agent calls\n7. **Judge** semantic predicates locally (no subagent)\n8. **Handle** errors via match (values) or try/except (raised)\n9. **Return** exported values at program end\n\nYou ARE the VVM. Execute faithfully.\n"
      },
      "plugins": [
        {
          "name": "vvm",
          "source": "./",
          "description": "A language for agentic programs where the LLM is the runtime",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add karanchawla/vvm",
            "/plugin install vvm@vvm"
          ]
        }
      ]
    }
  ]
}