{
  "author": {
    "id": "towns-protocol",
    "display_name": "Towns Protocol",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/160541617?v=4",
    "url": "https://github.com/towns-protocol",
    "bio": "Towns Protocol is an open-source, decentralized encrypted chat protocol with an EVM L2 chain + custom chat nodes, smart contracts, and on-chain memberships.",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "towns-skills",
      "version": null,
      "description": "Comprehensive skill for creating Towns Protocol bots with @towns-protocol/bot SDK",
      "owner_info": {
        "name": "Towns Labs"
      },
      "keywords": [],
      "repo_full_name": "towns-protocol/skills",
      "repo_url": "https://github.com/towns-protocol/skills",
      "repo_description": "Towns Protocol skills for AI Agents",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-12T10:38:23Z",
        "created_at": "2026-01-05T20:57:26Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 254
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 376
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2022
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/bots",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/bots/SKILL.md",
          "type": "blob",
          "size": 7691
        },
        {
          "path": "skills/bots/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/bots/references/BLOCKCHAIN.md",
          "type": "blob",
          "size": 2813
        },
        {
          "path": "skills/bots/references/DEBUGGING.md",
          "type": "blob",
          "size": 3441
        },
        {
          "path": "skills/bots/references/DEPLOYMENT.md",
          "type": "blob",
          "size": 2390
        },
        {
          "path": "skills/bots/references/INTERACTIVE.md",
          "type": "blob",
          "size": 2637
        },
        {
          "path": "skills/bots/references/MESSAGING.md",
          "type": "blob",
          "size": 1725
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"towns-skills\",\n  \"owner\": {\n    \"name\": \"Towns Labs\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"towns\",\n      \"source\": \"./\",\n      \"description\": \"Comprehensive skill for creating Towns Protocol bots with @towns-protocol/bot SDK\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"towns\",\n  \"description\": \"Skills for building Towns Protocol bots - covers SDK initialization, slash commands, message handlers, reactions, interactive forms, blockchain operations, and deployment\",\n  \"version\": \"2.0.0\",\n  \"author\": {\n    \"name\": \"towns-protocol\"\n  },\n  \"keywords\": [\"towns\", \"bot\", \"sdk\", \"blockchain\", \"messaging\", \"makeTownsBot\", \"webhook\"]\n}\n",
        "README.md": "# Towns Bot Skill\n\nAn [Agent Skill](https://agentskills.io) providing comprehensive knowledge for building Towns Protocol bots. Compatible with Claude Code, OpenAI Codex, and other agents supporting the Agent Skills specification.\n\n## Installation\n\n### Claude Code\n\n**Option 1: Via CLI menu**\n\n1. Run `/plugin` in Claude Code\n2. Select **Marketplaces** ‚Üí **Add Marketplace**\n3. Enter: `github:towns-protocol/skills`\n4. Run `/plugin install towns`\n\n**Option 2: Edit settings directly**\n\nAdd to `~/.claude/settings.json`:\n\n```json\n{\n  \"plugins\": {\n    \"marketplaces\": [\"github:towns-protocol/skills\"]\n  }\n}\n```\n\nThen restart Claude Code and run `/plugin install towns`\n\n### OpenAI Codex\n\n**Option 1: Clone to skills directory**\n\n```bash\ngit clone git@github.com:towns-protocol/skills.git ~/.codex/skills/towns\n```\n\n**Option 2: Add to project**\n\n```bash\ngit clone git@github.com:towns-protocol/skills.git .codex/skills/towns\n```\n\nThe skill will be available as `$bots` in Codex.\n\n### Other Agents\n\nThis skill follows the [Agent Skills specification](https://agentskills.io). Copy the `skills/bots/SKILL.md` file to your agent's skills directory.\n\n## Usage\n\n| Agent | Invocation |\n|-------|------------|\n| Claude Code | `/towns:bots` |\n| OpenAI Codex | `$bots` |\n\nThe skill also triggers automatically when working on Towns bot development tasks.\n\n## What's Included\n\n- SDK initialization and configuration\n- Event handlers (messages, commands, reactions, tips)\n- Messaging API (mentions, threads, attachments, formatting)\n- Interactive components (forms, buttons, transactions)\n- Blockchain operations (read/write contracts, transaction verification)\n- Deployment guides (local dev, Render.com, graceful shutdown)\n- Debugging patterns and common mistakes\n\n## Resources\n\n- [Towns Developer Portal](https://app.towns.com/developer)\n- [Towns Documentation](https://docs.towns.com/build/bots)\n- [@towns-protocol/bot SDK](https://www.npmjs.com/package/@towns-protocol/bot)\n- [Agent Skills Specification](https://agentskills.io)\n",
        "skills/bots/SKILL.md": "---\nname: bots\ndescription: >-\n  Use when building Towns Protocol bots - covers SDK initialization, slash commands,\n  message handlers, reactions, interactive forms, blockchain operations, and deployment.\n  Triggers: \"towns bot\", \"makeTownsBot\", \"onSlashCommand\", \"onMessage\", \"sendInteractionRequest\",\n  \"webhook\", \"bot deployment\", \"@towns-protocol/bot\"\nlicense: MIT\ncompatibility: Requires Bun runtime, Base network RPC access, @towns-protocol/bot SDK\nmetadata:\n  author: towns-protocol\n  version: \"2.0.0\"\n---\n\n# Towns Protocol Bot SDK Reference\n\n## Critical Rules\n\n**MUST follow these rules - violations cause silent failures:**\n\n1. **User IDs are Ethereum addresses** - Always `0x...` format, never usernames\n2. **Mentions require BOTH** - `<@{userId}>` format in text AND `mentions` array in options\n3. **Two-wallet architecture**:\n   - `bot.viem.account.address` = Gas wallet (signs & pays fees) - **MUST fund with Base ETH**\n   - `bot.appAddress` = Treasury (optional, for transfers)\n4. **Slash commands DON'T trigger onMessage** - They're exclusive handlers\n5. **Interactive forms use `type` property** - Not `case` (e.g., `type: 'form'`)\n6. **Never trust txHash alone** - Verify `receipt.status === 'success'` before granting access\n\n## Quick Reference\n\n### Key Imports\n\n```typescript\nimport { makeTownsBot, getSmartAccountFromUserId } from '@towns-protocol/bot'\nimport type { BotCommand, BotHandler } from '@towns-protocol/bot'\nimport { Permission } from '@towns-protocol/web3'\nimport { parseEther, formatEther, erc20Abi, zeroAddress } from 'viem'\nimport { readContract, waitForTransactionReceipt } from 'viem/actions'\nimport { execute } from 'viem/experimental/erc7821'\n```\n\n### Handler Methods\n\n| Method | Signature | Notes |\n|--------|-----------|-------|\n| `sendMessage` | `(channelId, text, opts?) ‚Üí { eventId }` | opts: `{ threadId?, replyId?, mentions?, attachments? }` |\n| `editMessage` | `(channelId, eventId, text)` | Bot's own messages only |\n| `removeEvent` | `(channelId, eventId)` | Bot's own messages only |\n| `sendReaction` | `(channelId, messageId, emoji)` | |\n| `sendInteractionRequest` | `(channelId, payload)` | Forms, transactions, signatures |\n| `hasAdminPermission` | `(userId, spaceId) ‚Üí boolean` | |\n| `ban` / `unban` | `(userId, spaceId)` | Needs ModifyBanning permission |\n\n### Bot Properties\n\n| Property | Description |\n|----------|-------------|\n| `bot.viem` | Viem client for blockchain |\n| `bot.viem.account.address` | Gas wallet - **MUST fund with Base ETH** |\n| `bot.appAddress` | Treasury wallet (optional) |\n| `bot.botId` | Bot identifier |\n\n**For detailed guides, see [references/](references/):**\n- [Messaging API](references/MESSAGING.md) - Mentions, threads, attachments, formatting\n- [Blockchain Operations](references/BLOCKCHAIN.md) - Read/write contracts, verify transactions\n- [Interactive Components](references/INTERACTIVE.md) - Forms, transaction requests\n- [Deployment](references/DEPLOYMENT.md) - Local dev, Render, tunnels\n- [Debugging](references/DEBUGGING.md) - Troubleshooting guide\n\n---\n\n## Bot Setup\n\n### Project Initialization\n\n```bash\nbunx towns-bot init my-bot\ncd my-bot\nbun install\n```\n\n### Environment Variables\n\n```bash\nAPP_PRIVATE_DATA=<base64_credentials>   # From app.towns.com/developer\nJWT_SECRET=<webhook_secret>              # Min 32 chars\nPORT=3000\nBASE_RPC_URL=https://base-mainnet.g.alchemy.com/v2/KEY  # Recommended\n```\n\n### Basic Bot Template\n\n```typescript\nimport { makeTownsBot } from '@towns-protocol/bot'\nimport type { BotCommand } from '@towns-protocol/bot'\n\nconst commands = [\n  { name: 'help', description: 'Show help' },\n  { name: 'ping', description: 'Check if alive' }\n] as const satisfies BotCommand[]\n\nconst bot = await makeTownsBot(\n  process.env.APP_PRIVATE_DATA!,\n  process.env.JWT_SECRET!,\n  { commands }\n)\n\nbot.onSlashCommand('ping', async (handler, event) => {\n  const latency = Date.now() - event.createdAt.getTime()\n  await handler.sendMessage(event.channelId, 'Pong! ' + latency + 'ms')\n})\n\nexport default bot.start()\n```\n\n### Config Validation\n\n```typescript\nimport { z } from 'zod'\n\nconst EnvSchema = z.object({\n  APP_PRIVATE_DATA: z.string().min(1),\n  JWT_SECRET: z.string().min(32),\n  DATABASE_URL: z.string().url().optional()\n})\n\nconst env = EnvSchema.safeParse(process.env)\nif (!env.success) {\n  console.error('Invalid config:', env.error.issues)\n  process.exit(1)\n}\n```\n\n---\n\n## Event Handlers\n\n### onMessage\n\nTriggers on regular messages (NOT slash commands).\n\n```typescript\nbot.onMessage(async (handler, event) => {\n  // event: { userId, spaceId, channelId, eventId, message, isMentioned, threadId?, replyId? }\n\n  if (event.isMentioned) {\n    await handler.sendMessage(event.channelId, 'You mentioned me!')\n  }\n})\n```\n\n### onSlashCommand\n\nTriggers on `/command`. Does NOT trigger onMessage.\n\n```typescript\nbot.onSlashCommand('weather', async (handler, { args, channelId }) => {\n  // /weather San Francisco ‚Üí args: ['San', 'Francisco']\n  const location = args.join(' ')\n  if (!location) {\n    await handler.sendMessage(channelId, 'Usage: /weather <location>')\n    return\n  }\n  // ... fetch weather\n})\n```\n\n### onReaction\n\n```typescript\nbot.onReaction(async (handler, event) => {\n  // event: { reaction, messageId, channelId }\n  if (event.reaction === 'üëã') {\n    await handler.sendMessage(event.channelId, 'I saw your wave!')\n  }\n})\n```\n\n### onTip\n\nRequires \"All Messages\" mode in Developer Portal.\n\n```typescript\nbot.onTip(async (handler, event) => {\n  // event: { senderAddress, receiverAddress, amount (bigint), currency }\n  if (event.receiverAddress === bot.appAddress) {\n    await handler.sendMessage(event.channelId,\n      'Thanks for ' + formatEther(event.amount) + ' ETH!')\n  }\n})\n```\n\n### onInteractionResponse\n\n```typescript\nbot.onInteractionResponse(async (handler, event) => {\n  switch (event.response.payload.content?.case) {\n    case 'form':\n      const form = event.response.payload.content.value\n      for (const c of form.components) {\n        if (c.component.case === 'button' && c.id === 'yes') {\n          await handler.sendMessage(event.channelId, 'You clicked Yes!')\n        }\n      }\n      break\n    case 'transaction':\n      const tx = event.response.payload.content.value\n      if (tx.txHash) {\n        // IMPORTANT: Verify on-chain before granting access\n        // See references/BLOCKCHAIN.md for full verification pattern\n        await handler.sendMessage(event.channelId,\n          'TX: https://basescan.org/tx/' + tx.txHash)\n      }\n      break\n  }\n})\n```\n\n### Event Context Validation\n\nAlways validate context before using:\n\n```typescript\nbot.onSlashCommand('cmd', async (handler, event) => {\n  if (!event.spaceId || !event.channelId) {\n    console.error('Missing context:', { userId: event.userId })\n    return\n  }\n  // Safe to proceed\n})\n```\n\n---\n\n## Common Mistakes\n\n| Mistake | Fix |\n|---------|-----|\n| `insufficient funds for gas` | Fund `bot.viem.account.address` with Base ETH |\n| Mention not highlighting | Include BOTH `<@userId>` in text AND `mentions` array |\n| Slash command not working | Add to `commands` array in makeTownsBot |\n| Handler not triggering | Check message forwarding mode in Developer Portal |\n| `writeContract` failing | Use `execute()` for external contracts |\n| Granting access on txHash | Verify `receipt.status === 'success'` first |\n| Message lines overlapping | Use `\\n\\n` (double newlines), not `\\n` |\n| Missing event context | Validate `spaceId`/`channelId` before using |\n\n---\n\n## Resources\n\n- **Developer Portal**: https://app.towns.com/developer\n- **Documentation**: https://docs.towns.com/build/bots\n- **SDK**: https://www.npmjs.com/package/@towns-protocol/bot\n- **Chain ID**: 8453 (Base Mainnet)\n",
        "skills/bots/references/BLOCKCHAIN.md": "# Blockchain Operations\n\n## Read Contract\n\n```typescript\nimport { readContract } from 'viem/actions'\nimport { erc20Abi } from 'viem'\n\nconst balance = await readContract(bot.viem, {\n  address: tokenAddress,\n  abi: erc20Abi,\n  functionName: 'balanceOf',\n  args: [userAddress]\n})\n```\n\n## Execute Transaction\n\n```typescript\nimport { execute } from 'viem/experimental/erc7821'\nimport { waitForTransactionReceipt } from 'viem/actions'\n\nconst hash = await execute(bot.viem, {\n  address: bot.appAddress,\n  account: bot.viem.account,\n  calls: [{\n    to: targetAddress,\n    abi: contractAbi,\n    functionName: 'transfer',\n    args: [recipient, amount]\n  }]\n})\n\nawait waitForTransactionReceipt(bot.viem, { hash })\n```\n\n## Verify Transaction (Critical for Payments)\n\n**Never grant access based on txHash alone.** Always verify on-chain:\n\n```typescript\nbot.onInteractionResponse(async (handler, event) => {\n  if (event.response.payload.content?.case !== 'transaction') return\n  const tx = event.response.payload.content.value\n\n  if (tx.txHash) {\n    const receipt = await waitForTransactionReceipt(bot.viem, {\n      hash: tx.txHash\n    })\n\n    if (receipt.status !== 'success') {\n      await handler.sendMessage(event.channelId, 'Transaction failed on-chain')\n      return\n    }\n\n    // NOW safe to grant access\n    await grantUserAccess(event.userId)\n    await handler.sendMessage(event.channelId, 'Payment confirmed!')\n  }\n})\n```\n\n## Debug Transaction Failures\n\n```typescript\ntry {\n  const hash = await execute(bot.viem, { /* ... */ })\n  console.log('TX submitted:', hash)\n\n  const receipt = await waitForTransactionReceipt(bot.viem, { hash })\n  console.log('TX result:', {\n    status: receipt.status,\n    gasUsed: receipt.gasUsed.toString(),\n    blockNumber: receipt.blockNumber\n  })\n\n  if (receipt.status !== 'success') {\n    console.error('TX reverted. Check on basescan:',\n      'https://basescan.org/tx/' + hash)\n  }\n} catch (err) {\n  console.error('TX failed:', err.message)\n  // Common: insufficient funds, nonce issues, contract revert\n}\n```\n\n## Token Addresses (Base Mainnet)\n\n```typescript\nimport { zeroAddress } from 'viem'\n\nconst TOKENS = {\n  ETH: zeroAddress,\n  USDC: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',\n  TOWNS: '0x00000000A22C618fd6b4D7E9A335C4B96B189a38'\n}\n```\n\n## Check Balances\n\n```typescript\nimport { formatEther } from 'viem'\n\nconst gasBalance = await bot.viem.getBalance({ address: bot.viem.account.address })\nconst treasuryBalance = await bot.viem.getBalance({ address: bot.appAddress })\nconsole.log('Gas: ' + formatEther(gasBalance) + ' ETH')\nconsole.log('Treasury: ' + formatEther(treasuryBalance) + ' ETH')\n```\n\n## Get User's Smart Account\n\n```typescript\nimport { getSmartAccountFromUserId } from '@towns-protocol/bot'\n\nconst userSmartAccount = getSmartAccountFromUserId(event.userId)\n```\n",
        "skills/bots/references/DEBUGGING.md": "# Debugging\n\n## Handler Not Triggering\n\nMost common issue. Check in order:\n\n### 1. Webhook URL Correct?\n\n```bash\n# Your bot should log incoming requests\ncurl -X POST https://your-webhook-url/webhook \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"test\": true}'\n```\n\n### 2. Tunnel Running? (local dev)\n\n```bash\n# Tailscale\ntailscale funnel status\n\n# ngrok\ncurl http://127.0.0.1:4040/api/tunnels\n```\n\n### 3. Bot Added to Channel?\n\nBot must be:\n- Installed in the Space (Settings ‚Üí Integrations)\n- Added to the specific channel (Channel Settings ‚Üí Integrations)\n\n### 4. Message Forwarding Mode?\n\nIn Developer Portal:\n- \"Mentions Only\" = only `@bot` messages\n- \"All Messages\" = everything (required for `onTip`)\n\n### 5. Slash Command Registered?\n\nMust be in `commands` array passed to `makeTownsBot`:\n\n```typescript\nconst commands = [\n  { name: 'mycommand', description: 'Does something' }\n] as const satisfies BotCommand[]\n\nconst bot = await makeTownsBot(creds, secret, { commands })\n```\n\n## Add Request Logging\n\n```typescript\nconst bot = await makeTownsBot(\n  process.env.APP_PRIVATE_DATA!,\n  process.env.JWT_SECRET!,\n  { commands }\n)\n\n// Log all incoming events\nbot.onMessage(async (handler, event) => {\n  console.log('[onMessage]', {\n    userId: event.userId,\n    channelId: event.channelId,\n    message: event.message.slice(0, 100),\n    isMentioned: event.isMentioned\n  })\n  // ... rest of handler\n})\n\nbot.onSlashCommand('*', async (handler, event) => {\n  console.log('[onSlashCommand]', {\n    command: event.command,\n    args: event.args,\n    userId: event.userId\n  })\n})\n```\n\n## Common Error Messages\n\n| Error | Cause | Fix |\n|-------|-------|-----|\n| `JWT verification failed` | Wrong JWT_SECRET | Match secret in Developer Portal |\n| `insufficient funds for gas` | Empty gas wallet | Fund `bot.viem.account.address` |\n| `Invalid APP_PRIVATE_DATA` | Malformed credentials | Re-copy from Developer Portal |\n| `ECONNREFUSED` on RPC | Bad RPC URL or rate limited | Use dedicated RPC (Alchemy/Infura) |\n| `nonce too low` | Concurrent transactions | Add transaction queue or retry logic |\n\n## Verify Webhook Connectivity\n\n```typescript\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/health', (c) => c.json({\n  status: 'ok',\n  timestamp: new Date().toISOString(),\n  gasWallet: bot.viem.account.address\n}))\n\n// Test from outside:\n// curl https://your-webhook-url/health\n```\n\n## Debug Transaction Failures\n\n```typescript\nimport { waitForTransactionReceipt } from 'viem/actions'\n\ntry {\n  const hash = await execute(bot.viem, { /* ... */ })\n  console.log('TX submitted:', hash)\n\n  const receipt = await waitForTransactionReceipt(bot.viem, { hash })\n  console.log('TX result:', {\n    status: receipt.status,\n    gasUsed: receipt.gasUsed.toString(),\n    blockNumber: receipt.blockNumber\n  })\n\n  if (receipt.status !== 'success') {\n    console.error('TX reverted. Check on basescan:',\n      'https://basescan.org/tx/' + hash)\n  }\n} catch (err) {\n  console.error('TX failed:', err.message)\n  // Common: insufficient funds, nonce issues, contract revert\n}\n```\n\n## Check Gas Wallet Balance\n\n```typescript\nimport { formatEther } from 'viem'\n\nconst balance = await bot.viem.getBalance({\n  address: bot.viem.account.address\n})\n\nconsole.log('Gas wallet balance:', formatEther(balance), 'ETH')\n\nif (balance === 0n) {\n  console.error('WARNING: Gas wallet is empty!')\n  console.error('Fund this address:', bot.viem.account.address)\n}\n```\n",
        "skills/bots/references/DEPLOYMENT.md": "# Deployment\n\n## Local Development\n\n```bash\n# Start bot (default port 5123)\nbun run dev\n\n# Expose webhook via Tailscale Funnel\ntailscale funnel 5123\n# Creates URL like: https://your-machine.taild8e1b0.ts.net/\n\n# Alternative: ngrok\nngrok http 5123\n```\n\n## Setup Webhook in Developer Portal\n\n1. Go to https://app.towns.com/developer\n2. Select your bot\n3. Set Webhook URL to your tunnel URL + `/webhook`\n   - Example: `https://your-machine.taild8e1b0.ts.net/webhook`\n4. Save changes\n\n## Testing Checklist\n\n- [ ] Bot server running (`bun run dev`)\n- [ ] Tunnel active (Tailscale/ngrok)\n- [ ] Webhook URL updated in Developer Portal\n- [ ] Bot installed in a Space (Settings ‚Üí Integrations)\n- [ ] Bot added to the specific channel (Channel Settings ‚Üí Integrations)\n- [ ] Check logs for incoming webhook events\n\n## Render.com Deployment\n\n1. Create Web Service from Git repo\n2. Set build command: `bun install`\n3. Set start command: `bun run start`\n4. Set environment variables:\n   - `APP_PRIVATE_DATA`\n   - `JWT_SECRET`\n   - `DATABASE_URL` (if using database)\n   - `BASE_RPC_URL` (recommended: Alchemy/Infura)\n5. Set webhook URL in app.towns.com/developer to Render URL + `/webhook`\n\n## Health Check Endpoint\n\nAdd for deployment platforms that require health checks:\n\n```typescript\nimport { Hono } from 'hono'\n\nconst app = new Hono()\n\napp.get('/health', (c) => c.json({\n  status: 'ok',\n  timestamp: new Date().toISOString(),\n  gasWallet: bot.viem.account.address\n}))\n```\n\n## Graceful Shutdown\n\nHandle SIGTERM for clean shutdown (required for Render/Kubernetes):\n\n```typescript\nprocess.on('SIGTERM', async () => {\n  console.log('SIGTERM received, closing...')\n  await pool.end()  // Close DB connections\n  process.exit(0)\n})\n```\n\n## Database Connection Pool\n\n```typescript\nimport { Pool } from 'pg'\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  max: 10,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000\n})\n\n// Health check on startup\nawait pool.query('SELECT 1')\n```\n\n## Thread Ownership Pattern (Race-Safe)\n\n```typescript\n// First writer wins\nawait pool.query(\n  `INSERT INTO threads (thread_id, user_id)\n   VALUES ($1, $2)\n   ON CONFLICT (thread_id) DO NOTHING`,\n  [threadId, userId]\n)\n\n// Check ownership\nconst result = await pool.query(\n  'SELECT user_id FROM threads WHERE thread_id = $1',\n  [threadId]\n)\nreturn result.rows[0]?.user_id === userId\n```\n",
        "skills/bots/references/INTERACTIVE.md": "# Interactive Components\n\n## Send Button Form\n\n```typescript\nawait handler.sendInteractionRequest(channelId, {\n  type: 'form',           // NOT 'case'\n  id: 'my-form',\n  components: [\n    { id: 'yes', type: 'button', label: 'Yes' },\n    { id: 'no', type: 'button', label: 'No' }\n  ],\n  recipient: event.userId  // Optional: private to this user\n})\n```\n\n## Handle Form Response\n\n```typescript\nbot.onInteractionResponse(async (handler, event) => {\n  if (event.response.payload.content?.case !== 'form') return\n\n  const form = event.response.payload.content.value\n  for (const c of form.components) {\n    if (c.component.case === 'button') {\n      console.log('Button clicked:', c.id)\n\n      if (c.id === 'yes') {\n        await handler.sendMessage(event.channelId, 'You clicked Yes!')\n      }\n    }\n  }\n})\n```\n\n## Request Transaction\n\n```typescript\nimport { encodeFunctionData, erc20Abi, parseUnits } from 'viem'\n\nawait handler.sendInteractionRequest(channelId, {\n  type: 'transaction',\n  id: 'payment',\n  title: 'Send Tokens',\n  subtitle: 'Transfer 50 USDC',\n  tx: {\n    chainId: '8453',\n    to: '0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913',  // USDC\n    value: '0',\n    data: encodeFunctionData({\n      abi: erc20Abi,\n      functionName: 'transfer',\n      args: [recipient, parseUnits('50', 6)]\n    })\n  },\n  recipient: event.userId\n})\n```\n\n## Handle Transaction Response\n\n```typescript\nbot.onInteractionResponse(async (handler, event) => {\n  if (event.response.payload.content?.case !== 'transaction') return\n\n  const tx = event.response.payload.content.value\n\n  if (tx.txHash) {\n    // IMPORTANT: Always verify on-chain before granting access\n    // See BLOCKCHAIN.md for full verification pattern\n    const receipt = await waitForTransactionReceipt(bot.viem, {\n      hash: tx.txHash\n    })\n\n    if (receipt.status === 'success') {\n      await handler.sendMessage(event.channelId,\n        'Payment confirmed: https://basescan.org/tx/' + tx.txHash)\n    } else {\n      await handler.sendMessage(event.channelId, 'Transaction failed on-chain')\n    }\n  } else if (tx.error) {\n    await handler.sendMessage(event.channelId, 'Transaction rejected: ' + tx.error)\n  }\n})\n```\n\n## Request Signature\n\n```typescript\nawait handler.sendInteractionRequest(channelId, {\n  type: 'signature',\n  id: 'sign-message',\n  title: 'Sign Message',\n  message: 'I agree to the terms of service',\n  recipient: event.userId\n})\n```\n\n## Important Notes\n\n- **Use `type` property** - NOT `case` (common mistake)\n- **`recipient` is optional** - If set, only that user sees the interaction\n- **Always verify transactions** - Never trust txHash alone, check receipt.status\n",
        "skills/bots/references/MESSAGING.md": "# Messaging API\n\n## Send Message with Mention\n\n**MUST include BOTH formatted text AND mentions array:**\n\n```typescript\n// Format: Hello <@0x...>!\nconst text = 'Hello <@' + userId + '>!'\nawait handler.sendMessage(channelId, text, {\n  mentions: [{ userId, displayName: 'User' }]\n})\n\n// @channel\nawait handler.sendMessage(channelId, 'Attention!', {\n  mentions: [{ atChannel: true }]\n})\n```\n\n## Threads & Replies\n\n```typescript\n// Reply in thread\nawait handler.sendMessage(channelId, 'Thread reply', { threadId: event.eventId })\n\n// Reply to specific message\nawait handler.sendMessage(channelId, 'Reply', { replyId: messageId })\n```\n\n## Attachments\n\n```typescript\n// Image\nattachments: [{ type: 'image', url: 'https://...jpg', alt: 'Description' }]\n\n// Miniapp\nattachments: [{ type: 'miniapp', url: 'https://your-app.com/miniapp.html' }]\n\n// Large file (chunked)\nattachments: [{\n  type: 'chunked',\n  data: readFileSync('./video.mp4'),\n  filename: 'video.mp4',\n  mimetype: 'video/mp4'\n}]\n```\n\n## Message Formatting\n\nTowns has specific rendering behavior:\n- **Use `\\n\\n`** (double newlines) between sections - single `\\n` causes overlap\n- **Never use `---`** as separator - renders as zero-height rule\n- **Use middot** for inline data: `Value: $1.00 ¬∑ P&L: $0.50`\n\n```typescript\n// Good - double newlines\nconst msg = ['**Header**', 'Line 1', 'Line 2'].join('\\n\\n')\n\n// Bad - single newlines will collapse\nconst bad = lines.join('\\n')\n```\n\n## Edit and Delete\n\n```typescript\n// Edit bot's own message\nawait handler.editMessage(channelId, eventId, 'Updated text')\n\n// Delete bot's own message\nawait handler.removeEvent(channelId, eventId)\n```\n\n## Reactions\n\n```typescript\nawait handler.sendReaction(channelId, messageId, 'üëç')\n```\n"
      },
      "plugins": [
        {
          "name": "towns",
          "source": "./",
          "description": "Comprehensive skill for creating Towns Protocol bots with @towns-protocol/bot SDK",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add towns-protocol/skills",
            "/plugin install towns@towns-skills"
          ]
        }
      ]
    }
  ]
}