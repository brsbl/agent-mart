{
  "author": {
    "id": "hmemcpy",
    "display_name": "Igal Tabachnik",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/601206?u=87f60c0e096c1d61f7a94d8692d134bb7fbeeba1&v=4",
    "url": "https://github.com/hmemcpy",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 2,
      "total_stars": 15,
      "total_forks": 1
    }
  },
  "marketplaces": [
    {
      "name": "ralph-wiggum",
      "version": "1.0.6",
      "description": "Generate Ralph Wiggum loop infrastructure for iterative AI-driven development",
      "owner_info": {
        "name": "hmemcpy",
        "email": "hmemcpy@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "hmemcpy/ralph-wiggum",
      "repo_url": "https://github.com/hmemcpy/ralph-wiggum",
      "repo_description": "Ralph Wiggum loop generator for iterative AI-driven development. Supports Claude Code and Amp.",
      "homepage": "",
      "signals": {
        "stars": 15,
        "forks": 1,
        "pushed_at": "2026-01-28T12:50:27Z",
        "created_at": "2026-01-10T16:38:06Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 598
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 406
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 5314
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/ralph-amp",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/ralph-amp/SKILL.md",
          "type": "blob",
          "size": 18898
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/ralph-claude",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/ralph-claude/SKILL.md",
          "type": "blob",
          "size": 17250
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"ralph-wiggum\",\n  \"version\": \"1.0.6\",\n  \"description\": \"Generate Ralph Wiggum loop infrastructure for iterative AI-driven development\",\n  \"owner\": {\n    \"name\": \"hmemcpy\",\n    \"email\": \"hmemcpy@gmail.com\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"ralph-wiggum\",\n      \"description\": \"Generate the complete Ralph Wiggum loop infrastructure for iterative AI-driven development. Supports Claude Code and Amp with agent-specific optimizations.\",\n      \"version\": \"1.0.6\",\n      \"author\": {\n        \"name\": \"hmemcpy\"\n      },\n      \"source\": \"./\",\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"ralph-wiggum\",\n  \"version\": \"1.0.5\",\n  \"description\": \"Generate Ralph Wiggum loop infrastructure for iterative AI-driven development. Supports Claude Code and Amp with agent-specific optimizations.\",\n  \"author\": {\n    \"name\": \"hmemcpy\"\n  },\n  \"repository\": \"https://github.com/hmemcpy/ralph-wiggum\",\n  \"license\": \"MIT\",\n  \"keywords\": [\"ralph-wiggum\", \"ai-loop\", \"autonomous\", \"development\"]\n}\n",
        "README.md": "# Ralph Wiggum Loop - Multi-Agent Plugin\n\nGenerate the complete [Ralph Wiggum loop](https://github.com/ghuntley/how-to-ralph-wiggum) infrastructure for iterative AI-driven development. Supports multiple AI agents with agent-specific optimizations.\n\n## What is Ralph?\n\nAn iterative AI development loop where a dumb bash script keeps restarting the AI agent, and the agent figures out what to do next by reading the plan file each time.\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    OUTER LOOP (bash)                    │\n│            while :; do amp -x < PROMPT.md ; done        │\n└─────────────────────────────────────────────────────────┘\n                           │\n                           ▼\n┌─────────────────────────────────────────────────────────┐\n│                   INNER LOOP (agent)                    │\n│   Read plan → Pick task → Implement → Test → Commit     │\n└─────────────────────────────────────────────────────────┘\n```\n\n## Workflow\n\n1. **Planning** (interactive) — Skill/command interviews you with clarifying questions\n2. **Building** (loop) — `./loop.sh` implements one task per iteration until complete\n\n## Supported Agents\n\n| Agent | CLI Command | Key Features |\n|-------|-------------|--------------|\n| **Amp** | `amp -x` | Oracle (planning/debug), Librarian (docs), finder (semantic search) |\n| **Claude Code** | `claude -p` | Plan Mode, AskUserQuestion, Subagents |\n\n## Installation\n\n```bash\ngit clone https://github.com/hmemcpy/ralph-wiggum\ncd ralph-wiggum\n./install.sh\n```\n\nThis installs:\n- **Claude Code**: Plugin to `~/.claude/plugins/`\n- **Amp**: Skill to `~/.config/agents/skills/ralph-wiggum/`\n\nRestart your agent for changes to take effect.\n\n## Usage\n\n### Amp\n\n```bash\n/skill ralph-amp [optional/path/to/plan.md]\n```\n\nThe skill will:\n1. Interview you with clarifying questions (A/B/C/D format)\n2. Optionally run Oracle for architectural review\n3. Generate all files\n\n### Claude Code\n\n```bash\n/skill ralph-claude [optional/path/to/plan.md]\n```\n\nThe skill will:\n1. Use `AskUserQuestion` to interview you\n2. Generate all files\n\n### Generated Files\n\n| File | Purpose |\n|------|---------|\n| `specs/<feature>.md` | Requirements, user stories, edge cases |\n| `IMPLEMENTATION_PLAN.md` | Summary + prioritized task list |\n| `PROMPT.md` | Build mode instructions |\n| `loop.sh` | Build-only loop script |\n\n## Running the Loop\n\n```bash\nchmod +x loop.sh\n\n# Run until complete\n./loop.sh\n\n# Limit iterations\n./loop.sh 10\n```\n\n## Loop Features\n\n- **Autonomous**: Runs until `RALPH_COMPLETE` — never stops on its own\n- **Self-healing**: Exponential backoff on errors (30s→60s→120s→max 5min), never gives up\n- **Rate limit handling**: Detects API limits, parses timezone, waits with countdown timer\n- **Self-learning**: Agent updates AGENTS.md with operational discoveries\n- **Thread tracking**: Commits include thread URL for traceability\n- **Completion detection**: Exits only when agent outputs `RALPH_COMPLETE`\n\n## Agent-Specific Features\n\n### Amp\n- **Oracle**: Architecture review, planning decisions, debugging\n- **Librarian**: Read library documentation, understand APIs\n- **finder**: Semantic codebase search (not just text matching)\n- **Task**: Parallel subagent work for independent operations\n\n### Claude Code\n- **Plan Mode**: Read-only analysis with `AskUserQuestion` for requirements gathering\n- **Subagents**: Parallel analysis of code areas\n\n## Core Principles\n\n1. **One Task Per Iteration** - Fresh context, maximum focus\n2. **Search First** - Don't assume not implemented\n3. **Implement Completely** - No placeholders or stubs\n4. **Backpressure** - Validation must pass before commit\n5. **Self-Learning** - Update AGENTS.md with operational discoveries\n6. **Self-Healing** - Document bugs even if unrelated to current work\n7. **Let Ralph Ralph** - Agent determines approach, loop never stops\n\n## Project Structure\n\n```\nralph-wiggum/\n├── .claude-plugin/         # Claude Code plugin manifest\n├── skills/\n│   ├── ralph-amp/\n│   │   └── SKILL.md        # Amp skill\n│   └── ralph-claude/\n│       └── SKILL.md        # Claude Code skill\n├── install.sh              # Installer for both agents\n└── README.md\n```\n\n## Requirements\n\n- An AI coding agent (Amp or Claude Code)\n- A project with tests/linting (for backpressure)\n- `jq` installed (for streaming output parsing)\n\n## Security Warning\n\nRalph runs autonomously with permissions bypassed. **Always run in a sandboxed environment** (Docker, VM, etc.) to protect credentials and sensitive files.\n\n## License\n\nMIT\n\n## Credits\n\nBased on [How to Ralph Wiggum](https://github.com/ghuntley/how-to-ralph-wiggum) by Geoffrey Huntley.\nInspired by [snarktank/ralph](https://github.com/snarktank/ralph) PRD and threading patterns.\n",
        "agents/ralph-amp/SKILL.md": "---\nname: ralph-amp\ndescription: Interactive planning skill for Amp. Generates specs, implementation plans, and loop infrastructure through clarifying questions.\nallowed-tools:\n  - \"*\"\n---\n\n# Ralph Planning Skill (Amp)\n\nGenerate specs, implementation plans, and loop infrastructure for iterative AI-driven development.\n\n## Entry\n\n**Usage:** `/skill ralph-amp [optional/path/to/plan.md]`\n\n- If path provided: Read that `.md` file as the source specification\n- If no path: Use the current conversation context\n\n---\n\n## Step 1: Interview the User\n\nYou MUST ask clarifying questions before generating any files. Present questions with lettered options for quick responses.\n\n**Interview approach:**\n1. Present 3-5 questions covering scope, constraints, and validation\n2. Use A/B/C/D multiple choice format for quick answers\n3. Allow the user to respond with shorthand like \"1A, 2C, 3B\"\n4. Ask follow-up questions if answers are unclear\n\n**Example interview:**\n\n> I'll help you plan this feature. First, let me ask a few questions:\n>\n> **1. Scope** - How broad is this change?\n> - A) Single file/module\n> - B) Multiple related files  \n> - C) Cross-cutting (many parts of codebase)\n> - D) Greenfield (new feature from scratch)\n>\n> **2. Risk tolerance** - How aggressive should changes be?\n> - A) Conservative - minimal changes\n> - B) Balanced - reasonable refactoring OK\n> - C) Aggressive - significant refactoring acceptable\n>\n> **3. Validation** - How should we verify the implementation?\n> - A) Existing test suite\n> - B) Add new tests\n> - C) Manual testing sufficient\n>\n> Reply with your choices (e.g., \"1B, 2A, 3B\") or answer in your own words.\n\n**WAIT for user response before proceeding.**\n\n---\n\n## Step 2: Oracle Review (Optional)\n\nAfter receiving answers, offer to analyze the codebase:\n\n> Would you like me to analyze the codebase architecture before generating the plan?\n> - Reply **oracle** for architectural analysis\n> - Reply **skip** to proceed directly\n\n### If user chooses `oracle`:\n1. Use the Oracle tool to analyze relevant code areas\n2. Identify existing patterns, potential conflicts, dependencies\n3. Present findings and any additional clarifying questions\n4. **WAIT for user response before proceeding**\n\n### If user chooses `skip`:\nProceed directly to Step 3.\n\n---\n\n## Step 3: Generate Files\n\n**Always overwrite existing files** — never add suffixes like `-v2`, `-new`, or `_backup`. These files are ephemeral and meant to be regenerated. Use the exact filenames specified below.\n\n### 1. `specs/<feature-slug>.md`\n\nRequirements specification containing:\n- Feature overview\n- User stories\n- Acceptance criteria\n- Edge cases and error handling\n- Out of scope items\n\n### 2. `IMPLEMENTATION_PLAN.md`\n\nFormat:\n```markdown\n# Implementation Plan: <Feature Name>\n\n> **Scope**: <scope choice> | **Risk**: <risk choice> | **Constraints**: <constraint choice>\n\n## Summary\n\n<2-3 sentence overview of the implementation approach>\n\n## Tasks\n\n- [ ] Task 1: Description with enough context for implementation\n- [ ] Task 2: Description with enough context for implementation\n- [ ] Task 3: Description with enough context for implementation\n...\n```\n\nTasks should be:\n- Ordered by priority/dependency\n- Small enough for single iteration\n- Include file paths when known\n- Self-contained with sufficient context\n\n### 3. `PROMPT_plan.md`\n\nGenerate with this content (replace `[DIRECTORIES]` with relevant source directories):\n\n```markdown\n# Planning Mode\n\nYou are in PLANNING mode. Analyze specifications against existing code and generate a prioritized implementation plan.\n\n## Phase 0: Orient\n\n### 0a. Study specifications\nRead all files in `specs/` directory using finder and parallel reads.\n\n### 0b. Study existing implementation\nUse finder to analyze relevant source directories:\n[DIRECTORIES]\n\n### 0c. Study the current plan\nRead `IMPLEMENTATION_PLAN.md` if it exists.\n\n## Phase 1: Gap Analysis\n\nCompare specs against implementation:\n- What's already implemented?\n- What's missing?\n- What's partially done?\n\n**CRITICAL**: Don't assume something isn't implemented. Use finder to search the codebase first.\n\n## Phase 2: Generate Plan\n\nUpdate `IMPLEMENTATION_PLAN.md` with:\n- Tasks sorted by priority (P0 → P1 → P2)\n- Clear descriptions with file locations\n- Dependencies noted where relevant\n- Discoveries from gap analysis\n\n**CRITICAL: ALL tasks MUST use checkbox format:**\n- `- [ ] **Task Name**` for pending tasks\n- `- [x] **Task Name**` for completed tasks\n\nDo NOT use other formats like `#### P1.1: Task Name` or `**Task Name**` without checkboxes. The build loop relies on `grep -c \"^\\- \\[ \\]\"` to count remaining tasks.\n\nCapture the WHY, not just the WHAT.\n\n## Phase 3: Exit\n\nAfter updating the plan, output **RALPH_COMPLETE** and exit.\n\n## Guardrails\n\n999. NEVER implement code in planning mode\n1000. Use Task tool for parallel analysis of different areas\n1001. Each task must be completable in ONE loop iteration\n1002. Use Oracle to review priorities before finalizing\n1003. **ALWAYS use checkbox format `- [ ]` or `- [x]` for tasks in IMPLEMENTATION_PLAN.md** - The build loop relies on `grep -c \"^\\- \\[ \\]\"` to count remaining tasks. Never use `####` headers or bold text without checkboxes.\n```\n\n### 4. `PROMPT_build.md`\n\nGenerate with this content (replace `[VALIDATION_COMMAND]` with the appropriate command from AGENTS.md or project config):\n\n```markdown\n# Build Mode\n\nImplement ONE task from the plan, validate, commit, exit.\n\n## Phase 0: Orient\n\nStudy:\n- @AGENTS.md (how to build/test)\n- @specs/* (requirements)\n- @IMPLEMENTATION_PLAN.md (current state)\n\n### Check for completion\n\n```bash\ngrep -c \"^\\- \\[ \\]\" IMPLEMENTATION_PLAN.md || echo 0\n```\n\n- If 0: Run validation → commit → output **RALPH_COMPLETE** → exit\n- If > 0: Continue to Phase 1\n\n## Phase 1: Implement\n\n1. **Study the plan** — Choose the most important task from @IMPLEMENTATION_PLAN.md\n2. **Search first** — Don't assume not implemented. Use finder to verify behavior doesn't already exist\n3. **Implement** — ONE task only. Implement completely — no placeholders or stubs\n4. **Validate** — Run `[VALIDATION_COMMAND]`, must pass before continuing\n\nIf stuck, use Oracle to debug. Add extra logging if needed.\n\n## Phase 2: Update & Learn\n\n**Update IMPLEMENTATION_PLAN.md:**\n- Mark task `- [x] Completed`\n- Add discovered bugs or issues (even if unrelated to current task)\n- Note any new tasks discovered\n- Periodically clean out completed items when file gets large\n\n**Update AGENTS.md** (if you learned something new):\n- Add correct commands discovered through trial and error\n- Keep it brief and operational only — no status updates or progress notes\n\n## Phase 3: Commit & Exit\n\n```bash\ngit add -A && git commit -m \"feat([scope]): [description]\n\nThread: $AMP_THREAD_URL\"\n```\n\nCheck remaining:\n```bash\ngrep -c \"^\\- \\[ \\]\" IMPLEMENTATION_PLAN.md || echo 0\n```\n\n- If > 0: Say \"X tasks remaining\" and EXIT\n- If = 0: Output **RALPH_COMPLETE**\n\n## Guardrails\n\n99999. When authoring documentation, capture the why — tests and implementation importance.\n999999. Single sources of truth, no migrations/adapters. If tests unrelated to your work fail, resolve them as part of the increment.\n9999999. Implement functionality completely. Placeholders and stubs waste time redoing the same work.\n99999999. Keep @IMPLEMENTATION_PLAN.md current with learnings — future iterations depend on this to avoid duplicating efforts.\n999999999. Keep @AGENTS.md operational only — status updates and progress notes pollute every future loop's context.\n9999999999. For any bugs you notice, resolve them or document them in @IMPLEMENTATION_PLAN.md even if unrelated to current work.\n99999999999. ONE task per iteration. Search before implementing. Validation MUST pass. Never output RALPH_COMPLETE if tasks remain.\n```\n\n### 5. `loop.sh`\n\nGenerate with this content (replace `[FEATURE_NAME]` with a short kebab-case feature name like `auth-system` or `api-refactor`):\n\n```bash\n#!/bin/bash\n\n# Ralph Wiggum Build Loop (Amp)\n# Usage:\n#   ./loop.sh           # Auto mode: plan first, then build (default)\n#   ./loop.sh plan      # Planning mode only\n#   ./loop.sh build     # Build mode only\n#   ./loop.sh 10        # Auto mode, max 10 build iterations\n#   ./loop.sh build 5   # Build mode, max 5 iterations\n\nset -e\n\nFEATURE_NAME=\"[FEATURE_NAME]\"\nMODE=\"plan\"\nAUTO_MODE=true\nMAX_ITERATIONS=0\nITERATION=0\nCONSECUTIVE_FAILURES=0\nPARENT_THREAD_FILE=$(mktemp)\n\n# Colors\nRED='\\033[0;31m'\nYELLOW='\\033[1;33m'\nGREEN='\\033[0;32m'\nCYAN='\\033[0;36m'\nNC='\\033[0m'\n\nfor arg in \"$@\"; do\n  if [[ \"$arg\" == \"plan\" ]]; then\n    MODE=\"plan\"\n    AUTO_MODE=false\n  elif [[ \"$arg\" == \"build\" ]]; then\n    MODE=\"build\"\n    AUTO_MODE=false\n  elif [[ \"$arg\" =~ ^[0-9]+$ ]]; then\n    MAX_ITERATIONS=$arg\n  fi\ndone\n\nPROMPT_FILE=\"PROMPT_${MODE}.md\"\n\nif [[ ! -f \"$PROMPT_FILE\" ]]; then\n  echo -e \"${RED}Error: $PROMPT_FILE not found${NC}\"\n  echo \"Run the ralph-amp skill first to generate the required files.\"\n  exit 1\nfi\n\ncleanup() {\n  rm -f \"$PARENT_THREAD_FILE\"\n}\ntrap cleanup EXIT\n\nswitch_to_build_mode() {\n  echo \"\"\n  echo -e \"${CYAN}=== Switching to Build Mode ===${NC}\"\n  echo \"\"\n  MODE=\"build\"\n  PROMPT_FILE=\"PROMPT_${MODE}.md\"\n  ITERATION=0\n}\n\nseconds_until_next_hour() {\n  local now=$(date +%s)\n  local current_minute=$(date +%M)\n  local current_second=$(date +%S)\n  local seconds_past_hour=$((10#$current_minute * 60 + 10#$current_second))\n  local seconds_until=$((3600 - seconds_past_hour))\n  echo $seconds_until\n}\n\nseconds_until_daily_reset() {\n  local reset_hour=5\n  local now=$(date +%s)\n  local today_reset=$(date -v${reset_hour}H -v0M -v0S +%s 2>/dev/null || date -d \"today ${reset_hour}:00:00\" +%s)\n\n  if [[ $now -ge $today_reset ]]; then\n    local tomorrow_reset=$((today_reset + 86400))\n    echo $((tomorrow_reset - now))\n  else\n    echo $((today_reset - now))\n  fi\n}\n\ncountdown() {\n  local seconds=$1\n  local message=$2\n\n  while [[ $seconds -gt 0 ]]; do\n    local hours=$((seconds / 3600))\n    local minutes=$(((seconds % 3600) / 60))\n    local secs=$((seconds % 60))\n    printf \"\\r${CYAN}%s${NC} Time remaining: %02d:%02d:%02d \" \"$message\" $hours $minutes $secs\n    sleep 1\n    ((seconds--))\n  done\n  printf \"\\r%-80s\\r\" \" \"\n}\n\nis_recoverable_error() {\n  local output=\"$1\"\n  local exit_code=\"$2\"\n\n  # Check JSON error field from stream-json output\n  if [[ \"$output\" =~ \\\"error\\\":\\\"rate_limit\\\" ]]; then\n    return 0\n  fi\n  if [[ \"$output\" =~ \"rate limit\" ]] || [[ \"$output\" =~ \"Rate limit\" ]]; then\n    return 0\n  fi\n  if [[ \"$output\" =~ Error:\\ 429 ]] || [[ \"$output\" =~ Error:\\ 529 ]]; then\n    return 0\n  fi\n  return 1\n}\n\nget_sleep_duration() {\n  local output=\"$1\"\n\n  local json_reset=$(echo \"$output\" | grep -oE '\"resetsAt\"\\s*:\\s*\"[^\"]+\"' | head -1 | sed 's/.*\"\\([^\"]*\\)\"$/\\1/')\n  if [[ -n \"$json_reset\" ]]; then\n    local reset_epoch=$(date -jf \"%Y-%m-%dT%H:%M:%S%z\" \"$json_reset\" +%s 2>/dev/null || \\\n                        date -d \"$json_reset\" +%s 2>/dev/null)\n    if [[ -n \"$reset_epoch\" ]]; then\n      local now=$(date +%s)\n      local diff=$((reset_epoch - now))\n      if [[ $diff -gt 0 ]]; then\n        echo $((diff + 60))\n        return\n      fi\n    fi\n  fi\n\n  if [[ \"$output\" =~ retry.after[[:space:]]*:?[[:space:]]*([0-9]+) ]]; then\n    echo \"${BASH_REMATCH[1]}\"\n    return\n  fi\n\n  if [[ \"$output\" =~ \"try again in \"([0-9]+)\" minute\" ]]; then\n    echo $(( ${BASH_REMATCH[1]} * 60 + 60 ))\n    return\n  fi\n\n  if [[ \"$output\" =~ \"try again in \"([0-9]+)\" hour\" ]]; then\n    echo $(( ${BASH_REMATCH[1]} * 3600 + 60 ))\n    return\n  fi\n\n  if [[ \"$output\" =~ (daily|day|24.?hour) ]]; then\n    seconds_until_daily_reset\n    return\n  fi\n\n  if [[ \"$output\" =~ resets[[:space:]]+([0-9]+)(am|pm) ]]; then\n    local reset_hour=\"${BASH_REMATCH[1]}\"\n    local ampm=\"${BASH_REMATCH[2]}\"\n    local tz=\"UTC\"\n    if [[ \"$output\" =~ \\(([A-Za-z_/]+)\\) ]]; then\n      tz=\"${BASH_REMATCH[1]}\"\n    fi\n    \n    if [[ \"$ampm\" == \"pm\" && \"$reset_hour\" -ne 12 ]]; then\n      reset_hour=$((reset_hour + 12))\n    elif [[ \"$ampm\" == \"am\" && \"$reset_hour\" -eq 12 ]]; then\n      reset_hour=0\n    fi\n    \n    local now=$(date +%s)\n    local target=$(TZ=\"$tz\" date -v${reset_hour}H -v0M -v0S +%s 2>/dev/null || TZ=\"$tz\" date -d \"today ${reset_hour}:00:00\" +%s)\n    \n    if [[ $now -ge $target ]]; then\n      target=$((target + 86400))\n    fi\n    \n    echo $((target - now + 60))\n    return\n  fi\n\n  # Default: wait until next hour\n  local wait_time=$(seconds_until_next_hour)\n  [[ $wait_time -lt 300 ]] && wait_time=300\n  echo $wait_time\n}\n\nhandle_recoverable_error() {\n  local output=\"$1\"\n  local sleep_duration=$(get_sleep_duration \"$output\")\n\n  echo \"\"\n  echo -e \"${YELLOW}=== Recoverable Error Detected ===${NC}\"\n  echo -e \"${YELLOW}Waiting before retry...${NC}\"\n  echo \"\"\n\n  local tz=\"UTC\"\n  if [[ \"$output\" =~ \\(([A-Za-z_/]+)\\) ]]; then\n    tz=\"${BASH_REMATCH[1]}\"\n  fi\n  local resume_time=$(TZ=\"$tz\" date -v+${sleep_duration}S \"+%Y-%m-%d %H:%M:%S\" 2>/dev/null || TZ=\"$tz\" date -d \"+${sleep_duration} seconds\" \"+%Y-%m-%d %H:%M:%S\")\n  echo -e \"Expected resume: ${CYAN}${resume_time}${NC}\"\n  echo \"\"\n\n  countdown $sleep_duration \"Waiting...\"\n\n  echo \"\"\n  echo -e \"${GREEN}Resuming...${NC}\"\n  echo \"\"\n\n  CONSECUTIVE_FAILURES=0\n}\n\nif [[ \"$AUTO_MODE\" == true ]]; then\n  echo -e \"${GREEN}Ralph loop: AUTO mode (plan → build)${NC}\"\n  [[ $MAX_ITERATIONS -gt 0 ]] && echo \"Max build iterations: $MAX_ITERATIONS\"\nelse\n  echo -e \"${GREEN}Ralph loop: $(echo \"$MODE\" | tr '[:lower:]' '[:upper:]') mode${NC}\"\n  [[ $MAX_ITERATIONS -gt 0 ]] && echo \"Max iterations: $MAX_ITERATIONS\"\nfi\necho \"Press Ctrl+C to stop\"\necho \"---\"\n\nwhile true; do\n  ITERATION=$((ITERATION + 1))\n  echo \"\"\n  MODE_DISPLAY=$(echo \"$MODE\" | tr '[:lower:]' '[:upper:]')\n  if [[ \"$AUTO_MODE\" == true ]]; then\n    echo -e \"${GREEN}=== ${MODE_DISPLAY} Iteration $ITERATION ===${NC}\"\n  else\n    echo -e \"${GREEN}=== Iteration $ITERATION ===${NC}\"\n  fi\n  echo \"\"\n\n  TEMP_OUTPUT=$(mktemp)\n  PARENT_THREAD=$(cat \"$PARENT_THREAD_FILE\" 2>/dev/null || true)\n  set +e\n\n  if [[ -n \"$PARENT_THREAD\" ]]; then\n    echo -e \"${CYAN}Creating handoff from parent ${PARENT_THREAD}...${NC}\"\n    \n    cat \"$PROMPT_FILE\" | amp threads handoff \"$PARENT_THREAD\" \\\n      --goal \"$(cat \"$PROMPT_FILE\")\" \\\n      -x \\\n      --dangerously-allow-all \\\n      --stream-json > \"$TEMP_OUTPUT\" 2>&1\n  else\n    amp -x --dangerously-allow-all --stream-json < \"$PROMPT_FILE\" > \"$TEMP_OUTPUT\" 2>&1\n  fi\n\n  THREAD_ID=$(jq -r 'select(.type == \"system\") | .session_id' \"$TEMP_OUTPUT\" 2>/dev/null | head -1)\n\n  cat \"$TEMP_OUTPUT\" | jq -r '\n      def tool_info:\n        if .name == \"edit_file\" or .name == \"create_file\" or .name == \"Read\" then\n          (.input.path | split(\"/\") | last | .[0:60])\n        elif .name == \"todo_write\" then\n          ((.input.todos // []) | map(.content) | join(\", \") | if contains(\"\\n\") then .[0:60] else . end)\n        elif .name == \"Bash\" then\n          (.input.cmd | if contains(\"\\n\") then split(\"\\n\") | first | .[0:50] else .[0:80] end)\n        elif .name == \"Grep\" then\n          (.input.pattern | .[0:40])\n        elif .name == \"glob\" then\n          (.input.filePattern | .[0:40])\n        elif .name == \"finder\" then\n          (.input.query | if contains(\"\\n\") then .[0:40] else . end)\n        elif .name == \"oracle\" then\n          (.input.task | if contains(\"\\n\") then .[0:40] else .[0:80] end)\n        elif .name == \"Task\" then\n          (.input.description // .input.prompt | if contains(\"\\n\") then .[0:40] else .[0:80] end)\n        else null end;\n      if .type == \"assistant\" then\n        .message.content[] |\n        if .type == \"text\" then\n          if (.text | split(\"\\n\") | length) <= 3 then .text else empty end\n        elif .type == \"tool_use\" then\n          \"    [\" + .name + \"]\" + (tool_info | if . then \" \" + . else \"\" end)\n        else empty end\n      elif .type == \"result\" then\n        \"--- \" + ((.duration_ms / 1000 * 10 | floor / 10) | tostring) + \"s, \" + (.num_turns | tostring) + \" turns ---\"\n      else empty end\n    ' 2>/dev/null\n\n  EXIT_CODE=$?\n  OUTPUT=$(cat \"$TEMP_OUTPUT\")\n  RESULT_MSG=$(jq -r 'select(.type == \"result\") | .result // empty' \"$TEMP_OUTPUT\" 2>/dev/null | tail -1)\n  rm -f \"$TEMP_OUTPUT\"\n  set -e\n\n  if [[ -n \"$THREAD_ID\" ]]; then\n    if [[ -z \"$PARENT_THREAD\" ]]; then\n      echo \"$THREAD_ID\" > \"$PARENT_THREAD_FILE\"\n      amp threads rename \"$THREAD_ID\" \"ralph: ${FEATURE_NAME} ${MODE} (parent)\" 2>/dev/null || true\n      echo -e \"${CYAN}Parent thread: $THREAD_ID${NC}\"\n    else\n      amp threads rename \"$THREAD_ID\" \"ralph: ${FEATURE_NAME} ${MODE} #${ITERATION}\" 2>/dev/null || true\n      echo -e \"${CYAN}Child thread: $THREAD_ID${NC}\"\n    fi\n  fi\n\n  if is_recoverable_error \"$OUTPUT\" \"$EXIT_CODE\"; then\n    handle_recoverable_error \"$OUTPUT\"\n    ITERATION=$((ITERATION - 1))\n    continue\n  fi\n\n  if [[ $EXIT_CODE -ne 0 ]]; then\n    CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))\n    echo \"\"\n    echo -e \"${RED}=== Error (exit code: $EXIT_CODE) ===${NC}\"\n\n    BACKOFF=$((30 * (2 ** (CONSECUTIVE_FAILURES - 1))))\n    [[ $BACKOFF -gt 300 ]] && BACKOFF=300\n\n    echo -e \"${YELLOW}Retrying in ${BACKOFF}s... (consecutive failures: $CONSECUTIVE_FAILURES)${NC}\"\n    countdown $BACKOFF \"Waiting...\"\n    ITERATION=$((ITERATION - 1))\n    continue\n  fi\n\n  CONSECUTIVE_FAILURES=0\n\n  if [[ \"$RESULT_MSG\" =~ \"RALPH_COMPLETE\" ]] || [[ \"$OUTPUT\" =~ \"RALPH_COMPLETE\" ]]; then\n    echo \"\"\n    echo -e \"${GREEN}=== Ralph Complete ===${NC}\"\n\n    if [[ \"$AUTO_MODE\" == true && \"$MODE\" == \"plan\" ]]; then\n      # Reset parent thread for build phase\n      rm -f \"$PARENT_THREAD_FILE\"\n      switch_to_build_mode\n      continue\n    fi\n\n    echo -e \"${GREEN}All tasks finished.${NC}\"\n    break\n  fi\n\n  if [[ $MAX_ITERATIONS -gt 0 && $ITERATION -ge $MAX_ITERATIONS ]]; then\n    if [[ \"$AUTO_MODE\" == true && \"$MODE\" == \"plan\" ]]; then\n      rm -f \"$PARENT_THREAD_FILE\"\n      switch_to_build_mode\n      continue\n    fi\n    echo \"\"\n    echo -e \"${GREEN}Reached max iterations ($MAX_ITERATIONS).${NC}\"\n    break\n  fi\n\n  sleep 2\ndone\n\necho \"\"\necho -e \"${GREEN}Ralph loop complete. Iterations: $ITERATION${NC}\"\n```\n\nMake the script executable:\n```bash\nchmod +x loop.sh\n```\n\n---\n\n## End: Next Steps\n\nAfter generating all files, tell the user:\n\n> **Files generated:**\n> - `specs/<feature-slug>.md` - Requirements specification\n> - `IMPLEMENTATION_PLAN.md` - Task list with checkboxes\n> - `PROMPT_plan.md` - Planning mode instructions\n> - `PROMPT_build.md` - Build mode instructions\n> - `loop.sh` - Dual-mode build loop script\n>\n> **Usage:**\n> - `./loop.sh` - Auto mode: plan first, then build\n> - `./loop.sh plan` - Planning mode only\n> - `./loop.sh build` - Build mode only\n> - `./loop.sh build 10` - Build mode, max 10 iterations\n>\n> **Thread organization:**\n> - Each phase creates its own parent thread\n> - Child threads named: `ralph: <feature-name> <mode> #N`\n> - View thread hierarchy at https://ampcode.com/threads\n>\n> **Next step:** Run `./loop.sh` to start the loop.\n",
        "skills/ralph-claude/SKILL.md": "---\nname: ralph-claude\ndescription: Interactive planning skill for Claude Code. Generates specs, implementation plans, and loop infrastructure through clarifying questions.\nallowed-tools:\n  - \"*\"\n---\n\n# Ralph Planning Skill (Claude)\n\nGenerate specs, implementation plans, and loop infrastructure for iterative AI-driven development.\n\n## Entry\n\n**Usage:** `/skill ralph-claude [optional/path/to/plan.md]`\n\n- If path provided: Read that `.md` file as the source specification\n- If no path: Use the current conversation context\n\n---\n\n## Step 1: Interview the User\n\nUse the `AskUserQuestion` tool to gather requirements. Present questions with lettered options for quick responses.\n\n**Interview approach:**\n1. Present 3-5 questions covering scope, constraints, and validation\n2. Use A/B/C/D multiple choice format for quick answers\n3. Allow the user to respond with shorthand like \"1A, 2C, 3B\"\n4. Ask follow-up questions if answers are unclear\n\n**Example questions to ask:**\n\n1. **Scope** - How broad is this change?\n   - A) Single file/module\n   - B) Multiple related files\n   - C) Cross-cutting (many parts of codebase)\n   - D) Greenfield (new feature from scratch)\n\n2. **Risk tolerance** - How aggressive should changes be?\n   - A) Conservative - minimal changes\n   - B) Balanced - reasonable refactoring OK\n   - C) Aggressive - significant refactoring acceptable\n\n3. **Validation** - How should we verify the implementation?\n   - A) Existing test suite\n   - B) Add new tests\n   - C) Manual testing sufficient\n\n**WAIT for user response before proceeding.**\n\n---\n\n## Step 2: Discover Project Context\n\nRead these files to understand the project:\n- `AGENTS.md` or `CLAUDE.md` - project rules and commands\n- `package.json`, `Cargo.toml`, `go.mod`, or equivalent - build system\n- Existing `specs/` if any - current state\n\nExtract:\n- **Validation command** (e.g., `npm test`, `cargo test`, `go test ./...`)\n- **Code patterns** to follow\n- **Path conventions**\n\n---\n\n## Step 3: Generate Files\n\n**Always overwrite existing files** — never add suffixes like `-v2`, `-new`, or `_backup`. These files are ephemeral and meant to be regenerated. Use the exact filenames specified below.\n\n### 1. `specs/<feature-slug>.md`\n\nTechnical specification:\n- **Overview**: What the feature does (1-2 sentences)\n- **Requirements**: Numbered list of functional requirements (R1, R2, R3...)\n- **Constraints**: Technical limitations, performance targets, compatibility requirements\n- **Edge cases**: Error conditions and expected behavior\n- **Out of scope**: Explicitly excluded functionality\n\n### 2. `IMPLEMENTATION_PLAN.md`\n\nFormat:\n```markdown\n# Implementation Plan: <Feature Name>\n\n> **Scope**: <scope choice> | **Risk**: <risk choice> | **Constraints**: <constraint choice>\n\n## Summary\n\n<2-3 sentence overview of the implementation approach>\n\n## Tasks\n\n- [ ] Task 1: Description with enough context for implementation\n- [ ] Task 2: Description with enough context for implementation\n- [ ] Task 3: Description with enough context for implementation\n...\n```\n\nTasks should be:\n- Ordered by priority/dependency\n- Small enough for single iteration\n- Include file paths when known\n- Self-contained with sufficient context\n\n### 3. `PROMPT_plan.md`\n\nGenerate with this content (replace `[DIRECTORIES]` with relevant source directories):\n\n```markdown\n# Planning Mode\n\nYou are in PLANNING mode. Analyze specifications against existing code and generate a prioritized implementation plan.\n\n## Phase 0: Orient\n\n### 0a. Study specifications\nRead all files in `specs/` directory using parallel subagents.\n\n### 0b. Study existing implementation\nUse parallel subagents to analyze relevant source directories:\n[DIRECTORIES]\n\n### 0c. Study the current plan\nRead `IMPLEMENTATION_PLAN.md` if it exists.\n\n## Phase 1: Gap Analysis\n\nCompare specs against implementation:\n- What's already implemented?\n- What's missing?\n- What's partially done?\n\n**CRITICAL**: Don't assume something isn't implemented. Search the codebase first.\n\n## Phase 2: Generate Plan\n\nUpdate `IMPLEMENTATION_PLAN.md` with:\n- Tasks sorted by priority (P0 → P1 → P2)\n- Clear descriptions with file locations\n- Dependencies noted where relevant\n- Discoveries from gap analysis\n\n**CRITICAL: ALL tasks MUST use checkbox format:**\n- `- [ ] **Task Name**` for pending tasks\n- `- [x] **Task Name**` for completed tasks\n\nDo NOT use other formats like `#### P1.1: Task Name` or `**Task Name**` without checkboxes. The build loop relies on `grep -c \"^\\- \\[ \\]\"` to count remaining tasks.\n\nCapture the WHY, not just the WHAT.\n\n## Guardrails\n\n999. NEVER implement code in planning mode\n1000. Use up to 10 parallel subagents for analysis\n1001. Each task must be completable in ONE loop iteration\n1002. **ALWAYS use checkbox format `- [ ]` or `- [x]` for tasks in IMPLEMENTATION_PLAN.md** - The build loop relies on `grep -c \"^\\- \\[ \\]\"` to count remaining tasks. Never use `####` headers or bold text without checkboxes.\n```\n\n### 4. `PROMPT_build.md`\n\nGenerate with this content (replace `[VALIDATION_COMMAND]` with actual command):\n\n```markdown\n# Build Mode\n\nImplement ONE task from the plan, validate, commit, exit.\n\n## Phase 0: Orient\n\nStudy with subagents:\n- @AGENTS.md or @CLAUDE.md (how to build/test)\n- @specs/* (requirements)\n- @IMPLEMENTATION_PLAN.md (current state)\n\n### Check for completion\n\n```bash\ngrep -c \"^\\- \\[ \\]\" IMPLEMENTATION_PLAN.md || echo 0\n```\n\n- If 0: Run validation → commit → output **RALPH_COMPLETE** → exit\n- If > 0: Continue to Phase 1\n\n## Phase 1: Implement\n\n1. **Study the plan** — Choose the most important task from @IMPLEMENTATION_PLAN.md\n2. **Search first** — Don't assume not implemented. Verify behavior doesn't already exist\n3. **Implement** — ONE task only. Implement completely — no placeholders or stubs\n4. **Validate** — Run `[VALIDATION_COMMAND]`, must pass before continuing\n\nIf stuck, use extended thinking to debug. Add extra logging if needed.\n\n## Phase 2: Update & Learn\n\n**Update IMPLEMENTATION_PLAN.md:**\n- Mark task `- [x] Completed`\n- Add discovered bugs or issues (even if unrelated to current task)\n- Note any new tasks discovered\n- Periodically clean out completed items when file gets large\n\n**Update AGENTS.md** (if you learned something new):\n- Add correct commands discovered through trial and error\n- Keep it brief and operational only — no status updates or progress notes\n\n## Phase 3: Commit & Exit\n\n```bash\ngit add -A && git commit -m \"feat([scope]): [description]\"\n```\n\nCheck remaining:\n```bash\ngrep -c \"^\\- \\[ \\]\" IMPLEMENTATION_PLAN.md || echo 0\n```\n\n- If > 0: Say \"X tasks remaining\" and EXIT\n- If = 0: Output **RALPH_COMPLETE**\n\n## Guardrails\n\n99999. When authoring documentation, capture the why — tests and implementation importance.\n999999. Single sources of truth, no migrations/adapters. If tests unrelated to your work fail, resolve them as part of the increment.\n9999999. Implement functionality completely. Placeholders and stubs waste time redoing the same work.\n99999999. Keep @IMPLEMENTATION_PLAN.md current with learnings — future iterations depend on this to avoid duplicating efforts.\n999999999. Keep @AGENTS.md operational only — status updates and progress notes pollute every future loop's context.\n9999999999. For any bugs you notice, resolve them or document them in @IMPLEMENTATION_PLAN.md even if unrelated to current work.\n99999999999. ONE task per iteration. Search before implementing. Validation MUST pass. Never output RALPH_COMPLETE if tasks remain.\n```\n\n### 5. `loop.sh`\n\nGenerate the dual-mode build loop script:\n\n```bash\n#!/bin/bash\n\n# Ralph Wiggum Build Loop (Claude)\n# Usage:\n#   ./loop.sh           # Auto mode: plan first, then build (default)\n#   ./loop.sh plan      # Planning mode only\n#   ./loop.sh build     # Build mode only\n#   ./loop.sh 10        # Auto mode, max 10 build iterations\n#   ./loop.sh build 5   # Build mode, max 5 iterations\n\nset -e\n\nMODE=\"plan\"\nAUTO_MODE=true\nPLAN_MAX_ITERATIONS=5\nMAX_ITERATIONS=0\nITERATION=0\nCONSECUTIVE_FAILURES=0\n\n# Colors\nRED='\\033[0;31m'\nYELLOW='\\033[1;33m'\nGREEN='\\033[0;32m'\nCYAN='\\033[0;36m'\nNC='\\033[0m'\n\nfor arg in \"$@\"; do\n  if [[ \"$arg\" == \"plan\" ]]; then\n    MODE=\"plan\"\n    AUTO_MODE=false\n  elif [[ \"$arg\" == \"build\" ]]; then\n    MODE=\"build\"\n    AUTO_MODE=false\n  elif [[ \"$arg\" =~ ^[0-9]+$ ]]; then\n    MAX_ITERATIONS=$arg\n  fi\ndone\n\nPROMPT_FILE=\"PROMPT_${MODE}.md\"\n\nif [[ ! -f \"$PROMPT_FILE\" ]]; then\n  echo -e \"${RED}Error: $PROMPT_FILE not found${NC}\"\n  echo \"Run the ralph-claude skill first to generate the required files.\"\n  exit 1\nfi\n\nswitch_to_build_mode() {\n  echo \"\"\n  echo -e \"${CYAN}=== Switching to Build Mode ===${NC}\"\n  echo \"\"\n  MODE=\"build\"\n  PROMPT_FILE=\"PROMPT_${MODE}.md\"\n  ITERATION=0\n}\n\nseconds_until_next_hour() {\n  local now=$(date +%s)\n  local current_minute=$(date +%M)\n  local current_second=$(date +%S)\n  local seconds_past_hour=$((10#$current_minute * 60 + 10#$current_second))\n  local seconds_until=$((3600 - seconds_past_hour))\n  echo $seconds_until\n}\n\nseconds_until_daily_reset() {\n  local reset_hour=5\n  local now=$(date +%s)\n  local today_reset=$(date -v${reset_hour}H -v0M -v0S +%s 2>/dev/null || date -d \"today ${reset_hour}:00:00\" +%s)\n\n  if [[ $now -ge $today_reset ]]; then\n    local tomorrow_reset=$((today_reset + 86400))\n    echo $((tomorrow_reset - now))\n  else\n    echo $((today_reset - now))\n  fi\n}\n\ncountdown() {\n  local seconds=$1\n  local message=$2\n\n  while [[ $seconds -gt 0 ]]; do\n    local hours=$((seconds / 3600))\n    local minutes=$(((seconds % 3600) / 60))\n    local secs=$((seconds % 60))\n    printf \"\\r${CYAN}%s${NC} Time remaining: %02d:%02d:%02d \" \"$message\" $hours $minutes $secs\n    sleep 1\n    ((seconds--))\n  done\n  printf \"\\r%-80s\\r\" \" \"\n}\n\nis_usage_limit_error() {\n  local output=\"$1\"\n  local exit_code=\"$2\"\n\n  # Only check for usage limits if there was an error\n  [[ \"$exit_code\" -eq 0 ]] && return 1\n\n  # Check the result JSON for error subtypes first (most reliable)\n  if echo \"$output\" | grep '^{' | jq -e 'select(.type == \"result\") | select(.subtype | test(\"error.*limit|rate_limit\"))' &>/dev/null; then\n    return 0\n  fi\n\n  # Fallback to text patterns in stderr/error messages (not in assistant text)\n  local error_text\n  error_text=$(echo \"$output\" | grep -v '^{' || true)\n  error_text+=$(echo \"$output\" | grep '^{' | jq -r 'select(.type == \"result\" and .is_error == true) | .result // empty' 2>/dev/null || true)\n\n  if [[ \"$error_text\" =~ \"You've hit your limit\" ]] || [[ \"$error_text\" =~ \"You have hit your limit\" ]]; then\n    return 0\n  fi\n  if [[ \"$error_text\" =~ Error:\\ 429 ]] || [[ \"$error_text\" =~ Error:\\ 529 ]]; then\n    return 0\n  fi\n  if [[ \"$error_text\" =~ rate.?limit ]] || [[ \"$error_text\" =~ usage.?limit ]]; then\n    return 0\n  fi\n  return 1\n}\n\nget_sleep_duration() {\n  local output=\"$1\"\n\n  if [[ \"$output\" =~ \"try again in \"([0-9]+)\" minute\" ]]; then\n    echo $(( ${BASH_REMATCH[1]} * 60 + 60 ))\n    return\n  fi\n\n  if [[ \"$output\" =~ \"try again in \"([0-9]+)\" hour\" ]]; then\n    echo $(( ${BASH_REMATCH[1]} * 3600 + 60 ))\n    return\n  fi\n\n  if [[ \"$output\" =~ (daily|day|24.?hour) ]]; then\n    seconds_until_daily_reset\n    return\n  fi\n\n  if [[ \"$output\" =~ resets[[:space:]]+([0-9]+)(am|pm) ]]; then\n    local reset_hour=\"${BASH_REMATCH[1]}\"\n    local ampm=\"${BASH_REMATCH[2]}\"\n    local tz=\"UTC\"\n    if [[ \"$output\" =~ \\(([A-Za-z_/]+)\\) ]]; then\n      tz=\"${BASH_REMATCH[1]}\"\n    fi\n\n    if [[ \"$ampm\" == \"pm\" && \"$reset_hour\" -ne 12 ]]; then\n      reset_hour=$((reset_hour + 12))\n    elif [[ \"$ampm\" == \"am\" && \"$reset_hour\" -eq 12 ]]; then\n      reset_hour=0\n    fi\n\n    local now=$(date +%s)\n    local target=$(TZ=\"$tz\" date -v${reset_hour}H -v0M -v0S +%s 2>/dev/null || TZ=\"$tz\" date -d \"today ${reset_hour}:00:00\" +%s)\n\n    if [[ $now -ge $target ]]; then\n      target=$((target + 86400))\n    fi\n\n    echo $((target - now + 60))\n    return\n  fi\n\n  # Default: wait until next hour\n  local wait_time=$(seconds_until_next_hour)\n  [[ $wait_time -lt 300 ]] && wait_time=300\n  echo $wait_time\n}\n\nhandle_usage_limit() {\n  local output=\"$1\"\n  local sleep_duration=$(get_sleep_duration \"$output\")\n\n  echo \"\"\n  echo -e \"${YELLOW}=== Usage Limit Detected ===${NC}\"\n  echo -e \"${YELLOW}Waiting for reset...${NC}\"\n  echo \"\"\n\n  local tz=\"UTC\"\n  if [[ \"$output\" =~ \\(([A-Za-z_/]+)\\) ]]; then\n    tz=\"${BASH_REMATCH[1]}\"\n  fi\n  local resume_time=$(TZ=\"$tz\" date -v+${sleep_duration}S \"+%Y-%m-%d %H:%M:%S\" 2>/dev/null || TZ=\"$tz\" date -d \"+${sleep_duration} seconds\" \"+%Y-%m-%d %H:%M:%S\")\n  echo -e \"Expected resume: ${CYAN}${resume_time}${NC}\"\n  echo \"\"\n\n  countdown $sleep_duration \"Waiting...\"\n\n  echo \"\"\n  echo -e \"${GREEN}Resuming...${NC}\"\n  echo \"\"\n\n  CONSECUTIVE_FAILURES=0\n}\n\nif [[ \"$AUTO_MODE\" == true ]]; then\n  echo -e \"${GREEN}Ralph loop: AUTO mode (plan ×${PLAN_MAX_ITERATIONS} → build)${NC}\"\n  [[ $MAX_ITERATIONS -gt 0 ]] && echo \"Max build iterations: $MAX_ITERATIONS\"\nelse\n  echo -e \"${GREEN}Ralph loop: $(echo \"$MODE\" | tr '[:lower:]' '[:upper:]') mode${NC}\"\n  [[ $MAX_ITERATIONS -gt 0 ]] && echo \"Max iterations: $MAX_ITERATIONS\"\nfi\necho \"Press Ctrl+C to stop\"\necho \"---\"\n\nwhile true; do\n  ITERATION=$((ITERATION + 1))\n  echo \"\"\n  MODE_DISPLAY=$(echo \"$MODE\" | tr '[:lower:]' '[:upper:]')\n  if [[ \"$AUTO_MODE\" == true ]]; then\n    echo -e \"${GREEN}=== ${MODE_DISPLAY} Iteration $ITERATION ===${NC}\"\n  else\n    echo -e \"${GREEN}=== Iteration $ITERATION ===${NC}\"\n  fi\n  echo \"\"\n\n  TEMP_OUTPUT=$(mktemp)\n  set +e\n\n  claude --print \\\n    --verbose \\\n    --output-format stream-json \\\n    --dangerously-skip-permissions \\\n    < \"$PROMPT_FILE\" 2>&1 | tee \"$TEMP_OUTPUT\" | sed 's/\\x1b\\[[0-9;]*m//g' | grep --line-buffered '^{' | jq --unbuffered -r '\n      def tool_info:\n        if .name == \"Edit\" or .name == \"Write\" or .name == \"Read\" then\n          (.input.file_path // .input.path | split(\"/\") | last | .[0:60])\n        elif .name == \"TodoWrite\" then\n          ((.input.todos // []) | map(.content) | join(\", \") | if contains(\"\\n\") then .[0:60] else . end)\n        elif .name == \"Bash\" then\n          (.input.command // .input.cmd | if contains(\"\\n\") then split(\"\\n\") | first | .[0:50] else .[0:80] end)\n        elif .name == \"Grep\" then\n          (.input.pattern | .[0:40])\n        elif .name == \"Glob\" then\n          (.input.pattern // .input.filePattern | .[0:40])\n        elif .name == \"WebFetch\" then\n          (.input.url | .[0:60])\n        elif .name == \"Task\" then\n          (.input.description // .input.prompt | if contains(\"\\n\") then .[0:40] else .[0:80] end)\n        else null end;\n      if .type == \"assistant\" then\n        .message.content[] |\n        if .type == \"text\" then\n          if (.text | split(\"\\n\") | length) <= 3 then .text else empty end\n        elif .type == \"tool_use\" then\n          \"    [\" + .name + \"]\" + (tool_info | if . then \" \" + . else \"\" end)\n        else empty end\n      elif .type == \"result\" then\n        \"--- \" + ((.duration_ms / 1000 * 10 | floor / 10) | tostring) + \"s, \" + (.num_turns | tostring) + \" turns ---\"\n      else empty end\n    ' 2>/dev/null\n\n  EXIT_CODE=${PIPESTATUS[0]}\n  OUTPUT=$(cat \"$TEMP_OUTPUT\")\n  RESULT_MSG=$(sed 's/\\x1b\\[[0-9;]*m//g' \"$TEMP_OUTPUT\" | grep '^{' | jq -r 'select(.type == \"result\") | .result // empty' 2>/dev/null | tail -1)\n  rm -f \"$TEMP_OUTPUT\"\n  set -e\n\n  if is_usage_limit_error \"$OUTPUT\" \"$EXIT_CODE\"; then\n    handle_usage_limit \"$OUTPUT\"\n    ITERATION=$((ITERATION - 1))\n    continue\n  fi\n\n  if [[ $EXIT_CODE -ne 0 ]]; then\n    CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))\n    echo \"\"\n    echo -e \"${RED}=== Error (exit code: $EXIT_CODE) ===${NC}\"\n    echo -e \"${RED}Output:${NC}\"\n    echo \"$OUTPUT\" | tail -20\n    echo \"\"\n\n    BACKOFF=$((30 * (2 ** (CONSECUTIVE_FAILURES - 1))))\n    [[ $BACKOFF -gt 300 ]] && BACKOFF=300\n\n    echo -e \"${YELLOW}Retrying in ${BACKOFF}s... (consecutive failures: $CONSECUTIVE_FAILURES)${NC}\"\n    countdown $BACKOFF \"Waiting...\"\n    ITERATION=$((ITERATION - 1))\n    continue\n  fi\n\n  CONSECUTIVE_FAILURES=0\n\n  # In auto mode, switch from plan to build after hitting plan cap\n  if [[ \"$AUTO_MODE\" == true && \"$MODE\" == \"plan\" && $ITERATION -ge $PLAN_MAX_ITERATIONS ]]; then\n    switch_to_build_mode\n    continue\n  fi\n\n  if [[ \"$RESULT_MSG\" =~ RALPH_COMPLETE ]]; then\n    echo \"\"\n    echo -e \"${GREEN}=== Ralph Complete ===${NC}\"\n    echo -e \"${GREEN}All tasks finished.${NC}\"\n    break\n  fi\n\n  if [[ $MAX_ITERATIONS -gt 0 && $ITERATION -ge $MAX_ITERATIONS ]]; then\n    echo \"\"\n    echo -e \"${GREEN}Reached max iterations ($MAX_ITERATIONS).${NC}\"\n    break\n  fi\n\n  sleep 2\ndone\n\necho \"\"\necho -e \"${GREEN}Ralph loop complete. Iterations: $ITERATION${NC}\"\n```\n\nMake the script executable:\n```bash\nchmod +x loop.sh\n```\n\n---\n\n## Step 4: Next Steps\n\nAfter generating all files, tell the user:\n\n> **Files generated:**\n> - `specs/<feature-slug>.md` - Requirements specification\n> - `IMPLEMENTATION_PLAN.md` - Task list with checkboxes\n> - `PROMPT_plan.md` - Planning mode instructions\n> - `PROMPT_build.md` - Build mode instructions\n> - `loop.sh` - Dual-mode build loop script\n>\n> **Usage:**\n> - `./loop.sh` - Auto mode: plan first, then build\n> - `./loop.sh plan` - Planning mode only\n> - `./loop.sh build` - Build mode only\n> - `./loop.sh build 10` - Build mode, max 10 iterations\n>\n> **Next step:** Run `./loop.sh` to start the loop.\n"
      },
      "plugins": [
        {
          "name": "ralph-wiggum",
          "description": "Generate the complete Ralph Wiggum loop infrastructure for iterative AI-driven development. Supports Claude Code and Amp with agent-specific optimizations.",
          "version": "1.0.6",
          "author": {
            "name": "hmemcpy"
          },
          "source": "./",
          "category": "development",
          "categories": [
            "development"
          ],
          "install_commands": [
            "/plugin marketplace add hmemcpy/ralph-wiggum",
            "/plugin install ralph-wiggum@ralph-wiggum"
          ]
        }
      ]
    }
  ]
}