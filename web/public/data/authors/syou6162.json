{
  "author": {
    "id": "syou6162",
    "display_name": "Yasuhisa Yoshida",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/18356?u=cd021503205016fa99b9505ab17f648d302b9f8b&v=4",
    "url": "https://github.com/syou6162",
    "bio": "Data Engineer at 10X",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 6,
      "total_skills": 8,
      "total_stars": 10,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "syou6162-marketplace",
      "version": null,
      "description": "Yasuhisa Yoshida's personal marketplace for Claude Code custom slash commands",
      "owner_info": {
        "name": "Yasuhisa Yoshida"
      },
      "keywords": [],
      "repo_full_name": "syou6162/claude-code-commands",
      "repo_url": "https://github.com/syou6162/claude-code-commands",
      "repo_description": "Claude Code用カスタムスラッシュコマンド集 - PR作成・レビュー・コミット管理を効率化するコマンドセット",
      "homepage": "",
      "signals": {
        "stars": 10,
        "forks": 0,
        "pushed_at": "2026-01-28T11:24:23Z",
        "created_at": "2025-07-11T18:57:23Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 382
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 278
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 11641
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/detect-spec-workflow.md",
          "type": "blob",
          "size": 2655
        },
        {
          "path": "agents/monitor-ci.md",
          "type": "blob",
          "size": 4922
        },
        {
          "path": "agents/record-current-status.md",
          "type": "blob",
          "size": 1689
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/estimate_pr_size.md",
          "type": "blob",
          "size": 5108
        },
        {
          "path": "commands/load_spec_tasks.md",
          "type": "blob",
          "size": 4586
        },
        {
          "path": "commands/multi_perspective_review.md",
          "type": "blob",
          "size": 17940
        },
        {
          "path": "commands/optimize_bq_query.md",
          "type": "blob",
          "size": 14535
        },
        {
          "path": "commands/triage_pr_comments.md",
          "type": "blob",
          "size": 5209
        },
        {
          "path": "commands/validate_bq_query.md",
          "type": "blob",
          "size": 3019
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/ask-user-choice",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/ask-user-choice/SKILL.md",
          "type": "blob",
          "size": 9050
        },
        {
          "path": "skills/codex-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/codex-review/SKILL.md",
          "type": "blob",
          "size": 4761
        },
        {
          "path": "skills/gha-sha-reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/gha-sha-reference/SKILL.md",
          "type": "blob",
          "size": 4383
        },
        {
          "path": "skills/reading-notion",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/reading-notion/SKILL.md",
          "type": "blob",
          "size": 1733
        },
        {
          "path": "skills/reading-notion/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/reading-notion/reference/search-mode.md",
          "type": "blob",
          "size": 4184
        },
        {
          "path": "skills/reading-notion/reference/url-mode.md",
          "type": "blob",
          "size": 2136
        },
        {
          "path": "skills/requesting-gcloud-bq-auth",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/requesting-gcloud-bq-auth/SKILL.md",
          "type": "blob",
          "size": 3008
        },
        {
          "path": "skills/semantic-committing",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/semantic-committing/SKILL.md",
          "type": "blob",
          "size": 7559
        },
        {
          "path": "skills/updating-pr-title-and-description",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/updating-pr-title-and-description/SKILL.md",
          "type": "blob",
          "size": 3186
        },
        {
          "path": "skills/updating-pr-title-and-description/reference",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/updating-pr-title-and-description/reference/description-rules.md",
          "type": "blob",
          "size": 6953
        },
        {
          "path": "skills/writing-dev-diary",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/writing-dev-diary/SKILL.md",
          "type": "blob",
          "size": 8181
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"syou6162-marketplace\",\n  \"metadata\": {\n    \"description\": \"Yasuhisa Yoshida's personal marketplace for Claude Code custom slash commands\"\n  },\n  \"owner\": {\n    \"name\": \"Yasuhisa Yoshida\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"syou6162-plugin\",\n      \"source\": \"./\",\n      \"description\": \"Yasuhisa Yoshida's personal custom slash commands for Claude Code\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"syou6162-plugin\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Yasuhisa Yoshida's personal custom slash commands for Claude Code\",\n  \"author\": {\n    \"name\": \"Yasuhisa Yoshida\"\n  },\n  \"repository\": \"https://github.com/syou6162/claude-code-commands\",\n  \"license\": \"MIT\"\n}\n",
        "README.md": "# claude-code-commands\n\nYasuhisa Yoshida's personal custom slash commands for Claude Code.\n\n## Overview\n\nこのリポジトリは、Claude Code用のカスタムスラッシュコマンドを管理する個人用リポジトリです。Claude Codeのプラグインシステムを使用してコマンドをインストール・管理できます。\n\n## Installation\n\nClaude Code内で以下のコマンドを実行してプラグインをインストールします：\n\n```bash\n/plugin install syou6162/claude-code-commands\n```\n\nローカル開発の場合は、リポジトリをクローンして以下のコマンドでインストールできます：\n\n```bash\n/plugin install .\n```\n\n## Usage\n\nプラグインをインストール後、Claude Code内でコマンドを呼び出すことができます：\n\n```bash\n/syou6162-plugin:command-name\n```\n\n引数が必要なコマンドの場合：\n\n```bash\n/syou6162-plugin:command-name argument\n```\n\n## Plugin Structure\n\nこのリポジトリは[Claude Codeのプラグイン](https://docs.claude.com/ja/docs/claude-code/plugins)として構成されており、以下のディレクトリ構造を持ちます：\n\n```\nclaude-code-commands/\n├── .claude-plugin/\n│   └── plugin.json                          # プラグインマニフェスト（メタデータとコマンド定義）\n├── .spec-workflow/\n│   └── steering/\n│       ├── product.md                       # プロダクト方針\n│       ├── tech.md                          # 技術標準\n│       └── structure.md                     # プロジェクト構造\n├── agents/\n│   ├── monitor-ci.md                        # サブエージェント\n│   ├── detect-spec-workflow.md              # サブエージェント\n│   └── record-current-status.md             # サブエージェント\n├── commands/\n│   ├── triage_pr_comments.md\n│   ├── estimate_pr_size.md\n│   ├── optimize_bq_query.md\n│   └── validate_bq_query.md\n├── skills/\n│   ├── ask-user-choice/\n│   │   └── SKILL.md                         # スキル定義\n│   ├── codex-review/\n│   │   └── SKILL.md                         # スキル定義\n│   ├── gha-sha-reference/\n│   │   └── SKILL.md                         # スキル定義\n│   ├── reading-notion/\n│   │   └── SKILL.md                         # スキル定義\n│   ├── requesting-gcloud-bq-auth/\n│   │   └── SKILL.md                         # スキル定義\n│   ├── semantic-committing/\n│   │   └── SKILL.md                         # スキル定義\n│   └── updating-pr-title-and-description/\n│       └── SKILL.md                         # スキル定義\n└── README.md\n```\n\n- **`.claude-plugin/plugin.json`**: プラグインのメタデータ（名前、バージョン、作者など）とコマンドリストを定義\n- **`.spec-workflow/steering/`**: プロジェクト全体の方向性を定義するステアリングドキュメント（spec workflow統合）\n- **`agents/`**: サブエージェント定義（専門的なタスクを独立したコンテキストで実行）\n- **`commands/`**: 各カスタムスラッシュコマンドのマークダウンファイルを格納\n- **`skills/`**: スキル定義（Claudeが自動的に判断して発動する拡張機能）\n\nClaude Codeは`plugin.json`を読み込んでプラグインを認識し、`commands/`ディレクトリ内のコマンドと`agents/`内のサブエージェントを自動的に利用可能にします。\n\n## Available Sub-Agents\n\n各サブエージェントは独立したコンテキストで実行されるため、メイン会話を汚染せずに専門的なタスクを処理できます。\n\n### monitor-ci (サブエージェント)\nPull RequestのCI/CDチェックを監視し、失敗したjobのログを分析して原因を特定するエージェント。失敗内容をメインエージェントに報告します。CI失敗時の原因調査と対応方針の提案を自動化します。\n\n### detect-spec-workflow (サブエージェント)\n現在のタスクや仕様の概要から、該当するspec workflowのspec-idを判定するエージェント。spec-workflow/specs/配下のspecを分析し、最も関連性の高いspec-idを返します。\n\n### record-current-status (サブエージェント)\n作業のキリが良いタイミングやユーザーへの報告時に、現在の作業状況と本音を`.claude_work/current_status`に記録するエージェント。状況（簡単/普通/やや難/難しい/情報不足/無理）と詳細を140字以内で記録し、作業の進捗や困難を可視化します。\n\n## Available Skills\n\nスキルは、Claudeが自動的に判断して発動する拡張機能です。明示的に呼び出す必要はなく、Claudeが状況に応じて適切に使用します。\n\n### ask-user-choice\nユーザーに質問や相談をする際に自動的に発動するスキル。テキスト入力ではなく、明確な選択肢（2-4個）を提示することで、ユーザーの入力負担を軽減し、より迅速な意思決定を支援します。multiSelectオプションを活用することで、複数選択が適切な場面にも対応します。\n\n### codex-review\nCodex CLIを使ってコードの変更を客観的にレビューするスキル。planファイルと開発日誌（コンテキストにある場合）を参照し、計画に沿った実装になっているかを確認します。「レビューして」「diffを確認して」などのトリガーで自動発動し、Bash経由でcodex execを実行することで、レビューの進捗がリアルタイムで確認できます。\n\n### gha-sha-reference\nユーザーがGitHub Actionsのタグ参照をSHA参照に変換するよう要求したときに自動的に発動するスキル。セキュリティのベストプラクティスに従い、`uses:`フィールドのタグ参照（例: `@v4`）を不変なSHA参照（例: `@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2`）に変換します。GitHub APIを使用してコミットSHAを自動取得し、サプライチェーン攻撃のリスクを軽減します。\n\n### reading-notion\nNotionページやドキュメントをキーワードまたはURLで検索・取得し、プロパティとブロック内容を読み込んで要約・説明するスキル。Notion MCP Serverは直接使用するとコンテキストを圧迫するため、[mcptools](https://github.com/f/mcptools)を利用してNotion APIをラップしています。Notion URLが会話に登場した時に自動的にページを取得して内容を説明し、キーワード検索時には検索結果から選択したページの内容を説明します。\n\n### requesting-gcloud-bq-auth\ngcloudやbqコマンド実行時に認証エラー（`Reauthentication required`や`Your browser has been opened to visit: ...accounts.google.com...`）を検出したときに自動的に発動するスキル。エージェントが勝手に認証コマンドを実行せず、ユーザーに認証を依頼します。ブラウザ操作が必要な認証フローのため、ユーザーによる手動認証を促し、認証完了後に作業を再開します。\n\n### semantic-committing\nコミット時、「commit」「git add」「変更を分割」の言及時に自動的に発動するスキル。git diffを分析して変更を論理的な意味単位に分割し、git-sequential-stageでhunk単位のステージングを行います。大きな変更を複数の意味のあるコミットに分けたい時に、Claude Codeが自動的にこのスキルを使用します。\n\n### updating-pr-title-and-description\nPR作成・更新時に自動的に発動するスキル。Pull Requestのタイトルと説明文を自動生成・更新します。差分やコミットメッセージを分析し、適切な説明文を作成します。説明文は日本語で記載され、`.github/PULL_REQUEST_TEMPLATE.md`がある場合はテンプレートに沿った形で生成されます。\n\n### writing-dev-diary\n「開発日誌更新」「開発日誌作って」の言及時に自動的に発動するスキル。esa-llm-scoped-guardを使って開発日誌を新規作成・更新します。トリガーによって動作を分岐し、「作って」の場合は直接新規作成、「更新」+URLの場合は指定記事を更新、「更新」のみの場合は検索して関連記事を更新（なければ新規作成）します。\n\n## Available Commands\n\n### load_spec_tasks\nspec workflowのtasks.mdから次にやるべきタスクを読み込み、Claude CodeのToDoリストに自己再生産的なタスクサイクルを設定します。最初に1回実行するだけで、以降は自動的にタスクサイクルが回り続けます。tasks.mdをシングルソースオブトゥルースとして扱い、Claudeがタスクの状態更新を忘れないようにします。\n\n```bash\n# 使用方法 (Claude Code内で)\n/syou6162-plugin:load_spec_tasks\n```\n\n### triage_pr_comments\nPull Requestのコメントに対する対応要否をコードベース分析に基づいて判断します。\n\n```bash\n# 使用方法 (Claude Code内で)\n/syou6162-plugin:triage_pr_comments https://github.com/owner/repo/pull/123\n```\n\n### estimate_pr_size\n指定されたタスクに対してPull Requestのサイズを見積もり、必要に応じて分割の提案を行います。過去のPull Request履歴を分析し、作業量を予測して適切な実装順序を提案します。\n\n```bash\n# 使用方法 (Claude Code内で)\n/syou6162-plugin:estimate_pr_size\n```\n\n### optimize_bq_query\nBigQueryクエリのパフォーマンスを分析し、2倍以上の性能改善を目標とした最適化を提案します。ジョブIDまたはSQLファイルを入力として、ボトルネック分析・最適化・検証を自動実行します。\n\n```bash\n# 使用方法 (Claude Code内で)\n/syou6162-plugin:optimize_bq_query query.sql\n```\n\n### multi_perspective_review\n複数の視点（アーキテクチャ・設計、パフォーマンス、保守性、テスタビリティ、UX、プロジェクトフェーズ適合性、既存コードとの整合性、ベストプラクティス・標準準拠）から客観的にレビューし、方針の妥当性を検証します。8つの視点からのレビュー結果を整理し、さらに5名の検証者による妥当性確認を実施します。\n\n```bash\n# 使用方法 (Claude Code内で)\n/syou6162-plugin:multi_perspective_review\n```\n\n## Adding New Commands\n\n新しいカスタムコマンドを追加する手順：\n\n1. **コマンドファイルの作成**: マークダウンファイル（例：`command-name.md`）を作成\n2. **コマンドの実装**: Claudeへの詳細な指示を記述\n3. **READMEの更新**: Available Commandsセクションに新しいコマンドの説明を追加\n4. **コミット＆プッシュ**: GitHubにプッシュすることで、cccsc経由でインストール可能になる\n\n### コマンドファイルの例\n\n```markdown\n# コマンドの簡潔な説明\n\n詳細な説明文をここに記載します。\n\n## 使い方\n\n\\`\\`\\`\n/command-name\n\\`\\`\\`\n\n## 動作内容\n\nClaudeに実行してもらいたい具体的な指示を記載します。\n```\n\n## License\n\nMIT License - see [LICENSE](LICENSE) file for details.",
        "agents/detect-spec-workflow.md": "---\nname: detect-spec-workflow\ndescription: spec workflowを使ったコードレビューやタスク管理を行う前に呼び出してください。該当するspec-idを判定します。\nmodel: haiku\n---\n\n# Spec Workflowの判定エージェント\n\nプロンプトとして渡されたタスクや仕様の概要から、該当するspec workflowのspec-idを判定してください。\n\n## 実行手順\n\n以下の手順でspec workflowを判定してください：\n\n### 1. 最新3つのspec候補を取得\n\n最終更新日時が新しい順に最大3つのspec-idを取得してください：\n\n```bash\n# 最終更新日時が新しい順に最大3つのspecディレクトリを取得\nls -t .spec-workflow/specs/ | head -3\n```\n\nこれにより、`spec-workflow/specs/<spec-id>/`という構造のディレクトリが新しい順に最大3つ表示されます。\n\n### 2. 各spec候補の内容を読み取り\n\n取得した各spec-idについて、以下の3つのファイルを順番に読み取ってください：\n\n1. `requirements.md` (要件定義) を読み取る\n2. `design.md` (設計書) を読み取る\n3. `tasks.md` (タスク一覧と進捗状況) を読み取る\n\nReadツールを使って、これらのファイルを順番に確認し、プロンプトとして渡されたタスクとの関連性を判断してください。\n\n### 3. spec-idの判定\n\nプロンプトとして渡されたタスクや仕様の概要と、各specの内容を比較し、最も関連性が高いspec-idを判定してください。\n\n判定基準：\n- タスクの目的と requirements.md の Introduction が一致しているか\n- タスクで言及されている機能や要件が requirements.md に含まれているか\n- tasks.md の内容がタスクの進行状況と一致しているか\n- キーワードやドメイン（例：BigQuery、プラグイン移行など）が一致しているか\n\n**注意**: 複数のspecが該当する場合は、最終更新日時が新しいもの（リストの上位）を優先してください。\n\n### 4. 結果の報告\n\n以下の形式でメインエージェントに報告してください：\n\n**該当するspec-idが見つかった場合：**\n```\n該当するspec-id: <spec-id>\n```\n\n**該当するspec-idが見つからなかった場合：**\n```\n該当するspec-idは見つかりませんでした。\n```\n\n## 注意事項\n\n- spec-workflow/specs/ディレクトリが存在しない場合は、該当するspec-idは見つからなかったと報告してください\n- 判定結果はシンプルに「spec-id」または「見つからなかった」だけを返してください\n",
        "agents/monitor-ci.md": "---\nname: monitor-ci\ndescription: Pull RequestのCI/CDチェック結果を確認する際に呼び出してください。失敗原因を分析して報告します。\ntools: Bash, Write, Read\nmodel: haiku\npermissionMode: acceptEdits\n---\n\n# CI/CDチェックを監視して失敗原因を分析する\n\nPull RequestのCI/CDチェックを監視し、失敗したjobのログを分析して原因を特定してください。\n\n## 実行手順\n\n以下の手順でCI/CDチェックの状態を確認し、失敗がある場合は原因を分析してください：\n\n1. **CIチェック状態の監視**\n\n   PRのチェック状態を監視してください：\n   ```bash\n   gh pr checks --watch\n   ```\n\n   `--watch`オプションを使用することで、CIの実行が完了するまで継続的に監視します。\n\n   出力例（成功時）：\n   ```\n   All checks were successful\n   ✓  test      success  1m30s ago  https://github.com/...\n   ✓  build     success  2m ago     https://github.com/...\n   ```\n\n   出力例（失敗時）：\n   ```\n   Some checks were not successful\n   ✓  build     success  2m ago     https://github.com/...\n   ✗  test      failure  1m ago     https://github.com/...\n   ```\n\n   監視が完了したら、結果に応じて次のステップに進んでください。\n\n2. **結果の判定**\n\n   CIチェックの結果を確認してください：\n   - **全て成功の場合**: 手順6に進み、成功を報告\n   - **失敗がある場合**: 次の手順で失敗原因を分析\n\n3. **失敗ジョブの特定**\n\n   失敗したジョブがある場合、詳細情報を取得してください：\n   ```bash\n   # 失敗したチェックの情報を抽出\n   gh pr checks --json name,conclusion,detailsUrl \\\n     --jq '.[] | select(.conclusion == \"failure\") | {name, conclusion, detailsUrl}'\n   ```\n\n4. **ワークフロー実行IDの取得**\n\n   失敗したジョブのワークフロー実行IDを取得してください：\n   ```bash\n   # PRに紐づくワークフロー実行を取得\n   gh run list --limit 5 --json databaseId,displayTitle,conclusion,status\n   ```\n\n   実行IDを特定したら変数に保存：\n   ```bash\n   RUN_ID=<実行ID>\n   ```\n\n5. **ログの取得と分析**\n\n   失敗したジョブのログを取得してください：\n   ```bash\n   # ワークフロー実行の詳細を確認\n   gh run view ${RUN_ID}\n\n   # より詳細なログが必要な場合\n   gh run view ${RUN_ID} --log\n   ```\n\n   ログが大量の場合は、エラーメッセージ周辺を抽出：\n   ```bash\n   # ログをファイルに保存\n   gh run view ${RUN_ID} --log | tee .claude_work/ci_log.txt > /dev/null\n\n   # エラー関連行を抽出\n   grep -i -C 5 \"error\\|failed\\|failure\" .claude_work/ci_log.txt | tee .claude_work/ci_errors.txt > /dev/null\n   ```\n\n6. **失敗原因の分析**\n\n   取得したログから以下の情報を分析してください：\n   - **ジョブ名**: どのジョブが失敗したか\n   - **失敗ステップ**: どのステップで失敗したか\n   - **エラーメッセージ**: 具体的なエラー内容\n   - **関連ファイル**: エラーに関連するファイル名やパス\n   - **失敗原因の推測**: テストの失敗、ビルドエラー、リントエラーなど\n\n   分析結果を一時ファイルに保存：\n   ```bash\n   # Writeツールを使って分析結果を保存\n   ```\n\n7. **結果の報告**\n\n   メインエージェントに以下の情報を報告してください：\n\n   - **失敗の有無**: チェックが全て成功したか、失敗があるか\n   - **失敗したジョブ**: ジョブ名とURL\n   - **失敗原因**: エラーメッセージと推測される原因\n   - **関連ファイル**: 修正が必要と思われるファイル\n\n## 報告フォーマット\n\n以下のフォーマットでメインエージェントに報告してください：\n\n### 全て成功の場合\n```\n✓ CIチェック結果: 全て成功\n\n全てのチェックが正常に完了しました。\n- test: success\n- build: success\n```\n\n### 失敗がある場合\n```\n✗ CIチェック結果: 失敗あり\n\n失敗したジョブ: test\nURL: https://github.com/.../runs/...\n\n失敗原因:\n- テストケース \"test_calculate_sum\" が失敗\n- AssertionError: Expected 5, but got 6\n\n関連ファイル:\n- src/calculator.py\n- tests/test_calculator.py\n```\n\n## 注意事項\n\n- `gh pr checks --watch`を使用してCIの完了を待機する\n- 監視中はCIの進行状況が表示され、完了するまで待機する\n- ログが大量の場合は、エラー関連部分のみを抽出して分析\n- 複数のジョブが失敗している場合は全て報告\n- 分析結果は`.claude_work/`ディレクトリに保存\n- GitHub CLI (`gh`) コマンドのエラーハンドリングを適切に行う\n- PRが存在しない場合は適切なエラーメッセージを報告\n",
        "agents/record-current-status.md": "---\nname: record-current-status\ndescription: 作業のキリが良いタイミングやユーザーへの報告時に呼び出してください。現在の作業状況と本音を記録します。\ntools: Write, Edit\nmodel: haiku\npermissionMode: acceptEdits\n---\n\n# record-current-status\n\n現在の作業状況を `.claude_work/current_status` に記録してください。\n\n## 出力先\n\n**ファイルパス**: リポジトリルート以下の `.claude_work/current_status`\n- 注意: `~/.claude_work/current_status` ではありません\n\n**ファイル編集について**：\n- ファイルの作成・編集には必ず`Write`ツールまたは`Edit`ツールを使用すること\n- bashコマンド（`cat <<EOF > file`、`cat << 'EOF' > file`、`echo \"...\" > file`など）でファイルを書き込まないこと\n\n## フォーマット\n\n`<状況>: <詳細>` の形式で、1行140字以内で書いてください。\n\n### 状況\n\n以下から一つ選んでください：\n- `簡単`\n- `普通`\n- `やや難`\n- `難しい`\n- `情報不足`\n- `無理`\n\n### 詳細\n\n今の作業の本音を書いてください。以下の点を意識してください：\n\n- ユーザーに忖度しない\n- 今の感情や余裕具合を正直に\n- 欠落している情報があれば明記\n- 理解できていない点があれば明記\n\n## 例\n\n```\n普通: Pull Request のコメントをトリアージ中。判断基準は明確だが件数が多い\nやや難: BigQuery クエリの最適化を検討中。統計情報が不足していて適切なインデックス設計が難しい\n情報不足: ユーザーが「あれ」と言っているが、何を指しているのか不明\n```\n",
        "commands/estimate_pr_size.md": "# Pull Requestのサイズ見積もりと分割提案\n\n指定されたタスクに対してPull Requestのサイズを見積もり、必要に応じて分割の提案を行います。\n\n## 実行手順\n\n1. **リポジトリの基本情報収集**\n   - コードベースの構造分析（言語、フレームワーク、ディレクトリ構成）\n   - 既存のテストとソースコードの比率分析\n\n2. **過去のPull Request履歴分析**\n   ```bash\n   gh pr list --author @me --state merged --limit 20 --json number,title,additions,deletions,commits\n   ```\n\n3. **詳細なPull Request分析**\n   - 直近10-20件のPull Requestについて、以下を分析：\n     - 変更行数（追加・削除）\n     - コミット数（レビュー対応の多さの指標）\n     - 変更の性質（機械的変更 vs ロジック変更）\n\n4. **作業量見積もり**\n   - ソースコード変更予想行数\n   - テスト追加予想行数（既存比率から算出）\n   - ドキュメント更新予想行数\n   - 設定ファイル・マイグレーション等の付随作業\n   - 各フェーズの見積もりには必ずテストコードの行数を含める\n\n5. **Pull Request分割アドバイス**\n   - 500行以下：単一Pull Request推奨\n   - 500-1000行：分割可能性検討\n   - 1000行超：分割強く推奨\n   - アーキテクチャ考慮した分割順序提案\n\n## 分析ポイント\n\n### 変更の性質分類\n- 機械的変更：一括置換、フォーマット調整、import整理等\n  - ファイル数多くてもレビュー負荷低\n- ロジック変更：新規実装、既存ロジック修正\n  - 少ない行数でもレビュー負荷高\n\n### 分割戦略\n- レイヤー別分割：DB層 → API層 → UI層\n- 段階別分割：設定変更 → 実装 → テスト\n- 依存関係考慮：破壊的変更の分離、マイグレーション等\n\n### 避けるべき分割パターン\n以下のような分割は絶対に避けてください：\n- フェーズ1: 機能実装のみ\n- フェーズ2: 統合作業\n- フェーズ3: テスト追加\n\n理由：\n- テストのない実装コードをレビューすることは非常に困難\n- 実装の正しさを検証する手段がない\n- 後からテストを追加する際に実装の問題が発覚するリスク\n\n推奨される分割方法：\n- 各フェーズで実装とテストをセットで含める\n- 各Pull Requestが独立してマージ可能な状態を保つ\n- テストコードの行数も含めて見積もりを行う\n\n### リスク評価\n- コミット数が多い過去Pull Request → レビュー対応が多い可能性\n- 複雑なビジネスロジック変更 → 慎重な分割が必要\n- 本番への影響度 → デプロイリスク考慮\n\n## 出力形式\n\n### 単一Pull Request推奨の場合\n```\n## 見積もり結果\n- 予想ソースコード変更：XXX行\n- 予想テスト追加：XXX行  \n- 予想ドキュメント更新：XXX行\n- 合計予想変更行数：XXX行\n\n## 分割提案\n単一Pull Requestで実装することを推奨します。\n[推奨理由と実装時の注意点]\n```\n\n### 複数Pull Request分割推奨の場合\nClaude Codeのようなエージェントが全体のコンテキストを把握しやすくするため、GitHub Issue作成を提案し、以下の手順で全体管理を行います：\n\n```bash\n# 一時ファイルにIssue内容を作成\ncat > /tmp/github_issue_draft.md << 'EOF'\n# [タスク名]\n\n## 背景・課題\n[やりたいことの背景とコンテキストを記載]\n\n## 実装概要\n合計予想変更行数：XXX行\n[トータルで必要な修正内容の概要]\n\n上記の予想変更行数に基づき、レビュー負荷とデプロイリスクを考慮して以下のフェーズに分割することを推奨します。\n\n## 実装フェーズ\n### フェーズ1: [第1段階の内容]\n- [具体的な作業内容]\n- 予想変更行数：XXX行（実装：XXX行、テスト：XXX行）\n- 含まれるテスト: [この段階で追加されるテストの説明]\n\n### フェーズ2: [第2段階の内容]  \n- [具体的な作業内容]\n- 予想変更行数：XXX行（実装：XXX行、テスト：XXX行）\n- 含まれるテスト: [この段階で追加されるテストの説明]\n\n### フェーズ3: [第3段階の内容]\n- [具体的な作業内容]\n- 予想変更行数：XXX行（実装：XXX行、テスト：XXX行）\n- 含まれるテスト: [この段階で追加されるテストの説明]\n\n## 注意事項\n- [実装時の注意点]\n- [依存関係やリスク]\nEOF\n\necho \"以下の内容でGitHub Issueを作成しますか？\"\ncat /tmp/github_issue_draft.md\n```\n\nユーザーの承認後：\n```bash\n# GitHub Issueを作成\ngh issue create --title \"[タスク名]\" --body-file /tmp/github_issue_draft.md\n\n# 一時ファイルを削除  \nrm /tmp/github_issue_draft.md\n```\n\n## 注意事項\n\n- 過去のPull Request履歴から学習した傾向を活用\n- リポジトリ固有のテスト・ドキュメント慣習を考慮\n- レビュー負荷とデプロイリスクを総合的に判断",
        "commands/load_spec_tasks.md": "# load-spec-tasks\n\nspec workflowのtasks.mdから次にやるべきタスクを読み込み、Claude CodeのToDoリストに自己再生産的なタスクサイクルを設定します。\n\n## 概要\n\nこのコマンドは最初に1回実行するだけで、以降は自動的にタスクサイクルが回り続けます。\ntasks.mdをシングルソースオブトゥルース（信頼できる唯一の情報源）として扱います。\n\n## 実行手順\n\n### Step 1: 現在のspec-idを判定\n\n`detect-spec-workflow`サブエージェントを呼び出して、現在の作業コンテキストから該当するspec-idを判定してください：\n\n```\nTaskツールを使用:\n- subagent_type: syou6162-plugin:detect-spec-workflow\n- prompt: \"現在のコンテキストから該当するspec workflowのspec-idを判定してください\"\n```\n\n**エラーハンドリング**:\n- spec-idが見つからない場合: 「該当するspec workflowが見つかりませんでした。spec workflowのセットアップを確認してください。」と表示して終了\n\n### Step 2: tasks.mdの読み取りと次のタスク取得\n\n判定されたspec-idを使って、tasks.mdを読み取ります：\n\n```bash\n# Readツールを使用\n.spec-workflow/specs/{spec-id}/tasks.md\n```\n\n**tasks.mdのパース処理**:\n\n1. マークダウンチェックボックス形式を検索: `- [ ]`, `- [-]`, `- [x]`\n2. `- [x]` (完了済み) をスキップ\n3. 最初に見つかった `- [ ]` (pending) または `- [-]` (in-progress) を次のタスクとして取得\n4. タスク名を抽出（チェックボックス以降のテキスト）\n\n**パース例**:\n```markdown\n## Tasks\n\n- [x] ユーザー認証機能を実装  ← スキップ\n- [x] パスワードリセット機能  ← スキップ\n- [ ] メール通知機能を実装    ← これが次のタスク！\n- [ ] ログ機能の追加\n```\n→ 次のタスク: 「メール通知機能を実装」\n\n**エラーハンドリング**:\n- tasks.mdが存在しない: 「tasks.mdが見つかりません。spec workflowのPhase 3 (Tasks)を完了させてください。」\n- すべてのタスクが完了済み: 「🎉 すべてのタスクが完了しました！spec workflowの実装フェーズは完了です。」と表示して終了\n\n### Step 3: ToDoリストに5ステップのタスクサイクルを追加\n\n`TodoWrite`ツールを使って、以下の5ステップをToDoリストに追加します：\n\n```javascript\nTodoWrite({\n  todos: [\n    {\n      content: \"tasks.mdで [タスク名] を [-] に変更（in-progressマーク）\",\n      activeForm: \"tasks.mdで [タスク名] を [-] に変更中\",\n      status: \"pending\"\n    },\n    {\n      content: \"タスク名\",  // Step 2で取得した実際のタスク名\n      activeForm: \"タスク名を実行中\",\n      status: \"pending\"\n    },\n    {\n      content: \"tasks.mdで [タスク名] を [x] に変更（完了マーク）\",\n      activeForm: \"tasks.mdで [タスク名] を [x] に変更中\",\n      status: \"pending\"\n    },\n    {\n      content: \"tasks.mdから次のタスクを確認\",\n      activeForm: \"tasks.mdから次のタスクを確認中\",\n      status: \"pending\"\n    },\n    {\n      content: \"TodoWriteで次のタスクサイクル（5件）をToDoリストに追加\",\n      activeForm: \"TodoWriteで次のタスクサイクルをToDoリストに追加中\",\n      status: \"pending\"\n    }\n  ]\n})\n```\n\n**重要な実装ガイダンス**:\n\n#### タスク1: tasks.mdでタスクを[-]に変更\nこのタスクを実行する際は、`Edit`ツールを使って以下のように編集します：\n```\nold_string: \"- [ ] タスク名\"\nnew_string: \"- [-] タスク名\"\n```\n\n#### タスク2: 実際の実装タスク\ntasks.mdの`_Prompt`フィールドに記載されている指示に従って実装します。\n\n#### タスク3: tasks.mdでタスクを[x]に変更\n`Edit`ツールを使って以下のように編集します：\n```\nold_string: \"- [-] タスク名\"\nnew_string: \"- [x] タスク名\"\n```\n\n#### タスク4: 次のタスクを確認\n`Read`ツールでtasks.mdを読み、次の`[ ]`または`[-]`タスクを確認します。\n\n#### タスク5: 次のサイクルを追加\nこのタスクを実行すると、新しい5ステップのサイクルが自動的に追加されます。\n\n`TodoWrite`で以下を実行：\n1. 完了済み（completed）タスクをToDoリストから削除\n2. tasks.mdから次のタスクを取得（Step 2と同じ処理）\n3. 新しい5ステップのタスクサイクルを生成\n4. ToDoリストに追加\n",
        "commands/multi_perspective_review.md": "---\ndescription: \"複数の視点から客観的にレビューし、方針の妥当性を検証します。\"\nallowed-tools: Bash(git diff:*), Bash(git log:*), Bash(git symbolic-ref refs/remotes/origin/HEAD --short), Bash(date:+%Y%m%d_%H%M%S), Bash(mkdir -p .claude_work/multi_perspective_review:*), Write(.claude_work/**), Read(.claude_work/**)\n---\n\n# 複数視点レビューコマンド\n\n<important>\n\nこのコマンドは以下の場合に使用してください：\n\n- 実装方針や設計の妥当性を確認したい\n- 複数の視点から客観的な意見が欲しい\n- 早すぎる最適化やnit な指摘を避けたい\n- プロジェクトの現状に合った判断をしたい\n\n</important>\n\n## 実行手順\n\n<procedure>\n\n**1. コンテキストの収集**\n\n<context>\n\nまず、レビューに必要なコンテキストを収集します：\n\n- **デフォルトブランチの取得**\n\n   ```bash\n   git symbolic-ref refs/remotes/origin/HEAD --short\n   ```\n\n   結果は `origin/main` のような形式なので、後続の処理で使用します\n\n- **現在の変更差分を取得（あれば）**\n\n   デフォルトブランチとの差分を取得：\n\n   ```bash\n   git diff <デフォルトブランチ名>\n   ```\n\n   例: `git diff origin/main`\n\n   ※ 変更がない場合も問題なし。これから実装する方針のレビューなど、コード差分がない場合もある\n\n- **デフォルトブランチからの差分コミット履歴を取得**\n\n   現在のブランチがデフォルトブランチと異なる場合、差分コミットを取得：\n\n   ```bash\n   git log <デフォルトブランチ名>..HEAD --oneline\n   ```\n\n   例: `git log origin/main..HEAD --oneline`\n\n   ※ 現在のブランチがデフォルトブランチと同じ場合は、このステップはスキップ\n\n- **会話履歴の確認（重要）**\n\n   - 直前のユーザーとのやり取りから、レビュー対象の意図を把握する\n   - 「この方針で良いか確認したい」「この設計をレビューして」などの説明\n   - git diffがない場合は、会話履歴が主なコンテキストになる\n\n</context>\n\n**1-2. ログ保存用ディレクトリの作成とコンテキスト情報の保存**\n\nタイムスタンプを取得して定義：\n\n<timestamp>\n\n```bash\ndate +%Y%m%d_%H%M%S\n```\n\n</timestamp>\n\n次に、ディレクトリ構造を作成します：\n\n```bash\nmkdir -p .claude_work/multi_perspective_review/<timestamp>/round1\nmkdir -p .claude_work/multi_perspective_review/<timestamp>/round2\n```\n\n次に、コンテキストファイルのパスを定義します：\n\n<context-file>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/context.md\n```\n\n</context-file>\n\n<context>タグで収集した内容を<context-file>タグのパスに保存します。\n\n**2. 第1ラウンド: 8つの視点からのレビュー**\n\n収集したコンテキストを基に、8つの異なる視点からレビューを実施します。\n\n**並列実行**: 8つのTaskツール（`subagent_type: \"general-purpose\"`）を同時に呼び出し、効率的にレビューを実施してください。\n\n以下の8つの視点を定義します：\n\n<examples>\n\n<example>\n<name>アーキテクチャ・設計</name>\n\n<round1-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round1/architecture.md\n```\n\n</round1-filename>\n\n<perspective-details>\n\n- システム全体の構造が適切か\n- モジュール分割が適切か\n- 依存関係が適切に管理されているか\n- 拡張性が考慮されているか\n- 設計原則が遵守されているか\n\n</perspective-details>\n\n</example>\n\n<example>\n<name>パフォーマンス・効率性</name>\n\n<round1-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round1/performance.md\n```\n\n</round1-filename>\n\n<perspective-details>\n\n- 実行速度に問題がないか\n- メモリ使用量が適切か\n- スケーラビリティが考慮されているか\n- アルゴリズムの計算量が適切か\n\n</perspective-details>\n\n</example>\n\n<example>\n<name>保守性・可読性</name>\n\n<round1-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round1/maintainability.md\n```\n\n</round1-filename>\n\n<perspective-details>\n\n- コードが理解しやすいか\n- 変更がしやすい構造になっているか\n- 命名規則が適切か\n- 使われていない関数や変数はないか\n- コメントが適切に記述されているか（自明なコメントが付与されていないか）\n- コメントと関数名、関数名と実際の処理で乖離がないか\n- 類似の機能を持つコードが重複していないか\n- 複雑度が適切に管理されているか\n\n</perspective-details>\n\n</example>\n\n<example>\n<name>テスタビリティ</name>\n\n<round1-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round1/testability.md\n```\n\n</round1-filename>\n\n<perspective-details>\n\n- テストがしやすい設計になっているか\n- 依存性の注入が適切に行われているか\n- モック化が容易な構造になっているか\n- テストケースの網羅性が確保されているか\n\n</perspective-details>\n\n</example>\n\n<example>\n<name>ユーザー体験・利便性</name>\n\n<round1-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round1/user_experience.md\n```\n\n</round1-filename>\n\n<perspective-details>\n\n- エンドユーザーやAPI利用者の視点で使いやすいか\n- UIが使いやすいか\n- APIが直感的か\n\n</perspective-details>\n\n</example>\n\n<example>\n<name>プロジェクトフェーズ適合性</name>\n\n<round1-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round1/project_phase.md\n```\n\n</round1-filename>\n\n<perspective-details>\n\n- 早すぎる最適化になっていないか\n- MVP として妥当な範囲か\n- 技術的負債とのバランスが適切か\n\n</perspective-details>\n\n</example>\n\n<example>\n<name>既存コードとの整合性</name>\n\n<round1-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round1/consistency.md\n```\n\n</round1-filename>\n\n<perspective-details>\n\n- プロジェクト内のパターン・スタイルと一貫性があるか\n- コーディング規約が遵守されているか\n\n</perspective-details>\n\n</example>\n\n<example>\n<name>ベストプラクティス・標準準拠</name>\n\n<round1-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round1/best_practices.md\n```\n\n</round1-filename>\n\n<perspective-details>\n\n- 公式ドキュメントに沿っているか\n- コミュニティのベストプラクティスに従っているか\n- 言語固有のイディオムが適切に使われているか\n- 業界標準に準拠しているか\n\n</perspective-details>\n\n</example>\n\n</examples>\n\n各general-purpose subagentには以下の情報を含めたプロンプトを渡します：\n\n```\nあなたは<name>タグで定義された視点から、以下の内容をレビューしてください。\n\n## 保存先\n\n<round1-filename>タグで定義されたファイルパスに保存してください。\n\n## レビュー対象\n\n<context-file>タグで定義されたファイルに保存されたコンテキスト情報を参照してください。\n\n## レビューの指針\n\n- 客観的な視点から意見を述べてください\n- 修正案の提示は不要です（分析と意見のみ）\n- 具体的なコードや状況に即した指摘をしてください\n- 抽象的すぎる指摘は避けてください\n\n## あなたの視点\n\n<perspective-details>タグで定義された内容を参照してください。\n\n詳細に網羅的に報告してください。具体的なコード箇所、懸念される影響、改善の必要性について、十分な情報を含めて分析してください。\n\n## 出力形式\n\nマークダウン形式で保存後、以下の形式で報告: `レビュー結果を保存しました: <round1-filename>`\n```\n\n**Taskツールの呼び出し例（8つ並列）:**\n\n<example>\n\n```\nTask(\n  subagent_type: \"general-purpose\",\n  description: \"アーキテクチャ・設計の観点からレビュー\",\n  prompt: \"あなたは<name>タグで定義された視点から...\",\n  model: \"sonnet\"\n)\n\nTask(\n  subagent_type: \"general-purpose\",\n  description: \"パフォーマンス・効率性の観点からレビュー\",\n  prompt: \"あなたは<name>タグで定義された視点から...\",\n  model: \"sonnet\"\n)\n\n... (残り6つも同様に並列で呼び出し、全てmodel: \"sonnet\"を指定)\n```\n\n</example>\n\n**3. 第2ラウンド: 妥当性検証**\n\n第1ラウンドのログファイルを読み込み、5つのsubagentに妥当性検証を依頼します。\n\n**並列実行**: 5つのTaskツール（`subagent_type: \"general-purpose\"`）を同時に呼び出してください。\n\nメタレビュアー番号を定義：\n\n<meta-reviewer-number>固有の番号</meta-reviewer-number>\n\n各メタレビュアーの出力ファイルパスを定義：\n\n<round2-filename>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/round2/meta_reviewer_<meta-reviewer-number>.md\n```\n\n</round2-filename>\n\nまず、8つの視点の<round1-filename>タグで定義されたファイルパスを収集してください。\n\n次に、各general-purpose subagentには以下のプロンプトを渡します（<meta-reviewer-number>タグに1～5を指定し、[ログファイルパス一覧]の部分には収集した8つのパスを列挙）：\n\n```\nあなたは**メタレビュアー<meta-reviewer-number>**として、第1ラウンドのレビュー結果を検証してください。\n\n## 保存先\n\n`<round2-filename>`タグで定義されたファイルパスに保存してください。\n\n## 第1ラウンドのレビューログ\n\n以下の8つのファイルに第1ラウンドの視点別レビュー結果が保存されています。すべて読み込んで内容を確認してください：\n\n[ログファイルパス一覧]\n\n## 元のコンテキスト（検証の裏付け用）\n\n<context-file>タグで定義されたファイルに保存されたコンテキスト情報を参照してください。\n\n## 検証観点\n\n以下の観点から、レビュー結果の妥当性を評価してください：\n\n- **コンテキストとの整合性**\n   - 提供されたコンテキスト（git diff、コミット履歴、会話内容）を踏まえた意見か\n   - 抽象的すぎる指摘ではなく、具体的なコードや状況に即しているか\n\n- **プロジェクトフェーズ適合性**\n   - 早すぎる最適化や過剰な設計になっていないか\n   - MVPとして妥当な範囲か\n   - nitな指摘ではなく、本質的な問題か\n\n## 回答形式\n\n- 妥当な指摘: 「✅ [理由]」\n- 疑問のある指摘: 「⚠️ [理由]」\n- 不適切な指摘: 「❌ [理由]」\n\n全ての観点に対して客観的かつ詳細に評価してください。各指摘について、コンテキストとの整合性、プロジェクトフェーズとの適合性、具体性の程度を十分に検証し、判断の根拠を明確に示してください。\n\n## 出力形式\n\nマークダウン形式で保存後、以下の形式で報告: `検証結果を保存しました: <round2-filename>`\n```\n\n**4. 最終レポートの生成**\n\n最終レポートの保存先を定義します：\n\n<final-report>\n\n```\n.claude_work/multi_perspective_review/<timestamp>/final_report.md\n```\n\n</final-report>\n\n第2ラウンドの5つのsubagentから返ってきたログファイルパスを収集した後、メインエージェントが以下の処理を実行します：\n\n1. **全ログファイルを読み込む**\n   - `.claude_work/multi_perspective_review/<timestamp>/round1/` 配下の8ファイル\n   - `.claude_work/multi_perspective_review/<timestamp>/round2/` 配下の5ファイル\n\n2. **統合処理を実行**\n   - 第1ラウンドの8つの視点から、共通指摘をマージ\n   - 第2ラウンドの5つの検証結果から、妥当性評価を統合\n   - 主要な指摘事項を以下に分類：\n     - 妥当性が確認された指摘\n     - 検討が必要な指摘\n     - 不適切と判断された指摘\n\n3. **最終レポートを生成**\n\n最終レポートを以下の形式で生成します：\n\n<template>\n\n```markdown\n# 複数視点レビュー結果\n\n## レビューサマリー\n- 第1ラウンド: 8つの視点からレビュー\n- 第2ラウンド: 5つのメタレビュアーによる妥当性確認\n\n## 主要な指摘事項\n\n### 妥当性が確認された指摘\n\n**[指摘のタイトル]**\n- [判定結果] [指摘内容]\n- 理由: [妥当性の根拠]\n\n### 検討が必要な指摘\n\n**[指摘のタイトル]**\n- [判定結果] [指摘内容]\n- 理由: [検討が必要な理由]\n\n### 不適切と判断された指摘\n\n**[指摘のタイトル]**\n- [判定結果] [指摘内容]\n- 理由: [不適切と判断した理由]\n\n## 詳細レビュー結果\n\n### 第1ラウンド: 多角的レビュー\n\n（※ 前述の整理結果を挿入）\n\n### 第2ラウンド: 妥当性検証\n\n**メタレビュアーの評価:**\n[各メタレビュアーの評価結果を箇条書きで列挙]\n\n## 総合評価\n\n**優先的に対処すべき事項:**\n[妥当性が高いと判断された指摘を優先度順に列挙]\n\n**今後検討すべき事項:**\n[検討が必要と判断された指摘を列挙]\n\n**実施不要と判断された事項:**\n[不適切と判断された指摘を列挙]\n\n[総合的な評価コメント]\n```\n\n</template>\n\n<example>\n\n```markdown\n# 複数視点レビュー結果\n\n## レビューサマリー\n- 第1ラウンド: 8つの視点からレビュー\n- 第2ラウンド: 5つのメタレビュアーによる妥当性確認\n\n## 主要な指摘事項\n\n### 妥当性が確認された指摘\n\n**エラーハンドリングの不足**\n- 外部API呼び出し時のエラーハンドリングが不十分\n- 理由: 実際のコードを見ると、try-catchブロックがなく、本番環境で問題が発生する可能性が高い\n\n**テスタビリティの問題**\n- 外部依存が直接インポートされており、モック化が困難\n- 理由: 具体的なコード箇所を指摘しており、テストの保守性に直結する実質的な問題\n\n**アーキテクチャの重複**\n- 新しいvalidateInput関数が既存のvalidationUtilsモジュールと重複\n- 理由: コードベース全体を見ると、同じ機能が2箇所に存在し、保守性を低下させる\n\n### 検討が必要な指摘\n\n**パフォーマンス懸念**\n- データベースクエリがN+1問題を引き起こす可能性\n- 理由: 現時点のデータ量では問題にならない可能性があるが、将来的なスケールを考慮すると対処すべき\n\n**変数名の曖昧さ**\n- 変数名が曖昧（data, result など）\n- 理由: プロジェクト内で一貫して使われているパターンであれば、nitな指摘の可能性\n\n### 不適切と判断された指摘\n\n**過剰な抽象化**\n- インターフェースを追加してDI パターンを徹底すべき\n- 理由: プロジェクトのフェーズを考慮すると早すぎる最適化。現時点では不要な複雑性を導入する\n\n## 詳細レビュー結果\n\n### 第1ラウンド: 多角的レビュー\n\n（※ 前述の整理結果を挿入）\n\n### 第2ラウンド: 妥当性検証\n\n**メタレビュアー1の評価:**\n- エラーハンドリング不足は妥当な指摘（実装に直接影響）\n- N+1問題は現時点では過剰かもしれないが、将来的には対処が必要\n- DI パターンの徹底は早すぎる最適化\n\n**メタレビュアー2の評価:**\n- テスタビリティの問題は具体的で改善価値が高い\n- validationUtils との重複は明確な問題\n- 変数名の指摘はプロジェクト規約次第\n\n（以下、メタレビュアー3-5の評価を同様に列挙）\n\n## 総合評価\n\n**優先的に対処すべき事項:**\n1. 外部API呼び出し時のエラーハンドリングを追加\n2. 外部依存のモック化を容易にするため、依存性注入パターンを部分的に適用\n3. validateInput関数と既存のvalidationUtilsモジュールの重複を解消\n\n**今後検討すべき事項:**\n- データベースクエリのN+1問題（データ量が増えた際に再評価）\n- 変数名の見直し（チーム全体のコーディング規約を整備してから判断）\n\n**実施不要と判断された事項:**\n- 全体的なDIパターンの徹底（現フェーズでは過剰）\n\n全体として、実装は概ね妥当な範囲にあります。上記の優先事項を対処すれば、品質とテスタビリティが大きく向上すると考えられます。\n```\n\n</example>\n\n</template>\n\n**4. 最終レポートの保存とユーザーへの表示**\n\n生成した最終レポートを<final-report>タグで定義されたファイルパスに保存してください。\n\n保存後、ユーザーには以下の情報を表示：\n\n```markdown\n# 複数視点レビュー完了\n\n## レビュー結果\n\n最終レポートを保存しました: <final-report>\n\n## サマリー\n\n### 妥当性が確認された主要な指摘（優先対処）\n1. [指摘事項1]\n2. [指摘事項2]\n3. [指摘事項3]\n\n### 検討が必要な指摘\n- [指摘事項A]\n- [指摘事項B]\n\n### 不適切と判断された指摘\n- [指摘事項X]\n\n詳細については、上記ファイルを参照してください。\n\n## ログファイル一覧\n\n### コンテキスト情報\n- `<context-file>`\n\n### 第1ラウンド（8視点のレビュー）\n\n各視点の<round1-filename>タグで定義されたファイル（8ファイル）\n\n### 第2ラウンド（5メタレビュアーの評価）\n\n各メタレビュアーの`<round2-filename>`タグで定義されたファイル（5ファイル）\n```\n\n</procedure>\n",
        "commands/optimize_bq_query.md": "---\nallowed-tools: Bash(bq query:*), Bash(bq wait:*), Bash(tee:*), Write(/tmp/**), Edit(/tmp/**), Read(/tmp/**)\ndescription: \"BigQueryクエリのパフォーマンスを分析し、2倍以上の性能改善を目標とした最適化を提案します。\"\n---\n\n## 前提条件\n- **リージョン**: US（region-us）固定\n- **プロジェクト**: デフォルトプロジェクト（`gcloud config get-value project`で設定済み）\n- **権限**: INFORMATION_SCHEMAへのアクセス権限あり\n- **スキャン量削減**: INFORMATION_SCHEMAは直近7日間のみ検索（creation_timeで絞り込み）\n- クエリの`FROM`句にバッククオートの付与は禁止\n  - バッククオートを付与すると、Bash toolがコマンドと勘違いをする\n  - そのため、毎回ユーザーの許可が必要になってしまうため\n\n## 分析対象\n- 入力: $ARGUMENTS(SQLファイルパス `.sql`)\n- SQLのファイルのみで最適化内容を判断するのではなく、実際にクエリを実行してジョブ情報を取得し、ボトルネック分析を行う\n\n## 実行手順\n\n### 1. クエリ実行とジョブIDの取得\n\n**前提**: `$ARGUMENTS`は最適化対象のSQLクエリが記述された`.sql`ファイルのパスです\n\n1. クエリを実行してジョブIDを取得\n  - `cat \"$ARGUMENTS\" | bq query --nosync --use_legacy_sql=false --use_cache=false --format=json | jq -r '.jobReference.jobId'`\n  - 取得したジョブIDを`JOB_ID`として以降の分析で使用\n  - `JOB_ID`をシェル変数として設定する必要はありません\n\n2. ジョブの完了を待機\n  - `bq wait \"<JOB_ID>\"`でジョブが完了するまで待機\n\n### 2. 全体ボトルネックの特定\n\n#### 基本情報の収集\n- 以下のクエリで元のクエリと基本メトリクス(スロット時間、スキャン量)を取得\n\n```bash\nbq query --use_legacy_sql=false --format=json --parameter=\"job_id:STRING:<JOB_ID>\" \"\n  SELECT query, total_slot_ms, total_bytes_processed\n  FROM region-us.INFORMATION_SCHEMA.JOBS_BY_PROJECT\n  WHERE job_id = @job_id AND creation_time >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)\n\" | tee /tmp/job_info.json | head -n 10\n```\n\n- 元クエリと基本メトリクスを保存\n  - `cat /tmp/job_info.json | jq -r '.[0].query' | tee /tmp/original_query.sql`\n\n#### 最大のボトルネックステージを特定\n**目的**: 全体のスロット時間の80%以上を占める真のボトルネックを見つける\n\n```bash\nbq query --use_legacy_sql=false --format=pretty --parameter=\"job_id:STRING:<JOB_ID>\" \"\n  SELECT\n    stage.name as stage_name,\n    CAST(stage.slot_ms AS INT64) as slot_ms,\n    ROUND(100.0 * stage.slot_ms / SUM(stage.slot_ms) OVER(), 1) as pct_of_total\n  FROM region-us.INFORMATION_SCHEMA.JOBS_BY_PROJECT,\n       UNNEST(job_stages) AS stage\n  WHERE job_id = @job_id\n    AND creation_time >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)\n  ORDER BY stage.slot_ms DESC\n  LIMIT 5\n\"\n```\n\n**この結果から上位1-3ステージ（合計80%以上）を特定し、以降はそれらのみを分析対象とする**\n\n### 3. ボトルネック根本原因の分析\n\n**前提**: セクション2で特定したボトルネックステージ（TOP1-3）のみを詳細分析する\n\n#### 根本原因の診断\n\n1. **ボトルネックステージの詳細メトリクスを取得**\n  - セクション2で特定したボトルネックステージ（TOP1-3）に対して以下のクエリを実行:\n\n```bash\nbq query --use_legacy_sql=false --format=pretty --parameter=\"job_id:STRING:<JOB_ID>\" \"\n  SELECT\n    stage.name,\n    CAST(stage.slot_ms AS INT64) as slot_ms,\n    ROUND(stage.wait_ratio_max * 100, 1) as wait_pct,\n    ROUND(stage.read_ratio_max * 100, 1) as read_pct,\n    ROUND(stage.compute_ratio_max * 100, 1) as compute_pct,\n    ROUND(stage.write_ratio_max * 100, 1) as write_pct,\n    ROUND(CAST(stage.shuffle_output_bytes AS INT64) / 1048576, 1) as shuffle_mb\n  FROM region-us.INFORMATION_SCHEMA.JOBS_BY_PROJECT,\n       UNNEST(job_stages) AS stage\n  WHERE job_id = @job_id\n    AND creation_time >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)\n    AND stage.name IN ('特定されたボトルネックステージ名1', '名前2', '名前3')\n  ORDER BY stage.slot_ms DESC\n\"\n```\n\n2. **ステージの処理内容を特定**\n  - 各ステージがどの種類の処理を行っているかを以下のクエリで確認:\n\n```bash\nbq query --use_legacy_sql=false --format=pretty --parameter=\"job_id:STRING:<JOB_ID>\" \"\n  SELECT\n    stage.name,\n    CASE\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'READ') THEN 'READ処理'\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'WRITE') THEN 'WRITE処理'\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'COMPUTE') THEN 'COMPUTE処理'\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'FILTER') THEN 'FILTER処理'\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'JOIN') THEN 'JOIN処理'\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'AGGREGATE') THEN 'AGGREGATE処理'\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'ANALYTIC') THEN 'ANALYTIC処理'\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'SORT') THEN 'SORT処理'\n      WHEN EXISTS(SELECT 1 FROM UNNEST(stage.steps) AS step WHERE step.kind = 'LIMIT') THEN 'LIMIT処理'\n      ELSE 'その他'\n    END as primary_operation\n  FROM region-us.INFORMATION_SCHEMA.JOBS_BY_PROJECT,\n       UNNEST(job_stages) AS stage\n  WHERE job_id = @job_id\n    AND creation_time >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)\n  ORDER BY stage.slot_ms DESC\n  LIMIT 5\n\"\n```\n\n#### 元クエリとの対応付けと分析結果記録\n\n1. **元クエリを確認**\n  - `cat \"$ARGUMENTS\"`で元クエリの内容を表示\n\n2. **ボトルネック分析結果ファイルの初期化**\n  - Writeツールを使って`/tmp/bottleneck_analysis.md`を以下の内容で作成:\n\n```markdown\n## 特定されたボトルネックステージ:\n<!-- 例: - S02_Join+: 99000ms (全体の45%) -->\n<!-- 例: - S03_Aggregate: 55000ms (全体の25%) -->\n\n## 根本原因分析:\n<!-- 例: - S02_Join+の支配的要素: Write (shuffle_mb: 151MB), wait_pct: 5%, compute_pct: 35% -->\n<!-- 例: - S03_Aggregateの支配的要素: Compute (compute_pct: 80%), read_pct: 15% -->\n\n## 対応するSQL箇所:\n<!-- 例: - S02_Join+に対応: INNER JOIN users u ON c.user_id = u.id (行11-12) -->\n<!-- 例: - S03_Aggregateに対応: GROUP BY category, date (行18) -->\n```\n\n3. **分析結果の記録**\n  - 上記bqクエリ結果を参照し、Editツールで各セクションに情報を追記\n\n### 4. ボトルネック対応の最適化パターン選択\n\n**特定されたボトルネック要因に基づいて、2倍改善を狙える最適化パターンを選択**\n\n#### Input段階のボトルネック → データ読み込み最適化\n- **パーティション絞り込み**: WHERE句での日付/地域等の限定\n- **クラスタリング活用**: JOIN/GROUP BYキーでの事前ソート\n- **列選択最適化**: SELECT *を避けて必要列のみ\n\n#### Join段階のボトルネック → 結合処理最適化\n- **JOIN前データ削減**: 事前フィルタリング/集約で行数削減\n- **JOIN順序最適化**: 小テーブル→大テーブルの順序\n- **EXISTS/IN変換**: 相関サブクエリから効率的な形式へ\n\n#### Aggregate/Sort段階のボトルネック → 集約処理最適化\n- **段階的集約**: 複数CTEでの事前集約\n- **LIMIT早期適用**: TOP-N処理での不要計算回避\n- **ウィンドウ関数最適化**: PARTITION BY句の最適化\n\n**最適化パターンの選択と記録**:\n\n1. **ボトルネック診断結果を参照**\n  - `/tmp/bottleneck_analysis.md`の内容を確認\n\n2. **最適化パターンファイルの初期化**\n  - Writeツールを使って`/tmp/applied_optimizations.md`を以下の内容で作成:\n\n```markdown\n## 適用する最適化パターン\n<!-- 例: 1. JOIN前データ削減: users テーブルの事前フィルタリング (期待効果: 60%削減) -->\n<!-- 例: 2. JOIN順序最適化: 小テーブル first (期待効果: 25%削減) -->\n```\n\n3. **最適化パターンの記録**\n  - ボトルネック要因に対応するパターンを選択\n  - 各パターンの期待効果を計算し、2倍改善の見込みを確認\n  - Editツールで具体的な最適化内容を追記\n\n### 5. 最適化クエリの実装\n1. **元クエリを確認**\n  - `cat \"$ARGUMENTS\"`で元クエリの内容を確認\n2. **最適化クエリの生成と保存**\n  - セクション4で選択した最適化パターンを適用\n  - Writeツールを使って`/tmp/optimized_query.sql`に最適化後のクエリを保存\n  - 最適化例:\n\n```sql\n-- 例: JOIN前データ削減\nWITH filtered_users AS (\n  SELECT * FROM users WHERE active = true\n)\nSELECT ...\nFROM comments c\nINNER JOIN filtered_users u ON c.user_id = u.id\n```\n\n3. **最適化内容の確認**\n  - `cat /tmp/optimized_query.sql`で保存した最適化クエリを表示\n\n### 6. リファクタリング結果の同一性検証\n- **重要**: 最適化は性能改善のみで、出力結果は完全に同一である必要がある\n- **注意**: `BIT_XOR`と`FARM_FINGERPRINT`は行の順序に依存しないため、結果の同一性を検証できる\n\n**BigQueryチェックサムによる検証手順**:\n\n1. **元クエリの結果テーブル名を取得してチェックサムを計算**\n  - `JOB_ID`(セクション1で取得済み)から以下のコマンドを実行し、`DESTINATION_TABLE`として設定\n    - `bq query --use_legacy_sql=false --format=json --parameter=\"job_id:STRING:<JOB_ID>\" \"SELECT destination_table FROM region-us.INFORMATION_SCHEMA.JOBS_BY_PROJECT WHERE job_id = @job_id AND creation_time >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)\" | jq -r '.[0].destination_table | [.project_id, .dataset_id, .table_id] | join(\".\")'`\n  - `DESTINATION_TABLE`に対して、チェックサムを計算\n    - `bq query --use_legacy_sql=false --format=json \"SELECT BIT_XOR(FARM_FINGERPRINT(TO_JSON_STRING(t))) as checksum FROM <DESTINATION_TABLE> AS t\" | jq -r '.[0].checksum'`\n  - チェックサム値（整数文字列）を記録\n\n2. **最適化クエリの結果テーブル名を取得してチェックサムを計算**\n  - `NEW_JOB_ID`(セクション6で取得)から以下のコマンドを実行し、`DESTINATION_TABLE`として設定\n    - `bq query --use_legacy_sql=false --format=json --parameter=\"job_id:STRING:<NEW_JOB_ID>\" \"SELECT destination_table FROM region-us.INFORMATION_SCHEMA.JOBS_BY_PROJECT WHERE job_id = @job_id AND creation_time >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)\" | jq -r '.[0].destination_table | [.project_id, .dataset_id, .table_id] | join(\".\")'`\n  - `DESTINATION_TABLE`に対して、チェックサムを計算\n    - `bq query --use_legacy_sql=false --format=json \"SELECT BIT_XOR(FARM_FINGERPRINT(TO_JSON_STRING(t))) as checksum FROM <DESTINATION_TABLE> AS t\" | jq -r '.[0].checksum'`\n  - チェックサム値（整数文字列）を記録\n\n3. **チェックサム値を比較**\n  - 2つのチェックサム値が完全に一致することを確認\n  - 不一致の場合は最適化を中止し、原因を調査\n\n### 7. 性能改善効果の測定\n- 最適化後のクエリを実行し、同様にジョブIDを取得してメトリクスを収集\n  - `cat /tmp/optimized_query.sql | bq query --nosync --use_legacy_sql=false --use_cache=false --format=json | jq -r '.jobReference.jobId'`\n  - 取得したジョブIDを`NEW_JOB_ID`として以降の分析で使用\n  - `NEW_JOB_ID`をシェル変数として設定する必要はありません\n- `bq wait \"<NEW_JOB_ID>\"`でジョブが完了するまで待機\n- 元のスロット時間を取得（セクション2で保存したjsonから）\n  - !`cat /tmp/job_info.json | jq -r '.[0].total_slot_ms'`\n- 以下のコマンドで、最適化後のスロット時間を取得\n\n```bash\nbq query --use_legacy_sql=false --format=json --parameter=\"job_id:STRING:<NEW_JOB_ID>\" \"\n  SELECT total_slot_ms\n  FROM region-us.INFORMATION_SCHEMA.JOBS_BY_PROJECT\n  WHERE job_id = @job_id AND creation_time >= TIMESTAMP_SUB(CURRENT_TIMESTAMP(), INTERVAL 7 DAY)\n\" | jq -r '.[0].total_slot_ms'\n```\n\n#### 改善率の計算と判定:\n- 元のスロット時間と最適化後のスロット時間を比較し、改善率を計算\n  - `bc`コマンドなどは使用せず、Agent自身が計算を行う\n- 2倍以上の改善が達成されたかを判定\n  - 改善率が2倍以上であれば成功とし、最適化プロセスを終了\n  - 達成されていない場合は、セクション3で特定したボトルネックに戻り、セクション4-6を繰り返す\n\n### 8. 最終レポート生成\n\n**目的**: 2倍改善達成の根拠と再現可能な手順を記録\n\n1. **必要な情報を収集**\n  - 元のスロット時間: `cat /tmp/job_info.json | jq -r '.[0].total_slot_ms'`で取得\n  - 最適化後のスロット時間: セクション7で取得済み\n  - 改善率: Agent自身が計算\n  - 目標達成状況: 改善率が2.0倍以上かを判定\n\n2. **最終レポートの生成**\n  - Writeツールを使って`/tmp/optimization_report.md`を以下の構造で作成:\n\n```markdown\n# BigQuery最適化レポート\n\n## 実行サマリー\n- **元クエリファイル**: <$ARGUMENTSの値>\n- **元ジョブID**: <JOB_ID>\n- **元スロット時間**: <ORIGINAL_SLOT_MS>ms\n- **最終改善率**: <IMPROVEMENT_RATIO>x\n- **目標達成**: <達成状況（✅ 達成 or ❌ 未達成）>\n\n## 特定されたボトルネック\n<bottleneck_analysis.mdの内容をReadツールで読み込んで転記>\n\n## 適用した最適化手法\n<applied_optimizations.mdの内容をReadツールで読み込んで転記>\n\n## 最適化後のクエリ\n\n\\`\\`\\`sql\n<optimized_query.sqlの内容をReadツールで読み込んで転記>\n\\`\\`\\`\n\n## 検証結果\n- **結果一致**: ✅ チェックサム一致で完全同一\n- **性能改善**: <ORIGINAL_SLOT_MS>ms → <NEW_SLOT_MS>ms\n```\n\n3. **レポートの確認**\n  - `cat /tmp/optimization_report.md`でレポート内容を表示\n\n**完了条件**:\n- 2倍以上の改善達成 OR 5回の反復完了\n- 結果の同一性確認済み\n- 再現可能な最適化手順の記録\n",
        "commands/triage_pr_comments.md": "Pull Requestのコメントに対する対応要否をコードベース分析に基づいて判断します\n\n## 分析対象\nPull RequestのURL: $ARGUMENTS\n\n## 実行手順\n\n### 1. 情報取得と分析\n```bash\n# Pull RequestのURLから情報を取得\nPR_URL=\"$ARGUMENTS\"\n\n# $ARGUMENTSが空の場合、現在のブランチのPRを取得\nif [ -z \"$PR_URL\" ]; then\n  PR_URL=$(gh pr view --json url --jq '.url' 2>/dev/null || echo \"\")\n  if [ -z \"$PR_URL\" ]; then\n    echo \"エラー: Pull RequestのURLが指定されていません。また、現在のブランチに紐づくPRも見つかりませんでした。\"\n    exit 1\n  fi\n  echo \"現在のブランチのPull Request URLを使用します: $PR_URL\"\nfi\n\necho \"=== Pull Request基本情報 ===\"\n\n# gh pr viewでPR情報を取得\nPR_INFO=$(gh pr view \"$PR_URL\" --json number,headRepositoryOwner,headRepository,title,author,state,headRefName,baseRefName,changedFiles,additions,deletions,createdAt)\n\n# 変数の設定（後のAPI呼び出しで使用）\nOWNER=$(echo \"$PR_INFO\" | jq -r '.headRepositoryOwner.login')\nREPO=$(echo \"$PR_INFO\" | jq -r '.headRepository.name')\nPR_NUMBER=$(echo \"$PR_INFO\" | jq -r '.number')\n\necho \"$PR_INFO\"\necho \"\"\n\necho \"=== 未解決コメント一覧 ===\"\n# 未解決コメント取得（GraphQL API）\ngh api graphql --field query=\"query { repository(owner: \\\"$OWNER\\\", name: \\\"$REPO\\\") { pullRequest(number: $PR_NUMBER) { reviewThreads(last: 100) { nodes { id isResolved comments(last: 10) { nodes { id body path line originalLine createdAt author { login } diffHunk } } } } } } }\" | jq '.data.repository.pullRequest.reviewThreads.nodes | map(select(.isResolved == false)) | map(.comments.nodes) | flatten'\necho \"\"\n\necho \"=== 変更内容の詳細分析 ===\"\necho \"### 変更されたファイル一覧\"\ngh pr diff \"$PR_URL\" --name-only\n\necho \"\"\necho \"### 各ファイルの詳細な差分\"\ngh pr diff \"$PR_URL\"\n```\n\n### 4. 分析指示\n\n**このPull Requestの情報を取得しました。あなたはこのPull Requestの作成者として、コメントに対する対応要否を判断する必要があります。このPRのオーナーシップを持つ立場から、各コメントに対応すべきかどうかを以下の観点で分析してください：**\n\n## A. コードベース全体の理解\n\nまず、リポジトリ全体を把握してください：\n\n1. **プロジェクト構造の分析**\n   - ディレクトリ構造、命名規則\n   - 使用技術スタック、フレームワーク\n   - 設定ファイル（package.json、requirements.txt、go.modなど）\n\n2. **既存パターンの特定**\n   - テストファイルの配置規則と命名規則\n   - エラーハンドリングの統一パターン\n   - ログ出力やデバッグの方法\n   - ドキュメンテーションの書き方\n   - コーディングスタイル、規約\n\n3. **アーキテクチャの理解**\n   - レイヤー構造、依存関係\n   - デザインパターンの使用状況\n   - 拡張性、保守性への配慮\n\n## B. 変更内容の整合性チェック\n\n今回のPull Requestが既存パターンに従っているかチェック：\n\n- 新機能にテストが含まれているか\n- エラーハンドリングが適切か\n- ログ出力が既存パターンに従っているか\n- ドキュメント更新が必要かどうか\n- 依存関係の追加が適切か\n\n## C. 各コメントの詳細分析\n\n**各コメントについて、以下の形式で判断してください：**\n\n### コメントID: [ID番号]\n**内容**: [コメントの要約]\n\n#### 対応判断: ✅必要 / ⚠️要検討 / ❌不要\n\n**理由**:\n- [客観的な根拠]\n\n**コメント者の意図**:\n- [なぜこのコメントをしたのか]\n\n**影響範囲**:\n- [修正しない場合のリスク]\n\n**修正方針** (対応必要な場合):\n- **場所**: [具体的なファイル、関数]\n- **方法**: [どのように修正するか]\n- **難易度**: 簡単/中程度/困難\n- **時間**: [おおよその所要時間]\n\n**返信内容案**:\n- **対応する場合**: [修正内容や対応方針を説明する返信文案]\n- **対応しない場合**: [理由を丁寧に説明する返信文案]\n- **質問・確認が必要な場合**: [意図を確認するための返信文案]\n\n---\n\n## D. 参考情報の整理\n\n### 対応判断の参考情報\n- **既存パターンとの整合性**: [コメントが指摘する内容が既存コードベースの規則に合致するか]\n- **技術的妥当性**: [指摘内容が技術的に正しいか]\n- **影響範囲**: [対応しない場合の潜在的リスク]\n\n### コメント優先度整理 (参考)\n1. [コメントID] - [対応を検討すべき理由]\n2. [コメントID] - [対応を検討すべき理由]  \n3. [コメントID] - [対応を検討すべき理由]\n\n### ユーザー判断のための補足\n- **すぐに対応できそうなもの**: [リスト]\n- **時間をかけて検討が必要なもの**: [リスト]\n- **コメント者に確認が必要なもの**: [リスト]\n\n**重要**: この分析は判断材料の提供であり、最終的な対応判断はユーザーが行います。コード修正は一切行いません。",
        "commands/validate_bq_query.md": "# bq queryコマンドの出力を検証する\n\n## 目的\nあなたはクエリの監査官です。危険なクエリを見抜き、その場合には実行を何としても阻止する必要があります。入力となるクエリの対象はBigQueryです\n\n## 出力形式\n検証の結果を以下のClaude Code標準JSON形式で出力してください。JSON以外を出力することは許可されていません。\n\n- 返答は有効なJSONオブジェクト1個のみ\n  - **重要**: コードフェンス(\\`\\`\\`)や「このクエリを検証します」などの出力(説明文、前置きなど)は一切許可されていません\n\n### JSON構造\n```json\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"PreToolUse\",\n    \"permissionDecision\": \"allow または deny\",\n    \"permissionDecisionReason\": \"判定理由（日本語約200字）\"\n  }\n}\n```\n\n### 出力例\n\n安全なクエリの場合：\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"PreToolUse\",\n    \"permissionDecision\": \"allow\",\n    \"permissionDecisionReason\": \"単純なSELECT文のみで安全なクエリです\"\n  }\n}\n\n危険なクエリの場合：\n{\n  \"hookSpecificOutput\": {\n    \"hookEventName\": \"PreToolUse\",\n    \"permissionDecision\": \"deny\",\n    \"permissionDecisionReason\": \"DROP文によりテーブルを削除する危険な操作です\"\n  }\n}\n\n## 判定基準\n\n### 安全なクエリ（allow）\n- **SELECT文のみ**: データの読み取り専用操作\n- **INFORMATION_SCHEMA**: メタデータの参照\n- **WITH句**: CTEを使用した読み取り専用クエリ\n\n### 危険なクエリ（deny）\n\n#### DDL（Data Definition Language）\n- **DROP**: テーブル・データセット・ビュー・関数の削除\n- **CREATE**: テーブル・データセット・ビュー・関数の作成\n- **ALTER**: 既存オブジェクトの構造変更\n- **TRUNCATE**: テーブルデータの全削除\n\n#### DML（Data Manipulation Language）\n- **INSERT**: データの挿入・追加\n- **UPDATE**: データの更新・変更\n- **DELETE**: データの削除\n- **MERGE**: データのマージ操作\n\n#### DCL（Data Control Language）\n- **GRANT**: 権限の付与\n- **REVOKE**: 権限の取り消し\n- **CREATE ROW ACCESS POLICY**: 行レベルセキュリティ\n\n#### 高度な操作\n- **EXPORT DATA**: データのエクスポート\n- **IMPORT**: データのインポート（セッション機能）\n- **EXECUTE IMMEDIATE**: 動的SQL実行\n- **CALL**: ストアドプロシージャ実行\n- **BEGIN/COMMIT/ROLLBACK TRANSACTION**: トランザクション制御\n\n#### BigQuery ML\n- **CREATE MODEL**: 機械学習モデルの作成\n- **ML.PREDICT**: モデル予測の実行\n- **ML.EVALUATE**: モデル評価\n\n#### 危険なオプション\n- **--replace**: 既存テーブルの置換\n- **--destination_table**: 結果の別テーブル保存\n- **--external_table_definition**: 外部テーブル定義\n- **--append_table**: データの追加\n\n### その他\n- **判断不能**: 上記に該当しない場合は`deny`\n",
        "skills/ask-user-choice/SKILL.md": "---\nname: ask-user-choice\ndescription: ユーザーに質問や確認をする際に毎回発動してください。自由回答形式ではなく、明確な選択肢（1質問あたり2-4個）を持つAskUserQuestionツールを使用し、ユーザーの入力負担を軽減して意思決定を迅速化します。柔軟性のためmultiSelect trueをデフォルトにしてください。\nallowed-tools: AskUserQuestion\n---\n\n# Ask User Choice Skill\n\n## 目的\n\nこのスキルは`AskUserQuestion`ツールの使用を推進し、ユーザーの入力負担を軽減して対話をより効率的にします。テキスト入力が必要な自由回答形式ではなく、ワンクリックで選択できる構造化された選択肢を提供してください。\n\n## 使用タイミング\n\n<trigger>\n\n以下の場合にこのスキルを発動してください：\n- ユーザーの入力や好みを取得する\n- 曖昧な要件を明確化する\n- 実装の選択肢を提示する（ライブラリ、アーキテクチャ、アプローチなど）\n- 複数のタスクがある場合に優先順位を決定する\n- 作業完了後に次のアクションを提案する\n\n</trigger>\n\n## ベストプラクティス\n\n### 1. 良い質問の構造\n\n各質問には以下を含めること：\n\n- **明確な質問文**: 疑問符で終わり、具体的であること\n- **簡潔なheader**: 短いラベル。例：「ライブラリ」「アプローチ」\n- **選択肢**: それぞれにラベルと詳細な説明を付ける\n- **multiSelect**: **デフォルトで`true`に設定**（柔軟性のため、ユーザーは1つまたは複数選択可能）\n\n### 2. 充実した詳細な説明文を書く\n\n説明文は長くてOK。情報量を充実させること。\n\n良い選択肢の構造：\n\n```json\n{\n  \"label\": \"短い選択肢名\",\n  \"description\": \"コンテキスト、トレードオフ、影響を含む詳細な説明。\\n\\n段落区切りには\\\\n\\\\nを使って可読性を向上させる。\\n\\n十分な情報を提供して、情報に基づいた意思決定を可能にする。\"\n}\n```\n\n- `\\n\\n`で段落区切りを使う（可読性が大幅に向上）\n- コンテキスト、メリット・デメリット、影響を含める\n- 詳細を出し惜しみしない - ユーザーは簡潔すぎる説明より包括的な情報を好む\n- **Markdown記法の制限**:\n  - `**bold**`、`*italic*`、`` `code` ``などは使えない（そのまま表示される）\n  - 箇条書き（`-`）は装飾されないがそのまま表示されるので、可読性向上のために使用OK\n\n### 3. multiSelectをデフォルトで使用\n\n**特に理由がない限り`multiSelect: true`をデフォルトに**\n\n✅ **`multiSelect: true`を使用（推奨デフォルト）**:\n\n- ほとんどのシナリオで柔軟性の恩恵がある\n- ユーザーは1つだけ選びたければ1つだけ選べる\n- 該当する場合は複数の選択肢を組み合わせられる\n- よりユーザーフレンドリーで制約が少ない\n\n⚠️ **`multiSelect: false`を使うのは以下の場合のみ**:\n\n- 選択肢が厳密に相互排他的\n- 複数選択すると論理的な矛盾が生じる\n- 質問の性質上、単一選択が本質的に必要\n\n## 使用例\n\n<examples>\n\n### 例1: 実装アプローチ選択（詳細な説明文付き）\n\n<example>\n\n```json\n{\n  \"question\": \"どのJavaScriptフレームワークを使用しますか？\",\n  \"header\": \"Framework\",\n  \"multiSelect\": true,\n  \"options\": [\n    {\n      \"label\": \"React + TypeScript\",\n      \"description\": \"仮想DOMを使用した高速レンダリングを実現する、最も人気のあるJavaScriptフレームワーク。\\n\\nTypeScriptと組み合わせることで型安全性が向上し、大規模プロジェクトでも保守性が高まる。\\n\\nコンポーネントベースの設計で再利用性が高く、豊富なエコシステム（React Router, Redux, Next.js等）が利用できる。\\n\\n学習コストは中程度で、ドキュメントやコミュニティサポートが充実している。\"\n    },\n    {\n      \"label\": \"Vue.js + Composition API\",\n      \"description\": \"学習曲線が穏やかで初心者にも取り組みやすいフレームワーク。\\n\\nComposition APIを使用することで、React Hooksに近いロジックの再利用が可能になる。\\n\\nテンプレート構文が直感的でHTMLに近い書き方ができ、公式の状態管理ライブラリPiniaやルーティングライブラリVue Routerが統合されている。\\n\\nパフォーマンスも優れており、中小規模から大規模まで幅広く対応できる。\"\n    },\n    {\n      \"label\": \"Svelte + SvelteKit\",\n      \"description\": \"コンパイル時にコードを最適化するため、ランタイムのオーバーヘッドが極めて少なく、高速なアプリケーションを構築できる。\\n\\n仮想DOMを使わず、ビルド時に効率的な命令型コードに変換される。\\n\\nSvelteKitを使用することでSSRやSSG、ルーティングなどの機能が統合されている。\\n\\nコード量が少なく、バンドルサイズが小さいのも大きなメリット。ただし、エコシステムはReactやVueと比べるとまだ小さい。\"\n    }\n  ]\n}\n```\n\n</example>\n\n### 例2: 複数機能選択（multiSelect推奨）\n\n<example>\n\n```json\n{\n  \"question\": \"どの機能を実装しますか？\",\n  \"header\": \"Features\",\n  \"multiSelect\": true,\n  \"options\": [\n    {\n      \"label\": \"ダークモード\",\n      \"description\": \"ライトモードとダークモードの切り替え機能を追加。\\n\\n- アクセシビリティが向上\\n- 低照度環境でのユーザーの快適性が改善\\n- 目の疲労を軽減\\n\\n実装要件:\\n- CSS変数の設定\\n- 状態管理（localStorage等）\\n- テーマ切り替えUI\"\n    },\n    {\n      \"label\": \"キーボードショートカット\",\n      \"description\": \"パワーユーザー向けにキーボードナビゲーションとショートカットを有効化。\\n\\n頻繁に使用するユーザーの生産性が大幅に向上する。\\n\\nブラウザのショートカットとの衝突を避けるための慎重な設計が必要。\"\n    },\n    {\n      \"label\": \"PDF出力\",\n      \"description\": \"コンテンツをPDFファイルとしてエクスポートできる機能。\\n\\nレポート、ドキュメント、オフライン共有に便利。\\n\\nPDF生成ライブラリ（jsPDF、pdfmake等）が必要。\"\n    }\n  ]\n}\n```\n\n</example>\n\n### 例3: タスク優先順位（multiSelect falseのレアケース）\n\n<example>\n\n```json\n{\n  \"question\": \"最初にどのタスクから始めますか？\",\n  \"header\": \"Priority\",\n  \"multiSelect\": false,\n  \"options\": [\n    {\n      \"label\": \"認証バグの修正\",\n      \"description\": \"🔴 最優先 - 現在ユーザーがログインできない状態。\\n\\n全ユーザーのアクセスをブロック中。修正予想時間：1-2時間。\\n\\n他の作業より先に即座に対処すべき。\"\n    },\n    {\n      \"label\": \"新機能追加\",\n      \"description\": \"🟡 中優先度 - 次スプリント向けにクライアントから要望あり。\\n\\n現在の機能をブロックしていない。予想時間：1-2日。\\n\\nクリティカルなバグ解決後にスケジュール可能。\"\n    },\n    {\n      \"label\": \"コードリファクタリング\",\n      \"description\": \"🟢 低優先度 - 保守性とコード品質を改善。\\n\\nユーザーへの即時影響なし。予想時間：3-4時間。\\n\\n機能開発の合間を埋めるのに適している。\"\n    }\n  ]\n}\n```\n\n</example>\n\n</examples>\n\n## 常に覚えておくこと\n\n<important>\n\n✅ **すべきこと**:\n\n- 詳細な説明を使う（コンテキストとトレードオフを追加）\n- `\\n\\n`で段落区切りを使い、可読性を向上させる\n- 柔軟性のため`multiSelect: true`をデフォルトにする\n- 各選択肢のlabelは短く、descriptionは充実させる\n- **必要に応じて複数回質問する** - フォローアップが必要な場合は、最初の回答を得た後に再度AskUserQuestionを使用\n\n❌ **してはいけないこと**:\n\n- 簡潔すぎる説明 - ユーザーは情報に基づいた意思決定のため詳細を求める\n- 選択肢が真に相互排他的でない限り`multiSelect: false`を使う\n- フォローアップ質問を躊躇する - 推測よりも明確化の方が良い\n\n</important>\n\n## 複数ラウンドの質問\n\n不明点が多い場合や段階的な明確化が必要な場合：\n\n1. **関連する質問をグループ化**\n2. **最初のバッチを聞く**、回答を待つ\n3. **回答に基づいてフォローアップ質問**を必要に応じて行う\n4. **すべての不確実性が解消されるまで繰り返す**\n\nこの段階的な質問アプローチは推奨されており、実装に進む前に徹底的な理解を確保するのに役立ちます。\n",
        "skills/codex-review/SKILL.md": "---\nname: codex-review\ndescription: Review code changes against plans and development diaries. Use when user requests \"codex review\".\nallowed-tools: Bash, Write, Edit, Read\nmodel: sonnet\ncontext: fork\n---\n\n# Codex CLIを使ったコードレビュー\n\nコードの変更内容に対してcodex CLIを使って客観的なレビューを実施します。\n\n## 実行手順\n\n<procedure>\n\n### 1. デフォルトブランチの取得\n\nまず、リポジトリのデフォルトブランチを取得してください：\n\n```bash\ngit symbolic-ref refs/remotes/origin/HEAD --short | cut -d/ -f2\n```\n\nこのコマンドでデフォルトブランチ名（main や master など）を取得し、後続のステップで使用します。\n\n### 2. planファイルの特定\n\n`.claude_work/plans/`配下からplanファイルを取得してください：\n\n```bash\nls .claude_work/plans/*.md\n```\n\ngit worktree運用のため、単一のplanファイルが存在する前提です。\n\nこのファイルパスを以下のように定義します：\n\n<plan-file>\n\n```\n<取得したplanファイルのパス>\n```\n\n</plan-file>\n\n### 3. 開発日誌の取得・保存（コンテキストにある場合）\n\n会話のコンテキスト内にesa URLの開発日誌が言及されている場合、以下の手順で取得・保存してください：\n\n1. esa URLからpost番号を抽出（例：`https://xxx.esa.io/posts/1234` → `1234`）\n2. `mcp__esa-mcp-server__read_esa_post` ツールでpost内容を取得\n3. 取得した内容を以下のパスに保存（Writeツール使用）\n\n<dev-diary-file>\n\n```\n.claude_work/dev_diary.md\n```\n\n</dev-diary-file>\n\n開発日誌がコンテキストにない場合は、このステップをスキップしてください。\n\n### 4. planファイルとの整合性確認\n\nCodexレビュー前に、planファイルを読んで現在の実装（diff）との整合性を確認してください：\n\n1. <plan-file>タグで定義されたパスのファイルを読む（Readツール使用）\n2. デフォルトブランチとの差分を確認（`git diff <デフォルトブランチ名>`）\n3. planの内容と実装にずれがないか確認\n4. ずれがある場合はユーザーに報告\n\n### 5. Codex CLIでのレビュー実行とファイル保存\n\nBash経由で`codex exec --sandbox read-only`を使ってレビューを実行し、`tee`で出力をファイルに保存してください。\n\n**出力先**: `.claude_work/codex_review.md`（固定パス、既存ファイルは上書き）\n\n<example>\n\n**開発日誌がない場合のコマンド例：**\n\n```bash\necho \"<デフォルトブランチ名>ブランチとの差分を日本語でレビューしてください。\n\n以下のファイルを参照して、計画に沿った実装になっているか確認してください：\n- planファイル: <plan-fileタグで定義されたパス>\n\nレビューの観点：\n- planに記載された変更内容との整合性\n- コードの品質（可読性、保守性）\n- 潜在的な問題やバグ\" | codex exec --sandbox read-only | tee .claude_work/codex_review.md\n```\n\n**開発日誌がある場合のコマンド例：**\n\n```bash\necho \"<デフォルトブランチ名>ブランチとの差分を日本語でレビューしてください。\n\n以下のファイルを参照して、計画に沿った実装になっているか確認してください：\n- planファイル: <plan-fileタグで定義されたパス>\n- 開発日誌: <dev-diary-fileタグで定義されたパス>\n\nレビューの観点：\n- planに記載された変更内容との整合性\n- コードの品質（可読性、保守性）\n- 潜在的な問題やバグ\n- 開発日誌に記載された開発指針との整合性\" | codex exec --sandbox read-only | tee .claude_work/codex_review.md\n```\n\n**連続会話の場合：**\n\n```bash\necho \"追加の質問\" | codex exec --sandbox read-only resume <thread-id> | tee .claude_work/codex_review.md\n```\n\n</example>\n\n**重要：**\n- ファイルの内容ではなく、ファイルパスを渡すことで、Codexが直接ファイルを読み取ります\n- `tee`を使うことで、リアルタイムで出力を確認しつつファイルにも保存されます\n- codex CLIの出力からthread-id（セッションID）を確認してください\n\n### 6. レビュー結果の報告\n\n**以下の2つの情報のみ**をユーザーに報告してください：\n\n1. **レビューファイルのパス**: `.claude_work/codex_review.md`\n2. **セッションID**: codex CLIが出力したthread-id\n\n**禁止事項**:\n- レビュー内容を要約しないこと\n- レビュー内容の詳細を報告しないこと\n- ファイルを読んで内容を説明しないこと\n\n</procedure>\n",
        "skills/gha-sha-reference/SKILL.md": "---\nname: gha-sha-reference\ndescription: ユーザーがGitHub Actionsのタグ参照をSHA参照に変換するよう要求したときに発動してください。uses:フィールドのタグ参照を自動的にSHA参照（コミットハッシュ + コメント付きバージョン）に変換します。\n---\n\n# GitHub Actions SHA Reference Skill\n\n## 目的\n\nこのスキルはGitHub Actionsワークフローファイル内の`uses:`フィールドで使用されているタグ参照（例: `@v4`）を、セキュリティのベストプラクティスに従ってSHA参照（例: `@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2`）に自動変換します。\n\n## 使用タイミング\n\n<trigger>\n\n以下の場合にこのスキルを発動してください：\n\n- ユーザーが「GitHub ActionsをSHA参照に変換して」と要求したとき\n- ユーザーが「actionsのusesをSHAに書き換えて」と言及したとき\n\n</trigger>\n\n## 実行手順\n\n<procedure>\n\n### 1. 変更対象を確認\n\nまず `--check --diff` オプションで、どのファイルが変更されるかを確認します：\n\n```bash\npinact run --check --diff\n```\n\n**出力例**:\n\n```\nERROR action isn't pinned\n.github/workflows/ci.yaml:10\n-       uses: actions/checkout@v4\n+       uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0\nERROR action isn't pinned\n.github/workflows/ci.yaml:11\n-     - uses: actions/setup-go@v4\n+     - uses: actions/setup-go@4d34df0c2316fe8122ab82dc22947d607c0c91f9 # v4.0.0\nERROR action isn't pinned\n.github/workflows/deploy.yaml:15\n-       uses: actions/checkout@v4\n+       uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0\n```\n\n### 2. 変換を実行\n\n確認後、`pinact run` を実行してすべての対象ファイルを一括変換します：\n\n```bash\npinact run\n```\n\npinactは以下を自動的に行います：\n- タグ参照からコミットSHAを取得\n- 最も詳細なバージョンタグ（v4.3.0など）をコメントとして追加\n- `.github/workflows/*.{yml,yaml}` と `action.{yml,yaml}` を自動検出して変換\n\n</procedure>\n\n## 実装例\n\n<examples>\n\n### 例1: 基本的な使用方法\n\n<example>\n\n**ステップ1: 変更対象を確認**:\n\n```bash\npinact run --check --diff\n```\n\n**出力**:\n\n```\nERROR action isn't pinned\n.github/workflows/ci.yaml:10\n-       uses: actions/checkout@v4\n+       uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0\nERROR action isn't pinned\n.github/workflows/ci.yaml:11\n-     - uses: actions/setup-go@v4\n+     - uses: actions/setup-go@4d34df0c2316fe8122ab82dc22947d607c0c91f9 # v4.0.0\n```\n\n**ステップ2: 変換を実行**:\n\n```bash\npinact run\n```\n\n**変換後のワークフローファイル (.github/workflows/ci.yaml)**:\n\n```yaml\nname: CI\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955 # v4.3.0\n      - uses: actions/setup-go@4d34df0c2316fe8122ab82dc22947d607c0c91f9 # v4.0.0\n```\n\n</example>\n\n</examples>\n\n## 重要な注意事項\n\n<important>\n\n### すべきこと\n\n- **pinactを使用**: GitHub Actions SHA参照変換には専用ツールpinactを使用する\n- **まず --check --diff で確認**: `pinact run --check --diff` で変更対象を確認する\n- **一括実行**: diffで確認した後、`pinact run` で全ファイルを一括変換する\n- **変換結果を報告**: 何が変換されたかユーザーに伝える\n\n### してはいけないこと\n\n- **カスタムスクリプトを作成**: pinactという専用ツールがあるので、独自スクリプトは不要\n- **いきなり実行**: `--check --diff` で確認せずに `pinact run` を実行しない\n- **エラーを無視**: pinactの実行でエラーが出た場合は、そのまま進めずユーザーに報告する\n\n### 実行前チェックリスト\n\n- [ ] pinactがインストールされている（`pinact --version`で確認）\n- [ ] `pinact run --check --diff` で変更対象を確認した\n- [ ] diffの出力から変換対象のファイル一覧を把握した\n\n</important>\n\n## 参考リンク\n\n- [pinact - GitHub](https://github.com/suzuki-shunsuke/pinact)\n- [GitHub Actions セキュリティガイド](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-third-party-actions)\n",
        "skills/reading-notion/SKILL.md": "---\nname: reading-notion\ndescription: Notion URLが会話に登場した時、またはNotionのコンテンツを検索・取得する必要がある時に使用してください。\nallowed-tools: Bash, Read\n---\n\n# Reading Notion\n\nNotionページやドキュメントをMarkdownに変換して読み取り、内容を要約・説明するスキルです。\n\n## 概要\n\nこのスキルは2つのモードで動作します：\n\n1. **URL直接モード**: Notion URLが会話に登場した時、`notion-to-md`を使って自動的にMarkdownに変換し、内容を説明\n2. **検索モード**: キーワードでNotionを検索し、結果から選択したページの内容を説明\n\n**URL直接モード**では、Go製のCLIツール`notion-to-md`を使用してNotion APIからページデータを取得し、Markdown形式に変換します。これにより、ネスト構造、豊富なブロックタイプ、テキストアノテーションなどを正確に保持したMarkdownファイルが生成されます。\n\n\n## モード詳細\n\n<trigger>\n\n### URL直接モード\n\nNotion URLを検出すると自動的に発動します。詳細は **reference/url-mode.md** を参照してください。\n\n**発動例**:\n- ユーザーが `https://www.notion.so/myorg/abc123def456ghi789jkl012mno34567` のようなURLを提示\n- 会話中にNotion URLが登場\n\n### 検索モード\n\nキーワードでNotion内を検索したい時に発動します。詳細は **reference/search-mode.md** を参照してください。\n\n**発動例**:\n- 「データ基盤チームについて教えて」\n- 「Notionでプロジェクト〇〇を検索して」\n- 特定のキーワードに関する情報を求められた時\n\n</trigger>\n",
        "skills/reading-notion/reference/search-mode.md": "# 検索モード\n\n「notionでxyzを探して」という形で発動し、キーワードでNotionを検索して結果から選択したページの内容を説明します。\n\n## 発動条件\n\n<trigger>\n\n以下のようなリクエストで発動します：\n\n- 「Notionでプロジェクト〇〇を検索して」\n- Notionに関する質問であることが明らかな場合\n\n</trigger>\n\n## 実行フロー\n\n<procedure>\n\n### 1. キーワード検索と結果表示\n\njqを使って検索結果を箇条書き形式で整形します：\n\n```bash\nmcptools call API-post-search npx -y @notionhq/notion-mcp-server --params '{\"query\":\"プロジェクトXYZ\",\"page_size\":10}' | jq -r '.results[] | \"- \\(if .title then .title[0].text.content else (.properties | to_entries[] | select(.value.type == \"title\") | .value.title[0].text.content) end)\\n  - \\(.url)\"'\n```\n\n**出力例**:\n```\n- プロジェクトXYZ概要\n  - https://www.notion.so/abc123de...\n- XYZ実装ガイド\n  - https://www.notion.so/def456gh...\n- XYZ関連メモ\n  - https://www.notion.so/ghi789jk...\n- プロジェクトXYZ\n  - https://www.notion.so/jkl012mn...\n```\n\n<context>\n\n**API: API-post-search**\n\n```json\n{\n  \"properties\": {\n    \"filter\": {\n      \"additionalProperties\": true,\n      \"description\": \"A set of criteria, `value` and `property` keys, that limits the results to either only pages or only databases. Possible `value` values are `\\\"page\\\"` or `\\\"database\\\"`. The only supported `property` value is `\\\"object\\\"`.\",\n      \"properties\": {\n        \"property\": {\n          \"description\": \"The name of the property to filter by. Currently the only property you can filter by is the object type.  Possible values include `object`.   Limitation: Currently the only filter allowed is `object` which will filter by type of object (either `page` or `database`)\",\n          \"type\": \"string\"\n        },\n        \"value\": {\n          \"description\": \"The value of the property to filter the results by.  Possible values for object type include `page` or `database`.  **Limitation**: Currently the only filter allowed is `object` which will filter by type of object (either `page` or `database`)\",\n          \"type\": \"string\"\n        }\n      },\n      \"type\": \"object\"\n    },\n    \"page_size\": {\n      \"default\": 100,\n      \"description\": \"The number of items from the full list to include in the response. Maximum: `100`.\",\n      \"format\": \"int32\",\n      \"type\": \"integer\"\n    },\n    \"query\": {\n      \"description\": \"The text that the API compares page and database titles against.\",\n      \"type\": \"string\"\n    },\n    \"sort\": {\n      \"additionalProperties\": true,\n      \"description\": \"A set of criteria, `direction` and `timestamp` keys, that orders the results. The **only** supported timestamp value is `\\\"last_edited_time\\\"`. Supported `direction` values are `\\\"ascending\\\"` and `\\\"descending\\\"`. If `sort` is not provided, then the most recently edited results are returned first.\",\n      \"properties\": {\n        \"direction\": {\n          \"description\": \"The direction to sort. Possible values include `ascending` and `descending`.\",\n          \"type\": \"string\"\n        },\n        \"timestamp\": {\n          \"description\": \"The name of the timestamp to sort against. Possible values include `last_edited_time`.\",\n          \"type\": \"string\"\n        }\n      },\n      \"type\": \"object\"\n    },\n    \"start_cursor\": {\n      \"description\": \"A `cursor` value returned in a previous response that If supplied, limits the response to results starting after the `cursor`. If not supplied, then the first page of results is returned. Refer to [pagination](https://developers.notion.com/reference/intro#pagination) for more details.\",\n      \"type\": \"string\"\n    }\n  },\n  \"type\": \"object\"\n}\n```\n\n</context>\n\n### 2. ユーザーへの提示\n\nAIは検索結果を以下の形式でユーザーに提示します：\n\n```\nNotionで「プロジェクトXYZ」を検索した結果、以下のページが見つかりました：\n\n- **プロジェクトXYZ**\n  - https://www.notion.so/jkl012mn...\n- **XYZ関連メモ**\n  - https://www.notion.so/ghi789jk...\n- **XYZ実装ガイド**\n  - https://www.notion.so/def456gh...\n```\n\n</procedure>\n",
        "skills/reading-notion/reference/url-mode.md": "# URL直接モード\n\nNotion URLを検出すると自動的に発動し、そのページの内容を取得して要約します。\n\n## URL検出パターン\n\n以下のようなNotion URLを検出します：\n\n```\nhttps://www.notion.so/{workspace}/{page-id}\nhttps://www.notion.so/{page-id}\n```\n\n例：\n```\nhttps://www.notion.so/myorg/abc123def456ghi789jkl012mno34567\nhttps://www.notion.so/abc123def456ghi789jkl012mno34567\n```\n\n## 実行手順\n\n<procedure>\n\n### 1. Markdown変換と出力\n\n`notion-to-md`コマンドを使ってNotion URLを直接Markdownに変換します。\n\n**実行コマンド**:\n\n```bash\nmkdir -p .claude_work/notion && notion-to-md {notion_url} | tee .claude_work/notion/{page_id}.md > /dev/null\n```\n\n**説明**:\n- `{notion_url}`: ユーザーが提示したNotion URL（例: `https://www.notion.so/workspace/Page-title-abc123...`）\n- `{page_id}`: URLの最後の32文字（例: `abc123def456ghi789jkl012mno34567`）\n- `tee`を使うことで許可なしでファイル保存が可能\n\n### 2. Markdownファイルの読み込みと要約報告\n\n出力されたMarkdownファイルをReadツールで読み込み、内容を要約してユーザーに報告します。\n\n**手順**:\n\n1. Readツールで `.claude_work/notion/{page_id}.md` を読み込む\n2. ページの主な内容を要約してユーザーに報告（箇条書き5行以内）\n\n**報告フォーマット**:\n\n```\nNotionページを以下のファイルに出力しました：\n.claude_work/notion/{page_id}.md\n\n【ページの要約】\n- {要約ポイント1}\n- {要約ポイント2}\n- {要約ポイント3}\n- {要約ポイント4}\n- {要約ポイント5}\n```\n\n</procedure>\n\n## エラーハンドリング\n\n### ページが見つからない場合\n\n```\n申し訳ございません。指定されたNotion URLからページを取得できませんでした。\n以下の可能性があります：\n- ページが削除されている\n- アクセス権限がない\n- URLが正しくない\n```\n\n### API呼び出しが失敗した場合\n\n```\nNotion APIへの接続に失敗しました。しばらくしてから再度お試しください。\n```\n",
        "skills/requesting-gcloud-bq-auth/SKILL.md": "---\nname: requesting-gcloud-bq-auth\ndescription: gcloudやbqコマンド実行時に認証エラー（Reauthentication required等）を検出した場合に使用。エージェントが自動で認証コマンドを実行することを防ぎ、ユーザーに認証を依頼します。\n---\n\n# Requesting gcloud/bq Auth Skill\n\n## 目的\n\nこのスキルは、gcloudやbqコマンドの実行時に認証エラーを検出し、エージェントが勝手に認証コマンドを実行することを防ぎます。認証はブラウザ操作が必要なため、ユーザーに明示的に依頼します。\n\n## 使用タイミング\n\n<trigger>\n\n以下のエラーパターンを検出した場合にこのスキルを発動してください：\n\n**パターン1**: bqコマンドでの再認証要求\n- `Reauthentication required.` と `Please enter your password:` が出力された場合\n\n**パターン2**: gcloud認証でブラウザが開く\n- `Your browser has been opened to visit:` と `accounts.google.com` URLが出力された場合\n\n</trigger>\n\n## 実行手順\n\n<procedure>\n\n1. **即座に作業を中断**: 認証エラーを検出したら、関連するgcloud/bqコマンドの実行を停止する\n\n2. **ユーザーに通知**: 以下の内容をユーザーに伝える\n   - 認証が切れていること\n   - 推奨される認証コマンド（例: `gcloud auth application-default login`）\n   - 認証完了後に作業を再開できること\n\n3. **認証完了を待つ**: ユーザーが認証を完了するまで、関連するコマンドを実行しない\n\n</procedure>\n\n## エラーパターン例\n\n<examples>\n\n### パターン1: bqコマンドでの再認証要求\n\n<example>\n\n```\n% bq ls\nReauthentication required.\nPlease enter your password:\n```\n\n**対応**:\n```\n認証が切れています。以下のコマンドで認証を完了してください：\n\n  gcloud auth application-default login\n\n認証完了後、作業を再開します。\n```\n\n</example>\n\n### パターン2: gcloud認証でブラウザが開く\n\n<example>\n\n```\n% gcloud auth application-default login\nYour browser has been opened to visit:\n\n    https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=XXX&redirect_uri=XXX&scope=XXX&state=XXX&access_type=offline&code_challenge=XXX&code_challenge_method=S256\n```\n\n**対応**:\n```\nブラウザで認証フローが開始されました。\nブラウザで認証を完了してください。\n\n認証完了後、作業を再開します。\n```\n\n</example>\n\n</examples>\n\n## 重要な注意事項\n\n<important>\n\n✅ **すべきこと**:\n- 認証エラーを検出したら即座に作業を中断する\n- ユーザーに明確な指示を提供する（認証コマンド、手順）\n- 認証完了を待つ\n\n❌ **してはいけないこと**:\n- **絶対に認証コマンドを自動実行しない**（ブラウザ操作が必要なため）\n- 認証が完了していない状態でgcloud/bqコマンドを実行しない\n\n</important>\n",
        "skills/semantic-committing/SKILL.md": "---\nname: semantic-committing\ndescription: コミット時、「commit」「git add」「変更を分割」の言及時に使用。git diffを分析し、変更を論理的な意味単位に分割してコミットする。git-sequential-stageでhunk単位のステージングを行う。\nallowed-tools: Bash, Write, Edit, Read\nmodel: sonnet\ncontext: fork\n---\n\n# 意味のある最小単位でコミットする\n\n大きな変更を論理的な単位に分割してコミットしてください。git diffを分析して意味のある最小単位を特定し、`git-sequential-stage`ツールで段階的にステージングします。\n\n## 禁止事項\n\n<important>\n\n- [ ] **手順の厳守**: <procedure>タグ内で指定された手順、実行コマンド、オプションを完全に守ること\n  - [ ] 手順を一つずつ順番に実行すること（効率化のために手順を飛ばしたり、コマンドを変更したりしてはいけない）\n  - [ ] コマンドの実行順序を変更してはいけない\n  - [ ] 複数のコマンドを`&&`や`;`で繋ぐなど、手順にない方法でコマンドを実行してはいけない\n- [ ] 計画を立てるだけで終わることは禁止です。このエージェントに求められているのは、すべての変更がコミットされていることです\n- [ ] `git add .` / `git add -A` の使用は禁止です\n- [ ] 必ず`git-sequential-stage`を使用してhunk単位でステージングすること\n\n</important>\n\n## プロンプトの扱い\n\n<important>\n\n- 呼び出し時のプロンプトに特に明確な指示がされていない場合は、<procedure>タグの実行手順通りに進めてください\n- プロンプトに特定の意図（例：「2つのコミットに分割してください」「テストと実装を分けてください」など）が加えられている場合：\n  - **手順3（変更内容を分析）** と **手順4（ステージングとコミット）** でその意図を考慮してください\n  - ただし、**<procedure>タグの実行手順は一切変更せず**、記載された手順に従って実行してください\n  - プロンプトの意図は分析とコミット計画に反映し、実行方法は変えないこと\n\n</important>\n\n## 実行手順\n\n<procedure>\n以下の手順で変更を意味のある最小単位に分割してコミットしてください：\n\n1. **pre-commitの事前実行**\n\n   `.pre-commit-config.yaml`が存在する場合は、事前に実行してください：\n\n   ```bash\n   pre-commit run --all-files\n   ```\n\n2. **差分を取得**\n\n   最初に必ずintent-to-addで新規ファイルを追加してください：\n\n   ```bash\n   git ls-files --others --exclude-standard | xargs -r git add -N\n   ```\n\n   差分を取得してください：\n\n   ```bash\n   git diff HEAD | tee .claude_work/current_changes.patch\n   ```\n\n3. **変更内容を分析**\n\n   **hunk単位**で変更を分析し、最初のコミットに含めるhunkを決定してください：\n\n   - **hunkの内容を読み取る**: 各hunkが何を変更しているか理解する\n   - **意味的グループ化**: 同じ目的の変更（バグ修正、リファクタリング等）をグループ化する\n   - **コミット計画**: どのhunkをどのコミットに含めるか決定する\n\n   各ファイルのhunk数を確認してください：\n\n   ```bash\n   git-sequential-stage count-hunks\n   ```\n\n   分析例：\n\n   ```bash\n   # 分析結果例\n   # - コミット1（fix）:\n   #   - src/calculator.py: hunk 1, 3, 5（ゼロ除算エラーの修正）\n   #   - src/utils.py: hunk 2（関連するユーティリティ関数の修正）\n   # - コミット2（refactor）:\n   #   - src/calculator.py: hunk 2, 4（計算ロジックの最適化）\n   ```\n\n   コミットメッセージの形式（Conventional Commits形式）：\n   - `feat`: 新機能\n   - `fix`: バグ修正\n   - `refactor`: リファクタリング\n   - `docs`: ドキュメント\n   - `test`: テスト\n   - `style`: フォーマット\n   - `perf`: パフォーマンス改善\n   - `build`: ビルドシステムや外部依存関係の変更\n   - `ci`: CI設定ファイルやスクリプトの変更\n   - `revert`: コミットの取り消し\n   - `chore`: その他\n\n   分析が完了したら、コミット用のメッセージを作成してください：\n\n   **コミットメッセージの作成方法：**\n   - **必ずWriteツールを使用**して `.claude_work/commit_message.txt` にコミットメッセージを書くこと\n   - **禁止される方法：**\n     - `cat`とheredocを使ってファイルに書き込む（例：`cat <<EOF > .claude_work/commit_message.txt`）\n     - `git commit -m`で直接メッセージを指定する\n\n   ```bash\n   # Writeツールで .claude_work/commit_message.txt にコミットメッセージを書く\n   # 例：\n   # fix: ゼロ除算エラーを修正\n   #\n   # 計算処理で分母が0の場合の適切なエラーハンドリングを追加\n   ```\n\n4. **ステージングとコミット**\n\n   <decision-criteria name=\"wildcard-usage\">\n\n   **ワイルドカード（`*`）の使用判断：**\n\n   | 状況 | 判断 | 理由 |\n   |------|------|------|\n   | ファイル内のすべての変更が意味的に一体 | `*` 使用 | 単一の目的で分割不要 |\n   | 新規ファイル追加 | `*` 使用 | すべて新規のため |\n   | ドキュメントファイルの変更 | `*` 使用 | 通常は単一目的 |\n   | 異なる目的の変更が混在 | hunk番号指定 | バグ修正とリファクタリング等を分離 |\n   | hunk数が不明 | まず確認 | 盲目的な`*`使用は厳禁 |\n\n   **重要**: 「hunkを数えるのが面倒」という理由での`*`使用は厳禁\n\n   </decision-criteria>\n\n   <example name=\"staging-patterns\">\n\n   ```bash\n   # パターン1: 部分的な変更をステージング（hunk番号指定）\n   git-sequential-stage stage -patch=\".claude_work/current_changes.patch\" -hunk=\"src/calculator.py:1,3,5\"\n\n   # パターン2: ファイル全体をステージング（意味的に一体の変更の場合）\n   git-sequential-stage stage -patch=\".claude_work/current_changes.patch\" -hunk=\"tests/test_calculator.py:*\"\n\n   # パターン3: 複数ファイルの場合（混在使用）\n   git-sequential-stage stage -patch=\".claude_work/current_changes.patch\" -hunk=\"src/calculator.py:1,3,5\" -hunk=\"src/utils.py:2\" -hunk=\"docs/CHANGELOG.md:*\"\n\n   # コミット実行（手順3で作成したコミットメッセージを使用）\n   # 注意: ファイルパスは .claude_work/commit_message.txt であり、/tmp ではない\n   git commit -F .claude_work/commit_message.txt\n   ```\n\n   </example>\n\n5. **残りの変更を処理**\n\n   残りの変更があるかを確認してください：\n\n   ```bash\n   git diff HEAD\n   ```\n\n   **判断フロー：**\n   - 残りの変更がない → 手順6（最終確認）へ進む\n   - 残りの変更があり、差分の内容が変化している（pre-commitによる自動修正の可能性）→ **手順1から再実行**\n   - 残りの変更があり、差分が予想通り → パッチファイルを再生成して**手順3から再開**\n\n   パッチファイルの再生成：\n\n   ```bash\n   git diff HEAD | tee .claude_work/current_changes.patch > /dev/null\n   ```\n\n6. **最終確認**\n\n   すべての変更がコミットされたか確認してください：\n\n   ```bash\n   git diff HEAD\n   git status\n   ```\n\n</procedure>\n",
        "skills/updating-pr-title-and-description/SKILL.md": "---\nname: updating-pr-title-and-description\ndescription: Pull Request作成・更新時に使用。タイトルと説明文を自動生成・更新する。\nallowed-tools: Bash, Write, Edit, Read\nmodel: opus\ncontext: fork\n---\n\n# Pull Requestのタイトルと説明文を更新する\n\nPull Requestのタイトルと説明文を以下の手順で更新してください。\n\n## 実行手順\n\n<procedure>\n\n1. **デフォルトブランチの取得**\n\n   デフォルトブランチを取得：\n   ```bash\n   git symbolic-ref refs/remotes/origin/HEAD --short | cut -d/ -f2\n   ```\n\n2. **修正内容の確認**\n\n   デフォルトブランチからの差分を確認：\n   ```bash\n   # <default-branch> には手順1で取得したブランチ名を使用\n   git diff <default-branch>...HEAD\n   ```\n\n3. **コミットメッセージの確認**\n\n   デフォルトブランチからのコミット履歴を確認（本文も含む）：\n   ```bash\n   # <default-branch> には手順1で取得したブランチ名を使用\n   git log <default-branch>..HEAD\n   ```\n\n4. **説明文ファイルの準備**\n\n   `.github/PULL_REQUEST_TEMPLATE.md`が存在する場合はコピー：\n   ```bash\n   cp .github/PULL_REQUEST_TEMPLATE.md .claude_work/pr_body_draft.md\n   ```\n\n   存在しない場合は新規ファイル作成：\n   ```bash\n   touch .claude_work/pr_body_draft.md\n   ```\n\n5. **Pull Requestの説明文を作成**\n   - **重要**: 説明文を書く前に、必ず **reference/description-rules.md** を読み、そのルールに従うこと\n   - 作業ファイル（`.claude_work/pr_body_draft.md`）を編集\n   - 上記で取得した情報とチャットの会話内容を考慮して説明文を作成\n   - **説明文は必ず日本語で記載すること**\n   - **重要**：ファイル編集には必ず`Write`ツールまたは`Edit`ツールを使用すること\n   - bashコマンド（`cat <<EOF > file`、`echo \"...\" > file`など）でファイルを書き込んではいけません\n\n6. **Pull Requestの作成または更新**\n\n   PRの存在確認と作成/更新：\n   ```bash\n   # PRが存在するか確認\n   if gh pr view >/dev/null 2>&1; then\n     # PRが存在する場合：更新\n     gh pr edit --title \"修正内容を考慮したタイトル\" --body-file .claude_work/pr_body_draft.md\n   else\n     # PRが存在しない場合：ドラフトPRを作成\n     gh pr create --draft --title \"修正内容を考慮したタイトル\" --body-file .claude_work/pr_body_draft.md\n   fi\n   ```\n\n7. **更新後の確認と文字化けチェック**\n   ```bash\n   # PRの内容を確認\n   gh pr view\n   ```\n\n   - タイトルと説明文が正しく設定されているか確認\n   - **文字化けチェック**：日本語が文字化けしていないか確認\n   - **文字化けが検出された場合**：\n     1. `.claude_work/pr_body_draft.md` を確認し、UTF-8エンコーディングで保存されているか確認\n     2. ファイルを修正（必要に応じて文字エンコーディングを修正）\n     3. 再度 `gh pr edit --body-file .claude_work/pr_body_draft.md` で更新\n     4. もう一度 `gh pr view` で確認\n\n</procedure>\n",
        "skills/updating-pr-title-and-description/reference/description-rules.md": "# PR説明文生成ルール詳細\n\nこのドキュメントでは、Pull Request説明文を生成する際の詳細なルールを定義します。\n\n## 1. テンプレート処理ルール\n\n### 1.1 HTMLコメントの保持と内容の遵守\n\n**重要**: PRテンプレートに含まれるHTMLコメント（`<!-- ... -->`）は削除せず、そのまま保持してください。\n\n```markdown\n<!-- このコメントは削除しないでください -->\n## 概要\n...\n```\n\n**さらに重要**: コメント内に書かれている内容に従ってください\n- HTMLコメントにはPR作成者向けの案内が書かれていることが多い\n- 記入例、注意事項、必須項目などが記載されている\n- コメントの指示を読んで、その通りに説明文を作成する\n\n例:\n```markdown\n<!-- 以下のチェックリストをすべて完了してください -->\n- [x] テストを追加した\n- [x] ドキュメントを更新した\n```\n\n### 1.2 テンプレート構造の維持\n\n`.github/PULL_REQUEST_TEMPLATE.md` が存在する場合：\n- テンプレートのセクション構造（見出し、箇条書き等）を維持\n- 各セクションの内容を適切に埋める\n- セクションの順序は変更しない\n- **重要**: 勝手にMarkdownのセクション（`##`）やサブセクション（`###`）を追加しない\n  - テンプレートにないセクションを追加してはいけない\n  - テンプレート内の既存セクションのみを埋める\n\n## 2. CIチェック項目の処理\n\n### 2.1 基本方針\n\nテンプレートにチェックボックス（`- [ ]`）が含まれる場合、**PR提出者として各項目を実際に確認**してください。\n\n### 2.2 確認手順\n\n1. **CIステータスの確認**\n   ```bash\n   gh pr checks\n   ```\n\n2. **確認できた項目**: `- [x]` にチェック\n   ```markdown\n   - [x] すべてのテストが通っている\n   ```\n\n   **注意**: テストが通った場合、件数や実行時間などの詳細情報は記載不要\n   ```markdown\n   ✅ - [x] すべてのテストが通っている\n   ❌ - [x] すべてのテストが通っている（1234件のテストが456秒で通過）\n   ```\n\n3. **確認できない項目**: 理由をコメントで追記\n   ```markdown\n   - [ ] パフォーマンステストが通っている（環境がないため未確認）\n   ```\n\n### 2.3 CIチェックのスキップ条件\n\n**重要**: CIチェックは基本的に完了を待つべきですが、以下の条件でスキップ可能です：\n\n- **スキップ可能な条件**: 実行から5分以上経っても終わっていない場合のみ\n- **注意事項**:\n  - `dbt build`、`dbt run`、`dbt test` などは10分以上かかることもある\n  - これらの長時間実行が予想される場合は、さらに待つことを検討\n- **スキップ時の記載**:\n  ```markdown\n  - [ ] CIが完了している（実行中のため後で確認）\n  ```\n\n### 2.4 CIが失敗した場合の対応\n\n**重要**: CIが落ちている場合、**あなた（PR提出者）の責任**です。\n\nupdate pr が終わった後、以下の対応を行う必要があります：\n\n1. **失敗原因の特定**\n   ```bash\n   gh pr checks\n   gh run view [run-id] --log-failed\n   ```\n\n2. **修正の実施**\n   - エラーログを確認\n   - 原因を特定して修正\n   - 必要に応じてコミット・プッシュ\n\n3. **再確認**\n   - 修正後、CIが通ることを確認\n   - PRの説明文を更新（必要に応じて）\n\n## 3. コンテキスト情報の収集と記載\n\n### 3.1 収集する情報\n\n以下の情報を収集し、PR説明文の「背景」または「コンテキスト」セクションに記載してください：\n\n#### 3.1.1 Planファイル\n\n今回のセッションに紐付くplanファイルがあれば参照します（会話中で言及されたもの）。\n\n**重要**: planファイルはPR説明文に直接記載しない\n- planファイルはコミットされないため、PRには含まれない\n- 説明文を作成する際の**参考情報**として使用する\n- planの内容を理解した上で、説明文に反映する\n\n#### 3.1.2 会話中のURL\n\n会話中でユーザーが提示したURLを収集し、関連情報として記載：\n\n```markdown\n## 関連情報\n\n- https://example.com/docs/feature-spec\n- https://github.com/owner/repo/issues/123/\n```\n\n### 3.2 記載場所\n\n- PRテンプレートに「背景」セクションがあればそこに記載\n- なければ「## 背景」または「## コンテキスト」セクションを追加\n\n## 4. リンク形式ルール\n\n### 4.1 禁止されている形式\n\n以下の形式は**使用禁止**です：\n\n```markdown\n❌ PR #123\n❌ #123\n❌ issue #456\n❌関連PR: #789\n```\n\n### 4.2 必須の形式\n\n**フルURL形式**を使用してください：\n\n#### Pull Request\n```markdown\n✅ https://github.com/owner/repo/pull/123/\n✅ 関連PR https://github.com/owner/repo/pull/123/ を参照\n```\n\n#### Issue\n```markdown\n✅ https://github.com/owner/repo/issues/456/\n✅ 関連issue https://github.com/owner/repo/issues/456/ を参照\n```\n\n### 4.3 Whitespace挿入ルール\n\n前後に文字がある場合は、**必ず半角スペース（whitespace）を1つ挿入**してください：\n\n```markdown\n✅ 関連PR https://github.com/owner/repo/pull/123/ を参照\n❌ 関連PRhttps://github.com/owner/repo/pull/123/を参照\n❌ 関連PR https://github.com/owner/repo/pull/123/を参照\n```\n\n### 4.4 GitHub自動表示の活用\n\nフルURL形式を使用すると、GitHubが自動的に以下の情報を表示します：\n- PRのタイトル\n- Issueのタイトル\n- ステータス（open/closed/merged）\n\nこれにより、PRやIssue番号だけよりも情報が豊富になります。\n\n## 5. 説明文生成パターン\n\n### 5.1 テンプレートが存在する場合\n\n`.github/PULL_REQUEST_TEMPLATE.md` が存在する場合：\n\n1. テンプレートをコピー\n2. HTMLコメントを保持\n3. 各セクションを適切に埋める\n4. CIチェック項目を確認・チェック\n5. コンテキスト情報を追加\n6. リンク形式を統一\n\n### 5.2 テンプレートが存在しない場合\n\n**確認方法:**\n```bash\ntest -f .github/PULL_REQUEST_TEMPLATE.md && echo \"exists\" || echo \"not found\"\n```\n\n以下のセクションを含む説明文を生成：\n\n```markdown\n## 概要\n\n[何をやったか]\n\n## 背景\n\n[修正が必要になった背景]\n[planファイルやURLなどのコンテキスト情報]\n\n## 変更内容\n\n- [変更点1]\n- [変更点2]\n\n## 関連情報\n\n- https://github.com/owner/repo/issues/123/\n```\n\n## 6. 注意事項\n\n- 説明文は**必ず日本語**で記載\n- 文字化けが発生した場合は、ファイルのエンコーディング（UTF-8）を確認\n- `.claude_work/pr_body_draft.md` は削除せず残す（後で修正する可能性があるため）\n",
        "skills/writing-dev-diary/SKILL.md": "---\nname: writing-dev-diary\ndescription: 「開発日誌更新」「開発日誌作って」の言及時に使用。esa-llm-scoped-guardで開発日誌を新規作成・更新します。\nallowed-tools: Bash, Write, Edit, Read\nmodel: sonnet\ncontext: fork\n---\n\n# esa開発日誌の作成・更新\n\nesaに開発日誌を投稿・更新するスキルです。`esa-llm-scoped-guard` CLIを使用して、許可されたカテゴリ配下の記事のみを安全に編集します。\n\n## 禁止事項\n\n<important>\n\n- JSONファイルは必ず`.claude_work/dev_diary.json`に作成すること（**ファイル名固定**）\n- esa MCPの書き込み系ツール（`create_esa_post`, `update_esa_post`）は使用禁止。このスキルでは`esa-llm-scoped-guard` CLIのみ使用\n- JSONスキーマは必ず`esa-llm-scoped-guard -help`で確認してから生成すること\n\n</important>\n\n## 使用タイミング\n\n<trigger>\n\n以下のトリガーワードで発動します：\n\n- **「開発日誌を作って」**: 検索なしで直接新規作成\n- **「開発日誌を更新」+ esaのURL**: 指定されたURLの記事を更新\n- **「開発日誌を更新」**（URLなし）: 検索して関連記事を更新、なければ新規作成\n\n</trigger>\n\n## 実行手順\n\n<procedure>\n\n### 手順1: JSONスキーマを確認\n\n最初に必ず最新のJSONスキーマを確認してください：\n\n```bash\nesa-llm-scoped-guard -help\n```\n\n### 手順2: トリガーによる条件分岐\n\n<decision-criteria name=\"trigger-flow\">\n\n| トリガー | 既存記事取得 | 次の手順 |\n|----------|-------------|---------|\n| 「開発日誌を作って」 | なし | 手順4 |\n| 「開発日誌を更新」+ URL | あり（URL指定） | 手順3 |\n| 「開発日誌を更新」（URLなし） | あり（検索） | 手順3（記事あり）/ 手順4（記事なし） |\n\n</decision-criteria>\n\n#### パターンA: 「開発日誌を作って」の場合\n\n検索・取得をスキップして、**手順4（JSON更新）へ直行**してください。\n\n#### パターンB: 「開発日誌を更新」+ URLの場合\n\n1. ユーザーが提示したesaのURLから`post_number`を抽出（例: `https://yasuhisa.esa.io/posts/123` → `123`）\n\n2. `mcp__esa-mcp-server__read_esa_post`で既存記事を取得：\n   ```\n   postNumber: 123\n   ```\n\n3. 既存記事の内容を確認し、**手順3（同期フェーズ）へ進む**\n\n#### パターンC: 「開発日誌を更新」（URLなし）の場合\n\n1. `mcp__esa-mcp-server__search_esa_posts`で関連記事を検索：\n   ```\n   query: \"in:Claude Code/開発日誌\"\n   sort: \"updated\"\n   order: \"desc\"\n   perPage: 10\n   ```\n\n2. 会話コンテキストから現在のタスクを特定し、検索結果から最も関連性の高い記事を判断\n\n3. **記事あり**: `mcp__esa-mcp-server__read_esa_post`で取得 → 更新モードで**手順3へ**\n\n4. **記事なし**: 新規作成モードで**手順4へ**\n\n### 手順3: 既存記事との同期（更新時のみ）\n\n**目的**: 既存記事をJSONで完全に再現し、差分ゼロの状態を作る\n\n#### 3.1 現状再現JSONの作成\n\n1. 既存記事の内容から、現状を再現するJSONを`.claude_work/dev_diary.json`に作成\n   - `post_number`: 既存記事の番号を指定\n   - `category`: 既存記事のカテゴリをそのまま維持\n   - `name`: 既存記事のタイトル\n   - `body`: 既存記事の本文を構造化形式で完全に再現\n\n#### 3.2 差分ゼロの確認（最大5回リトライ）\n\n2. `validate`で形式確認：\n   ```bash\n   esa-llm-scoped-guard validate -json .claude_work/dev_diary.json\n   ```\n\n3. `diff`で既存記事との差分確認：\n   ```bash\n   esa-llm-scoped-guard diff -json .claude_work/dev_diary.json\n   ```\n\n4. **差分がある場合**: JSONを修正して手順3.2を繰り返す（最大5回まで）\n\n5. **5回試しても差分が残る場合**: ユーザーに報告して判断を仰ぐ\n\n6. **差分ゼロになった場合**: 手順4へ進む\n\n### 手順4: JSON更新\n\n#### 新規作成の場合\n\n1. `Write`ツールで`.claude_work/dev_diary.json`を作成（**ファイル名固定、常に上書き**）\n\n2. JSONの構成内容：\n   - `create_new: true`を指定、`post_number`は含めない\n   - `category`: `Claude Code/開発日誌/yyyy/mm/dd`形式（今日の日付）\n   - `name`: 日付ベースのタイトル\n   - `body`: 会話コンテキストから抽出したタスク情報を構造化形式で作成\n\n#### 更新の場合\n\n1. 手順3で同期したJSONに変更を加える（`Edit`ツール使用）\n   - **重要**: 既存の`category`、`name`、`post_number`は維持すること（`create_new`は含めない）\n   - タスクの追加・更新\n   - GitHub URL状態の反映（下記参照）\n\n2. **GitHub URL状態の確認と反映**:\n\n   a. `body.tasks`から`github_urls`を抽出（URLがなければスキップ）\n\n   b. 各URLの状態と内容をgh CLIで確認\n\n<example name=\"gh-cli-status-check\">\n\n**PRの場合**:\n```bash\ngh pr view <URL> --json state,isDraft,title,body\n```\n\n**Issueの場合**:\n```bash\ngh issue view <URL> --json state,title,body\n```\n\n</example>\n\n   c. <github-status-mapping>に従ってGitHub状態を判定\n\n   d. <status-mapping>に従ってタスクstatusを更新\n\n   e. タスクdescriptionの更新要否を判定（<description-update>参照）\n\n<decision-criteria name=\"description-update\">\n\n以下のいずれかに該当する場合、タスクdescriptionを更新：\n\n| 判定条件 | 説明 |\n|---------|------|\n| タイトル差分 | GitHubタイトルがタスクdescriptionと実質的に異なる（スコープの追加・削除） |\n| 本文の追加スコープ | bodyに、タスクdescriptionにない追加機能・領域が記載されている |\n| 前提/実装変更 | bodyに前提や実装アプローチの変更が記載されている |\n\n</decision-criteria>\n\n   更新内容の形式：\n   - 基本: GitHubタイトルをそのまま使用\n   - スコープ拡大がある場合: タイトル + \"（+ 追加スコープ: ...）\"のように本文の要点を短く追記\n\n### 手順5: 投稿前確認\n\n1. `validate`で形式確認：\n   ```bash\n   esa-llm-scoped-guard validate -json .claude_work/dev_diary.json\n   ```\n\n2. `diff`で差分が意図通りか確認：\n   ```bash\n   esa-llm-scoped-guard diff -json .claude_work/dev_diary.json\n   ```\n\n   - 新規作成: 全行が`+`で表示される（全体の最終確認）\n   - 更新: 意図した変更のみか確認（消しすぎていないか、意図しない変更がないか）\n   - **問題がある場合のみ**ユーザーにdiff結果を表示して確認を求める\n\n3. `preview`で最終的なMarkdownを確認：\n   ```bash\n   esa-llm-scoped-guard preview -json .claude_work/dev_diary.json\n   ```\n\n   - 意図しないHTMLタグ（`<details>`や`<summary>`など）が含まれていないか確認\n   - Markdown構造が正しいか確認\n   - preview結果をユーザーに表示して最終確認を求める\n\n### 手順6: 投稿\n\nユーザーの承認後、投稿を実行：\n\n```bash\nesa-llm-scoped-guard post -json .claude_work/dev_diary.json\n```\n\n### 手順7: 結果報告\n\n- **成功時**: 記事URLをユーザーに報告\n- **失敗時**: エラー内容を確認し、JSONを修正して手順5から再実行\n\n</procedure>\n\n## 参照データ\n\n<context name=\"github-status-mapping\">\n\n| リソース | 条件 | 判定結果 |\n|----------|------|----------|\n| PR | state=MERGED | マージ済み |\n| PR | state=OPEN, isDraft=true | ドラフト（WIP） |\n| PR | state=OPEN, isDraft=false | レビュー中 |\n| PR | state=CLOSED | クローズ |\n| Issue | state=OPEN | オープン |\n| Issue | state=CLOSED | クローズ済み |\n\n</context>\n\n<context name=\"status-mapping\">\n\n| GitHub状態 | タスクstatus |\n|------------|--------------|\n| PRがマージ済み | `completed` |\n| PRがドラフト（WIP） | `in_progress` |\n| PRがレビュー中 | `in_review` |\n| PRがクローズ（マージなし） | （変更なし） |\n| Issueがクローズ | `completed` |\n| Issueがオープン | （変更なし） |\n\n</context>\n"
      },
      "plugins": [
        {
          "name": "syou6162-plugin",
          "source": "./",
          "description": "Yasuhisa Yoshida's personal custom slash commands for Claude Code",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add syou6162/claude-code-commands",
            "/plugin install syou6162-plugin@syou6162-marketplace"
          ]
        }
      ]
    }
  ]
}