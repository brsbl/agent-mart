{
  "author": {
    "id": "matlab",
    "display_name": "MATLAB Development & AI Coding Projects",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/100243663?v=4",
    "url": "https://github.com/matlab",
    "bio": "Development tools for MATLAB® | AI Prompts for MATLAB Copilot, MATLAB Skills for Claude Code, MATLAB MCP for agentic workflows, and Slash Commands for AI coding",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 5,
      "total_stars": 20,
      "total_forks": 8
    }
  },
  "marketplaces": [
    {
      "name": "matlab-skills",
      "version": null,
      "description": "A collection of agent skills for MATLAB development, including Live Script generation, unit testing, performance optimization, HTML/JavaScript app building, and digital filter design.",
      "owner_info": {
        "name": "The MathWorks, Inc."
      },
      "keywords": [],
      "repo_full_name": "matlab/skills",
      "repo_url": "https://github.com/matlab/skills",
      "repo_description": "A collection of Agent Skills for MATLAB development. Skills are specialized instruction sets that extend a coding agent's capabilities for specific tasks, automatically activating when needed.",
      "homepage": "https://www.mathworks.com/matlabcentral/discussions/ai",
      "signals": {
        "stars": 20,
        "forks": 8,
        "pushed_at": "2026-01-28T23:16:43Z",
        "created_at": "2025-10-25T15:28:46Z",
        "license": "NOASSERTION"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1335
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 976
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 9629
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/matlab-digital-filter-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/matlab-digital-filter-design/SKILL.md",
          "type": "blob",
          "size": 7018
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/INDEX.md",
          "type": "blob",
          "size": 2817
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/best-practices.md",
          "type": "blob",
          "size": 10699
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/cards",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/cards/designfilt.md",
          "type": "blob",
          "size": 4264
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/cards/efficient-filtering.md",
          "type": "blob",
          "size": 6183
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/cards/filter-analyzer.md",
          "type": "blob",
          "size": 2982
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/cards/general-iir-fir.md",
          "type": "blob",
          "size": 2766
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/cards/multirate-offline.md",
          "type": "blob",
          "size": 2242
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/cards/multirate-streaming.md",
          "type": "blob",
          "size": 3079
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/cards/multistage-ifir.md",
          "type": "blob",
          "size": 2813
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/efficient-filtering.md",
          "type": "blob",
          "size": 15082
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/filter-analyzer.md",
          "type": "blob",
          "size": 18481
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/multirate.md",
          "type": "blob",
          "size": 13900
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/multistage-ifir.md",
          "type": "blob",
          "size": 8713
        },
        {
          "path": "skills/matlab-digital-filter-design/knowledge/patterns.md",
          "type": "blob",
          "size": 16282
        },
        {
          "path": "skills/matlab-live-script",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/matlab-live-script/SKILL.md",
          "type": "blob",
          "size": 5920
        },
        {
          "path": "skills/matlab-performance-optimizer",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/matlab-performance-optimizer/SKILL.md",
          "type": "blob",
          "size": 12834
        },
        {
          "path": "skills/matlab-test-generator",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/matlab-test-generator/SKILL.md",
          "type": "blob",
          "size": 12287
        },
        {
          "path": "skills/matlab-uihtml-app-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/matlab-uihtml-app-builder/SKILL.md",
          "type": "blob",
          "size": 24188
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"matlab-skills\",\n  \"owner\": {\n    \"name\": \"The MathWorks, Inc.\"\n  },\n  \"metadata\": {\n    \"description\": \"A collection of agent skills for MATLAB development, including Live Script generation, unit testing, performance optimization, HTML/JavaScript app building, and digital filter design.\",\n    \"version\": \"1.0.1\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"matlab-skills\",\n      \"source\": \"./\",\n      \"description\": \"A collection of agent skills for MATLAB development\",\n      \"version\": \"1.0.1\",\n      \"author\": {\n        \"name\": \"The MathWorks, Inc.\"\n      },\n      \"homepage\": \"https://github.com/matlab/skills\",\n      \"repository\": \"https://github.com/matlab/skills\",\n      \"license\": \"BSD-3-Clause\",\n      \"keywords\": [\n        \"matlab\",\n        \"live-scripts\",\n        \"testing\",\n        \"performance\",\n        \"optimization\",\n        \"vectorization\",\n        \"code-generation\",\n        \"scientific-computing\",\n        \"data-analysis\",\n        \"programming\",\n        \"html\",\n        \"javascript\",\n        \"uihtml\",\n        \"web\",\n        \"interactive\",\n        \"gui\",\n        \"webapp\",\n        \"filter\",\n        \"digital-filter\",\n        \"signal-processing\",\n        \"fir\",\n        \"iir\",\n        \"lowpass\",\n        \"highpass\",\n        \"bandpass\",\n        \"bandstop\",\n        \"notch\",\n        \"dsp\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"matlab-skills\",\n  \"version\": \"1.0.1\",\n  \"description\": \"A collection of agent skills for MATLAB development, including Live Script generation, unit testing, performance optimization, HTML/JavaScript app building, and digital filter design.\",\n  \"author\": {\n    \"name\": \"The MathWorks, Inc.\",\n    \"url\": \"https://github.com/matlab/skills\"\n  },\n  \"homepage\": \"https://github.com/matlab/skills\",\n  \"repository\": \"https://github.com/matlab/skills\",\n  \"license\": \"BSD-3-Clause\",\n  \"keywords\": [\n    \"matlab\",\n    \"live-scripts\",\n    \"testing\",\n    \"performance\",\n    \"optimization\",\n    \"vectorization\",\n    \"code-generation\",\n    \"scientific-computing\",\n    \"data-analysis\",\n    \"programming\",\n    \"html\",\n    \"javascript\",\n    \"uihtml\",\n    \"web\",\n    \"interactive\",\n    \"gui\",\n    \"webapp\",\n    \"filter\",\n    \"digital-filter\",\n    \"signal-processing\",\n    \"fir\",\n    \"iir\",\n    \"lowpass\",\n    \"highpass\",\n    \"bandpass\",\n    \"bandstop\",\n    \"notch\",\n    \"dsp\"\n  ]\n}\n",
        "README.md": "# MATLAB Skills for Coding Agents\n\nA collection of [Agent Skills](https://agentskills.io) for MATLAB development using coding agents. Skills are specialized instruction sets that extend the capabilities of coding agents for specific tasks, automatically activating when needed.\n\n## What are Skills?\n\nSkills are modular, portable capabilities that work across coding agents:\n\n- **Composable**: Skills stack together automatically when needed\n- **Efficient**: Only load when relevant to your current task\n- **Powerful**: Combine instructions with executable code for reliable results\n\n## Available Skills\n\n### MATLAB Live Script Generator\n**Skill ID**: `matlab-live-script`\n\nCreates properly formatted MATLAB plain text Live Scripts (.m files) with rich text documentation, equations, and visualizations. Automatically handles:\n\n- Section formatting with `%[text]` markers\n- LaTeX equation rendering with double backslashes\n- Bulleted lists with proper termination\n- Required appendix formatting\n- Plot and figure management\n- Code and documentation integration\n\n**When it activates**: Creating MATLAB scripts, educational content, Live Scripts, or .m files with documentation.\n\n### MATLAB Test Generator\n**Skill ID**: `matlab-test-generator`\n\nCreates unit tests using the MATLAB Testing Framework. Generates test classes, test methods, and test suites following best practices:\n\n- Class-based test structure with `matlab.unittest.TestCase`\n- Proper test method naming and organization\n- Comprehensive assertion methods (`verifyEqual`, `verifyError`, etc.)\n- Parameterized tests for data-driven testing\n- Setup and teardown methods for test fixtures\n- Test tagging and selective execution\n- Mock objects and performance testing\n\n**When it activates**: Generating test files, test cases, unit tests, test suites, or when testing MATLAB code is requested.\n\n### MATLAB Performance Optimizer\n**Skill ID**: `matlab-performance-optimizer`\n\nOptimizes MATLAB code for better performance through vectorization, memory management, and profiling guidance:\n\n- Vectorization of loops and operations\n- Array preallocation strategies\n- Memory optimization techniques (data types, sparse matrices)\n- Profiling and benchmarking workflows\n- Built-in function usage over manual implementations\n- Parallel computing with `parfor` and GPU arrays\n- Algorithm-specific optimizations\n- Performance pitfall identification\n\n**When it activates**: User requests optimization, mentions slow code, performance issues, speed improvements, or asks to make code faster or more efficient.\n\n### MATLAB uihtml App Builder\n**Skill ID**: `matlab-uihtml-app-builder`\n\nBuilds interactive web applications using HTML/JavaScript interfaces with MATLAB computational backends via the uihtml component:\n\n- Bidirectional HTML-MATLAB communication patterns\n- Event handling and data transfer strategies\n- Security and input validation best practices\n- Complete working examples (calculator, visualizer, forms)\n- Modern UI design with CSS styling\n- Error handling and debugging techniques\n- Performance optimization for web apps\n- Testing strategies for HTML/MATLAB integration\n\n**When it activates**: Creating HTML-based MATLAB apps, JavaScript MATLAB interfaces, web UIs, interactive GUIs, or when user mentions uihtml, HTML, JavaScript, web apps, or web interfaces.\n\n### MATLAB Digital Filter Design\n**Skill ID**: `matlab-digital-filter-design`\n\nDesigns and validates digital filters in MATLAB using Signal Processing Toolbox and DSP System Toolbox:\n\n- FIR and IIR filter design (lowpass, highpass, bandpass, bandstop, notch)\n- Architecture selection guidance (single-stage vs efficient alternatives)\n- `designfilt()` workflow with proper sample rate handling\n- Filter Analyzer for visual comparison of designs\n- Multirate and multistage filter optimization for narrow transitions\n- Streaming (causal) vs offline (batch) mode support\n- Zero-phase filtering with `filtfilt()` for offline processing\n- Numerical verification of passband ripple and stopband attenuation\n\n**When it activates**: Cleaning up noisy signals, removing interference, filtering signals, designing FIR/IIR filters, or comparing filters in Filter Analyzer.\n\n## Installation & Usage\n\n### Claude Code (CLI)\n\n**Recommended**: Install all MATLAB agent skills using the plugin marketplace:\n\n```bash\n# (Step 1) Add the marketplace to Claude Code\n/plugin marketplace add matlab/skills\n\n# (Step 2) Install all the MATLAB Agent Skills\n/plugin install matlab-skills@matlab-skills\n```\n\nThis installs all MATLAB skills (`matlab-live-script`, `matlab-test-generator`, `matlab-performance-optimizer`, `matlab-uihtml-app-builder`, `matlab-digital-filter-design`) in one command. Skills automatically activate when Claude detects relevant tasks.\n\n**Alternative**: Manually install to your personal skills directory:\n\n```bash\n# Clone the repository\ngit clone https://github.com/matlab/skills.git\n\n# Copy all skills to your Claude skills directory\ncp -r skills/skills/* ~/.claude/skills/\n```\n\nOnce installed, just ask Claude to \"create a MATLAB Live Script\" or \"optimize this code\" and the appropriate skill will load automatically.\n\n### Claude.ai (Web) and Claude Desktop\n\nSkills are available to Pro, Max, Team, and Enterprise users. Each skill must be uploaded separately as a ZIP file.\n\n**Uploading Skills:**\n\n1. Open **Settings** → **Capabilities**\n2. Enable Skills (Team/Enterprise admins must enable organization-wide first)\n3. Click **Upload Skill** for each skill you want to add\n\n**Creating ZIP Files:**\n\nEach skill requires a ZIP file with `SKILL.md` at the root level. Some skills include additional resource folders (like `knowledge/`) that must be included.\n\n*Single skill (macOS/Linux):*\n\n```bash\ncd skills/<skill-name>\nzip -r ../<skill-name>.zip .\n```\n\n*Single skill (Windows PowerShell):*\n\n```powershell\ncd skills\nCompress-Archive -Path \"<skill-name>\\*\" -DestinationPath \"<skill-name>.zip\"\n```\n\n*All skills at once (macOS/Linux):*\n\n```bash\ncd skills\nfor d in */; do (cd \"$d\" && zip -r \"../${d%/}.zip\" .); done\n```\n\n*All skills at once (Windows PowerShell):*\n\n```powershell\ncd skills\nGet-ChildItem -Directory | ForEach-Object {\n    Compress-Archive -Path \"$($_.Name)\\*\" -DestinationPath \"$($_.Name).zip\" -Force\n}\n```\n\nUpload the ZIP files to get the MATLAB skills collection. Skills activate automatically when Claude detects relevant tasks.\n\n### Claude API\n\nUse the Skills API for programmatic control:\n\n```python\nimport anthropic\n\nclient = anthropic.Anthropic(api_key=\"your-api-key\")\n\nresponse = client.messages.create(\n    model=\"claude-sonnet-4-5-20250929\",\n    max_tokens=4096,\n    skills=[\"matlab-live-script\"],\n    messages=[\n        {\"role\": \"user\", \"content\": \"Create a Live Script showing Fourier transforms\"}\n    ]\n)\n```\n\n**Requirements**:\n- Skills API access (see [API documentation](https://docs.anthropic.com/))\n- Code Execution Tool beta enabled\n\n## Contributing\n\nWe welcome contributions! Whether you want to:\n\n- Add new MATLAB skills (code generation, debugging, testing, etc.)\n- Improve existing skills\n- Fix bugs or typos\n- Suggest enhancements\n\nPlease see [CONTRIBUTING.md](CONTRIBUTING.md) for detailed guidelines.\n\n### Quick Start for Contributors\n\n1. Fork this repository\n2. Create a new skill directory: `skills/your-skill-name/`\n3. Add a `SKILL.md` file with proper frontmatter\n4. Test thoroughly with a coding agent\n5. Submit a pull request\n\n## Skill Development Resources\n\n- [Official Skills Documentation](https://code.claude.com/docs/en/skills) - Claude Code documentation for using and creating skills\n- [Agent Skills Specification](https://agentskills.io/specification) - Complete format specification for SKILL.md files\n- [Agent Skills Repository](https://github.com/agentskills/agentskills) - Specification and documentation for Agent Skills\n- [Anthropic Skills Repository](https://github.com/anthropics/skills) - Example skills demonstrating Agent Skills capabilities\n- [Claude Code Plugin Guide](https://code.claude.com/docs/en/plugins) - Guide for installing and managing skill plugins\n\n## Related Projects\n\n- [matlab/matlab-mcp-core-server](https://github.com/matlab/matlab-mcp-core-server) - Official MATLAB MCP Server for running MATLAB using AI applications like Claude Code and VS Code\n- [matlab/rules](https://github.com/matlab/rules) - MATLAB coding rules and guidelines optimized for AI coding assistants\n- [matlab/prompts](https://github.com/matlab/prompts) - Curated collection of AI prompts for MATLAB development\n- [matlab/slash-commands](https://github.com/matlab/slash-commands) - Slash commands for streamlining MATLAB development workflows in Claude Code\n\n## License\n\nThis project is licensed under the MathWorks BSD-3-Clause License - see the [LICENSE](LICENSE) file for details.\n\nCopyright (c) 2025-2026, The MathWorks, Inc. All rights reserved.\n\n## Community\n\n- **Issues**: Report bugs or request features via [GitHub Issues](https://github.com/matlab/skills/issues)\n- **Discussions**: Share ideas and ask questions in [MATLAB Central GenAI Discussions Channel](https://www.mathworks.com/matlabcentral/discussions/ai)\n\n---\n\n**Supported Coding Agents**: Agent Skills are supported by [Claude Code](https://claude.ai/code), [Claude.ai](https://claude.ai), [Cursor](https://cursor.com), [VS Code](https://code.visualstudio.com), [GitHub Copilot](https://github.com), [Gemini CLI](https://geminicli.com), [OpenAI Codex](https://developers.openai.com/codex), [Amp](https://ampcode.com), [Goose](https://block.github.io/goose), [Roo Code](https://roocode.com), and [many more](https://agentskills.io). Feature availability may vary by plan and platform.\n",
        "skills/matlab-digital-filter-design/SKILL.md": "---\nname: matlab-digital-filter-design\ndescription: Designs and validates digital filters in MATLAB. Use when cleaning up noisy signals, removing interference, filtering signals, designing FIR/IIR filters (lowpass/highpass/bandpass/bandstop/notch), or comparing filters in Filter Analyzer.\n---\n\n# MATLAB Digital Filter Design Expert\n\nYou design, implement, and validate digital filters in MATLAB (Signal Processing Toolbox + DSP System Toolbox). You help users choose the right architecture (single-stage vs efficient alternatives), generate correct code, and verify the result with plots + numbers.\n\n## Must-follow\n- **Read INDEX.md**\n- **Always write to .m files.** Never put multi-line MATLAB code directly in `evaluate_matlab_code`. Write to a `.m` file, run with `run_matlab_file`, edit on error. This saves tokens on error recovery.\n- **Preflight before ANY MATLAB call.** Before calling ANY function listed in INDEX.md — via `evaluate_matlab_code`, `run_matlab_file`, or `.m` file — read the required cards first. State `Preflight: [cards]` at top of response. No exceptions.\n- **Do not guess key requirements.** If *Mode* (streaming vs offline) or *Phase requirement* is not stated, **ask**.  \n  You may analyze the signal first (spectrum, peaks, bandwidth), but you must not silently commit to `filtfilt()` or a linear‑phase design without the user’s intent.\n- **No Hz designs without Fs.** If `Fs` is unknown, **STOP and ask** (unless the user explicitly wants normalized frequency).\n- **Always pin the sample rate.**\n  - `designfilt(..., SampleRate=Fs)`\n  - `freqz(d, [], Fs)` / `grpdelay(d, [], Fs)` (plot in **Hz**)\n- **IIR stability:** prefer **SOS/CTF** forms (avoid high‑order `[b,a]` polynomials).\n\n### MATLAB Code/Function Call Best Practise\n- Write code to a `.m` file first, then run with `run_matlab_file`\n- If errors occur, edit the file and rerun — don't put all code inline in tool calls\n\n1. List MATLAB functions you'll call\n2. Check `knowledge/INDEX.md` for each (function-level + task-level tables)\n3. Read required cards\n4. State at response top:\n   ```\n   Preflight: cards/filter-analyzer.md, cards/designfilt.md\n   ```\n   or `Preflight: none required (no indexed functions)`\n\n## Planning workflow (phases)\n\n### Phase 1: Signal Analysis\n- Use MCP to analyze input data (spectrum, signal length, interference location, etc.)\n- Compute `trans_pct` and identify interference characteristics\n- This gives accurate estimates instead of guesses\n\n### Phase 2: Clarify Intent (before any overview or comparison)\n**After signal analysis, ask Mode + Phase if not stated:**\n- **Mode**: streaming (causal) | offline (batch)\n- **Phase**: zero-phase | linear-phase | don't-care\n\nUse `AskUserQuestion` with clear descriptions:\n- Streaming = real-time, sample-by-sample, must be causal\n- Offline = batch processing, can use `filtfilt()` for zero-phase\n- Zero-phase = no time shift, preserves transient shape (offline only)\n- Linear-phase = constant group delay, works both modes\n- Don't-care = minimize compute, phase distortion acceptable\n\n**Wait for answer before showing any approach comparison or overview.**\n\n### Phase 3: Architecture Selection (show only viable options)\n- Open `efficient-filtering.md` if `trans_pct < 2%`\n- Show **only viable candidates** given Mode + Phase constraints\n- Explicitly state excluded families with one-line reason\n- Use Filter Analyzer for visual comparison\n\n---\n\n## Design intake checklist\n\n### Checklist A: Required signal + frequency spec (cannot proceed without)\n\n- [ ] `Fs` (Hz)\n- [ ] Response type: lowpass / highpass / bandpass / bandstop / notch\n- [ ] Edge frequencies in Hz\n  - low/high: `Fpass`, `Fstop`\n  - bandpass/bandstop: `Fpass1`, `Fstop1`, `Fpass2`, `Fstop2`\n  - notch: center `F0` (+ bandwidth or Q)\n\nIf any item is missing → **ask**.\n\n### Checklist B: Required intent for architecture choice (must ask if unknown)\n\n- [ ] **Mode**: streaming (causal) | offline (batch)\n- [ ] **Phase**: zero‑phase | linear‑phase | don’t‑care\n- [ ] **Magnitude constraints** (make explicit):\n  - `Rp_dB` passband ripple (default **1 dB**)\n  - `Rs_dB` stopband attenuation (default **60 dB**)\n  - for asymmetric band specs: allow `Rs1_dB`, `Rs2_dB`\n\nIf Mode or Phase is unknown: ask **1–2** clarifying questions and stop.  \nDo **not** assume “offline” or “zero‑phase”.\n\n### Standard spec block (always include)\n\n```text\nFs = ___ Hz\nResponse = lowpass | highpass | bandpass | bandstop | notch\nEdges (Hz) = ...\nMagnitude = Rp = ___ dB, Rs = ___ dB  (or Rs1/Rs2)\nMode = streaming | offline\nPhase = zero-phase | linear-phase | don't-care\nConstraints = latency/CPU/memory/fixed-point (if any)\n```\n\n---\n\n## Architecture checkpoint\n\nCompute these and state them before finalizing an approach:\n\n- `trans_bw = Fstop - Fpass`\n- `trans_pct = 100 * trans_bw / Fs`\n- `M_max = floor(Fs/(2*Fstop))` (only meaningful for lowpass-based multirate ideas)\n\n**Decision rule**\n\n- `trans_pct > 5%` → single‑stage FIR or IIR is usually fine\n- `2% ≤ trans_pct ≤ 5%` → single‑stage is possible; mention efficient alternatives if cost/latency matters\n- `trans_pct < 2%` → **STOP and do a narrow‑transition comparison**\n  Open `knowledge/cards/efficient-filtering.md`.\n\n**Important:** for `trans_pct < 2%`, do **not** blindly show all four families.  \nSelect and present only the **viable** candidates given Mode + Phase, and explicitly mark excluded families (with a one‑line reason).\n\n---\n\n## Design + verify workflow\n\n1. **Feasibility / order sanity check**\n   - Default: let `designfilt` choose minimum order from `Rp/Rs`, then query `filtord(d)`.\n   - Optional (especially for narrow transitions): use `kaiserord` / `firpmord` to estimate FIR length for planning (not as “the truth”).\n\n2. **Design candidates**\n   - Prefer `designfilt()` with explicit `Rp/Rs` and `SampleRate=Fs`.\n   - Streaming IIR: prefer `SystemObject=true` (returns `dsp.SOSFilter`) for stable, stateful filtering.\n   - Offline zero‑phase: `filtfilt()` is allowed, but you must state:\n     - forward‑backward filtering **squares magnitude** (≈ doubles dB attenuation) and effectively doubles order.\n\n3. **Compare visually when there's a choice**\n   - **Use `filterAnalyzer()`** for comparing ≥2 designs — do not write custom freqz/grpdelay plots\n   - Open `knowledge/cards/filter-analyzer.md` first\n   - Minimum displays: magnitude + group delay (add impulse response when latency is a concern)\n\n4. **Verify with numbers (not just plots)**\n   - Worst‑case passband ripple and stopband attenuation vs spec.\n   - For `filtfilt()`, verify the **effective** response (magnitude squared).\n\n5. **Deliver the output**\n   - Specs recap\n   - Derived metrics (`trans_pct`, order/taps, MPIS if relevant)\n   - Chosen architecture + why\n   - MATLAB code\n   - Verification snippet + results\n   - Implementation form (digitalFilter vs System object, SOS/CTF export)\n\nThat’s the whole job: make the workflow predictable, and make the assumptions impossible to miss.\n",
        "skills/matlab-digital-filter-design/knowledge/INDEX.md": "# Knowledge Index\n\n**Cards contain critical gotchas. You MUST read the relevant card before writing any code that uses the functions listed below. Skipping cards causes errors.**\n\n- **Cards**: Short, task-focused. Read before calling specific functions.\n- **Guides**: Deep reference. Read when you need full context.\n\n---\n\n## Function-Level Routing (read the card or you WILL hit errors)\n\n| Function / Pattern | Card to read |\n|--------------------|--------------|\n| `designfilt(...)` any response | `cards/designfilt.md` |\n| `iirnotch(...)`, `iircomb(...)` | `cards/designfilt.md` |\n| `ifir(...)`, `design(..., 'ifir')` | `cards/multistage-ifir.md` |\n| `filterAnalyzer(...)` | `cards/filter-analyzer.md` |\n| `dsp.FIRDecimator`, `dsp.FIRInterpolator` | `cards/multirate-streaming.md` |\n| `resample(...)` for filtering | `cards/multirate-offline.md` |\n| High-order IIR (>8), long FIR (>100 taps), `freqz`/`grpdelay` | `cards/general-iir-fir.md` |\n\n---\n\n## Task-Level Routing\n\n| Trigger / task | Card to read | Guide (if needed) |\n|----------------|--------------|-------------------|\n| `trans_pct < 2%` or \"very sharp / tight transition\" | `cards/efficient-filtering.md` | `efficient-filtering.md` |\n| Cost comparison / \"fastest/cheapest\" / MPIS | `cards/efficient-filtering.md` | `efficient-filtering.md` |\n| Using **Filter Analyzer** (`filterAnalyzer`, session mgmt, overlays) | `cards/filter-analyzer.md` | `filter-analyzer.md` |\n| **Multirate OFFLINE** (rate change + zero-phase) | `cards/multirate-offline.md` | `multirate.md` |\n| **Multirate STREAMING** (polyphase System objects) | `cards/multirate-streaming.md` | `multirate.md` |\n| **Constant-rate multistage FIR** (IFIR method) | `cards/multistage-ifir.md` | `multistage-ifir.md` |\n\n---\n\n## Card Summary\n\n| Card | Purpose | ~Lines |\n|------|---------|--------|\n| `cards/designfilt.md` | Response types, params, gotchas | ~110 |\n| `cards/general-iir-fir.md` | High-order IIR, long FIR, freqz, filtfilt | ~80 |\n| `cards/efficient-filtering.md` | Narrow transitions, MPIS comparison | ~130 |\n| `cards/filter-analyzer.md` | Filter Analyzer API | ~100 |\n| `cards/multirate-offline.md` | Offline zero-phase with rate change | ~60 |\n| `cards/multirate-streaming.md` | Streaming polyphase pipelines | ~75 |\n| `cards/multistage-ifir.md` | IFIR at constant rate | ~95 |\n\n---\n\n## Guides (deep reference, rarely needed full)\n\n| Guide | Content | ~Lines |\n|-------|---------|--------|\n| `patterns.md` | Streaming wrappers, advanced patterns | ~400 |\n| `best-practices.md` | Methodology, validation flow | ~375 |\n| `filter-analyzer.md` | Full Filter Analyzer reference | ~515 |\n| `multirate.md` | Complete multirate theory + examples | ~405 |\n| `efficient-filtering.md` | Deep dive on narrow transitions | ~375 |\n| `multistage-ifir.md` | IFIR theory and variants | ~290 |\n",
        "skills/matlab-digital-filter-design/knowledge/best-practices.md": "# Filter Design Best Practices\n\nGuidelines for robust filter design, validation workflows, and professional interactions. Consult this file when you need guidance on methodology and approach.\n\n## Table of Contents\n- [Core Principles](#core-principles)\n- [Provide Complete Solutions](#provide-complete-solutions)\n- [Documentation Usage Strategy](#documentation-usage-strategy)\n- [Common Tasks Reference](#common-tasks-reference)\n- [Example Interaction Pattern](#example-interaction-pattern)\n- [Validation Workflow](#validation-workflow)\n- [Architecture Decision Workflow](#architecture-decision-workflow)\n- [Streaming vs Offline](#streaming-vs-offline)\n- [Performance Optimization](#performance-optimization)\n- [Quick Lookup](#quick-lookup)\n\n---\n\n## Core Principles\n\n### Always Consider\n\n1. **Sample Rate Implications**\n   - Frequency specifications are relative to Fs/2 (Nyquist)\n   - Narrow transition bands (< 2% of Fs) require special handling\n   - Plot in Hz for clarity: `freqz(d, [], Fs)`\n\n2. **Filter Order vs Performance Trade-offs**\n   - Higher order = sharper cutoff but more computation\n   - IIR = fewer coefficients but non-linear phase\n   - FIR = linear phase but longer filters\n\n3. **Computational Efficiency for Real-Time**\n   - Prefer IIR for streaming with sharp cutoff\n   - Use multistage for narrow transition bands\n   - Consider `fftfilt()` for long FIR (> 100 taps)\n\n4. **Numerical Stability for IIR**\n   - Always use SOS or CTF form (not `[b,a]`)\n   - Use `designfilt()` which handles stability internally\n   - For high-order IIR (> 8), verify pole locations\n\n---\n\n## Provide Complete Solutions\n\nEvery filter design response should include:\n\n### 1. Design Code\n```matlab\nd = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n```\n\n### 2. Visualization Code\n```matlab\nfigure;\nfreqz(d, [], Fs);\ngrid on;\ntitle('Filter Response');\n```\n\n### 3. Parameter Explanation\n- Why this filter type was chosen\n- Trade-offs considered\n- Key specifications achieved\n\n### 4. Validation Steps\n- How to verify the design meets specs\n- Test signal suggestions\n- Performance metrics to check\n\n---\n\n## Documentation Usage Strategy\n\n### Start Broad, Drill Down\n\n1. **First**: Check `docs/INDEX.md` for file summaries\n2. **Overview**: Read `signal_filter-design.md` for concepts\n3. **Details**: Drill into `ref_designfilt.md` for exact syntax\n4. **Examples**: Check `examples/` for complete workflows\n\n### Reference During Design\n\n- **Verify syntax** against official docs before executing\n- **Check examples** in documentation for similar problems\n- **Confirm parameters** for edge cases (bandpass, notch, etc.)\n\n---\n\n## Common Tasks Reference\n\n### Task: Design Lowpass Filter\n\n1. **Check quick-reference.md** for parameter templates\n2. **Read relevant section** from `ref_designfilt.md`\n3. **Generate MATLAB code** using `designfilt()`\n4. **Test if MCP available** by running code\n5. **Provide visualization** code for frequency response\n\n### Task: Choose Design Method\n\n**Consult** `signal_filter-design.md` for:\n- Design method comparison\n- When to use each approach\n- Trade-offs between methods\n\n**Reference** `ref_designfilt.md` for:\n- Available methods per filter type\n- Method-specific parameters\n- Examples using each method\n\n### Task: Analyze Existing Filter\n\n1. **Guide user** to use Filter Analyzer app\n2. **Reference** `ref_filteranalyzer-app.md` for:\n   - How to import filters\n   - Available analysis types\n   - Interpretation of results\n\n### Task: Apply Filter to Data\n\n1. **Determine requirements**:\n   - Need zero phase? → Use `filtfilt()`\n   - Long FIR filter? → Consider `fftfilt()`\n   - Streaming/real-time? → Use `dsp.SOSFilter`\n   - Standard application? → Use `filter()`\n\n2. **Reference appropriate documentation**:\n   - `ref_filtfilt.md` for zero-phase requirements\n   - `ref_fftfilt.md` for performance optimization\n   - `ref_filter.md` for state management\n\n---\n\n## Example Interaction Pattern\n\n**User Request**: \"I need a bandpass filter for 50-100 Hz signal at 1000 Hz sampling rate\"\n\n**Your Response Pattern**:\n\n### Step 1: Clarify Requirements\nAsk about:\n- FIR or IIR preference?\n- Phase requirements (linear, zero, minimum)?\n- Stopband attenuation needed?\n\n### Step 2: Read Documentation\nCheck `ref_designfilt.md` for bandpass filter syntax\n\n### Step 3: Recommend Approach\nSuggest FIR equiripple (linear phase) or IIR Butterworth (minimum order)\n\n### Step 4: Generate Code\nProvide complete `designfilt()` code with all parameters\n\n### Step 5: Test (if MCP available)\nExecute and show frequency response\n\n### Step 6: Guide Application\nExplain how to apply with `filter()` or `filtfilt()`\n\n---\n\n## Validation Workflow\n\n### Pre-Application Checks\n\n```matlab\n% 1) Order (MATLAB's actual order)\nfprintf(\"Filter order: %d\\n\", filtord(d));\n\n% 2) Frequency response (Hz-aware)\nNfft = 8192;\n[h, f] = freqz(d, Nfft, Fs);\nmag_dB = 20*log10(abs(h) + eps);\n\n% 3) If the final application is filtfilt(d,x), verify the *effective* response\nuse_filtfilt = false;  % set true if you will apply filtfilt()\nif use_filtfilt\n    mag_dB = 2*mag_dB;  % |H|^2 -> dB doubles\nend\n\n% 4) Build pass/stop masks by RESPONSE TYPE\nresponseType = \"lowpass\";  % \"highpass\" | \"bandpass\" | \"bandstop\"\n\nswitch responseType\n    case \"lowpass\"\n        pass = f <= Fpass;\n        stop = f >= Fstop;\n    case \"highpass\"\n        pass = f >= Fpass;\n        stop = f <= Fstop;\n    case \"bandpass\"\n        pass = (f >= Fpass1) & (f <= Fpass2);\n        stop = (f <= Fstop1) | (f >= Fstop2);\n    case \"bandstop\"\n        pass = (f <= Fpass1) | (f >= Fpass2);\n        stop = (f >= Fstop1) & (f <= Fstop2);\nend\n\n% 5) Measured specs (worst-case)\nRp_meas_dB = max(mag_dB(pass)) - min(mag_dB(pass));\nRs_meas_dB = -max(mag_dB(stop));\n\nfprintf(\"Measured ripple: %.3f dB (spec %.3f dB)\\n\", Rp_meas_dB, Rp);\nfprintf(\"Measured stopband attenuation: %.1f dB (spec %.1f dB)\\n\", Rs_meas_dB, Rs);\n\n% 6) Plot (optional but recommended)\nfigure; plot(f, mag_dB); grid on;\nxlabel(\"Frequency (Hz)\"); ylabel(\"Magnitude (dB)\");\ntitle(\"Magnitude Response (verified in Hz)\");\n```\n\n### Post-Filtering Checks\n\n```matlab\n% 1. Visual comparison\nfigure;\nplot(t, x, 'b', t, y, 'r');\nlegend('Original', 'Filtered');\n\n% 2. Spectrum comparison\nfigure;\npwelch(x, [], [], [], Fs); hold on;\npwelch(y, [], [], [], Fs);\nlegend('Original', 'Filtered');\n\n% 3. SNR improvement (if ground truth available)\nsnr_before = 10*log10(sum(clean.^2) / sum((noisy - clean).^2));\nsnr_after = 10*log10(sum(clean.^2) / sum((filtered - clean).^2));\nfprintf('SNR Improvement: %.1f dB\\n', snr_after - snr_before);\n```\n\n---\n\n## Architecture Decision Workflow\n\n### Pre-Design Check (MANDATORY)\n\nFor EVERY filter design, calculate:\n\n```matlab\n% Transition width (Δf) should match the RESPONSE TYPE.\n% Use the *constraining* transition (smallest transition band) in Hz.\n%\n% lowpass:   Δf = Fstop - Fpass\n% highpass:  Δf = Fpass - Fstop\n% bandpass:  Δf = min(Fpass1 - Fstop1, Fstop2 - Fpass2)\n% bandstop:  Δf = min(Fstop1 - Fpass1, Fpass2 - Fstop2)\n\ndelta_f = ...;                         % fill based on response type (Hz)\ntrans_pct = 100 * (delta_f / Fs);      % Transition width as % of sample rate\n\n% FIR length heuristic (sanity check only; not a guarantee)\nN_est = (Rs * Fs) / (22 * delta_f);\n\n% Max decimation factor is straightforward for LOWPASS cases:\n% M_max ≈ floor(Fs / (2 * Fstop))\n% For highpass/band* cases, safe decimation depends on spectral placement and is not a single formula.\nM_max = floor(Fs / (2 * Fstop));\n```\n\n\n        ### Prefer MATLAB-Native FIR Order Estimators (recommended)\n\n        The heuristic `N_est = (Rs * Fs)/(22 * Δf)` is **sanity-check only**. For a more standard, MATLAB-native estimate:\n\n        - **Kaiser window estimate**: `kaiserord` (good quick order estimate for windowed FIR)\n        - **Equiripple estimate**: `firpmord` (order estimate for Parks–McClellan FIR)\n\n        ```matlab\n        % Convert dB specs to linear deviations\n        dev_p = (10^(Rp/20)-1) / (10^(Rp/20)+1);\n        dev_s = 10^(-Rs/20);\n\n        % LOWPASS example (adapt f/a for other responses):\n        f = [Fpass Fstop];     % Hz\n        a = [1 0];             % desired amplitudes in each band\n        dev = [dev_p dev_s];   % linear deviations\n\n        [N_kaiser, Wn, beta, ftype] = kaiserord(f, a, dev, Fs);\n        [N_pm, fo, ao, w] = firpmord(f, a, dev, Fs);\n\n        fprintf(\"Order estimates: Kaiser=%d, Equiripple=%d\n\", N_kaiser, N_pm);\n        ```\n\n        **Workflow recommendation**:\n        1) Use `kaiserord`/`firpmord` to estimate if a single-stage FIR is plausible.\n        2) Design the real filter (e.g., `designfilt(..., DesignMethod=\"equiripple\")`).\n        3) Verify with `freqz` + measured `Rp_meas_dB` / `Rs_meas_dB`.\n\n\n### Decision Matrix\n\n| trans_pct | Action |\n|-----------|--------|\n| > 5% | Single-stage OK |\n| 2-5% | Mention multistage option |\n| < 2% | **Present tradeoff to user** (see `cards/efficient-filtering.md`) |\n\n### Response Template\n\n> \"Architecture check: Transition BW = X% of Fs, estimated ~Y taps. [Single-stage recommended / Multistage recommended - asking user preference].\"\n\n---\n\n## Streaming vs Offline\n\n### Offline Processing\n\n- Use `filtfilt()` for zero-phase\n- Use `resample()` for multirate\n- Process entire signal at once\n- No state management needed\n\n### Streaming/Real-Time\n\n- Use `dsp.SOSFilter` with `SystemObject=true`\n- Or use `ctffilt()` (R2024b+) with state management\n- Process frame-by-frame\n- Reset state when needed\n\n### Key Rule\n\n**Offline zero-phase** → `resample()` + `filtfilt()`\n**Streaming causal** → System objects + `filter()`\n\nNever mix: System objects with `filtfilt()` = catastrophic failure (see `gotchas.md` #10)\n\n---\n\n## Performance Optimization\n\n### Long FIR Filters\n\n```matlab\nif length(b) > 100\n    y = fftfilt(b, x);  % FFT-based, faster\nelse\n    y = filter(b, 1, x);  % Direct form OK\nend\n```\n\n### Narrow Transition Bands\n\n- Consider multistage approach\n- Calculate efficiency gain: `(N_single) / (N_dec + N_sharp/M + N_interp)`\n- For trans_pct < 2%, multistage often 5-10x more efficient (see `cards/efficient-filtering.md`)\n\n### IIR Numerical Stability\n\n- Always use SOS form via `designfilt()` or `zp2sos()`\n- Avoid `[b,a]` form for order > 8\n- Check pole locations if stability concerns arise\n\n---\n\n## Quick Lookup\n\n| Topic | Consult |\n|-------|---------|\n| Common errors | `gotchas.md` |\n| Code templates | `patterns.md` |\n| API details | `docs/INDEX.md` |\n| Architecture decision | Pre-Design Check above |\n| Offline vs streaming | Streaming vs Offline section |\n| Validation | Validation Workflow section |\n\n",
        "skills/matlab-digital-filter-design/knowledge/cards/designfilt.md": "# designfilt Reference Card\n\nOpen this card **before** writing any `designfilt(...)` call.\n\n## Response Type Quick Reference\n\n| Filter type | Response string | Key parameters |\n|-------------|-----------------|----------------|\n| Lowpass FIR | `\"lowpassfir\"` | `PassbandFrequency`, `StopbandFrequency` |\n| Lowpass IIR | `\"lowpassiir\"` | `PassbandFrequency`, `StopbandFrequency` |\n| Highpass FIR | `\"highpassfir\"` | `StopbandFrequency`, `PassbandFrequency` |\n| Highpass IIR | `\"highpassiir\"` | `StopbandFrequency`, `PassbandFrequency` |\n| Bandpass FIR | `\"bandpassfir\"` | `PassbandFrequency=[f1 f2]` (vector OK) |\n| Bandpass IIR | `\"bandpassiir\"` | `PassbandFrequency1`, `PassbandFrequency2` (scalar!) |\n| Bandstop FIR | `\"bandstopfir\"` | `StopbandFrequency=[f1 f2]` (vector OK) |\n| Bandstop IIR | `\"bandstopiir\"` | `StopbandFrequency1`, `StopbandFrequency2` (scalar!) |\n| **Notch (single tone)** | `\"notchiir\"` | `CenterFrequency`, `QualityFactor` |\n| Peak (boost) | `\"peakiir\"` | `CenterFrequency`, `QualityFactor`, `PassbandRipple` |\n\n## Core Patterns\n\n### FIR (linear phase by default)\n\n```matlab\nd = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n```\n\n### IIR (minimum order)\n\n```matlab\nd = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"ellip\");\n```\n\n### Notch (single tone removal)\n\n```matlab\nd = designfilt(\"notchiir\", ...\n    CenterFrequency=f0, QualityFactor=Q, ...\n    SampleRate=Fs);\n```\n\n**Q guidelines**: 10-50 typical. Higher Q = sharper notch but more ringing.\n\n### Bandpass IIR (scalar edges required!)\n\n```matlab\nd = designfilt(\"bandpassiir\", ...\n    StopbandFrequency1=fs1, PassbandFrequency1=f1, ...\n    PassbandFrequency2=f2,  StopbandFrequency2=fs2, ...\n    PassbandRipple=Rp, ...\n    StopbandAttenuation1=Rs, StopbandAttenuation2=Rs, ...\n    SampleRate=Fs, DesignMethod=\"ellip\");\n```\n\n## Design Methods\n\n| Method | Characteristics |\n|--------|-----------------|\n| `\"ellip\"` | Minimum order, equiripple in pass & stop |\n| `\"butter\"` | Maximally flat, monotonic response |\n| `\"cheby1\"` | Ripple in passband only |\n| `\"cheby2\"` | Ripple in stopband only |\n| `\"equiripple\"` | Parks-McClellan (FIR only) |\n\n## SystemObject=true (streaming)\n\nFor streaming applications, get a System object directly:\n\n```matlab\n% Returns dsp.SOSFilter (IIR) or dsp.FIRFilter (FIR)\nsosFilter = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    SampleRate=Fs, DesignMethod=\"ellip\", ...\n    SystemObject=true);\n\ny = sosFilter(x);  % Stateful, ready for streaming\n```\n\n---\n\n## Gotchas\n\n### IIR bandpass/bandstop vector error\n\n**Wrong**:\n```matlab\nd = designfilt(\"bandpassiir\", ...\n    PassbandFrequency=[300 3400], ...);  % ERROR! Vector not allowed for IIR\n```\n\n**Correct**: Use scalar properties with `...1`/`...2` suffixes.\n\n**Note**: FIR bandpass/bandstop CAN use vectors: `PassbandFrequency=[f1 f2]`\n\n### Deprecated Coefficients property\n\n**Wrong**: `sos = d.Coefficients;` (removed in recent versions)\n\n**Correct**:\n```matlab\nB = d.Numerator;      % Lx3 per-section\nA = d.Denominator;    % Lx3 per-section\nsos = [B A];          % Lx6 if needed\n```\n\n### Manual dsp.SOSFilter vs SystemObject=true\n\nDon't manually extract coefficients to create a System object:\n```matlab\n% Inefficient\nd = designfilt(...); B = d.Numerator; A = d.Denominator;\nsosFilter = dsp.SOSFilter('Numerator', B, 'Denominator', A);\n\n% Efficient - get System object directly\nsosFilter = designfilt(..., SystemObject=true);\n```\n\n### Ultra-high-Q notch (excessive ringing)\n\n**Problematic**: `QualityFactor=1000` causes long ringing\n\n**Better**: Use moderate Q (10-50). For multiple tones, use several moderate notches instead of one ultra-sharp notch.\n\n---\n\n## iirnotch / iircomb (alternative to designfilt)\n\nFor simple notch filters, `iirnotch` is a quick alternative:\n\n```matlab\nwo = f0/(Fs/2);      % Normalized frequency\nbw = bandwidth/(Fs/2);  % Normalized bandwidth\n[b, a] = iirnotch(wo, bw);\ny = filter(b, a, x);\n```\n\n**Note**: Returns `[b, a]` coefficients, not a digitalFilter object.\n",
        "skills/matlab-digital-filter-design/knowledge/cards/efficient-filtering.md": "# Efficient Filtering Card (`trans_pct < 2%`)\n\nUse this card when the transition band is **narrow** or you need to compare **compute cost** across architectures.\n\n```matlab\ntrans_pct = 100 * (Fstop - Fpass) / Fs;\n```\n\nIf `trans_pct < 2%`, a single-stage FIR may be hundreds of taps. **Stop and compare architectures** instead of committing early.\n\n## Step 0 — compute the planning metrics\n\n```matlab\ntrans_bw  = Fstop - Fpass;\ntrans_pct = 100 * trans_bw / Fs;\nM_max     = floor(Fs/(2*Fstop));   % upper bound for lowpass-safe decimation\n```\n\n## Step 1 — do not guess: confirm the intent\n\nYou must know:\n- Mode: **streaming** (causal) vs **offline** (batch)\n- Phase: **zero-phase**, **linear-phase**, or **don't-care**\n- Whether internal **rate change** is acceptable (multirate pipelines)\n\nIf any is unknown: ask, then stop.\n\n## Step 2 — pick the viable candidate families (don't force all four)\n\nFor `trans_pct < 2%`, present **2–4 viable candidates**, not a fixed set.\n\n### Quick lookup: Mode × Phase → Viable families\n\n| Mode | Phase | Single-stage IIR | Single-stage FIR | Multirate | IFIR |\n|------|-------|------------------|------------------|-----------|------|\n| **Streaming** | linear-phase | ❌ | ✅ | ✅ polyphase | ✅ |\n| **Streaming** | don't-care | ✅ | ✅ | ✅ polyphase | ✅ |\n| **Offline** | zero-phase | ✅ `filtfilt()` | ✅ `filtfilt()` | ✅ `resample()+filtfilt()` | ✅ `filtfilt()` |\n| **Offline** | linear-phase | ❌ | ✅ | ✅ polyphase | ✅ |\n| **Offline** | don't-care | ✅ | ✅ | ✅ either | ✅ |\n\n**Key insight**: Polyphase multirate (FIR decimator/interpolator) gives **linear-phase** — it's NOT limited to offline zero-phase workflows.\n\n### Family details\n\n| Family | Viable when | Quick notes |\n|---|---|---|\n| Single-stage **IIR** | phase ≠ \"linear-phase\" | Offline can use `filtfilt()` for zero-phase. Streaming IIR is efficient but non-linear phase. |\n| Single-stage **FIR** | always viable | Linear phase possible, but may be long / high latency / high MPIS. |\n| **Multirate pipeline** (dec→filter→interp) | rate change OK | **Streaming**: polyphase System objects (linear-phase). **Offline zero-phase**: `resample()` + `filtfilt()`. Never mix `filtfilt` with System objects. |\n| **Constant-rate multistage FIR** (IFIR method) | rate change NOT OK | FIR-like behavior at constant rate with fewer multipliers than single-stage FIR in many narrow-band cases. |\n\nIf a family is excluded, say so explicitly (one line), e.g.:\n- \"Excluded IIR: user requires linear phase in streaming.\"\n- \"Excluded multirate: user cannot change internal sample rate.\"\n\n### Choosing between IFIR and Notch+LP\n\nWhen the spectrum shows a **dominant tonal interferer** near the transition band, consider a **Notch + relaxed LP** hybrid:\n\n| Approach | Best when |\n|----------|-----------|\n| **Notch + relaxed LP** | Known tonal interferer you can notch out (allows wider transition) |\n| **IFIR** | General narrow transition, no specific tone to exploit |\n| Single-stage FIR | Baseline (always works) |\n\n**Decision rule:**\n1. Analyze spectrum for dominant tones in/near transition band\n2. If tone found: try Notch (at tone freq) + relaxed LP (wider Fstop)\n3. Compare MPIS via `cost()` — pick the cheaper option\n4. If no identifiable tone → use IFIR or single FIR\n\n## Step 3 — feasibility check (order estimates)\n\n### Default \"MATLAB-native\" flow (recommended)\n\nLet `designfilt` pick the minimum order from `Rp/Rs`, then query `filtord(d)`.\n\n```matlab\nd_try = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n\nN = filtord(d_try);\n```\n\n### FIR planning estimates (useful for architecture decisions)\n\n```matlab\ndev_p = (10^(Rp/20)-1)/(10^(Rp/20)+1);  % passband deviation (linear)\ndev_s = 10^(-Rs/20);                    % stopband deviation (linear)\n\n[Nk,~,~,~] = kaiserord([Fpass Fstop],[1 0],[dev_p dev_s], Fs);\n[Np,~,~,~] = firpmord([Fpass Fstop],[1 0],[dev_p dev_s], Fs);\n```\n\nUse these as \"order smell tests,\" not absolute truth.\n\n## Step 4 — compute MPIS with `cost()`\n\n**MPIS = Multiplications Per Input Sample**, reported by `cost()` on DSP System objects.\n\n### 80/20 rules\n\n- Tap count alone lies (multirate runs parts at lower rate; IIR cost isn't \"sections × taps\").\n- Prefer **System objects** + `cost()`:\n  - FIR → `dsp.FIRFilter`\n  - IIR → `dsp.SOSFilter` (often easiest via `designfilt(..., SystemObject=true)`)\n  - Pipelines → `dsp.FilterCascade`\n\n### FIR MPIS\n\n```matlab\nd_fir = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n\nfirSys = dsp.FIRFilter(\"Numerator\", d_fir.Numerator);\nmpis_fir = cost(firSys).MultiplicationsPerInputSample;\n```\n\n### IIR MPIS (prefer SystemObject=true)\n\n```matlab\n% Returns dsp.SOSFilter directly (stable + stateful)\niirSys = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"ellip\", ...\n    SystemObject=true);\n\nmpis_iir = cost(iirSys).MultiplicationsPerInputSample;\n```\n\n### Pipeline MPIS\n\n```matlab\npipe = dsp.FilterCascade(stage1, stage2, stage3);\nmpis_pipe = cost(pipe).MultiplicationsPerInputSample;\n```\n\nFor multirate decimate→filter→interpolate pipelines, `cost(pipe)` accounts for polyphase structure and internal rates.\n\n### Offline `filtfilt()` note\n\n- `filtfilt()` runs the filter **twice** → compute cost is roughly **2×** the single-pass cost.\n- The effective magnitude response is **squared** (≈ doubles attenuation in dB).\n\n## Step 5 — compare with Filter Analyzer\n\n- Open `knowledge/cards/filter-analyzer.md` and overlay candidates.\n\nMinimum comparisons to show:\n- Magnitude response (meet specs)\n- Group delay (latency + phase behavior)\n- MPIS (when compute matters)\n\n---\n\n## `resample()` note\n\n`resample()` uses internal filters not exposed to `cost()`.\nIf you need performance numbers for an offline `resample()` pipeline, use `timeit()` on your machine.\n",
        "skills/matlab-digital-filter-design/knowledge/cards/filter-analyzer.md": "# Filter Analyzer Card\n\nOpen this card **before** you write any code that uses:\n`filterAnalyzer`, `addFilters`, `addDisplays`, `replaceFilters`, `newSession`, or `filterAnalysisOptions`.\n\n## Non‑negotiables\n\n- Always pass `SampleRates=Fs` so plots are in **Hz** (not normalized).\n- `FilterNames` must be valid MATLAB identifiers:\n  - ✅ `[\"FIR_Equiripple\",\"IIR_Ellip\"]`\n  - ❌ `[\"FIR Equiripple\",\"IIR-ellip\"]`\n- Overlay rules:\n  - frequency-domain overlays only with frequency-domain\n  - time-domain overlays only with time-domain\n- Avoid duplicate filters on re-runs:\n  - prefer `newSession(fa)` (fresh start), or\n  - `replaceFilters(fa, ...)` (update-in-place)\n\n## Canonical “compare two filters” pattern\n\n```matlab\nFs = 44100;\n\n% d1, d2 can be digitalFilter objects or supported System objects\nnames = [\"FIR_Equiripple\",\"IIR_Ellip\"];\n\n[fa, dispMag] = filterAnalyzer(d1, d2, ...\n    FilterNames=names, ...\n    SampleRates=Fs, ...\n    Analysis=\"magnitude\", ...\n    OverlayAnalysis=\"phase\");\n\ndispGD = addDisplays(fa, Analysis=\"groupdelay\");\nshowFilters(fa, true, FilterNames=names, DisplayNums=dispGD);\n\ndispImp = addDisplays(fa, Analysis=\"impulse\");\nshowFilters(fa, true, FilterNames=names, DisplayNums=dispImp);\n```\n\n## Robust session pattern (no duplicates across reruns)\n\n```matlab\nFs = 44100;\nnames = [\"LP_A\",\"LP_B\"];\n\nif exist(\"fa\",\"var\") && isvalid(fa)\n    newSession(fa);\nelse\n    fa = filterAnalyzer();  % open empty app\nend\n\naddFilters(fa, dA, dB, FilterNames=names, SampleRates=Fs);\naddDisplays(fa, Analysis=\"magnitude\", OverlayAnalysis=\"phase\");\naddDisplays(fa, Analysis=\"groupdelay\");\n```\n\n## Update a filter without duplicating it\n\n```matlab\n% Replace existing filters by name (keeps displays intact)\nreplaceFilters(fa, dA_new, dB_new, ...\n    FilterNames=[\"LP_A\",\"LP_B\"], ...\n    SampleRates=Fs);\n```\n\n## Visualize a multirate pipeline as one “filter”\n\nWhen comparing a decimate→filter→interpolate pipeline against a single-stage filter, wrap the full chain in `dsp.FilterCascade`.\n\n```matlab\nFs = 44100; M = 4;\n\n% Streaming-friendly components (System objects)\ndec_sys = designMultirateFIR(DecimationFactor=M, StopbandAttenuation=60, SystemObject=true);\n\nd_core = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=2800, StopbandFrequency=3100, ...\n    PassbandRipple=0.1, StopbandAttenuation=60, ...\n    SampleRate=Fs/M, DesignMethod=\"equiripple\");\n\ncore_sys = dsp.FIRFilter(\"Numerator\", d_core.Numerator);\n\ninterp_sys = designMultirateFIR(InterpolationFactor=M, StopbandAttenuation=60, SystemObject=true);\n\npipe = dsp.FilterCascade(dec_sys, core_sys, interp_sys);\n\n% Add alongside other filters\naddFilters(fa, pipe, FilterNames=\"Multirate_Pipeline\", SampleRates=Fs);\n```\n\n## When to open the full guide\n\nOpen `knowledge/filter-analyzer.md` when you need:\n- `filterAnalysisOptions` (log scale, NFFT, normalization, etc.)\n- display management (`duplicateDisplays`, `deleteDisplays`, …)\n- session save/load (`saveSession`)\n- version-specific notes\n",
        "skills/matlab-digital-filter-design/knowledge/cards/general-iir-fir.md": "# General IIR/FIR Best Practices Card\n\nOpen this card when working with high-order IIR, long FIR, `freqz`/`grpdelay` plots, or `filtfilt`.\n\n---\n\n## High-Order IIR: Use SOS Form\n\nThe `[b, a]` transfer function form is **numerically unstable** for high-order IIR filters (order > 8).\n\n**Risky**:\n```matlab\n[b, a] = butter(12, 0.3);  % High-order [b,a] form\ny = filter(b, a, x);       % May produce Inf/NaN\n```\n\n**Better**:\n```matlab\n% Option 1: zpk → sos conversion\n[z, p, k] = butter(12, 0.3);\nsos = zp2sos(z, p, k);\ny = sosfilt(sos, x);\n\n% Option 2: designfilt (recommended - handles SOS internally)\nd = designfilt(\"lowpassiir\", ...\n    FilterOrder=12, HalfPowerFrequency=0.3, ...\n    DesignMethod=\"butter\");\ny = filter(d, x);  % Uses stable SOS form internally\n```\n\n---\n\n## Long FIR: Use fftfilt\n\nDirect convolution (`filter(b, 1, x)`) is slow for FIR filters > ~100 taps.\n\n```matlab\nb = d.Numerator;\n\nif length(b) > 100\n    y = fftfilt(b, x);  % FFT-based overlap-add (much faster)\nelse\n    y = filter(b, 1, x);  % Direct form OK for short FIR\nend\n```\n\n**Rule of thumb**: For FIR length N and signal length L:\n- `filter()` is O(N*L)\n- `fftfilt()` is O(L*log(L)) — wins for large N\n\n---\n\n## freqz/grpdelay: Always Pass Fs\n\nWithout `Fs`, plots show normalized frequency (0 to pi) — confusing!\n\n**Confusing**:\n```matlab\nfreqz(d);  % Plots 0 to π normalized\n```\n\n**Clear**:\n```matlab\nfreqz(d, [], Fs);     % Plots in Hz\ngrpdelay(d, [], Fs);  % Group delay axis in Hz\n```\n\nAlso applies to `phasez`, `zerophase`, etc.\n\n---\n\n## filtfilt: Offline Only!\n\n`filtfilt()` requires the **entire signal** (forward-backward filtering). It is **not** compatible with streaming/real-time.\n\n**Wrong** (real-time loop):\n```matlab\nfor frame = 1:numFrames\n    y = filtfilt(d, x_frame);  % ERROR: filtfilt needs entire signal\nend\n```\n\n**Correct** (streaming):\n```matlab\n% Use a System object with state management\nsosFilt = dsp.SOSFilter('Numerator', B, 'Denominator', A);\nfor frame = 1:numFrames\n    y_frame = sosFilt(x_frame);  % Causal, state preserved\nend\n```\n\n**Correct** (offline zero-phase):\n```matlab\ny_offline = filtfilt(d, entire_signal);\n```\n\n### filtfilt doubles attenuation\n\n`filtfilt` applies the filter twice (forward + backward), so:\n- Effective magnitude = |H(f)|^2\n- Stopband attenuation roughly doubles in dB\n- Passband ripple roughly doubles in dB\n\nAccount for this when specifying `Rs` and `Rp`.\n\n---\n\n## Quick Checklist\n\n| Situation | Action |\n|-----------|--------|\n| IIR order > 8 | Use `designfilt` or `zp2sos` + `sosfilt` |\n| FIR length > 100 | Use `fftfilt()` |\n| Plotting frequency response | Pass `Fs` to `freqz`, `grpdelay` |\n| Real-time filtering | Use `dsp.SOSFilter` or `dsp.FIRFilter` |\n| Zero-phase offline | Use `filtfilt()` on entire signal |\n",
        "skills/matlab-digital-filter-design/knowledge/cards/multirate-offline.md": "# Multirate OFFLINE Card (rate change + zero‑phase)\n\nUse this card when the user wants:\n- output returned to the **original sample rate**, but\n- is OK with an **internal rate change**, and\n- wants **offline / batch** processing (zero‑phase is on the table).\n\n## Critical Gotcha: System Objects + filtfilt = Catastrophic\n\n**Never** combine multirate System objects with `filtfilt()`:\n\n```matlab\n% WRONG - causes severe signal degradation (e.g., -27 dB SNR)\ndecimator = dsp.FIRDecimator(M, b_dec);\ninterpolator = dsp.FIRInterpolator(M, b_interp);\n\nx_dec = decimator(x);              % System object has internal state\nx_filt = filtfilt(d, x_dec);       % filtfilt assumes no state - MISALIGNED!\ny = interpolator(x_filt);          % Output is garbage\n```\n\n**Why**: System objects maintain internal state and group delays. `filtfilt()` processes forward/backward assuming clean start states, causing catastrophic misalignment.\n\n**Solution**: Use `resample()` for offline zero-phase multirate:\n\n```matlab\nx_dec = resample(x, 1, M);         % Built-in anti-alias, proper alignment\nx_filt = filtfilt(d_sharp, x_dec); % Zero-phase at reduced rate\ny = resample(x_filt, M, 1);        % Interpolate back properly\n```\n\n## Canonical offline pipeline\n\n```matlab\nFs = 44100;\nM  = 4;\nFs_dec = Fs/M;\n\n% 1) Downsample with built-in anti-aliasing\nx_dec = resample(x, 1, M);\n\n% 2) Design the sharp filter at the reduced rate\nd_sharp = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs_dec, DesignMethod=\"equiripple\");\n\n% 3) Zero-phase filtering at low rate\ny_dec = filtfilt(d_sharp, x_dec);\n\n% 4) Upsample back (built-in anti-imaging)\ny = resample(y_dec, M, 1);\n```\n\n## Notes that avoid “confident nonsense”\n\n- `resample()` has hidden filter cost (not exposed via `cost()`).\n  - Use `timeit()` if you need wall-clock timing.\n- If you use `filtfilt(d_sharp, ...)`, the effective magnitude response is **squared**.\n  - Expect stopband attenuation in dB to roughly **double**.\n- For architecture choice (narrow transitions), compare against:\n  - single-stage FIR (high MPIS),\n  - constant-rate multistage FIR (IFIR), if rate change is not acceptable.\n",
        "skills/matlab-digital-filter-design/knowledge/cards/multirate-streaming.md": "# Multirate STREAMING Card (polyphase, causal)\n\nUse this card when the user wants:\n- **streaming / real-time / frame-based** filtering, and\n- output stays at the **original sample rate**, but\n- internal rate change is acceptable.\n\n## 80/20 rules\n\n- Streaming is **causal** → no `filtfilt()`. (Zero-phase requires the entire signal.)\n- Use **System objects** (`SystemObject=true`) so state is handled correctly across frames.\n- Frame length should be a multiple of the decimation factor `M`.\n\n**Note**: If you need zero-phase, switch to offline mode with `resample()`. See `cards/multirate-offline.md`.\n\n## Canonical streaming pipeline (dec → sharp filter → interp)\n\n```matlab\nFs = 44100;\nM  = 4;\nFs_dec = Fs/M;\n\n% Stage 1: decimator (polyphase)\ndec = designMultirateFIR(DecimationFactor=M, ...\n    StopbandAttenuation=60, ...\n    SystemObject=true);\n\n% Stage 2: sharp filter at low rate (System object for streaming)\nsharp = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs_dec, DesignMethod=\"equiripple\", ...\n    SystemObject=true);\n\n% Stage 3: interpolator (polyphase)\ninterp = designMultirateFIR(InterpolationFactor=M, ...\n    StopbandAttenuation=60, ...\n    SystemObject=true);\n\n% Frame loop (example)\nframeLen = 1024;              % choose so mod(frameLen,M)==0\ny = zeros(size(x));\nreset(dec); reset(sharp); reset(interp);\n\nfor k = 1:frameLen:(numel(x)-frameLen+1)\n    frame = x(k:k+frameLen-1);\n\n    frame_dec  = dec(frame);\n    frame_filt = sharp(frame_dec);\n    frame_out  = interp(frame_filt);\n\n    y(k:k+frameLen-1) = frame_out;\nend\n```\n\n## Efficiency note (common trap)\n\nFor narrow transitions, don’t try to “bake the sharp spec” into a multistage decimator/interpolator.  \nInstead:\n- decimate/interpolate with relaxed anti-alias / anti-image, and\n- do the sharp filtering at the reduced rate.\n\nSee `knowledge/multirate.md` for the full decision guide.\n\n## Filter Analyzer comparison (pipeline as one object)\n\nWrap the pipeline in `dsp.FilterCascade` (then open the Filter Analyzer card):\n\n```matlab\npipe = dsp.FilterCascade(dec, sharp, interp);\nfilterAnalyzer(pipe, FilterNames=\"Multirate_Pipeline\", SampleRates=Fs);\n```\n\n## Gotchas\n\n### API confusion: designMultirateFIR vs dsp.FIRDecimator\n\n`designMultirateFIR` is the recommended modern API. Don't confuse it with raw System object constructors:\n\n```matlab\n% WRONG — invalid syntax (dsp.FIRDecimator doesn't take 'SystemObject')\ndecim = dsp.FIRDecimator(M, 'SystemObject', true);\n\n% RIGHT — use designMultirateFIR\ndecim = designMultirateFIR(DecimationFactor=M, StopbandAttenuation=60, SystemObject=true);\n```\n\n`dsp.FIRDecimator(M)` creates a default decimator; `designMultirateFIR` gives you spec control.\n\n### Querying filter order from System objects\n\n`filtord()` works on `digitalFilter` objects but NOT on System objects:\n\n```matlab\n% WRONG — filtord doesn't work on dsp.FIRDecimator\nN = filtord(decim);  % ERROR\n\n% RIGHT — use Numerator property\nN = numel(decim.Numerator) - 1;\n```\n",
        "skills/matlab-digital-filter-design/knowledge/cards/multistage-ifir.md": "# Constant‑Rate Multistage FIR Card (IFIR method)\n\nUse this card when:\n- the transition is narrow (`trans_pct < 2%`), and\n- you want **FIR-like phase behavior** (often linear phase), and\n- you **cannot** (or don’t want to) change the sample rate internally.\n\nMATLAB’s standard tool for this is **IFIR** (Interpolated FIR): a sparse “model” filter plus an image‑suppressor, in cascade.\n\n## Two workflows (pick based on what you need)\n\n### A) Filter Analyzer / streaming-friendly (recommended)\n\nThis returns a `dsp.FilterCascade` that Filter Analyzer understands.\n\n```matlab\nFs = 44100;\nFn = Fs/2;\n\nHf = fdesign.lowpass(Fpass/Fn, Fstop/Fn, Rp, Rs);\n\n% Returns dsp.FilterCascade\nifirSys = ifir(Hf, SystemObject=true);\n% (equivalent) ifirSys = design(Hf, \"ifir\", SystemObject=true);\n\nfilterAnalyzer(ifirSys, FilterNames=\"IFIR\", SampleRates=Fs);\n\n% Apply (streaming/casual)\ny = ifirSys(x);\nreset(ifirSys);\n```\n\n### B) Offline zero‑phase with coefficient access\n\nRaw coefficients are convenient for `filtfilt()`, but they don’t drop cleanly into Filter Analyzer.\n\n```matlab\nFs = 44100;\nFn = Fs/2;\n\ndev_p = (10^(Rp/20)-1)/(10^(Rp/20)+1);\ndev_s = 10^(-Rs/20);\n\nL = 4;  % interpolation factor (try 2–8)\n[b_ifir, b_model, b_image] = ifir(L, \"low\", [Fpass Fstop]/Fn, [dev_p dev_s]);\n\ny = filtfilt(b_ifir, 1, x);  % zero-phase (offline only)\n```\n\n## Gotchas\n\n### IFIR + Filter Analyzer / filtord\n\n**Problem**: Raw `ifir()` coefficient outputs don't work with `filterAnalyzer` or `filtord`:\n\n```matlab\n% These will ERROR or give wrong results\n[b_ifir, b_model, b_image] = ifir(L, \"low\", [Fpass Fstop]/Fn, [dev_p dev_s]);\nfilterAnalyzer(b_ifir, SampleRates=Fs);  % ERROR\nfiltord(b_ifir);  % Works but gives wrong answer (overall, not per-stage)\n\n% design() returns dfilt objects, not digitalFilter\nd_ifir = design(fdesign.lowpass(...), 'ifir');\nfiltord(d_ifir.Stage(1));  % ERROR: dfilt.dffir not supported\n```\n\n**Solution**: Use `SystemObject=true` to get a `dsp.FilterCascade`:\n\n```matlab\nHf = fdesign.lowpass(Fpass/Fn, Fstop/Fn, Rp, Rs);\nifirSys = ifir(Hf, SystemObject=true);\n\n% Works with Filter Analyzer\nfilterAnalyzer(ifirSys, FilterNames=\"IFIR\", SampleRates=Fs);\n\n% Get tap counts via cost()\nc = cost(ifirSys);\nfprintf(\"Total multiplications per sample: %d\\n\", c.MultiplicationsPerInputSample);\n```\n\n### Getting stage coefficients for filtfilt\n\nIf you need raw coefficients (e.g., for `filtfilt`), use workflow B and apply directly:\n\n```matlab\n[b_ifir, ~, ~] = ifir(L, \"low\", [Fpass Fstop]/Fn, [dev_p dev_s]);\ny = filtfilt(b_ifir, 1, x);  % OK - raw coefficients work here\n```\n\n## When to prefer multirate instead\n\nIf internal rate change *is* acceptable, multirate dec→filter→interp can be even cheaper.  \nUse `knowledge/cards/multirate-streaming.md` or `multirate-offline.md` depending on Mode.\n",
        "skills/matlab-digital-filter-design/knowledge/efficient-filtering.md": "# Efficient Filtering for Narrow Transitions\n\nWhen transition bands are narrow (trans_pct < 2%; see `cards/efficient-filtering.md`), single-stage FIR filters require hundreds of taps. This guide helps you choose an efficient alternative.\n\n## Table of Contents\n- [When You Need This](#when-you-need-this)\n- [Four Approaches Compared](#four-approaches-compared)\n- [Quantify Single-Stage FIR Cost](#quantify-single-stage-fir-cost)\n- [Multirate Design](#multirate-design-function-selection)\n- [IFIR Quick Syntax](#ifir-quick-syntax)\n- [Decision Flowchart](#decision-flowchart)\n- [MPIS Cost Comparison](#mpis-cost-comparison-real-example)\n- [Why MPIS is the Right Metric](#why-mpis-is-the-right-metric)\n- [Visualizing All Approaches in Filter Analyzer](#visualizing-all-approaches-in-filter-analyzer)\n- [Quick Selection Guide](#quick-selection-guide)\n- [Cross-References](#cross-references)\n\n---\n\n## When You Need This\n\nCalculate your transition percentage:\n\n```\nCompute constraining transition width Δf (Hz):\n- lowpass:   Δf = Fstop - Fpass\n- highpass:  Δf = Fpass - Fstop\n- bandpass:  Δf = min(Fpass1 - Fstop1, Fstop2 - Fpass2)\n- bandstop:  Δf = min(Fstop1 - Fpass1, Fpass2 - Fstop2)\n\nThen:\ntrans_pct = 100 * (Δf / Fs)\n```\n\n| trans_pct | Recommendation |\n|-----------|----------------|\n| > 5% | Single-stage filter is fine |\n| 2-5% | Consider efficient alternatives |\n| **< 2%** | **Efficient approach strongly recommended** (see `cards/efficient-filtering.md`) |\n\n---\n\n## Four Approaches Compared\n\n| Approach | Sample Rate | Structure | Best When |\n|----------|-------------|-----------|-----------|\n| **Single-stage IIR** | Constant | SOS (biquads) | Offline zero-phase OK, minimum coefficients |\n| **Multirate** | Changes internally | Decimate→filter→interpolate | Large M possible, prefer linear phase |\n| **IFIR** | Constant | Sparse + image suppressor | Rate change problematic, constant rate required |\n| **Single-stage FIR** | Constant | One filter | trans_pct > 5%, or simplicity matters |\n\n**Key insight**: For offline processing, **IIR + `filtfilt()`** is often the most efficient because `filtfilt()` cancels phase distortion, allowing minimum-order IIR designs.\n\n**Note**: Because `filtfilt()` applies the filter forward and backward, the effective magnitude response is the squared magnitude of the original filter (amplitude specs should be checked on the combined response).\n---\n\n## Quantify Single-Stage FIR Cost\n\nBefore you jump to multirate/IFIR, **quantify how bad a single-stage FIR really is** using MATLAB-native estimators.\n\n```matlab\n% Convert dB specs to linear deviations\ndev_p = (10^(Rp_dB/20)-1) / (10^(Rp_dB/20)+1);\ndev_s = 10^(-Rs_dB/20);\n\n% LOWPASS example (Hz). Adapt f/a for other responses:\nf = [Fpass Fstop];\na = [1 0];\ndev = [dev_p dev_s];\n\n% Order estimates\n[N_kaiser, Wn, beta, ftype] = kaiserord(f, a, dev, Fs);\n[N_pm, fo, ao, w] = firpmord(f, a, dev, Fs);\n\nfprintf(\"Estimated FIR order: Kaiser=%d, Equiripple=%d\n\", N_kaiser, N_pm);\n```\n\n**Interpretation**:\n- If the estimate is already in the **hundreds of taps**, a single-stage linear-phase FIR is likely expensive in streaming.\n- If the estimate is modest, you may not need multirate/IFIR at all — keep it simple and verify.\n\n\n---\n\n## Multirate Design: Function Selection\n\nFor multirate approaches, select functions based on your goal:\n\n| Goal | Recommended Approach |\n|------|---------------------|\n| **Pure rate conversion** (wideband anti-alias) | `designMultistageDecimator/Interpolator` with default TW |\n| **Narrow-transition filtering** at reduced rate | `designMultirateFIR` (anti-alias) + separate sharp filter |\n| **Offline FIR-based rate conversion** (delay-compensated) | `resample()` |\n\n### When Multistage Excels\n\n`designMultistageDecimator/Interpolator` automatically factor the overall rate-change (when the factor is composite) into stages and select a stage sequence that minimizes MPIS.\n\n**Example** (from MathWorks docs): For M=48 decimation, multistage reduces MPIS from ~15.7 to ~7.3 — roughly 2× savings.\n\n**Note**: Actual savings depend heavily on TW, Astop, and factorization. Use `cost()` to compare specific designs.\n\nThese functions are optimized for **wideband anti-aliasing**. Default transition width depends on the function and MATLAB release:\n- `designMultistageDecimator`: default TW = 0.2×Fs/M\n- `designMultistageInterpolator`: default TW = 0.2×Fs (R2024b+; was 0.2×Fs/L previously)\n\n### Narrow-Transition Strategy\n\nFor narrow transition bands, the sharp filtering is more efficient at reduced sample rate:\n\n1. **Decimate** with relaxed anti-alias (`designMultirateFIR`)\n2. **Sharp filter** at reduced rate (`designfilt` with tight specs)\n3. **Interpolate** with anti-image (`designMultirateFIR`)\n\nThis separates the anti-aliasing (wideband) from the sharp filtering (narrowband), allowing each to be optimized independently.\n\n\n\n        ### Multirate Candidate Selection Recipe (repeatable)\n\n        For lowpass-style “keep baseband” problems, start with:\n\n        ```matlab\n        % Max decimation factor that keeps stopband below new Nyquist (lowpass heuristic)\n        M_max = floor(Fs / (2*Fstop));\n        M_try = [2 3 4 5 6 8];\n        M_try = M_try(M_try <= M_max);\n        ```\n\n        Then evaluate each `M` by **total MPIS** (multiplications per input sample):\n\n        ```matlab\n        best = struct(M=1, mpis=Inf);\n\n        for M = M_try\n            Fs_dec = Fs / M;\n\n            % Anti-alias / anti-image (relaxed) at full rate\n            dec = designMultirateFIR(DecimationFactor=M, StopbandAttenuation=Rs_dB, SystemObject=true);\n            interp = designMultirateFIR(InterpolationFactor=M, StopbandAttenuation=Rs_dB, SystemObject=true);\n\n            % Sharp filter at reduced rate (digitalFilter -> wrap for cost())\n            d_sharp = designfilt(\"lowpassfir\", ...\n                PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n                PassbandRipple=Rp_dB, StopbandAttenuation=Rs_dB, ...\n                SampleRate=Fs_dec, DesignMethod=\"equiripple\");\n            sharp = dsp.FIRFilter(Numerator=d_sharp.Numerator);\n\n            mpis_total = cost(dec).MultiplicationsPerInputSample + ...\n                         cost(sharp).MultiplicationsPerInputSample / M + ...\n                         cost(interp).MultiplicationsPerInputSample;\n\n            if mpis_total < best.mpis\n                best.M = M; best.mpis = mpis_total;\n            end\n        end\n\n        fprintf(\"Best multirate candidate: M=%d (%.2f MPIS)\n\", best.M, best.mpis);\n        ```\n\n        **Why this is “standard”**: it turns “multirate might help” into a repeatable cost-based selection, instead of a vibe-based guess.\n\n        **Caveat**: `M_max` above is a *lowpass heuristic*. For highpass/bandpass/bandstop, safe rate-change needs spectrum-aware reasoning.\n\n→ See `knowledge/multirate.md` for complete workflows and cost analysis examples.\n\n---\n\n## IFIR Quick Syntax\n\n**Method 1: Direct ifir() with linear deviations**\n```matlab\n% WARNING: ifir() uses LINEAR deviations, not dB!\ndelta_p = 10^(Rp_dB/20) - 1;  % passband deviation\ndelta_s = 10^(-Rs_dB/20);      % stopband deviation\n[h, g] = ifir(L, 'low', [f1 f2], [delta_p delta_s]);\ny = filter(g, 1, filter(h, 1, x));  % cascade application\n\n% For Filter Analyzer: wrap in System objects\nH = dsp.FIRFilter(Numerator=h);\nG = dsp.FIRFilter(Numerator=g);\nfilterAnalyzer(cascade(H,G), FilterNames=\"IFIR_Cascade\");\n```\n\n**Method 2: fdesign + ifir (Recommended for Filter Analyzer)**\n```matlab\n% Returns dsp.FilterCascade directly - works with filterAnalyzer\nHf = fdesign.lowpass(Fpass/(Fs/2), Fstop/(Fs/2));\nHd = ifir(Hf, SystemObject=true);\nfilterAnalyzer(Hd, FilterNames=\"IFIR_Lowpass\");\n```\n\n---\n\n## Decision Flowchart\n\n```\nNarrow transition band (trans_pct < 2%)?\n│\n├── No  → Single-stage filter is fine\n│         - FIR for linear phase (streaming)\n│         - IIR for efficiency\n│\n└── Yes → Is this offline or streaming?\n    │\n    ├── OFFLINE → Do you need linear phase (constant group delay)?\n    │   │\n    │   ├── No  → **IIR + filtfilt()** (BEST: 23 MPIS)\n    │   │         Zero-phase, far fewer coefficients\n    │   │\n    │   └── Yes → Choose efficient FIR approach:\n    │             ├── Can you tolerate internal rate change?\n    │             │   ├── Yes → **Multirate** (decimate→filter→interpolate)\n    │             │   └── No  → **IFIR** (constant rate)\n    │             └── Or just accept ~400 taps if simplicity matters\n    │\n    └── STREAMING → Do you need linear phase?\n        │\n        ├── No  → **IIR** (minimum order, sharp cutoff)\n        │\n        └── Yes → Choose efficient FIR approach:\n                  ├── Can you tolerate internal rate change?\n                  │   ├── Yes → **Multirate** (System objects)\n                  │   └── No  → **IFIR** (constant rate)\n                  └── Or accept latency of ~400-tap FIR\n```\n\n---\n\n## MPIS Cost Comparison (Real Example)\n\n**Specifications**: Fs=44.1kHz, Fpass=2.8kHz, Fstop=3.1kHz, 60dB stopband (trans_pct = 0.68%)\n\n```matlab\n%% Measure MPIS with cost() function\nFs = 44100; Fpass = 2800; Fstop = 3100; Rs = 60;\n\n% FIR Equiripple\nd_fir = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    StopbandAttenuation=Rs, SampleRate=Fs, DesignMethod=\"equiripple\");\nfir_sys = dsp.FIRFilter('Numerator', d_fir.Numerator);\ncost_fir = cost(fir_sys);\n\n% IIR Elliptic\nd_iir = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    StopbandAttenuation=Rs, SampleRate=Fs, DesignMethod=\"ellip\");\niir_sys = dsp.SOSFilter('Numerator', d_iir.Numerator, 'Denominator', d_iir.Denominator);\ncost_iir = cost(iir_sys);\n\nfprintf('FIR Equiripple: %d taps, %.0f MPIS\\n', length(d_fir.Numerator), cost_fir.MultiplicationsPerInputSample);\nfprintf('IIR Elliptic:   %d sections, %.0f MPIS\\n', size(d_iir.Numerator,1), cost_iir.MultiplicationsPerInputSample);\n```\n\n**Results**:\n\n| Filter | Taps/Sections | MPIS | Relative Cost |\n|--------|---------------|------|---------------|\n| FIR Equiripple | 407 taps | **407** | 1.00× (baseline) |\n| IIR Elliptic | 5 sections | **23** | 0.06× (**17× more efficient**) |\n| FIR Decimator (M=4) | 96 taps | 18.25 | (per input sample) |\n| FIR Interpolator (L=4) | 96 taps | 72 | (per output sample) |\n\n---\n\n## Why MPIS is the Right Metric\n\n| Metric | Problem |\n|--------|---------|\n| **Tap count** | Ignores polyphase efficiency, IIR structure, rate changes |\n| **`timeit()`** | Hardware-dependent, JIT-variable, not reproducible |\n| **MPIS via `cost()`** | Deterministic, structure-aware, MathWorks standard |\n\nUse the `cost()` function on DSP System objects to get accurate MPIS values.\n\n---\n\n## Visualizing All Approaches in Filter Analyzer\n\n**All filter types can be visualized together** in Filter Analyzer, including:\n- Single-stage FIR/IIR (`digitalFilter`, `dsp.FIRFilter`, `dsp.SOSFilter`)\n- IFIR cascades (`dsp.FilterCascade` from `ifir()`)\n- Multirate pipelines (`dsp.FilterCascade` wrapping dec→filter→interp)\n- Individual multirate filters (`dsp.FIRDecimator`, `dsp.FIRInterpolator`)\n\n### Complete Comparison Example (FIR vs IFIR vs Multirate Pipeline)\n\n**IMPORTANT**: For multirate pipelines, wrap the complete dec→filter→interp chain in `dsp.FilterCascade` so it appears as a single filter for comparison.\n\n```matlab\n%% Complete comparison: FIR vs IFIR vs Multirate Pipeline\nFs = 44100; M = 4;\nFpass = 2800; Fstop = 3000; Rp = 0.1; Rs = 60;\n\n% Approach 1: Single-stage FIR (baseline)\nd_fir = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\nfir_sys = dsp.FIRFilter('Numerator', d_fir.Numerator);\n\n% Approach 2: IFIR cascade\nHf = fdesign.lowpass(Fpass/(Fs/2), Fstop/(Fs/2), Rp, Rs);\nifir_sys = ifir(Hf, 'SystemObject', true);\n\n% Approach 3: Multirate pipeline (dec → filter → interp)\ndec_sys = designMultirateFIR(DecimationFactor=M, StopbandAttenuation=Rs, SystemObject=true);\nd_core = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs/M, DesignMethod=\"equiripple\");\ncore_sys = dsp.FIRFilter('Numerator', d_core.Numerator);  % Wrap for cascade!\ninterp_sys = designMultirateFIR(InterpolationFactor=M, StopbandAttenuation=Rs, SystemObject=true);\nmultirate_cascade = dsp.FilterCascade(dec_sys, core_sys, interp_sys);\n\n% Open Filter Analyzer with ALL THREE\nfa = filterAnalyzer(fir_sys, ifir_sys, multirate_cascade, ...\n    FilterNames=[\"FIR_SingleStage\", \"IFIR_Cascade\", \"Multirate_Pipeline\"], ...\n    SampleRates=Fs, Analysis=\"magnitude\");\n\n% Add group delay and impulse response\naddDisplays(fa, Analysis=\"groupdelay\");\naddDisplays(fa, Analysis=\"impulse\");\nshowFilters(fa, true);\n\n% Compare MPIS\nfprintf('MPIS: FIR=%.0f, IFIR=%.0f, Multirate=%.0f\\n', ...\n    cost(fir_sys).MultiplicationsPerInputSample, ...\n    cost(ifir_sys).MultiplicationsPerInputSample, ...\n    cost(multirate_cascade).MultiplicationsPerInputSample);\n```\n\n**Key points:**\n- Wrap `digitalFilter` in `dsp.FIRFilter` before adding to `dsp.FilterCascade`\n- **Use `dsp.FilterCascade(dec, filter, interp)`** to create a single object for comparison\n- Filter Analyzer shows the **overall** frequency response of the cascade\n- Use same `SampleRates=Fs` for all (multirate rates are handled internally)\n- IFIR cascades automatically expand to show individual stages\n\n→ See `knowledge/filter-analyzer.md` § \"Visualizing Multirate Pipelines\" for more details.\n\n---\n\n## Quick Selection Guide\n\n| Your Situation | Recommended Approach | Details |\n|----------------|---------------------|---------|\n| Offline, zero-phase OK | **IIR + `filtfilt()`** | Simplest, most efficient |\n| Offline, linear phase needed, rate change OK | **Multirate** | `resample()` + sharp filter |\n| Offline, linear phase needed, constant rate | **IFIR** | `ifir()` function |\n| Streaming, no phase requirement | **IIR** | `dsp.SOSFilter` |\n| Streaming, linear phase, rate change OK | **Multirate** | System objects pipeline |\n| Streaming, linear phase, constant rate | **IFIR** | `ifir(..., SystemObject=true)` |\n\n---\n\n## Cross-References\n\n**Detailed Guides**:\n- **Multirate workflows** → `knowledge/multirate.md`\n- **IFIR/Multistage workflows** → `knowledge/multistage-ifir.md`\n\n**API Documentation**:\n- `docs/ref_designMultirateFIR.md` — Multirate FIR design\n- `docs/ref_designMultistageDecimator.md` — Optimal cascaded decimator\n- `docs/ref_designMultistageInterpolator.md` — Optimal cascaded interpolator\n- `docs/ref_ifir.md` — IFIR filter design\n- `docs/ref_resample.md` — Sample rate conversion\n- `docs/dsp_multirate-filtering.md` — Multirate concepts\n\n**Other Knowledge**:\n- `knowledge/filter-analyzer.md` — Visualizing and comparing filters\n- `knowledge/patterns.md` — Code templates for all approaches\n",
        "skills/matlab-digital-filter-design/knowledge/filter-analyzer.md": "# Filter Analyzer App Workflows\n\nComprehensive guide for using the MATLAB Filter Analyzer app programmatically via `filterAnalyzer`.\n\n**Prefer Filter Analyzer over manual plotting** for filter visualization whenever comparing filters, iterating on designs, or needing interactive exploration.\n---\n\n## Table of Contents\n- [Analysis Types Quick Reference](#analysis-types-quick-reference)\n- [When to Use Filter Analyzer vs Manual Plots](#when-to-use-filter-analyzer-vs-manual-plots)\n- [Object Methods Quick Reference](#object-methods-quick-reference)\n- [Session Management](#session-management)\n- [Working with Analysis Options](#working-with-analysis-options)\n- [Workflow Examples](#workflow-examples)\n- [Getting Existing Filter Names](#getting-existing-filter-names-undocumented)\n- [Visualizing Multirate Filters](#visualizing-multirate-filters)\n- [Tips and Gotchas](#tips-and-gotchas)\n- [Version Info](#version-info)\n\n## Analysis Types Quick Reference\n\n| Analysis | Domain | Overlay? | Key Options |\n|----------|--------|----------|-------------|\n| `\"magnitude\"` | Freq | Yes | `MagnitudeMode`, `NormalizeMagnitude` |\n| `\"phase\"` | Freq | Yes | `PhaseUnits`, `ContinuousPhase` |\n| `\"groupdelay\"` | Freq | Yes | `GroupDelayUnits` |\n| `\"phasedelay\"` | Freq | Yes | `PhaseUnits` |\n| `\"magestimate\"` | Freq | Yes | `MagnitudeEstimateNumTrials` |\n| `\"noisepsd\"` | Freq | Yes | `NoisePSDNumTrials` |\n| `\"impulse\"` | Time | Yes | `ResponseLengthMode`, `ResponseLength` |\n| `\"step\"` | Time | Yes | `ResponseLengthMode`, `ResponseLength` |\n| `\"polezero\"` | Other | No | — |\n| `\"info\"` | Other | No | — |\n| `\"coefficients\"` | Other | No | `CoefficientsFormat` |\n\n**Overlay rules**: Frequency-domain analyses can overlay with other frequency-domain. Time-domain with time-domain. `polezero`, `info`, `coefficients` do not support overlays.\n\n---\n\n## When to Use Filter Analyzer vs Manual Plots\n\n### Use Filter Analyzer when:\n- Comparing multiple filters side-by-side\n- Need interactive exploration (zoom, pan)\n- Want overlay analysis (magnitude + phase, impulse + step)\n- Need specification mask visualization\n- Working iteratively (app stays open, update filters in place)\n- Need multiple analysis displays simultaneously\n\n### Use manual `freqz`/`grpdelay` when:\n- Simple single-filter quick check\n- Need to customize plot appearance beyond app options\n- Generating figures for export/publication (more control over formatting)\n- Scripting batch analysis without GUI\n\n---\n\n## Object Methods Quick Reference\n\n| Method | Syntax | Purpose |\n|--------|--------|---------|\n| `addFilters` | `addFilters(fa, filt1, filt2, ..., FilterNames=, SampleRates=)` | Add filters |\n| `addDisplays` | `dispNum = addDisplays(fa, Analysis=, OverlayAnalysis=)` | Add analysis display |\n| `deleteFilters` | `deleteFilters(fa, FilterNames=names)` | Remove filters by name |\n| `deleteDisplays` | `deleteDisplays(fa, DisplayNums=num)` | Remove display by number |\n| `duplicateDisplays` | `dupNum = duplicateDisplays(fa, DisplayNums=num)` | Clone a display |\n| `showFilters` | `showFilters(fa, true/false, FilterNames=, DisplayNums=)` | Show/hide filters |\n| `showLegend` | `showLegend(fa, true/false, DisplayNums=)` | Toggle legend |\n| `renameFilters` | `renameFilters(fa, oldNames, newNames)` | Rename filters |\n| `replaceFilters` | `replaceFilters(fa, filt1, ..., FilterNames=, SampleRates=)` | Update existing filters |\n| `getAnalysisOptions` | `opts = getAnalysisOptions(fa, DisplayNums=)` | Get display options |\n| `setAnalysisOptions` | `setAnalysisOptions(fa, opts, DisplayNums=)` | Set display options |\n| `zoom` | `zoom(fa, \"passband\"/\"default\", DisplayNums=)` | Zoom presets |\n| `saveSession` | `saveSession(fa, 'file.mat')` | Save session to file |\n| `newSession` | `newSession(fa)` | Clear all filters/displays |\n| `close` | `close(fa)` | Close the app |\n\n---\n\n## Session Management\n\n### Problem: Duplicate Filters Accumulating\n\nWhen repeatedly running code that adds filters to Filter Analyzer, you get:\n```\nFIR_Equiripple\nFIR_Equiripple_1\nFIR_Equiripple_2\n...\n```\n\nThis happens because `filterAnalyzer()` or `addFilters()` appends to existing session.\n\n### Solution 1: Fresh Session (Recommended)\n\nUse `newSession(fa)` to clear all filters before adding new ones:\n\n```matlab\n% Get or create Filter Analyzer handle\nif exist('fa', 'var') && isvalid(fa)\n    newSession(fa);  % Clear all existing filters\nelse\n    fa = filterAnalyzer();\nend\n\n% Now add filters - no duplicates\naddFilters(fa, d1, d2, d3, ...\n    FilterNames=[\"FIR_Equiripple\", \"FIR_Kaiser\", \"FIR_Hamming\"], ...\n    SampleRates=Fs);\n```\n\n### Solution 2: Replace Existing Filters\n\nUse `replaceFilters()` to update filters by name (keeps app state, displays):\n\n```matlab\nfa = getFilterAnalyzerHandle;\n\n% Replace filters with same names\nreplaceFilters(fa, d1_new, d2_new, d3_new, ...\n    FilterNames=[\"FIR_Equiripple\", \"FIR_Kaiser\", \"FIR_Hamming\"], ...\n    SampleRates=Fs);\n```\n\n**Note**: `FilterNames` specifies WHICH existing filters to replace.\n\n### Solution 3: Delete Specific Filters\n\nRemove specific filters by name:\n\n```matlab\nfa = getFilterAnalyzerHandle;\ndeleteFilters(fa, FilterNames=[\"FIR_Equiripple_1\", \"FIR_Kaiser_2\"]);\n```\n\n---\n\n## Working with Analysis Options\n\n### Creating and Applying Options\n\n```matlab\n% Create options for specific analysis (with overlay)\nopts = filterAnalysisOptions(\"magnitude\", \"phase\");\nopts.NFFT = 4096;\nopts.FrequencyScale = \"log\";\nopts.MagnitudeMode = \"db\";\n\n% Apply to specific display\nsetAnalysisOptions(fa, opts, DisplayNums=2);\n\n% Get current options from a display\ncurrentOpts = getAnalysisOptions(fa, DisplayNums=2);\n```\n\n### Common filterAnalysisOptions Properties\n\n**All Frequency-Domain Analyses:**\n| Property | Values | Default |\n|----------|--------|---------|\n| `FrequencyNormalizationMode` | `\"auto\"`, `\"normalized\"`, `\"unnormalized\"` | `\"auto\"` |\n| `FrequencyRange` | `\"auto\"`, `\"onesided\"`, `\"twosided\"`, `\"centered\"` | `\"auto\"` |\n| `FrequencyScale` | `\"linear\"`, `\"log\"` | `\"linear\"` |\n| `NFFT` | positive integer | `8192` |\n| `ReferenceSampleRateMode` | `\"max\"`, `\"specify\"` | `\"max\"` |\n\n**Magnitude-Specific:**\n| Property | Values | Default |\n|----------|--------|---------|\n| `MagnitudeMode` | `\"db\"`, `\"linear\"`, `\"squared\"`, `\"zerophase\"` | `\"db\"` |\n| `NormalizeMagnitude` | `true`, `false` | `false` |\n\n**Phase-Specific:**\n| Property | Values | Default |\n|----------|--------|---------|\n| `PhaseUnits` | `\"radians\"`, `\"degrees\"` | `\"radians\"` |\n| `ContinuousPhase` | `true`, `false` | `false` |\n\n**Group Delay:**\n| Property | Values | Default |\n|----------|--------|---------|\n| `GroupDelayUnits` | `\"samples\"`, `\"time\"` | `\"samples\"` |\n\n**Time-Domain (impulse/step):**\n| Property | Values | Default |\n|----------|--------|---------|\n| `ResponseLengthMode` | `\"auto\"`, `\"specify\"` | `\"auto\"` |\n| `ResponseLength` | positive integer | (auto-computed) |\n\n**Coefficients Display:**\n| Property | Values | Default |\n|----------|--------|---------|\n| `CoefficientsFormat` | `\"decimal\"`, `\"hex\"`, `\"binary\"` | `\"decimal\"` |\n\n**CTF View (cascaded transfer functions):**\n| Property | Values | Default |\n|----------|--------|---------|\n| `CTFAnalysisMode` | `\"complete\"`, `\"individual\"`, `\"cumulative\"`, `\"specify\"` | `\"complete\"` |\n\n---\n\n## Workflow Examples\n\n### Example 1: Multi-Display Filter Comparison\n\n```matlab\n%% Compare Butterworth, Elliptic, and FIR filters\nFs = 44100;\n\n% Design filters\nd_butter = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=2000, StopbandFrequency=2500, ...\n    PassbandRipple=1, StopbandAttenuation=60, ...\n    SampleRate=Fs, DesignMethod=\"butter\");\n\nd_ellip = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=2000, StopbandFrequency=2500, ...\n    PassbandRipple=1, StopbandAttenuation=60, ...\n    SampleRate=Fs, DesignMethod=\"ellip\");\n\nd_fir = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=2000, StopbandFrequency=2500, ...\n    PassbandRipple=1, StopbandAttenuation=60, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n\nfilterNames = [\"Butterworth\", \"Elliptic\", \"FIR_Equiripple\"];\n\n% Open with magnitude + phase overlay\n[fa, disp1] = filterAnalyzer(d_butter, d_ellip, d_fir, ...\n    FilterNames=filterNames, ...\n    SampleRates=Fs, ...\n    Analysis=\"magnitude\", OverlayAnalysis=\"phase\");\n\n% Add group delay display\ndisp2 = addDisplays(fa, Analysis=\"groupdelay\");\nshowFilters(fa, true, FilterNames=filterNames, DisplayNums=disp2);\n\n% Add impulse + step response display\ndisp3 = addDisplays(fa, Analysis=\"impulse\", OverlayAnalysis=\"step\");\nshowFilters(fa, true, FilterNames=filterNames, DisplayNums=disp3);\n\n% Add pole-zero plot\ndisp4 = addDisplays(fa, Analysis=\"polezero\");\nshowFilters(fa, true, FilterNames=filterNames, DisplayNums=disp4);\n\n% Customize magnitude display for log frequency scale\nopts = getAnalysisOptions(fa, DisplayNums=disp1);\nopts.FrequencyScale = \"log\";\nsetAnalysisOptions(fa, opts, DisplayNums=disp1);\n```\n\n### Example 2: Iterative Design with Live Updates\n\n```matlab\n%% Iterative filter design - update without duplicates\nFs = 48000;\n\n% Initial design\nd = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=1000, StopbandFrequency=1200, ...\n    PassbandRipple=0.1, StopbandAttenuation=60, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n\nfa = filterAnalyzer(d, FilterNames=\"LP_Design\", SampleRates=Fs, ...\n    Analysis=\"magnitude\", OverlayAnalysis=\"phase\");\n\n% ... user reviews, wants tighter transition band ...\n\n% Update design - replaceFilters keeps same name, no duplicates\nd_v2 = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=1000, StopbandFrequency=1100, ...\n    PassbandRipple=0.1, StopbandAttenuation=60, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n\nreplaceFilters(fa, d_v2, FilterNames=\"LP_Design\", SampleRates=Fs);\n% Display updates in-place, no \"LP_Design_1\" created\n```\n\n### Example 3: Complete Session Management Pattern\n\n```matlab\n%% Robust pattern for repeated runs\nFs = 44100;\nfilterNames = [\"FIR_Equiripple\", \"FIR_Kaiser\", \"FIR_Hamming\"];\n\n% Design filters\nd_eq = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=2800, StopbandFrequency=3100, ...\n    PassbandRipple=0.1, StopbandAttenuation=60, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n\nd_kaiser = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=2800, StopbandFrequency=3100, ...\n    PassbandRipple=0.1, StopbandAttenuation=60, ...\n    SampleRate=Fs, DesignMethod=\"kaiserwin\");\n\nd_hamming = designfilt(\"lowpassfir\", ...\n    FilterOrder=200, CutoffFrequency=2950, ...\n    SampleRate=Fs, DesignMethod=\"window\", Window=hamming(201));\n\n%% Visualize in Filter Analyzer (no duplicates on re-run)\nif exist('fa', 'var') && isvalid(fa)\n    % App already open - fresh start\n    newSession(fa);\n    addFilters(fa, d_eq, d_kaiser, d_hamming, ...\n        FilterNames=filterNames, SampleRates=Fs);\nelse\n    % First run - create new session\n    fa = filterAnalyzer(d_eq, d_kaiser, d_hamming, ...\n        FilterNames=filterNames, SampleRates=Fs, ...\n        Analysis=\"magnitude\", OverlayAnalysis=\"phase\");\nend\n\n% Add more displays\naddDisplays(fa, Analysis=\"groupdelay\");\nshowFilters(fa, true, FilterNames=filterNames);\n\naddDisplays(fa, Analysis=\"impulse\", OverlayAnalysis=\"step\");\nshowFilters(fa, true, FilterNames=filterNames);\n```\n\n---\n\n## Getting Existing Filter Names (Undocumented)\n\nNo official API exists, but this helper function works:\n\n```matlab\nfunction names = getFilterAnalyzerFilterNames(fa)\n    % Get filter names from an open Filter Analyzer session\n    % Usage: names = getFilterAnalyzerFilterNames(fa)\n    %        names = getFilterAnalyzerFilterNames()  % auto-gets handle\n\n    if nargin < 1\n        fa = getFilterAnalyzerHandle;\n    end\n\n    warning('off', 'MATLAB:structOnObject');\n    try\n        s = struct(fa);\n        impl = s.FilterAnalyzerImpl;\n        implStruct = struct(impl);\n        faModel = struct(struct(implStruct.MainModel).FilterAnalyzerModel);\n        filterInfoMap = faModel.FilterInfoMap;\n\n        k = keys(filterInfoMap);\n        names = strings(1, length(k));\n\n        for i = 1:length(k)\n            fwa = struct(struct(filterInfoMap(k(i))).FilterWithAnalysis);\n            names(i) = string(fwa.Name);\n        end\n    catch ME\n        names = strings(0);\n        warning('Could not get filter names: %s', ME.message);\n    end\n    warning('on', 'MATLAB:structOnObject');\nend\n```\n\n**Example usage**:\n```matlab\nfa = getFilterAnalyzerHandle;\nexistingNames = getFilterAnalyzerFilterNames(fa);\ndisp(existingNames);  % [\"FIR_Equiripple\", \"FIR_Kaiser\", \"FIR_Hamming\"]\n```\n\n---\n\n## Visualizing Multirate Filters\n\nFilter Analyzer fully supports multirate System objects including `dsp.FIRDecimator`, `dsp.FIRInterpolator`, and `dsp.FilterCascade` (from multistage designs).\n\n### Example 1: Compare Decimator Designs\n\n```matlab\n%% Compare single-stage vs multistage decimators\nFs = 44100;\n\n% Single-stage decimators\ndec4 = designMultirateFIR(DecimationFactor=4, SystemObject=true);\ndec8 = designMultirateFIR(DecimationFactor=8, SystemObject=true);\n\n% Multistage decimator (automatic cascade optimization)\ndecMultistage = designMultistageDecimator(8);\n\n% Compare all three in Filter Analyzer\nfilterAnalyzer(dec4, dec8, decMultistage, ...\n    SampleRates=Fs, ...\n    FilterNames=[\"Decim4_Single\", \"Decim8_Single\", \"Decim8_Multistage\"], ...\n    Analysis=\"magnitude\");\n```\n\n### Example 2: Compare Interpolator Designs\n\n```matlab\n%% Compare interpolators with different attenuation specs\nFs = 48000;\n\ninterp_60dB = designMultirateFIR(InterpolationFactor=4, ...\n    StopbandAttenuation=60, SystemObject=true);\ninterp_80dB = designMultirateFIR(InterpolationFactor=4, ...\n    StopbandAttenuation=80, SystemObject=true);\n\nfilterAnalyzer(interp_60dB, interp_80dB, ...\n    SampleRates=Fs, ...\n    FilterNames=[\"Interp_60dB\", \"Interp_80dB\"], ...\n    Analysis=\"magnitude\", OverlayAnalysis=\"phase\");\n```\n\n### Example 3: Analyze Multistage Cascade Structure\n\n```matlab\n%% Visualize a multistage decimator cascade\nFs = 44100;\ndecCascade = designMultistageDecimator(16);\n\n% View overall response\nfilterAnalyzer(decCascade, SampleRates=Fs, FilterNames=\"Multistage16x\");\n\n% Check cascade structure\ninfo(decCascade)\n```\n\n### Supported Multirate Types\n\n| System Object | Created By | Filter Analyzer Support |\n|---------------|------------|------------------------|\n| `dsp.FIRDecimator` | `designMultirateFIR(..., SystemObject=true)` | ✓ Full support |\n| `dsp.FIRInterpolator` | `designMultirateFIR(..., SystemObject=true)` | ✓ Full support |\n| `dsp.FIRRateConverter` | `designMultirateFIR(..., SystemObject=true)` | ✓ Full support |\n| `dsp.FilterCascade` | `designMultistageDecimator()` | ✓ Full support |\n| `dsp.FilterCascade` | `designMultistageInterpolator()` | ✓ Full support |\n| `dsp.FilterCascade` | Manual cascade (see below) | ✓ Full support |\n\n### Example 4: Visualizing Multirate Pipelines (dec→filter→interp)\n\nWhen comparing multirate pipelines against single-stage filters, wrap the complete pipeline in `dsp.FilterCascade`:\n\n```matlab\n%% Compare FIR, IFIR, and Multirate Pipeline side-by-side\nFs = 44100;\nM = 4;\n\n% Approach 1: Single-stage FIR\nd_fir = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=2800, StopbandFrequency=3000, ...\n    PassbandRipple=0.1, StopbandAttenuation=60, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\nfir_sys = dsp.FIRFilter('Numerator', d_fir.Numerator);\n\n% Approach 2: IFIR\nHf = fdesign.lowpass(2800/(Fs/2), 3000/(Fs/2), 0.1, 60);\nifir_sys = ifir(Hf, 'SystemObject', true);\n\n% Approach 3: Multirate pipeline (dec → filter → interp)\ndec_sys = designMultirateFIR(DecimationFactor=M, StopbandAttenuation=60, SystemObject=true);\nd_core = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=2800, StopbandFrequency=3000, ...\n    PassbandRipple=0.1, StopbandAttenuation=60, ...\n    SampleRate=Fs/M, DesignMethod=\"equiripple\");\ncore_sys = dsp.FIRFilter('Numerator', d_core.Numerator);  % Wrap for cascade\ninterp_sys = designMultirateFIR(InterpolationFactor=M, StopbandAttenuation=60, SystemObject=true);\n\n% Create cascade from pipeline\nmultirate_cascade = dsp.FilterCascade(dec_sys, core_sys, interp_sys);\n\n% Compare ALL THREE in Filter Analyzer\nfa = filterAnalyzer(fir_sys, ifir_sys, multirate_cascade, ...\n    FilterNames=[\"FIR_SingleStage\", \"IFIR_Cascade\", \"Multirate_Pipeline\"], ...\n    SampleRates=Fs, Analysis=\"magnitude\");\n\n% Add group delay for latency comparison\naddDisplays(fa, Analysis=\"groupdelay\");\nshowFilters(fa, true, FilterNames=[\"FIR_SingleStage\", \"IFIR_Cascade\", \"Multirate_Pipeline\"]);\n\n% Compare MPIS\nfprintf('MPIS: FIR=%.0f, IFIR=%.0f, Multirate=%.0f\\n', ...\n    cost(fir_sys).MultiplicationsPerInputSample, ...\n    cost(ifir_sys).MultiplicationsPerInputSample, ...\n    cost(multirate_cascade).MultiplicationsPerInputSample);\n```\n\n**Key points:**\n- Wrap `digitalFilter` in `dsp.FIRFilter` before adding to cascade\n- Use `dsp.FilterCascade(dec, filter, interp)` to create a single object\n- Filter Analyzer shows the **overall** frequency response of the cascade\n- Use same `SampleRates=Fs` for all (multirate rates are handled internally)\n\n---\n\n## Tips and Gotchas\n\n1. **Match FilterNames to variable names**: Use the same name as your workspace variable so you can easily identify filters. Example: `filterAnalyzer(d_butter, d_ellip, FilterNames=[\"d_butter\", \"d_ellip\"])` — not `[\"Butterworth\", \"Elliptic\"]`\n2. **Always store the handle**: Keep `fa` in your workspace to manage the session\n3. **Check validity**: Use `isvalid(fa)` before calling methods\n4. **Lost your handle?**: Use `fa = getFilterAnalyzerHandle` to recover it\n5. **Persist across sessions**: Use `saveSession(fa, 'myfilters.mat')` and load later\n6. **FilterNames must be valid MATLAB identifiers**: No spaces, hyphens, or special characters. Use underscores: `\"d_butter\"` not `\"d-butter\"` or `\"d butter\"`\n7. **Overlay rules are strict**: Frequency-domain only overlays with frequency-domain; time-domain with time-domain. `polezero`, `info`, `coefficients` don't support overlays.\n8. **Name-value syntax required**: Most methods use `DisplayNums=`, `FilterNames=` syntax, not positional arguments\n9. **Zoom presets**: `\"passband\"`, `\"default\"`, `\"x\"`, `\"y\"`, `\"xy\"` — custom axis limits require using the app UI\n10. **`filterAnalyzer` returns display number**: `[fa, dispNum] = filterAnalyzer(...)` — only the initial call returns both\n\n---\n\n## Version Info\n\n- `filterAnalyzer` function: **R2024a+**\n- `replaceFilters` method: **R2024a+**\n- `getAnalysisOptions` / `setAnalysisOptions`: **R2024a+**\n- `LegendStrings` argument: **R2025a+**\n- Tested on: **R2024b**\n",
        "skills/matlab-digital-filter-design/knowledge/multirate.md": "# Multirate Filtering Guide\n\nComplete guide for multirate filtering in MATLAB. Covers when to use each function, streaming vs offline workflows, and cost analysis.\n---\n\n## Table of Contents\n- [Critical Decision: Which Function to Use?](#critical-decision-which-function-to-use)\n- [When Not to Use designMultistageDecimator/Interpolator](#important-when-not-to-use-designmultistagedecimatorinterpolator)\n- [Concept: Multirate Pipeline](#concept-multirate-pipeline)\n- [Workflow 1: Streaming Multirate](#workflow-1-streaming-multirate-narrow-transition)\n- [Workflow 2: Offline Zero-Phase](#workflow-2-offline-zero-phase-narrow-transition)\n- [Workflow 3: Wideband Rate Conversion](#workflow-3-wideband-rate-conversion-large-m)\n- [Workflow 4: Complex Specifications](#workflow-4-complex-specifications-fdesign)\n- [Cost Analysis](#cost-analysis-how-to-compare-approaches)\n- [Key Functions Reference](#key-functions-reference)\n- [Gotchas](#gotchas)\n- [API References](#api-references)\n- [Visualization](#visualization)\n\n## Critical Decision: Which Function to Use?\n\n**The choice of multirate function depends on your use case.** Using the wrong function can result in 5× worse performance.\n\n### Quick Decision Table\n\n| Use Case | Recommended Approach | Why |\n|----------|---------------------|-----|\n| **Narrow transition + streaming** | `designMultirateFIR` + separate sharp filter | Relaxed anti-alias + efficient sharp filter at low rate |\n| **Narrow transition + offline** | `resample()` + sharp filter + `filtfilt()` | Simplest, built-in anti-alias, zero-phase |\n| **Wideband rate change (M≥8)** | `designMultistageDecimator/Interpolator` | Automatic cascade optimization |\n| **Complex frequency specs** | `fdesign.decimator` + `design()` | Flexible specification object |\n| **CIC or halfband filters** | `fdesign.decimator` with CIC response | Specialized filter types |\n\n---\n\n## IMPORTANT: When NOT to Use designMultistageDecimator/Interpolator\n\n**These functions are NOT optimal for narrow-transition filtering!**\n\nWhen you pass tight specs (narrow TW, high Astop), these functions try to achieve the sharp transition **within** the decimation/interpolation, requiring very long filters.\n\n### Real Example (Fs=44.1kHz, Fpass=2.8kHz, Fstop=3.1kHz, 60dB)\n\n| Approach | MPIS | Result |\n|----------|------|--------|\n| `designMultirateFIR` + sharp filter | **115.75** | BEST |\n| Single-stage FIR | 407.00 | Baseline |\n| `designMultistageDecimator` + `Interpolator` with tight specs | 531.25 | WORSE! |\n\n**Lesson**: For narrow transitions, use `designMultirateFIR` (relaxed anti-alias) + **separate sharp filter at reduced rate**.\n\n### When designMultistage* IS Optimal\n\nFor **wideband rate conversion** (just anti-alias, no specific filtering), `designMultistageDecimator/Interpolator` with **default specs** is very efficient:\n\n| M | designMultirateFIR (MPIS) | designMultistage* (MPIS) | Winner |\n|---|---------------------------|--------------------------|--------|\n| 4 | 90.2 | **60.8** | Multistage |\n| 8 | 189.1 | **81.9** | Multistage (2.3×) |\n| 16 | 382.6 | **128.4** | Multistage (3.0×) |\n| 32 | 767.3 | **190.7** | Multistage (4.0×) |\n\n---\n\n## Concept: Multirate Pipeline\n\n```\nInput (Fs) → Decimate (÷M) → Filter (Fs/M) → Interpolate (×M) → Output (Fs)\n```\n\n**Why it works**: A 400-tap filter at 44.1 kHz becomes a ~100-tap filter at 11 kHz (after 4× decimation), and processes 1/4 as many samples.\n\n**Output rate = Input rate**: Decimation and interpolation cancel out.\n\n---\n\n## Workflow 1: Streaming Multirate (Narrow Transition)\n\n**Use `designMultirateFIR` for anti-alias + separate sharp filter.**\n\n```matlab\n%% Streaming multirate with narrow transition band\nFs = 44100;\nFpass = 2800; Fstop = 3100;\nRp = 0.1; Rs = 60;\nM = 4;  % Decimation/interpolation factor\nFs_dec = Fs / M;\n\n%% Design filters\n% Step 1: Decimator with RELAXED anti-alias (just prevent aliasing)\ndec = designMultirateFIR(DecimationFactor=M, ...\n    StopbandAttenuation=Rs, SystemObject=true);\n\n% Step 2: Sharp lowpass at reduced rate\nd_sharp = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs_dec, DesignMethod=\"equiripple\");\n\n% Step 3: Interpolator with anti-image\ninterp = designMultirateFIR(InterpolationFactor=M, ...\n    StopbandAttenuation=Rs, SystemObject=true);\n\n%% Process frames (streaming)\nframeSize = 1024;  % Must be multiple of M\ny = zeros(size(x));\n\nfor i = 1:frameSize:length(x)-frameSize+1\n    frame = x(i:i+frameSize-1);\n\n    % Pipeline: decimate → sharp filter → interpolate\n    frame_dec = dec(frame);\n    frame_filt = filter(d_sharp, frame_dec);  % Causal\n    frame_out = interp(frame_filt);\n\n    y(i:i+frameSize-1) = frame_out;\nend\n```\n\n**Note**: Streaming is **causal only** — no `filtfilt()`. There will be group delay.\n\n---\n\n## Workflow 2: Offline Zero-Phase (Narrow Transition)\n\n**Use `resample()` for simplicity — it has built-in anti-alias/anti-image filters.**\n\n```matlab\n%% Offline multirate with zero-phase sharp filter\nFs = 44100;\nFpass = 2800; Fstop = 3100;\nRp = 0.1; Rs = 60;\nM = 4;\nFs_dec = Fs / M;\n\n% Load signal\n[x, ~] = audioread(\"noisy_signal.wav\");\n\n%% Stage 1: Decimate (resample handles anti-aliasing)\nx_dec = resample(x, 1, M);\n\n%% Stage 2: Sharp lowpass at reduced rate (zero-phase)\nd_sharp = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs_dec, DesignMethod=\"equiripple\");\n\nx_filt = filtfilt(d_sharp, x_dec);  % Zero-phase at low rate\n\n%% Stage 3: Interpolate back (resample handles anti-imaging)\ny = resample(x_filt, M, 1);\n\n% Output y is at original Fs, zero-phase filtered\n```\n\n**Advantages**:\n- Simple 3-line pipeline\n- `resample()` handles anti-alias/anti-image automatically\n- `filtfilt()` gives zero-phase at reduced computational cost\n\n---\n\n## Workflow 3: Wideband Rate Conversion (Large M)\n\n**Use `designMultistageDecimator/Interpolator` with DEFAULT specs for pure rate change.**\n\n```matlab\n%% Wideband rate conversion (M=16, no specific filtering)\nM = 16;\nFs = 48000;\n\n% Default specs - optimized for wideband anti-alias\ndec = designMultistageDecimator(M);\ninterp = designMultistageInterpolator(M);\n\n% View cascade structure\ninfo(dec)\ninfo(interp)\n\n% Cost comparison\ncost_dec = cost(dec);\ncost_interp = cost(interp);\nfprintf('Decimator: %.2f MPIS\\n', cost_dec.MultiplicationsPerInputSample);\nfprintf('Interpolator: %.2f MPIS\\n', cost_interp.MultiplicationsPerInputSample);\n\n% Apply (streaming)\ny_dec = dec(x);\ny_out = interp(y_dec);\n```\n\n**When to use**: Decimation factor M > 8, or when you want MATLAB to optimize the cascade automatically.\n\n---\n\n## Workflow 4: Complex Specifications (fdesign)\n\n**Use `fdesign.decimator` when you need specific passband/stopband control.**\n\n```matlab\n%% fdesign.decimator with lowpass specification\nM = 4;\nFs = 44100;\nFpass_norm = 2800 / Fs;  % Normalized to Fs\nFstop_norm = 3100 / Fs;\nRp = 0.1; Rs = 60;\n\n% Create specification object\nd = fdesign.decimator(M, 'lowpass', 'Fp,Fst,Ap,Ast', ...\n    Fpass_norm, Fstop_norm, Rp, Rs);\n\n% Available design methods\ndesignmethods(d)\n\n% Design with kaiserwin (handles tight specs)\nhd = design(d, 'kaiserwin', SystemObject=true);\ncost(hd)\n\n% Design with multistage (deprecated - use designMultistageDecimator)\n% hd_multi = design(d, 'multistage', SystemObject=true);\n```\n\n**Key points**:\n- Frequencies are normalized to Fs (0 to 1)\n- Use `'kaiserwin'` for tight specs where `'equiripple'` fails\n- The `'multistage'` method is deprecated — use `designMultistageDecimator` instead\n\n---\n\n## Cost Analysis: How to Compare Approaches\n\n### Using the cost() Function\n\n```matlab\n%% Measure MPIS for each component\nM = 4;\nRs = 60;\n\n% Decimator\ndec = designMultirateFIR(DecimationFactor=M, ...\n    StopbandAttenuation=Rs, SystemObject=true);\ncost_dec = cost(dec);\nfprintf('Decimator: %d taps, %.2f MPIS\\n', ...\n    length(dec.Numerator), cost_dec.MultiplicationsPerInputSample);\n\n% Sharp filter at reduced rate\nd_sharp = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=2800, StopbandFrequency=3100, ...\n    StopbandAttenuation=Rs, SampleRate=44100/M, ...\n    DesignMethod=\"equiripple\");\nsharp_sys = dsp.FIRFilter(Numerator=d_sharp.Numerator);\ncost_sharp = cost(sharp_sys);\nfprintf('Sharp filter: %d taps, %.2f MPIS (at 1/%d rate = %.2f effective)\\n', ...\n    length(d_sharp.Numerator), cost_sharp.MultiplicationsPerInputSample, ...\n    M, cost_sharp.MultiplicationsPerInputSample/M);\n\n% Interpolator\ninterp = designMultirateFIR(InterpolationFactor=M, ...\n    StopbandAttenuation=Rs, SystemObject=true);\ncost_interp = cost(interp);\nfprintf('Interpolator: %d taps, %.2f MPIS\\n', ...\n    length(interp.Numerator), cost_interp.MultiplicationsPerInputSample);\n\n% Total pipeline cost\ntotal_mpis = cost_dec.MultiplicationsPerInputSample + ...\n             cost_sharp.MultiplicationsPerInputSample/M + ...\n             cost_interp.MultiplicationsPerInputSample;\nfprintf('TOTAL: %.2f MPIS\\n', total_mpis);\n```\n\n### Comparing with resample() Pipeline\n\n`resample()` has internal filters not exposed to `cost()`. Use `timeit()`:\n\n```matlab\nx = randn(44100*2, 1);  % 2 seconds at 44.1 kHz\n\nf_pipeline = @() resample(filtfilt(d_sharp, resample(x, 1, M)), M, 1);\nt_pipeline = timeit(f_pipeline);\nfprintf('Offline pipeline: %.2f ms\\n', t_pipeline * 1000);\n```\n\n---\n\n## Key Functions Reference\n\n| Function | Use Case | Returns |\n|----------|----------|---------|\n| `designMultirateFIR()` | Single-stage decimator/interpolator | Coefficients or System object |\n| `designMultistageDecimator()` | Optimal cascaded decimator (large M, wideband) | `dsp.FilterCascade` |\n| `designMultistageInterpolator()` | Optimal cascaded interpolator (large M, wideband) | `dsp.FilterCascade` |\n| `resample(x, P, Q)` | Offline rate conversion with anti-alias | Resampled signal |\n| `fdesign.decimator()` | Flexible decimator specification | Specification object |\n| `fdesign.interpolator()` | Flexible interpolator specification | Specification object |\n| `dsp.FIRDecimator` | Streaming decimation System object | System object |\n| `dsp.FIRInterpolator` | Streaming interpolation System object | System object |\n\n---\n\n## Gotchas\n\n### 1. Don't Use designMultistage* with Tight Specs for Narrow Transitions\n\n```matlab\n% WRONG: Trying to do sharp filtering within decimation\ndec = designMultistageDecimator(M, Fs, TW, Rs);  % TW = narrow\n\n% RIGHT: Relaxed decimator + separate sharp filter\ndec = designMultirateFIR(DecimationFactor=M, ...);\nd_sharp = designfilt(\"lowpassfir\", ..., SampleRate=Fs/M);\n```\n\n### 2. Don't Use System Objects with filtfilt()\n\n```matlab\n% WRONG: System objects have internal state\ndec_sys = designMultirateFIR(DecimationFactor=M, SystemObject=true);\ny = filtfilt(dec_sys, x);  % ERROR!\n\n% RIGHT: Use resample() for offline zero-phase\nx_dec = resample(x, 1, M);\n```\n\n### 3. Frame Size Must Be Multiple of M\n\n```matlab\n% For streaming decimation\nframeSize = 1024;  % OK for M=4 (1024/4 = 256)\nframeSize = 1000;  % ERROR for M=4 (not divisible)\n```\n\n### 4. resample() Has Hidden Filter Cost\n\nDon't claim \"100 taps at 11 kHz\" — `resample()` adds its own anti-alias/anti-image filtering. Measure total pipeline cost with `timeit()`.\n\n### 5. Fs Meaning Differs Between Functions\n\n- `designMultistageDecimator(M, Fs, ...)`: Fs = **input** rate\n- `designMultistageInterpolator(L, Fs, ...)`: Fs = **output** rate (R2024b+)\n\n---\n\n## API References\n\n| Doc File | Content |\n|----------|---------|\n| `docs/ref_designMultirateFIR.md` | Single-stage decimator/interpolator design |\n| `docs/ref_designMultistageDecimator.md` | Optimal cascaded decimator |\n| `docs/ref_designMultistageInterpolator.md` | Optimal cascaded interpolator |\n| `docs/ref_resample.md` | Offline sample rate conversion |\n| `docs/dsp_multirate-filtering.md` | Multirate concepts overview |\n\n---\n\n## Visualization\n\n**All multirate filters work with Filter Analyzer** for response visualization and comparison.\n\n### Visualizing Individual Multirate Filters\n\n```matlab\n% Compare decimator designs in Filter Analyzer\ndec4 = designMultirateFIR(DecimationFactor=4, SystemObject=true);\ndecMulti = designMultistageDecimator(8);\nfilterAnalyzer(dec4, decMulti, SampleRates=Fs, ...\n    FilterNames=[\"SingleStage\", \"Multistage\"]);\n```\n\n### Visualizing Complete Multirate Pipelines\n\n**IMPORTANT**: For comparing dec→filter→interp pipelines against single-stage filters, wrap the complete pipeline in `dsp.FilterCascade`:\n\n```matlab\n%% Create cascade from multirate pipeline for Filter Analyzer\nFs = 44100; M = 4;\n\n% Build pipeline components\ndec_sys = designMultirateFIR(DecimationFactor=M, StopbandAttenuation=60, SystemObject=true);\nd_core = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=2800, StopbandFrequency=3000, ...\n    StopbandAttenuation=60, SampleRate=Fs/M, DesignMethod=\"equiripple\");\ncore_sys = dsp.FIRFilter('Numerator', d_core.Numerator);  % Wrap digitalFilter!\ninterp_sys = designMultirateFIR(InterpolationFactor=M, StopbandAttenuation=60, SystemObject=true);\n\n% Create cascade for visualization\nmultirate_cascade = dsp.FilterCascade(dec_sys, core_sys, interp_sys);\n\n% Add to Filter Analyzer alongside other filter types\nfilterAnalyzer(multirate_cascade, SampleRates=Fs, FilterNames=\"Multirate_Pipeline\");\n```\n\n**Key points:**\n- Wrap `digitalFilter` in `dsp.FIRFilter` before adding to cascade\n- `dsp.FilterCascade` shows the **overall** response of the pipeline\n- Use same `SampleRates=Fs` as the input rate\n\nSee `knowledge/filter-analyzer.md` → \"Visualizing Multirate Pipelines\" for complete comparison examples.\n\n---\n\n## See Also\n\n- `knowledge/efficient-filtering.md` — Decision guide for choosing approach\n- `knowledge/multistage-ifir.md` — IFIR (constant-rate alternative)\n- `knowledge/patterns.md` — Code templates\n- `knowledge/filter-analyzer.md` — Multirate filter visualization\n",
        "skills/matlab-digital-filter-design/knowledge/multistage-ifir.md": "# IFIR and Multistage Filtering Guide\n\nComplete guide for **Interpolated FIR (IFIR)** filters — a multistage approach that operates at **constant sample rate** (no decimation/interpolation).\n---\n\n## Table of Contents\n- [Concept](#concept)\n- [When to Use IFIR](#when-to-use-ifir)\n- [Key Functions](#key-functions)\n- [Workflow 1: SystemObject Method](#workflow-1-systemobject-method-filter-analyzer-compatible)\n- [Workflow 2: Raw Coefficients Method](#workflow-2-raw-coefficients-method-for-filtfilt)\n- [Understanding IFIR Structure](#understanding-ifir-structure)\n- [Cost Analysis](#cost-analysis)\n- [Comparison: IFIR vs Multirate](#comparison-ifir-vs-multirate)\n- [Choosing Interpolation Factor L](#choosing-interpolation-factor-l)\n- [Gotchas](#gotchas)\n- [API References](#api-references)\n- [See Also](#see-also)\n\n## Concept\n\nIFIR uses two filters in cascade:\n\n```\nInput → Model Filter h(z^L) → Image Suppressor g(z) → Output\n        (sparse)              (removes images)\n```\n\n- **Model filter `h(z^L)`**: Sparse filter with zeros inserted between taps (stretched by factor L)\n- **Image suppressor `g(z)`**: Removes spectral images created by the sparse filter\n- **Combined response**: Achieves the target narrowband response with fewer total multipliers\n\n**Key advantage**: Sample rate stays constant throughout — no decimation or interpolation needed.\n\n---\n\n## When to Use IFIR\n\n| Criterion | IFIR | Alternative |\n|-----------|------|-------------|\n| trans_pct < 2% | ✓ Good choice | Single-stage OK if > 5% |\n| Rate change problematic | ✓ **Best choice** | Multirate changes rate internally |\n| Need linear phase | ✓ Maintains linear phase | IIR loses linear phase |\n| Filter Analyzer visualization | ✓ Works with SystemObject=true | Multirate pipelines can't be visualized end-to-end |\n\n---\n\n## Key Functions\n\n| Function | Returns | Filter Analyzer? | filtfilt()? |\n|----------|---------|------------------|-------------|\n| `ifir(Hf, SystemObject=true)` | `dsp.FilterCascade` | ✓ Yes | ✗ Use object directly |\n| `ifir(L, 'low', freqs, devs)` | Raw coefficients `[b_ifir]` | ✗ No | ✓ Yes |\n| `design(Hf, 'ifir', SystemObject=true)` | `dsp.FilterCascade` | ✓ Yes | ✗ Use object directly |\n\n---\n\n## Workflow 1: SystemObject Method (Filter Analyzer Compatible)\n\nUse this when you want to visualize in Filter Analyzer or use streaming.\n\n```matlab\n%% IFIR with SystemObject (Filter Analyzer compatible)\nFs = 44100;\nFpass = 2800; Fstop = 3200;\nRp = 0.1; Rs = 60;\n\n% Create filter specification (normalized frequencies)\nFn = Fs / 2;\nHf = fdesign.lowpass(Fpass/Fn, Fstop/Fn, Rp, Rs);\n\n% Design IFIR filter (returns dsp.FilterCascade)\nd_ifir = ifir(Hf, SystemObject=true);\n% Alternative: d_ifir = design(Hf, 'ifir', SystemObject=true);\n\n% View structure\ninfo(d_ifir)\n\n% Visualize in Filter Analyzer\nfilterAnalyzer(d_ifir, FilterNames=\"IFIR_Lowpass\", SampleRates=Fs, ...\n    Analysis=\"magnitude\", OverlayAnalysis=\"phase\");\n\n% Apply filter (streaming - causal)\ny = d_ifir(x);\n\n% For batch processing, reset between uses\nreset(d_ifir);\n```\n\n**Note**: `dsp.FilterCascade` objects work directly with Filter Analyzer but **cannot** be used with `filtfilt()`.\n\n---\n\n## Workflow 2: Raw Coefficients Method (For filtfilt)\n\nUse this when you need zero-phase filtering with `filtfilt()`.\n\n```matlab\n%% IFIR with raw coefficients (for filtfilt)\nFs = 44100;\nFpass = 2800; Fstop = 3200;\nRp = 0.1; Rs = 60;\nFn = Fs / 2;\n\n% Calculate deviations from ripple specs\ndev_pass = (10^(Rp/20) - 1) / (10^(Rp/20) + 1);\ndev_stop = 10^(-Rs/20);\n\n% Choose interpolation factor L (typically 2-8)\nL = 4;  % Higher L = more sparse model filter\n\n% Design IFIR (returns coefficient vectors)\n[b_ifir, b_model, b_image] = ifir(L, 'low', [Fpass Fstop]/Fn, [dev_pass dev_stop]);\n\n% Apply with filtfilt (zero-phase)\ny = filtfilt(b_ifir, 1, x);\n\n% Report filter lengths\nfprintf('Combined IFIR: %d taps\\n', length(b_ifir));\nfprintf('Model filter:  %d taps (sparse)\\n', length(b_model));\nfprintf('Image suppressor: %d taps\\n', length(b_image));\n```\n\n**Note**: Raw coefficients work with `filtfilt()` but cannot be added directly to Filter Analyzer.\n\n---\n\n## Understanding IFIR Structure\n\n### Model Filter h(z^L)\n\nThe model filter is \"stretched\" by inserting L-1 zeros between each coefficient:\n\n```\nOriginal:  h = [h0, h1, h2, h3]\nStretched: h(z^4) = [h0, 0, 0, 0, h1, 0, 0, 0, h2, 0, 0, 0, h3]\n```\n\nThis creates a narrower transition band but introduces spectral images.\n\n### Image Suppressor g(z)\n\nA short lowpass filter that removes the images created by the sparse model filter.\n\n### Why It's Efficient\n\n| Component | Taps | Non-zero Multiplies |\n|-----------|------|---------------------|\n| Model filter h(z^L) | ~400 (sparse) | ~100 (only every L-th) |\n| Image suppressor g(z) | ~30 | ~30 |\n| **Total** | ~430 | **~130** |\n\nCompare to single-stage FIR: 400 taps = 400 multiplies.\n\n---\n\n## Cost Analysis\n\n### Measuring MPIS for IFIR\n\n```matlab\n%% Get MPIS for IFIR SystemObject\nFs = 44100;\nFpass = 2800; Fstop = 3200;\nRp = 0.1; Rs = 60;\nFn = Fs / 2;\n\nHf = fdesign.lowpass(Fpass/Fn, Fstop/Fn, Rp, Rs);\nd_ifir = ifir(Hf, SystemObject=true);\n\n% Get cost\nc = cost(d_ifir);\nfprintf('IFIR MPIS: %.2f\\n', c.MultiplicationsPerInputSample);\nfprintf('Coefficients: %d\\n', c.NumCoefficients);\n```\n\n### Comparison with Alternatives\n\n```matlab\n%% Compare IFIR vs single-stage vs IIR\n% Single-stage FIR\nd_fir = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    StopbandAttenuation=Rs, SampleRate=Fs, DesignMethod=\"equiripple\");\nfir_sys = dsp.FIRFilter('Numerator', d_fir.Numerator);\n\n% IIR Elliptic\nd_iir = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    StopbandAttenuation=Rs, SampleRate=Fs, DesignMethod=\"ellip\");\niir_sys = dsp.SOSFilter('Numerator', d_iir.Numerator, 'Denominator', d_iir.Denominator);\n\n% Compare\nfprintf('Single-stage FIR: %.0f MPIS\\n', cost(fir_sys).MultiplicationsPerInputSample);\nfprintf('IFIR:             %.0f MPIS\\n', cost(d_ifir).MultiplicationsPerInputSample);\nfprintf('IIR Elliptic:     %.0f MPIS\\n', cost(iir_sys).MultiplicationsPerInputSample);\n```\n\n---\n\n## Comparison: IFIR vs Multirate\n\n| Aspect | IFIR | Multirate |\n|--------|------|-----------|\n| **Sample rate** | Constant throughout | Changes internally |\n| **Structure** | Two filters in cascade | Decimate→filter→interpolate pipeline |\n| **Filter Analyzer** | ✓ Works directly | ✗ Can't show end-to-end |\n| **Zero-phase offline** | Raw coefficients + filtfilt | resample + filtfilt |\n| **Complexity** | Simpler (one cascade) | More stages |\n| **Best for** | Rate change problematic | Large decimation possible |\n\n---\n\n## Choosing Interpolation Factor L\n\nThe interpolation factor L controls the trade-off between model filter sparsity and image suppressor length:\n\n| L | Model Filter | Image Suppressor | Total Efficiency |\n|---|--------------|------------------|------------------|\n| 2 | Less sparse | Shorter | Moderate |\n| 4 | More sparse | Medium | Good |\n| 8 | Very sparse | Longer | Diminishing returns |\n\n**Rule of thumb**: Start with L=4, adjust based on cost() measurements.\n\n```matlab\n% Compare different L values\nfor L = [2 4 6 8]\n    [b_ifir, ~, ~] = ifir(L, 'low', [Fpass Fstop]/Fn, [dev_pass dev_stop]);\n    fprintf('L=%d: %d total taps\\n', L, length(b_ifir));\nend\n```\n\n---\n\n## Gotchas\n\n### 1. SystemObject vs Raw Coefficients\n\n```matlab\n% SystemObject: Can't use with filtfilt\nd_ifir = ifir(Hf, SystemObject=true);\ny = filtfilt(d_ifir, x);  % ERROR!\n\n% Raw coefficients: Can't use with Filter Analyzer\n[b_ifir, ~, ~] = ifir(L, 'low', freqs, devs);\nfilterAnalyzer(b_ifir, ...);  % Won't show IFIR structure properly\n```\n\n### 2. Normalized Frequencies for fdesign\n\n```matlab\n% fdesign uses normalized frequencies (0 to 1, where 1 = Fs/2)\nFn = Fs / 2;\nHf = fdesign.lowpass(Fpass/Fn, Fstop/Fn, Rp, Rs);  % Normalized!\n\n% NOT: fdesign.lowpass(Fpass, Fstop, ...)  % Wrong!\n```\n\n### 3. Deviations vs dB for Raw ifir()\n\n```matlab\n% Raw ifir() uses linear deviations, not dB\nRp_dB = 0.1;  % Passband ripple in dB\nRs_dB = 60;   % Stopband attenuation in dB\n\ndev_pass = (10^(Rp_dB/20) - 1) / (10^(Rp_dB/20) + 1);  % Convert to deviation\ndev_stop = 10^(-Rs_dB/20);  % Convert to deviation\n\n[b_ifir, ~, ~] = ifir(L, 'low', freqs, [dev_pass dev_stop]);\n```\n\n---\n\n## API References\n\n| Doc File | Content |\n|----------|---------|\n| `docs/ref_ifir.md` | `ifir()` function reference |\n\n---\n\n## See Also\n\n- `knowledge/efficient-filtering.md` — Decision guide for choosing approach\n- `knowledge/multirate.md` — Multirate (rate-changing) alternative\n- `knowledge/patterns.md` — Code templates\n- `knowledge/filter-analyzer.md` — Visualizing IFIR filters\n",
        "skills/matlab-digital-filter-design/knowledge/patterns.md": "# Filter Design Patterns\n\nQuick design templates and application patterns for MATLAB digital filter design. Consult this file when you need ready-to-use code patterns.\n\n---\n## Table of Contents\n- [Quick Design Patterns](#quick-design-patterns)\n  - [High-Level One-Liners](#high-level-one-liners)\n  - [Order Estimation](#order-estimation)\n  - [Minimum-Phase FIR (Reduced Latency)](#minimum-phase-fir-reduced-latency)\n  - [IFIR (Interpolated FIR) for Narrow Transitions](#ifir-interpolated-fir-for-narrow-transitions)\n- [Multirate Design Patterns](#multirate-design-patterns)\n  - [Streaming Multirate](#streaming-multirate-modern-syntax-r2024a)\n  - [Offline Zero-Phase Multirate](#offline-zero-phase-multirate)\n  - [Wideband Rate Conversion](#wideband-rate-conversion-large-m)\n- [Application Patterns](#application-patterns)\n  - [Extract Coefficients](#extract-coefficients-from-digitalfilter-object)\n  - [Offline Validation](#offline-validation-zero-phase)\n  - [Streaming CTF](#streaming-ctf-path-r2024b)\n  - [Streaming SOS System Object](#streaming-sos-system-object-all-versions)\n  - [Advanced Filter Analyzer Usage](#advanced-filter-analyzer-usage)\n- [Complete Examples](#complete-examples)\n- [Quick Lookup](#quick-lookup)\n\n**Note**: For basic `designfilt()` syntax (response types, parameters, gotchas), see `cards/designfilt.md`.\n\n\n## Quick Design Patterns\n\n### High-Level One-Liners\n\nThese functions auto-design minimum-order filters and return `[y, d]`:\n\n```matlab\n% Lowpass / Highpass\n[y, d] = lowpass(x, Fpass, Fs, StopbandAttenuation=Rs, ImpulseResponse=\"iir\");\n[y, d] = highpass(x, Fpass, Fs, StopbandAttenuation=Rs, ImpulseResponse=\"iir\");\n\n% Bandpass / Bandstop (passband as [f1 f2])\n[y, d] = bandpass(x, [f1 f2], Fs, StopbandAttenuation=Rs, ImpulseResponse=\"iir\");\n[y, d] = bandstop(x, [f1 f2], Fs, StopbandAttenuation=Rs, ImpulseResponse=\"iir\");\n```\n\n**Note**: Set `ImpulseResponse=\"fir\"` for linear phase. Use `Steepness` parameter (0-1) to control transition width.\n\n---\n\n### Order Estimation\n\nUse MATLAB-native estimators to sanity-check how big a single-stage FIR might be **before** committing to multirate/IFIR.\n\n```matlab\n% Convert dB specs to linear deviations\ndev_p = (10^(Rp_dB/20)-1) / (10^(Rp_dB/20)+1);\ndev_s = 10^(-Rs_dB/20);\n\n% LOWPASS example (Hz). Adapt f/a for highpass/bandpass/bandstop.\nf = [Fpass Fstop];\na = [1 0];\ndev = [dev_p dev_s];\n\n% Kaiser window estimate\n[N_kaiser, Wn, beta, ftype] = kaiserord(f, a, dev, Fs);\n\n% Equiripple estimate (Parks–McClellan)\n[N_pm, fo, ao, w] = firpmord(f, a, dev, Fs);\n\nfprintf(\"Estimated order: Kaiser=%d, Equiripple=%d\\n\", N_kaiser, N_pm);\n```\n\n\n### Minimum-Phase FIR (Reduced Latency)\n\nUse `PhaseConstraint=\"minimum\"` with designfilt (**NOT** `MinimumPhase=true`):\n\n```matlab\n% Minimum-phase FIR (lower delay than linear phase, same order)\nd = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\", ...\n    PhaseConstraint=\"minimum\");  % CORRECT syntax\n\n% Alternative: firgr with 'minphase' flag (advanced)\nb = firgr(N, [0 Fp/Fn Fst/Fn 1], [1 1 0 0], [1 w], 'minphase');\n```\n\n**Trade-offs**:\n- Lower group delay than linear-phase (roughly half)\n- Non-linear phase (not suitable for phase-sensitive applications)\n- Cannot use `filtfilt()` (already minimum phase, would create mixed-phase result)\n- Use `filter()` for causal application\n\n---\n\n### IFIR (Interpolated FIR) for Narrow Transitions\n\nFor narrow transition bands (trans_pct < 2%; see `cards/efficient-filtering.md`), IFIR reduces total multipliers by using sparse filter + image suppressor at constant sample rate.\n\n**Method 1: fdesign + ifir with SystemObject (Recommended for Filter Analyzer)**\n\n```matlab\n% Design IFIR lowpass with fdesign (returns dsp.FilterCascade)\nFpass = 2800; Fstop = 3200; Fs = 44100;\n\nHf = fdesign.lowpass(Fpass/(Fs/2), Fstop/(Fs/2));\n\n% Two equivalent ways to get dsp.FilterCascade:\nd_ifir = ifir(Hf, SystemObject=true);           % Option 1\n% d_ifir = design(Hf, 'ifir', SystemObject=true);  % Option 2\n\n% Works directly with Filter Analyzer\nfilterAnalyzer(d_ifir, FilterNames=\"IFIR_Lowpass\", SampleRates=Fs);\n\n% Apply filter (streaming)\ny = d_ifir(x);\n\n% For offline zero-phase, use Method 2 (raw coefficients with filtfilt)\n```\n\n**Method 2: Raw ifir() function (For coefficient access and filtfilt)**\n\n```matlab\n% Raw IFIR design returns coefficient arrays\nFn = Fs/2;\ndev_pass = (10^(Rp/20) - 1) / (10^(Rp/20) + 1);\ndev_stop = 10^(-Rs/20);\n\n[b_ifir, b_model, b_image] = ifir(L, \"low\", [Fpass Fstop]/Fn, [dev_pass dev_stop]);\n\n% Apply with filtfilt (works with raw coefficients)\ny = filtfilt(b_ifir, 1, x);\n\n% WARNING: Raw coefficients don't work directly with filterAnalyzer()\n% Use Method 1 for Filter Analyzer compatibility\n```\n\n**When to use IFIR**:\n- Narrow transition bands (trans_pct < 2%; see `cards/efficient-filtering.md`)\n- Constant sample rate required (can't use multirate)\n- Need fewer multipliers than single-stage FIR\n\n**Trade-offs vs Multirate**:\n- IFIR: Constant rate, simpler pipeline, works with Filter Analyzer (Method 1)\n- Multirate: May be faster for very narrow bands, but internal rate change\n\n---\n\n## Multirate Design Patterns\n\n### Streaming Multirate (Modern Syntax, R2024a+)\n\nFor real-time/streaming applications with polyphase efficiency:\n\n```matlab\n% Example: Multistage lowpass (STREAMING/REAL-TIME)\nM = 4;  % Decimation factor\nFs_dec = Fs / M;  % Decimated sample rate\n\n% Stage 1: Anti-alias + decimate (modern syntax with SystemObject=true)\ndec_filt = designMultirateFIR(DecimationFactor=M, ...\n    StopbandAttenuation=Rs, SystemObject=true);\n\n% Stage 2: Sharp lowpass at reduced rate\nd_sharp = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs_dec, DesignMethod=\"equiripple\");\n\n% Stage 3: Interpolate + image rejection (modern syntax)\ninterp_filt = designMultirateFIR(InterpolationFactor=M, ...\n    StopbandAttenuation=Rs, SystemObject=true);\n\n% Apply cascade (STREAMING - causal, has group delay)\nx_dec = dec_filt(x);             % Decimate\nx_filt = filter(d_sharp, x_dec); % Sharp filter at low rate (causal)\ny = interp_filt(x_filt);         % Interpolate back to original Fs\n```\n\n### Offline Zero-Phase Multirate\n\nFor offline batch processing where zero-phase filtering is needed:\n\n```matlab\n% Example: Multistage lowpass (OFFLINE - zero-phase)\nM = 4;\nFs_dec = Fs / M;\n\n% Stage 1: Decimate with built-in anti-alias (use resample, NOT System objects)\nx_dec = resample(x, 1, M);\n\n% Stage 2: Sharp lowpass at reduced rate (zero-phase)\nd_sharp = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs_dec, DesignMethod=\"equiripple\");\n\nx_filt = filtfilt(d_sharp, x_dec);  % Zero-phase filtering\n\n% Stage 3: Interpolate back (use resample for proper alignment)\ny = resample(x_filt, M, 1);\n```\n\n**WARNING**: Do NOT use `dsp.FIRDecimator`/`FIRInterpolator` with `filtfilt()`. See `cards/multirate-offline.md` for details.\n\n### Wideband Rate Conversion (Large M)\n\nFor pure rate conversion with large factors (M≥8), use `designMultistageDecimator/Interpolator`:\n\n```matlab\n% Wideband rate conversion - multistage automatically optimizes cascade\nM = 16;  % Large decimation factor\n\n% Multistage decimator (default wideband TW)\ndec = designMultistageDecimator(M);\n\n% Multistage interpolator (default wideband TW)\ninterp = designMultistageInterpolator(M);\n\n% View cascade structure and cost\ninfo(dec)\ncost(dec)\n\n% Apply (streaming)\ny_dec = dec(x);\ny_out = interp(y_dec);\n```\n\n**Note**: These functions automatically factor composite M into stages for minimum MPIS. Benefits increase with M. Default TW is wideband; for narrow-transition filtering, use the streaming/offline patterns above instead.\n\n---\n\n## Application Patterns\n\n### Extract Coefficients from digitalFilter Object\n\n```matlab\n% After designing with designfilt()\nd = designfilt(\"lowpassiir\", ...);\n\n% Get CTF form (per-section rows)\nB = d.Numerator;      % Lx3 [b0 b1 b2] for each section\nA = d.Denominator;    % Lx3 [a0 a1 a2] for each section\nL = size(B, 1);       % number of biquad sections\n\n% Convert to SOS matrix (Lx6) if needed\nsos = [B A];          % [b0 b1 b2 a0 a1 a2] per row\n\n% DEPRECATED: Don't use d.Coefficients (removed in recent versions)\n```\n\n### Offline Validation (Zero-Phase)\n\n```matlab\n% Zero-phase reference (doubles effective filter order)\ny0 = filtfilt(d, x);\n\n% Frequency response (Hz-aware)\nfigure;\nfreqz(d, [], Fs);\ngrid on;\ntitle('Magnitude & Phase Response');\n\n% Group delay\nfigure;\ngrpdelay(d, [], Fs);\ngrid on;\ntitle('Group Delay vs Frequency');\n\n% Measure achieved specs\n[h, f] = freqz(d, 2048, Fs);\nmag_dB = 20*log10(abs(h));\n\n% Find -3dB cutoff\nidx_3dB = find(mag_dB < -3, 1);\nfprintf('-3dB Cutoff: %.2f Hz\\n', f(idx_3dB));\n\n% Measure stopband attenuation\nstopband_idx = f > Fstop;\nmin_atten = -max(mag_dB(stopband_idx));\nfprintf('Stopband Attenuation: %.1f dB\\n', min_atten);\n```\n\n### Streaming: CTF Path (R2024b+)\n\n```matlab\n% Extract CTF coefficients\nB = d.Numerator;\nA = d.Denominator;\n\n% ONE-SHOT: Process entire signal (no frame management)\ny_all = ctffilt(B, A, x);\n\n% FRAME-BY-FRAME: Real-time with state carryover\nframeLen = 1024;\nstate_ctf = [];  % initialize empty (zeros internally)\nN = numel(x);\ny_frames = zeros(N, 1);\np = 1;\n\nwhile p <= N\n    q = min(p + frameLen - 1, N);\n    [y_frames(p:q), state_ctf] = ctffilt(B, A, x(p:q), state_ctf);\n    p = q + 1;\nend\n\n% Verify: y_all ≈ y_frames (within numerical precision)\nmax_error = max(abs(y_all - y_frames));\nfprintf('Max streaming error: %.2e\\n', max_error);\n```\n\n### Streaming: SOS System Object (All Versions)\n\n**PREFERRED METHOD**: Use `SystemObject=true` in `designfilt()`:\n\n```matlab\n% Get dsp.SOSFilter directly (no manual coefficient extraction)\nsosFilter = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=Fpass, StopbandFrequency=Fstop, ...\n    PassbandRipple=Rp, StopbandAttenuation=Rs, ...\n    SampleRate=Fs, DesignMethod=\"ellip\", ...\n    SystemObject=true);  % Returns dsp.SOSFilter with ScaleValues\n\n% Access properties if needed\nif sosFilter.HasScaleValues\n    G = sosFilter.ScaleValues;  % Section scale values\nend\n\n% ONE-SHOT\ny_all = sosFilter(x);\n\n% FRAME-BY-FRAME (state preserved automatically)\nreset(sosFilter);  % ensure known start\nframeLen = 1024;\np = 1;\ny_frames = zeros(numel(x), 1);\n\nwhile p <= numel(x)\n    q = min(p + frameLen - 1, numel(x));\n    y_frames(p:q) = sosFilter(x(p:q));  % state handled internally\n    p = q + 1;\nend\n\n% Works for codegen, Simulink, and HDL workflows\n```\n\n**ALTERNATIVE**: Manual creation from existing `digitalFilter`:\n\n```matlab\n% If you already have a digitalFilter object 'd'\nB = d.Numerator;\nA = d.Denominator;\nsosFilt = dsp.SOSFilter('Numerator', B, 'Denominator', A);\ny = sosFilt(x);\n```\n\n### Advanced Filter Analyzer Usage\n\n```matlab\nFs = 44100;\n\n% Design two filters for comparison\nhpIIR = designfilt(\"highpassiir\", ...\n    StopbandFrequency=200, PassbandFrequency=300, ...\n    StopbandAttenuation=60, PassbandRipple=1, ...\n    SampleRate=Fs, DesignMethod=\"ellip\");\n\nhpFIR = designfilt(\"highpassfir\", ...\n    StopbandFrequency=200, PassbandFrequency=300, ...\n    StopbandAttenuation=70, PassbandRipple=0.5, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n\n% Configure frequency-domain display\noptsMag = filterAnalysisOptions(\"magnitude\", \"phase\", ...\n    FrequencyNormalizationMode=\"unnormalized\", ...\n    ReferenceSampleRateMode=\"specify\", ...\n    ReferenceSampleRate=Fs, ...\n    FrequencyRange=\"onesided\", ...\n    FrequencyScale=\"log\", ...\n    NFFT=4096, ...\n    NormalizeMagnitude=true);\n\n% IMPORTANT: FilterNames must be valid MATLAB identifiers\nfilterNames = [\"HP_IIR_ellip\", \"HP_FIR_equiripple\"];\n\n[fa, disp1] = filterAnalyzer(hpIIR, hpFIR, ...\n    FilterNames=filterNames, ...\n    SampleRates=[Fs Fs], ...\n    AnalysisOptions=optsMag);\n\n% Add time-domain displays (impulse + step)\noptsTD = filterAnalysisOptions(\"impulse\", \"step\", ...\n    ResponseLengthMode=\"specify\", ...\n    ResponseLength=512);\ndisp2 = addDisplays(fa, ...\n    AnalysisOptions=optsTD, ...\n    FilterNames=filterNames);\n```\n\n---\n\n## Complete Examples\n\n### Example 1: Minimal Lowpass (Auto Min-Order, Offline Zero-Phase)\n\n**User Request**: \"Design a lowpass filter at 48 kHz, pass 8 kHz, stop 10 kHz, 80 dB attenuation, zero-phase offline\"\n\n```matlab\nFs = 48e3;\n\n% High-level one-liner (auto designs minimum order IIR)\n[y, d] = lowpass(x, 8e3, Fs, ...\n    StopbandAttenuation=80, ...\n    ImpulseResponse=\"iir\", ...\n    Steepness=0.85);\n\n% Zero-phase reference (offline processing)\ny0 = filtfilt(d, x);\n\n% Validate response (Hz-aware)\nfigure; freqz(d, [], Fs); grid on;\ntitle('Lowpass IIR: |H(f)| & Phase');\n\nfigure; grpdelay(d, [], Fs); grid on;\ntitle('Lowpass IIR: Group Delay');\n\n% Report specs\nfprintf('Filter Order: %d\\n', filtord(d));\n[h, f] = freqz(d, 512, Fs);\nfprintf('-3dB Cutoff: %.1f Hz\\n', f(find(abs(h) < 1/sqrt(2), 1)));\n```\n\n### Example 2: Speech Bandpass (IIR with Streaming)\n\n**User Request**: \"Bandpass filter for speech (300-3400 Hz) at 44.1 kHz, 1 dB passband ripple, 60 dB stopband, real-time causal\"\n\n```matlab\nFs = 44100;\n\n% Design IIR bandpass (IMPORTANT: use scalar edge properties with 1/2 suffixes!)\nd = designfilt(\"bandpassiir\", ...\n    StopbandFrequency1=200,  PassbandFrequency1=300, ...\n    PassbandFrequency2=3400, StopbandFrequency2=3900, ...\n    PassbandRipple=1, ...\n    StopbandAttenuation1=60, StopbandAttenuation2=60, ...\n    SampleRate=Fs, DesignMethod=\"ellip\");\n\n% Streaming: dsp.SOSFilter via SystemObject flag (PREFERRED)\nsosFilter = designfilt(\"bandpassiir\", ...\n    StopbandFrequency1=200,  PassbandFrequency1=300, ...\n    PassbandFrequency2=3400, StopbandFrequency2=3900, ...\n    PassbandRipple=1, ...\n    StopbandAttenuation1=60, StopbandAttenuation2=60, ...\n    SampleRate=Fs, DesignMethod=\"ellip\", ...\n    SystemObject=true);  % Returns dsp.SOSFilter directly\n\ny_sos = sosFilter(x);  % Use directly\n\n% Offline zero-phase validation\ny0 = filtfilt(d, x);\nfigure; freqz(d, [], Fs); grid on;\n\nfprintf('Filter Order: %d sections\\n', size(d.Numerator, 1));\n```\n\n### Example 3: Linear-Phase FIR with Filter Analyzer Overlay\n\n**User Request**: \"Linear-phase FIR lowpass at 10 kHz, pass 1 kHz, stop 1.2 kHz, 70 dB attenuation. Compare with IIR.\"\n\n```matlab\nFs = 1e4;\n\n% FIR design (linear phase, equiripple)\nd_fir = designfilt(\"lowpassfir\", ...\n    PassbandFrequency=1e3, StopbandFrequency=1.2e3, ...\n    PassbandRipple=0.2, StopbandAttenuation=70, ...\n    SampleRate=Fs, DesignMethod=\"equiripple\");\n\n% IIR comparator (elliptic, minimum order)\nd_iir = designfilt(\"lowpassiir\", ...\n    PassbandFrequency=1e3, StopbandFrequency=1.2e3, ...\n    PassbandRipple=0.2, StopbandAttenuation=70, ...\n    SampleRate=Fs, DesignMethod=\"ellip\");\n\n% Apply FIR with zero-phase\ny0 = filtfilt(d_fir, x);\n\n% Overlay comparison in Filter Analyzer\n% IMPORTANT: FilterNames must be valid MATLAB identifiers!\nfa = filterAnalyzer(d_fir, d_iir, ...\n    FilterNames=[\"FIR_equiripple\", \"IIR_ellip\"], ...\n    Analysis=\"magnitude\", ...\n    OverlayAnalysis=\"phase\", ...\n    SampleRates=[Fs Fs]);\n\n% Report\nfprintf('FIR Length: %d taps\\n', length(d_fir.Numerator));\nfprintf('IIR Order: %d sections\\n', size(d_iir.Numerator, 1));\nfprintf('FIR Group Delay: %.2f samples\\n', mean(grpdelay(d_fir, 1)));\n```\n\n**Trade-offs**:\n- FIR: Linear phase, ~120 taps\n- IIR: Minimum order (4-6 sections), non-linear phase\n- FIR suitable for offline; IIR better for real-time\n\n---\n\n## Quick Lookup\n\n| Pattern | Section | Use Case |\n|---------|---------|----------|\n| High-level one-liners | Quick Design | Rapid prototyping |\n| FIR designfilt | Quick Design | Linear phase filters |\n| IIR designfilt | Quick Design | Sharp cutoff, minimum order |\n| Minimum-phase FIR | Quick Design | Reduced latency |\n| Streaming multirate | Multirate | Real-time polyphase |\n| Offline multirate | Multirate | Zero-phase with `resample()` |\n| Coefficient extraction | Application | Manual coefficient access |\n| CTF streaming | Application | R2024b+ real-time |\n| SOS streaming | Application | All versions real-time |\n| Filter Analyzer | Application | Visual comparison |\n\n",
        "skills/matlab-live-script/SKILL.md": "---\nname: matlab-live-script\ndescription: Create MATLAB plain text Live Scripts (.m files) following specific formatting rules. Use when generating MATLAB scripts, educational MATLAB content, Live Scripts, or when the user requests .m files with rich text formatting.\nlicense: MathWorks BSD-3-Clause (see LICENSE)\n---\n\n# MATLAB Plain Text Live Script Generator\n\nThis skill provides comprehensive guidelines for creating properly formatted MATLAB plain text Live Scripts. These scripts combine executable MATLAB code with rich text documentation in a single .m file.\n\n## When to Use This Skill\n\n- Creating new MATLAB Live Scripts in plain text format\n- Generating educational MATLAB content with explanations\n- When the user requests .m files with documentation\n- Converting code examples into Live Script format\n- Creating tutorial or example scripts\n\n## Critical Rules\n\n### File Format\n- **ALWAYS** use the .m suffix for plain text Live Scripts\n- **NEVER** create .mlx scripts (binary format)\n- **MUST** close every script with the required appendix\n\n### Required Appendix\nEvery Live Script must end with this exact formatting:\n\n```matlab\n%[appendix]{\"version\":\"1.0\"}\n%---\n%[metadata:view]\n%   data: {\"layout\":\"inline\"}\n%---\n```\n\n### Reading Live Scripts (Token Optimization)\nWhen reading a Live Script file to pass back to the language model, you can save significant token count by ignoring everything below the appendix marker (which begins with `%[appendix]`). This optimization avoids passing large embedded images that are stored in the appendix section. All working code and text content appears before the appendix, so no functional information is lost.\n\n## Formatting Rules\n\n### Section Headers\n**CORRECT format:**\n```matlab\n%%\n%[text] ## Section Title\n```\n\n**INCORRECT format (DO NOT USE):**\n```matlab\n%% Section Title\n```\n\n### Rich Text\n- Normal text uses `%[text]` prefix\n- Text intended for a single paragraph should appear on a single line\n- Use Markdown formatting after `%[text]`\n- **DO NOT** leave blank lines in the file\n\n### Bulleted Lists\nBulleted lists must have a backslash on the last item:\n\n```matlab\n%[text] - bullet 1\n%[text] - bullet 2\n%[text] - bullet 3 \\\n```\n\n\n### Tables\n\n```matlab\n%[text:table]\n%[text] | Column A | Column B |\n%[text] | --- | --- |\n%[text] | Value 1 | Value 2 |\n%[text] | Value 3 | Value 4 |\n%[text:table]\n```\n\n\n### LaTeX Equations\nFormat equations with double backslashes:\n\n```matlab\n%[text] $ e = \\\\sum_{\\\\alpha=0}^\\\\infty \\\\alpha^n/n! $\n```\n\nNote: All backslashes in LaTeX must be doubled.\n\n### Comments for Readers\n**DO NOT** use fprintf for reader comments:\n```matlab\nfprintf('This is a comment')  % WRONG\n```\n\n**Instead use rich text:**\n```matlab\n%[text] This is a comment  % CORRECT\n```\n\n## Code Guidelines\n\n### Figures and Plots\n- Use **implicit figure creation** (just call plot, histogram, etc.)\n- **DO NOT** use the `figure` command to create new figures\n- Put no more than one plot per section (unless using tiled layouts)\n- Only use tiled plots when especially important to the illustration\n\n### Script Initialization\n- **DO NOT** start scripts with `close all` or `clear` commands\n- Let MATLAB handle workspace management\n\n## Complete Example\n\n```matlab\n%[text] # Sinusoidal Signals\n%[text] Examples of sinusoidal signal in MATLAB.\n%[text] - sine waves\n%[text] - cosine waves \\\nx = linspace(0,8*pi);\n%%\n%[text] ## Sine Wave\nplot(x,sin(x))\ntitle('Sine Wave')\nxlabel('x (radians)')\nylabel('sin(x)')\ngrid on\n%%\n%[text] ## Cosine Wave\nplot(x,cos(x))\ntitle('Cosine Wave')\nxlabel('x (radians)')\nylabel('cos(x)')\ngrid on\n%[text]\n\n%[appendix]{\"version\":\"1.0\"}\n%---\n%[metadata:view]\n%   data: {\"layout\":\"inline\"}\n%---\n```\n\n## Structure Pattern\n\nA typical Live Script follows this pattern:\n\n1. **Title and Introduction**\n   ```matlab\n   %[text] # Main Title\n   %[text] Brief description of what this script does.\n   ```\n\n2. **Setup Code** (if needed)\n   ```matlab\n   variable = value;\n   data = load('file.mat');\n   ```\n\n3. **Sections with Explanations**\n   ```matlab\n   %%\n   %[text] ## Section Name\n   %[text] Explanation of what this section does.\n   code_goes_here();\n   plot(results)\n   ```\n\n4. **Required Appendix**\n   ```matlab\n   %[appendix]{\"version\":\"1.0\"}\n   %---\n   %[metadata:view]\n   %   data: {\"layout\":\"inline\"}\n   %---\n   ```\n\n## Common Patterns\n\n### Mathematical Explanations with Equations\n```matlab\n%[text] ## Theory\n%[text] The discrete Fourier transform is defined as:\n%[text] $ X(k) = \\\\sum_{n=0}^{N-1} x(n)e^{-j2\\\\pi kn/N} $\n```\n\n### Code with Inline Comments\n```matlab\n%%\n%[text] ## Data Processing\n%[text] First, we load and filter the data.\ndata = load('measurements.mat');\nfiltered = lowpass(data, 0.5);  % Apply lowpass filter\n%[text] Then we visualize the results.\nplot(filtered)\ntitle('Filtered Data')\n```\n\n### Multiple Related Plots (Tiled Layout)\nOnly when necessary for comparison:\n```matlab\n%%\n%[text] ## Comparison of Methods\ntiledlayout(1,2)\nnexttile\nplot(method1)\ntitle('Method 1')\nnexttile\nplot(method2)\ntitle('Method 2')\n```\n\n## Checklist\n\nBefore finishing a Live Script, verify:\n- [ ] File has .m extension\n- [ ] Sections use `%%` followed by `%[text] ##`\n- [ ] No blank lines in the file\n- [ ] Bulleted lists end with backslash\n- [ ] LaTeX uses double backslashes\n- [ ] No `figure` commands\n- [ ] No `close all` or `clear` at start\n- [ ] Appendix is present and correctly formatted\n- [ ] No `fprintf` for comments (use `%[text]` instead)\n\n## Troubleshooting\n\n**Issue**: Script doesn't display rich text properly\n- **Solution**: Ensure `%[text]` is at the start of each text line\n\n**Issue**: Equations not rendering\n- **Solution**: Check that all backslashes are doubled in LaTeX\n\n**Issue**: Sections not appearing correctly\n- **Solution**: Use `%%` on its own line, then `%[text] ##` on the next line\n\n**Issue**: Script won't save with outputs\n- **Solution**: Verify appendix is exactly as specified, with proper indentation\n",
        "skills/matlab-performance-optimizer/SKILL.md": "---\nname: matlab-performance-optimizer\ndescription: Optimize MATLAB code for better performance through vectorization, memory management, and profiling. Use when user requests optimization, mentions slow code, performance issues, speed improvements, or asks to make code faster or more efficient.\nlicense: MathWorks BSD-3-Clause (see LICENSE)\n---\n\n# MATLAB Performance Optimizer\n\nThis skill provides comprehensive guidelines for optimizing MATLAB code performance. Apply vectorization techniques, memory optimization strategies, and profiling tools to make code faster and more efficient.\n\n## When to Use This Skill\n\n- Optimizing slow or inefficient MATLAB code\n- Converting loops to vectorized operations\n- Reducing memory usage\n- Improving algorithm performance\n- When user mentions: slow, performance, optimize, speed up, efficient, memory\n- Profiling code to find bottlenecks\n- Parallelizing computations\n\n## Core Optimization Principles\n\n### 1. Vectorization (Most Important)\n\n**Replace loops with vectorized operations whenever possible.**\n\n**SLOW - Using loops:**\n```matlab\n% Slow approach\nn = 1000000;\nresult = zeros(n, 1);\nfor i = 1:n\n    result(i) = sin(i) * cos(i);\nend\n```\n\n**FAST - Vectorized:**\n```matlab\n% Fast approach\nn = 1000000;\ni = 1:n;\nresult = sin(i) .* cos(i);\n```\n\n### 2. Preallocate Arrays\n\n**Always preallocate arrays before loops.**\n\n**SLOW - Growing arrays:**\n```matlab\n% Very slow - array grows each iteration\nresult = [];\nfor i = 1:10000\n    result(end+1) = i^2;\nend\n```\n\n**FAST - Preallocated:**\n```matlab\n% Fast - preallocated array\nn = 10000;\nresult = zeros(n, 1);\nfor i = 1:n\n    result(i) = i^2;\nend\n```\n\n### 3. Use Built-in Functions\n\n**MATLAB built-in functions are highly optimized.**\n\n**SLOW - Manual implementation:**\n```matlab\n% Slow\nsum_val = 0;\nfor i = 1:length(x)\n    sum_val = sum_val + x(i);\nend\n```\n\n**FAST - Built-in function:**\n```matlab\n% Fast\nsum_val = sum(x);\n```\n\n## Vectorization Techniques\n\n### Element-wise Operations\n\nUse `.*`, `./`, `.^` for element-wise operations:\n\n```matlab\n% Instead of this:\nfor i = 1:length(x)\n    y(i) = x(i)^2 + 2*x(i) + 1;\nend\n\n% Do this:\ny = x.^2 + 2*x + 1;\n```\n\n### Logical Indexing\n\nReplace conditional loops with logical indexing:\n\n```matlab\n% Instead of this:\ncount = 0;\nfor i = 1:length(data)\n    if data(i) > threshold\n        count = count + 1;\n        filtered(count) = data(i);\n    end\nend\nfiltered = filtered(1:count);\n\n% Do this:\nfiltered = data(data > threshold);\n```\n\n### Matrix Operations\n\nUse matrix multiplication instead of nested loops:\n\n```matlab\n% Instead of this:\nC = zeros(size(A, 1), size(B, 2));\nfor i = 1:size(A, 1)\n    for j = 1:size(B, 2)\n        for k = 1:size(A, 2)\n            C(i,j) = C(i,j) + A(i,k) * B(k,j);\n        end\n    end\nend\n\n% Do this:\nC = A * B;\n```\n\n### Cumulative Operations\n\nUse `cumsum`, `cumprod`, `cummax`, `cummin`:\n\n```matlab\n% Instead of this:\nrunning_sum = zeros(size(data));\nrunning_sum(1) = data(1);\nfor i = 2:length(data)\n    running_sum(i) = running_sum(i-1) + data(i);\nend\n\n% Do this:\nrunning_sum = cumsum(data);\n```\n\n## Memory Optimization\n\n### Use Appropriate Data Types\n\n```matlab\n% Instead of default double (8 bytes)\ndata = rand(1000, 1000);  % 8 MB\n\n% Use single precision when appropriate (4 bytes)\ndata = single(rand(1000, 1000));  % 4 MB\n\n% Use integers when applicable\nindices = uint32(1:1000000);  % 4 MB instead of 8 MB\n```\n\n### Sparse Matrices\n\nFor matrices with mostly zeros:\n\n```matlab\n% Dense matrix (wastes memory)\nA = zeros(10000, 10000);\nA(1:100, 1:100) = rand(100);  % 800 MB\n\n% Sparse matrix (efficient)\nA = sparse(10000, 10000);\nA(1:100, 1:100) = rand(100);  % Only stores non-zeros\n```\n\n### Clear Unused Variables\n\n```matlab\n% Process large data\nlargeData = loadData();\nprocessedData = processData(largeData);\n\n% Clear when no longer needed\nclear largeData;\n\n% Continue with processed data\nresults = analyze(processedData);\n```\n\n### In-Place Operations\n\n```matlab\n% Instead of creating copies\nA = A + 5;  % In-place when possible\n\n% Avoid unnecessary copies\nB = A;      % Creates copy if A is modified later\nB = A + 0;  % Forces copy\n```\n\n## Profiling and Benchmarking\n\n### Using the Profiler\n\n```matlab\n% Profile code execution\nprofile on\nmyFunction(inputs);\nprofile viewer\nprofile off\n```\n\nThe profiler shows:\n- Time spent in each function\n- Number of calls to each function\n- Lines that take the most time\n\n### Timing Comparisons\n\n```matlab\n% Time single execution\ntic;\nresult = myFunction(data);\nelapsedTime = toc;\n\n% Benchmark with timeit (more accurate)\ntimeit(@() myFunction(data))\n\n% Compare multiple approaches\ntime1 = timeit(@() approach1(data));\ntime2 = timeit(@() approach2(data));\nfprintf('Approach 1: %.6f s\\nApproach 2: %.6f s\\n', time1, time2);\n```\n\n## Common Optimization Patterns\n\n### Pattern 1: Replace find with Logical Indexing\n\n```matlab\n% SLOW\nindices = find(x > 5);\ny = x(indices);\n\n% FAST\ny = x(x > 5);\n```\n\n### Pattern 2: Use bsxfun for Broadcasting\n\n```matlab\n% Instead of repmat\nA = rand(1000, 5);\nB = rand(1, 5);\nC = A - repmat(B, size(A, 1), 1);\n\n% Use implicit expansion (R2016b+) or bsxfun\nC = A - B;  % Implicit expansion\nC = bsxfun(@minus, A, B);  % Older MATLAB\n```\n\n### Pattern 3: Avoid Repeated Calculations\n\n```matlab\n% SLOW - recalculates each iteration\nfor i = 1:n\n    result(i) = data(i) / sqrt(sum(data.^2));\nend\n\n% FAST - calculate once\nnorm_factor = sqrt(sum(data.^2));\nfor i = 1:n\n    result(i) = data(i) / norm_factor;\nend\n\n% EVEN FASTER - vectorize\nresult = data / sqrt(sum(data.^2));\n```\n\n### Pattern 4: Efficient String Operations\n\n```matlab\n% SLOW - concatenating in loop\nstr = '';\nfor i = 1:1000\n    str = [str, sprintf('Line %d\\n', i)];\nend\n\n% FAST - cell array + join\nlines = cell(1000, 1);\nfor i = 1:1000\n    lines{i} = sprintf('Line %d', i);\nend\nstr = strjoin(lines, '\\n');\n\n% FASTEST - vectorized sprintf\nstr = sprintf('Line %d\\n', 1:1000);\n```\n\n### Pattern 5: Use Table for Mixed Data Types\n\n```matlab\n% Instead of separate arrays\nnames = cell(1000, 1);\nages = zeros(1000, 1);\nscores = zeros(1000, 1);\n\n% Use table\ndata = table(names, ages, scores);\n% Faster access and better organization\n```\n\n## Algorithm-Specific Optimizations\n\n### Convolution and Filtering\n\n```matlab\n% Use built-in functions\nfiltered = conv(signal, kernel, 'same');\nfiltered = filter(b, a, signal);\n\n% For 2D\nfiltered = conv2(image, kernel, 'same');\nfiltered = imfilter(image, kernel);\n\n% FFT-based for large kernels\nfiltered = ifft(fft(signal) .* fft(kernel, length(signal)));\n```\n\n### Distance Calculations\n\n```matlab\n% Instead of nested loops for pairwise distances\n% SLOW\nn = size(points, 1);\ndistances = zeros(n, n);\nfor i = 1:n\n    for j = 1:n\n        distances(i,j) = norm(points(i,:) - points(j,:));\n    end\nend\n\n% FAST - vectorized\ndistances = pdist2(points, points);\n\n% Or using bsxfun\ndiff = bsxfun(@minus, permute(points, [1 3 2]), permute(points, [3 1 2]));\ndistances = sqrt(sum(diff.^2, 3));\n```\n\n### Sorting and Searching\n\n```matlab\n% Presort for multiple searches\nsortedData = sort(data);\n\n% Binary search on sorted data\nidx = find(sortedData >= value, 1, 'first');\n\n% Use ismember for set operations\n[isPresent, locations] = ismember(searchValues, data);\n\n% Use unique for removing duplicates\nuniqueData = unique(data);\n```\n\n## Parallel Computing\n\n### Simple Parallel Loops (parfor)\n\n```matlab\n% Convert for to parfor for independent iterations\nparfor i = 1:n\n    results(i) = expensiveFunction(data(i));\nend\n```\n\n**Requirements for parfor:**\n- Iterations must be independent\n- Loop variable must be consecutive integers\n- Variables must be classified as loop, sliced, broadcast, or reduction\n\n### Parallel Array Operations\n\n```matlab\n% Create parallel pool\nparpool('local', 4);  % 4 workers\n\n% Use parallel array functions\nresult = arrayfun(@expensiveFunction, data, 'UniformOutput', false);\n\n% GPU arrays for massive parallelization\ngpuData = gpuArray(data);\nresult = arrayfun(@myFunction, gpuData);\nresult = gather(result);  % Bring back to CPU\n```\n\n## Advanced Optimizations\n\n### MEX Functions for Critical Sections\n\nConvert performance-critical code to C/C++:\n\n```matlab\n% Create MEX file for bottleneck function\n% Write myFunction.c, then compile:\n% mex myFunction.c\n\n% Call like regular MATLAB function\nresult = myFunction(inputs);\n```\n\n### Persistent Variables for Cached Results\n\n```matlab\nfunction result = expensiveComputation(input)\n    persistent cachedData cachedInput\n\n    if isequal(input, cachedInput)\n        % Return cached result\n        result = cachedData;\n        return;\n    end\n\n    % Compute and cache\n    result = computeExpensiveOperation(input);\n    cachedData = result;\n    cachedInput = input;\nend\n```\n\n### JIT Acceleration Best Practices\n\nMATLAB's JIT (Just-In-Time) compiler optimizes:\n- Simple for-loops with scalar operations\n- Functions without dynamic features\n\n**JIT-friendly code:**\n```matlab\nfunction result = jitFriendly(n)\n    result = 0;\n    for i = 1:n\n        result = result + i;\n    end\nend\n```\n\n**JIT-unfriendly code (avoid):**\n```matlab\nfunction result = jitUnfriendly(n)\n    result = 0;\n    for i = 1:n\n        eval(['x' num2str(i) ' = i;']);  % Dynamic code\n    end\nend\n```\n\n## Performance Checklist\n\nBefore finalizing optimized code, verify:\n- [ ] Loops are vectorized where possible\n- [ ] Arrays are preallocated before loops\n- [ ] Built-in functions used instead of manual implementations\n- [ ] Logical indexing used instead of find + indexing\n- [ ] Appropriate data types used (single vs double, integers)\n- [ ] Sparse matrices used for sparse data\n- [ ] Repeated calculations moved outside loops\n- [ ] String concatenation uses efficient methods\n- [ ] Code profiled to identify actual bottlenecks\n- [ ] Matrix operations used instead of element-wise loops\n- [ ] Parallel computing considered for independent operations\n- [ ] Memory-intensive operations optimized\n- [ ] Caching implemented for repeated expensive calls\n\n## Profiling Workflow\n\n1. **Measure First**: Profile before optimizing\n   ```matlab\n   profile on\n   myScript;\n   profile viewer\n   ```\n\n2. **Identify Bottlenecks**: Focus on functions taking most time\n\n3. **Optimize**: Apply appropriate techniques\n\n4. **Measure Again**: Verify improvement\n   ```matlab\n   % Before\n   time_before = timeit(@() myFunction(data));\n\n   % After optimization\n   time_after = timeit(@() myFunctionOptimized(data));\n\n   fprintf('Speedup: %.2fx\\n', time_before/time_after);\n   ```\n\n5. **Iterate**: Repeat for remaining bottlenecks\n\n## Common Performance Pitfalls\n\n### Pitfall 1: Premature Optimization\n- Profile first, optimize second\n- Focus on actual bottlenecks, not assumptions\n\n### Pitfall 2: Over-vectorization\n- Sometimes loops are clearer and fast enough\n- Balance readability with performance\n\n### Pitfall 3: Ignoring Memory Access Patterns\n```matlab\n% SLOW - column-wise access (MATLAB is column-major)\nfor j = 1:cols\n    for i = 1:rows\n        A(i,j) = process(i, j);\n    end\nend\n\n% FAST - row-wise iteration, column-wise access\nfor i = 1:rows\n    for j = 1:cols\n        A(i,j) = process(i, j);\n    end\nend\n\n% FASTEST - vectorized\n[I, J] = ndgrid(1:rows, 1:cols);\nA = process(I, J);\n```\n\n### Pitfall 4: Unnecessary Data Type Conversions\n```matlab\n% SLOW - repeated conversions\nfor i = 1:n\n    x = double(data(i));\n    result(i) = sin(x);\nend\n\n% FAST - convert once\nx = double(data);\nresult = sin(x);\n```\n\n## Optimization Examples\n\n### Example 1: Image Processing\n\n```matlab\n% SLOW\n[rows, cols] = size(image);\noutput = zeros(rows, cols);\nfor i = 2:rows-1\n    for j = 2:cols-1\n        output(i,j) = mean(image(i-1:i+1, j-1:j+1), 'all');\n    end\nend\n\n% FAST\nkernel = ones(3,3) / 9;\noutput = conv2(image, kernel, 'same');\n```\n\n### Example 2: Statistical Analysis\n\n```matlab\n% SLOW\nn = size(data, 1);\nmeans = zeros(n, 1);\nfor i = 1:n\n    means(i) = mean(data(i, :));\nend\n\n% FAST\nmeans = mean(data, 2);\n```\n\n### Example 3: Time Series Processing\n\n```matlab\n% SLOW\nn = length(signal);\nmovingAvg = zeros(size(signal));\nwindow = 10;\nfor i = window:n\n    movingAvg(i) = mean(signal(i-window+1:i));\nend\n\n% FAST\nmovingAvg = movmean(signal, window);\n```\n\n## Troubleshooting Performance\n\n**Issue**: Code still slow after vectorization\n- **Solution**: Profile to find new bottlenecks; consider algorithm complexity\n\n**Issue**: Out of memory errors\n- **Solution**: Use smaller data types, process in chunks, use sparse matrices\n\n**Issue**: parfor slower than for loop\n- **Solution**: Check if overhead outweighs benefits; ensure iterations are expensive enough\n\n**Issue**: GPU computation slower than CPU\n- **Solution**: Data transfer overhead may exceed computation time; use for large arrays\n\n## Additional Resources\n\n- Use `profile viewer` to analyze performance\n- Use `memory` to check memory usage\n- Use `doc` with: `timeit`, `tic/toc`, `parfor`, `gpuArray`, `sparse`\n- Check MATLAB Performance and Memory documentation\n",
        "skills/matlab-test-generator/SKILL.md": "---\nname: matlab-test-generator\ndescription: Create comprehensive MATLAB unit tests using the MATLAB Testing Framework. Use when generating test files, test cases, unit tests, test suites, or when the user requests testing for MATLAB code, functions, or classes.\nlicense: MathWorks BSD-3-Clause (see LICENSE)\n---\n\n# MATLAB Test Generator\n\nThis skill provides comprehensive guidelines for creating robust unit tests using the MATLAB Testing Framework. Generate test classes, test methods, and test suites following MATLAB best practices.\n\n## When to Use This Skill\n\n- Creating unit tests for MATLAB functions or classes\n- Generating test suites for existing code\n- Writing test cases with assertions and fixtures\n- Creating parameterized tests\n- Setting up test environments with setup/teardown methods\n- When user requests testing, test coverage, or mentions unit tests\n\n## MATLAB Testing Framework Overview\n\nMATLAB supports multiple testing approaches:\n\n1. **Script-Based Tests** - Simple test scripts with assertions\n2. **Function-Based Tests** - Test functions with local functions for each test\n3. **Class-Based Tests** - Full-featured test classes (recommended for complex testing)\n\n## Test Class Structure\n\n### Basic Test Class Template\n\n```matlab\nclassdef MyFunctionTest < matlab.unittest.TestCase\n    % Tests for myFunction\n\n    properties (TestParameter)\n        % Define parameters for parameterized tests\n    end\n\n    properties\n        % Test fixtures and shared data\n    end\n\n    methods (TestClassSetup)\n        % Runs once before all tests\n    end\n\n    methods (TestClassTeardown)\n        % Runs once after all tests\n    end\n\n    methods (TestMethodSetup)\n        % Runs before each test method\n    end\n\n    methods (TestMethodTeardown)\n        % Runs after each test method\n    end\n\n    methods (Test)\n        % Individual test methods\n    end\nend\n```\n\n## Critical Rules\n\n### File Naming\n- **Test files MUST end with `Test.m`** (e.g., `myFunctionTest.m`)\n- Class name must match filename\n- Follow PascalCase naming convention\n- Place in `tests/` directory or alongside source with `Test` suffix\n\n### Test Method Naming\n- Use descriptive, readable names\n- Start with lowercase letter\n- Use camelCase\n- Describe what is being tested\n- Example: `testAdditionWithPositiveNumbers`\n\n### Assertions\nAlways use the appropriate assertion method:\n- `verifyEqual(actual, expected)` - Continues testing on failure\n- `assertEqual(actual, expected)` - Stops testing on failure (legacy)\n- `verifyTrue(condition)` - Verify boolean condition\n- `verifyError(f, errorID)` - Verify function throws error\n- `verifyWarning(f, warningID)` - Verify function issues warning\n- `verifyInstanceOf(actual, expectedClass)` - Verify object type\n- `verifySize(actual, expectedSize)` - Verify array size\n- `verifyEmpty(actual)` - Verify empty array\n\n## Complete Test Examples\n\n### Example 1: Testing a Simple Function\n\nFunction to test (`add.m`):\n```matlab\nfunction result = add(a, b)\n    % ADD Add two numbers\n    result = a + b;\nend\n```\n\nTest class (`addTest.m`):\n```matlab\nclassdef addTest < matlab.unittest.TestCase\n    % Tests for add function\n\n    methods (Test)\n        function testAddPositiveNumbers(testCase)\n            % Test addition of positive numbers\n            result = add(2, 3);\n            testCase.verifyEqual(result, 5);\n        end\n\n        function testAddNegativeNumbers(testCase)\n            % Test addition of negative numbers\n            result = add(-2, -3);\n            testCase.verifyEqual(result, -5);\n        end\n\n        function testAddMixedNumbers(testCase)\n            % Test addition of positive and negative\n            result = add(5, -3);\n            testCase.verifyEqual(result, 2);\n        end\n\n        function testAddZero(testCase)\n            % Test addition with zero\n            result = add(5, 0);\n            testCase.verifyEqual(result, 5);\n        end\n\n        function testAddArrays(testCase)\n            % Test element-wise addition of arrays\n            result = add([1 2 3], [4 5 6]);\n            testCase.verifyEqual(result, [5 7 9]);\n        end\n    end\nend\n```\n\n### Example 2: Parameterized Tests\n\n```matlab\nclassdef calculateAreaTest < matlab.unittest.TestCase\n    % Tests for calculateArea function with parameters\n\n    properties (TestParameter)\n        rectangleDims = struct(...\n            'small', struct('width', 2, 'height', 3, 'expected', 6), ...\n            'large', struct('width', 10, 'height', 20, 'expected', 200), ...\n            'unit', struct('width', 1, 'height', 1, 'expected', 1));\n    end\n\n    methods (Test)\n        function testRectangleArea(testCase, rectangleDims)\n            % Test rectangle area calculation\n            area = calculateArea(rectangleDims.width, rectangleDims.height);\n            testCase.verifyEqual(area, rectangleDims.expected);\n        end\n    end\nend\n```\n\n### Example 3: Tests with Fixtures\n\n```matlab\nclassdef DataProcessorTest < matlab.unittest.TestCase\n    % Tests for DataProcessor class with setup/teardown\n\n    properties\n        TestData\n        TempFile\n    end\n\n    methods (TestMethodSetup)\n        function createTestData(testCase)\n            % Create test data before each test\n            testCase.TestData = rand(100, 5);\n            testCase.TempFile = tempname;\n        end\n    end\n\n    methods (TestMethodTeardown)\n        function deleteTestData(testCase)\n            % Clean up after each test\n            if isfile(testCase.TempFile)\n                delete(testCase.TempFile);\n            end\n        end\n    end\n\n    methods (Test)\n        function testDataLoading(testCase)\n            % Test data loading functionality\n            save(testCase.TempFile, 'data', testCase.TestData);\n            processor = DataProcessor(testCase.TempFile);\n            testCase.verifyEqual(processor.data, testCase.TestData);\n        end\n\n        function testDataNormalization(testCase)\n            % Test data normalization\n            processor = DataProcessor();\n            processor.data = testCase.TestData;\n            normalized = processor.normalize();\n            testCase.verifyLessThanOrEqual(max(normalized(:)), 1);\n            testCase.verifyGreaterThanOrEqual(min(normalized(:)), 0);\n        end\n    end\nend\n```\n\n### Example 4: Error Testing\n\n```matlab\nclassdef validateInputTest < matlab.unittest.TestCase\n    % Tests for validateInput function\n\n    methods (Test)\n        function testValidInput(testCase)\n            % Test valid input passes\n            testCase.verifyWarningFree(@() validateInput(5));\n        end\n\n        function testNegativeInputError(testCase)\n            % Test negative input throws error\n            testCase.verifyError(@() validateInput(-5), 'MATLAB:validators:mustBePositive');\n        end\n\n        function testNonNumericInputError(testCase)\n            % Test non-numeric input throws error\n            testCase.verifyError(@() validateInput('text'), 'MATLAB:validators:mustBeNumeric');\n        end\n\n        function testEmptyInputError(testCase)\n            % Test empty input throws error\n            testCase.verifyError(@() validateInput([]), 'MATLAB:validators:mustBeNonempty');\n        end\n    end\nend\n```\n\n## Test Organization Best Practices\n\n### Directory Structure\n```\nproject/\n├── src/\n│   ├── myFunction.m\n│   └── MyClass.m\n└── tests/\n    ├── myFunctionTest.m\n    └── MyClassTest.m\n```\n\n### Running Tests\n\n**Run all tests in directory:**\n```matlab\nresults = runtests('tests')\n```\n\n**Run specific test class:**\n```matlab\nresults = runtests('myFunctionTest')\n```\n\n**Run specific test method:**\n```matlab\nresults = runtests('myFunctionTest/testAddPositiveNumbers')\n```\n\n**Generate test suite:**\n```matlab\nsuite = testsuite('tests');\nresults = run(suite);\n```\n\n**With coverage report:**\n```matlab\nimport matlab.unittest.TestRunner\nimport matlab.unittest.plugins.CodeCoveragePlugin\n\nrunner = TestRunner.withTextOutput;\nrunner.addPlugin(CodeCoveragePlugin.forFolder('src'));\nresults = runner.run(testsuite('tests'));\n```\n\n## Assertion Tolerance\n\nFor floating-point comparisons, use tolerance:\n\n```matlab\n% Absolute tolerance\ntestCase.verifyEqual(actual, expected, 'AbsTol', 1e-10);\n\n% Relative tolerance\ntestCase.verifyEqual(actual, expected, 'RelTol', 1e-6);\n\n% Both\ntestCase.verifyEqual(actual, expected, 'AbsTol', 1e-10, 'RelTol', 1e-6);\n```\n\n## Test Assumptions\n\nUse assumptions to skip tests when prerequisites aren't met:\n\n```matlab\nfunction testPlotting(testCase)\n    % Skip test if not running in graphical environment\n    testCase.assumeTrue(usejava('desktop'), 'Requires desktop environment');\n\n    % Test code here\n    fig = figure;\n    plot(1:10);\n    testCase.verifyInstanceOf(fig, 'matlab.ui.Figure');\n    close(fig);\nend\n```\n\n## Test Tagging\n\nTag tests for selective execution:\n\n```matlab\nmethods (Test, TestTags = {'Unit'})\n    function testBasicOperation(testCase)\n        % Fast unit test\n    end\nend\n\nmethods (Test, TestTags = {'Integration', 'Slow'})\n    function testDatabaseConnection(testCase)\n        % Slower integration test\n    end\nend\n```\n\nRun tagged tests:\n```matlab\n% Run only Unit tests\nsuite = testsuite('tests', 'Tag', 'Unit');\nresults = run(suite);\n```\n\n## Mock Objects and Stubs\n\nFor testing code with dependencies:\n\n```matlab\nfunction testWithMock(testCase)\n    % Create mock object\n    import matlab.mock.TestCase\n    [mock, behavior] = testCase.createMock(?MyInterface);\n\n    % Define behavior\n    testCase.assignOutputsWhen(withAnyInputs(behavior.methodName), expectedOutput);\n\n    % Use mock in test\n    result = functionUnderTest(mock);\n    testCase.verifyEqual(result, expectedValue);\nend\n```\n\n## Performance Testing\n\nTest execution time:\n\n```matlab\nfunction testPerformance(testCase)\n    % Test function executes within time limit\n    tic;\n    result = expensiveFunction(largeData);\n    elapsedTime = toc;\n\n    testCase.verifyLessThan(elapsedTime, 1.0, ...\n        'Function should complete within 1 second');\nend\n```\n\n## Checklist for Test Creation\n\nBefore finalizing tests, verify:\n- [ ] Test file ends with `Test.m`\n- [ ] Class inherits from `matlab.unittest.TestCase`\n- [ ] Test methods use descriptive names\n- [ ] Appropriate assertions used (verify vs assert)\n- [ ] Edge cases covered (empty, zero, negative, large values)\n- [ ] Error cases tested with `verifyError`\n- [ ] Floating-point comparisons use tolerance\n- [ ] Setup/teardown methods clean up resources\n- [ ] Tests are independent (can run in any order)\n- [ ] Tests follow Arrange-Act-Assert pattern\n- [ ] Parameterized tests used for similar test cases\n- [ ] Comments explain what is being tested\n\n## Common Patterns\n\n### Arrange-Act-Assert Pattern\n\n```matlab\nfunction testCalculation(testCase)\n    % Arrange - Set up test data\n    input1 = 5;\n    input2 = 3;\n    expected = 8;\n\n    % Act - Execute the code under test\n    actual = myFunction(input1, input2);\n\n    % Assert - Verify the result\n    testCase.verifyEqual(actual, expected);\nend\n```\n\n### Testing Private Methods\n\n```matlab\n% Use access to test private methods\nclassdef MyClassTest < matlab.unittest.TestCase\n    methods (Test)\n        function testPrivateMethod(testCase)\n            obj = MyClass();\n            % Access private method\n            result = obj.privateMethod(testCase);\n            testCase.verifyEqual(result, expectedValue);\n        end\n    end\nend\n```\n\n### Testing Static Methods\n\n```matlab\nfunction testStaticMethod(testCase)\n    % Test static method without instantiation\n    result = MyClass.staticMethod(input);\n    testCase.verifyEqual(result, expected);\nend\n```\n\n## Troubleshooting\n\n**Issue**: Tests not discovered\n- **Solution**: Ensure filename ends with `Test.m` and class inherits from `matlab.unittest.TestCase`\n\n**Issue**: Floating-point comparison failures\n- **Solution**: Use `'AbsTol'` or `'RelTol'` parameters with `verifyEqual`\n\n**Issue**: Tests affecting each other\n- **Solution**: Ensure proper cleanup in teardown methods and test independence\n\n**Issue**: Slow test execution\n- **Solution**: Use tags to separate fast unit tests from slow integration tests\n\n## Additional Resources\n\n- Use `doc matlab.unittest.TestCase` for complete assertion reference\n- Use `doc matlab.unittest.fixtures` for advanced fixture usage\n- Use `doc matlab.mock` for mocking framework documentation\n",
        "skills/matlab-uihtml-app-builder/SKILL.md": "---\nname: matlab-uihtml-app-builder\ndescription: Build interactive web applications using HTML/JavaScript interfaces with MATLAB computational backends via the uihtml component. Use when creating HTML-based MATLAB apps, JavaScript MATLAB interfaces, web UIs with MATLAB, interactive MATLAB GUIs, or when user mentions uihtml, HTML, JavaScript, web apps, or web interfaces.\nlicense: MathWorks BSD-3-Clause (see LICENSE)\n---\n\n# MATLAB uihtml App Builder\n\nThis skill provides comprehensive guidelines for building interactive web applications that combine HTML/JavaScript interfaces with MATLAB computational backends using the uihtml component. This architecture leverages modern web UI capabilities while harnessing MATLAB's powerful calculation engine.\n\n## When to Use This Skill\n\n- Building interactive MATLAB apps with HTML/JavaScript interfaces\n- Creating web-based UIs for MATLAB applications\n- Developing modern, responsive MATLAB GUIs using web technologies\n- When user mentions: uihtml, HTML, JavaScript, web app, web interface, interactive GUI\n- Combining web UI design with MATLAB computational power\n- Creating calculator apps, data visualizers, or form-based MATLAB tools\n\n## Core Architecture\n\n### The Four Components\n\n1. **HTML Interface** - User interface with buttons, forms, displays\n2. **JavaScript Logic** - Event handling and UI interactions\n3. **MATLAB Backend** - Computational engine and data processing\n4. **uihtml Component** - Bridge between HTML and MATLAB\n\n### Communication Patterns\n\nThe uihtml component enables bidirectional communication between JavaScript and MATLAB through several mechanisms:\n\n#### Pattern 1: MATLAB → JavaScript (Data Property)\n\n**Use Case**: Sending data from MATLAB to update the HTML interface\n\n```matlab\n% MATLAB side\nh.Data = \"Hello World!\";\n```\n\n```javascript\n// JavaScript side\nhtmlComponent.addEventListener(\"DataChanged\", function(event) {\n    document.getElementById(\"display\").innerHTML = htmlComponent.Data;\n});\n```\n\n#### Pattern 2: JavaScript → MATLAB (Events)\n\n**Use Case**: Triggering MATLAB functions from user interactions\n\n```javascript\n// JavaScript side - send event to MATLAB\nhtmlComponent.sendEventToMATLAB(\"Calculate\", expression);\n```\n\n```matlab\n% MATLAB side - receive and handle event\nh.HTMLEventReceivedFcn = @handleEvent;\n\nfunction handleEvent(src, event)\n    eventName = event.HTMLEventName;\n    eventData = event.HTMLEventData;\n    % Process event...\nend\n```\n\n#### Pattern 3: MATLAB → JavaScript (Custom Events)\n\n**Use Case**: Sending computed results or status updates to JavaScript\n\n```matlab\n% MATLAB side - send custom event to JavaScript\nsendEventToHTMLSource(h, \"ResultChanged\", result);\n```\n\n```javascript\n// JavaScript side - listen for custom event\nhtmlComponent.addEventListener(\"ResultChanged\", function(event) {\n    document.getElementById(\"display\").textContent = event.Data;\n});\n```\n\n#### Pattern 4: Complex Data Transfer\n\n**Use Case**: Passing structured data between MATLAB and JavaScript\n\n```matlab\n% MATLAB side - struct data gets JSON encoded automatically\nitemData = struct(\"ItemName\",\"Apple\",\"Price\",2,\"Quantity\",10);\nh.Data = itemData;\n```\n\n```javascript\n// JavaScript side - access as object properties\nhtmlComponent.Data.ItemName  // \"Apple\"\nhtmlComponent.Data.Price     // 2\nhtmlComponent.Data.Quantity  // 10\n```\n\n## Critical Rules\n\n### Security Requirements\n\n- **ALWAYS** set `HTMLSource = 'trusted'` when using local HTML files:\n  ```matlab\n  h.HTMLSource = fullfile(pwd, 'myapp.html');\n  % This is treated as trusted automatically for local files\n  ```\n\n- **MUST** validate all input from JavaScript before processing in MATLAB\n- **NEVER** use `eval()` on user input without strict sanitization\n- **ALWAYS** restrict allowed characters in user input for expressions\n\n### Error Handling\n\n**ALWAYS wrap MATLAB event handlers in try-catch blocks:**\n\n```matlab\nfunction handleEvent(src, event)\n    eventName = event.HTMLEventName;\n    eventData = event.HTMLEventData;\n\n    try\n        % Process the event\n        result = processData(eventData);\n\n        % Send result back to JavaScript\n        sendEventToHTMLSource(src, 'ResultEvent', result);\n\n    catch ME\n        % Handle errors gracefully\n        fprintf('Error: %s\\n', ME.message);\n        sendEventToHTMLSource(src, 'ErrorEvent', ME.message);\n    end\nend\n```\n\n### Data Validation\n\n**ALWAYS validate user input before processing:**\n\n```matlab\nfunction result = validateExpression(expression)\n    allowedChars = '0123456789+-*/.() ';\n    if ~all(ismember(expression, allowedChars))\n        error('Invalid characters in expression');\n    end\n    % Additional validation...\n    result = true;\nend\n```\n\n### File Organization\n\n**Follow this directory structure:**\n\n```\nproject/\n├── app.m           # Main MATLAB function\n├── app.html        # HTML interface\n├── README.md       # Usage instructions\n└── examples/       # Additional examples (optional)\n```\n\n## Complete Examples\n\n### Example 1: Simple Calculator App\n\n**MATLAB Side (calculator.m):**\n\n```matlab\nfunction calculator()\n    % Create main figure\n    fig = uifigure('Name', 'Calculator', 'Position', [100 100 400 500]);\n\n    % Create HTML component\n    h = uihtml(fig, 'Position', [25 25 350 450]);\n    h.HTMLSource = fullfile(pwd, 'calculator.html');\n    h.HTMLEventReceivedFcn = @(src, event) handleEvent(src, event);\nend\n\nfunction handleEvent(src, event)\n    eventName = event.HTMLEventName;\n    eventData = event.HTMLEventData;\n\n    try\n        switch eventName\n            case 'Calculate'\n                % Validate input\n                expression = char(eventData);\n                allowedChars = '0123456789+-*/.() ';\n\n                if ~all(ismember(expression, allowedChars))\n                    error('Invalid characters in expression');\n                end\n\n                % Evaluate safely\n                result = eval(expression);\n\n                % Send result back\n                sendEventToHTMLSource(src, 'Result', num2str(result));\n\n            case 'Clear'\n                sendEventToHTMLSource(src, 'Result', '0');\n        end\n\n    catch ME\n        fprintf('Error: %s\\n', ME.message);\n        sendEventToHTMLSource(src, 'Error', 'Invalid expression');\n    end\nend\n```\n\n**HTML Side (calculator.html):**\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            margin: 0;\n            padding: 20px;\n        }\n\n        .calculator {\n            background: white;\n            border-radius: 10px;\n            padding: 20px;\n            box-shadow: 0 10px 30px rgba(0,0,0,0.3);\n        }\n\n        .display {\n            width: 100%;\n            height: 60px;\n            font-size: 24px;\n            text-align: right;\n            padding: 10px;\n            border: 2px solid #ccc;\n            border-radius: 5px;\n            margin-bottom: 10px;\n            background: #f9f9f9;\n        }\n\n        .buttons {\n            display: grid;\n            grid-template-columns: repeat(4, 1fr);\n            gap: 10px;\n        }\n\n        button {\n            padding: 20px;\n            font-size: 18px;\n            border: none;\n            border-radius: 5px;\n            cursor: pointer;\n            background: #667eea;\n            color: white;\n            transition: background 0.3s;\n        }\n\n        button:hover {\n            background: #764ba2;\n        }\n\n        .operator {\n            background: #ff6b6b;\n        }\n\n        .operator:hover {\n            background: #ee5a52;\n        }\n    </style>\n\n    <script type=\"text/javascript\">\n        let currentExpression = '';\n\n        function setup(htmlComponent) {\n            window.htmlComponent = htmlComponent;\n\n            // Listen for results from MATLAB\n            htmlComponent.addEventListener(\"Result\", function(event) {\n                document.getElementById(\"display\").value = event.Data;\n                currentExpression = event.Data;\n            });\n\n            htmlComponent.addEventListener(\"Error\", function(event) {\n                document.getElementById(\"display\").value = \"Error\";\n                currentExpression = '';\n            });\n        }\n\n        function appendToDisplay(value) {\n            currentExpression += value;\n            document.getElementById(\"display\").value = currentExpression;\n        }\n\n        function clearDisplay() {\n            currentExpression = '';\n            document.getElementById(\"display\").value = '0';\n            window.htmlComponent.sendEventToMATLAB(\"Clear\", \"\");\n        }\n\n        function calculate() {\n            if (currentExpression) {\n                window.htmlComponent.sendEventToMATLAB(\"Calculate\", currentExpression);\n            }\n        }\n    </script>\n</head>\n<body>\n    <div class=\"calculator\">\n        <input type=\"text\" id=\"display\" class=\"display\" value=\"0\" readonly>\n        <div class=\"buttons\">\n            <button onclick=\"appendToDisplay('7')\">7</button>\n            <button onclick=\"appendToDisplay('8')\">8</button>\n            <button onclick=\"appendToDisplay('9')\">9</button>\n            <button class=\"operator\" onclick=\"appendToDisplay('/')\">/</button>\n\n            <button onclick=\"appendToDisplay('4')\">4</button>\n            <button onclick=\"appendToDisplay('5')\">5</button>\n            <button onclick=\"appendToDisplay('6')\">6</button>\n            <button class=\"operator\" onclick=\"appendToDisplay('*')\">*</button>\n\n            <button onclick=\"appendToDisplay('1')\">1</button>\n            <button onclick=\"appendToDisplay('2')\">2</button>\n            <button onclick=\"appendToDisplay('3')\">3</button>\n            <button class=\"operator\" onclick=\"appendToDisplay('-')\">-</button>\n\n            <button onclick=\"appendToDisplay('0')\">0</button>\n            <button onclick=\"appendToDisplay('.')\">.</button>\n            <button onclick=\"calculate()\">=</button>\n            <button class=\"operator\" onclick=\"appendToDisplay('+')\">+</button>\n\n            <button style=\"grid-column: span 4; background: #ff6b6b;\" onclick=\"clearDisplay()\">Clear</button>\n        </div>\n    </div>\n</body>\n</html>\n```\n\n### Example 2: Data Visualization App\n\n**MATLAB Side (visualizer.m):**\n\n```matlab\nfunction visualizer()\n    fig = uifigure('Name', 'Data Visualizer', 'Position', [100 100 800 600]);\n\n    % Create HTML component for controls\n    h = uihtml(fig, 'Position', [25 400 750 175]);\n    h.HTMLSource = fullfile(pwd, 'controls.html');\n    h.HTMLEventReceivedFcn = @(src, event) handleEvent(src, event, fig);\n\n    % Create axes for plotting\n    ax = uiaxes(fig, 'Position', [25 25 750 350]);\n    xlabel(ax, 'X');\n    ylabel(ax, 'Y');\n    title(ax, 'Interactive Plot');\nend\n\nfunction handleEvent(src, event, fig)\n    eventName = event.HTMLEventName;\n    eventData = event.HTMLEventData;\n\n    try\n        switch eventName\n            case 'UpdatePlot'\n                % Parse parameters from JavaScript\n                params = eventData;\n                frequency = params.frequency;\n                amplitude = params.amplitude;\n                plotType = params.plotType;\n\n                % Generate data\n                x = linspace(0, 4*pi, 200);\n\n                switch plotType\n                    case 'sine'\n                        y = amplitude * sin(frequency * x);\n                    case 'cosine'\n                        y = amplitude * cos(frequency * x);\n                    case 'both'\n                        y = amplitude * sin(frequency * x);\n                        y2 = amplitude * cos(frequency * x);\n                end\n\n                % Find axes and plot\n                ax = findobj(fig, 'Type', 'axes');\n                cla(ax);\n\n                if strcmp(plotType, 'both')\n                    plot(ax, x, y, 'LineWidth', 2);\n                    hold(ax, 'on');\n                    plot(ax, x, y2, 'LineWidth', 2);\n                    hold(ax, 'off');\n                    legend(ax, 'Sine', 'Cosine');\n                else\n                    plot(ax, x, y, 'LineWidth', 2);\n                end\n\n                grid(ax, 'on');\n\n                % Send confirmation\n                sendEventToHTMLSource(src, 'PlotUpdated', 'Success');\n        end\n\n    catch ME\n        fprintf('Error: %s\\n', ME.message);\n        sendEventToHTMLSource(src, 'Error', ME.message);\n    end\nend\n```\n\n**HTML Side (controls.html):**\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);\n            color: white;\n            margin: 0;\n            padding: 20px;\n        }\n\n        .controls {\n            display: grid;\n            grid-template-columns: 1fr 1fr 1fr;\n            gap: 20px;\n        }\n\n        .control-group {\n            background: rgba(255,255,255,0.1);\n            padding: 15px;\n            border-radius: 8px;\n        }\n\n        label {\n            display: block;\n            margin-bottom: 5px;\n            font-weight: bold;\n        }\n\n        input[type=\"range\"] {\n            width: 100%;\n        }\n\n        select, button {\n            width: 100%;\n            padding: 8px;\n            border-radius: 5px;\n            border: none;\n            font-size: 14px;\n        }\n\n        button {\n            background: #3498db;\n            color: white;\n            cursor: pointer;\n            margin-top: 10px;\n            transition: background 0.3s;\n        }\n\n        button:hover {\n            background: #2980b9;\n        }\n    </style>\n\n    <script type=\"text/javascript\">\n        function setup(htmlComponent) {\n            window.htmlComponent = htmlComponent;\n\n            htmlComponent.addEventListener(\"PlotUpdated\", function(event) {\n                console.log(\"Plot updated successfully\");\n            });\n        }\n\n        function updatePlot() {\n            const frequency = parseFloat(document.getElementById(\"frequency\").value);\n            const amplitude = parseFloat(document.getElementById(\"amplitude\").value);\n            const plotType = document.getElementById(\"plotType\").value;\n\n            const params = {\n                frequency: frequency,\n                amplitude: amplitude,\n                plotType: plotType\n            };\n\n            window.htmlComponent.sendEventToMATLAB(\"UpdatePlot\", params);\n        }\n\n        function updateFreqLabel(value) {\n            document.getElementById(\"freqValue\").textContent = value;\n        }\n\n        function updateAmpLabel(value) {\n            document.getElementById(\"ampValue\").textContent = value;\n        }\n    </script>\n</head>\n<body>\n    <div class=\"controls\">\n        <div class=\"control-group\">\n            <label>Frequency: <span id=\"freqValue\">1</span></label>\n            <input type=\"range\" id=\"frequency\" min=\"0.1\" max=\"5\" step=\"0.1\" value=\"1\"\n                   oninput=\"updateFreqLabel(this.value)\">\n        </div>\n\n        <div class=\"control-group\">\n            <label>Amplitude: <span id=\"ampValue\">1</span></label>\n            <input type=\"range\" id=\"amplitude\" min=\"0.1\" max=\"5\" step=\"0.1\" value=\"1\"\n                   oninput=\"updateAmpLabel(this.value)\">\n        </div>\n\n        <div class=\"control-group\">\n            <label>Plot Type:</label>\n            <select id=\"plotType\">\n                <option value=\"sine\">Sine</option>\n                <option value=\"cosine\">Cosine</option>\n                <option value=\"both\">Both</option>\n            </select>\n        </div>\n    </div>\n\n    <button onclick=\"updatePlot()\">Update Plot</button>\n</body>\n</html>\n```\n\n### Example 3: Form Processing App\n\n**MATLAB Side (formProcessor.m):**\n\n```matlab\nfunction formProcessor()\n    fig = uifigure('Name', 'Form Processor', 'Position', [100 100 600 400]);\n\n    h = uihtml(fig, 'Position', [25 25 550 350]);\n    h.HTMLSource = fullfile(pwd, 'form.html');\n    h.HTMLEventReceivedFcn = @(src, event) handleEvent(src, event);\nend\n\nfunction handleEvent(src, event)\n    eventName = event.HTMLEventName;\n    eventData = event.HTMLEventData;\n\n    try\n        switch eventName\n            case 'SubmitForm'\n                % Extract form data\n                name = eventData.name;\n                email = eventData.email;\n                age = eventData.age;\n\n                % Validate data\n                if isempty(name) || isempty(email)\n                    error('Name and email are required');\n                end\n\n                if ~contains(email, '@')\n                    error('Invalid email address');\n                end\n\n                if age < 0 || age > 120\n                    error('Invalid age');\n                end\n\n                % Process data (example: save to file or database)\n                fprintf('Processing form:\\n');\n                fprintf('  Name: %s\\n', name);\n                fprintf('  Email: %s\\n', email);\n                fprintf('  Age: %d\\n', age);\n\n                % Send success message\n                result = struct('status', 'success', ...\n                               'message', 'Form submitted successfully!');\n                sendEventToHTMLSource(src, 'FormResult', result);\n\n            case 'ClearForm'\n                sendEventToHTMLSource(src, 'FormCleared', '');\n        end\n\n    catch ME\n        fprintf('Error: %s\\n', ME.message);\n        result = struct('status', 'error', 'message', ME.message);\n        sendEventToHTMLSource(src, 'FormResult', result);\n    end\nend\n```\n\n## Best Practices\n\n### UI Design Principles\n\n- **Use CSS Grid or Flexbox** for responsive layouts that adapt to different window sizes\n- **Implement hover effects** for better user experience and visual feedback\n- **Provide clear visual feedback** for user actions (button clicks, form submission, errors)\n- **Use semantic HTML elements** (button, input, form) for better accessibility\n- **Apply professional color schemes** using CSS gradients and modern design patterns\n\n### Performance Optimization\n\n- **Minimize data transfer** between HTML and MATLAB - send only necessary data\n- **Use appropriate data types** - numbers, strings, structs (converted to JSON)\n- **Implement loading indicators** for long MATLAB operations\n- **Cache results** when appropriate using persistent variables in MATLAB\n- **Batch multiple updates** instead of sending many small events\n\n### Error Handling Strategy\n\n**JavaScript Side:**\n```javascript\nhtmlComponent.addEventListener(\"Error\", function(event) {\n    // Display user-friendly error messages\n    alert(\"Error: \" + event.Data);\n});\n```\n\n**MATLAB Side:**\n```matlab\ntry\n    result = processInput(input);\n    sendEventToHTMLSource(src, 'Success', result);\ncatch ME\n    fprintf('Error: %s\\n', ME.message);\n    sendEventToHTMLSource(src, 'Error', 'Processing failed');\nend\n```\n\n### Testing Strategy\n\n1. **Unit Testing** - Test MATLAB functions independently\n   ```matlab\n   % Test individual processing functions\n   assert(validateExpression('2+2'), 'Validation should pass');\n   ```\n\n2. **Integration Testing** - Test HTML-MATLAB communication\n   ```matlab\n   % Test event handling with sample data\n   testEvent = struct('HTMLEventName', 'Calculate', 'HTMLEventData', '2+2');\n   handleEvent(h, testEvent);\n   ```\n\n3. **User Testing** - Test complete user workflows\n   - Try all button combinations\n   - Test edge cases and invalid inputs\n   - Verify visual feedback is clear\n\n4. **Error Testing** - Test error conditions\n   - Invalid input characters\n   - Empty input fields\n   - Network/timeout scenarios\n\n### Debugging Tips\n\n- **MATLAB Side**: Use `fprintf()` to log events and data\n  ```matlab\n  fprintf('Received event: %s with data: %s\\n', eventName, eventData);\n  ```\n\n- **JavaScript Side**: Use browser developer tools (F12) to debug\n  ```javascript\n  console.log(\"Sending to MATLAB:\", data);\n  ```\n\n- **Test each communication direction separately**\n  - First test MATLAB → JavaScript (Data property)\n  - Then test JavaScript → MATLAB (events)\n  - Finally test bidirectional flow\n\n- **Verify data types and formats**\n  ```matlab\n  fprintf('Data type: %s\\n', class(eventData));\n  fprintf('Data value: %s\\n', string(eventData));\n  ```\n\n## Common Patterns\n\n### Pattern 1: Calculator Pattern\n- JavaScript builds expression strings from button clicks\n- Send expression to MATLAB via `sendEventToMATLAB`\n- MATLAB safely evaluates with input validation\n- Results sent back via `sendEventToHTMLSource`\n- Display results in real-time\n\n### Pattern 2: Data Visualization Pattern\n- JavaScript handles user interaction (sliders, dropdowns)\n- Send parameters to MATLAB for computation\n- MATLAB processes data and updates plots\n- Can use uiaxes for MATLAB plots or send data for JavaScript plotting\n- Support real-time updates and animations\n\n### Pattern 3: Form Processing Pattern\n- JavaScript collects form data into structured object\n- Send entire form data as single event\n- MATLAB validates each field\n- Process data (save, compute, export)\n- Send confirmation or error messages back\n- Update UI based on results\n\n### Pattern 4: Real-time Monitoring Pattern\n- MATLAB continuously generates data (simulation, sensor reading)\n- Send updates via `sendEventToHTMLSource` at intervals\n- JavaScript updates display in real-time\n- Implement start/stop/pause controls\n- Use efficient data formats (arrays, structs)\n\n## Implementation Checklist\n\nBefore deploying a uihtml app, verify:\n\n- [ ] HTML file exists in correct location\n- [ ] `HTMLSource` property set to correct file path\n- [ ] `HTMLEventReceivedFcn` callback defined\n- [ ] JavaScript `setup(htmlComponent)` function implemented\n- [ ] Event listeners added for MATLAB→JS communication\n- [ ] Try-catch blocks wrap all MATLAB event handling\n- [ ] Input validation implemented for all user data\n- [ ] Error events sent back to JavaScript for user feedback\n- [ ] CSS styling applied for professional appearance\n- [ ] Responsive design tested at different window sizes\n- [ ] All user interactions provide visual feedback\n- [ ] Loading indicators shown for long operations\n- [ ] File organization follows project structure\n- [ ] Documentation (README) created with usage instructions\n\n## Troubleshooting\n\n**Issue**: HTML file not loading in uihtml component\n- **Solution**: Check file path is absolute or relative to current directory\n  ```matlab\n  h.HTMLSource = fullfile(pwd, 'app.html');  % Absolute path\n  ```\n\n**Issue**: Events not triggering MATLAB callback\n- **Solution**: Verify `HTMLEventReceivedFcn` is set before HTML loads\n- **Solution**: Check JavaScript is calling `sendEventToMATLAB` correctly\n\n**Issue**: Data not updating in JavaScript\n- **Solution**: Ensure `DataChanged` event listener is registered in `setup()`\n- **Solution**: Verify MATLAB is setting `h.Data` property, not sending event\n\n**Issue**: JavaScript errors in browser console\n- **Solution**: Open browser dev tools (F12) to see detailed error messages\n- **Solution**: Ensure `htmlComponent` is passed to `setup()` function\n- **Solution**: Check for typos in element IDs and function names\n\n**Issue**: MATLAB errors not displayed to user\n- **Solution**: Implement error event handling in both MATLAB and JavaScript\n- **Solution**: Use try-catch in MATLAB and send error messages via `sendEventToHTMLSource`\n\n**Issue**: Slow performance when sending data\n- **Solution**: Reduce frequency of updates (throttle events)\n- **Solution**: Send only changed data, not entire datasets\n- **Solution**: Use appropriate data types (numbers vs strings)\n\n**Issue**: Complex data structures not transferring correctly\n- **Solution**: Use MATLAB structs (automatically converted to JSON)\n- **Solution**: Avoid nested cell arrays; use struct arrays instead\n- **Solution**: Test data transfer with simple examples first\n\n**Issue**: Styling not appearing correctly\n- **Solution**: Verify CSS is in `<style>` block inside `<head>`\n- **Solution**: Check for CSS syntax errors\n- **Solution**: Use browser dev tools to inspect computed styles\n\n## Additional Resources\n\n- MATLAB Documentation: `doc uihtml`\n- HTML/CSS/JavaScript: MDN Web Docs\n- Event handling: `doc sendEventToHTMLSource`\n- Figure creation: `doc uifigure`\n- Debugging: Use browser Developer Tools (F12)\n"
      },
      "plugins": [
        {
          "name": "matlab-skills",
          "source": "./",
          "description": "A collection of agent skills for MATLAB development",
          "version": "1.0.1",
          "author": {
            "name": "The MathWorks, Inc."
          },
          "homepage": "https://github.com/matlab/skills",
          "repository": "https://github.com/matlab/skills",
          "license": "BSD-3-Clause",
          "keywords": [
            "matlab",
            "live-scripts",
            "testing",
            "performance",
            "optimization",
            "vectorization",
            "code-generation",
            "scientific-computing",
            "data-analysis",
            "programming",
            "html",
            "javascript",
            "uihtml",
            "web",
            "interactive",
            "gui",
            "webapp",
            "filter",
            "digital-filter",
            "signal-processing",
            "fir",
            "iir",
            "lowpass",
            "highpass",
            "bandpass",
            "bandstop",
            "notch",
            "dsp"
          ],
          "categories": [
            "bandpass",
            "bandstop",
            "code-generation",
            "data-analysis",
            "digital-filter",
            "dsp",
            "filter",
            "fir",
            "gui",
            "highpass",
            "html",
            "iir",
            "interactive",
            "javascript",
            "live-scripts",
            "lowpass",
            "matlab",
            "notch",
            "optimization",
            "performance",
            "programming",
            "scientific-computing",
            "signal-processing",
            "testing",
            "uihtml",
            "vectorization",
            "web",
            "webapp"
          ],
          "install_commands": [
            "/plugin marketplace add matlab/skills",
            "/plugin install matlab-skills@matlab-skills"
          ]
        }
      ]
    }
  ]
}