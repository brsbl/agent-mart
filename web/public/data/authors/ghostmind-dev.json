{
  "author": {
    "id": "ghostmind-dev",
    "display_name": "ghostmind-dev",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/108080350?v=4",
    "url": "https://github.com/ghostmind-dev",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 2,
      "total_skills": 2,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "ghostmind",
      "version": null,
      "description": "Ghostmind system plugin with skills for development workflows and AI image generation",
      "owner_info": {
        "name": "ghostmind-dev"
      },
      "keywords": [],
      "repo_full_name": "ghostmind-dev/system",
      "repo_url": "https://github.com/ghostmind-dev/system",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-11-30T00:24:53Z",
        "created_at": "2025-10-25T01:46:50Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 452
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/system",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/system/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/system/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 199
        },
        {
          "path": "plugins/system/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/system/skills/system",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/system/skills/system/SKILL.md",
          "type": "blob",
          "size": 15854
        },
        {
          "path": "plugins/system/skills/system/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/system/skills/system/references/compose-overview.md",
          "type": "blob",
          "size": 7095
        },
        {
          "path": "plugins/system/skills/system/references/custom-scripts-guide.md",
          "type": "blob",
          "size": 5776
        },
        {
          "path": "plugins/system/skills/system/references/docker-overview.md",
          "type": "blob",
          "size": 5834
        },
        {
          "path": "plugins/system/skills/system/references/mcp-configuration.md",
          "type": "blob",
          "size": 6201
        },
        {
          "path": "plugins/system/skills/system/references/meta-json-guide.md",
          "type": "blob",
          "size": 9730
        },
        {
          "path": "plugins/system/skills/system/references/routines-guide.md",
          "type": "blob",
          "size": 7131
        },
        {
          "path": "plugins/system/skills/system/references/run-cli-overview.md",
          "type": "blob",
          "size": 4414
        },
        {
          "path": "plugins/system/skills/system/references/system-overview.md",
          "type": "blob",
          "size": 22169
        },
        {
          "path": "plugins/system/skills/system/references/terraform-overview.md",
          "type": "blob",
          "size": 7733
        },
        {
          "path": "plugins/system/skills/system/references/tmux-sections-guide.md",
          "type": "blob",
          "size": 28295
        },
        {
          "path": "plugins/system/skills/system/references/tunnel-configuration.md",
          "type": "blob",
          "size": 7739
        },
        {
          "path": "plugins/utils",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utils/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utils/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 196
        },
        {
          "path": "plugins/utils/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utils/commands/create-ai-note.md",
          "type": "blob",
          "size": 640
        },
        {
          "path": "plugins/utils/commands/publish-changes.md",
          "type": "blob",
          "size": 362
        },
        {
          "path": "plugins/utils/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utils/skills/banana",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/utils/skills/banana/SKILL.md",
          "type": "blob",
          "size": 1981
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"ghostmind\",\n  \"owner\": {\n    \"name\": \"ghostmind-dev\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"system\",\n      \"source\": \"./plugins/system\",\n      \"description\": \"Ghostmind system plugin with skills for development workflows and AI image generation\"\n    },\n    {\n      \"name\": \"utils\",\n      \"source\": \"./plugins/utils\",\n      \"description\": \"Ghostmind utils plugin with skills for development workflows and AI image generation\"\n    }\n  ]\n}\n",
        "plugins/system/.claude-plugin/plugin.json": "{\n  \"name\": \"system\",\n  \"description\": \"Ghostmind system plugins with skills for development workflows and AI image generation\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"ghostmind-dev\"\n  }\n}\n",
        "plugins/system/skills/system/SKILL.md": "---\nname: ghostmind-system\ndescription: This skill should be used when working with the Ghostmind development system, which uses meta.json as a central configuration for Docker, Compose, Terraform, and Tmux. Use this skill when creating or modifying configurations for any of these components, setting up new applications, or understanding how the system components interconnect.\n---\n\n# Ghostmind System Skill\n\nThis skill should be used when working with the Ghostmind development system, which uses meta.json as a central configuration for Docker, Compose, Terraform, and Tmux. Use this skill when creating or modifying configurations for any of these components, setting up new applications, or understanding how the system components interconnect.\n\n## When to Use This Skill\n\nUse this skill when:\n\n- Creating or configuring new applications in the Ghostmind system\n- Working with `meta.json` configuration files\n- Setting up Docker containers, Docker Compose services, or Terraform infrastructure\n- Configuring Tmux sessions, windows, and panes\n- Writing or modifying custom scripts in the system\n- Setting up MCP (Model Context Protocol) servers\n- Configuring Cloudflared tunnels for local development\n- Creating shell command routines\n- Troubleshooting configuration issues\n- Understanding the relationship between system components\n- Working with environment variables, vault secrets, or variable substitution\n- Setting up development environments in VS Code devcontainers\n\n## ⚠️ CRITICAL: ALWAYS Fetch the Schema First\n\n**This is the most important rule when working with the Ghostmind system:**\n\n### Before ANY work involving meta.json, ALWAYS fetch the latest schema:\n\n```\nSchema URL: https://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n**Why this is imperative:**\n- The schema is the **authoritative source** for all available meta.json properties\n- It contains validation rules, property structures, and available options\n- The schema is actively maintained and may change\n- Working without the schema can lead to invalid configurations\n- Every component (docker, compose, terraform, etc.) has its configuration structure defined in the schema\n\n**When to fetch:**\n- At the start of any task involving the Ghostmind system\n- Before creating or modifying meta.json files\n- When documenting configuration options\n- When troubleshooting configuration issues\n- Before reading any component guides\n\n**How to fetch:**\nUse WebFetch to retrieve the schema and understand the complete structure before proceeding with configuration work\n\n## Core Capabilities\n\n### 1. Meta.json Configuration\n\nmeta.json is the **foundation** of every application in the Ghostmind system. It:\n\n- Acts as the single source of truth for application configuration\n- Defines what components exist (docker, compose, terraform, tmux, etc.)\n- Links different parts together\n- Configures development tools (MCP, tunnels, routines, custom scripts)\n- Enables the `run` tool to orchestrate the application\n- Supports variable substitution for dynamic behavior\n\n**Key files to reference:**\n- `references/meta-json-guide.md` - Core meta.json concepts and structure\n- `references/system-overview.md` - Foundation document for understanding the system\n\n### 2. Run CLI Tool\n\nThe `run` command is the unified orchestrator for all system operations. It's both:\n- A CLI tool for executing commands\n- A Deno TypeScript library for custom scripts\n\n**Key commands:**\n- `run docker` - Docker operations (build, push, exec)\n- `run compose` - Docker Compose operations (up, down, build)\n- `run terraform` - Terraform operations (plan, apply, destroy)\n- `run tmux` - Tmux session management (init, attach, kill)\n- `run custom` - Execute custom TypeScript scripts\n- `run vault` - Secrets management (import, export)\n\n**Reference:** `references/run-cli-overview.md`\n\n### 3. Component Configuration\n\nEach component has its own guide with meta.json configuration, examples, and best practices:\n\n| Component      | Purpose                          | Guide                              |\n|----------------|----------------------------------|------------------------------------|\n| Docker         | Container configuration          | `references/docker-overview.md`    |\n| Compose        | Multi-container orchestration    | `references/compose-overview.md`   |\n| Terraform      | Infrastructure as code           | `references/terraform-overview.md` |\n| Tmux           | Terminal session management      | `references/tmux-sections-guide.md`|\n| Custom Scripts | TypeScript/Deno workflow scripts | `references/custom-scripts-guide.md`|\n| Routines       | Shell command aliases            | `references/routines-guide.md`     |\n| MCP            | AI agent tool servers            | `references/mcp-configuration.md`  |\n| Tunnel         | Cloudflared public URL exposure  | `references/tunnel-configuration.md`|\n\n**Each component guide includes:**\n- Schema-fetching reminder\n- Meta.json configuration section specific to that component\n- Practical examples and patterns\n- Best practices and common workflows\n\n### 4. Development Environment\n\n**VS Code Devcontainers:**\n- 95% of projects are developed inside VS Code devcontainers\n- Containers provide isolated, reproducible development environments\n- Special environment variables are used for Docker-in-Docker scenarios\n\n**Critical Environment Variables:**\n\n**SRC vs LOCALHOST_SRC:**\n- `SRC`: Path to source code inside the devcontainer (e.g., `/workspaces/my-app`)\n- `LOCALHOST_SRC`: Path on the host machine (e.g., `/Users/me/code/my-app`)\n- Required for Docker-in-Docker volume mounting\n- Automatically set in devcontainer configurations\n\n**PROJECT and APP:**\n- `PROJECT`: Extracted from root meta.json `name` property\n- `APP`: Extracted from app meta.json `name` property\n- Used throughout the system for naming consistency\n- Support variable substitution: `${PROJECT}`, `${APP}`\n\n**Reference:** `references/system-overview.md` - Comprehensive environment variable documentation\n\n### 5. Variable Substitution\n\nEnvironment variables can be used dynamically in:\n- meta.json files\n- .env files\n- Docker Compose configurations\n- Terraform configurations\n\n**Syntax:** `${VARIABLE_NAME}`\n\n**Common patterns:**\n```bash\n# In .env files\nSERVER_URL=\"http://localhost:${PORT}\"\nPUBLIC_URL=\"https://${TUNNEL_NAME}\"\n\n# In meta.json\n\"image\": \"${PROJECT}/${APP}:${VERSION}\"\n\"hostname\": \"${APP}.${DOMAIN}\"\n```\n\n**Reference:** `references/system-overview.md` - Variable substitution section\n\n### 6. Secrets Management with Vault\n\n**Vault Integration:**\n- Centralized secrets management using Google Cloud Secret Manager\n- Automatic import/export of environment variables\n- Secure sharing across teams and environments\n\n**Workflow:**\n```bash\n# Export secrets to vault\nrun vault export\n\n# Import secrets from vault\nrun vault import\n```\n\n**File patterns:**\n- `.env.base` - Non-sensitive defaults, committed to git\n- `.env.local` - Local overrides, gitignored\n- `.env.{environment}` - Environment-specific, gitignored\n- `.env` - Generated by merging base + environment, gitignored\n\n**Reference:** `references/system-overview.md` - Vault and secrets section\n\n## Common Workflows\n\n### Creating a New Application\n\n1. **Fetch the schema** (always first!)\n2. Create `meta.json` with basic properties (id, name, version)\n3. Add component configurations as needed:\n   - `docker` for containerization\n   - `compose` for local development\n   - `terraform` for cloud deployment\n   - `tmux` for development environment\n4. Create `.env.base` with non-sensitive defaults\n5. Set up vault secrets if needed\n6. Define custom scripts or routines for common tasks\n\n**Reference:** `references/system-overview.md` - Project structure patterns\n\n### Configuring a Component\n\n1. **Fetch the schema** to understand available properties\n2. Read the component-specific guide (e.g., `references/docker-overview.md`)\n3. Add the component section to meta.json\n4. Test the configuration using `run` commands\n5. Document any custom scripts or routines\n\n### Troubleshooting Configuration Issues\n\n1. **Fetch the schema** to verify property names and structure\n2. Validate meta.json against the schema\n3. Check environment variables and variable substitution\n4. Review component-specific logs using `run` commands\n5. Consult the relevant component guide\n\n### Working with Custom Scripts\n\n1. Create TypeScript file in scripts directory\n2. Import types: `CustomArgs`, `CustomOptions`\n3. Import functions from `jsr:@ghostmind/run`\n4. Add script reference to meta.json `custom` section\n5. Execute with `run custom <script-name>`\n\n**Reference:** `references/custom-scripts-guide.md`\n\n## System Architecture Overview\n\n### GitHub Organization\n\nAll Ghostmind repositories are in: https://github.com/orgs/ghostmind-dev/repositories\n\n**Key repositories:**\n- **config repos**: Shared configuration (Terraform, Docker, etc.)\n- **init repos**: Application initialization and setup\n- **play repos**: Experimentation and development environments\n- **run**: The orchestrator CLI tool and library\n\n### Multi-Meta.json Support\n\nProjects can have:\n- **Single meta.json**: At project root for simple applications\n- **Multiple meta.json**: One root + multiple apps, each with their own meta.json\n- **Root meta.json**: Defines project-level properties (PROJECT variable source)\n- **App meta.json**: Defines app-specific configuration (APP variable source)\n\n**Reference:** `references/meta-json-guide.md` - Multi-meta.json section\n\n### Component Interconnection\n\nComponents in meta.json work together:\n\n```\nmeta.json\n├── docker       → Defines container image\n│   └── Used by: compose (services), terraform (Cloud Run)\n├── compose      → Local development orchestration\n│   └── Uses: docker images, .env files\n├── terraform    → Cloud infrastructure\n│   └── Uses: docker images, .env variables\n├── tmux         → Development environment\n│   └── Can: run custom scripts, start compose services\n├── custom       → TypeScript workflows\n│   └── Can: orchestrate all components\n├── routines     → Shell command aliases\n│   └── Can: chain run commands\n├── mcp          → AI agent tools\n└── tunnel       → Public URL exposure\n    └── Uses: PORT variable from .env\n```\n\n**Reference:** `references/system-overview.md` - System components section\n\n## Best Practices\n\n### 1. Schema-First Approach\n\n- **ALWAYS fetch the schema** before working with meta.json\n- Use the schema as documentation, not just validation\n- Check the schema for new features and properties\n- Validate configurations against the schema\n\n### 2. Environment Variables\n\n- Use `.env.base` for defaults (committed)\n- Use `.env.local` for local overrides (gitignored)\n- Use `.env.{environment}` for environment-specific values (gitignored)\n- Never commit secrets to git - use vault\n- Use variable substitution for dynamic values\n\n### 3. Project Organization\n\n- Start with minimal meta.json\n- Add components incrementally as needed\n- Keep custom scripts focused and single-purpose\n- Use routines for simple command aliases\n- Document complex workflows in custom scripts\n\n### 4. Development Workflow\n\n- Work in VS Code devcontainers for consistency\n- Use `run` commands instead of direct docker/terraform\n- Leverage Tmux for persistent development environments\n- Use MCP for project-specific AI agent tools\n- Use tunnels for webhook/OAuth testing\n\n### 5. Configuration Management\n\n- Keep meta.json clean and well-structured\n- Use comments sparingly (JSON doesn't support them)\n- Reference the schema for available options\n- Test configurations in local environment first\n- Use version control for configuration changes\n\n## Getting Started\n\n### First Steps with the Skill\n\n1. **Fetch the schema** (https://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json)\n2. Read `references/system-overview.md` for foundational understanding\n3. Review `references/meta-json-guide.md` for core concepts\n4. Identify which components you need (docker, compose, terraform, etc.)\n5. Read the relevant component guides\n6. Start with a minimal configuration and iterate\n\n### Essential Reading Order\n\nFor comprehensive understanding, read in this order:\n\n1. **SKILL.md** (this file) - Overview and when to use\n2. **references/system-overview.md** - Foundation and architecture\n3. **references/meta-json-guide.md** - Core configuration concepts\n4. **Component guides** - As needed for specific components\n5. **references/run-cli-overview.md** - CLI tool usage\n\n### Quick Reference\n\n**Common tasks:**\n- New app setup → `system-overview.md` + `meta-json-guide.md`\n- Docker config → `docker-overview.md`\n- Compose config → `compose-overview.md`\n- Terraform config → `terraform-overview.md`\n- Tmux setup → `tmux-sections-guide.md`\n- Custom workflows → `custom-scripts-guide.md`\n- Simple aliases → `routines-guide.md`\n- MCP servers → `mcp-configuration.md`\n- Tunnels → `tunnel-configuration.md`\n\n## Important Considerations\n\n### Devcontainer Context\n\nWhen working in VS Code devcontainers:\n- Use `SRC` for paths inside the container\n- Use `LOCALHOST_SRC` for Docker-in-Docker volume mounts\n- Environment variables are automatically set\n- Docker socket is shared from host\n\n**Reference:** `references/system-overview.md` - Devcontainer section\n\n### Variable Substitution Rules\n\n- Variables use `${VAR_NAME}` syntax\n- Substitution happens at runtime\n- Variables must be defined in .env files or environment\n- `PROJECT` and `APP` are automatically extracted from meta.json\n- Nested substitution is not supported\n\n**Reference:** `references/system-overview.md` - Variable substitution section\n\n### Schema Validation\n\n- meta.json files should validate against the schema\n- The `run` tool validates configurations automatically\n- Schema violations will cause errors\n- Always fetch latest schema for validation\n\n### Component Dependencies\n\nSome components depend on others:\n- **Compose** services reference **docker** images\n- **Terraform** Cloud Run services reference **docker** images\n- **Custom scripts** can orchestrate all components\n- **Routines** can chain **run** commands\n- **Tmux** can execute **custom** scripts or **routines**\n\n## Support and Resources\n\n### GitHub Organization\nhttps://github.com/orgs/ghostmind-dev/repositories\n\n### Key Repositories\n- **run**: https://github.com/ghostmind-dev/run (CLI tool and library)\n- **config repos**: Shared configuration templates\n- **init repos**: Application initialization\n\n### Schema URL\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n\n### Documentation Files\n\nAll reference files are in `references/` directory:\n- `system-overview.md` - Comprehensive system documentation\n- `meta-json-guide.md` - Central configuration guide\n- `run-cli-overview.md` - CLI tool documentation\n- `docker-overview.md` - Docker configuration\n- `compose-overview.md` - Docker Compose configuration\n- `terraform-overview.md` - Terraform configuration\n- `tmux-sections-guide.md` - Tmux configuration\n- `custom-scripts-guide.md` - Custom script development\n- `routines-guide.md` - Shell command aliases\n- `mcp-configuration.md` - MCP server setup\n- `tunnel-configuration.md` - Cloudflared tunnels\n\n## Remember\n\nThe Ghostmind system is designed to be:\n- **Flexible**: Not prescriptive about project structure\n- **Configuration-driven**: meta.json as single source of truth\n- **Component-based**: Add only what you need\n- **Schema-validated**: Always fetch and use the schema\n- **Environment-aware**: Support for multiple environments\n- **Secure**: Vault integration for secrets\n\n**Most importantly:** ALWAYS fetch the schema before working with meta.json configuration. This is the foundation of successful work with the Ghostmind system\n",
        "plugins/system/skills/system/references/compose-overview.md": "# Docker Compose Configuration Overview\n\n## Introduction\n\nThis document explains how Docker Compose is configured and used within Ghostmind's development system. Docker Compose is **exclusively used for local development** and provides a consistent way to run applications in development environments.\n\n## Core Concept: Development-Only Containerization\n\nDocker Compose in Ghostmind's system:\n- **Development only** - Never used for production deployments\n- **Environment variable driven** - Uses `SRC` and `LOCALHOST_SRC` extensively\n- **Meta.json configured** - Location and settings defined in meta configuration\n- **Hot reload enabled** - Source code mounted for live development\n\n## Compose Configuration in meta.json\n\n**⚠️ ALWAYS fetch the schema first:**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\nThe Compose configuration is defined under the `compose` property in `meta.json`:\n\n```json\n{\n  \"compose\": {\n    \"default\": {\n      \"root\": \"local\",\n      \"filename\": \"compose.yaml\"\n    }\n  }\n}\n```\n\n### Configuration Properties\n\n#### `root` (required)\n- **Purpose**: Specifies the directory where compose files are located\n- **Example**: `\"root\": \"local\"`\n- **Result**: Compose files are in `/path/to/project/local/`\n- **Common values**: `\"local\"`, `\"compose\"`, `\"dev\"`\n\n#### `filename` (optional)\n- **Purpose**: Custom compose filename\n- **Default**: `docker-compose.yaml` if not specified\n- **Example**: `\"filename\": \"compose.yaml\"`\n- **Result**: Uses `/path/to/project/local/compose.yaml`\n\n**For complete `compose` property structure:** Fetch the schema\n\n## Critical Environment Variables Usage\n\n### File and Directory References\n\n**All paths in compose files MUST use the `SRC` environment variable:**\n\n```yaml\nservices:\n  app:\n    build:\n      context: ${SRC}/app                    # ✅ Build context\n      dockerfile: ${SRC}/docker/Dockerfile.dev  # ✅ Dockerfile location\n    env_file:\n      - ${SRC}/.env.base                     # ✅ Environment files\n      - ${SRC}/.env.local\n```\n\n### Volume Mounting\n\n**Volume mounting MUST use `LOCALHOST_SRC` for host paths:**\n\n```yaml\nservices:\n  app:\n    volumes:\n      - ${LOCALHOST_SRC}/app:/app/app        # ✅ Host path uses LOCALHOST_SRC\n      - ${LOCALHOST_SRC}/data:/app/data      # ✅ Correct for dev container\n```\n\n**Why this is critical:**\n- Dev containers run inside Docker\n- Volume mounts need **host machine paths**, not container paths\n- `SRC` = container path, `LOCALHOST_SRC` = host path\n\n### Environment Variable Injection\n\n```yaml\nservices:\n  app:\n    environment:\n      LOCALHOST_SRC: ${LOCALHOST_SRC}        # ✅ Pass to container\n      SRC: ${SRC}                           # ✅ Container operations\n```\n\n## Standard Environment Files\n\nCompose configurations reference two environment files:\n\n### `.env.base`\n- **Purpose**: Shared environment variables across all environments\n- **Contains**: Common configuration, defaults\n- **Usage**: `env_file: - ${SRC}/.env.base`\n\n### `.env.local`\n- **Purpose**: Local development specific variables\n- **Contains**: Development overrides, local secrets\n- **Usage**: `env_file: - ${SRC}/.env.local`\n\n## Complete Example\n\nBased on the current project structure:\n\n### meta.json Configuration\n```json\n{\n  \"compose\": {\n    \"default\": {\n      \"root\": \"local\",\n      \"filename\": \"compose.yaml\"\n    }\n  }\n}\n```\n\n### compose.yaml Example\n```yaml\nservices:\n  app:\n    container_name: doc-mcp\n    build:\n      context: ${SRC}/app\n      dockerfile: ${SRC}/docker/Dockerfile.dev\n      args:\n        LOCAL: 'true'\n    env_file:\n      - ${SRC}/.env.base\n      - ${SRC}/.env.local\n    ports:\n      - ${PORT}:${PORT}\n    environment:\n      APP: ${APP}\n      LOCALHOST_SRC: ${LOCALHOST_SRC}\n      DENO_ENV: development\n    volumes:\n      - ${LOCALHOST_SRC}/app:/app/app\n    command: ['npm', 'run', 'dev']\n```\n\n## Multiple Compose Configurations\n\nYou can define multiple compose setups for different purposes:\n\n```json\n{\n  \"compose\": {\n    \"app\": {\n      \"root\": \"local/app\",\n      \"filename\": \"compose.yaml\"\n    },\n    \"database\": {\n      \"root\": \"local/db\",\n      \"filename\": \"db-compose.yaml\"\n    },\n    \"full\": {\n      \"root\": \"local\",\n      \"filename\": \"full-stack.yaml\"\n    }\n  }\n}\n```\n\n## Integration with Docker Configuration\n\nCompose files reference Docker configurations from meta.json:\n\n```yaml\n# Compose references Docker image built from meta.json docker config\nservices:\n  app:\n    build:\n      context: ${SRC}/app                    # References docker.context_dir\n      dockerfile: ${SRC}/docker/Dockerfile.dev  # References docker.root + env file\n```\n\n## Common Patterns\n\n### Single Service Development\n```yaml\nservices:\n  app:\n    build:\n      context: ${SRC}/app\n      dockerfile: ${SRC}/docker/Dockerfile.dev\n    volumes:\n      - ${LOCALHOST_SRC}/app:/app/app\n    env_file:\n      - ${SRC}/.env.base\n      - ${SRC}/.env.local\n```\n\n### Multi-Service Development\n```yaml\nservices:\n  api:\n    build:\n      context: ${SRC}/services/api\n      dockerfile: ${SRC}/docker/api/Dockerfile.dev\n    volumes:\n      - ${LOCALHOST_SRC}/services/api:/app/api\n\n  worker:\n    build:\n      context: ${SRC}/services/worker\n      dockerfile: ${SRC}/docker/worker/Dockerfile.dev\n    volumes:\n      - ${LOCALHOST_SRC}/services/worker:/app/worker\n```\n\n### External Services Integration\n```yaml\nservices:\n  app:\n    build:\n      context: ${SRC}/app\n      dockerfile: ${SRC}/docker/Dockerfile.dev\n    depends_on:\n      - postgres\n      - redis\n\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_DB: ${DB_NAME}\n    volumes:\n      - ${LOCALHOST_SRC}/data/postgres:/var/lib/postgresql/data\n\n  redis:\n    image: redis:7-alpine\n```\n\n## Best Practices\n\n1. **Always use environment variables** for paths (`SRC`, `LOCALHOST_SRC`)\n2. **Use LOCALHOST_SRC for volume mounts** to ensure proper dev container operation\n3. **Reference environment files** with `${SRC}` prefix\n4. **Keep compose files in dedicated directories** (usually `local/`)\n5. **Use development-specific Dockerfiles** (e.g., `Dockerfile.dev`)\n6. **Mount source code for hot reload** during development\n\n## Integration with `run` Tool\n\nThe `run` tool uses compose configuration to:\n\n1. **Locate compose files**: Uses `root` property from meta.json\n2. **Set environment context**: Injects `SRC` and `LOCALHOST_SRC`\n3. **Load environment files**: Automatically references `.env.base` and `.env.local`\n4. **Orchestrate development**: Provides commands for dev environment management\n\n## Key Differences from Production\n\n| Aspect | Development (Compose) | Production (Terraform) |\n|--------|----------------------|------------------------|\n| **Purpose** | Local development | Cloud deployment |\n| **Environment** | Dev container | Google Cloud Run |\n| **Files** | `compose.yaml` | Terraform configs |\n| **Volumes** | Source code mounting | No direct mounting |\n| **Hot reload** | Enabled | Not applicable |\n\nThis development-focused approach enables rapid iteration while maintaining consistency with the production deployment architecture defined in Terraform configurations.",
        "plugins/system/skills/system/references/custom-scripts-guide.md": "# Custom Scripts Guide\n\n## Introduction\n\nCustom scripts are **TypeScript/Deno files** that provide reusable workflows for project-specific operations. They allow you to create complex, multi-step operations using the full power of TypeScript and access to `run` library utilities.\n\n## What Are Custom Scripts?\n\nCustom scripts are:\n- TypeScript files (`.ts`) executed by Deno runtime\n- Located in a directory defined in `meta.json`\n- Reusable workflows for development, deployment, testing, and maintenance\n- Composable operations combining `run` utilities with any Deno-compatible libraries\n\n**Key Difference from Routines:**\n- **Routines** = Simple shell command aliases\n- **Custom Scripts** = Full TypeScript programs with logic, conditionals, loops, error handling\n\n## meta.json Configuration\n\n**⚠️ ALWAYS fetch the schema first:**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n### Basic Configuration\n\n```json\n{\n  \"custom\": {\n    \"root\": \"scripts\"\n  }\n}\n```\n\n**Properties:**\n\n**`custom.root` (string)**\n- Directory containing `.ts` script files\n- Common values: `\"scripts\"`, `\"custom\"`, `\"workflows\"`\n- All `.ts` files in this directory become executable via `run custom <name>`\n\n**For complete `custom` property structure:** Fetch the schema\n\n## Script Structure\n\n### Required Structure\n\nEvery custom script must:\n1. Be a `.ts` file in the `custom.root` directory\n2. Export a default function\n3. Accept `CustomArgs` and `CustomOptions` parameters\n\n**Minimal Example:**\n\n```typescript\nimport type { CustomArgs, CustomOptions } from 'jsr:@ghostmind/run';\n\nexport default async function (args: CustomArgs, opts: CustomOptions) {\n  console.log('Custom script executed!');\n}\n```\n\n### Function Parameters\n\n**CustomArgs** - Array of positional arguments\n```typescript\n// Execution: run custom myscript arg1 arg2\nexport default async function (args: CustomArgs, opts: CustomOptions) {\n  console.log(args); // ['arg1', 'arg2']\n}\n```\n\n**CustomOptions** - Named flags via `has()` method\n```typescript\nexport default async function (args: CustomArgs, opts: CustomOptions) {\n  const { has } = opts;\n\n  if (has('build')) {\n    // Build logic\n  }\n\n  if (has('deploy')) {\n    // Deploy logic\n  }\n}\n```\n\n**Usage with flags:**\n```bash\nrun custom dev build deploy\n# has('build') = true\n# has('deploy') = true\n```\n\n## Available Utilities\n\nCustom scripts can import utilities from `jsr:@ghostmind/run`:\n\n```typescript\nimport {\n  dockerBuild,\n  dockerPush,\n  dockerComposeBuild,\n  dockerComposeUp,\n  terraformApply,\n} from 'jsr:@ghostmind/run';\n```\n\n**Note:** For the complete list of available functions, check the `@ghostmind/run` package or source code.\n\n## External Libraries\n\nCustom scripts can use any Deno-compatible library:\n\n**Shell commands with zx:**\n```typescript\nimport { $ } from 'npm:zx@8.1.3';\n\nexport default async function (args: CustomArgs, opts: CustomOptions) {\n  $.verbose = true;\n  await $`npm install`;\n  await $`npm run build`;\n}\n```\n\n**Node.js modules:**\n```typescript\nimport { readFile } from 'node:fs/promises';\n```\n\n**npm packages:**\n```typescript\nimport chalk from 'npm:chalk@5';\n```\n\n## Execution\n\n```bash\n# Execute script by name (without .ts extension)\nrun custom script-name\n\n# Execute with flags\nrun custom dev build up\n```\n\nThe script name matches the filename:\n- `scripts/dev.ts` → `run custom dev`\n- `scripts/deploy.ts` → `run custom deploy`\n- `scripts/migrate.ts` → `run custom migrate`\n\n## Simple Example\n\n**File:** `scripts/dev.ts`\n\n```typescript\nimport type { CustomArgs, CustomOptions } from 'jsr:@ghostmind/run';\nimport { dockerComposeBuild, dockerComposeUp } from 'jsr:@ghostmind/run';\n\nexport default async function (args: CustomArgs, opts: CustomOptions) {\n  const { has } = opts;\n\n  if (has('build')) {\n    await dockerComposeBuild({});\n  }\n\n  if (has('up')) {\n    await dockerComposeUp({ forceRecreate: true });\n  }\n}\n```\n\n**Usage:**\n```bash\nrun custom dev build up\n```\n\n## Integration with Routines\n\nCustom scripts work well with routines for frequently used workflows:\n\n**meta.json:**\n```json\n{\n  \"custom\": {\n    \"root\": \"scripts\"\n  },\n  \"routines\": {\n    \"dev\": \"run custom dev build up\",\n    \"deploy\": \"run custom deploy\"\n  }\n}\n```\n\n**Usage:**\n```bash\n# Via routine (short)\nrun routine dev\n\n# Direct custom script (explicit)\nrun custom dev build up\n```\n\n## When to Use Custom Scripts\n\n**Use custom scripts when:**\n- Complex multi-step workflows\n- Conditional logic needed (if/else, loops)\n- Error handling required\n- Combining multiple operations\n- Need full TypeScript/Deno capabilities\n\n**Use routines when:**\n- Simple command aliases\n- No logic needed\n- Just executing shell commands\n\n## Best Practices\n\n1. **Use type imports** for CustomArgs/CustomOptions\n2. **Use meaningful script names** (dev.ts, deploy.ts, migrate.ts)\n3. **Handle errors gracefully** with try/catch\n4. **Use flags** for optional steps (`has('build')`, `has('deploy')`)\n5. **Document complex scripts** with comments\n\n## Troubleshooting\n\n**Script not found:**\n```bash\n# Error: Script 'mysc' not found\n# Solution: Check spelling and file exists in custom.root directory\n```\n\n**Import errors:**\n```typescript\n// ❌ Wrong\nimport { something } from '@ghostmind/run';\n\n// ✅ Correct\nimport { something } from 'jsr:@ghostmind/run';\n```\n\n## Next Steps\n\n- **Understanding meta.json:** See `meta-json-guide.md`\n- **run CLI commands:** See `run-cli-overview.md`\n- **Routines vs Custom Scripts:** See `routines-guide.md`\n- **System overview:** See `system-overview.md`\n\n**Remember:** The majority of the time, you don't need to know the internal implementation of custom functions. Focus on understanding:\n1. How to configure `custom` in meta.json\n2. Basic script structure\n3. How to execute scripts with `run custom`\n",
        "plugins/system/skills/system/references/docker-overview.md": "# Docker Configuration Overview\n\n## Introduction\n\nThis document explains how Docker is configured and used within our system. Docker configurations are defined in the `meta.json` file and enable containerization for both development and production deployments.\n\n## Core Concept: Flexible Docker Setup\n\nDocker configurations in our system are:\n- **Location-flexible**: Dockerfile can be placed in any folder\n- **Registry-aware**: Image names include full container registry addresses\n- **Environment-specific**: Different Dockerfiles for development vs production\n- **Build-context aware**: Separation between Dockerfile location and build context\n\n## Docker Configuration in meta.json\n\n**⚠️ ALWAYS fetch the schema first:**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\nThe Docker configuration is defined under the `docker` property in `meta.json`:\n\n```json\n{\n  \"docker\": {\n    \"default\": {\n      \"root\": \"docker\",\n      \"image\": \"gcr.io/ghostmind-core/docs-mcp\",\n      \"env_based\": false,\n      \"context_dir\": \"app\"\n    }\n  }\n}\n```\n\n### Configuration Properties\n\n#### `root` (required)\n- **Purpose**: Specifies the directory where Dockerfile(s) are located\n- **Example**: `\"root\": \"docker\"`\n- **Result**: Dockerfiles are in `/path/to/project/docker/`\n\n#### `image` (required)\n- **Purpose**: Full image name including registry address\n- **Supported Registries**:\n  - GitHub Container Registry: `ghcr.io/organization/image-name`\n  - Google Cloud Registry: `gcr.io/project-id/image-name`\n- **Example**: `\"image\": \"gcr.io/ghostmind-core/docs-mcp\"`\n\n#### `env_based` (optional)\n- **Purpose**: Whether to use environment-specific Dockerfiles\n- **Values**: `true` or `false`\n- **When `false`**: Uses `Dockerfile` (default)\n- **When `true`**: Uses `Dockerfile.dev`, `Dockerfile.prod`, etc.\n\n#### `context_dir` (optional)\n- **Purpose**: Build context directory (relative to project root)\n- **Default**: Project root if not specified\n- **Example**: `\"context_dir\": \"app\"`\n- **Result**: Docker build runs from `/path/to/project/app/`\n\n#### `tag_modifiers` (optional)\n- **Purpose**: Additional tags to apply to the image\n- **Type**: Array of strings\n- **Example**: `\"tag_modifiers\": [\"latest\", \"v1.0.0\"]`\n\n**For complete `docker` property structure:** Fetch the schema\n\n## Multiple Docker Configurations\n\nYou can define multiple Docker configurations for different purposes:\n\n```json\n{\n  \"docker\": {\n    \"app\": {\n      \"root\": \"docker\",\n      \"image\": \"gcr.io/project/app\",\n      \"context_dir\": \"app\"\n    },\n    \"worker\": {\n      \"root\": \"docker/worker\",\n      \"image\": \"gcr.io/project/worker\",\n      \"context_dir\": \"worker\"\n    },\n    \"nginx\": {\n      \"root\": \"docker/nginx\",\n      \"image\": \"gcr.io/project/nginx\"\n    }\n  }\n}\n```\n\n## File Structure Examples\n\n### Basic Setup\n```\nproject/\n├── meta.json\n├── docker/\n│   └── Dockerfile\n└── app/\n    └── (application code)\n```\n\n### Environment-Specific Setup\n```\nproject/\n├── meta.json\n├── docker/\n│   ├── Dockerfile.dev\n│   └── Dockerfile.prod\n└── app/\n    └── (application code)\n```\n\n### Multi-Service Setup\n```\nproject/\n├── meta.json\n├── docker/\n│   ├── app/\n│   │   └── Dockerfile\n│   ├── worker/\n│   │   └── Dockerfile\n│   └── nginx/\n│       └── Dockerfile\n├── app/\n└── worker/\n```\n\n## Container Registry Integration\n\n### GitHub Container Registry\n- **Format**: `ghcr.io/username/repository-name`\n- **Authentication**: Uses `GITHUB_TOKEN`\n- **Example**: `\"image\": \"ghcr.io/ghostmind-dev/docs-mcp\"`\n\n### Google Cloud Registry\n- **Format**: `gcr.io/project-id/image-name`\n- **Authentication**: Uses Google Cloud credentials\n- **Example**: `\"image\": \"gcr.io/ghostmind-core/docs-mcp\"`\n\n## Build Process Integration\n\nThe `run` tool uses the Docker configuration to:\n\n1. **Locate Dockerfile**: Uses `root` property to find Dockerfile\n2. **Set build context**: Uses `context_dir` for Docker build context\n3. **Tag images**: Applies full registry path from `image` property\n4. **Handle environments**: Selects appropriate Dockerfile based on `env_based`\n\n## Integration with Other Components\n\n### Docker + Compose\nLocal development uses Docker images defined here:\n```json\n{\n  \"docker\": {\n    \"default\": { \"image\": \"gcr.io/project/app\" }\n  },\n  \"compose\": {\n    \"default\": { \"root\": \"local\" }\n  }\n}\n```\n\n### Docker + Terraform\nProduction deployment references Docker images:\n```json\n{\n  \"docker\": {\n    \"default\": { \"image\": \"gcr.io/project/app\" }\n  },\n  \"terraform\": {\n    \"run\": {\n      \"containers\": [\"default\"]\n    }\n  }\n}\n```\n\n## Best Practices\n\n1. **Use full registry paths** in image names for clarity\n2. **Separate Dockerfile location from build context** when needed\n3. **Use multiple configurations** for multi-service applications\n4. **Keep Dockerfiles in dedicated folders** for organization\n5. **Use environment-based Dockerfiles** for different deployment targets\n\n## Common Patterns\n\n### Single Application\n```json\n{\n  \"docker\": {\n    \"default\": {\n      \"root\": \"docker\",\n      \"image\": \"gcr.io/project/app\",\n      \"context_dir\": \"app\"\n    }\n  }\n}\n```\n\n### Microservices\n```json\n{\n  \"docker\": {\n    \"api\": {\n      \"root\": \"docker/api\",\n      \"image\": \"gcr.io/project/api\",\n      \"context_dir\": \"services/api\"\n    },\n    \"worker\": {\n      \"root\": \"docker/worker\",\n      \"image\": \"gcr.io/project/worker\",\n      \"context_dir\": \"services/worker\"\n    }\n  }\n}\n```\n\n### Development vs Production\n```json\n{\n  \"docker\": {\n    \"app\": {\n      \"root\": \"docker\",\n      \"image\": \"gcr.io/project/app\",\n      \"env_based\": true,\n      \"context_dir\": \"app\"\n    }\n  }\n}\n```\n\nThis configuration enables flexible, registry-aware Docker setups that integrate seamlessly with the broader system architecture.",
        "plugins/system/skills/system/references/mcp-configuration.md": "# MCP Configuration Guide\n\n## Introduction\n\nMCP (Model Context Protocol) servers provide specialized tools and knowledge to AI agents like Claude. The Ghostmind system allows you to configure **project-specific MCP servers** in `meta.json`, which are then used to generate `.mcp.json` files for MCP clients.\n\n## What is MCP?\n\nMCP servers extend AI agent capabilities by providing:\n- **Tools** - Functions the agent can call (e.g., query database, search documentation)\n- **Resources** - Information the agent can access (e.g., schemas, configurations)\n- **Prompts** - Specialized instructions for specific tasks\n\n**Project-Specific MCP:**\nThe MCP configuration in `meta.json` is for project-specific servers, not global ones.\n\n## meta.json Configuration\n\n**⚠️ ALWAYS fetch the schema first:**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n### Basic Configuration\n\n```json\n{\n  \"mcp\": {\n    \"server-name\": {\n      \"type\": \"http\",\n      \"url\": \"https://mcp.ghostmind.app\"\n    }\n  }\n}\n```\n\n**Structure:**\n\n**`mcp.<name>` (object)**\n- `<name>`: Server identifier (e.g., `tags-dev`, `system-local`)\n- Value: Server configuration object\n\n**For complete `mcp` property structure:** Fetch the schema\n\n## Server Types\n\n### HTTP Type\n\nFor remote MCP servers accessed via HTTP:\n\n```json\n{\n  \"mcp\": {\n    \"tags-dev\": {\n      \"type\": \"http\",\n      \"url\": \"https://mcp.ghostmind.app\"\n    }\n  }\n}\n```\n\n**Properties:**\n- `type`: `\"http\"`\n- `url`: Full URL to MCP server endpoint\n\n### Command Type\n\nFor local MCP servers executed as commands:\n\n```json\n{\n  \"mcp\": {\n    \"local-server\": {\n      \"type\": \"command\",\n      \"command\": \"node\",\n      \"args\": [\"server.js\"]\n    }\n  }\n}\n```\n\n**Properties:**\n- `type`: `\"command\"`\n- `command`: Executable command\n- `args`: Array of arguments\n\n### Command with Custom Script\n\n```json\n{\n  \"mcp\": {\n    \"system-local\": {\n      \"type\": \"command\",\n      \"command\": \"run\",\n      \"args\": [\"custom\", \"mcp-server\"]\n    }\n  }\n}\n```\n\nThis executes a custom script that starts the MCP server.\n\n## Workflow\n\n### 1. Define MCP Servers in meta.json\n\n```json\n{\n  \"mcp\": {\n    \"tags-dev\": {\n      \"type\": \"http\",\n      \"url\": \"https://mtl-mcp.ghostmind.app\"\n    },\n    \"system-dev\": {\n      \"type\": \"http\",\n      \"url\": \"https://mcp.ghostmind.app\"\n    }\n  }\n}\n```\n\n### 2. Generate .mcp.json\n\n```bash\n# Generate .mcp.json from all MCP configs\nrun mcp set --all\n\n# Generate specific MCP server config\nrun mcp set --name tags-dev\n```\n\n### 3. Use with MCP Client\n\nThe generated `.mcp.json` file is used by:\n- Claude Code\n- Other MCP-compatible clients\n- AI agents that support MCP\n\n## Multiple MCP Servers\n\nYou can define multiple MCP servers for different purposes:\n\n```json\n{\n  \"mcp\": {\n    \"database\": {\n      \"type\": \"http\",\n      \"url\": \"https://db-mcp.example.com\"\n    },\n    \"docs\": {\n      \"type\": \"http\",\n      \"url\": \"https://docs-mcp.example.com\"\n    },\n    \"local-tools\": {\n      \"type\": \"command\",\n      \"command\": \"node\",\n      \"args\": [\"tools/mcp-server.js\"]\n    }\n  }\n}\n```\n\n## Integration with Routines\n\nCommon pattern to set MCP configuration via routine:\n\n```json\n{\n  \"mcp\": {\n    \"tags-dev\": {\n      \"type\": \"http\",\n      \"url\": \"https://mcp.ghostmind.app\"\n    }\n  },\n  \"routines\": {\n    \"mcp_set\": \"run mcp set --all\",\n    \"setup\": \"run vault import && run routine mcp_set\"\n  }\n}\n```\n\n**Usage:**\n```bash\nrun routine mcp_set\n```\n\n## Real-World Examples\n\n### HTTP MCP Server\n\n```json\n{\n  \"mcp\": {\n    \"tags-dev\": {\n      \"type\": \"http\",\n      \"url\": \"https://mtl-mcp.ghostmind.app\"\n    }\n  }\n}\n```\n\n### Multiple Environment-Specific Servers\n\n```json\n{\n  \"mcp\": {\n    \"tags-dev\": {\n      \"type\": \"http\",\n      \"url\": \"https://dev-mcp.ghostmind.app\"\n    },\n    \"tags-prod\": {\n      \"type\": \"http\",\n      \"url\": \"https://prod-mcp.ghostmind.app\"\n    }\n  }\n}\n```\n\n### Mixed HTTP and Command\n\n```json\n{\n  \"mcp\": {\n    \"remote-tools\": {\n      \"type\": \"http\",\n      \"url\": \"https://mcp.example.com\"\n    },\n    \"local-server\": {\n      \"type\": \"command\",\n      \"command\": \"run\",\n      \"args\": [\"custom\", \"start-mcp\"]\n    }\n  }\n}\n```\n\n## When to Use MCP Configuration\n\n**Use MCP configuration when:**\n- Project needs access to project-specific tools\n- AI agent needs specialized knowledge for the project\n- Domain-specific operations required (database queries, API calls, etc.)\n\n**Common Use Cases:**\n- Database schema exploration\n- Documentation search\n- Project-specific utilities\n- API interaction tools\n- Custom development workflows\n\n## Best Practices\n\n### 1. Use Descriptive Server Names\n\n```json\n// ✅ Good - clear purpose\n{\n  \"mcp\": {\n    \"database-tools\": { ... },\n    \"docs-search\": { ... }\n  }\n}\n\n// ❌ Avoid - unclear\n{\n  \"mcp\": {\n    \"server1\": { ... },\n    \"mcp2\": { ... }\n  }\n}\n```\n\n### 2. Separate Dev and Prod Servers\n\n```json\n{\n  \"mcp\": {\n    \"tools-dev\": {\n      \"type\": \"http\",\n      \"url\": \"https://dev.example.com\"\n    },\n    \"tools-prod\": {\n      \"type\": \"http\",\n      \"url\": \"https://prod.example.com\"\n    }\n  }\n}\n```\n\n### 3. Use Routines for MCP Setup\n\n```json\n{\n  \"mcp\": { ... },\n  \"routines\": {\n    \"mcp_set\": \"run mcp set --all\",\n    \"setup\": \"run routine mcp_set\"\n  }\n}\n```\n\n### 4. Document Server Purpose\n\nAdd comments in documentation or README about what each MCP server provides.\n\n## Troubleshooting\n\n### .mcp.json not generated\n\n**Problem:** Running `run mcp set --all` but no `.mcp.json` created\n\n**Solution:** Verify `mcp` property exists in `meta.json` and has valid configuration\n\n### MCP server not accessible\n\n**Problem:** MCP client can't connect to server\n\n**Solution:**\n- Check URL is correct\n- Verify server is running (for command type)\n- Check network connectivity (for http type)\n\n### Wrong server configuration\n\n**Problem:** Generated `.mcp.json` has incorrect settings\n\n**Solution:** Update `meta.json` and run `run mcp set --all` again\n\n## Next Steps\n\n- **Understanding meta.json:** See `meta-json-guide.md`\n- **run CLI:** See `run-cli-overview.md`\n- **Routines:** See `routines-guide.md`\n- **System overview:** See `system-overview.md`\n\n**Remember:** MCP configuration in `meta.json` is for project-specific servers. Global MCP servers are configured separately in Claude Code settings.\n",
        "plugins/system/skills/system/references/meta-json-guide.md": "# meta.json Configuration Guide\n\n## Introduction\n\nThe `meta.json` file is the **central configuration** for every application in the Ghostmind system. It is the single source of truth that defines what components exist, how they're configured, and how the `run` tool orchestrates them.\n\n## ⚠️ CRITICAL: ALWAYS FETCH THE SCHEMA\n\n**This cannot be emphasized enough:**\n\n### Before ANY work with meta.json, ALWAYS fetch the latest schema:\n\n```\nSchema URL: https://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n**Why this is absolutely critical:**\n- The schema is the **only authoritative source** for all available properties\n- The schema is **actively maintained and updated**\n- Properties, structures, validation rules, and options **change over time**\n- Working without the latest schema **will lead to invalid configurations**\n- **No documentation can replace the schema** - it is always the source of truth\n\n**When to fetch (every time):**\n- Before creating a new meta.json\n- Before modifying an existing meta.json\n- Before documenting meta.json properties\n- Before troubleshooting configuration issues\n- **At the start of ANY task** involving the Ghostmind system\n- When in doubt about any property or structure\n\n**How to fetch:**\nUse WebFetch or similar tools to retrieve and examine the complete schema structure.\n\n## Core Required Properties\n\nEvery meta.json must have these three properties:\n\n```json\n{\n  \"id\": \"_kc2vvsMN7jU\",\n  \"name\": \"my-app\",\n  \"version\": \"0.0.1\"\n}\n```\n\n**`id` (string, required)**\n- Unique identifier\n- Generated once, never changes\n\n**`name` (string, required)**\n- Configuration name\n- Used to extract `PROJECT` and `APP` environment variables\n- Should be descriptive\n\n**`version` (string, required)**\n- Semantic version: \"major.minor.patch\"\n- Track configuration changes over time\n\n## Optional Core Metadata\n\n```json\n{\n  \"description\": \"Next.js UI with authentication\",\n  \"type\": \"app\",\n  \"global\": false,\n  \"tags\": [\"frontend\", \"oauth\"]\n}\n```\n\n**`description`** - Human-readable description\n\n**`type`** - Values: `\"app\"`, `\"project\"`, `\"template\"`\n\n**`global`** - Boolean for global/local scope\n\n**`tags`** - Array of strings for categorization\n\n## Configuration Components\n\nmeta.json can define configurations for:\n\n| Component   | Property     | Detailed Guide                |\n|-------------|--------------|-------------------------------|\n| Docker      | `docker`     | `docker-overview.md`          |\n| Compose     | `compose`    | `compose-overview.md`         |\n| Terraform   | `terraform`  | `terraform-overview.md`       |\n| Tmux        | `tmux`       | `tmux-guide.md`               |\n| Custom      | `custom`     | `custom-scripts-guide.md`     |\n| Routines    | `routines`   | `routines-guide.md`           |\n| MCP         | `mcp`        | `mcp-configuration.md`        |\n| Tunnel      | `tunnel`     | `tunnel-configuration.md`     |\n| Secrets     | `secrets`    | `system-overview.md`          |\n| Port        | `port`       | `system-overview.md`          |\n\n**⚠️ For detailed configuration of each component:**\n- **Fetch the schema** to see available properties\n- **Read the component's guide** for detailed documentation and examples\n- Each guide includes its own meta.json configuration section\n\n## Variable Substitution\n\nmeta.json supports variable substitution:\n\n```json\n{\n  \"name\": \"my-app\",\n  \"port\": 5001,\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"${PROJECT}.example.com\",\n      \"service\": \"http://localhost:${PORT}\"\n    }\n  }\n}\n```\n\nVariables available:\n- `${PORT}` - From `port` property\n- `${PROJECT}` - From root meta.json `name`\n- `${APP}` - From current directory meta.json `name`\n- Any variable from `.env` files\n\n**For details on variable substitution:** See `system-overview.md` (Environment Variables section)\n\n## Multi-meta.json Projects\n\nProjects can have multiple meta.json files:\n\n### Pattern 1: Root + App-Specific\n\n```\nmy-project/\n├── meta.json          # Root: global config (tmux, mcp)\n├── ui/\n│   └── meta.json      # UI: docker, compose, terraform\n└── api/\n    └── meta.json      # API: docker, compose, terraform\n```\n\n**Behavior:**\n- `PROJECT` extracted from root meta.json `name`\n- `APP` extracted from current directory meta.json `name`\n- Navigate to appropriate directory before running `run` commands\n\n### Pattern 2: Single Consolidated\n\n```\nmy-app/\n├── meta.json          # All configuration in one file\n├── app/\n├── docker/\n├── local/\n└── infra/\n```\n\n### Pattern 3: Config-Only (No App Code)\n\n```\ndatabase/\n├── meta.json          # Just infrastructure config\n└── infra/\n```\n\n**For details:** See `system-overview.md` (Project Structure Patterns section)\n\n## Component Configuration Overview\n\n**Each component has its own guide with detailed meta.json configuration:**\n\n### Docker (`docker` property)\n```json\n{\n  \"docker\": {\n    \"default\": {\n      \"root\": \"docker\",\n      \"image\": \"gcr.io/project/app\",\n      \"context_dir\": \"app\"\n    }\n  }\n}\n```\n**→ See `docker-overview.md` for complete configuration**\n\n### Compose (`compose` property)\n```json\n{\n  \"compose\": {\n    \"default\": {\n      \"root\": \"local\",\n      \"filename\": \"compose.yaml\"\n    }\n  }\n}\n```\n**→ See `compose-overview.md` for complete configuration**\n\n### Terraform (`terraform` property)\n```json\n{\n  \"terraform\": {\n    \"run\": {\n      \"path\": \"infra\",\n      \"containers\": [\"default\"]\n    }\n  }\n}\n```\n**→ See `terraform-overview.md` for complete configuration**\n\n### Tmux (`tmux` property)\n```json\n{\n  \"tmux\": {\n    \"sessions\": [\n      {\n        \"name\": \"session-name\",\n        \"windows\": [ ... ]\n      }\n    ]\n  }\n}\n```\n**→ See `tmux-guide.md` for complete configuration**\n\n### Custom Scripts (`custom` property)\n```json\n{\n  \"custom\": {\n    \"root\": \"scripts\"\n  }\n}\n```\n**→ See `custom-scripts-guide.md` for complete configuration**\n\n### Routines (`routines` property)\n```json\n{\n  \"routines\": {\n    \"dev\": \"run custom dev build up\",\n    \"deploy\": \"run docker build && run docker push\"\n  }\n}\n```\n**→ See `routines-guide.md` for complete configuration**\n\n### MCP (`mcp` property)\n```json\n{\n  \"mcp\": {\n    \"server-name\": {\n      \"type\": \"http\",\n      \"url\": \"https://mcp.example.com\"\n    }\n  }\n}\n```\n**→ See `mcp-configuration.md` for complete configuration**\n\n### Tunnel (`tunnel` property)\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"app.example.com\",\n      \"service\": \"http://localhost:5001\"\n    }\n  }\n}\n```\n**→ See `tunnel-configuration.md` for complete configuration**\n\n## Workflow: Creating a meta.json\n\n**1. Fetch the Schema (ALWAYS)**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n**2. Start with Required Properties**\n```json\n{\n  \"id\": \"unique-id\",\n  \"name\": \"my-app\",\n  \"version\": \"0.0.1\"\n}\n```\n\n**3. Add Components as Needed**\n\nFor each component you want to add:\n1. **Fetch the schema** again to see latest structure\n2. **Read the component's guide** (e.g., `docker-overview.md`)\n3. **Add the configuration** to meta.json\n4. **Test with `run` commands**\n\n**4. Validate**\n\nEnsure:\n- Required properties present\n- Referenced directories exist\n- Valid JSON syntax\n- Variable substitution uses correct format\n\n## Best Practices\n\n### 1. Always Fetch Schema First\n\nCannot be repeated enough - **fetch the schema before any meta.json work**.\n\n### 2. Start Minimal, Expand Incrementally\n\n```json\n// Start\n{\n  \"id\": \"abc\",\n  \"name\": \"app\",\n  \"version\": \"0.0.1\"\n}\n\n// Add components one at a time\n{\n  \"id\": \"abc\",\n  \"name\": \"app\",\n  \"version\": \"0.0.1\",\n  \"docker\": { ... }  // Added docker\n}\n```\n\n### 3. Read Component Guides for Details\n\nDon't guess at configuration - read the specific guide for each component.\n\n### 4. Use Variable Substitution\n\nAvoid hardcoding values that can be derived:\n\n```json\n// ✅ Good\n{\n  \"port\": 5001,\n  \"tunnel\": {\n    \"default\": {\n      \"service\": \"http://localhost:${PORT}\"\n    }\n  }\n}\n\n// ❌ Avoid\n{\n  \"port\": 5001,\n  \"tunnel\": {\n    \"default\": {\n      \"service\": \"http://localhost:5001\"\n    }\n  }\n}\n```\n\n### 5. Organize Multi-App Projects\n\nUse multiple meta.json files for complex projects:\n- Root meta.json: Global config (tmux, mcp)\n- App meta.json files: App-specific config (docker, compose, terraform)\n\n## Troubleshooting\n\n### \"Property not found in schema\"\n\n**Problem:** Using a property that doesn't exist\n\n**Solution:** Fetch the schema and verify the property exists and is spelled correctly\n\n### \"Invalid value for property\"\n\n**Problem:** Using wrong type or invalid value\n\n**Solution:** Fetch the schema to see valid types and enum values\n\n### \"Referenced directory doesn't exist\"\n\n**Problem:** Config references `\"root\": \"docker\"` but no `docker/` directory\n\n**Solution:** Create the directory or fix the path in meta.json\n\n### Always Out of Date?\n\n**Problem:** Documentation seems out of sync with schema\n\n**Solution:** The schema is the authority - always fetch it, documentation may lag behind\n\n## Next Steps\n\n**To understand the system:**\n- `system-overview.md` - Architecture and how components connect\n- `run-cli-overview.md` - How run commands work with meta.json\n\n**To configure specific components (each has meta.json config section):**\n- `docker-overview.md` - Docker images\n- `compose-overview.md` - Local development\n- `terraform-overview.md` - Infrastructure deployment\n- `tmux-guide.md` - Terminal layouts\n- `custom-scripts-guide.md` - TypeScript scripts\n- `routines-guide.md` - Command aliases\n- `mcp-configuration.md` - MCP servers\n- `tunnel-configuration.md` - Cloudflared tunnels\n\n**Remember: ALWAYS FETCH THE SCHEMA FIRST**\n\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n",
        "plugins/system/skills/system/references/routines-guide.md": "# Routines Guide\n\n## Introduction\n\nRoutines are **named shell command aliases** defined in `meta.json`. They provide quick access to frequently used commands through memorable names, eliminating the need to type long command sequences repeatedly.\n\n## What Are Routines?\n\nRoutines are:\n- Simple key-value pairs mapping names to shell commands\n- Defined in `meta.json` under the `routines` property\n- Executed via `run routine <name>`\n- Any valid shell command or combination of commands\n\n**Key Difference from Custom Scripts:**\n- **Routines** = Simple shell command aliases (no logic, no conditionals)\n- **Custom Scripts** = Full TypeScript programs with logic, loops, error handling\n\n## meta.json Configuration\n\n**⚠️ ALWAYS fetch the schema first:**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n### Basic Configuration\n\n```json\n{\n  \"routines\": {\n    \"dev\": \"run custom dev build up\",\n    \"deploy\": \"run docker build && run docker push && run terraform apply\",\n    \"tmux_init\": \"run tmux init session-name --all\",\n    \"logs\": \"run custom logs\"\n  }\n}\n```\n\n**Structure:**\n\n**`routines.<name>` (string)**\n- `<name>`: Memorable routine name (e.g., `dev`, `deploy`, `tmux_init`)\n- Value: Any shell command or command chain\n\n**For complete `routines` property structure:** Fetch the schema\n\n## Execution\n\n```bash\n# Execute routine by name\nrun routine <name>\n\n# Examples\nrun routine dev\nrun routine deploy\nrun routine tmux_init\n```\n\n## Common Patterns\n\n### Development Workflows\n\n```json\n{\n  \"routines\": {\n    \"dev\": \"run custom dev build up\",\n    \"dev_stop\": \"run compose down\"\n  }\n}\n```\n\n### Tmux Management\n\n```json\n{\n  \"routines\": {\n    \"tmux_init\": \"run tmux init session-name --all\",\n    \"tmux_attach\": \"run tmux attach session-name\",\n    \"tmux_start\": \"run tmux attach session-name --run-all\",\n    \"tmux_terminate\": \"run tmux terminate session-name\"\n  }\n}\n```\n\n### Deployment\n\n```json\n{\n  \"routines\": {\n    \"deploy\": \"run docker build && run docker push && run terraform apply\",\n    \"deploy_fast\": \"run docker push && run terraform apply\"\n  }\n}\n```\n\n### Tunnels and MCP\n\n```json\n{\n  \"routines\": {\n    \"tunnel_start\": \"run tunnel run --all --name project-tunnels\",\n    \"mcp_set\": \"run mcp set --all\"\n  }\n}\n```\n\n### Combined Commands\n\n```json\n{\n  \"routines\": {\n    \"setup\": \"run vault import && run tmux init app --all && run routine dev\"\n  }\n}\n```\n\n## Invoking Other run Commands\n\nRoutines can execute any `run` command:\n\n```json\n{\n  \"routines\": {\n    \"dev\": \"run custom dev build up\",           // Custom script\n    \"deploy\": \"run terraform apply\",            // Direct command\n    \"tunnel\": \"run tunnel run --name default\",  // Tunnel command\n    \"init\": \"run routine mcp_set && run routine dev\"  // Other routines\n  }\n}\n```\n\n## Chaining Commands\n\nUse shell operators to chain multiple commands:\n\n**Sequential (&&) - Stop on error:**\n```json\n{\n  \"routines\": {\n    \"deploy\": \"run docker build && run docker push && run terraform apply\"\n  }\n}\n```\n\n**Sequential (;) - Continue on error:**\n```json\n{\n  \"routines\": {\n    \"cleanup\": \"run compose down; run docker system prune -f\"\n  }\n}\n```\n\n**Parallel (&) - Run simultaneously:**\n```json\n{\n  \"routines\": {\n    \"dev_all\": \"run custom ui build up & run custom api build up\"\n  }\n}\n```\n\n## When to Use Routines\n\n**Use routines when:**\n- Simple command aliases needed\n- No logic or conditionals required\n- Frequently used command combinations\n- Quick access to common workflows\n\n**Use custom scripts when:**\n- Complex logic needed (if/else, loops)\n- Error handling required\n- Multiple steps with conditionals\n- Need TypeScript/Deno capabilities\n\n## Integration with Custom Scripts\n\nRoutines often invoke custom scripts for complex workflows:\n\n```json\n{\n  \"custom\": {\n    \"root\": \"scripts\"\n  },\n  \"routines\": {\n    \"dev\": \"run custom dev build up\",\n    \"deploy\": \"run custom deploy deploy check\",\n    \"migrate\": \"run custom migrate apply metadata\"\n  }\n}\n```\n\n**Benefits:**\n- **Routines** = Short, memorable names\n- **Custom Scripts** = Complex implementation\n\n## Real-World Examples\n\n### Full Development Setup\n\n```json\n{\n  \"routines\": {\n    \"dev\": \"run custom dev build up\",\n    \"dev_stop\": \"run compose down\",\n    \"dev_reset\": \"run compose down && run custom dev build up\"\n  }\n}\n```\n\n### Complete Deployment Pipeline\n\n```json\n{\n  \"routines\": {\n    \"deploy\": \"run docker build && run docker push && run terraform apply\",\n    \"deploy_rollback\": \"run terraform destroy && run terraform apply\"\n  }\n}\n```\n\n### Multi-App Project\n\n```json\n{\n  \"routines\": {\n    \"tmux_init\": \"run tmux init project --all\",\n    \"tmux_attach\": \"run tmux attach project\",\n    \"tmux_terminate\": \"run tmux terminate project\",\n    \"tunnels_start\": \"run tunnel run --all --name project\",\n    \"mcp_set\": \"run mcp set --all\"\n  }\n}\n```\n\n## Best Practices\n\n### 1. Use Descriptive Names\n\n```json\n// ✅ Good - clear purpose\n{\n  \"routines\": {\n    \"dev_start\": \"run custom dev build up\",\n    \"dev_stop\": \"run compose down\"\n  }\n}\n\n// ❌ Avoid - unclear\n{\n  \"routines\": {\n    \"d\": \"run custom dev build up\",\n    \"x\": \"run compose down\"\n  }\n}\n```\n\n### 2. Group Related Routines\n\n```json\n{\n  \"routines\": {\n    // Development\n    \"dev\": \"run custom dev build up\",\n    \"dev_stop\": \"run compose down\",\n\n    // Tmux\n    \"tmux_init\": \"run tmux init app --all\",\n    \"tmux_attach\": \"run tmux attach app\",\n\n    // Deployment\n    \"deploy\": \"run custom deploy\",\n    \"deploy_logs\": \"run custom logs\"\n  }\n}\n```\n\n### 3. Use && for Critical Sequences\n\n```json\n// ✅ Good - stops on error\n{\n  \"routines\": {\n    \"deploy\": \"run docker build && run docker push && run terraform apply\"\n  }\n}\n\n// ❌ Risky - continues on error\n{\n  \"routines\": {\n    \"deploy\": \"run docker build; run docker push; run terraform apply\"\n  }\n}\n```\n\n### 4. Keep Routines Simple\n\n```json\n// ✅ Good - simple alias\n{\n  \"routines\": {\n    \"dev\": \"run custom dev build up\"\n  }\n}\n\n// ❌ Too complex - use custom script instead\n{\n  \"routines\": {\n    \"dev\": \"if [ -f .env ]; then run vault import; fi && run custom dev build up && run tunnel run --name default\"\n  }\n}\n```\n\n### 5. Reference Other Routines When Useful\n\n```json\n{\n  \"routines\": {\n    \"dev\": \"run custom dev build up\",\n    \"tunnel\": \"run tunnel run --name default\",\n    \"full_dev\": \"run routine dev && run routine tunnel\"\n  }\n}\n```\n\n## Troubleshooting\n\n### \"Routine not found\"\n\n**Problem:** Running `run routine dev` but no `dev` routine exists\n\n**Solution:** Check `meta.json` routines property for correct name\n\n### Command fails silently\n\n**Problem:** Routine executes but doesn't stop on error\n\n**Solution:** Use `&&` instead of `;` to stop on first error\n\n### Variable substitution not working\n\n**Problem:** `${PORT}` in routine not expanding\n\n**Solution:** Environment variables in routines are evaluated by the shell, ensure they're exported\n\n## Next Steps\n\n- **Understanding meta.json:** See `meta-json-guide.md`\n- **Custom Scripts:** See `custom-scripts-guide.md`\n- **run CLI:** See `run-cli-overview.md`\n- **System overview:** See `system-overview.md`\n\n**Remember:** Routines are for simple aliases. For complex workflows with logic, use custom scripts.\n",
        "plugins/system/skills/system/references/run-cli-overview.md": "# run CLI Overview\n\n## What is `run`?\n\nThe `run` CLI is the **unified orchestrator** for all Ghostmind system operations. It reads `meta.json` to understand your application and provides commands for managing the entire development and deployment lifecycle.\n\n## Dual Nature\n\n**`run` is available in two forms:**\n\n**1. CLI Tool**\n```bash\nrun docker build\nrun compose up\nrun terraform apply\nrun custom dev build up\n```\n\n**2. Deno TypeScript Library**\n```typescript\nimport { dockerBuild, dockerComposeUp } from 'jsr:@ghostmind/run';\n\nawait dockerBuild({ name: 'default' });\nawait dockerComposeUp({ forceRecreate: true });\n```\n\n## Critical Requirement: meta.json\n\n**⚠️ Most `run` operations require `meta.json`:**\n- Commands must be executed from the directory containing the relevant `meta.json`\n- The tool reads `meta.json` to understand your application structure\n- For multi-meta.json projects, navigate to the appropriate directory first\n\n## Command Categories\n\nThe `run` tool provides commands for:\n\n| Category    | Purpose                                    | Example                    |\n|-------------|--------------------------------------------|----------------------------|\n| **docker**  | Build and push production images           | `run docker build`         |\n| **compose** | Manage local development with Docker Compose | `run compose up`          |\n| **terraform** | Deploy infrastructure to cloud            | `run terraform apply`      |\n| **tmux**    | Initialize terminal session layouts        | `run tmux init session`    |\n| **mcp**     | Configure MCP servers                      | `run mcp set --all`        |\n| **tunnel**  | Expose local servers via Cloudflared       | `run tunnel run --name default` |\n| **vault**   | Import/export secrets from Vault           | `run vault import`         |\n| **custom**  | Execute TypeScript/Deno scripts            | `run custom dev build up`  |\n| **routine** | Execute named shell command aliases        | `run routine dev_start`    |\n\n## How It Works\n\n**1. Reads meta.json**\n```json\n{\n  \"name\": \"my-app\",\n  \"docker\": { ... },\n  \"compose\": { ... },\n  \"routines\": { ... }\n}\n```\n\n**2. Executes Operations**\n- `run docker build` → Reads `docker` config from meta.json\n- `run compose up` → Reads `compose` config from meta.json\n- `run routine dev` → Executes shell command from `routines` config\n\n**3. Manages Environment**\n- Loads `.env.base` and environment-specific `.env` files\n- Resolves variable substitution (`${PORT}`, `${PROJECT}`)\n- Extracts `PROJECT` and `APP` from meta.json\n\n## Common Workflows\n\n**Development:**\n```bash\nrun vault import              # Get secrets\nrun tmux init app --all       # Setup terminal\nrun routine dev_start         # Start services\nrun tunnel run --name default # Expose locally\n```\n\n**Deployment:**\n```bash\nrun docker build    # Build image\nrun docker push     # Push to registry\nrun terraform apply # Deploy infrastructure\n```\n\n**Custom Workflows:**\n```bash\nrun custom dev build up        # Custom development script\nrun custom deploy deploy check # Custom deployment script\nrun custom migrate apply       # Custom migration script\n```\n\n## When to Use What\n\n**Custom Scripts** - Complex workflows with logic, loops, error handling\n\n**Routines** - Simple shell command aliases\n\n**Direct Commands** - One-off operations\n\n## Environment Variables\n\nThe `run` tool automatically:\n- Loads `.env` files based on environment\n- Resolves variable substitution in .env files\n- Extracts `PROJECT` from root meta.json `name`\n- Extracts `APP` from current directory meta.json `name`\n\n## Best Practices\n\n1. **Navigate to correct directory** before running commands\n2. **Use routines** for frequently used command combinations\n3. **Use custom scripts** for complex multi-step workflows\n4. **Check meta.json** has required configuration before running commands\n\n## Next Steps\n\n**Understanding the system:**\n- `system-overview.md` - System architecture and concepts\n- `meta-json-guide.md` - Complete meta.json documentation\n\n**Using specific features:**\n- `custom-scripts-guide.md` - TypeScript/Deno workflows\n- `docker-overview.md` - Docker configuration\n- `compose-overview.md` - Local development\n- `terraform-overview.md` - Infrastructure deployment\n- `tmux-guide.md` - Terminal layouts\n- `routines-guide.md` - Command aliases\n- `mcp-configuration.md` - MCP servers\n- `tunnel-configuration.md` - Cloudflared tunnels\n",
        "plugins/system/skills/system/references/system-overview.md": "# System Overview\n\n## Introduction\n\nThe Ghostmind development system is a configuration-driven workflow where **meta.json serves as the central configuration** that defines and orchestrates all application components. This document provides a comprehensive overview of the system architecture, development environment, and how components interconnect.\n\n## Core Principle: Everything Starts with `meta.json`\n\nThe `meta.json` file is the **foundation of every application** in the Ghostmind system. It acts as the single source of truth that:\n\n- Defines what components exist in the application\n- Links different parts together (app code, Docker, Compose, Terraform, Tmux)\n- Configures development tools (MCP, tunnels, routines, custom scripts)\n- Enables the `run` tool to understand and orchestrate the application\n- Allows dynamic behavior through variable substitution\n\n**Key insight:** An application can exist with just a `meta.json` file. All other components (Docker, Compose, Terraform, etc.) are optional and only defined when needed.\n\n**Flexibility:** The structure is not prescriptive. `meta.json` describes where things are and how they're configured, not enforcing rigid folder structures or naming conventions. A project can have one meta.json at the root, or multiple meta.json files for different apps within the project.\n\n### CRITICAL: Always Fetch the Schema\n\n**⚠️ IMPERATIVE RULE: Before working with meta.json configuration or understanding the system, ALWAYS fetch the latest schema:**\n\n```\nSchema URL: https://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n**Why this is critical:**\n- The schema is the **authoritative source** for all available meta.json properties\n- The schema is actively maintained and updated\n- Properties, structures, and validation rules may change\n- Working without the latest schema can lead to invalid configurations\n\n**When to fetch:**\n- Before creating or modifying meta.json files\n- When documenting the system\n- When troubleshooting configuration issues\n- At the start of any task involving the Ghostmind system\n\n**How to fetch:**\nUse WebFetch or similar tools to retrieve the schema and understand the complete structure before proceeding with any configuration work.\n\n## System Architecture\n\n### GitHub Organization Structure\n\nAll Ghostmind system repositories are hosted in the GitHub organization:\n- **Organization**: https://github.com/orgs/ghostmind-dev/repositories\n\n**Key Repositories:**\n\n1. **container** (https://github.com/ghostmind-dev/container)\n   - Base Docker image for devcontainers\n   - Dockerfile: https://raw.githubusercontent.com/ghostmind-dev/container/refs/heads/main/container/Dockerfile.base\n   - Pre-configured development environment used by 95% of projects\n\n2. **config** (https://github.com/ghostmind-dev/config)\n   - Miscellaneous configuration files (.gitignore, vscode settings, etc.)\n   - Devcontainer features that complement the main devcontainer\n   - Initialization configurations\n\n3. **init** (https://github.com/ghostmind-dev/init)\n   - Initialization scripts that run on devcontainer startup\n   - Performs maintenance tasks: login to GCP, install run CLI, login to vault, etc.\n   - Devcontainer feature to enable/disable init actions\n\n4. **play** (https://github.com/ghostmind-dev/play)\n   - Collection of custom GitHub Actions\n   - Currently used for deployment workflows\n\n5. **run** (https://github.com/ghostmind-dev/run)\n   - Core CLI tool and Deno TypeScript library\n   - Orchestrates all system operations\n   - meta.json schema: https://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n\n## Development Environment\n\n### Devcontainer Workflow\n\n**95% of projects are developed in VS Code Dev Containers**, providing:\n\n- Pre-configured development environment from the container repository\n- Consistent tooling across all team members\n- Automatic integration with system utilities\n- Access to critical environment variables\n- Seamless Docker-in-Docker operations\n\n**Exceptions:** Projects requiring native OS access are developed outside of devcontainers.\n\n### Devcontainer Configuration\n\nThe devcontainer is configured through `.devcontainer/devcontainer.json` with special environment variables:\n\n```json\n{\n  \"containerEnv\": {\n    \"LOCALHOST_SRC\": \"${localWorkspaceFolder}\",\n    \"SRC\": \"${containerWorkspaceFolder}\"\n  }\n}\n```\n\n**Features Integration:**\n- Devcontainer features from the **config** repository provide additional tooling\n- Devcontainer features from the **init** repository enable startup automation\n\n### Critical Environment Variables: `SRC` and `LOCALHOST_SRC`\n\n**These are fundamental to the entire system and used heavily throughout applications:**\n\n**`SRC`** - Root path inside the dev container\n- Example: `/workspaces/project-name/`\n- Used for all operations within the dev container\n- References to files and folders when working inside the container\n\n**`LOCALHOST_SRC`** - Host machine path to the same location\n- Example: `/Users/developer/projects/project-name/`\n- **Critical for Docker-in-Docker operations**\n- Required when mounting volumes from within the devcontainer\n\n### Why Both Are Essential\n\nWhen running **Docker from within the dev container** (Docker-in-Docker):\n- Container paths (`SRC`) do NOT work for volume mounting\n- Docker daemon runs on the host and needs **host paths** (`LOCALHOST_SRC`)\n- This enables hot-reload in local development with Docker Compose\n\n**Example scenario:**\n```yaml\n# In compose.yaml - CORRECT usage\nservices:\n  app:\n    volumes:\n      - ${LOCALHOST_SRC}/ui/app:/app/app  # ✅ Host path for mounting\n    environment:\n      LOCALHOST_SRC: ${LOCALHOST_SRC}     # ✅ Pass to container\n```\n\n```bash\n# Inside dev container - WRONG vs RIGHT\n❌ docker run -v $SRC/data:/app/data image        # Container path - won't mount\n✅ docker run -v $LOCALHOST_SRC/data:/app/data image  # Host path - works\n```\n\nThis dual-path system enables seamless Docker operations while maintaining the dev container workflow.\n\n## Environment Variables and Secrets Management\n\n### Environment File Structure\n\nEnvironment variables are managed through layered `.env` files:\n\n**File Types:**\n- **`.env.base`** (or `.env.common`) - Shared across all environments (local, dev, prod)\n- **`.env.local`** - Local development specific\n- **`.env.dev`** - Development environment specific (optional)\n- **`.env.prod`** - Production specific (optional)\n\n**Configurable Base Name:**\nThe base environment file extension can be configured in `meta.json`:\n```json\n{\n  \"secrets\": {\n    \"base\": \"common\"  // Uses .env.common instead of .env.base\n  }\n}\n```\n\n### Variable Substitution in .env Files\n\nEnvironment files support **variable substitution**, allowing dynamic values:\n\n**Example .env.base:**\n```bash\nPORT=5001\nAPP=\"ui\"\n```\n\n**Example .env.local:**\n```bash\nENVIRONMENT=local\nSERVER_URL=http://localhost:${PORT}         # References PORT from .env.base\nDB_ENDPOINT=\"http://host.docker.internal:5080/v1/graphql\"\nTUNNEL_NAME=\"ghostmind.app\"\nNEXTAUTH_URL=\"https://${TUNNEL_NAME}\"       # Dynamic substitution\n```\n\nThe `run` tool automatically resolves these references when loading environment variables.\n\n### Automatic Variable Extraction from meta.json\n\nTwo special variables are **automatically extracted** from `meta.json` if not explicitly defined in `.env` files:\n\n**`PROJECT`** - Extracted from the `name` property in the **root** meta.json\n```json\n// Root meta.json\n{\n  \"name\": \"mtl\",  // PROJECT = \"mtl\"\n  ...\n}\n```\n\n**`APP`** - Extracted from the `name` property in the meta.json **where the command is run**\n```json\n// /city/meta.json\n{\n  \"name\": \"city\",  // APP = \"city\" when run from /city/\n  ...\n}\n```\n\n**Behavior when run from root:**\nIf run from the root directory and neither PROJECT nor APP is defined in `.env` files, both will have the same value (the root project name).\n\n### Vault Integration for Secrets\n\n**Vault wrapper** (built into the `run` command) manages sensitive secrets:\n\n**How it works:**\n- Secrets are stored in Vault (HashiCorp Vault or similar)\n- `.env` files are stored in Vault, NOT in version control\n- The `run` tool provides import/export functionality\n\n**Commands:**\n```bash\n# Import secrets from Vault to local .env files\nrun vault import\n\n# Export local .env files to Vault\nrun vault export\n```\n\n**Workflow:**\n1. Secrets stored centrally in Vault\n2. Developers import secrets locally when needed\n3. Never commit `.env` files to Git\n4. Update Vault when secrets change\n\n## The `run` Tool\n\nThe `run` tool is the **unified orchestrator** for all system operations.\n\n### Dual Nature: CLI and Library\n\n**Available in two forms:**\n1. **CLI tool** - Command-line interface for terminal operations\n2. **Deno TypeScript library** - Importable functions for custom scripts (`jsr:@ghostmind/run`)\n\n**Example CLI usage:**\n```bash\nrun docker build\nrun compose up\nrun terraform apply\nrun tmux init session-name\nrun routine dev_start\nrun custom dev build up\n```\n\n**Example library usage (in custom scripts):**\n```typescript\nimport { dockerComposeBuild, dockerComposeUp } from 'jsr:@ghostmind/run';\n\nawait dockerComposeBuild({});\nawait dockerComposeUp({ forceRecreate: true });\n```\n\n### meta.json Dependency\n\n**Most operations require `meta.json`:**\n- The `run` tool reads `meta.json` to understand the application structure\n- Commands should be executed from the directory containing the relevant `meta.json`\n- For multi-meta.json projects, navigate to the appropriate directory before running commands\n\n**Example:**\n```bash\n# For a project with multiple apps\n/project/\n  ├── meta.json           # Root project config\n  ├── ui/\n  │   └── meta.json       # UI app config\n  └── api/\n      └── meta.json       # API app config\n\n# Run UI-specific commands from ui/\ncd /project/ui\nrun custom dev up\n\n# Run API-specific commands from api/\ncd /project/api\nrun custom dev up\n```\n\n### Core Capabilities\n\nThe `run` tool provides utilities for:\n\n- **Docker**: Build and push container images\n- **Compose**: Manage local development environments\n- **Terraform**: Deploy infrastructure to cloud\n- **Tmux**: Initialize and manage terminal sessions\n- **MCP**: Configure Model Context Protocol servers\n- **Tunnel**: Set up Cloudflared tunnels\n- **Vault**: Import/export secrets\n- **Custom**: Execute custom TypeScript scripts\n- **Routine**: Run named shell commands\n- **Environment**: Automatic variable injection and substitution\n\n## System Components\n\n### 1. Application Code (`app/`)\n\n**Purpose:** Contains the actual source code of your application\n\n**What it can be:** Node.js, Go, Python, Rust, or any application type\n\n**In meta.json:** Not explicitly configured - it's the default working directory where the application code lives\n\n**Flexibility:** The `app/` directory is a convention, not a requirement. Application code can be in any structure.\n\n### 2. Containerization (`docker/`)\n\n**Purpose:** Defines how to package the application into Docker images for production deployment\n\n**Contains:** Dockerfile(s) for building container images\n\n**In meta.json:** Configured under the `docker` property:\n```json\n{\n  \"docker\": {\n    \"default\": {\n      \"root\": \"docker\",\n      \"image\": \"gcr.io/ghostmind-core/my-app\",\n      \"env_based\": false,\n      \"context_dir\": \"app\"\n    }\n  }\n}\n```\n\n**Key features:**\n- Multiple image definitions possible (default, dev, test, etc.)\n- Build context typically points to `app/`\n- Image name and registry configuration\n- Tag modifiers for versioning\n\n**Separation from Compose:**\n- Docker config is for **production** images\n- Compose config (below) is for **local development**\n- They operate independently\n\n### 3. Local Development (`local/` or `compose/`)\n\n**Purpose:** Enables local development with Docker Compose and hot-reload\n\n**Contains:** `compose.yaml` defining services, volumes, networks\n\n**Critical:** Only used for **development**, never for production deployment\n\n**In meta.json:** Configured under the `compose` property:\n```json\n{\n  \"compose\": {\n    \"default\": {\n      \"root\": \"local\",\n      \"filename\": \"compose.yaml\"\n    }\n  }\n}\n```\n\n**Hot-reload pattern:**\n```yaml\nservices:\n  app:\n    volumes:\n      - ${LOCALHOST_SRC}/ui/app:/app/app  # Enables hot-reload\n    environment:\n      LOCALHOST_SRC: ${LOCALHOST_SRC}     # Pass host path to container\n```\n\nThe `LOCALHOST_SRC` mounting is essential for hot-reload to work in the devcontainer workflow.\n\n### 4. Infrastructure Deployment (`infra/`)\n\n**Purpose:** Infrastructure-as-Code using Terraform for cloud deployment\n\n**Target:** Currently optimized for **Google Cloud Run**\n\n**Contains:** Terraform configuration files\n\n**In meta.json:** Configured under the `terraform` property:\n```json\n{\n  \"terraform\": {\n    \"run\": {\n      \"path\": \"infra\",\n      \"global\": false,\n      \"containers\": [\"default\"]\n    }\n  }\n}\n```\n\n**Required file structure:**\n- `backend.tf` - Terraform state backend\n- `versions.tf` - Provider versions\n- `main.tf` - Main infrastructure resources\n- `variables.tf` - Variable definitions (auto-generated from .env files)\n\nThe `containers` array references Docker images defined in the `docker` section, enabling automated deployments with freshly built images.\n\n### 5. Custom Scripts (`scripts/`)\n\n**Purpose:** TypeScript/Deno scripts for complex, reusable workflows\n\n**Contains:** `.ts` files that export a default function\n\n**In meta.json:** Configured under the `custom` property:\n```json\n{\n  \"custom\": {\n    \"root\": \"scripts\"\n  }\n}\n```\n\n**Script structure:**\n```typescript\nimport type { CustomArgs, CustomOptions } from 'jsr:@ghostmind/run';\nimport { dockerComposeBuild, dockerComposeUp } from 'jsr:@ghostmind/run';\n\nexport default async function (args: CustomArgs, opts: CustomOptions) {\n  if (opts.has('build')) {\n    await dockerComposeBuild({});\n  }\n  if (opts.has('up')) {\n    await dockerComposeUp({ forceRecreate: true });\n  }\n}\n```\n\n**Execution:**\n```bash\nrun custom dev build up  # Runs scripts/dev.ts with 'build' and 'up' flags\n```\n\nCustom scripts are the most powerful feature for creating project-specific workflows.\n\n### 6. Routines (Named Shell Commands)\n\n**Purpose:** Quick access to frequently used commands through memorable names\n\n**In meta.json:** Configured under the `routines` property:\n```json\n{\n  \"routines\": {\n    \"dev_start\": \"run custom dev build up\",\n    \"tmux_init\": \"run tmux init mtl --all\",\n    \"tunnel_run\": \"run tunnel run --all --name mtl\"\n  }\n}\n```\n\n**Execution:**\n```bash\nrun routine dev_start   # Executes \"run custom dev build up\"\nrun routine tmux_init   # Executes \"run tmux init mtl --all\"\n```\n\nRoutines are simple shell command aliases stored in configuration.\n\n### 7. MCP (Model Context Protocol)\n\n**Purpose:** Configure project-specific MCP servers for AI agent integration\n\n**In meta.json:** Configured under the `mcp` property:\n```json\n{\n  \"mcp\": {\n    \"tags-dev\": {\n      \"type\": \"http\",\n      \"url\": \"https://mcp.ghostmind.app\"\n    }\n  }\n}\n```\n\n**Workflow:**\n1. Define MCP servers in `meta.json`\n2. Run `run mcp set --all` to generate `.mcp.json`\n3. The `.mcp.json` file is used by Claude Code or other MCP clients\n\nMCP servers provide domain-specific tools and knowledge to AI agents.\n\n### 8. Tunnel (Cloudflared Tunnels)\n\n**Purpose:** Expose local development servers through public URLs via Cloudflare\n\n**In meta.json:** Configured under the `tunnel` property:\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"ghostmind.app\",\n      \"service\": \"http://localhost:5001\"\n    }\n  }\n}\n```\n\n**Execution:**\n```bash\nrun tunnel run --name default  # Starts tunnel for local:5001 → ghostmind.app\n```\n\nTunnels enable OAuth callbacks, webhook testing, and sharing local development environments.\n\n### 9. Tmux (Terminal Multiplexer)\n\n**Purpose:** Configure tmux session layouts with windows and panes for development workflows\n\n**In meta.json:** Configured under the `tmux` property:\n```json\n{\n  \"tmux\": {\n    \"sessions\": [\n      {\n        \"name\": \"mtl\",\n        \"windows\": [\n          {\n            \"name\": \"server\",\n            \"layout\": \"compact\",\n            \"compact\": {\n              \"type\": \"main-side\",\n              \"panes\": {\n                \"main\": \"run custom dev build up\",\n                \"execution-shell\": \"echo 'Ready'\"\n              }\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n**Features:**\n- Multiple sessions, windows, and panes\n- Three layout modes: sections (hierarchical), grid (predefined), compact (key-value)\n- Automatic command execution on pane creation\n- Support for SSH targets and custom paths\n\n**Execution:**\n```bash\nrun tmux init mtl --all      # Initialize session with all windows\nrun tmux attach mtl          # Attach to session\nrun tmux terminate mtl       # Terminate session\n```\n\nTmux configurations enable complex, reproducible development environments.\n\n## How Components Connect\n\n```\nmeta.json (Central Configuration)\n    │\n    ├── Application Architecture\n    │   ├── app/ (Source Code)\n    │   ├── docker/ (Production Images)\n    │   ├── local/ (Dev Environment with Compose)\n    │   └── infra/ (Cloud Infrastructure with Terraform)\n    │\n    ├── Development Tools\n    │   ├── scripts/ (Custom TypeScript Scripts)\n    │   ├── routines (Named Shell Commands)\n    │   └── tmux (Terminal Session Layouts)\n    │\n    ├── Integration Services\n    │   ├── mcp (AI Agent Tooling)\n    │   └── tunnel (Public URL Exposure)\n    │\n    └── Configuration\n        ├── secrets (.env files + Vault)\n        ├── port (Application Port)\n        └── tags (Metadata)\n```\n\n**Flow:**\n1. `meta.json` defines what exists and how it's configured\n2. Environment variables (`.env` + vault) provide runtime configuration\n3. `run` tool orchestrates operations based on `meta.json`\n4. Components operate independently but reference each other through configuration\n\n## Project Structure Patterns\n\n### Single-App Project\n\n```\nmy-app/\n├── meta.json              # Single configuration\n├── app/                   # Application code\n├── docker/\n│   └── Dockerfile\n├── local/\n│   └── compose.yaml\n├── infra/\n│   └── *.tf\n├── scripts/\n│   └── dev.ts\n├── .env.base\n└── .env.local\n```\n\n### Multi-App Project\n\n```\nmy-project/\n├── meta.json              # Root project configuration\n├── ui/\n│   ├── meta.json          # UI app configuration\n│   ├── app/\n│   ├── docker/\n│   ├── local/\n│   ├── infra/\n│   ├── scripts/\n│   ├── .env.base\n│   └── .env.local\n├── api/\n│   ├── meta.json          # API app configuration\n│   ├── app/\n│   ├── docker/\n│   ├── local/\n│   ├── infra/\n│   ├── scripts/\n│   ├── .env.base\n│   └── .env.local\n└── db/\n    ├── meta.json          # DB configuration (no app code)\n    ├── infra/\n    ├── .env.base\n    └── .env.local\n```\n\n**Flexibility:**\n- Each app has its own `meta.json` and configuration\n- Not all apps need all components (e.g., db might only have infra/)\n- Run commands from the appropriate directory\n\n### Config-Only Project\n\n```\ndatabase/\n├── meta.json              # Just configuration\n├── infra/\n│   └── *.tf\n├── .env.base\n└── .env.prod\n```\n\nSome projects (like managed databases) only need infrastructure configuration with no application code.\n\n## Development Workflow\n\n### Typical Development Lifecycle\n\n1. **Initialize Environment**\n   - Open project in VS Code Dev Container\n   - Devcontainer auto-runs init scripts (GCP login, vault login, install tools)\n   - Import secrets: `run vault import`\n\n2. **Start Local Development**\n   - Initialize tmux layout: `run routine tmux_init`\n   - Start services: `run routine dev_start` (typically runs custom script)\n   - Start tunnel: `run routine tunnel_run` (if needed for OAuth/webhooks)\n\n3. **Development**\n   - Code in `app/` directory\n   - Changes hot-reload via Docker Compose volume mounts (`LOCALHOST_SRC`)\n   - Use execution-shell panes in tmux for commands\n\n4. **Build and Deploy**\n   - Build Docker image: `run docker build`\n   - Push to registry: `run docker push`\n   - Deploy infrastructure: `run terraform apply`\n\n5. **Shutdown**\n   - Terminate tmux: `run routine tmux_terminate`\n   - Services stop automatically\n\n## Key Principles\n\n### Configuration-Driven Development\n\nThe system is designed around **configuration over convention**:\n- `meta.json` is the single source of truth\n- Structure is flexible, not prescriptive\n- Components are loosely coupled through configuration\n- The `run` tool orchestrates everything based on configuration\n\n### Incremental Modularity\n\nNot all applications need all components:\n- Start with just `meta.json`\n- Add components as needed (Docker → Compose → Terraform)\n- Each component is independent and optional\n- Structure adapts to application needs\n\n### Developer Experience\n\nThe system prioritizes developer productivity:\n- Consistent tooling across all projects via devcontainers\n- Hot-reload for rapid iteration\n- Reusable workflows through custom scripts and routines\n- Automated secrets management\n- Terminal multiplexing for complex workflows\n\n### Security\n\nSecrets are never committed to version control:\n- `.env` files managed through Vault\n- Import/export workflow for local development\n- Separation of base config (`.env.base`) and environment-specific secrets\n\n## Next Steps\n\nTo dive deeper into specific components:\n\n- **meta.json structure**: See `meta-json-guide.md`\n- **run CLI tool**: See `run-cli-overview.md`\n- **Custom scripts**: See `custom-scripts-guide.md`\n- **Docker configuration**: See `docker-overview.md`\n- **Compose setup**: See `compose-overview.md`\n- **Terraform deployment**: See `terraform-overview.md`\n- **Tmux layouts**: See `tmux-guide.md`\n- **MCP configuration**: See `mcp-configuration.md`\n- **Routines**: See `routines-guide.md`\n- **Tunnel setup**: See `tunnel-configuration.md`\n\nEach guide builds on the concepts introduced in this overview.\n",
        "plugins/system/skills/system/references/terraform-overview.md": "# Terraform Infrastructure Overview\n\n## Introduction\n\nThis document explains how Terraform is configured and used within Ghostmind's development system for **production deployments**. Terraform handles Infrastructure-as-Code for Google Cloud Platform deployments, particularly Google Cloud Run services.\n\n## Core Concept: Production Infrastructure-as-Code\n\nTerraform in Ghostmind's system:\n- **Production deployments** - Used for deploying to Google Cloud Platform\n- **Google Cloud Run focused** - Optimized for serverless container deployments\n- **Meta.json configured** - Infrastructure location and container references defined centrally\n- **Standardized structure** - Consistent file organization across all projects\n\n## Terraform Configuration in meta.json\n\n**⚠️ ALWAYS fetch the schema first:**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\nThe Terraform configuration is defined under the `terraform` property in `meta.json`:\n\n```json\n{\n  \"terraform\": {\n    \"run\": {\n      \"path\": \"infra\",\n      \"global\": false,\n      \"containers\": [\"default\"]\n    }\n  }\n}\n```\n\n### Configuration Properties\n\n#### `path` (required)\n- **Purpose**: Specifies the directory where Terraform files are located\n- **Example**: `\"path\": \"infra\"`\n- **Result**: Terraform files are in `/path/to/project/infra/`\n- **Common values**: `\"infra\"`, `\"terraform\"`, `\"infrastructure\"`\n\n#### `global` (optional)\n- **Purpose**: Flag to indicate if the configuration is global scope\n- **Default**: `false`\n- **Values**: `true` or `false`\n\n#### `containers` (required)\n- **Purpose**: List of Docker container configurations to deploy\n- **Example**: `[\"default\"]` references the \"default\" docker configuration from meta.json\n- **Multiple containers**: `[\"api\", \"worker\", \"nginx\"]` for multi-service deployments\n\n**For complete `terraform` property structure:** Fetch the schema\n\n## Required Terraform File Structure\n\nGhostmind's Terraform setup **always requires** these specific files:\n\n### 1. `backend.tf` (Required)\n**Purpose**: Defines Terraform state backend using Google Cloud Storage\n\n```hcl\nterraform {\n  backend \"gcs\" {}\n}\n```\n\n**Key points:**\n- **Always use `backend \"gcs\"`** for Google Cloud Storage state management\n- Configuration details provided via backend config during initialization\n- Enables team collaboration and state locking\n\n### 2. `versions.tf` (Required)\n**Purpose**: Specifies Terraform and provider version requirements\n\n```hcl\nterraform {\n  required_providers {\n    google = {\n      source = \"hashicorp/google\"\n    }\n  }\n  required_version = \">= 1.3.7\"\n}\n```\n\n**Current version**: `>= 1.3.7`\n**Note**: This version requirement should be updated when Terraform versions change\n\n### 3. `variables.tf` (Auto-generated)\n**Purpose**: Defines input variables for the Terraform configuration\n**Important**: This file is **automatically generated** by tooling - do not create manually\n\n### 4. `main.tf` (Required)\n**Purpose**: Contains the main infrastructure resources\n\n## Standard main.tf Structure\n\nBased on the current Google Cloud Run deployment pattern:\n\n```hcl\nprovider \"google\" {\n  project = var.GCP_PROJECT_ID\n}\n\nresource \"google_cloud_run_v2_service\" \"default\" {\n  name     = \"${var.PROJECT}-${var.ENVIRONMENT}-${var.APP}\"\n  location = \"us-central1\"\n\n  deletion_protection = false\n\n  template {\n    scaling {\n      min_instance_count = 0\n      max_instance_count = 1\n    }\n\n    containers {\n      image = var.IMAGE_DIGEST_DEFAULT\n\n      resources {\n        limits = {\n          cpu    = \"2000m\"\n          memory = \"4Gi\"\n        }\n        cpu_idle          = true\n        startup_cpu_boost = false\n      }\n\n      ports {\n        container_port = var.PORT\n      }\n\n      # Dynamic environment variables\n      dynamic \"env\" {\n        for_each = local.env_vars\n        content {\n          name  = env.value.name\n          value = env.value.value\n        }\n      }\n    }\n  }\n}\n\n# IAM configuration for public access\ndata \"google_iam_policy\" \"noauth\" {\n  binding {\n    role    = \"roles/run.invoker\"\n    members = [\"allUsers\"]\n  }\n}\n\nresource \"google_cloud_run_service_iam_policy\" \"noauth\" {\n  location = google_cloud_run_v2_service.default.location\n  project  = google_cloud_run_v2_service.default.project\n  service  = google_cloud_run_v2_service.default.name\n\n  policy_data = data.google_iam_policy.noauth.policy_data\n}\n```\n\n## Available Variables\n\nThe following variables are automatically available through the tooling:\n\n### Core Variables\n- **`GCP_PROJECT_ID`** - Google Cloud Project ID\n- **`PROJECT`** - Project name from meta.json\n- **`ENVIRONMENT`** - Deployment environment (dev, staging, prod)\n- **`APP`** - Application name from meta.json\n\n### Container Variables\n- **`IMAGE_DIGEST_DEFAULT`** - Docker image digest for the \"default\" container\n- **`PORT`** - Application port number\n\n### Dynamic Environment Variables\n- **`local.env_vars`** - Auto-generated from environment configuration\n\n## Integration with Docker Configuration\n\nTerraform deployments reference Docker images defined in meta.json:\n\n```json\n{\n  \"docker\": {\n    \"default\": {\n      \"image\": \"gcr.io/project/app\"\n    }\n  },\n  \"terraform\": {\n    \"run\": {\n      \"containers\": [\"default\"]\n    }\n  }\n}\n```\n\nThe `containers` array links to Docker configurations:\n- `\"default\"` → uses `docker.default.image`\n- `\"api\"` → uses `docker.api.image`\n\n## Multi-Container Deployments\n\nFor applications with multiple services:\n\n### meta.json Configuration\n```json\n{\n  \"docker\": {\n    \"api\": {\n      \"image\": \"gcr.io/project/api\"\n    },\n    \"worker\": {\n      \"image\": \"gcr.io/project/worker\"\n    }\n  },\n  \"terraform\": {\n    \"run\": {\n      \"containers\": [\"api\", \"worker\"]\n    }\n  }\n}\n```\n\n### Terraform Variables Available\n- `var.IMAGE_DIGEST_API`\n- `var.IMAGE_DIGEST_WORKER`\n\n## File Organization Example\n\n```\nproject/\n├── meta.json\n├── infra/                    # Terraform directory\n│   ├── backend.tf           # ✅ Required: GCS backend\n│   ├── versions.tf          # ✅ Required: Version constraints\n│   ├── variables.tf         # ✅ Auto-generated by tooling\n│   ├── main.tf              # ✅ Required: Main resources\n│   └── .terraform.lock.hcl  # Generated by terraform init\n```\n\n## Current Status: Work in Progress\n\n**Important Note**: The Terraform automation is currently **work in progress**. While the structure and patterns are established, the tooling for automation may evolve.\n\n**Current approach**:\n- Manual Terraform configuration based on templates\n- Standardized file structure requirements\n- Integration with Docker image references from meta.json\n\n**Future considerations**:\n- Enhanced automation through tooling\n- Template generation based on meta.json configuration\n- Simplified deployment workflows\n\n## Best Practices\n\n1. **Always include required files**: `backend.tf`, `versions.tf`, `main.tf`\n2. **Use GCS backend** for state management\n3. **Reference Docker containers** via meta.json `containers` array\n4. **Follow naming conventions**: `${var.PROJECT}-${var.ENVIRONMENT}-${var.APP}`\n5. **Keep versions up to date**: Currently using Terraform >= 1.3.7\n6. **Let tooling generate variables.tf** - don't create manually\n\n## Integration with Deployment Workflow\n\n1. **Development**: Docker Compose (local development only)\n2. **Production**: Terraform + Google Cloud Run\n3. **Container Images**: Built from Docker configurations\n4. **State Management**: Google Cloud Storage backend\n5. **Environment Variables**: Injected via dynamic configuration\n\nThis infrastructure setup enables consistent, reproducible deployments while maintaining the flexibility to adapt to different application architectures within Ghostmind's development workflow.",
        "plugins/system/skills/system/references/tmux-sections-guide.md": "# Tmux Layout Guide\n\n## Introduction\n\nTmux layouts in the Ghostmind system are configured in `meta.json` and provide reproducible terminal session configurations for development workflows.\n\n**⚠️ ALWAYS fetch the schema first:**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n**For complete `tmux` property structure:** Fetch the schema\n\nThe **Tmux Layout System** provides three powerful ways to create tmux layouts:\n\n1. **Compact Layout** - Minimal object-based configuration (recommended for most use cases)\n2. **Grid Layout** - Simplified predefined arrangements\n3. **Section Layout** - Hierarchical configuration for complex custom layouts\n\n## Path Configuration\n\nYou can configure working directories at multiple levels with automatic inheritance and override:\n\n### Path Resolution Rules\n\n1. **Absolute paths** (starting with `/`) are used as-is\n2. **Relative paths** are resolved relative to their parent:\n   - Pane paths are relative to window path (or session root if no window path)\n   - Window paths are relative to session root\n3. **Child paths override parent paths** (pane path > window path > session root)\n\n### Examples\n\n```json\n{\n  \"tmux\": {\n    \"sessions\": [{\n      \"name\": \"dev\",\n      \"root\": \"projects/myapp\",  // Session root\n      \"windows\": [{\n        \"name\": \"backend\",\n        \"path\": \"api\",            // Relative to session root: projects/myapp/api\n        \"layout\": \"compact\",\n        \"compact\": {\n          \"type\": \"vertical\",\n          \"panes\": {\n            \"server\": \"npm start\",     // Runs in: projects/myapp/api\n            \"tests\": \"npm test\"        // Runs in: projects/myapp/api\n          }\n        }\n      }, {\n        \"name\": \"frontend\",\n        \"path\": \"/home/user/frontend\",  // Absolute path\n        \"layout\": \"compact\",\n        \"compact\": {\n          \"type\": \"vertical\",\n          \"panes\": {\n            \"dev\": \"npm run dev\",      // Runs in: /home/user/frontend\n            \"build\": \"npm run build\"   // Runs in: /home/user/frontend\n          }\n        }\n      }]\n    }]\n  }\n}\n```\n\n## Compact Layout (Recommended)\n\nCompact layouts provide the simplest, most readable configuration format. Define your panes as key-value pairs where the key is the pane name and the value is the command - that's it!\n\n### Available Grid Types\n\n- **`single`** - Single pane (1 pane)\n- **`vertical`** - Two panes split left/right (2 panes)\n- **`horizontal`** - Two panes split top/bottom (2 panes)\n- **`two-by-two`** - Four panes in 2x2 grid (4 panes)\n- **`main-side`** - One large pane (66%) on left, two stacked panes (34%) on right (3 panes)\n\n### Basic Compact Structure\n\n```json\n{\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"vertical\",\n    \"panes\": {\n      \"editor\": \"nvim\",\n      \"terminal\": \"npm run dev\"\n    }\n  }\n}\n```\n\n### Key Features\n\n- **Ultra-minimal syntax**: Just name and command\n- **Pane names become titles**: Automatically used as tmux pane titles\n- **Auto-fill support**: Missing panes are auto-generated\n- **Predictable order**: Panes fill from top-left to bottom-right\n- **Window-level path support**: Set `path` at window level to control starting directory for all panes\n\n**Note**: Compact layout doesn't support pane-level paths since panes are simple name:command pairs. Use Grid or Section layout if you need per-pane path control.\n\n### Pane Ordering\n\nPanes are created in this order for each grid type:\n\n- **`two-by-two`**: Top-left → Top-right → Bottom-left → Bottom-right\n- **`main-side`**: Main (left) → Top-right → Bottom-right\n- **`vertical`**: Left → Right\n- **`horizontal`**: Top → Bottom\n\n### Auto-Fill Behavior\n\nIf you define fewer panes than the grid type expects:\n\n- Missing panes are auto-created with names like `pane-0`, `pane-1`, etc.\n- You'll see a warning showing how many panes were auto-filled\n\nIf you define more panes than the grid type expects:\n\n- Only the first N panes are used (where N = expected count)\n- You'll see a warning about extra panes being ignored\n\n### Compact Layout Examples\n\n#### Single Pane\n\n```json\n{\n  \"name\": \"main-window\",\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"single\",\n    \"panes\": {\n      \"terminal\": \"bash\"\n    }\n  }\n}\n```\n\n#### Vertical Split (Side-by-Side)\n\n```json\n{\n  \"name\": \"dev-window\",\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"vertical\",\n    \"panes\": {\n      \"editor\": \"nvim\",\n      \"terminal\": \"npm run dev\"\n    }\n  }\n}\n```\n\nWith window-level path:\n\n```json\n{\n  \"name\": \"dev-window\",\n  \"path\": \"src\",              // All panes start in src/\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"vertical\",\n    \"panes\": {\n      \"editor\": \"nvim\",       // Runs in: src/\n      \"terminal\": \"npm run dev\"  // Runs in: src/\n    }\n  }\n}\n```\n\n#### Horizontal Split (Top/Bottom)\n\n```json\n{\n  \"name\": \"logs-window\",\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"horizontal\",\n    \"panes\": {\n      \"app-logs\": \"tail -f logs/app.log\",\n      \"error-logs\": \"tail -f logs/error.log\"\n    }\n  }\n}\n```\n\n#### Two-by-Two Grid\n\n```json\n{\n  \"name\": \"monitoring\",\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"two-by-two\",\n    \"panes\": {\n      \"top-left\": \"htop\",\n      \"top-right\": \"docker stats\",\n      \"bottom-left\": \"tail -f logs/access.log\",\n      \"bottom-right\": \"tail -f logs/error.log\"\n    }\n  }\n}\n```\n\nLayout:\n\n```\n┌─────────────┬─────────────┐\n│  top-left   │  top-right  │\n│             │             │\n├─────────────┼─────────────┤\n│ bottom-left │bottom-right │\n│             │             │\n└─────────────┴─────────────┘\n```\n\n#### Main-Side Layout\n\n```json\n{\n  \"name\": \"ide-window\",\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"main-side\",\n    \"panes\": {\n      \"editor\": \"nvim\",\n      \"terminal\": \"bash\",\n      \"logs\": \"tail -f logs/dev.log\"\n    }\n  }\n}\n```\n\nLayout:\n\n```\n┌──────────────────┬──────────┐\n│                  │ terminal │\n│                  ├──────────┤\n│     editor       │   logs   │\n│                  │          │\n└──────────────────┴──────────┘\n```\n\n#### Execution Shell Pattern (Common for AI Assistance)\n\n```json\n{\n  \"name\": \"server\",\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"main-side\",\n    \"panes\": {\n      \"nodejs\": \"run custom dev build up\",\n      \"tunnel\": \"run tunnel run\",\n      \"execution-shell\": \"echo Ready for commands\"\n    }\n  }\n}\n```\n\nThe `execution-shell` pane is left empty (just echoes a message) so AI assistants can use it for running commands without interrupting long-running processes.\n\n#### Auto-Fill Example\n\n```json\n{\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"two-by-two\",\n    \"panes\": {\n      \"api\": \"npm start\",\n      \"db\": \"docker-compose up\"\n      // Auto-fills pane-2 and pane-3\n    }\n  }\n}\n```\n\n---\n\n## Grid Layout\n\nGrid layouts provide predefined, easy-to-use window arrangements with more control than compact layouts. Choose a grid type and define your panes with full pane objects - the system handles all the splitting logic automatically.\n\n### Available Grid Types\n\n- **`single`** - Single pane (1 pane)\n- **`vertical`** - Two panes split left/right (2 panes)\n- **`horizontal`** - Two panes split top/bottom (2 panes)\n- **`two-by-two`** - Four panes in 2x2 grid (4 panes)\n- **`main-side`** - One large pane (66%) on left, two stacked panes (34%) on right (3 panes)\n\n### Basic Grid Structure\n\n```json\n{\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"vertical\",\n    \"panes\": [\n      {\n        \"name\": \"left\",\n        \"command\": \"nvim\"\n      },\n      {\n        \"name\": \"right\",\n        \"command\": \"npm run dev\"\n      }\n    ]\n  }\n}\n```\n\nGrid layouts also support **window-level and pane-level paths**:\n\n```json\n{\n  \"name\": \"dev-window\",\n  \"path\": \"src\",              // All panes start in src/ by default\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"vertical\",\n    \"panes\": [\n      {\n        \"name\": \"editor\",\n        \"command\": \"nvim\"       // Runs in: src/\n      },\n      {\n        \"name\": \"tests\",\n        \"path\": \"tests\",        // Overrides: src/tests/\n        \"command\": \"npm test\"\n      }\n    ]\n  }\n}\n```\n\n### Auto-Fill Feature\n\nGrid layouts support **auto-fill** - you don't need to define all panes. Missing panes are automatically created with default names (`pane-0`, `pane-1`, etc.).\n\n```json\n{\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"two-by-two\",\n    \"panes\": [\n      {\n        \"name\": \"api\",\n        \"command\": \"npm start\"\n      },\n      {\n        \"name\": \"db\",\n        \"command\": \"docker-compose up\"\n      }\n      // Auto-fills pane-2 and pane-3\n    ]\n  }\n}\n```\n\n### Grid Layout Examples\n\n#### Single Pane\n\n```json\n{\n  \"name\": \"main-window\",\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"single\",\n    \"panes\": [\n      {\n        \"name\": \"terminal\"\n      }\n    ]\n  }\n}\n```\n\n#### Vertical Split (Side-by-Side)\n\n```json\n{\n  \"name\": \"dev-window\",\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"vertical\",\n    \"panes\": [\n      {\n        \"name\": \"editor\",\n        \"command\": \"nvim\"\n      },\n      {\n        \"name\": \"terminal\",\n        \"command\": \"npm run dev\"\n      }\n    ]\n  }\n}\n```\n\n#### Horizontal Split (Top/Bottom)\n\n```json\n{\n  \"name\": \"logs-window\",\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"horizontal\",\n    \"panes\": [\n      {\n        \"name\": \"app-logs\",\n        \"command\": \"tail -f logs/app.log\"\n      },\n      {\n        \"name\": \"error-logs\",\n        \"command\": \"tail -f logs/error.log\"\n      }\n    ]\n  }\n}\n```\n\n#### Two-by-Two Grid\n\n```json\n{\n  \"name\": \"monitoring\",\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"two-by-two\",\n    \"panes\": [\n      {\n        \"name\": \"top-left\",\n        \"command\": \"htop\"\n      },\n      {\n        \"name\": \"top-right\",\n        \"command\": \"docker stats\"\n      },\n      {\n        \"name\": \"bottom-left\",\n        \"command\": \"tail -f logs/access.log\"\n      },\n      {\n        \"name\": \"bottom-right\",\n        \"command\": \"tail -f logs/error.log\"\n      }\n    ]\n  }\n}\n```\n\nLayout:\n\n```\n┌─────────────┬─────────────┐\n│  top-left   │  top-right  │\n│             │             │\n├─────────────┼─────────────┤\n│ bottom-left │bottom-right │\n│             │             │\n└─────────────┴─────────────┘\n```\n\n#### Main-Side Layout\n\n```json\n{\n  \"name\": \"ide-window\",\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"main-side\",\n    \"panes\": [\n      {\n        \"name\": \"editor\",\n        \"command\": \"nvim\"\n      },\n      {\n        \"name\": \"terminal\",\n        \"command\": \"bash\"\n      },\n      {\n        \"name\": \"logs\",\n        \"command\": \"tail -f logs/dev.log\"\n      }\n    ]\n  }\n}\n```\n\nLayout:\n\n```\n┌──────────────────┬──────────┐\n│                  │ terminal │\n│                  ├──────────┤\n│     editor       │   logs   │\n│                  │          │\n└──────────────────┴──────────┘\n```\n\n---\n\n## Section Layout (Advanced)\n\nThe **Section Layout System** provides an intuitive and powerful way to create complex custom tmux layouts using hierarchical configuration. Think of it as building blocks where you define how to split space and what goes in each section.\n\n## Core Concepts\n\n### Sections\n\nA **section** defines how to split space and contains **items**. Every section has:\n\n- `split`: Direction to split (`\"horizontal\"` or `\"vertical\"`)\n- `items`: Array of panes or nested sections\n- `size`: Optional size specification (e.g., `\"50%\"`, `\"30\"`)\n\n### Items\n\n**Items** are what go inside sections. They can be:\n\n- **Panes**: Terminal windows with commands\n- **Sections**: Nested sections with their own split and items\n\n## Basic Structure\n\n```json\n{\n  \"layout\": \"sections\",\n  \"section\": {\n    \"split\": \"vertical\",\n    \"items\": [\n      {\n        \"name\": \"left-pane\",\n        \"command\": \"echo 'Left Side'\",\n        \"size\": \"30%\"\n      },\n      {\n        \"name\": \"right-pane\",\n        \"command\": \"echo 'Right Side'\",\n        \"size\": \"70%\"\n      }\n    ]\n  }\n}\n```\n\n**Required Properties:**\n\n- `layout`: Must be `\"sections\"`\n- `section`: The root section defining your layout\n\n## Split Directions\n\n- **`\"vertical\"`**: Split left/right (creates columns)\n- **`\"horizontal\"`**: Split top/bottom (creates rows)\n\n## Pane Configuration\n\nEach pane supports:\n\n```json\n{\n  \"name\": \"unique-pane-name\",\n  \"command\": \"echo 'Hello World'\",\n  \"path\": \"relative/path/or/absolute\",\n  \"sshTarget\": \"user@hostname\",\n  \"size\": \"50%\"\n}\n```\n\n### Properties\n\n- **`name`** (required): Unique identifier for the pane\n- **`command`**: Command to execute when pane starts\n- **`path`**: Starting directory. If starts with `/`, treated as absolute. Otherwise, relative to window path (or session root if no window path). **Overrides window-level path.**\n- **`sshTarget`**: SSH target for remote execution\n- **`size`**: Size of this pane within its parent section\n\n### Path Override Example\n\n```json\n{\n  \"tmux\": {\n    \"sessions\": [{\n      \"name\": \"dev\",\n      \"root\": \"/workspace\",\n      \"windows\": [{\n        \"name\": \"mixed-paths\",\n        \"path\": \"backend\",           // Window default: /workspace/backend\n        \"layout\": \"sections\",\n        \"section\": {\n          \"split\": \"vertical\",\n          \"items\": [{\n            \"name\": \"api\",\n            \"command\": \"npm start\"   // Uses window path: /workspace/backend\n          }, {\n            \"name\": \"scripts\",\n            \"path\": \"scripts\",       // Relative to window: /workspace/backend/scripts\n            \"command\": \"bash\"\n          }, {\n            \"name\": \"logs\",\n            \"path\": \"/var/log/app\", // Absolute path overrides everything\n            \"command\": \"tail -f app.log\"\n          }]\n        }\n      }]\n    }]\n  }\n}\n```\n\n## Size Specifications\n\nSizes can be specified as:\n\n- **Percentage**: `\"50%\"`, `\"33%\"`, `\"25%\"`\n- **Absolute**: `\"30\"`, `\"20\"` (tmux units)\n\n**Important**: Sizes should add up to 100% within each section for best results.\n\n## Layout Examples\n\n### Simple Two-Pane Split\n\n```json\n{\n  \"layout\": \"sections\",\n  \"section\": {\n    \"split\": \"vertical\",\n    \"items\": [\n      {\n        \"name\": \"editor\",\n        \"command\": \"nvim\",\n        \"size\": \"70%\"\n      },\n      {\n        \"name\": \"terminal\",\n        \"command\": \"bash\",\n        \"size\": \"30%\"\n      }\n    ]\n  }\n}\n```\n\n### Three-Pane Horizontal Stack\n\n```json\n{\n  \"layout\": \"sections\",\n  \"section\": {\n    \"split\": \"horizontal\",\n    \"items\": [\n      {\n        \"name\": \"top\",\n        \"command\": \"htop\",\n        \"size\": \"33%\"\n      },\n      {\n        \"name\": \"middle\",\n        \"command\": \"tail -f /var/log/app.log\",\n        \"size\": \"33%\"\n      },\n      {\n        \"name\": \"bottom\",\n        \"command\": \"bash\",\n        \"size\": \"34%\"\n      }\n    ]\n  }\n}\n```\n\n### Nested Sections Example\n\n```json\n{\n  \"layout\": \"sections\",\n  \"section\": {\n    \"split\": \"vertical\",\n    \"items\": [\n      {\n        \"name\": \"sidebar\",\n        \"command\": \"ranger\",\n        \"size\": \"25%\"\n      },\n      {\n        \"split\": \"horizontal\",\n        \"size\": \"75%\",\n        \"items\": [\n          {\n            \"name\": \"editor\",\n            \"command\": \"nvim\",\n            \"size\": \"70%\"\n          },\n          {\n            \"split\": \"vertical\",\n            \"size\": \"30%\",\n            \"items\": [\n              {\n                \"name\": \"terminal\",\n                \"command\": \"bash\",\n                \"size\": \"50%\"\n              },\n              {\n                \"name\": \"logs\",\n                \"command\": \"tail -f logs/app.log\",\n                \"size\": \"50%\"\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nThis creates:\n\n```\n┌─────────┬───────────────────────────┐\n│         │                           │\n│ sidebar │         editor            │\n│         │                           │\n│         ├─────────────┬─────────────┤\n│         │   terminal  │    logs     │\n│         │             │             │\n└─────────┴─────────────┴─────────────┘\n```\n\n### IDE-Style Layout\n\n```json\n{\n  \"layout\": \"sections\",\n  \"section\": {\n    \"split\": \"horizontal\",\n    \"items\": [\n      {\n        \"split\": \"vertical\",\n        \"size\": \"80%\",\n        \"items\": [\n          {\n            \"name\": \"file-explorer\",\n            \"command\": \"ranger\",\n            \"size\": \"20%\"\n          },\n          {\n            \"name\": \"editor\",\n            \"command\": \"nvim .\",\n            \"size\": \"60%\"\n          },\n          {\n            \"name\": \"preview\",\n            \"command\": \"echo 'Preview Pane'\",\n            \"size\": \"20%\"\n          }\n        ]\n      },\n      {\n        \"split\": \"vertical\",\n        \"size\": \"20%\",\n        \"items\": [\n          {\n            \"name\": \"terminal\",\n            \"command\": \"bash\",\n            \"size\": \"50%\"\n          },\n          {\n            \"name\": \"logs\",\n            \"command\": \"tail -f logs/development.log\",\n            \"size\": \"50%\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Development Environment\n\n```json\n{\n  \"layout\": \"sections\",\n  \"section\": {\n    \"split\": \"vertical\",\n    \"items\": [\n      {\n        \"split\": \"horizontal\",\n        \"size\": \"70%\",\n        \"items\": [\n          {\n            \"name\": \"editor\",\n            \"command\": \"nvim\",\n            \"path\": \"src\",\n            \"size\": \"70%\"\n          },\n          {\n            \"split\": \"vertical\",\n            \"size\": \"30%\",\n            \"items\": [\n              {\n                \"name\": \"server\",\n                \"command\": \"npm run dev\",\n                \"size\": \"50%\"\n              },\n              {\n                \"name\": \"tests\",\n                \"command\": \"npm run test:watch\",\n                \"size\": \"50%\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"split\": \"horizontal\",\n        \"size\": \"30%\",\n        \"items\": [\n          {\n            \"name\": \"git\",\n            \"command\": \"git status\",\n            \"size\": \"50%\"\n          },\n          {\n            \"name\": \"terminal\",\n            \"command\": \"bash\",\n            \"size\": \"50%\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n## Remote Development with SSH\n\n```json\n{\n  \"layout\": \"sections\",\n  \"section\": {\n    \"split\": \"vertical\",\n    \"items\": [\n      {\n        \"name\": \"local-terminal\",\n        \"command\": \"bash\",\n        \"size\": \"50%\"\n      },\n      {\n        \"split\": \"horizontal\",\n        \"size\": \"50%\",\n        \"items\": [\n          {\n            \"name\": \"remote-editor\",\n            \"command\": \"nvim\",\n            \"sshTarget\": \"user@server.com\",\n            \"path\": \"/var/www/app\",\n            \"size\": \"70%\"\n          },\n          {\n            \"name\": \"remote-logs\",\n            \"command\": \"tail -f /var/log/nginx/access.log\",\n            \"sshTarget\": \"user@server.com\",\n            \"size\": \"30%\"\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n## Design Principles\n\n### 1. Hierarchical Thinking\n\nStructure your layout like a tree:\n\n- Root section defines the main split\n- Each item can be a pane (leaf) or another section (branch)\n- Nest as deeply as needed\n\n### 2. Size Planning\n\n- Start with major sections (e.g., 70% editor, 30% tools)\n- Then subdivide sections as needed\n- Ensure sizes add up to 100% in each section\n\n### 3. Logical Grouping\n\n- Group related functionality in the same section\n- Use nested sections to create zones\n- Keep frequently used panes easily accessible\n\n## Common Patterns\n\n### Two-Column Layout\n\n```json\n{\n  \"split\": \"vertical\",\n  \"items\": [\n    { \"name\": \"left\", \"size\": \"50%\" },\n    { \"name\": \"right\", \"size\": \"50%\" }\n  ]\n}\n```\n\n### Three-Row Layout\n\n```json\n{\n  \"split\": \"horizontal\",\n  \"items\": [\n    { \"name\": \"top\", \"size\": \"33%\" },\n    { \"name\": \"middle\", \"size\": \"33%\" },\n    { \"name\": \"bottom\", \"size\": \"34%\" }\n  ]\n}\n```\n\n### Sidebar + Main Area\n\n```json\n{\n  \"split\": \"vertical\",\n  \"items\": [\n    { \"name\": \"sidebar\", \"size\": \"25%\" },\n    { \"name\": \"main\", \"size\": \"75%\" }\n  ]\n}\n```\n\n### Header + Body + Footer\n\n```json\n{\n  \"split\": \"horizontal\",\n  \"items\": [\n    { \"name\": \"header\", \"size\": \"10%\" },\n    { \"name\": \"body\", \"size\": \"80%\" },\n    { \"name\": \"footer\", \"size\": \"10%\" }\n  ]\n}\n```\n\n## Best Practices\n\n1. **Start Simple**: Begin with basic splits, then add complexity\n2. **Use Meaningful Names**: Make pane names descriptive\n3. **Plan Your Sizes**: Sketch the layout before coding\n4. **Test Iteratively**: Use `tmux init <session>` to test changes\n5. **Consider Workflows**: Design around how you actually work\n6. **Document Complex Layouts**: Add comments explaining the structure\n\n## Troubleshooting\n\n### Layout Not As Expected\n\n- Check that splits are correct (`horizontal` vs `vertical`)\n- Verify sizes add up to 100%\n- Ensure proper nesting structure\n\n### Panes Too Small\n\n- Adjust size percentages\n- Consider removing nested levels\n- Test on target terminal size\n\n### Commands Not Running\n\n- Check `command` syntax\n- Verify `path` exists\n- Test `sshTarget` connectivity\n\n## Complete Working Examples\n\nThe examples above demonstrate real-world configuration patterns for:\n\n- Development environments\n- System monitoring setups\n- Remote administration layouts\n- Multi-project workflows\n\n---\n\n## Choosing Between Compact, Grid, and Section Layouts\n\n### Use Compact Layout When:\n\n✅ You want the simplest, most readable configuration\n✅ You need standard arrangements (1-4 panes)\n✅ You don't need custom pane properties (path, sshTarget, etc.)\n✅ You're defining common development workflows\n✅ You want pane names to automatically become titles\n\n**Example**: Most development workflows fit perfectly into compact layouts.\n\n```json\n{\n  \"layout\": \"compact\",\n  \"compact\": {\n    \"type\": \"main-side\",\n    \"panes\": {\n      \"editor\": \"nvim\",\n      \"terminal\": \"bash\",\n      \"logs\": \"tail -f app.log\"\n    }\n  }\n}\n```\n\n### Use Grid Layout When:\n\n✅ You need standard arrangements (1-4 panes)\n✅ You need pane properties like `path` or `sshTarget`\n✅ You want more control than compact but don't need custom splits\n✅ You need to define pane-specific starting directories\n\n**Example**: Development with remote execution or specific working directories.\n\n```json\n{\n  \"layout\": \"grid\",\n  \"grid\": {\n    \"type\": \"vertical\",\n    \"panes\": [\n      {\n        \"name\": \"local\",\n        \"command\": \"nvim\",\n        \"path\": \"src\"\n      },\n      {\n        \"name\": \"remote\",\n        \"command\": \"npm run dev\",\n        \"sshTarget\": \"prod-server\"\n      }\n    ]\n  }\n}\n```\n\n### Use Section Layout When:\n\n✅ You need custom split ratios (e.g., 70/30, 25/75)\n✅ You need more than 4 panes\n✅ You need complex nested arrangements\n✅ You need precise control over layout structure\n✅ Standard grids don't match your workflow\n\n**Example**: IDE-style layouts with file explorer, editor, terminal, and multiple monitoring panes.\n\n```json\n{\n  \"layout\": \"sections\",\n  \"section\": {\n    \"split\": \"vertical\",\n    \"items\": [\n      { \"name\": \"sidebar\", \"size\": \"20%\" },\n      {\n        \"split\": \"horizontal\",\n        \"size\": \"80%\",\n        \"items\": [\n          { \"name\": \"editor\", \"size\": \"70%\" },\n          { \"name\": \"terminal\", \"size\": \"30%\" }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Recommendation\n\n**Start with Compact Layout** for 90% of use cases. It provides the cleanest, most maintainable configuration.\n\n**Upgrade to Grid Layout** when you need:\n\n- Pane-specific properties (`path`, `sshTarget`)\n- More verbose configuration for clarity\n\n**Use Section Layout** only when you need:\n\n- Custom split ratios\n- More than 4 panes\n- Complex nested arrangements\n\n---\n\n## Complete Session Configuration Example\n\n### Using Compact Layouts (Recommended)\n\n```json\n{\n  \"tmux\": {\n    \"sessions\": [\n      {\n        \"name\": \"dev\",\n        \"windows\": [\n          {\n            \"name\": \"editor\",\n            \"layout\": \"compact\",\n            \"compact\": {\n              \"type\": \"vertical\",\n              \"panes\": {\n                \"nvim\": \"nvim\",\n                \"terminal\": \"bash\"\n              }\n            }\n          },\n          {\n            \"name\": \"servers\",\n            \"layout\": \"compact\",\n            \"compact\": {\n              \"type\": \"two-by-two\",\n              \"panes\": {\n                \"api\": \"npm run dev:api\",\n                \"web\": \"npm run dev:web\",\n                \"db\": \"docker-compose up postgres\",\n                \"redis\": \"docker-compose up redis\"\n              }\n            }\n          },\n          {\n            \"name\": \"monitoring\",\n            \"layout\": \"compact\",\n            \"compact\": {\n              \"type\": \"main-side\",\n              \"panes\": {\n                \"logs\": \"tail -f logs/development.log\",\n                \"htop\": \"htop\",\n                \"docker\": \"docker stats\"\n              }\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Using Grid Layouts\n\n```json\n{\n  \"tmux\": {\n    \"sessions\": [\n      {\n        \"name\": \"dev\",\n        \"windows\": [\n          {\n            \"name\": \"editor\",\n            \"layout\": \"grid\",\n            \"grid\": {\n              \"type\": \"vertical\",\n              \"panes\": [\n                {\n                  \"name\": \"nvim\",\n                  \"command\": \"nvim\"\n                },\n                {\n                  \"name\": \"terminal\"\n                }\n              ]\n            }\n          },\n          {\n            \"name\": \"servers\",\n            \"layout\": \"grid\",\n            \"grid\": {\n              \"type\": \"two-by-two\",\n              \"panes\": [\n                {\n                  \"name\": \"api\",\n                  \"command\": \"npm run dev:api\"\n                },\n                {\n                  \"name\": \"web\",\n                  \"command\": \"npm run dev:web\"\n                },\n                {\n                  \"name\": \"db\",\n                  \"command\": \"docker-compose up postgres\"\n                },\n                {\n                  \"name\": \"redis\",\n                  \"command\": \"docker-compose up redis\"\n                }\n              ]\n            }\n          },\n          {\n            \"name\": \"monitoring\",\n            \"layout\": \"grid\",\n            \"grid\": {\n              \"type\": \"main-side\",\n              \"panes\": [\n                {\n                  \"name\": \"logs\",\n                  \"command\": \"tail -f logs/development.log\"\n                },\n                {\n                  \"name\": \"htop\",\n                  \"command\": \"htop\"\n                },\n                {\n                  \"name\": \"docker\",\n                  \"command\": \"docker stats\"\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Mixing All Three Layout Types\n\nYou can use all layout types in the same session:\n\n```json\n{\n  \"tmux\": {\n    \"sessions\": [\n      {\n        \"name\": \"mixed\",\n        \"windows\": [\n          {\n            \"name\": \"simple\",\n            \"layout\": \"compact\",\n            \"compact\": {\n              \"type\": \"vertical\",\n              \"panes\": {\n                \"left\": \"nvim\",\n                \"right\": \"bash\"\n              }\n            }\n          },\n          {\n            \"name\": \"moderate\",\n            \"layout\": \"grid\",\n            \"grid\": {\n              \"type\": \"main-side\",\n              \"panes\": [\n                { \"name\": \"main\", \"path\": \"src\" },\n                { \"name\": \"side-1\" },\n                { \"name\": \"side-2\" }\n              ]\n            }\n          },\n          {\n            \"name\": \"complex\",\n            \"layout\": \"sections\",\n            \"section\": {\n              \"split\": \"vertical\",\n              \"items\": [\n                {\n                  \"name\": \"sidebar\",\n                  \"size\": \"20%\"\n                },\n                {\n                  \"split\": \"horizontal\",\n                  \"size\": \"80%\",\n                  \"items\": [\n                    { \"name\": \"main\", \"size\": \"70%\" },\n                    { \"name\": \"footer\", \"size\": \"30%\" }\n                  ]\n                }\n              ]\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n",
        "plugins/system/skills/system/references/tunnel-configuration.md": "# Tunnel Configuration Guide\n\n## Introduction\n\nTunnels expose local development servers through public URLs using Cloudflare tunnels. This is essential for testing OAuth callbacks, webhooks, and sharing local development environments without deploying to production.\n\n## What Are Tunnels?\n\nCloudflared tunnels provide:\n- **Public URLs** for local services (e.g., `https://app.example.com` → `http://localhost:5001`)\n- **OAuth callback testing** - Required for authentication flows\n- **Webhook development** - Test external services calling your local app\n- **Local environment sharing** - Share work-in-progress with team\n\n## meta.json Configuration\n\n**⚠️ ALWAYS fetch the schema first:**\n```\nhttps://raw.githubusercontent.com/ghostmind-dev/run/refs/heads/main/meta/schema.json\n```\n\n### Basic Configuration\n\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"ghostmind.app\",\n      \"service\": \"http://localhost:5001\"\n    }\n  }\n}\n```\n\n**Structure:**\n\n**`tunnel.<name>` (object)**\n- `<name>`: Tunnel identifier (e.g., `default`, `api`, `webhooks`)\n- Value: Tunnel configuration object\n\n**For complete `tunnel` property structure:** Fetch the schema\n\n## Tunnel Properties\n\n### hostname (string)\n\nPublic domain name for the tunnel:\n\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"ghostmind.app\"\n    }\n  }\n}\n```\n\nCommon patterns:\n- `\"app.example.com\"` - Subdomain\n- `\"localhost.run\"` - Development domain\n- `\"example.com\"` - Root domain\n\n### service (string)\n\nLocal service URL to expose:\n\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"service\": \"http://localhost:5001\"\n    }\n  }\n}\n```\n\nFormat: `http://localhost:<port>`\n\n### Using Variable Substitution\n\nReference port from `meta.json`:\n\n```json\n{\n  \"port\": 5001,\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"ghostmind.app\",\n      \"service\": \"http://localhost:${PORT}\"\n    }\n  }\n}\n```\n\n## Execution\n\n```bash\n# Start specific tunnel\nrun tunnel run --name default\n\n# Start all tunnels\nrun tunnel run --all\n\n# Start all tunnels with custom session name\nrun tunnel run --all --name my-tunnels\n```\n\n## Multiple Tunnels\n\nConfigure multiple tunnels for different services:\n\n```json\n{\n  \"tunnel\": {\n    \"ui\": {\n      \"hostname\": \"app.example.com\",\n      \"service\": \"http://localhost:5001\"\n    },\n    \"api\": {\n      \"hostname\": \"api.example.com\",\n      \"service\": \"http://localhost:3000\"\n    },\n    \"webhooks\": {\n      \"hostname\": \"webhooks.example.com\",\n      \"service\": \"http://localhost:8080\"\n    }\n  }\n}\n```\n\n**Start all:**\n```bash\nrun tunnel run --all\n```\n\n## Integration with Routines\n\nCommon pattern for tunnel management:\n\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"ghostmind.app\",\n      \"service\": \"http://localhost:5001\"\n    }\n  },\n  \"routines\": {\n    \"tunnel_start\": \"run tunnel run --all --name project-tunnels\",\n    \"dev_full\": \"run routine dev && run routine tunnel_start\"\n  }\n}\n```\n\n**Usage:**\n```bash\nrun routine tunnel_start\n```\n\n## Integration with Environment Variables\n\nUse tunnels in `.env` files:\n\n**meta.json:**\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"ghostmind.app\",\n      \"service\": \"http://localhost:${PORT}\"\n    }\n  }\n}\n```\n\n**.env.local:**\n```bash\nTUNNEL_NAME=\"ghostmind.app\"\nNEXTAUTH_URL=\"https://${TUNNEL_NAME}\"\nPUBLIC_URL=\"https://${TUNNEL_NAME}\"\n```\n\n## Real-World Examples\n\n### Single Application\n\n```json\n{\n  \"port\": 5001,\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"ghostmind.app\",\n      \"service\": \"http://localhost:${PORT}\"\n    }\n  }\n}\n```\n\n### Multi-Service Application\n\n```json\n{\n  \"tunnel\": {\n    \"frontend\": {\n      \"hostname\": \"city.ghostmind.app\",\n      \"service\": \"http://localhost:5001\"\n    },\n    \"api\": {\n      \"hostname\": \"api-city.ghostmind.app\",\n      \"service\": \"http://localhost:3000\"\n    }\n  }\n}\n```\n\n### Development + Staging\n\n```json\n{\n  \"tunnel\": {\n    \"dev\": {\n      \"hostname\": \"dev.ghostmind.app\",\n      \"service\": \"http://localhost:5001\"\n    },\n    \"staging\": {\n      \"hostname\": \"staging.ghostmind.app\",\n      \"service\": \"http://localhost:5002\"\n    }\n  }\n}\n```\n\n## Use Cases\n\n### OAuth Authentication\n\n**Problem:** OAuth providers require public callback URLs\n\n**Solution:**\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"app.example.com\",\n      \"service\": \"http://localhost:5001\"\n    }\n  }\n}\n```\n\n**.env.local:**\n```bash\nNEXTAUTH_URL=\"https://app.example.com\"\n```\n\nNow OAuth callbacks work with local development.\n\n### Webhook Testing\n\n**Problem:** External services need to call your local app\n\n**Solution:**\n```json\n{\n  \"tunnel\": {\n    \"webhooks\": {\n      \"hostname\": \"webhooks.example.com\",\n      \"service\": \"http://localhost:8080\"\n    }\n  }\n}\n```\n\nConfigure webhook URL as `https://webhooks.example.com` in external service.\n\n### Team Sharing\n\n**Problem:** Need to share local work-in-progress\n\n**Solution:**\n```bash\nrun tunnel run --name default\n```\n\nShare `https://app.example.com` with team members.\n\n## Integration with Tmux\n\nCommon pattern in tmux configurations:\n\n```json\n{\n  \"tunnel\": {\n    \"default\": {\n      \"hostname\": \"ghostmind.app\",\n      \"service\": \"http://localhost:5001\"\n    }\n  },\n  \"tmux\": {\n    \"sessions\": [\n      {\n        \"name\": \"dev\",\n        \"windows\": [\n          {\n            \"name\": \"services\",\n            \"layout\": \"compact\",\n            \"compact\": {\n              \"type\": \"vertical\",\n              \"panes\": {\n                \"server\": \"run custom dev build up\",\n                \"tunnel\": \"sleep 8 && run tunnel run --name default\"\n              }\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n```\n\nThe tunnel starts automatically when tmux session initializes.\n\n## Best Practices\n\n### 1. Use Variable Substitution for Ports\n\n```json\n// ✅ Good - DRY\n{\n  \"port\": 5001,\n  \"tunnel\": {\n    \"default\": {\n      \"service\": \"http://localhost:${PORT}\"\n    }\n  }\n}\n\n// ❌ Avoid - hardcoded\n{\n  \"port\": 5001,\n  \"tunnel\": {\n    \"default\": {\n      \"service\": \"http://localhost:5001\"\n    }\n  }\n}\n```\n\n### 2. Use Descriptive Tunnel Names\n\n```json\n// ✅ Good - clear purpose\n{\n  \"tunnel\": {\n    \"frontend\": { ... },\n    \"api\": { ... },\n    \"webhooks\": { ... }\n  }\n}\n\n// ❌ Avoid - unclear\n{\n  \"tunnel\": {\n    \"tunnel1\": { ... },\n    \"t2\": { ... }\n  }\n}\n```\n\n### 3. Integrate with Routines\n\n```json\n{\n  \"tunnel\": { ... },\n  \"routines\": {\n    \"tunnel_start\": \"run tunnel run --all\",\n    \"dev_with_tunnel\": \"run routine dev && run routine tunnel_start\"\n  }\n}\n```\n\n### 4. Add Delay in Tmux\n\nAllow service to start before tunnel:\n\n```json\n{\n  \"tmux\": {\n    \"sessions\": [{\n      \"windows\": [{\n        \"panes\": {\n          \"server\": \"run custom dev up\",\n          \"tunnel\": \"sleep 8 && run tunnel run --name default\"  // Wait 8s\n        }\n      }]\n    }]\n  }\n}\n```\n\n## Troubleshooting\n\n### Tunnel fails to connect\n\n**Problem:** `run tunnel run --name default` fails\n\n**Solution:**\n- Verify hostname is correct\n- Check local service is running on specified port\n- Ensure Cloudflared is configured properly\n\n### OAuth callbacks fail\n\n**Problem:** OAuth redirect doesn't work\n\n**Solution:**\n- Verify `NEXTAUTH_URL` uses tunnel hostname\n- Check OAuth provider callback URL matches tunnel hostname\n- Ensure tunnel is running before testing OAuth\n\n### Port already in use\n\n**Problem:** Tunnel can't connect because port is occupied\n\n**Solution:**\n- Stop other services using the port\n- Change port in `meta.json` and restart services\n\n## Next Steps\n\n- **Understanding meta.json:** See `meta-json-guide.md`\n- **run CLI:** See `run-cli-overview.md`\n- **Routines:** See `routines-guide.md`\n- **Tmux integration:** See `tmux-guide.md`\n- **System overview:** See `system-overview.md`\n\n**Remember:** Tunnels are essential for OAuth, webhooks, and local environment sharing. Always start the tunnel after your local service is running.\n",
        "plugins/utils/.claude-plugin/plugin.json": "{\n  \"name\": \"utils\",\n  \"description\": \"Ghostmind utils plugin with skills for development workflows and AI image generation\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"ghostmind-dev\"\n  }\n}\n",
        "plugins/utils/commands/create-ai-note.md": "---\ndescription: Create a note for the AI table\n---\n\nReuired tag: ai\n\nSo we are creating a new node and the only requirement is that it has the AI tag. That's it. You should probably add more tag but this tag is important because this will make sure that it will appear in the AI table. So you don't have to worry about the AI table it's already created. So that's it. So this node specifically, I mean it could be related to other table but I mean the tagging itself and you don't need to create a new view or all that kind of thing. You just create the node, add this tag and add as many other tag as you want. So here's the message.\n\n$1\n",
        "plugins/utils/commands/publish-changes.md": "---\ndescription: publish the git changes to main branch\n---\n\nYou need to perform the following commands: \n\n- git add . (always add all)\n- git commit -m YOUR_DETAILS_MESSAGES\n- git push orgin dev\n- create a pull request with the remote main\n- merge with changes with the remote main\n\nnever merge with the local main branch. We do not maintain a local main branch\n",
        "plugins/utils/skills/banana/SKILL.md": "---\nname: banana\ndescription: Generate images using Google's Gemini image generation model with Deno. Use this skill when the user wants to create AI-generated images, perform image-to-image transformations, or generate visual content from text prompts. Triggers include requests like \"generate an image of...\", \"create a picture of...\", \"make an image with...\", or \"transform this image to...\".\n---\n\n# Banana Image Generation Skill\n\nGenerate images using Google's Gemini 2.0 Flash image generation model, running with Deno.\n\n## Quick Start\n\nGenerate an image from a text prompt:\n\n```bash\ndeno run --allow-all scripts/generate-image.ts \"A cat eating a nano-banana in a fancy restaurant\"\n```\n\nTransform an existing image:\n\n```bash\ndeno run --allow-all scripts/generate-image.ts \"Make this cat wear a top hat\" --input cat.png --output fancy-cat.png\n```\n\n## Requirements\n\n- `GOOGLE_API_KEY` environment variable must be set\n- Deno runtime\n\n## Script Usage\n\nThe `scripts/generate-image.ts` script supports:\n\n| Flag | Description |\n|------|-------------|\n| `<prompt>` | Text description of the image to generate (required) |\n| `--input <path>` | Input image for image-to-image generation (optional) |\n| `--output <path>` | Output path for generated image (default: `generated-image.png`) |\n\n## Examples\n\nText-to-image:\n```bash\ndeno run --allow-all scripts/generate-image.ts \"A futuristic city at sunset\"\n```\n\nImage-to-image with custom output:\n```bash\ndeno run --allow-all scripts/generate-image.ts \"Add a rainbow to the sky\" --input landscape.jpg --output rainbow-landscape.png\n```\n\n## Programmatic Usage\n\nImport and use in Deno scripts:\n\n```typescript\nimport { generateImage } from \"./scripts/generate-image.ts\";\n\nawait generateImage({\n  prompt: \"A nano-banana floating in space\",\n  outputPath: \"space-banana.png\"\n});\n```\n\nWith input image:\n\n```typescript\nawait generateImage({\n  prompt: \"Make this banana purple\",\n  imagePath: \"banana.png\",\n  outputPath: \"purple-banana.png\"\n});\n```\n"
      },
      "plugins": [
        {
          "name": "system",
          "source": "./plugins/system",
          "description": "Ghostmind system plugin with skills for development workflows and AI image generation",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add ghostmind-dev/system",
            "/plugin install system@ghostmind"
          ]
        },
        {
          "name": "utils",
          "source": "./plugins/utils",
          "description": "Ghostmind utils plugin with skills for development workflows and AI image generation",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add ghostmind-dev/system",
            "/plugin install utils@ghostmind"
          ]
        }
      ]
    }
  ]
}