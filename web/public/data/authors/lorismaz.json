{
  "author": {
    "id": "lorismaz",
    "display_name": "Loris Mazloum",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/2421972?u=460ea7524c21ec7e54727b180f466290698d265d&v=4",
    "url": "https://github.com/lorismaz",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "charm-ruby",
      "version": null,
      "description": "Plugins for building beautiful CLI tools in Ruby",
      "owner_info": {
        "name": "Loris Mazloum",
        "email": "loris@mazloum.com"
      },
      "keywords": [],
      "repo_full_name": "lorismaz/charm-ruby-claude-plugin",
      "repo_url": "https://github.com/lorismaz/charm-ruby-claude-plugin",
      "repo_description": "Claude Code plugin for building beautiful CLI tools in Ruby using the charm-ruby ecosystem",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-15T08:38:13Z",
        "created_at": "2026-01-03T13:53:01Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 802
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 550
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3265
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/cli-architect.md",
          "type": "blob",
          "size": 6791
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/add-component.md",
          "type": "blob",
          "size": 10643
        },
        {
          "path": "commands/new-cli.md",
          "type": "blob",
          "size": 7465
        },
        {
          "path": "commands/package.md",
          "type": "blob",
          "size": 4845
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/charm-ruby-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/charm-ruby-development/SKILL.md",
          "type": "blob",
          "size": 13171
        },
        {
          "path": "skills/charm-ruby-development/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/charm-ruby-development/references/accessibility-guidelines.md",
          "type": "blob",
          "size": 9266
        },
        {
          "path": "skills/charm-ruby-development/references/bubble-tea-architecture.md",
          "type": "blob",
          "size": 8633
        },
        {
          "path": "skills/charm-ruby-development/references/bubbles-components.md",
          "type": "blob",
          "size": 14298
        },
        {
          "path": "skills/charm-ruby-development/references/bubblezone-mouse.md",
          "type": "blob",
          "size": 10023
        },
        {
          "path": "skills/charm-ruby-development/references/cli-ux-best-practices.md",
          "type": "blob",
          "size": 8697
        },
        {
          "path": "skills/charm-ruby-development/references/gem-distribution.md",
          "type": "blob",
          "size": 11788
        },
        {
          "path": "skills/charm-ruby-development/references/harmonica-animation.md",
          "type": "blob",
          "size": 11100
        },
        {
          "path": "skills/charm-ruby-development/references/huh-forms.md",
          "type": "blob",
          "size": 9985
        },
        {
          "path": "skills/charm-ruby-development/references/lipgloss-styling.md",
          "type": "blob",
          "size": 9179
        },
        {
          "path": "skills/charm-ruby-development/references/ntcharts-visualization.md",
          "type": "blob",
          "size": 8036
        },
        {
          "path": "skills/charm-ruby-development/references/testing-tui-applications.md",
          "type": "blob",
          "size": 12537
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"charm-ruby\",\n  \"owner\": {\n    \"name\": \"Loris Mazloum\",\n    \"email\": \"loris@mazloum.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Plugins for building beautiful CLI tools in Ruby\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"charm-ruby\",\n      \"source\": \"./\",\n      \"description\": \"Build beautiful, interactive CLI tools in Ruby using the charm-ruby ecosystem (Bubble Tea, Lipgloss, Bubbles, Huh, and more)\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Loris Mazloum\"\n      },\n      \"homepage\": \"https://charm-ruby.dev\",\n      \"repository\": \"https://github.com/lorismaz/charm-ruby-claude-plugin\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"ruby\", \"cli\", \"tui\", \"terminal\", \"charm\", \"bubbletea\", \"lipgloss\"],\n      \"category\": \"development\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"charm-ruby\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Build beautiful, interactive CLI tools in Ruby using the charm-ruby ecosystem (Bubble Tea, Lipgloss, Bubbles, Huh, and more)\",\n  \"author\": {\n    \"name\": \"Loris Mazloum\",\n    \"url\": \"https://github.com/lorismaz\"\n  },\n  \"repository\": \"https://github.com/lorismaz/charm-ruby-claude-plugin\",\n  \"homepage\": \"https://charm-ruby.dev\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"ruby\",\n    \"cli\",\n    \"tui\",\n    \"terminal\",\n    \"charm\",\n    \"bubbletea\",\n    \"lipgloss\",\n    \"interactive\"\n  ]\n}\n",
        "README.md": "# Charm Ruby Plugin for Claude Code\n\nBuild beautiful, interactive command-line applications in Ruby using the [charm-ruby](https://charm-ruby.dev) ecosystem.\n\n## What is Charm Ruby?\n\nCharm Ruby is a collection of Ruby gems ported from [Charm.sh](https://charm.sh)'s Go libraries by Marco Roth. It provides everything you need to build stunning terminal user interfaces:\n\n| Gem | Purpose |\n|-----|---------|\n| **bubbletea** | Model-View-Update architecture for interactive apps |\n| **lipgloss** | CSS-like terminal styling |\n| **bubbles** | Pre-built components (spinners, inputs, lists, tables) |\n| **huh** | Interactive forms with validation |\n| **glamour** | Markdown rendering in terminal |\n| **harmonica** | Physics-based spring animations |\n| **gum** | Shell script interactions |\n| **bubblezone** | Mouse event tracking and clickable zones |\n| **ntcharts** | Terminal charts (sparklines, bar/line charts, heatmaps) |\n\n## Features\n\n### Skill: Charm Ruby Development\n\nComprehensive knowledge for building CLI tools:\n\n- Quick start guides\n- Bubble Tea MVU architecture patterns\n- Lipgloss styling reference\n- Component integration\n- Best practices\n- Gem distribution\n\nTriggered when you ask about building CLI tools in Ruby, terminal UIs, or any charm-ruby library.\n\n### Commands\n\n| Command | Description |\n|---------|-------------|\n| `/charm:init [name]` | Scaffold a new charm-ruby CLI project |\n| `/charm:add-component [type]` | Add a Bubbles component to your project |\n| `/charm:package` | Prepare your CLI for RubyGems distribution |\n\n### Agent: CLI Architect\n\nExpert Ruby CLI architect that helps you:\n\n- Design application architecture\n- Plan multi-screen navigation\n- Select appropriate components\n- Structure your Bubble Tea models\n- Follow terminal UX best practices\n\n## Quick Start\n\n1. **Create a new project:**\n   ```\n   /charm:init my-awesome-cli\n   ```\n\n2. **Add components as needed:**\n   ```\n   /charm:add-component list\n   /charm:add-component spinner\n   ```\n\n3. **When ready to publish:**\n   ```\n   /charm:package\n   ```\n\n## Example: Simple Counter\n\n```ruby\nrequire \"bubbletea\"\nrequire \"lipgloss\"\n\nclass CounterModel\n  include Bubbletea::Model\n\n  def initialize\n    @count = 0\n    @style = Lipgloss::Style.new.bold(true).foreground(\"#FF69B4\")\n  end\n\n  def init\n    nil\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"q\" then return [self, Bubbletea.quit]\n      when \"up\", \"k\" then @count += 1\n      when \"down\", \"j\" then @count -= 1\n      end\n    end\n    [self, nil]\n  end\n\n  def view\n    \"Count: #{@style.render(@count.to_s)}\\n\\n↑/k inc • ↓/j dec • q quit\"\n  end\nend\n\nBubbletea.run(CounterModel.new)\n```\n\n## Resources\n\n- [charm-ruby.dev](https://charm-ruby.dev) - Official documentation\n- [Marco Roth's blog post](https://marcoroth.dev/posts/glamorous-christmas) - Comprehensive overview\n- [charm.sh](https://charm.sh) - Original Go libraries\n\n## Installation\n\nIn Claude Code, run these slash commands:\n\n1. Add the marketplace:\n   ```\n   /plugin marketplace add lorismaz/charm-ruby-claude-plugin\n   ```\n\n2. Install the plugin:\n   ```\n   /plugin install charm-ruby@charm-ruby\n   ```\n\nThe skill, commands, and agent will be automatically available after installation.\n\n## License\n\nMIT\n",
        "agents/cli-architect.md": "---\nmodel: sonnet\nwhenToUse: |\n  Expert Ruby CLI architect specializing in charm-ruby terminal applications. Use when the user needs help designing CLI tool architecture, planning interactive terminal features, structuring Bubble Tea models, or making terminal UI decisions. Triggers: \"design my CLI\", \"structure this command line app\", \"how should I organize my terminal UI\", \"charm-ruby architecture\", \"plan my Ruby TUI\", \"CLI design advice\".\n\n  <example>\n  Context: User wants to build a new CLI tool\n  user: \"I want to build a CLI tool for managing Docker containers with an interactive TUI\"\n  assistant: \"I'll use the cli-architect agent to design the architecture for your Docker management CLI\"\n  <commentary>User is asking for CLI architecture design, which is exactly what this agent specializes in</commentary>\n  </example>\n\n  <example>\n  Context: User needs help structuring their terminal app\n  user: \"How should I structure my Ruby TUI application that has multiple screens?\"\n  assistant: \"Let me use the cli-architect agent to help plan your multi-screen TUI architecture\"\n  <commentary>User is asking about terminal UI structure, a core competency of this agent</commentary>\n  </example>\n\n  <example>\n  Context: User is deciding on components\n  user: \"What's the best way to show progress for file downloads in my CLI?\"\n  assistant: \"I'll consult the cli-architect agent for the best approach to progress visualization in your CLI\"\n  <commentary>User needs guidance on terminal UI patterns, which this agent can help with</commentary>\n  </example>\ncolor: \"#7D56F4\"\ntools:\n  - Read\n  - Glob\n  - Grep\n  - WebFetch\n---\n\n# CLI Architect for Charm Ruby Applications\n\nYou are an expert Ruby CLI architect specializing in building beautiful, interactive terminal applications using the charm-ruby ecosystem. You help users design well-structured, maintainable CLI tools that provide excellent user experiences.\n\n## Your Expertise\n\n- **Bubble Tea Architecture**: Model-View-Update patterns, state management, message handling\n- **Terminal UI Design**: Component selection, layout patterns, user interaction flows\n- **Charm Ruby Ecosystem**: Lipgloss styling, Bubbles components, Huh forms, Glamour markdown\n- **CLI Best Practices**: Command structure, argument parsing, error handling, help systems\n- **Ruby Gem Distribution**: Project structure for publishable CLI gems\n\n## Architecture Process\n\nWhen helping design a CLI application:\n\n### 1. Understand Requirements\n\nAsk clarifying questions:\n- What is the primary purpose of the CLI?\n- Who are the target users (developers, ops, general users)?\n- What are the main features/commands?\n- What data sources will it interact with?\n- Are there any similar tools to reference?\n\n### 2. Recommend Application Structure\n\nBased on requirements, suggest:\n- Single model vs. multi-screen architecture\n- Which Bubbles components to use\n- State management approach\n- File organization\n\n### 3. Design the Model Structure\n\nFor each major feature, outline:\n- State fields needed\n- Messages to handle\n- Commands for async operations\n- View rendering approach\n\n### 4. Component Selection\n\nMatch features to charm-ruby components:\n\n| Feature Need | Recommended Component |\n|--------------|----------------------|\n| Loading states | Bubbles::Spinner |\n| User text input | Bubbles::TextInput or Huh form |\n| Item selection | Bubbles::List |\n| Data display | Bubbles::Table |\n| Long content | Bubbles::Viewport |\n| Progress | Bubbles::Progress or custom |\n| Multi-field input | Huh::Form |\n\n### 5. Suggest UX Patterns\n\nRecommend terminal UX best practices:\n- Vim-style navigation (j/k/h/l)\n- Clear help text and keybindings\n- Confirmation for destructive actions\n- Progress feedback for operations > 100ms\n- Graceful error handling with recovery options\n\n## Architecture Patterns\n\n### Simple Single-Screen App\n\n```ruby\nclass Model\n  include Bubbletea::Model\n\n  def initialize\n    # All state in one model\n  end\n\n  def update(msg)\n    # Handle all messages\n  end\n\n  def view\n    # Render entire UI\n  end\nend\n```\n\nBest for: Simple tools, quick utilities, single-purpose CLIs\n\n### Multi-Screen Navigation\n\n```ruby\nclass App\n  SCREENS = [:menu, :list, :detail, :edit]\n\n  def initialize\n    @screen = :menu\n    @menu = MenuModel.new\n    @list = ListModel.new\n    # ...\n  end\n\n  def update(msg)\n    case @screen\n    when :menu then handle_menu(msg)\n    when :list then handle_list(msg)\n    # ...\n    end\n  end\nend\n```\n\nBest for: Feature-rich apps, multi-step workflows, complex tools\n\n### Component Composition\n\n```ruby\nclass DashboardModel\n  def initialize\n    @header = HeaderComponent.new\n    @sidebar = SidebarComponent.new\n    @content = ContentComponent.new\n  end\n\n  def view\n    Lipgloss.join_vertical(:left,\n      @header.view,\n      Lipgloss.join_horizontal(:top,\n        @sidebar.view,\n        @content.view\n      )\n    )\n  end\nend\n```\n\nBest for: Complex layouts, reusable UI sections, dashboard-style apps\n\n### Form Wizard\n\n```ruby\nclass WizardModel\n  STEPS = [:info, :config, :confirm]\n\n  def initialize\n    @step = 0\n    @data = {}\n    @forms = STEPS.map { |s| create_form(s) }\n  end\n\n  def update(msg)\n    if @forms[@step].complete?\n      @data.merge!(@forms[@step].result)\n      @step += 1\n    end\n    # ...\n  end\nend\n```\n\nBest for: Multi-step configuration, setup wizards, guided workflows\n\n## Common Patterns\n\n### Async Data Loading\n\n```ruby\ndef init\n  Bubbletea.batch(\n    fetch_data_cmd,\n    @spinner.tick\n  )\nend\n\ndef fetch_data_cmd\n  Bubbletea.cmd do\n    data = API.fetch_items\n    DataLoadedMsg.new(data)\n  rescue => e\n    ErrorMsg.new(e.message)\n  end\nend\n```\n\n### Confirmation Dialog\n\n```ruby\ndef handle_delete(item)\n  @confirm_dialog = ConfirmDialog.new(\n    message: \"Delete #{item.name}?\",\n    on_confirm: -> { delete_item(item) },\n    on_cancel: -> { @confirm_dialog = nil }\n  )\nend\n```\n\n### Search/Filter\n\n```ruby\ndef initialize\n  @items = all_items\n  @filter = \"\"\nend\n\ndef filtered_items\n  return @items if @filter.empty?\n  @items.select { |i| i.name.downcase.include?(@filter.downcase) }\nend\n```\n\n## Response Format\n\nWhen providing architecture recommendations:\n\n1. **Summary**: Brief overview of recommended approach\n2. **Structure**: File/class organization\n3. **Components**: Which charm-ruby components to use\n4. **State Design**: Key state fields and their purposes\n5. **Message Flow**: Important messages and state transitions\n6. **Code Skeleton**: Basic implementation outline\n7. **Next Steps**: What to implement first\n\n## Important Notes\n\n- Always consider terminal size constraints\n- Recommend alt_screen mode for full-screen apps\n- Suggest keyboard shortcuts that feel natural\n- Consider accessibility (no color-only information)\n- Plan for error states and edge cases\n- Keep performance in mind (fast view rendering)\n",
        "commands/add-component.md": "---\nname: add-component\ndescription: Add a Bubbles component to an existing charm-ruby project\nargument-hint: \"[component-type]\"\nallowed-tools:\n  - Write\n  - Edit\n  - Read\n  - Glob\n  - Grep\n  - AskUserQuestion\n---\n\n# Add a Bubbles Component\n\nAdd a pre-built Bubbles component to an existing charm-ruby project, including the component module and integration with the main model.\n\n## Available Component Types\n\n| Type | Description |\n|------|-------------|\n| `spinner` | Animated loading indicator |\n| `text-input` | Single-line text input with cursor |\n| `text-area` | Multi-line text editing |\n| `list` | Scrollable, selectable item list |\n| `table` | Formatted data tables |\n| `progress` | Progress bar with percentage |\n| `viewport` | Scrollable content area |\n| `form` | Huh interactive form |\n\n## Workflow\n\n### 1. Verify Project Structure\n\nFirst, verify this is a charm-ruby project by checking for:\n- A `lib/` directory with a main module file\n- A `Gemfile` with bubbletea/lipgloss dependencies\n\nIf not found, inform the user:\n```\nThis doesn't appear to be a charm-ruby project. Run /charm:init first to create one.\n```\n\n### 2. Determine Component Type\n\nIf the user provided a component type argument, validate it against the available types.\n\nIf not provided or invalid, ask:\n```\nWhich component would you like to add?\n\n• spinner - Loading indicator\n• text-input - Single-line text input\n• text-area - Multi-line text input\n• list - Selectable item list\n• table - Data table\n• progress - Progress bar\n• viewport - Scrollable content\n• form - Interactive form (Huh)\n```\n\n### 3. Detect Project Structure\n\nFind the project's module name by reading the main lib file. Look for:\n```ruby\nmodule SomeModuleName\n```\n\nExtract the module name and snake_case version for file paths.\n\n### 4. Create Components Directory\n\nIf it doesn't exist, create `lib/{project_name}/components/`.\n\n### 5. Generate Component File\n\nCreate the component file based on the selected type.\n\n#### spinner.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbles\"\nrequire \"lipgloss\"\n\nmodule {ModuleName}\n  module Components\n    class Spinner\n      attr_reader :spinner, :message\n\n      def initialize(message = \"Loading...\")\n        @spinner = Bubbles::Spinner.new\n        @spinner.style = :dots\n        @message = message\n        @style = Lipgloss::Style.new.foreground(\"#FF69B4\")\n      end\n\n      def tick\n        @spinner.tick\n      end\n\n      def update(msg)\n        @spinner, cmd = @spinner.update(msg)\n        [self, cmd]\n      end\n\n      def view\n        \"#{@style.render(@spinner.view)} #{@message}\"\n      end\n    end\n  end\nend\n```\n\n#### text_input.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbles\"\nrequire \"lipgloss\"\n\nmodule {ModuleName}\n  module Components\n    class TextInput\n      attr_reader :input, :label\n\n      def initialize(label:, placeholder: \"\")\n        @label = label\n        @input = Bubbles::TextInput.new\n        @input.placeholder = placeholder\n        @input.focus\n        setup_styles\n      end\n\n      def value\n        @input.value\n      end\n\n      def focus\n        @input.focus\n      end\n\n      def blur\n        @input.blur\n      end\n\n      def focused?\n        @input.focused?\n      end\n\n      def update(msg)\n        @input, cmd = @input.update(msg)\n        [self, cmd]\n      end\n\n      def view\n        label = @label_style.render(\"#{@label}:\")\n        \"#{label} #{@input.view}\"\n      end\n\n      private\n\n      def setup_styles\n        @label_style = Lipgloss::Style.new\n          .foreground(\"#888888\")\n          .bold(true)\n      end\n    end\n  end\nend\n```\n\n#### text_area.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbles\"\nrequire \"lipgloss\"\n\nmodule {ModuleName}\n  module Components\n    class TextArea\n      attr_reader :textarea, :label\n\n      def initialize(label:, placeholder: \"\", width: 60, height: 5)\n        @label = label\n        @textarea = Bubbles::TextArea.new\n        @textarea.placeholder = placeholder\n        @textarea.width = width\n        @textarea.height = height\n        @textarea.focus\n        setup_styles\n      end\n\n      def value\n        @textarea.value\n      end\n\n      def focus\n        @textarea.focus\n      end\n\n      def blur\n        @textarea.blur\n      end\n\n      def update(msg)\n        @textarea, cmd = @textarea.update(msg)\n        [self, cmd]\n      end\n\n      def view\n        label = @label_style.render(@label)\n        \"#{label}\\n#{@textarea.view}\"\n      end\n\n      private\n\n      def setup_styles\n        @label_style = Lipgloss::Style.new\n          .foreground(\"#888888\")\n          .bold(true)\n          .margin_bottom(1)\n      end\n    end\n  end\nend\n```\n\n#### list.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbles\"\nrequire \"lipgloss\"\n\nmodule {ModuleName}\n  module Components\n    class List\n      attr_reader :items, :cursor\n\n      def initialize(items:, title: nil)\n        @items = items\n        @title = title\n        @cursor = 0\n        setup_styles\n      end\n\n      def selected_item\n        @items[@cursor]\n      end\n\n      def update(msg)\n        case msg\n        when Bubbletea::KeyMsg\n          case msg.string\n          when \"up\", \"k\"\n            @cursor = [@cursor - 1, 0].max\n          when \"down\", \"j\"\n            @cursor = [@cursor + 1, @items.length - 1].min\n          when \"g\"\n            @cursor = 0\n          when \"G\"\n            @cursor = @items.length - 1\n          end\n        end\n        [self, nil]\n      end\n\n      def view\n        lines = []\n\n        if @title\n          lines << @title_style.render(@title)\n          lines << \"\"\n        end\n\n        @items.each_with_index do |item, i|\n          if i == @cursor\n            lines << @selected_style.render(\"> #{item}\")\n          else\n            lines << @item_style.render(\"  #{item}\")\n          end\n        end\n\n        lines.join(\"\\n\")\n      end\n\n      private\n\n      def setup_styles\n        @title_style = Lipgloss::Style.new\n          .bold(true)\n          .foreground(\"#FAFAFA\")\n          .background(\"#7D56F4\")\n          .padding(0, 1)\n\n        @selected_style = Lipgloss::Style.new\n          .foreground(\"#FF69B4\")\n          .bold(true)\n\n        @item_style = Lipgloss::Style.new\n          .foreground(\"#AAAAAA\")\n      end\n    end\n  end\nend\n```\n\n#### table.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbles\"\nrequire \"lipgloss\"\n\nmodule {ModuleName}\n  module Components\n    class Table\n      attr_reader :table, :cursor\n\n      def initialize(columns:, rows:)\n        @table = Bubbles::Table.new\n        @table.columns = columns\n        @table.rows = rows\n        @cursor = 0\n        setup_styles\n      end\n\n      def selected_row\n        @table.rows[@cursor]\n      end\n\n      def update(msg)\n        case msg\n        when Bubbletea::KeyMsg\n          case msg.string\n          when \"up\", \"k\"\n            @cursor = [@cursor - 1, 0].max\n          when \"down\", \"j\"\n            @cursor = [@cursor + 1, @table.rows.length - 1].min\n          end\n        end\n        @table, cmd = @table.update(msg)\n        [self, cmd]\n      end\n\n      def view\n        @table.view\n      end\n\n      private\n\n      def setup_styles\n        @table.border = :rounded\n        @table.header_style = Lipgloss::Style.new\n          .bold(true)\n          .foreground(\"#FFFFFF\")\n          .background(\"#7D56F4\")\n        @table.selected_style = Lipgloss::Style.new\n          .background(\"#333333\")\n      end\n    end\n  end\nend\n```\n\n#### progress.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"lipgloss\"\n\nmodule {ModuleName}\n  module Components\n    class Progress\n      attr_reader :percent, :width\n\n      def initialize(width: 40)\n        @percent = 0.0\n        @width = width\n        setup_styles\n      end\n\n      def set(percent)\n        @percent = [[percent, 0.0].max, 1.0].min\n      end\n\n      def increment(amount = 0.1)\n        set(@percent + amount)\n      end\n\n      def complete?\n        @percent >= 1.0\n      end\n\n      def view\n        filled_width = (@width * @percent).round\n        empty_width = @width - filled_width\n\n        filled = @filled_style.render(\" \" * filled_width)\n        empty = @empty_style.render(\" \" * empty_width)\n        percentage = @percent_style.render(\"#{(@percent * 100).round}%\")\n\n        \"#{filled}#{empty} #{percentage}\"\n      end\n\n      private\n\n      def setup_styles\n        @filled_style = Lipgloss::Style.new\n          .background(\"#7D56F4\")\n\n        @empty_style = Lipgloss::Style.new\n          .background(\"#3C3C3C\")\n\n        @percent_style = Lipgloss::Style.new\n          .foreground(\"#888888\")\n      end\n    end\n  end\nend\n```\n\n#### viewport.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbles\"\n\nmodule {ModuleName}\n  module Components\n    class Viewport\n      attr_reader :viewport\n\n      def initialize(content:, width: 80, height: 20)\n        @viewport = Bubbles::Viewport.new\n        @viewport.width = width\n        @viewport.height = height\n        @viewport.content = content\n      end\n\n      def content=(new_content)\n        @viewport.content = new_content\n      end\n\n      def scroll_percent\n        @viewport.scroll_percent\n      end\n\n      def at_top?\n        @viewport.at_top?\n      end\n\n      def at_bottom?\n        @viewport.at_bottom?\n      end\n\n      def update(msg)\n        @viewport, cmd = @viewport.update(msg)\n        [self, cmd]\n      end\n\n      def view\n        @viewport.view\n      end\n    end\n  end\nend\n```\n\n#### form.rb (requires Huh)\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"huh\"\n\nmodule {ModuleName}\n  module Components\n    class Form\n      attr_reader :result\n\n      def initialize(&block)\n        @form = Huh::Form.new(&block)\n        @result = nil\n      end\n\n      def run\n        @result = @form.run\n        @result\n      end\n\n      def cancelled?\n        @result&.cancelled?\n      end\n\n      def completed?\n        @result&.completed?\n      end\n\n      def [](key)\n        @result&.[](key)\n      end\n    end\n  end\nend\n```\n\n### 6. Update Main Module File\n\nAdd the component require to the main `lib/{project_name}.rb`:\n\n```ruby\nrequire_relative \"{project_name}/components/{component_name}\"\n```\n\n### 7. Show Integration Example\n\nAfter creating the component, show how to use it:\n\n```ruby\n# In your model:\n\ndef initialize\n  @{component} = {ModuleName}::Components::{ComponentClass}.new(...)\nend\n\ndef update(msg)\n  @{component}, cmd = @{component}.update(msg)\n  [self, cmd]\nend\n\ndef view\n  @{component}.view\nend\n```\n\n### 8. Check for Missing Dependencies\n\nIf the component requires a gem not in the Gemfile (e.g., `huh` for form), inform the user:\n\n```\nNote: This component requires the 'huh' gem. Add to your Gemfile:\n\n  gem \"huh\", github: \"marcoroth/huh-ruby\"\n\nThen run: bundle install\n```\n",
        "commands/new-cli.md": "---\nname: new-cli\ndescription: Scaffold a new charm-ruby CLI project with Bubble Tea architecture\nargument-hint: \"[project-name]\"\nallowed-tools:\n  - Write\n  - Bash\n  - Read\n  - Glob\n  - AskUserQuestion\n---\n\n# Initialize a Charm Ruby CLI Project\n\nCreate a new Ruby CLI project scaffolded for charm-ruby development with Bubble Tea MVU architecture, Lipgloss styling, and gem distribution setup.\n\n## Workflow\n\n### 1. Determine Project Name\n\nIf the user provided a project name argument, use it. Otherwise, ask:\n\n```\nWhat would you like to name your CLI project?\n```\n\nThe project name should be:\n- Lowercase with hyphens (e.g., `my-awesome-cli`)\n- Valid Ruby gem name\n- Converted to snake_case for module names (e.g., `my_awesome_cli` → `MyAwesomeCli`)\n\n### 2. Create Project Structure\n\nCreate the following directory structure:\n\n```\n{project-name}/\n├── bin/\n│   └── {project-name}      # Executable (chmod +x)\n├── lib/\n│   ├── {project_name}.rb   # Main entry point\n│   └── {project_name}/\n│       ├── version.rb      # Version constant\n│       ├── cli.rb          # CLI entry class\n│       └── model.rb        # Main Bubble Tea model\n├── spec/\n│   └── {project_name}_spec.rb  # Basic test file\n├── .gitignore\n├── .rubocop.yml\n├── Gemfile\n├── {project-name}.gemspec\n├── LICENSE.txt\n├── Rakefile\n└── README.md\n```\n\n### 3. File Contents\n\n#### bin/{project-name}\n\n```ruby\n#!/usr/bin/env ruby\n# frozen_string_literal: true\n\nrequire \"{project_name}\"\n\n{ModuleName}::CLI.start\n```\n\n#### lib/{project_name}.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire_relative \"{project_name}/version\"\nrequire_relative \"{project_name}/cli\"\nrequire_relative \"{project_name}/model\"\n\nmodule {ModuleName}\n  class Error < StandardError; end\nend\n```\n\n#### lib/{project_name}/version.rb\n\n```ruby\n# frozen_string_literal: true\n\nmodule {ModuleName}\n  VERSION = \"0.1.0\"\nend\n```\n\n#### lib/{project_name}/cli.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbletea\"\n\nmodule {ModuleName}\n  class CLI\n    def self.start(args = ARGV)\n      new(args).run\n    end\n\n    def initialize(args)\n      @args = args\n    end\n\n    def run\n      case @args.first\n      when \"-v\", \"--version\"\n        puts \"{project-name} #{VERSION}\"\n      when \"-h\", \"--help\"\n        show_help\n      else\n        start_app\n      end\n    end\n\n    private\n\n    def show_help\n      puts <<~HELP\n        {project-name} - A beautiful CLI tool\n\n        Usage: {project-name} [options]\n\n        Options:\n          -h, --help     Show this help\n          -v, --version  Show version\n      HELP\n    end\n\n    def start_app\n      Bubbletea.run(Model.new, alt_screen: true)\n    end\n  end\nend\n```\n\n#### lib/{project_name}/model.rb\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbletea\"\nrequire \"lipgloss\"\n\nmodule {ModuleName}\n  class Model\n    include Bubbletea::Model\n\n    def initialize\n      @cursor = 0\n      @items = [\"Getting started\", \"Add features\", \"Ship it!\"]\n      setup_styles\n    end\n\n    def init\n      nil\n    end\n\n    def update(msg)\n      case msg\n      when Bubbletea::KeyMsg\n        handle_key(msg)\n      else\n        [self, nil]\n      end\n    end\n\n    def view\n      title = @title_style.render(\" {ModuleName} \")\n\n      items = @items.map.with_index do |item, i|\n        if i == @cursor\n          @selected_style.render(\"> #{item}\")\n        else\n          \"  #{item}\"\n        end\n      end.join(\"\\n\")\n\n      help = @help_style.render(\"j/k navigate • enter select • q quit\")\n\n      \"\\n#{title}\\n\\n#{items}\\n\\n#{help}\\n\"\n    end\n\n    private\n\n    def setup_styles\n      @title_style = Lipgloss::Style.new\n        .bold(true)\n        .foreground(\"#FAFAFA\")\n        .background(\"#7D56F4\")\n        .padding(0, 1)\n\n      @selected_style = Lipgloss::Style.new\n        .foreground(\"#FF69B4\")\n        .bold(true)\n\n      @help_style = Lipgloss::Style.new\n        .foreground(\"#626262\")\n    end\n\n    def handle_key(msg)\n      case msg.string\n      when \"q\", \"ctrl+c\", \"esc\"\n        [self, Bubbletea.quit]\n      when \"up\", \"k\"\n        @cursor = [@cursor - 1, 0].max\n        [self, nil]\n      when \"down\", \"j\"\n        @cursor = [@cursor + 1, @items.length - 1].min\n        [self, nil]\n      when \"enter\"\n        # Handle selection - customize this!\n        [self, nil]\n      else\n        [self, nil]\n      end\n    end\n  end\nend\n```\n\n#### Gemfile\n\n```ruby\n# frozen_string_literal: true\n\nsource \"https://rubygems.org\"\n\ngemspec\n\ngroup :development do\n  gem \"debug\"\nend\n```\n\n#### {project-name}.gemspec\n\n```ruby\n# frozen_string_literal: true\n\nrequire_relative \"lib/{project_name}/version\"\n\nGem::Specification.new do |spec|\n  spec.name          = \"{project-name}\"\n  spec.version       = {ModuleName}::VERSION\n  spec.authors       = [\"Your Name\"]\n  spec.email         = [\"you@example.com\"]\n\n  spec.summary       = \"A beautiful CLI tool built with charm-ruby\"\n  spec.description   = \"Describe what your CLI does here.\"\n  spec.homepage      = \"https://github.com/yourusername/{project-name}\"\n  spec.license       = \"MIT\"\n\n  spec.required_ruby_version = \">= 2.7.0\"\n\n  spec.metadata = {\n    \"homepage_uri\" => spec.homepage,\n    \"source_code_uri\" => spec.homepage,\n    \"changelog_uri\" => \"#{spec.homepage}/blob/main/CHANGELOG.md\"\n  }\n\n  spec.files = Dir.chdir(__dir__) do\n    `git ls-files -z`.split(\"\\x0\").reject do |f|\n      f.match(%r{\\A(?:test|spec|features)/}) ||\n        f.match(%r{\\A\\.(?:git|github)})\n    end\n  end\n\n  spec.bindir        = \"bin\"\n  spec.executables   = [\"{project-name}\"]\n  spec.require_paths = [\"lib\"]\n\n  spec.add_dependency \"bubbletea\", \"~> 0.1\"\n  spec.add_dependency \"lipgloss\", \"~> 0.1\"\n  spec.add_dependency \"bubbles\", \"~> 0.1\"\n\n  spec.add_development_dependency \"rake\", \"~> 13.0\"\n  spec.add_development_dependency \"rspec\", \"~> 3.0\"\n  spec.add_development_dependency \"rubocop\", \"~> 1.0\"\nend\n```\n\n#### .gitignore\n\n```\n/.bundle/\n/.yardoc\n/_yardoc/\n/coverage/\n/doc/\n/pkg/\n/spec/reports/\n/tmp/\n*.gem\nGemfile.lock\n```\n\n#### .rubocop.yml\n\n```yaml\nAllCops:\n  TargetRubyVersion: 2.7\n  NewCops: enable\n\nStyle/Documentation:\n  Enabled: false\n\nMetrics/MethodLength:\n  Max: 20\n\nMetrics/BlockLength:\n  Exclude:\n    - \"spec/**/*\"\n    - \"*.gemspec\"\n```\n\n#### Rakefile\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bundler/gem_tasks\"\nrequire \"rspec/core/rake_task\"\n\nRSpec::Core::RakeTask.new(:spec)\n\ntask default: :spec\n```\n\n#### README.md\n\n```markdown\n# {ModuleName}\n\nA beautiful CLI tool built with [charm-ruby](https://charm-ruby.dev).\n\n## Installation\n\n```bash\ngem install {project-name}\n```\n\n## Usage\n\n```bash\n{project-name}\n```\n\n## Development\n\n```bash\nbundle install\nbundle exec rake spec\n```\n\n## License\n\nMIT\n```\n\n#### LICENSE.txt\n\nUse MIT license template with current year.\n\n#### spec/{project_name}_spec.rb\n\n```ruby\n# frozen_string_literal: true\n\nRSpec.describe {ModuleName} do\n  it \"has a version number\" do\n    expect({ModuleName}::VERSION).not_to be_nil\n  end\nend\n```\n\n### 4. Post-Creation Steps\n\nAfter creating all files:\n\n1. Make the bin file executable:\n   ```bash\n   chmod +x {project-name}/bin/{project-name}\n   ```\n\n2. Initialize git repository:\n   ```bash\n   cd {project-name} && git init\n   ```\n\n3. Display next steps to the user:\n   ```\n   ✅ Created {project-name}!\n\n   Next steps:\n     cd {project-name}\n     bundle install\n     bundle exec bin/{project-name}\n\n   To publish to RubyGems:\n     gem build {project-name}.gemspec\n     gem push {project-name}-0.1.0.gem\n   ```\n",
        "commands/package.md": "---\nname: package\ndescription: Prepare a charm-ruby CLI project for RubyGems distribution\nallowed-tools:\n  - Read\n  - Edit\n  - Write\n  - Bash\n  - Glob\n  - Grep\n  - AskUserQuestion\n---\n\n# Package for RubyGems Distribution\n\nPrepare the charm-ruby CLI project for publishing to RubyGems.org by validating and updating the gemspec, checking file permissions, and providing publishing instructions.\n\n## Workflow\n\n### 1. Verify Project Structure\n\nConfirm this is a valid gem project by checking for:\n- `*.gemspec` file\n- `lib/*/version.rb` with VERSION constant\n- `bin/` directory with executable(s)\n- `Gemfile`\n\nIf missing critical files, inform the user what needs to be created.\n\n### 2. Validate Gemspec\n\nRead the gemspec file and check for:\n\n#### Required Fields\n\n- `spec.name` - Must be set and valid\n- `spec.version` - Should reference VERSION constant\n- `spec.authors` - Must not be placeholder\n- `spec.email` - Must not be placeholder\n- `spec.summary` - Should be meaningful (not default text)\n- `spec.homepage` - Should be a valid URL\n- `spec.license` - Should be specified\n\n#### Recommended Fields\n\n- `spec.description` - Longer than summary\n- `spec.metadata` - homepage_uri, source_code_uri, changelog_uri\n- `spec.required_ruby_version` - Should be specified\n\nIf any required field has placeholder values like \"TODO\", \"Your Name\", or \"you@example.com\", ask the user:\n\n```\nYour gemspec has placeholder values that need updating:\n\n• authors: Currently \"Your Name\" - What's your name?\n• email: Currently \"you@example.com\" - What's your email?\n• homepage: Not set - What's the project URL? (e.g., GitHub repo)\n```\n\nUpdate the gemspec with the user's answers.\n\n### 3. Check Version\n\nRead `lib/*/version.rb` and display current version:\n\n```\nCurrent version: 0.1.0\n```\n\nAsk if the user wants to bump the version before publishing:\n\n```\nDo you want to update the version before publishing?\n• Keep 0.1.0\n• Bump patch (0.1.1)\n• Bump minor (0.2.0)\n• Bump major (1.0.0)\n• Custom version\n```\n\nIf they choose to bump, update the version.rb file.\n\n### 4. Verify Executable Permissions\n\nCheck that files in `bin/` are executable:\n\n```bash\nls -la bin/\n```\n\nIf any are not executable, fix them:\n\n```bash\nchmod +x bin/*\n```\n\n### 5. Check for Required Files\n\nVerify these files exist:\n- `README.md` - Package documentation\n- `LICENSE.txt` or `LICENSE` - License file\n- `CHANGELOG.md` - Version history (optional but recommended)\n\nIf CHANGELOG.md doesn't exist, offer to create a template:\n\n```markdown\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\n## [Unreleased]\n\n## [{version}] - {date}\n\n### Added\n- Initial release\n```\n\n### 6. Validate Dependencies\n\nCheck the gemspec dependencies against the Gemfile:\n- Ensure all runtime dependencies are in gemspec\n- Verify version constraints are appropriate\n\nIf using `huh` from GitHub, warn:\n\n```\nNote: 'huh' is installed from GitHub. For gem publishing, ensure\nusers can install it. Add installation note to README.\n```\n\n### 7. Run Pre-flight Checks\n\nExecute validation commands:\n\n```bash\n# Validate gemspec syntax\nruby -e \"require 'rubygems'; spec = Gem::Specification.load('{gemspec}'); puts 'Gemspec valid!'\"\n\n# Check for uncommitted changes (optional)\ngit status --porcelain\n```\n\n### 8. Build the Gem\n\nBuild the gem file:\n\n```bash\ngem build {project-name}.gemspec\n```\n\nVerify the .gem file was created and show its size:\n\n```\n✓ Built {project-name}-{version}.gem (12.5 KB)\n```\n\n### 9. Display Publishing Instructions\n\nShow the final steps to publish:\n\n```\n✅ Package ready for publishing!\n\nTo publish to RubyGems.org:\n\n  1. Create account at https://rubygems.org/sign_up (if needed)\n\n  2. Configure credentials:\n     gem signin\n\n  3. Push the gem:\n     gem push {project-name}-{version}.gem\n\n  4. Tag the release in git:\n     git tag v{version}\n     git push origin v{version}\n\nAfter publishing, users can install with:\n  gem install {project-name}\n```\n\n### 10. Checklist Summary\n\nDisplay a summary checklist:\n\n```\nPre-publish Checklist:\n\n✓ Gemspec validates successfully\n✓ Version set to {version}\n✓ Author and email configured\n✓ Homepage URL set\n✓ License specified\n✓ README.md exists\n✓ Executables are executable\n✓ Gem builds successfully\n\n{Optional warnings if any}\n\nReady to publish!\n```\n\n## Common Issues\n\n### \"Couldn't find {project-name}.gemspec\"\n\nThe gemspec file name must match the gem name exactly.\n\n### \"License identifier unknown\"\n\nUse standard SPDX license identifiers: MIT, Apache-2.0, GPL-3.0, etc.\n\n### \"Homepage has no value\"\n\nSet a valid URL, typically the GitHub repository.\n\n### Permission denied on executable\n\nRun `chmod +x bin/{executable}` to fix.\n\n### Git not clean\n\nCommit all changes before publishing to ensure the gem includes latest code:\n```bash\ngit add -A && git commit -m \"Prepare v{version} release\"\n```\n",
        "skills/charm-ruby-development/SKILL.md": "# Charm Ruby Development\n\nThis skill provides comprehensive guidance for building beautiful, interactive command-line applications in Ruby using the charm-ruby ecosystem (bubbletea, lipgloss, bubbles, huh, glamour, harmonica, gum, bubblezone, ntcharts). It helps users design CLI tools with Bubble Tea's Model-View-Update architecture, style terminal output with Lipgloss, integrate pre-built Bubbles components, create interactive forms with Huh, add mouse support with Bubblezone, render terminal charts with ntcharts, and package CLI tools as Ruby gems for distribution on RubyGems.org.\n\nUse this skill when the user asks about:\n- Building CLI tools or TUI applications with Ruby\n- Using charm-ruby, bubbletea, lipgloss, bubbles, huh, glamour, harmonica, gum, bubblezone, or ntcharts\n- Terminal user interfaces in Ruby\n- Interactive command-line applications\n- Mouse events in terminal applications\n- Terminal charts and data visualization\n- Distributing Ruby CLI tools as gems\n\n> **Note**: The charm-ruby gems are Ruby ports of the original Go libraries from Charm.sh. While the API is similar, some Go-specific patterns (like Goroutine initialization) have been adapted for Ruby. If you encounter unexpected behavior, check that you're using the Ruby-specific patterns shown in this documentation.\n\n---\n\n## Quick Start\n\nInstall the core charm-ruby gems:\n\n```ruby\n# Gemfile\ngem \"bubbletea\"    # MVU architecture\ngem \"lipgloss\"     # Terminal styling\ngem \"bubbles\"      # Pre-built components\ngem \"glamour\"      # Markdown rendering\ngem \"harmonica\"    # Spring animations\ngem \"gum\"          # Shell script helpers\ngem \"bubblezone\"   # Mouse event zones\ngem \"ntcharts\"     # Terminal charts\n\n# Huh requires GitHub install until gem name resolved\ngem \"huh\", github: \"marcoroth/huh-ruby\"\n```\n\nThen run `bundle install`.\n\n---\n\n## Bubble Tea: Model-View-Update Architecture\n\nBubble Tea implements the Elm-inspired MVU pattern for building interactive terminal applications. Every Bubble Tea app has three core methods:\n\n1. **init**: Initialize state and optionally return startup commands\n2. **update**: Handle messages (user input, command results) and return new state\n3. **view**: Render current state as a string for display\n\n### Basic Structure\n\n```ruby\nrequire \"bubbletea\"\n\nclass MyModel\n  include Bubbletea::Model\n\n  def initialize\n    @count = 0\n  end\n\n  def init\n    nil  # No initial command\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"q\", \"ctrl+c\"\n        return self, Bubbletea.quit\n      when \"up\", \"k\"\n        @count += 1\n      when \"down\", \"j\"\n        @count -= 1\n      end\n    end\n    [self, nil]\n  end\n\n  def view\n    \"Count: #{@count}\\n\\nPress up/down to change, q to quit\"\n  end\nend\n\nBubbletea.run(MyModel.new)\n```\n\n### Key Concepts\n\n- **Messages**: Events like `KeyMsg`, `MouseMsg`, or custom messages from commands\n- **Commands**: Async operations that return messages when complete\n- **Model immutability**: Return new state from `update`, don't mutate in place\n\nFor detailed architecture patterns, see `references/bubble-tea-architecture.md`.\n\n---\n\n## Lipgloss: Terminal Styling\n\nLipgloss provides CSS-like styling for terminal output with support for colors, borders, padding, margins, and alignment.\n\n### Style Basics\n\n```ruby\nrequire \"lipgloss\"\n\n# Create a style with method chaining\nstyle = Lipgloss::Style.new\n  .bold(true)\n  .foreground(\"#FAFAFA\")\n  .background(\"#7D56F4\")\n  .padding(1, 2)\n  .border(:rounded)\n  .border_foreground(\"#FF0000\")\n\n# Apply style to text\nstyled_text = style.render(\"Hello, World!\")\nputs styled_text\n```\n\n### Color Support\n\nLipgloss automatically adapts to terminal capabilities:\n\n- **ANSI 16**: Basic terminal colors\n- **ANSI 256**: Extended color palette\n- **True Color**: 24-bit hex colors like `\"#FF5733\"`\n- **Adaptive**: Automatically adjusts for light/dark backgrounds\n\n```ruby\n# Adaptive color (light bg / dark bg)\nstyle = Lipgloss::Style.new\n  .foreground(Lipgloss.adaptive_color(\"#000000\", \"#FFFFFF\"))\n```\n\n### Layout Primitives\n\n```ruby\n# Padding: top, right, bottom, left (or single value for all)\nstyle.padding(1, 2, 1, 2)\n\n# Margins\nstyle.margin(1, 2)\n\n# Width and alignment\nstyle.width(40).align(:center)\n\n# Borders: :normal, :rounded, :double, :thick, :hidden\nstyle.border(:rounded).border_foreground(\"#888888\")\n```\n\nFor complete styling reference, see `references/lipgloss-styling.md`.\n\n---\n\n## Bubbles: Pre-Built Components\n\nBubbles provides ready-to-use components that integrate with Bubble Tea's MVU architecture.\n\n### Available Components\n\n| Component | Purpose |\n|-----------|---------|\n| Spinner | Animated loading indicators |\n| TextInput | Single-line text input with cursor |\n| TextArea | Multi-line text editing |\n| List | Scrollable, selectable item list |\n| Table | Formatted data tables |\n| Progress | Progress bar with percentage |\n| Viewport | Scrollable content area |\n\n### Using Components\n\nComponents maintain their own state and expose `update` and `view` methods:\n\n```ruby\nrequire \"bubbles\"\n\nclass MyModel\n  include Bubbletea::Model\n\n  def initialize\n    @spinner = Bubbles::Spinner.new\n    @spinner.style = :dots  # :line, :dots, :minidots, :jump, etc.\n    @loading = true\n  end\n\n  def init\n    @spinner.tick  # Start spinner animation\n  end\n\n  def update(msg)\n    if @loading\n      spinner, cmd = @spinner.update(msg)\n      @spinner = spinner\n      return [self, cmd]\n    end\n    [self, nil]\n  end\n\n  def view\n    if @loading\n      \"Loading... #{@spinner.view}\"\n    else\n      \"Done!\"\n    end\n  end\nend\n```\n\nFor all component patterns, see `references/bubbles-components.md`.\n\n---\n\n## Huh: Interactive Forms\n\nHuh simplifies building interactive forms with validation, styling, and multiple input types.\n\n### Form Building\n\n```ruby\nrequire \"huh\"\n\nform = Huh::Form.new do |f|\n  f.group do |g|\n    g.input :name, title: \"What's your name?\", placeholder: \"Enter name...\"\n    g.select :color, title: \"Favorite color?\", options: %w[Red Green Blue]\n    g.confirm :agree, title: \"Do you agree to the terms?\"\n  end\nend\n\nresult = form.run\nputs \"Name: #{result[:name]}\"\nputs \"Color: #{result[:color]}\"\nputs \"Agreed: #{result[:agree]}\"\n```\n\n### Input Types\n\n- `input`: Single-line text with optional validation\n- `text`: Multi-line text area\n- `select`: Single choice from options\n- `multi_select`: Multiple choices\n- `confirm`: Yes/No question\n\n### Validation\n\n```ruby\nf.input :email,\n  title: \"Email address\",\n  validate: ->(v) { v.include?(\"@\") ? nil : \"Invalid email\" }\n```\n\nFor complete form patterns, see `references/huh-forms.md`.\n\n---\n\n## Gum: Shell Script Helpers\n\nGum provides a Ruby interface for creating interactive shell script prompts without building full Bubble Tea applications. Perfect for quick scripts and CLI utilities.\n\n### Input Prompts\n\n```ruby\nrequire \"gum\"\n\n# Simple text input\nname = Gum.input(placeholder: \"Enter your name\")\n\n# With header and default value\nemail = Gum.input(\n  header: \"Contact Information\",\n  placeholder: \"email@example.com\",\n  value: ENV[\"USER_EMAIL\"]\n)\n```\n\n### Selection Menus\n\n```ruby\n# Single selection\ncolor = Gum.choose(\"Red\", \"Green\", \"Blue\", header: \"Pick a color\")\n\n# Multiple selection\nfeatures = Gum.choose(\n  \"Authentication\",\n  \"Database\",\n  \"API\",\n  \"Testing\",\n  header: \"Select features to enable\",\n  no_limit: true  # Allow multiple selections\n)\n```\n\n### Confirmations\n\n```ruby\n# Simple yes/no\nif Gum.confirm(\"Delete all files?\")\n  delete_files\nend\n\n# With custom prompt\nproceed = Gum.confirm(\n  \"Deploy to production?\",\n  affirmative: \"Yes, deploy\",\n  negative: \"No, cancel\"\n)\n```\n\n### Spinners for Long Operations\n\n```ruby\n# Show spinner while executing a block\nresult = Gum.spin(title: \"Installing dependencies...\") do\n  system(\"bundle install\")\nend\n\n# With custom spinner style\nGum.spin(title: \"Building project...\", spinner: :dots) do\n  system(\"rake build\")\nend\n```\n\n### Filtering Lists\n\n```ruby\n# Interactive fuzzy filter\nselected = Gum.filter(\n  items,\n  placeholder: \"Search...\",\n  header: \"Select a file\"\n)\n```\n\n### Styled Output\n\n```ruby\n# Print styled text\nGum.style(\"Success!\", foreground: \"#00FF00\", bold: true)\n\n# Create a styled box\nGum.style(\n  \"Welcome to My CLI\",\n  border: :rounded,\n  padding: \"1 2\",\n  foreground: \"#FFFFFF\",\n  background: \"#7D56F4\"\n)\n```\n\n---\n\n## Composing Applications\n\nLarger applications compose multiple components and screens:\n\n### Multi-Screen Pattern\n\n```ruby\nclass App\n  include Bubbletea::Model\n\n  SCREEN_MENU = :menu\n  SCREEN_FORM = :form\n  SCREEN_RESULT = :result\n\n  def initialize\n    @screen = SCREEN_MENU\n    @menu = MenuModel.new\n    @form = FormModel.new\n    @result = nil\n  end\n\n  def update(msg)\n    case @screen\n    when SCREEN_MENU\n      @menu, cmd = @menu.update(msg)\n      if @menu.selected\n        @screen = SCREEN_FORM\n      end\n    when SCREEN_FORM\n      @form, cmd = @form.update(msg)\n      if @form.submitted\n        @result = process(@form.data)\n        @screen = SCREEN_RESULT\n      end\n    end\n    [self, cmd]\n  end\n\n  def view\n    case @screen\n    when SCREEN_MENU then @menu.view\n    when SCREEN_FORM then @form.view\n    when SCREEN_RESULT then render_result(@result)\n    end\n  end\nend\n```\n\n---\n\n## Best Practices\n\n### Performance\n- Keep `view` methods fast; avoid heavy computation\n- Use commands for async operations (file I/O, network)\n- Batch style creation; don't recreate styles every render\n- Only re-render when state actually changes\n\n### Testing\n- Test `update` logic by calling with mock messages\n- Verify state transitions independently from rendering\n- Use Aruba gem for integration testing of complete CLI\n- See `references/testing-tui-applications.md` for comprehensive patterns\n\n### Error Handling\n- Catch errors in commands and return error messages\n- Display user-friendly error messages with styled output\n- Provide clear feedback for invalid input in forms\n- Use meaningful exit codes (0 success, non-zero errors)\n- Send errors to stderr, output to stdout\n\n### User Experience\n- Support vim-style keys (j/k/h/l) alongside arrows\n- Always show quit instructions (q or Ctrl+C)\n- Use spinners for any operation over 100ms\n- Provide progress feedback for long operations\n- Show concise, meaningful output (avoid verbose confirmations)\n- See `references/cli-ux-best-practices.md` for comprehensive UX patterns\n\n### Accessibility\n- Respect `NO_COLOR` environment variable\n- Don't rely solely on color to convey meaning (use symbols too)\n- Support `--no-color` flag for explicit control\n- Use ANSI 16 colors for maximum terminal compatibility\n- Provide JSON output mode for machine parsing\n- See `references/accessibility-guidelines.md` for complete guidelines\n\n---\n\n## Distribution\n\nPackage your CLI as a Ruby gem for easy installation via RubyGems.org.\n\n### Project Structure\n\n```\nmy-cli/\n├── Gemfile\n├── my-cli.gemspec\n├── bin/\n│   └── my-cli          # Executable\n├── lib/\n│   ├── my_cli.rb       # Main entry\n│   └── my_cli/\n│       ├── version.rb\n│       ├── cli.rb      # CLI class\n│       └── model.rb    # Bubble Tea model\n└── README.md\n```\n\n### Gemspec Essentials\n\n```ruby\nGem::Specification.new do |spec|\n  spec.name          = \"my-cli\"\n  spec.version       = MyCli::VERSION\n  spec.authors       = [\"Your Name\"]\n  spec.summary       = \"A beautiful CLI tool\"\n\n  spec.executables   = [\"my-cli\"]\n  spec.require_paths = [\"lib\"]\n\n  spec.add_dependency \"bubbletea\"\n  spec.add_dependency \"lipgloss\"\n  spec.add_dependency \"bubbles\"\n\n  spec.required_ruby_version = \">= 2.7.0\"\nend\n```\n\nFor complete distribution guide, see `references/gem-distribution.md`.\n\n---\n\n## Examples\n\nWorking code examples are available in the `examples/` directory:\n\n- `simple-counter.rb` - Minimal Bubble Tea application\n- `interactive-form.rb` - Huh form with validation\n- `styled-list.rb` - Lipgloss-styled selectable list\n- `progress-spinner.rb` - Async operation with spinner feedback\n\n---\n\n## Additional Features\n\nFor advanced functionality, see the detailed reference guides:\n\n- `references/ntcharts-visualization.md` - Terminal charts (sparklines, bar charts, line charts, heatmaps)\n- `references/bubblezone-mouse.md` - Mouse event handling and clickable zones\n- `references/harmonica-animation.md` - Spring physics animations with angular_frequency and damping_ratio\n\n## UX, Accessibility, and Testing\n\nFor building production-quality CLI applications:\n\n- `references/cli-ux-best-practices.md` - Comprehensive CLI UX patterns (errors, help, progress, colors)\n- `references/accessibility-guidelines.md` - NO_COLOR support, screen readers, keyboard navigation\n- `references/testing-tui-applications.md` - Unit testing models, integration testing with Aruba\n\n---\n\n## Resources\n\n- [charm-ruby.dev](https://charm-ruby.dev) - Official documentation\n- [marcoroth.dev/posts/glamorous-christmas](https://marcoroth.dev/posts/glamorous-christmas) - Comprehensive overview blog post\n- [marcoroth/bubbletea-ruby](https://github.com/marcoroth/bubbletea-ruby) - Bubble Tea source\n- [marcoroth/lipgloss-ruby](https://github.com/marcoroth/lipgloss-ruby) - Lipgloss source\n- [charm.sh](https://charm.sh) - Original Go libraries documentation\n",
        "skills/charm-ruby-development/references/accessibility-guidelines.md": "# Terminal Accessibility Guidelines\n\nThis reference covers best practices for building accessible CLI and TUI applications that work for all users.\n\n---\n\n## Color Accessibility\n\n### Respect NO_COLOR\n\nThe `NO_COLOR` environment variable is a standard that users set when they want applications to disable color output. Always respect it:\n\n```ruby\ndef color_enabled?\n  !ENV.key?(\"NO_COLOR\") && $stdout.tty?\nend\n\ndef styled_output(text, style)\n  if color_enabled?\n    style.render(text)\n  else\n    text\n  end\nend\n```\n\n### Provide --no-color Flag\n\nAlso support explicit flag control:\n\n```ruby\n# Parse arguments\nno_color = ARGV.include?(\"--no-color\")\n\n# Disable colors if flag present\nLipgloss.no_color = no_color if no_color\n```\n\n### ANSI vs True Color\n\nNot all terminals support 24-bit (true color). Use adaptive colors that degrade gracefully:\n\n```ruby\n# Prefer ANSI 16 colors for maximum compatibility\n# These work on virtually all terminals:\nANSI_COLORS = {\n  black: \"0\",\n  red: \"1\",\n  green: \"2\",\n  yellow: \"3\",\n  blue: \"4\",\n  magenta: \"5\",\n  cyan: \"6\",\n  white: \"7\"\n}\n\n# Lipgloss handles degradation automatically:\n# True Color → ANSI 256 → ANSI 16 → No color\n\n# For critical information, use ANSI 16 colors directly:\nstyle = Lipgloss::Style.new.foreground(\"1\")  # ANSI red\n```\n\n### Don't Rely Solely on Color\n\nColor should enhance, not convey essential meaning alone:\n\n```ruby\n# Bad: Color is the only indicator\ndef status(success)\n  color = success ? \"#00FF00\" : \"#FF0000\"\n  Lipgloss::Style.new.foreground(color).render(\"●\")\nend\n\n# Good: Symbol + color provides redundancy\ndef status(success)\n  if success\n    style = Lipgloss::Style.new.foreground(\"#00FF00\")\n    style.render(\"✓ Success\")\n  else\n    style = Lipgloss::Style.new.foreground(\"#FF0000\")\n    style.render(\"✗ Failed\")\n  end\nend\n```\n\n### High Contrast\n\nEnsure sufficient contrast between foreground and background:\n\n```ruby\n# Good: High contrast combinations\nLipgloss::Style.new\n  .foreground(\"#FFFFFF\")  # White text\n  .background(\"#000000\")  # Black background\n\n# Use adaptive colors for different themes\nLipgloss::Style.new\n  .foreground(Lipgloss.adaptive_color(\"#000000\", \"#FFFFFF\"))\n```\n\n---\n\n## Screen Reader Compatibility\n\n### Structured Output\n\nScreen readers parse terminal output linearly. Structure output clearly:\n\n```ruby\n# Good: Clear sections with headers\ndef render_report(data)\n  <<~REPORT\n    === Build Report ===\n\n    Status: #{data.status}\n    Duration: #{data.duration}s\n    Files: #{data.file_count}\n\n    === Warnings ===\n    #{data.warnings.map { |w| \"• #{w}\" }.join(\"\\n\")}\n\n    === Next Steps ===\n    #{data.next_steps.map { |s| \"• #{s}\" }.join(\"\\n\")}\n  REPORT\nend\n```\n\n### Avoid Decorative Characters\n\nExcessive decoration interferes with screen readers:\n\n```ruby\n# Bad: Decorative noise\nputs \"╔════════════════════════════════╗\"\nputs \"║     Welcome to My CLI!         ║\"\nputs \"╚════════════════════════════════╝\"\n\n# Good: Simple, parseable output\nputs \"=== Welcome to My CLI ===\"\nputs \"\"\n```\n\n### Announce State Changes\n\nWhen state changes in interactive apps, make it clear:\n\n```ruby\ndef update(msg)\n  case msg\n  when SelectionChanged\n    @selected = msg.item\n    # Clear announcement for screen readers\n    @announcement = \"Selected: #{msg.item.name}\"\n  end\n  [self, nil]\nend\n\ndef view\n  content = render_list\n  # Include announcement in output\n  announcement = @announcement ? \"\\n#{@announcement}\" : \"\"\n  \"#{content}#{announcement}\"\nend\n```\n\n---\n\n## Keyboard Navigation\n\n### Full Keyboard Support\n\nEvery action should be achievable via keyboard:\n\n```ruby\nKEYBINDINGS = {\n  \"up\" => :prev_item,      \"k\" => :prev_item,\n  \"down\" => :next_item,    \"j\" => :next_item,\n  \"enter\" => :select,      \" \" => :toggle,\n  \"tab\" => :next_section,  \"shift+tab\" => :prev_section,\n  \"?\" => :show_help,       \"q\" => :quit,\n  \"ctrl+c\" => :quit\n}\n\ndef update(msg)\n  case msg\n  when Bubbletea::KeyMsg\n    action = KEYBINDINGS[msg.string]\n    send(action) if action && respond_to?(action, true)\n  end\n  [self, nil]\nend\n```\n\n### Focus Indicators\n\nMake it clear which element has focus:\n\n```ruby\ndef render_item(item, focused)\n  if focused\n    style = Lipgloss::Style.new\n      .foreground(\"#FFFFFF\")\n      .background(\"#7D56F4\")\n      .bold(true)\n    style.render(\"> #{item.name}\")\n  else\n    \"  #{item.name}\"\n  end\nend\n```\n\n### Skip Navigation\n\nFor long lists or complex UIs, provide shortcuts:\n\n```ruby\n# Jump to positions\nwhen \"g\" then @cursor = 0              # Top\nwhen \"G\" then @cursor = @items.length - 1  # Bottom\nwhen \"ctrl+d\" then @cursor += 10       # Page down\nwhen \"ctrl+u\" then @cursor -= 10       # Page up\n```\n\n---\n\n## Alternative Output Modes\n\n### Machine-Readable Output\n\nSupport JSON or structured output for scripts and assistive tools:\n\n```ruby\nif ENV[\"OUTPUT_FORMAT\"] == \"json\"\n  puts JSON.pretty_generate({\n    status: \"success\",\n    files_processed: 42,\n    warnings: warnings\n  })\nelse\n  puts \"Processed 42 files with #{warnings.count} warnings\"\nend\n```\n\n### Quiet Mode\n\nAllow silencing non-essential output:\n\n```ruby\ndef log(message, level: :info)\n  return if @quiet && level != :error\n\n  case level\n  when :error then $stderr.puts \"Error: #{message}\"\n  when :warn then puts \"Warning: #{message}\"\n  else puts message\n  end\nend\n```\n\n### Verbose Mode\n\nProvide detailed output when requested:\n\n```ruby\ndef debug(message)\n  puts \"[DEBUG] #{message}\" if @verbose\nend\n```\n\n---\n\n## Text and Typography\n\n### Avoid Fancy Unicode\n\nNot all terminals/fonts render Unicode equally:\n\n```ruby\n# Risky: May not render correctly\nputs \"→ Next step\"\nputs \"★ Featured\"\nputs \"◉ Selected\"\n\n# Safe: ASCII alternatives\nputs \"-> Next step\"\nputs \"* Featured\"\nputs \"[x] Selected\"\n```\n\n### Configurable Symbols\n\nLet users customize symbols:\n\n```ruby\nDEFAULT_SYMBOLS = {\n  success: \"✓\",\n  error: \"✗\",\n  warning: \"⚠\",\n  arrow: \"→\",\n  bullet: \"•\"\n}\n\nASCII_SYMBOLS = {\n  success: \"[ok]\",\n  error: \"[ERR]\",\n  warning: \"[!]\",\n  arrow: \"->\",\n  bullet: \"*\"\n}\n\ndef symbols\n  @ascii_mode ? ASCII_SYMBOLS : DEFAULT_SYMBOLS\nend\n```\n\n### Word Wrapping\n\nWrap long lines at word boundaries:\n\n```ruby\ndef wrap_text(text, width)\n  text.gsub(/(.{1,#{width}})(\\s+|$)/, \"\\\\1\\n\").strip\nend\n\n# Or use Lipgloss width constraints\nstyle = Lipgloss::Style.new.width(60)\nputs style.render(long_text)\n```\n\n---\n\n## Animation and Motion\n\n### Reduce Motion Option\n\nSome users experience motion sensitivity:\n\n```ruby\ndef animation_enabled?\n  !ENV.key?(\"REDUCE_MOTION\")\nend\n\ndef spinner_view\n  if animation_enabled?\n    @spinner.view\n  else\n    \"[loading]\"  # Static alternative\n  end\nend\n```\n\n### Reasonable Animation Speed\n\nAvoid flickering or rapid updates:\n\n```ruby\n# Spinner tick rate: ~100ms is comfortable\n# Progress updates: No more than 10 per second\n# Screen refreshes: Only when state changes\n\ndef update(msg)\n  case msg\n  when Bubbletea::TickMsg\n    # Throttle updates\n    return [self, nil] if (Time.now - @last_update) < 0.1\n    @last_update = Time.now\n    # ... update logic\n  end\nend\n```\n\n---\n\n## Error Handling for Accessibility\n\n### Descriptive Errors\n\nErrors should be self-explanatory:\n\n```ruby\n# Bad\nputs \"Error: ENOENT\"\n\n# Good\nputs \"Error: File not found: /path/to/config.yml\"\nputs \"Expected a configuration file at this location.\"\nputs \"Run 'myapp init' to create a default configuration.\"\n```\n\n### Error Placement\n\nSend errors to stderr so they can be separated from output:\n\n```ruby\ndef error(message)\n  $stderr.puts \"Error: #{message}\"\nend\n\ndef warn(message)\n  $stderr.puts \"Warning: #{message}\"\nend\n```\n\n### Exit Codes\n\nUse meaningful exit codes for scripting:\n\n```ruby\nEXIT_SUCCESS = 0\nEXIT_ERROR = 1\nEXIT_USAGE = 2\nEXIT_NOT_FOUND = 66\n\nbegin\n  run_command\n  exit(EXIT_SUCCESS)\nrescue ArgumentError => e\n  $stderr.puts \"Invalid argument: #{e.message}\"\n  exit(EXIT_USAGE)\nrescue FileNotFoundError => e\n  $stderr.puts \"File not found: #{e.message}\"\n  exit(EXIT_NOT_FOUND)\nrescue => e\n  $stderr.puts \"Error: #{e.message}\"\n  exit(EXIT_ERROR)\nend\n```\n\n---\n\n## Testing Accessibility\n\n### Checklist\n\nBefore release, verify:\n\n- [ ] Works with `NO_COLOR=1`\n- [ ] Works in 80-column terminal\n- [ ] All actions have keyboard shortcuts\n- [ ] Help text is comprehensive\n- [ ] Error messages are descriptive\n- [ ] Output makes sense without color\n- [ ] Works with common screen readers\n- [ ] JSON output mode available\n\n### Automated Tests\n\n```ruby\nRSpec.describe \"Accessibility\" do\n  it \"respects NO_COLOR\" do\n    ENV[\"NO_COLOR\"] = \"1\"\n    output = capture_output { run_command }\n    expect(output).not_to include(\"\\e[\")  # No ANSI codes\n  end\n\n  it \"provides JSON output\" do\n    ENV[\"OUTPUT_FORMAT\"] = \"json\"\n    output = capture_output { run_command }\n    expect { JSON.parse(output) }.not_to raise_error\n  end\n\n  it \"handles narrow terminals\" do\n    ENV[\"COLUMNS\"] = \"40\"\n    output = capture_output { run_command }\n    expect(output.lines.map(&:length).max).to be <= 40\n  end\nend\n```\n\n---\n\n## Resources\n\n- [NO_COLOR Standard](https://no-color.org/)\n- [WCAG Guidelines](https://www.w3.org/WAI/standards-guidelines/wcag/)\n- [Inclusive Design Principles](https://inclusivedesignprinciples.org/)\n- [A11y Project](https://www.a11yproject.com/)\n",
        "skills/charm-ruby-development/references/bubble-tea-architecture.md": "# Bubble Tea Architecture Reference\n\n## The Model-View-Update Pattern\n\nBubble Tea implements the Elm architecture, creating a unidirectional data flow:\n\n```\nUser Input → Message → Update → New Model → View → Terminal Output\n                ↑                              |\n                └──────── Commands ────────────┘\n```\n\n## Core Components\n\n### Model\n\nThe Model holds all application state. It must include `Bubbletea::Model` and implement three methods:\n\n```ruby\nclass MyModel\n  include Bubbletea::Model\n\n  attr_reader :items, :cursor, :selected\n\n  def initialize\n    @items = []\n    @cursor = 0\n    @selected = Set.new\n    @loading = false\n    @error = nil\n  end\n\n  def init\n    # Called once at startup\n    # Return a Command or nil\n    load_items_cmd\n  end\n\n  def update(msg)\n    # Handle messages, return [new_model, command]\n    # ...\n    [self, nil]\n  end\n\n  def view\n    # Return string to display\n    # ...\n  end\nend\n```\n\n### Messages\n\nMessages are events that trigger state updates:\n\n```ruby\n# Built-in messages\nBubbletea::KeyMsg        # Keyboard input\nBubbletea::MouseMsg      # Mouse events\nBubbletea::WindowSizeMsg # Terminal resize\n\n# Custom messages (use Struct or class)\nLoadedItemsMsg = Struct.new(:items)\nErrorMsg = Struct.new(:error)\nTickMsg = Struct.new(:time)\n```\n\n### Commands\n\nCommands are functions that perform side effects and return messages:\n\n```ruby\n# Simple command returning a message\ndef load_items_cmd\n  Bubbletea.cmd do\n    items = fetch_items_from_api\n    LoadedItemsMsg.new(items)\n  rescue => e\n    ErrorMsg.new(e.message)\n  end\nend\n\n# Batch multiple commands\nBubbletea.batch(\n  load_items_cmd,\n  start_timer_cmd\n)\n\n# Quit command\nBubbletea.quit\n\n# No-op (nil is also valid)\nBubbletea.none\n```\n\n## Handling Input\n\n### Keyboard Input\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::KeyMsg\n    handle_key(msg)\n  else\n    [self, nil]\n  end\nend\n\ndef handle_key(msg)\n  case msg.string\n  # Movement\n  when \"up\", \"k\"\n    @cursor = [@cursor - 1, 0].max\n  when \"down\", \"j\"\n    @cursor = [@cursor + 1, @items.length - 1].min\n  when \"g\"\n    @cursor = 0  # Go to top\n  when \"G\"\n    @cursor = @items.length - 1  # Go to bottom\n\n  # Actions\n  when \"enter\"\n    return [self, select_item_cmd(@items[@cursor])]\n  when \" \"  # Space\n    toggle_selection(@cursor)\n\n  # Quit\n  when \"q\", \"esc\"\n    return [self, Bubbletea.quit]\n  when \"ctrl+c\"\n    return [self, Bubbletea.quit]\n  end\n\n  [self, nil]\nend\n```\n\n### Mouse Input\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::MouseMsg\n    if msg.button == :left && msg.action == :press\n      # msg.x and msg.y contain coordinates\n      handle_click(msg.x, msg.y)\n    elsif msg.action == :wheel_up\n      scroll_up\n    elsif msg.action == :wheel_down\n      scroll_down\n    end\n  end\n  [self, nil]\nend\n```\n\n### Window Resize\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::WindowSizeMsg\n    @width = msg.width\n    @height = msg.height\n    recalculate_layout\n  end\n  [self, nil]\nend\n```\n\n## State Management Patterns\n\n### Immutable Updates\n\nPrefer returning new state rather than mutating:\n\n```ruby\n# Good: Create new state\ndef update(msg)\n  new_items = @items + [msg.item]\n  new_model = self.class.new\n  new_model.instance_variable_set(:@items, new_items)\n  [new_model, nil]\nend\n\n# Also acceptable: Mutate and return self\ndef update(msg)\n  @items << msg.item\n  [self, nil]\nend\n```\n\n### Derived State\n\nCalculate derived values in `view`, not `update`:\n\n```ruby\ndef view\n  # Calculate here, not stored in model\n  visible_items = @items[@offset, @page_size]\n  total_pages = (@items.length / @page_size.to_f).ceil\n  current_page = @offset / @page_size + 1\n\n  render_list(visible_items, current_page, total_pages)\nend\n```\n\n### State Machines\n\nUse explicit states for complex flows:\n\n```ruby\nclass WizardModel\n  STATES = [:welcome, :input_name, :input_email, :confirm, :complete]\n\n  def initialize\n    @state = :welcome\n    @data = {}\n  end\n\n  def update(msg)\n    case @state\n    when :welcome\n      if msg.is_a?(Bubbletea::KeyMsg) && msg.string == \"enter\"\n        @state = :input_name\n      end\n    when :input_name\n      if msg.is_a?(NameSubmittedMsg)\n        @data[:name] = msg.name\n        @state = :input_email\n      end\n    # ... etc\n    end\n    [self, nil]\n  end\nend\n```\n\n## Async Operations\n\n### Long-Running Tasks\n\nUse commands for operations that take time:\n\n```ruby\ndef fetch_data_cmd\n  Bubbletea.cmd do\n    # This runs in a separate fiber/thread\n    response = HTTP.get(\"https://api.example.com/data\")\n    DataLoadedMsg.new(JSON.parse(response.body))\n  rescue => e\n    ErrorMsg.new(e.message)\n  end\nend\n\ndef update(msg)\n  case msg\n  when Bubbletea::KeyMsg\n    if msg.string == \"r\"  # Refresh\n      @loading = true\n      return [self, fetch_data_cmd]\n    end\n  when DataLoadedMsg\n    @loading = false\n    @data = msg.data\n  when ErrorMsg\n    @loading = false\n    @error = msg.error\n  end\n  [self, nil]\nend\n```\n\n### Timers and Ticks\n\nCreate periodic updates:\n\n```ruby\ndef tick_cmd(interval = 0.1)\n  Bubbletea.tick(interval) do |time|\n    TickMsg.new(time)\n  end\nend\n\ndef update(msg)\n  case msg\n  when TickMsg\n    @frame = (@frame + 1) % @animation_frames.length\n    return [self, tick_cmd]  # Schedule next tick\n  end\n  [self, nil]\nend\n\ndef init\n  tick_cmd  # Start the tick loop\nend\n```\n\n## Composing Models\n\n### Sub-Models\n\nBreak complex UIs into composable pieces:\n\n```ruby\nclass AppModel\n  def initialize\n    @header = HeaderModel.new\n    @sidebar = SidebarModel.new\n    @content = ContentModel.new\n    @focus = :content\n  end\n\n  def update(msg)\n    # Route to focused sub-model\n    case @focus\n    when :sidebar\n      @sidebar, cmd = @sidebar.update(msg)\n    when :content\n      @content, cmd = @content.update(msg)\n    end\n\n    # Handle navigation between sections\n    if msg.is_a?(Bubbletea::KeyMsg) && msg.string == \"tab\"\n      @focus = next_focus(@focus)\n    end\n\n    [self, cmd]\n  end\n\n  def view\n    [\n      @header.view,\n      horizontal_join(@sidebar.view, @content.view),\n      footer_view\n    ].join(\"\\n\")\n  end\nend\n```\n\n### Message Routing\n\nForward messages to sub-models with context:\n\n```ruby\n# Wrap sub-model messages\nSidebarMsg = Struct.new(:inner_msg)\nContentMsg = Struct.new(:inner_msg)\n\ndef update(msg)\n  case msg\n  when SidebarMsg\n    @sidebar, cmd = @sidebar.update(msg.inner_msg)\n    # Wrap any returned command\n    cmd = wrap_cmd(cmd, SidebarMsg) if cmd\n  when ContentMsg\n    @content, cmd = @content.update(msg.inner_msg)\n    cmd = wrap_cmd(cmd, ContentMsg) if cmd\n  end\n  [self, cmd]\nend\n```\n\n## Program Options\n\n### Running the Application\n\n```ruby\n# Basic run\nBubbletea.run(MyModel.new)\n\n# With options\nBubbletea.run(MyModel.new,\n  alt_screen: true,      # Use alternate screen buffer\n  mouse: true,           # Enable mouse support\n  bracketed_paste: true  # Handle paste events\n)\n\n# Run and get final model\nfinal_model = Bubbletea.run(MyModel.new)\nputs \"Final count: #{final_model.count}\"\n```\n\n### Alternate Screen\n\nUse alternate screen for full-screen apps:\n\n```ruby\n# Switches to alternate buffer, clears screen\n# Restores original screen on exit\nBubbletea.run(model, alt_screen: true)\n```\n\n## Error Handling\n\n### Graceful Degradation\n\n```ruby\ndef update(msg)\n  case msg\n  when ErrorMsg\n    @error = msg.error\n    @loading = false\n    # Don't quit, show error in UI\n  end\n  [self, nil]\nend\n\ndef view\n  if @error\n    error_style.render(\"Error: #{@error}\\nPress r to retry, q to quit\")\n  else\n    normal_view\n  end\nend\n```\n\n### Recovery Commands\n\n```ruby\ndef retry_cmd\n  Bubbletea.cmd do\n    sleep 1  # Brief delay before retry\n    RetryMsg.new\n  end\nend\n\ndef update(msg)\n  case msg\n  when ErrorMsg\n    @error = msg.error\n    @retry_count += 1\n    if @retry_count < 3\n      return [self, retry_cmd]\n    end\n  when RetryMsg\n    return [self, fetch_data_cmd]\n  end\n  [self, nil]\nend\n```\n\n## Testing\n\n### Unit Testing Update Logic\n\n```ruby\nrequire \"minitest/autorun\"\n\nclass TestMyModel < Minitest::Test\n  def test_increment\n    model = MyModel.new\n    model.instance_variable_set(:@count, 5)\n\n    key_msg = Bubbletea::KeyMsg.new(\"up\")\n    new_model, _cmd = model.update(key_msg)\n\n    assert_equal 6, new_model.instance_variable_get(:@count)\n  end\n\n  def test_quit_returns_quit_cmd\n    model = MyModel.new\n    key_msg = Bubbletea::KeyMsg.new(\"q\")\n\n    _model, cmd = model.update(key_msg)\n\n    assert_equal Bubbletea.quit, cmd\n  end\nend\n```\n\n### Testing View Output\n\n```ruby\ndef test_view_shows_count\n  model = MyModel.new\n  model.instance_variable_set(:@count, 42)\n\n  output = model.view\n\n  assert_includes output, \"42\"\n  assert_includes output, \"Press\"\nend\n```\n",
        "skills/charm-ruby-development/references/bubbles-components.md": "# Bubbles Components Reference\n\n## Overview\n\nBubbles provides pre-built, reusable components for Bubble Tea applications. Each component manages its own state and integrates via the standard `update`/`view` pattern.\n\n## Component Integration Pattern\n\nAll Bubbles components follow this pattern:\n\n```ruby\nclass MyModel\n  include Bubbletea::Model\n\n  def initialize\n    @component = Bubbles::SomeComponent.new\n  end\n\n  def init\n    @component.init  # Some components need initialization\n  end\n\n  def update(msg)\n    # Forward messages to component\n    @component, cmd = @component.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    @component.view\n  end\nend\n```\n\n## Spinner\n\nAnimated loading indicator with multiple styles.\n\n### Basic Usage\n\n```ruby\nrequire \"bubbles\"\n\nclass LoadingModel\n  include Bubbletea::Model\n\n  def initialize\n    @spinner = Bubbles::Spinner.new\n    @loading = true\n  end\n\n  def init\n    @spinner.tick  # Start animation\n  end\n\n  def update(msg)\n    return [self, Bubbletea.quit] if done_loading?\n\n    @spinner, cmd = @spinner.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    \"#{@spinner.view} Loading...\"\n  end\nend\n```\n\n### Spinner Styles\n\n```ruby\n@spinner.style = :line      # |/-\\\n@spinner.style = :dots      # ⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏\n@spinner.style = :minidots  # ⠁⠂⠄⡀⢀⠠⠐⠈\n@spinner.style = :jump      # ⢄⢂⢁⡁⡈⡐⡠\n@spinner.style = :pulse     # ░▒▓█▓▒░\n@spinner.style = :points    # ∙∙∙●∙∙\n@spinner.style = :globe     # 🌍🌎🌏\n@spinner.style = :moon      # 🌑🌒🌓🌔🌕🌖🌗🌘\n@spinner.style = :monkey    # 🙈🙉🙊\n@spinner.style = :meter     # ▱▰▱▱▱▱▱ cycling\n\n# Custom spinner frames\n@spinner.frames = [\"⠋\", \"⠙\", \"⠹\", \"⠸\", \"⠼\", \"⠴\", \"⠦\", \"⠧\", \"⠇\", \"⠏\"]\n@spinner.fps = 10  # Frames per second\n```\n\n### Styling Spinner Output\n\n```ruby\n@spinner.style = :dots\n@spinner.spinner_style = Lipgloss::Style.new.foreground(\"#FF69B4\")\n```\n\n## TextInput\n\nSingle-line text input with cursor.\n\n### Basic Usage\n\n```ruby\nclass FormModel\n  include Bubbletea::Model\n\n  def initialize\n    @input = Bubbles::TextInput.new\n    @input.placeholder = \"Enter your name...\"\n    @input.focus  # Give focus to enable input\n  end\n\n  def init\n    Bubbletea.blink  # Enable cursor blinking\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      return [self, Bubbletea.quit] if msg.string == \"enter\"\n    end\n\n    @input, cmd = @input.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    \"Name: #{@input.view}\\n\\nPress Enter to submit\"\n  end\n\n  def value\n    @input.value\n  end\nend\n```\n\n### TextInput Options\n\n```ruby\n@input = Bubbles::TextInput.new\n\n# Placeholder (shown when empty)\n@input.placeholder = \"Type here...\"\n\n# Initial value\n@input.value = \"Default text\"\n\n# Character limit\n@input.char_limit = 50\n\n# Width in characters\n@input.width = 40\n\n# Password mode (hide input)\n@input.echo_mode = :password    # Shows ••••\n@input.echo_mode = :none        # Shows nothing\n@input.echo_mode = :normal      # Default, shows text\n\n# Styling\n@input.prompt = \"> \"\n@input.prompt_style = Lipgloss::Style.new.foreground(\"#888888\")\n@input.text_style = Lipgloss::Style.new.foreground(\"#FFFFFF\")\n@input.placeholder_style = Lipgloss::Style.new.foreground(\"#555555\")\n@input.cursor_style = Lipgloss::Style.new.background(\"#FFFFFF\")\n\n# Focus handling\n@input.focus    # Enable input\n@input.blur     # Disable input\n@input.focused? # Check if focused\n```\n\n### Validation\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::KeyMsg\n    if msg.string == \"enter\"\n      if valid_email?(@input.value)\n        # Submit\n      else\n        @error = \"Invalid email format\"\n      end\n    end\n  end\n\n  @input, cmd = @input.update(msg)\n  [self, cmd]\nend\n\ndef valid_email?(value)\n  value.match?(/\\A[\\w+\\-.]+@[a-z\\d\\-]+(\\.[a-z\\d\\-]+)*\\.[a-z]+\\z/i)\nend\n```\n\n## TextArea\n\nMulti-line text editing.\n\n### Basic Usage\n\n```ruby\nclass EditorModel\n  include Bubbletea::Model\n\n  def initialize\n    @textarea = Bubbles::TextArea.new\n    @textarea.placeholder = \"Enter your message...\"\n    @textarea.focus\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      return [self, Bubbletea.quit] if msg.string == \"ctrl+d\"\n    end\n\n    @textarea, cmd = @textarea.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    header = \"Message (Ctrl+D to submit):\\n\\n\"\n    header + @textarea.view\n  end\nend\n```\n\n### TextArea Options\n\n```ruby\n@textarea = Bubbles::TextArea.new\n\n# Dimensions\n@textarea.width = 60\n@textarea.height = 10\n\n# Character/line limits\n@textarea.char_limit = 500\n@textarea.max_height = 20\n\n# Initial value\n@textarea.value = \"Starting text...\"\n\n# Line numbers\n@textarea.show_line_numbers = true\n@textarea.line_number_style = Lipgloss::Style.new.foreground(\"#666666\")\n\n# Styling\n@textarea.prompt = \"│ \"\n@textarea.cursor_style = Lipgloss::Style.new.background(\"#FFFFFF\")\n```\n\n## List\n\nScrollable, selectable item list.\n\n### Basic Usage\n\n```ruby\nclass ListModel\n  include Bubbletea::Model\n\n  def initialize(items)\n    @list = Bubbles::List.new(items)\n    @list.title = \"Select an item\"\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"q\"\n        return [self, Bubbletea.quit]\n      when \"enter\"\n        @selected = @list.selected_item\n        return [self, Bubbletea.quit]\n      end\n    end\n\n    @list, cmd = @list.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    @list.view\n  end\nend\n\n# Items can be strings or objects with `title` and `description` methods\nitems = [\n  \"Simple string item\",\n  ListItem.new(\"Item with details\", \"Additional description\")\n]\n```\n\n### List Options\n\n```ruby\n@list = Bubbles::List.new(items)\n\n# Title and styling\n@list.title = \"Choose wisely\"\n@list.title_style = Lipgloss::Style.new.bold(true)\n\n# Dimensions\n@list.width = 40\n@list.height = 15\n\n# Filtering (type to filter)\n@list.filter_enabled = true\n@list.filter_prompt = \"Filter: \"\n\n# Selection indicator\n@list.show_selected = true\n@list.selected_style = Lipgloss::Style.new.foreground(\"#FF69B4\").bold(true)\n\n# Cursor style\n@list.cursor = \"→ \"\n@list.cursor_style = Lipgloss::Style.new.foreground(\"#FF69B4\")\n\n# Pagination\n@list.show_pagination = true\n@list.pagination_style = Lipgloss::Style.new.foreground(\"#666666\")\n\n# Status bar\n@list.show_status_bar = true\n@list.status_bar_style = Lipgloss::Style.new.background(\"#333333\")\n```\n\n### Custom List Items\n\n```ruby\nclass TodoItem\n  attr_reader :title, :description, :done\n\n  def initialize(title, description, done: false)\n    @title = title\n    @description = description\n    @done = done\n  end\n\n  # Required by Bubbles::List\n  def filter_value\n    \"#{title} #{description}\"\n  end\nend\n\nitems = [\n  TodoItem.new(\"Buy groceries\", \"Milk, eggs, bread\"),\n  TodoItem.new(\"Call mom\", \"Wish her happy birthday\"),\n  TodoItem.new(\"Fix bug\", \"Issue #123 in production\")\n]\n\n@list = Bubbles::List.new(items)\n```\n\n## Table\n\nFormatted data tables.\n\n### Basic Usage\n\n```ruby\nclass TableModel\n  include Bubbletea::Model\n\n  def initialize\n    @table = Bubbles::Table.new\n    @table.columns = [\"Name\", \"Age\", \"City\"]\n    @table.rows = [\n      [\"Alice\", \"30\", \"New York\"],\n      [\"Bob\", \"25\", \"San Francisco\"],\n      [\"Charlie\", \"35\", \"Chicago\"]\n    ]\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      return [self, Bubbletea.quit] if msg.string == \"q\"\n    end\n\n    @table, cmd = @table.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    @table.view\n  end\nend\n```\n\n### Table Options\n\n```ruby\n@table = Bubbles::Table.new\n\n# Column definitions with widths\n@table.columns = [\n  Bubbles::Column.new(\"Name\", width: 20),\n  Bubbles::Column.new(\"Age\", width: 5),\n  Bubbles::Column.new(\"City\", width: 15)\n]\n\n# Row selection\n@table.focused = true\n@table.selected_style = Lipgloss::Style.new.background(\"#333333\")\n\n# Border style\n@table.border = :rounded\n@table.border_style = Lipgloss::Style.new.foreground(\"#444444\")\n\n# Header styling\n@table.header_style = Lipgloss::Style.new\n  .bold(true)\n  .foreground(\"#FFFFFF\")\n  .background(\"#7D56F4\")\n\n# Cell styling\n@table.cell_style = Lipgloss::Style.new.padding(0, 1)\n\n# Alternating rows\n@table.styles = {\n  even_row: Lipgloss::Style.new.background(\"#1a1a2e\"),\n  odd_row: Lipgloss::Style.new.background(\"#0f0f1a\")\n}\n```\n\n### Navigable Table\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::KeyMsg\n    case msg.string\n    when \"enter\"\n      row = @table.selected_row\n      handle_selection(row)\n    end\n  end\n\n  @table, cmd = @table.update(msg)\n  [self, cmd]\nend\n```\n\n## Progress\n\nProgress bar for showing completion.\n\n### Basic Usage\n\n```ruby\nclass DownloadModel\n  include Bubbletea::Model\n\n  def initialize\n    @progress = Bubbles::Progress.new\n    @percent = 0.0\n  end\n\n  def update(msg)\n    case msg\n    when ProgressMsg\n      @percent = msg.percent\n      if @percent >= 1.0\n        return [self, Bubbletea.quit]\n      end\n    end\n\n    @progress, cmd = @progress.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    @progress.view_as(@percent) + \"\\n\\n#{(@percent * 100).round}% complete\"\n  end\nend\n```\n\n### Progress Options\n\n```ruby\n@progress = Bubbles::Progress.new\n\n# Dimensions\n@progress.width = 40\n\n# Colors\n@progress.full_color = \"#00FF00\"      # Completed portion\n@progress.empty_color = \"#333333\"     # Remaining portion\n\n# Gradient (alternative to solid color)\n@progress.gradient_colors = [\"#FF0000\", \"#FFFF00\", \"#00FF00\"]\n\n# Characters\n@progress.full_char = \"█\"\n@progress.empty_char = \"░\"\n\n# Percentage display\n@progress.show_percentage = true\n@progress.percentage_style = Lipgloss::Style.new.foreground(\"#888888\")\n```\n\n### Animated Progress\n\n```ruby\ndef simulate_progress_cmd\n  Bubbletea.tick(0.1) do |_time|\n    ProgressMsg.new(@percent + 0.05)\n  end\nend\n\ndef update(msg)\n  case msg\n  when ProgressMsg\n    @percent = [msg.percent, 1.0].min\n    return [self, simulate_progress_cmd] if @percent < 1.0\n  end\n  [self, nil]\nend\n```\n\n## Viewport\n\nScrollable content area for long text.\n\n### Basic Usage\n\n```ruby\nclass DocModel\n  include Bubbletea::Model\n\n  def initialize(content)\n    @viewport = Bubbles::Viewport.new\n    @viewport.content = content\n    @viewport.width = 80\n    @viewport.height = 20\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      return [self, Bubbletea.quit] if msg.string == \"q\"\n    end\n\n    @viewport, cmd = @viewport.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    header = \"Documentation (q to quit)\\n\\n\"\n    footer = \"\\n\\n#{scroll_percent}%\"\n    header + @viewport.view + footer\n  end\n\n  def scroll_percent\n    @viewport.scroll_percent.round\n  end\nend\n```\n\n### Viewport Options\n\n```ruby\n@viewport = Bubbles::Viewport.new\n\n# Dimensions (required)\n@viewport.width = 80\n@viewport.height = 20\n\n# Content\n@viewport.content = long_text\n@viewport.set_content(new_content)  # Replace content\n\n# Scroll position\n@viewport.goto_top\n@viewport.goto_bottom\n@viewport.line_up(5)\n@viewport.line_down(5)\n@viewport.half_page_up\n@viewport.half_page_down\n\n# Query position\n@viewport.at_top?\n@viewport.at_bottom?\n@viewport.scroll_percent  # 0.0 to 100.0\n@viewport.y_offset        # Current line offset\n\n# Mouse scrolling\n@viewport.mouse_wheel_enabled = true\n@viewport.mouse_wheel_delta = 3  # Lines per wheel tick\n```\n\n### Viewport with Styled Content\n\n```ruby\ndef render_content\n  lines = @items.map.with_index do |item, i|\n    style = i == @cursor ? @selected_style : @normal_style\n    style.render(item)\n  end\n  lines.join(\"\\n\")\nend\n\ndef update(msg)\n  # Update cursor\n  @viewport.content = render_content\n  @viewport, cmd = @viewport.update(msg)\n  [self, cmd]\nend\n```\n\n## File Picker\n\nBrowse and select files.\n\n### Basic Usage\n\n```ruby\nclass FilePickerModel\n  include Bubbletea::Model\n\n  def initialize(start_dir = Dir.pwd)\n    @picker = Bubbles::FilePicker.new(start_dir)\n    @selected = nil\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"q\"\n        return [self, Bubbletea.quit]\n      when \"enter\"\n        if @picker.selected_file\n          @selected = @picker.selected_file\n          return [self, Bubbletea.quit]\n        end\n      end\n    end\n\n    @picker, cmd = @picker.update(msg)\n    [self, cmd]\n  end\n\n  def view\n    header = \"Select a file (Enter to select, q to cancel)\\n\\n\"\n    header + @picker.view\n  end\nend\n```\n\n### File Picker Options\n\n```ruby\n@picker = Bubbles::FilePicker.new(start_dir)\n\n# Filtering\n@picker.allowed_types = [\".rb\", \".txt\", \".md\"]\n@picker.show_hidden = false\n@picker.dir_allowed = true  # Allow selecting directories\n\n# Display\n@picker.height = 15\n@picker.file_style = Lipgloss::Style.new.foreground(\"#AAAAAA\")\n@picker.dir_style = Lipgloss::Style.new.foreground(\"#5555FF\").bold(true)\n@picker.selected_style = Lipgloss::Style.new.reverse(true)\n\n# Icons\n@picker.show_icons = true\n@picker.file_icon = \"📄\"\n@picker.dir_icon = \"📁\"\n```\n\n## Composing Multiple Components\n\n### Form with Multiple Inputs\n\n```ruby\nclass SignupForm\n  include Bubbletea::Model\n\n  def initialize\n    @inputs = [\n      Bubbles::TextInput.new.tap { |i| i.placeholder = \"Username\" },\n      Bubbles::TextInput.new.tap { |i| i.placeholder = \"Email\" },\n      Bubbles::TextInput.new.tap { |i|\n        i.placeholder = \"Password\"\n        i.echo_mode = :password\n      }\n    ]\n    @focus_index = 0\n    @inputs[@focus_index].focus\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"tab\"\n        @inputs[@focus_index].blur\n        @focus_index = (@focus_index + 1) % @inputs.length\n        @inputs[@focus_index].focus\n        return [self, nil]\n      when \"shift+tab\"\n        @inputs[@focus_index].blur\n        @focus_index = (@focus_index - 1) % @inputs.length\n        @inputs[@focus_index].focus\n        return [self, nil]\n      when \"enter\"\n        if @focus_index == @inputs.length - 1\n          return [self, submit_cmd]\n        else\n          @inputs[@focus_index].blur\n          @focus_index += 1\n          @inputs[@focus_index].focus\n          return [self, nil]\n        end\n      end\n    end\n\n    @inputs[@focus_index], cmd = @inputs[@focus_index].update(msg)\n    [self, cmd]\n  end\n\n  def view\n    labels = [\"Username\", \"Email\", \"Password\"]\n    fields = @inputs.zip(labels).map do |input, label|\n      \"#{label}: #{input.view}\"\n    end\n    fields.join(\"\\n\\n\") + \"\\n\\n(Tab to switch fields, Enter to submit)\"\n  end\nend\n```\n",
        "skills/charm-ruby-development/references/bubblezone-mouse.md": "# Bubblezone: Mouse Event Handling\n\nBubblezone enables mouse interaction in Bubble Tea applications by creating clickable zones in your terminal UI. It tracks mouse events and maps them to specific UI elements.\n\n## Installation\n\n```ruby\n# Gemfile\ngem \"bubblezone\"\n```\n\n## Core Concepts\n\nBubblezone works by:\n1. **Marking zones**: Wrap UI elements with zone markers\n2. **Tracking events**: Listen for mouse events in your model\n3. **Checking bounds**: Determine which zone received a click\n\n## Basic Usage\n\n```ruby\nrequire \"bubbletea\"\nrequire \"bubblezone\"\n\nclass ClickableModel\n  include Bubbletea::Model\n\n  def initialize\n    @zone = Bubblezone::Zone.new\n    @clicked = nil\n  end\n\n  def init\n    Bubbletea.enable_mouse  # Enable mouse tracking\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::MouseMsg\n      if @zone.in_bounds?(\"button1\", msg)\n        @clicked = \"Button 1\"\n      elsif @zone.in_bounds?(\"button2\", msg)\n        @clicked = \"Button 2\"\n      end\n    when Bubbletea::KeyMsg\n      return [self, Bubbletea.quit] if msg.string == \"q\"\n    end\n    [self, nil]\n  end\n\n  def view\n    # Wrap clickable elements with zone.mark\n    btn1 = @zone.mark(\"button1\", \"[ Click Me ]\")\n    btn2 = @zone.mark(\"button2\", \"[ Or Me ]\")\n\n    output = \"#{btn1}  #{btn2}\\n\\n\"\n    output += \"Clicked: #{@clicked || 'nothing'}\\n\"\n    output += \"\\nPress q to quit\"\n\n    # Scan the output to register zone positions\n    @zone.scan(output)\n  end\nend\n\nBubbletea.run(ClickableModel.new)\n```\n\n## Zone API\n\n### Creating Zones\n\n```ruby\nzone = Bubblezone::Zone.new\n\n# Mark a region with an ID\nmarked = zone.mark(\"unique-id\", \"content to make clickable\")\n\n# Mark with styling preserved\nstyled = Lipgloss::Style.new.bold(true).render(\"Styled Button\")\nmarked = zone.mark(\"styled-btn\", styled)\n```\n\n### Checking Bounds\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::MouseMsg\n    # Check if click is within a zone\n    if zone.in_bounds?(\"my-zone\", msg)\n      handle_click\n    end\n\n    # Get the zone ID at mouse position\n    zone_id = zone.at(msg)\n    if zone_id\n      handle_zone_click(zone_id)\n    end\n  end\n  [self, nil]\nend\n```\n\n### Scanning Output\n\nThe `scan` method must be called on your final view output to register zone positions:\n\n```ruby\ndef view\n  output = build_ui_string\n  @zone.scan(output)  # Returns the same string, registers positions\nend\n```\n\n## Mouse Event Types\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::MouseMsg\n    case msg.type\n    when :press\n      # Mouse button pressed\n      handle_press(msg)\n    when :release\n      # Mouse button released\n      handle_release(msg)\n    when :motion\n      # Mouse moved (with button held)\n      handle_drag(msg)\n    when :wheel_up\n      handle_scroll_up\n    when :wheel_down\n      handle_scroll_down\n    end\n\n    # Mouse button information\n    case msg.button\n    when :left\n      left_click(msg)\n    when :right\n      right_click(msg)\n    when :middle\n      middle_click(msg)\n    end\n  end\n  [self, nil]\nend\n```\n\n## Interactive List Example\n\nBuild a clickable list with hover highlighting:\n\n```ruby\nrequire \"bubbletea\"\nrequire \"bubblezone\"\nrequire \"lipgloss\"\n\nclass ClickableList\n  include Bubbletea::Model\n\n  ITEMS = [\"Apple\", \"Banana\", \"Cherry\", \"Date\", \"Elderberry\"]\n\n  def initialize\n    @zone = Bubblezone::Zone.new\n    @selected = nil\n    @hovered = nil\n    setup_styles\n  end\n\n  def init\n    Bubbletea.enable_mouse\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::MouseMsg\n      ITEMS.each_with_index do |item, i|\n        if @zone.in_bounds?(\"item-#{i}\", msg)\n          case msg.type\n          when :press\n            @selected = i\n          when :motion\n            @hovered = i\n          end\n        end\n      end\n\n      # Clear hover when mouse leaves items\n      @hovered = nil unless ITEMS.any? { |_, i| @zone.in_bounds?(\"item-#{i}\", msg) }\n\n    when Bubbletea::KeyMsg\n      return [self, Bubbletea.quit] if msg.string == \"q\"\n    end\n    [self, nil]\n  end\n\n  def view\n    lines = [\n      @title_style.render(\"Click an item:\"),\n      \"\"\n    ]\n\n    ITEMS.each_with_index do |item, i|\n      style = if i == @selected\n                @selected_style\n              elsif i == @hovered\n                @hover_style\n              else\n                @item_style\n              end\n\n      content = style.render(\"  #{item}  \")\n      lines << @zone.mark(\"item-#{i}\", content)\n    end\n\n    lines << \"\"\n    lines << \"Selected: #{@selected ? ITEMS[@selected] : 'none'}\"\n    lines << \"\\nPress q to quit\"\n\n    output = lines.join(\"\\n\")\n    @zone.scan(output)\n  end\n\n  private\n\n  def setup_styles\n    @title_style = Lipgloss::Style.new\n      .bold(true)\n      .foreground(\"#FFFFFF\")\n\n    @item_style = Lipgloss::Style.new\n      .foreground(\"#888888\")\n\n    @hover_style = Lipgloss::Style.new\n      .foreground(\"#FFFFFF\")\n      .background(\"#333333\")\n\n    @selected_style = Lipgloss::Style.new\n      .foreground(\"#FFFFFF\")\n      .background(\"#7D56F4\")\n      .bold(true)\n  end\nend\n\nBubbletea.run(ClickableList.new)\n```\n\n## Button Component\n\nCreate reusable clickable buttons:\n\n```ruby\nmodule Components\n  class Button\n    attr_reader :id, :label\n    attr_accessor :pressed\n\n    def initialize(id:, label:, zone:)\n      @id = id\n      @label = label\n      @zone = zone\n      @pressed = false\n      setup_styles\n    end\n\n    def check_click(msg)\n      @zone.in_bounds?(@id, msg)\n    end\n\n    def render\n      style = @pressed ? @pressed_style : @normal_style\n      content = style.render(\" #{@label} \")\n      @zone.mark(@id, content)\n    end\n\n    private\n\n    def setup_styles\n      @normal_style = Lipgloss::Style.new\n        .foreground(\"#FFFFFF\")\n        .background(\"#7D56F4\")\n        .padding(0, 1)\n        .border(:rounded)\n\n      @pressed_style = Lipgloss::Style.new\n        .foreground(\"#FFFFFF\")\n        .background(\"#5D36D4\")\n        .padding(0, 1)\n        .border(:rounded)\n    end\n  end\nend\n```\n\nUsage:\n\n```ruby\nclass ButtonDemo\n  include Bubbletea::Model\n\n  def initialize\n    @zone = Bubblezone::Zone.new\n    @ok_btn = Components::Button.new(id: \"ok\", label: \"OK\", zone: @zone)\n    @cancel_btn = Components::Button.new(id: \"cancel\", label: \"Cancel\", zone: @zone)\n    @result = nil\n  end\n\n  def init\n    Bubbletea.enable_mouse\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::MouseMsg\n      if msg.type == :press\n        if @ok_btn.check_click(msg)\n          @ok_btn.pressed = true\n          @result = \"OK clicked!\"\n        elsif @cancel_btn.check_click(msg)\n          @cancel_btn.pressed = true\n          @result = \"Cancelled\"\n        end\n      elsif msg.type == :release\n        @ok_btn.pressed = false\n        @cancel_btn.pressed = false\n      end\n    when Bubbletea::KeyMsg\n      return [self, Bubbletea.quit] if msg.string == \"q\"\n    end\n    [self, nil]\n  end\n\n  def view\n    buttons = \"#{@ok_btn.render}  #{@cancel_btn.render}\"\n    output = \"#{buttons}\\n\\n#{@result}\\n\\nPress q to quit\"\n    @zone.scan(output)\n  end\nend\n```\n\n## Tab Bar with Mouse\n\n```ruby\nclass TabBar\n  include Bubbletea::Model\n\n  TABS = [\"Home\", \"Settings\", \"Help\"]\n\n  def initialize\n    @zone = Bubblezone::Zone.new\n    @active_tab = 0\n    setup_styles\n  end\n\n  def init\n    Bubbletea.enable_mouse\n  end\n\n  def update(msg)\n    case msg\n    when Bubbletea::MouseMsg\n      if msg.type == :press\n        TABS.each_with_index do |_, i|\n          @active_tab = i if @zone.in_bounds?(\"tab-#{i}\", msg)\n        end\n      end\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"q\" then return [self, Bubbletea.quit]\n      when \"left\", \"h\" then @active_tab = [0, @active_tab - 1].max\n      when \"right\", \"l\" then @active_tab = [@active_tab + 1, TABS.length - 1].min\n      end\n    end\n    [self, nil]\n  end\n\n  def view\n    tabs = TABS.map.with_index do |name, i|\n      style = i == @active_tab ? @active_style : @inactive_style\n      @zone.mark(\"tab-#{i}\", style.render(\" #{name} \"))\n    end\n\n    tab_bar = tabs.join(\"\")\n    content = render_tab_content(@active_tab)\n\n    output = \"#{tab_bar}\\n#{@border}\\n#{content}\\n\\nClick tabs or use ←/→ • q to quit\"\n    @zone.scan(output)\n  end\n\n  private\n\n  def render_tab_content(index)\n    case index\n    when 0 then \"Welcome to the Home tab!\"\n    when 1 then \"Settings would go here...\"\n    when 2 then \"Help documentation...\"\n    end\n  end\n\n  def setup_styles\n    @active_style = Lipgloss::Style.new\n      .foreground(\"#FFFFFF\")\n      .background(\"#7D56F4\")\n      .bold(true)\n\n    @inactive_style = Lipgloss::Style.new\n      .foreground(\"#888888\")\n      .background(\"#333333\")\n\n    @border = \"─\" * 40\n  end\nend\n```\n\n## Best Practices\n\n### Zone ID Naming\n\n```ruby\n# Good: descriptive, unique IDs\nzone.mark(\"save-button\", \"Save\")\nzone.mark(\"item-0\", items[0])\nzone.mark(\"tab-settings\", \"Settings\")\n\n# Avoid: generic or duplicate IDs\nzone.mark(\"btn\", \"Save\")      # Not descriptive\nzone.mark(\"item\", item)       # Will conflict\n```\n\n### Performance\n\n```ruby\n# Create zone once, reuse\ndef initialize\n  @zone = Bubblezone::Zone.new  # Single instance\nend\n\n# Scan only the final output\ndef view\n  output = build_complex_ui\n  @zone.scan(output)  # Scan once at the end\nend\n```\n\n### Combining with Keyboard\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::MouseMsg\n    handle_mouse(msg)\n  when Bubbletea::KeyMsg\n    # Always support keyboard alternatives\n    case msg.string\n    when \"enter\" then activate_focused_item\n    when \"j\", \"down\" then focus_next\n    when \"k\", \"up\" then focus_previous\n    end\n  end\n  [self, nil]\nend\n```\n\n### Accessibility\n\n- Always provide keyboard alternatives to mouse actions\n- Don't rely solely on hover states for information\n- Consider users who can't use a mouse\n\n## Disabling Mouse\n\n```ruby\ndef cleanup\n  Bubbletea.disable_mouse\nend\n\n# Or in update when quitting\ndef update(msg)\n  if should_quit?(msg)\n    return [self, Bubbletea.batch(\n      Bubbletea.disable_mouse,\n      Bubbletea.quit\n    )]\n  end\n  [self, nil]\nend\n```\n\n## Resources\n\n- [bubblezone-ruby GitHub](https://github.com/marcoroth/bubblezone-ruby)\n- [Original Go bubblezone](https://github.com/charmbracelet/zone)\n",
        "skills/charm-ruby-development/references/cli-ux-best-practices.md": "# CLI UX Best Practices\n\nThis reference provides guidelines for creating command-line applications that are intuitive, accessible, and delightful to use.\n\n---\n\n## Core UX Principles\n\n### Human-First Design\n\nThe terminal is a human interface first, machine interface second. Prioritize clarity and usability:\n\n```ruby\n# Bad: Cryptic output\nputs \"ERR_AUTH_FAIL_403\"\n\n# Good: Human-readable with context\nputs \"Authentication failed: Invalid API token\"\nputs \"Run `my-cli auth login` to authenticate\"\n```\n\n### Consistency with Terminal Conventions\n\nUsers expect standard behaviors:\n\n- **Exit codes**: `0` for success, non-zero for errors\n- **Streams**: `stdout` for output, `stderr` for errors and progress\n- **Signals**: Handle `SIGINT` (Ctrl+C) gracefully\n- **Flags**: Use `-h/--help`, `-v/--version`, `-q/--quiet`, `--verbose`\n\n```ruby\n# Handle graceful shutdown\ntrap(\"INT\") do\n  puts \"\\nOperation cancelled\"\n  exit(130)  # Standard exit code for SIGINT\nend\n```\n\n### Speed and Responsiveness\n\nUsers perceive CLIs as fast. Meet expectations:\n\n- **< 100ms**: Immediate feedback expected\n- **100ms - 1s**: Show spinner or progress indicator\n- **> 1s**: Show progress bar with ETA if possible\n\n```ruby\n# For operations over 100ms\nGum.spin(title: \"Fetching data...\") do\n  fetch_data\nend\n```\n\n---\n\n## Information Density\n\n### Meaningful Output\n\nEvery line should add value. Avoid verbose congratulations or unnecessary confirmation:\n\n```ruby\n# Bad: Too verbose\nputs \"Starting operation...\"\nputs \"Operation started successfully!\"\nputs \"Processing items...\"\nputs \"Items processed successfully!\"\nputs \"Congratulations! Everything worked!\"\n\n# Good: Concise and informative\nputs \"Processed 42 items in 1.2s\"\n```\n\n### Progressive Disclosure\n\nShow essential info by default, details on request:\n\n```ruby\n# Default: Summary\nputs \"Build completed with 3 warnings\"\n\n# With --verbose: Full details\nif verbose?\n  warnings.each { |w| puts \"  #{w.file}:#{w.line}: #{w.message}\" }\nend\n```\n\n---\n\n## Error Handling\n\n### Clear, Actionable Errors\n\nErrors should tell users what happened, why, and how to fix it:\n\n```ruby\nclass AppError < StandardError\n  attr_reader :hint, :exit_code\n\n  def initialize(message, hint: nil, exit_code: 1)\n    super(message)\n    @hint = hint\n    @exit_code = exit_code\n  end\nend\n\ndef handle_error(error)\n  style = Lipgloss::Style.new.foreground(\"#FF0000\").bold(true)\n  hint_style = Lipgloss::Style.new.foreground(\"#888888\").italic(true)\n\n  $stderr.puts style.render(\"Error: #{error.message}\")\n  $stderr.puts hint_style.render(\"Hint: #{error.hint}\") if error.hint\n  exit(error.exit_code)\nend\n\n# Usage\nraise AppError.new(\n  \"Config file not found: ~/.myapp/config.yml\",\n  hint: \"Run `myapp init` to create a default configuration\"\n)\n```\n\n### Error Categories\n\nUse consistent exit codes by category:\n\n| Exit Code | Category | Example |\n|-----------|----------|---------|\n| 0 | Success | Command completed |\n| 1 | General error | Unknown error |\n| 2 | Usage error | Invalid arguments |\n| 64 | Input error | Malformed input file |\n| 65 | Data error | Invalid data format |\n| 66 | No input | File not found |\n| 130 | SIGINT | User pressed Ctrl+C |\n\n---\n\n## Help System Design\n\n### Multi-Level Help\n\nProvide help at different detail levels:\n\n```ruby\n# Short help (shown on error or -h)\ndef short_help\n  <<~HELP\n    Usage: myapp <command> [options]\n\n    Commands:\n      init      Create new project\n      build     Build the project\n      deploy    Deploy to production\n\n    Run 'myapp <command> --help' for command-specific help.\n  HELP\nend\n\n# Detailed help (shown on --help)\ndef detailed_help(command)\n  case command\n  when \"build\"\n    <<~HELP\n      Usage: myapp build [options] [target]\n\n      Build the project for deployment.\n\n      Options:\n        -o, --output DIR    Output directory (default: ./dist)\n        -w, --watch         Watch for changes\n        --minify            Minify output files\n        --sourcemaps        Generate source maps\n\n      Examples:\n        myapp build                    # Build with defaults\n        myapp build --watch            # Build and watch\n        myapp build -o ./public        # Custom output dir\n    HELP\n  end\nend\n```\n\n### Examples Are Essential\n\nAlways include practical examples in help text:\n\n```ruby\n# Show common use cases\nExamples:\n  # Basic usage\n  myapp fetch https://api.example.com/data\n\n  # With authentication\n  myapp fetch --auth token123 https://api.example.com/data\n\n  # Output to file\n  myapp fetch https://api.example.com/data > output.json\n```\n\n---\n\n## Progress Indicators\n\n### Spinner for Indeterminate Progress\n\nWhen you don't know how long an operation will take:\n\n```ruby\nspinner = Bubbles::Spinner.new\nspinner.style = :dots  # Clean, professional\n\n# Show context with spinner\ndef view\n  if @loading\n    \"#{@spinner.view} Connecting to server...\"\n  else\n    \"Connected!\"\n  end\nend\n```\n\n### Progress Bar for Known Progress\n\nWhen you can measure progress:\n\n```ruby\nprogress = Bubbles::Progress.new\nprogress.total = files.count\n\nfiles.each_with_index do |file, i|\n  process(file)\n  progress.current = i + 1\n  # Shows: [████████░░░░░░░░] 50% (25/50 files)\nend\n```\n\n### X of Y Pattern\n\nFor batch operations, show position in sequence:\n\n```ruby\nitems.each_with_index do |item, i|\n  puts \"[#{i + 1}/#{items.count}] Processing #{item.name}\"\n  process(item)\nend\n```\n\n---\n\n## Keyboard Navigation\n\n### Vim-Style Bindings\n\nSupport both arrow keys and vim-style navigation:\n\n```ruby\ndef update(msg)\n  case msg\n  when Bubbletea::KeyMsg\n    case msg.string\n    # Arrow keys\n    when \"up\" then move_up\n    when \"down\" then move_down\n    when \"left\" then move_left\n    when \"right\" then move_right\n    # Vim keys\n    when \"k\" then move_up\n    when \"j\" then move_down\n    when \"h\" then move_left\n    when \"l\" then move_right\n    # Common shortcuts\n    when \"g\" then jump_to_start\n    when \"G\" then jump_to_end\n    when \"/\" then enter_search_mode\n    when \"q\", \"ctrl+c\" then [self, Bubbletea.quit]\n    end\n  end\n  [self, nil]\nend\n```\n\n### Always Show Controls\n\nDisplay available actions at the bottom of interactive UIs:\n\n```ruby\ndef view\n  content = render_main_content\n\n  help_style = Lipgloss::Style.new.foreground(\"#888888\")\n  controls = help_style.render(\"↑/k up • ↓/j down • enter select • q quit\")\n\n  \"#{content}\\n\\n#{controls}\"\nend\n```\n\n---\n\n## Color and Styling Guidelines\n\n### Semantic Colors\n\nUse colors consistently for meaning:\n\n```ruby\nCOLORS = {\n  success: \"#00FF00\",\n  error: \"#FF0000\",\n  warning: \"#FFAA00\",\n  info: \"#00AAFF\",\n  muted: \"#888888\"\n}\n\ndef success(msg)\n  Lipgloss::Style.new.foreground(COLORS[:success]).render(\"✓ #{msg}\")\nend\n\ndef error(msg)\n  Lipgloss::Style.new.foreground(COLORS[:error]).render(\"✗ #{msg}\")\nend\n\ndef warning(msg)\n  Lipgloss::Style.new.foreground(COLORS[:warning]).render(\"⚠ #{msg}\")\nend\n```\n\n### Adaptive Colors\n\nSupport both light and dark terminal themes:\n\n```ruby\n# Automatically adjusts based on terminal background\ntext_color = Lipgloss.adaptive_color(\"#000000\", \"#FFFFFF\")\nstyle = Lipgloss::Style.new.foreground(text_color)\n```\n\n### Graceful Degradation\n\nHandle terminals with limited color support:\n\n```ruby\n# Lipgloss automatically adapts to terminal capabilities:\n# - True Color (24-bit): Full hex colors\n# - ANSI 256: Closest match from 256 palette\n# - ANSI 16: Basic colors only\n# - No color: Plain text\n```\n\n---\n\n## Confirmation Patterns\n\n### Destructive Actions\n\nAlways confirm destructive operations:\n\n```ruby\ndef delete_all\n  if Gum.confirm(\"Delete all 47 files? This cannot be undone.\")\n    files.each(&:delete)\n    puts success(\"Deleted 47 files\")\n  else\n    puts \"Operation cancelled\"\n  end\nend\n```\n\n### Dry Run Support\n\nProvide preview mode for risky operations:\n\n```ruby\n# --dry-run shows what would happen without doing it\nif dry_run?\n  puts \"Would delete:\"\n  files.each { |f| puts \"  #{f}\" }\n  puts \"\\nRun without --dry-run to execute\"\nelse\n  files.each(&:delete)\nend\n```\n\n---\n\n## Terminal Size Handling\n\n### Responsive Layouts\n\nAdapt to terminal dimensions:\n\n```ruby\ndef view\n  width = Bubbletea.term_width\n  height = Bubbletea.term_height\n\n  if width < 80\n    render_compact_view\n  else\n    render_full_view\n  end\nend\n```\n\n### Minimum Size Requirements\n\nGracefully handle small terminals:\n\n```ruby\ndef view\n  width = Bubbletea.term_width\n\n  if width < 40\n    \"Terminal too narrow. Please resize to at least 40 columns.\"\n  else\n    render_content\n  end\nend\n```\n\n---\n\n## Resources\n\n- [Command Line Interface Guidelines](https://clig.dev/)\n- [12 Factor CLI Apps](https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46)\n- [GNU Coding Standards](https://www.gnu.org/prep/standards/standards.html#Command_002dLine-Interfaces)\n",
        "skills/charm-ruby-development/references/gem-distribution.md": "# Gem Distribution Reference\n\n## Overview\n\nDistributing your charm-ruby CLI tool as a Ruby gem allows users to install it with a simple `gem install` command. This guide covers project structure, gemspec configuration, versioning, and publishing to RubyGems.org.\n\n## Project Structure\n\nStandard gem structure for a CLI tool:\n\n```\nmy-cli/\n├── bin/\n│   └── my-cli              # Executable script\n├── lib/\n│   ├── my_cli.rb           # Main entry point (requires all modules)\n│   └── my_cli/\n│       ├── version.rb      # Version constant\n│       ├── cli.rb          # CLI entry class\n│       ├── model.rb        # Bubble Tea model(s)\n│       └── components/     # Custom components\n│           └── ...\n├── spec/                   # Tests (optional but recommended)\n│   └── ...\n├── .gitignore\n├── .rubocop.yml            # Linting config (optional)\n├── Gemfile\n├── LICENSE.txt\n├── README.md\n├── CHANGELOG.md\n└── my-cli.gemspec\n```\n\n## Essential Files\n\n### bin/my-cli\n\nThe executable that users run:\n\n```ruby\n#!/usr/bin/env ruby\n# frozen_string_literal: true\n\nrequire \"my_cli\"\n\nMyCli::CLI.start\n```\n\nMake it executable:\n\n```bash\nchmod +x bin/my-cli\n```\n\n### lib/my_cli.rb\n\nMain entry point that loads all modules:\n\n```ruby\n# frozen_string_literal: true\n\nrequire_relative \"my_cli/version\"\nrequire_relative \"my_cli/cli\"\nrequire_relative \"my_cli/model\"\n\nmodule MyCli\n  class Error < StandardError; end\nend\n```\n\n### lib/my_cli/version.rb\n\nVersion constant used by gemspec:\n\n```ruby\n# frozen_string_literal: true\n\nmodule MyCli\n  VERSION = \"0.1.0\"\nend\n```\n\n### lib/my_cli/cli.rb\n\nCLI entry class:\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbletea\"\nrequire \"lipgloss\"\n\nmodule MyCli\n  class CLI\n    def self.start(args = ARGV)\n      new(args).run\n    end\n\n    def initialize(args)\n      @args = args\n    end\n\n    def run\n      case @args.first\n      when \"-v\", \"--version\"\n        puts \"my-cli #{VERSION}\"\n      when \"-h\", \"--help\"\n        show_help\n      else\n        start_app\n      end\n    end\n\n    private\n\n    def show_help\n      puts <<~HELP\n        my-cli - A beautiful CLI tool\n\n        Usage: my-cli [options]\n\n        Options:\n          -h, --help     Show this help\n          -v, --version  Show version\n      HELP\n    end\n\n    def start_app\n      Bubbletea.run(Model.new, alt_screen: true)\n    end\n  end\nend\n```\n\n### lib/my_cli/model.rb\n\nMain Bubble Tea model:\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bubbletea\"\nrequire \"lipgloss\"\n\nmodule MyCli\n  class Model\n    include Bubbletea::Model\n\n    def initialize\n      @cursor = 0\n      @items = [\"Item 1\", \"Item 2\", \"Item 3\"]\n    end\n\n    def init\n      nil\n    end\n\n    def update(msg)\n      case msg\n      when Bubbletea::KeyMsg\n        handle_key(msg)\n      else\n        [self, nil]\n      end\n    end\n\n    def view\n      # Render your UI here\n      lines = @items.map.with_index do |item, i|\n        prefix = i == @cursor ? \"> \" : \"  \"\n        \"#{prefix}#{item}\"\n      end\n      lines.join(\"\\n\") + \"\\n\\nq to quit\"\n    end\n\n    private\n\n    def handle_key(msg)\n      case msg.string\n      when \"q\", \"ctrl+c\"\n        [self, Bubbletea.quit]\n      when \"up\", \"k\"\n        @cursor = [@cursor - 1, 0].max\n        [self, nil]\n      when \"down\", \"j\"\n        @cursor = [@cursor + 1, @items.length - 1].min\n        [self, nil]\n      else\n        [self, nil]\n      end\n    end\n  end\nend\n```\n\n## Gemspec Configuration\n\n### my-cli.gemspec\n\n```ruby\n# frozen_string_literal: true\n\nrequire_relative \"lib/my_cli/version\"\n\nGem::Specification.new do |spec|\n  spec.name          = \"my-cli\"\n  spec.version       = MyCli::VERSION\n  spec.authors       = [\"Your Name\"]\n  spec.email         = [\"you@example.com\"]\n\n  spec.summary       = \"A beautiful CLI tool built with charm-ruby\"\n  spec.description   = \"A more detailed description of what your CLI does and why it's useful.\"\n  spec.homepage      = \"https://github.com/yourusername/my-cli\"\n  spec.license       = \"MIT\"\n\n  spec.required_ruby_version = \">= 2.7.0\"\n\n  spec.metadata = {\n    \"bug_tracker_uri\"   => \"https://github.com/yourusername/my-cli/issues\",\n    \"changelog_uri\"     => \"https://github.com/yourusername/my-cli/blob/main/CHANGELOG.md\",\n    \"documentation_uri\" => \"https://github.com/yourusername/my-cli#readme\",\n    \"homepage_uri\"      => spec.homepage,\n    \"source_code_uri\"   => \"https://github.com/yourusername/my-cli\"\n  }\n\n  # Specify which files should be included in the gem\n  spec.files = Dir.chdir(__dir__) do\n    `git ls-files -z`.split(\"\\x0\").reject do |f|\n      f.match(%r{\\A(?:test|spec|features)/}) ||\n        f.match(%r{\\A\\.(?:git|github|rubocop)})\n    end\n  end\n\n  # Executables go in bin/ directory\n  spec.bindir        = \"bin\"\n  spec.executables   = [\"my-cli\"]\n  spec.require_paths = [\"lib\"]\n\n  # Runtime dependencies (required to run)\n  spec.add_dependency \"bubbletea\", \"~> 0.1\"\n  spec.add_dependency \"lipgloss\", \"~> 0.1\"\n  spec.add_dependency \"bubbles\", \"~> 0.1\"\n\n  # Development dependencies (only for development/testing)\n  spec.add_development_dependency \"rake\", \"~> 13.0\"\n  spec.add_development_dependency \"rspec\", \"~> 3.0\"\n  spec.add_development_dependency \"rubocop\", \"~> 1.0\"\nend\n```\n\n### Key Gemspec Fields\n\n| Field | Description |\n|-------|-------------|\n| `name` | Gem name (lowercase, hyphens OK) |\n| `version` | Semantic version (MAJOR.MINOR.PATCH) |\n| `summary` | One-line description (< 140 chars) |\n| `description` | Detailed description |\n| `executables` | Array of bin/ scripts to install |\n| `add_dependency` | Runtime dependencies with version constraints |\n\n### Version Constraints\n\n```ruby\n# Exact version\nspec.add_dependency \"bubbletea\", \"0.1.0\"\n\n# Any version >= 0.1.0 and < 1.0.0\nspec.add_dependency \"bubbletea\", \"~> 0.1\"\n\n# Any version >= 0.1.0 and < 0.2.0\nspec.add_dependency \"bubbletea\", \"~> 0.1.0\"\n\n# Any version >= 0.1.0\nspec.add_dependency \"bubbletea\", \">= 0.1\"\n\n# Complex constraints\nspec.add_dependency \"bubbletea\", \">= 0.1\", \"< 2.0\"\n```\n\n## Gemfile\n\nFor development:\n\n```ruby\n# frozen_string_literal: true\n\nsource \"https://rubygems.org\"\n\n# Specify gem dependencies in my-cli.gemspec\ngemspec\n\n# Development-only gems not in gemspec\ngroup :development do\n  gem \"debug\"\nend\n```\n\n## Versioning\n\n### Semantic Versioning (SemVer)\n\nFollow MAJOR.MINOR.PATCH:\n\n- **MAJOR**: Breaking changes (incompatible API changes)\n- **MINOR**: New features (backwards-compatible)\n- **PATCH**: Bug fixes (backwards-compatible)\n\n### Version Workflow\n\n```ruby\n# lib/my_cli/version.rb\n\nmodule MyCli\n  VERSION = \"0.1.0\"  # Initial development\n  # VERSION = \"0.2.0\"  # Added new feature\n  # VERSION = \"0.2.1\"  # Bug fix\n  # VERSION = \"1.0.0\"  # First stable release\nend\n```\n\n### Pre-release Versions\n\n```ruby\nVERSION = \"1.0.0.alpha\"\nVERSION = \"1.0.0.beta.1\"\nVERSION = \"1.0.0.rc.1\"\n```\n\n## Building the Gem\n\n### Build Locally\n\n```bash\n# Build gem file\ngem build my-cli.gemspec\n\n# Output: my-cli-0.1.0.gem\n```\n\n### Install Locally for Testing\n\n```bash\n# Install from local .gem file\ngem install ./my-cli-0.1.0.gem\n\n# Or install directly from source\nbundle exec rake install\n```\n\n### Test the Executable\n\n```bash\n# After installation, test the command\nmy-cli --version\nmy-cli --help\nmy-cli\n```\n\n## Publishing to RubyGems.org\n\n### First-Time Setup\n\n1. Create account at [rubygems.org](https://rubygems.org/sign_up)\n2. Get API key from profile settings\n3. Configure credentials:\n\n```bash\n# Interactive setup\ngem signin\n\n# Or manually create ~/.gem/credentials\nmkdir -p ~/.gem\necho \":rubygems_api_key: YOUR_API_KEY\" > ~/.gem/credentials\nchmod 0600 ~/.gem/credentials\n```\n\n### Publish\n\n```bash\n# Build fresh gem\ngem build my-cli.gemspec\n\n# Push to RubyGems\ngem push my-cli-0.1.0.gem\n```\n\n### Release Workflow\n\n1. Update version in `version.rb`\n2. Update `CHANGELOG.md`\n3. Commit changes: `git commit -am \"Release v0.2.0\"`\n4. Tag release: `git tag v0.2.0`\n5. Build: `gem build my-cli.gemspec`\n6. Push gem: `gem push my-cli-0.2.0.gem`\n7. Push to git: `git push && git push --tags`\n\n### Using Rake Tasks\n\nAdd to `Rakefile`:\n\n```ruby\n# frozen_string_literal: true\n\nrequire \"bundler/gem_tasks\"\nrequire \"rspec/core/rake_task\"\n\nRSpec::Core::RakeTask.new(:spec)\n\ntask default: :spec\n```\n\nThen use:\n\n```bash\n# Build gem\nrake build\n\n# Install locally\nrake install\n\n# Release (builds, tags, pushes gem and git)\nrake release\n```\n\n## CHANGELOG.md\n\nKeep a changelog for users:\n\n```markdown\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/),\nand this project adheres to [Semantic Versioning](https://semver.org/).\n\n## [Unreleased]\n\n### Added\n- New feature in development\n\n## [0.2.0] - 2025-01-15\n\n### Added\n- Interactive file picker\n- Color theme support\n\n### Fixed\n- Cursor position after scroll\n\n## [0.1.0] - 2025-01-01\n\n### Added\n- Initial release\n- Basic navigation\n- Item selection\n```\n\n## README.md Template\n\n```markdown\n# My CLI\n\nA beautiful CLI tool built with charm-ruby.\n\n## Installation\n\n```bash\ngem install my-cli\n```\n\n## Usage\n\n```bash\n# Start the interactive interface\nmy-cli\n\n# Show help\nmy-cli --help\n\n# Show version\nmy-cli --version\n```\n\n## Development\n\nAfter cloning:\n\n```bash\nbin/setup\nbundle exec rake spec\n```\n\n## Contributing\n\nBug reports and pull requests welcome at https://github.com/yourusername/my-cli\n\n## License\n\nMIT License - see LICENSE.txt\n```\n\n## CI/CD with GitHub Actions\n\n### .github/workflows/ci.yml\n\n```yaml\nname: CI\n\non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        ruby: ['2.7', '3.0', '3.1', '3.2']\n\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: ${{ matrix.ruby }}\n          bundler-cache: true\n      - run: bundle exec rake spec\n\n  lint:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '3.2'\n          bundler-cache: true\n      - run: bundle exec rubocop\n```\n\n### .github/workflows/release.yml\n\n```yaml\nname: Release\n\non:\n  push:\n    tags: ['v*']\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '3.2'\n          bundler-cache: true\n      - name: Build gem\n        run: gem build *.gemspec\n      - name: Push to RubyGems\n        run: gem push *.gem\n        env:\n          GEM_HOST_API_KEY: ${{ secrets.RUBYGEMS_API_KEY }}\n```\n\n## Best Practices\n\n1. **Use frozen_string_literal**: Add to all Ruby files for performance\n2. **Pin major versions**: Use `~>` to allow minor updates but prevent breaking changes\n3. **Test before release**: Run full test suite before publishing\n4. **Document changes**: Keep CHANGELOG updated\n5. **Semantic versioning**: Follow SemVer strictly\n6. **Minimal dependencies**: Only include what's needed\n7. **Support multiple Ruby versions**: Test on Ruby 2.7+\n8. **Provide --help and --version**: Standard CLI conventions\n9. **Handle errors gracefully**: Don't crash with stack traces\n10. **Include LICENSE**: Required for open source gems\n\n## Troubleshooting\n\n### Gem Not Found After Install\n\nCheck PATH includes gem bin directory:\n\n```bash\necho $PATH\ngem environment\n```\n\n### Permission Denied\n\nDon't use `sudo gem install`. Instead:\n\n```bash\n# Use rbenv/rvm, or:\ngem install --user-install my-cli\n```\n\n### Version Conflicts\n\n```bash\n# Check installed versions\ngem list my-cli\n\n# Uninstall old versions\ngem uninstall my-cli --version 0.1.0\n```\n\n### Executable Not Running\n\nCheck shebang line in bin/ file:\n\n```ruby\n#!/usr/bin/env ruby\n```\n\nEnsure file is executable:\n\n```bash\nchmod +x bin/my-cli\n```\n",
        "skills/charm-ruby-development/references/harmonica-animation.md": "# Harmonica: Physics-Based Animations\n\nHarmonica provides spring physics animations for Bubble Tea applications. Create smooth, natural-feeling transitions and animations using spring dynamics.\n\n## Installation\n\n```ruby\n# Gemfile\ngem \"harmonica\"\n```\n\n## Core Concepts\n\nHarmonica simulates spring physics with two key parameters:\n\n- **Angular Frequency (ω)**: Controls animation speed. Higher values = faster springs\n- **Damping Ratio (ζ)**: Controls oscillation. Values < 1 oscillate, = 1 critically damped, > 1 overdamped\n\n## Basic Usage\n\n```ruby\nrequire \"harmonica\"\n\n# Create a spring with default parameters\nspring = Harmonica::Spring.new\n\n# Create with custom physics\nspring = Harmonica::Spring.new(\n  angular_frequency: 5.0,  # Speed of animation\n  damping_ratio: 0.5       # Amount of bounce\n)\n\n# Set target value\nspring.target = 100.0\n\n# Update each frame (returns current position)\nposition = spring.update(delta_time)\n```\n\n## Animation Parameters\n\n### Angular Frequency\n\nControls how fast the spring moves toward its target:\n\n```ruby\n# Slow, gentle animation\nspring = Harmonica::Spring.new(angular_frequency: 2.0)\n\n# Medium speed (good default)\nspring = Harmonica::Spring.new(angular_frequency: 5.0)\n\n# Fast, snappy animation\nspring = Harmonica::Spring.new(angular_frequency: 10.0)\n\n# Very fast (almost instant)\nspring = Harmonica::Spring.new(angular_frequency: 20.0)\n```\n\n### Damping Ratio\n\nControls oscillation behavior:\n\n```ruby\n# Underdamped (bouncy) - oscillates around target\nspring = Harmonica::Spring.new(damping_ratio: 0.3)  # Very bouncy\nspring = Harmonica::Spring.new(damping_ratio: 0.5)  # Moderate bounce\nspring = Harmonica::Spring.new(damping_ratio: 0.8)  # Slight bounce\n\n# Critically damped - reaches target fastest without oscillation\nspring = Harmonica::Spring.new(damping_ratio: 1.0)\n\n# Overdamped - no oscillation, slower approach\nspring = Harmonica::Spring.new(damping_ratio: 1.5)\nspring = Harmonica::Spring.new(damping_ratio: 2.0)  # Very slow settle\n```\n\n### Common Presets\n\n```ruby\nmodule AnimationPresets\n  # UI element hover/focus\n  SNAPPY = { angular_frequency: 8.0, damping_ratio: 0.9 }\n\n  # Menu transitions\n  SMOOTH = { angular_frequency: 5.0, damping_ratio: 1.0 }\n\n  # Playful bouncy effect\n  BOUNCY = { angular_frequency: 6.0, damping_ratio: 0.4 }\n\n  # Gentle, slow reveal\n  GENTLE = { angular_frequency: 3.0, damping_ratio: 1.2 }\n\n  # Quick snap with slight settle\n  QUICK = { angular_frequency: 12.0, damping_ratio: 0.85 }\nend\n\nspring = Harmonica::Spring.new(**AnimationPresets::BOUNCY)\n```\n\n## Bubble Tea Integration\n\n### Animated Counter\n\n```ruby\nrequire \"bubbletea\"\nrequire \"harmonica\"\nrequire \"lipgloss\"\n\nclass AnimatedCounter\n  include Bubbletea::Model\n\n  def initialize\n    @value = 0\n    @spring = Harmonica::Spring.new(\n      angular_frequency: 6.0,\n      damping_ratio: 0.6\n    )\n    @spring.target = 0\n    @display_value = 0.0\n    @last_tick = Time.now\n    setup_styles\n  end\n\n  def init\n    tick_cmd\n  end\n\n  def update(msg)\n    case msg\n    when TickMsg\n      now = Time.now\n      delta = now - @last_tick\n      @last_tick = now\n      @display_value = @spring.update(delta)\n      return [self, tick_cmd]\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"q\" then return [self, Bubbletea.quit]\n      when \"up\", \"k\"\n        @value += 10\n        @spring.target = @value\n      when \"down\", \"j\"\n        @value -= 10\n        @spring.target = @value\n      end\n    end\n    [self, nil]\n  end\n\n  def view\n    displayed = @display_value.round\n    number = @number_style.render(displayed.to_s.rjust(5))\n\n    \"#{@title_style.render(\"Animated Counter\")}\\n\\n\" \\\n    \"#{number}\\n\\n\" \\\n    \"↑/k +10 • ↓/j -10 • q quit\"\n  end\n\n  private\n\n  def tick_cmd\n    Bubbletea.tick(1.0 / 60.0) { TickMsg.new }  # 60 FPS\n  end\n\n  def setup_styles\n    @title_style = Lipgloss::Style.new.bold(true)\n    @number_style = Lipgloss::Style.new\n      .foreground(\"#7D56F4\")\n      .bold(true)\n  end\nend\n\nclass TickMsg; end\n```\n\n### Animated Progress Bar\n\n```ruby\nclass AnimatedProgress\n  include Bubbletea::Model\n\n  def initialize\n    @target_progress = 0.0\n    @spring = Harmonica::Spring.new(\n      angular_frequency: 4.0,\n      damping_ratio: 1.0  # No bounce for progress\n    )\n    @display_progress = 0.0\n    @last_tick = Time.now\n    @width = 40\n    setup_styles\n  end\n\n  def init\n    tick_cmd\n  end\n\n  def update(msg)\n    case msg\n    when TickMsg\n      delta = Time.now - @last_tick\n      @last_tick = Time.now\n      @display_progress = @spring.update(delta)\n      return [self, tick_cmd]\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"q\" then return [self, Bubbletea.quit]\n      when \" \", \"enter\"\n        @target_progress = [@target_progress + 0.1, 1.0].min\n        @spring.target = @target_progress\n      when \"r\"\n        @target_progress = 0.0\n        @spring.target = 0.0\n      end\n    end\n    [self, nil]\n  end\n\n  def view\n    progress = @display_progress.clamp(0.0, 1.0)\n    filled = (progress * @width).round\n    empty = @width - filled\n\n    bar = @filled_style.render(\"█\" * filled) + @empty_style.render(\"░\" * empty)\n    percent = \"#{(progress * 100).round}%\"\n\n    \"Progress: #{bar} #{percent}\\n\\n\" \\\n    \"Space to add 10% • r to reset • q quit\"\n  end\n\n  private\n\n  def tick_cmd\n    Bubbletea.tick(1.0 / 30.0) { TickMsg.new }\n  end\n\n  def setup_styles\n    @filled_style = Lipgloss::Style.new.foreground(\"#7D56F4\")\n    @empty_style = Lipgloss::Style.new.foreground(\"#333333\")\n  end\nend\n```\n\n### Smooth Scrolling\n\n```ruby\nclass SmoothScrollView\n  include Bubbletea::Model\n\n  def initialize(content, height: 20)\n    @content = content.lines\n    @height = height\n    @target_offset = 0\n    @spring = Harmonica::Spring.new(\n      angular_frequency: 8.0,\n      damping_ratio: 0.9\n    )\n    @display_offset = 0.0\n    @last_tick = Time.now\n  end\n\n  def init\n    tick_cmd\n  end\n\n  def update(msg)\n    case msg\n    when TickMsg\n      delta = Time.now - @last_tick\n      @last_tick = Time.now\n      @display_offset = @spring.update(delta)\n      return [self, tick_cmd]\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"q\" then return [self, Bubbletea.quit]\n      when \"j\", \"down\"\n        @target_offset = [@target_offset + 1, max_offset].min\n        @spring.target = @target_offset\n      when \"k\", \"up\"\n        @target_offset = [@target_offset - 1, 0].max\n        @spring.target = @target_offset\n      when \"d\"  # Half page down\n        @target_offset = [@target_offset + @height / 2, max_offset].min\n        @spring.target = @target_offset\n      when \"u\"  # Half page up\n        @target_offset = [@target_offset - @height / 2, 0].max\n        @spring.target = @target_offset\n      end\n    end\n    [self, nil]\n  end\n\n  def view\n    offset = @display_offset.round.clamp(0, max_offset)\n    visible = @content[offset, @height] || []\n\n    visible.join + \"\\n\" + scroll_indicator\n  end\n\n  private\n\n  def max_offset\n    [@content.length - @height, 0].max\n  end\n\n  def scroll_indicator\n    pct = max_offset > 0 ? (@display_offset / max_offset * 100).round : 100\n    \"Scroll: #{pct}% • j/k scroll • d/u half page • q quit\"\n  end\n\n  def tick_cmd\n    Bubbletea.tick(1.0 / 60.0) { TickMsg.new }\n  end\nend\n```\n\n## Multiple Springs\n\nAnimate multiple values independently:\n\n```ruby\nclass MultiSpringDemo\n  include Bubbletea::Model\n\n  def initialize\n    @springs = {\n      x: Harmonica::Spring.new(angular_frequency: 5.0, damping_ratio: 0.6),\n      y: Harmonica::Spring.new(angular_frequency: 5.0, damping_ratio: 0.6),\n      size: Harmonica::Spring.new(angular_frequency: 8.0, damping_ratio: 0.8)\n    }\n    @position = { x: 20.0, y: 10.0, size: 1.0 }\n    @last_tick = Time.now\n  end\n\n  def init\n    tick_cmd\n  end\n\n  def update(msg)\n    case msg\n    when TickMsg\n      delta = Time.now - @last_tick\n      @last_tick = Time.now\n\n      @position[:x] = @springs[:x].update(delta)\n      @position[:y] = @springs[:y].update(delta)\n      @position[:size] = @springs[:size].update(delta)\n\n      return [self, tick_cmd]\n    when Bubbletea::KeyMsg\n      case msg.string\n      when \"h\", \"left\"\n        @springs[:x].target = [@springs[:x].target - 5, 0].max\n      when \"l\", \"right\"\n        @springs[:x].target = @springs[:x].target + 5\n      when \"k\", \"up\"\n        @springs[:y].target = [@springs[:y].target - 2, 0].max\n      when \"j\", \"down\"\n        @springs[:y].target = @springs[:y].target + 2\n      when \"+\", \"=\"\n        @springs[:size].target = @springs[:size].target + 0.5\n      when \"-\"\n        @springs[:size].target = [@springs[:size].target - 0.5, 0.5].max\n      when \"q\"\n        return [self, Bubbletea.quit]\n      end\n    end\n    [self, nil]\n  end\n\n  def view\n    x = @position[:x].round\n    y = @position[:y].round\n    size = @position[:size].round\n\n    canvas = Array.new(25) { \" \" * 60 }\n\n    # Draw object at animated position\n    char = \"●\" * size\n    if y >= 0 && y < canvas.length && x >= 0 && x < 60\n      canvas[y] = canvas[y][0...x] + char + canvas[y][(x + char.length)..-1].to_s\n    end\n\n    canvas.join(\"\\n\") + \"\\n\\nhjkl move • +/- size • q quit\"\n  end\n\n  private\n\n  def tick_cmd\n    Bubbletea.tick(1.0 / 60.0) { TickMsg.new }\n  end\nend\n```\n\n## Animation Utilities\n\n### Easing Helper\n\n```ruby\nmodule Harmonica\n  module Presets\n    def self.ease_out\n      Spring.new(angular_frequency: 6.0, damping_ratio: 1.0)\n    end\n\n    def self.ease_in_out\n      Spring.new(angular_frequency: 4.0, damping_ratio: 1.2)\n    end\n\n    def self.bounce\n      Spring.new(angular_frequency: 8.0, damping_ratio: 0.3)\n    end\n\n    def self.elastic\n      Spring.new(angular_frequency: 10.0, damping_ratio: 0.2)\n    end\n  end\nend\n```\n\n### Animation State Machine\n\n```ruby\nclass AnimationController\n  def initialize\n    @spring = Harmonica::Spring.new(angular_frequency: 6.0, damping_ratio: 0.8)\n    @state = :idle\n  end\n\n  def start_animation(from:, to:)\n    @spring.position = from\n    @spring.target = to\n    @state = :animating\n  end\n\n  def update(delta)\n    return @spring.position if @state == :idle\n\n    position = @spring.update(delta)\n\n    # Check if animation complete (velocity near zero, at target)\n    if (@spring.position - @spring.target).abs < 0.01 && @spring.velocity.abs < 0.01\n      @state = :idle\n    end\n\n    position\n  end\n\n  def animating?\n    @state == :animating\n  end\nend\n```\n\n## Performance Tips\n\n1. **Frame rate**: 30-60 FPS is usually sufficient\n2. **Batch updates**: Update all springs in one tick\n3. **Stop when settled**: Skip updates when animation complete\n4. **Reuse springs**: Don't create new spring objects every frame\n\n```ruby\ndef tick_cmd\n  # Only continue animation if springs are moving\n  if animation_active?\n    Bubbletea.tick(1.0 / 60.0) { TickMsg.new }\n  else\n    nil\n  end\nend\n\ndef animation_active?\n  @springs.values.any? do |spring|\n    (spring.position - spring.target).abs > 0.001 ||\n    spring.velocity.abs > 0.001\n  end\nend\n```\n\n## Resources\n\n- [harmonica-ruby GitHub](https://github.com/marcoroth/harmonica-ruby)\n- [Original Go harmonica](https://github.com/charmbracelet/harmonica)\n- [Spring physics explanation](https://blog.maximeheckel.com/posts/the-physics-behind-spring-animations/)\n",
        "skills/charm-ruby-development/references/huh-forms.md": "# Huh Forms Reference\n\n## Overview\n\nHuh simplifies building interactive terminal forms with validation, theming, and multiple input types. It handles the complexity of form navigation, focus management, and input validation.\n\n## Installation\n\nCurrently, Huh must be installed from GitHub (gem name resolution pending):\n\n```ruby\n# Gemfile\ngem \"huh\", github: \"marcoroth/huh-ruby\"\n```\n\nThen run `bundle install`.\n\n## Basic Form\n\n```ruby\nrequire \"huh\"\n\nform = Huh::Form.new do |f|\n  f.group do |g|\n    g.input :name, title: \"What's your name?\"\n    g.input :email, title: \"Email address\"\n  end\nend\n\nresult = form.run\n\nputs \"Name: #{result[:name]}\"\nputs \"Email: #{result[:email]}\"\n```\n\n## Input Types\n\n### Text Input\n\nSingle-line text input:\n\n```ruby\ng.input :username,\n  title: \"Username\",\n  description: \"Choose a unique username\",\n  placeholder: \"Enter username...\",\n  value: \"default_value\",        # Initial value\n  char_limit: 20,                # Max characters\n  validate: ->(v) { v.length >= 3 ? nil : \"Must be at least 3 characters\" }\n```\n\n### Text Area\n\nMulti-line text input:\n\n```ruby\ng.text :bio,\n  title: \"Tell us about yourself\",\n  description: \"Write a short bio\",\n  placeholder: \"Enter your bio...\",\n  char_limit: 500,\n  height: 5                      # Number of visible lines\n```\n\n### Select\n\nSingle choice from options:\n\n```ruby\ng.select :color,\n  title: \"Favorite color\",\n  options: %w[Red Green Blue Yellow],\n  value: \"Blue\"                  # Default selection\n\n# With detailed options\ng.select :plan,\n  title: \"Choose a plan\",\n  options: [\n    { value: \"free\", label: \"Free\", description: \"Basic features\" },\n    { value: \"pro\", label: \"Pro\", description: \"All features, $10/mo\" },\n    { value: \"enterprise\", label: \"Enterprise\", description: \"Custom pricing\" }\n  ]\n```\n\n### Multi-Select\n\nMultiple choices:\n\n```ruby\ng.multi_select :features,\n  title: \"Select features to enable\",\n  options: [\n    { value: \"auth\", label: \"Authentication\" },\n    { value: \"api\", label: \"API Access\" },\n    { value: \"export\", label: \"Data Export\" },\n    { value: \"notify\", label: \"Notifications\" }\n  ],\n  selected: [\"auth\"],            # Pre-selected values\n  min: 1,                        # Minimum selections required\n  max: 3                         # Maximum selections allowed\n```\n\n### Confirm\n\nYes/No question:\n\n```ruby\ng.confirm :agree,\n  title: \"Do you agree to the terms of service?\",\n  affirmative: \"Yes, I agree\",   # Custom yes text\n  negative: \"No, I don't\"        # Custom no text\n```\n\n### Note\n\nDisplay-only text (no input):\n\n```ruby\ng.note :info,\n  title: \"Important\",\n  description: \"Please read the following carefully before proceeding.\"\n```\n\n## Form Groups\n\nGroups organize related inputs. Forms can have multiple groups that appear sequentially:\n\n```ruby\nform = Huh::Form.new do |f|\n  # First screen\n  f.group do |g|\n    g.input :name, title: \"Name\"\n    g.input :email, title: \"Email\"\n  end\n\n  # Second screen\n  f.group do |g|\n    g.input :company, title: \"Company\"\n    g.input :role, title: \"Role\"\n  end\n\n  # Third screen\n  f.group do |g|\n    g.confirm :subscribe, title: \"Subscribe to newsletter?\"\n    g.confirm :agree, title: \"Agree to terms?\"\n  end\nend\n```\n\n## Validation\n\n### Simple Validation\n\n```ruby\ng.input :email,\n  title: \"Email\",\n  validate: ->(v) {\n    return \"Email is required\" if v.empty?\n    return \"Invalid email format\" unless v.include?(\"@\")\n    nil  # Return nil for valid input\n  }\n```\n\n### Multiple Validations\n\n```ruby\ng.input :password,\n  title: \"Password\",\n  validate: ->(v) {\n    errors = []\n    errors << \"at least 8 characters\" if v.length < 8\n    errors << \"one uppercase letter\" unless v.match?(/[A-Z]/)\n    errors << \"one lowercase letter\" unless v.match?(/[a-z]/)\n    errors << \"one number\" unless v.match?(/[0-9]/)\n\n    errors.empty? ? nil : \"Password must have #{errors.join(', ')}\"\n  }\n```\n\n### Cross-Field Validation\n\nValidate against other fields using form-level validation:\n\n```ruby\nform = Huh::Form.new do |f|\n  f.group do |g|\n    g.input :password, title: \"Password\"\n    g.input :confirm, title: \"Confirm Password\"\n  end\n\n  f.validate do |data|\n    if data[:password] != data[:confirm]\n      { confirm: \"Passwords do not match\" }\n    else\n      {}\n    end\n  end\nend\n```\n\n## Theming\n\n### Built-in Themes\n\n```ruby\nform = Huh::Form.new(theme: :dracula) do |f|\n  # ...\nend\n\n# Available themes: :default, :dracula, :catppuccin, :charm, :base16\n```\n\n### Custom Theme\n\n```ruby\ntheme = Huh::Theme.new do |t|\n  # Colors\n  t.primary = \"#FF69B4\"\n  t.secondary = \"#888888\"\n  t.background = \"#1A1A2E\"\n\n  # Focus styling\n  t.focused do |s|\n    s.title = Lipgloss::Style.new.foreground(\"#FF69B4\").bold(true)\n    s.description = Lipgloss::Style.new.foreground(\"#888888\")\n    s.cursor = Lipgloss::Style.new.foreground(\"#FF69B4\")\n  end\n\n  # Blurred (unfocused) styling\n  t.blurred do |s|\n    s.title = Lipgloss::Style.new.foreground(\"#666666\")\n    s.description = Lipgloss::Style.new.foreground(\"#444444\")\n  end\n\n  # Option styling (for selects)\n  t.option do |s|\n    s.selected = Lipgloss::Style.new.foreground(\"#FF69B4\")\n    s.unselected = Lipgloss::Style.new.foreground(\"#888888\")\n  end\n\n  # Error styling\n  t.error = Lipgloss::Style.new.foreground(\"#FF0000\")\nend\n\nform = Huh::Form.new(theme: theme) do |f|\n  # ...\nend\n```\n\n## Keyboard Navigation\n\nDefault keybindings in Huh forms:\n\n| Key | Action |\n|-----|--------|\n| `Tab` / `↓` | Next field |\n| `Shift+Tab` / `↑` | Previous field |\n| `Enter` | Submit current field / Next group |\n| `Space` | Toggle (confirm/multi-select) |\n| `Esc` | Cancel form |\n| `Ctrl+C` | Cancel form |\n\n## Conditional Fields\n\nShow fields based on previous answers:\n\n```ruby\nform = Huh::Form.new do |f|\n  f.group do |g|\n    g.select :type,\n      title: \"Account type\",\n      options: %w[Personal Business]\n  end\n\n  f.group(visible: ->(data) { data[:type] == \"Business\" }) do |g|\n    g.input :company, title: \"Company name\"\n    g.input :tax_id, title: \"Tax ID\"\n  end\n\n  f.group(visible: ->(data) { data[:type] == \"Personal\" }) do |g|\n    g.input :birthdate, title: \"Birth date\"\n  end\nend\n```\n\n## Form Options\n\n```ruby\nform = Huh::Form.new(\n  theme: :charm,\n  accessible: true,              # Screen reader friendly\n  show_help: true,               # Show keybinding hints\n  width: 60                      # Form width\n) do |f|\n  # ...\nend\n```\n\n## Handling Results\n\n### Basic Result Access\n\n```ruby\nresult = form.run\n\n# Access by key\nname = result[:name]\nemail = result[:email]\n\n# Check if form was cancelled\nif result.cancelled?\n  puts \"Form cancelled\"\n  exit 1\nend\n```\n\n### Result Methods\n\n```ruby\nresult = form.run\n\nresult[:field_name]    # Get specific field value\nresult.to_h            # Convert to hash\nresult.cancelled?      # Was form cancelled?\nresult.completed?      # Was form completed?\n```\n\n## Advanced Patterns\n\n### Wizard-Style Form\n\n```ruby\ndef create_wizard\n  Huh::Form.new do |f|\n    # Step 1: Basic Info\n    f.group do |g|\n      g.note :step1, title: \"Step 1 of 3: Basic Information\"\n      g.input :name, title: \"Full name\"\n      g.input :email, title: \"Email\"\n    end\n\n    # Step 2: Preferences\n    f.group do |g|\n      g.note :step2, title: \"Step 2 of 3: Preferences\"\n      g.select :language, title: \"Preferred language\", options: %w[English Spanish French]\n      g.multi_select :notifications, title: \"Notifications\", options: %w[Email SMS Push]\n    end\n\n    # Step 3: Confirmation\n    f.group do |g|\n      g.note :step3, title: \"Step 3 of 3: Confirm\"\n      g.confirm :confirm, title: \"Is all information correct?\"\n    end\n  end\nend\n```\n\n### Inline Form (No Full Screen)\n\n```ruby\n# Run form without taking over terminal\nresult = form.run(inline: true)\n```\n\n### Programmatic Control\n\n```ruby\nform = Huh::Form.new do |f|\n  # ...\nend\n\n# Set initial values\nform.set_value(:name, \"John Doe\")\nform.set_value(:email, \"john@example.com\")\n\n# Skip to specific group\nform.goto_group(2)\n\n# Run with pre-populated values\nresult = form.run\n```\n\n### Dynamic Options\n\n```ruby\n# Fetch options from external source\ndef get_country_options\n  countries = fetch_countries_from_api\n  countries.map { |c| { value: c.code, label: c.name } }\nend\n\nform = Huh::Form.new do |f|\n  f.group do |g|\n    g.select :country,\n      title: \"Country\",\n      options: get_country_options\n  end\nend\n```\n\n## Integration with Bubble Tea\n\nHuh forms can run standalone or be integrated into a larger Bubble Tea application:\n\n```ruby\nclass AppModel\n  include Bubbletea::Model\n\n  def initialize\n    @state = :menu\n    @form = nil\n    @form_result = nil\n  end\n\n  def update(msg)\n    case @state\n    when :menu\n      if msg.is_a?(Bubbletea::KeyMsg) && msg.string == \"n\"\n        @form = create_user_form\n        @state = :form\n      end\n    when :form\n      if @form.done?\n        @form_result = @form.result\n        @state = :result\n      else\n        @form.update(msg)\n      end\n    end\n    [self, nil]\n  end\n\n  def view\n    case @state\n    when :menu\n      \"Press 'n' to create new user\"\n    when :form\n      @form.view\n    when :result\n      \"Created user: #{@form_result[:name]}\"\n    end\n  end\n\n  private\n\n  def create_user_form\n    Huh::Form.new do |f|\n      f.group do |g|\n        g.input :name, title: \"Name\"\n        g.input :email, title: \"Email\"\n      end\n    end\n  end\nend\n```\n\n## Error Handling\n\n```ruby\nbegin\n  result = form.run\nrescue Huh::CancelledError\n  puts \"Form was cancelled\"\n  exit 1\nrescue Huh::ValidationError => e\n  puts \"Validation failed: #{e.message}\"\n  puts \"Errors: #{e.errors}\"\nend\n```\n\n## Best Practices\n\n1. **Keep groups focused**: Each group should represent one logical step\n2. **Provide helpful descriptions**: Use `description` to explain expected input\n3. **Use placeholders**: Show example values in placeholders\n4. **Validate early**: Catch errors at the field level when possible\n5. **Theme consistently**: Match form theme to your application's style\n6. **Handle cancellation**: Always check if form was cancelled\n7. **Pre-populate when possible**: Set sensible defaults to reduce user effort\n",
        "skills/charm-ruby-development/references/lipgloss-styling.md": "# Lipgloss Styling Reference\n\n## Overview\n\nLipgloss provides CSS-like styling for terminal output. Styles are created through method chaining and applied with `render`.\n\n## Creating Styles\n\n```ruby\nrequire \"lipgloss\"\n\n# Empty style\nstyle = Lipgloss::Style.new\n\n# Chained style\nstyle = Lipgloss::Style.new\n  .bold(true)\n  .foreground(\"#FFFFFF\")\n  .background(\"#7D56F4\")\n  .padding(1, 2)\n\n# Apply to text\noutput = style.render(\"Hello, World!\")\n```\n\n## Colors\n\n### Color Formats\n\n```ruby\n# Hex colors (true color)\nstyle.foreground(\"#FF5733\")\nstyle.background(\"#1A1A2E\")\n\n# ANSI 256 colors (0-255)\nstyle.foreground(\"201\")  # Hot pink\nstyle.background(\"236\")  # Dark gray\n\n# ANSI 16 basic colors\nstyle.foreground(\"red\")\nstyle.foreground(\"bright-blue\")\n# Available: black, red, green, yellow, blue, magenta, cyan, white\n# Bright variants: bright-black, bright-red, etc.\n\n# No color (transparent)\nstyle.foreground(\"\")\n```\n\n### Adaptive Colors\n\nAutomatically adjust for light/dark terminal backgrounds:\n\n```ruby\n# Lipgloss.adaptive_color(light_bg_color, dark_bg_color)\ntext_color = Lipgloss.adaptive_color(\"#333333\", \"#EEEEEE\")\nstyle = Lipgloss::Style.new.foreground(text_color)\n```\n\n### Complete Colors\n\nDefine colors for all color profiles:\n\n```ruby\ncolor = Lipgloss.complete_color(\n  true_color: \"#FF5733\",\n  ansi256: \"202\",\n  ansi: \"red\"\n)\nstyle.foreground(color)\n```\n\n## Text Formatting\n\n### Font Styles\n\n```ruby\nstyle\n  .bold(true)\n  .italic(true)\n  .underline(true)\n  .strikethrough(true)\n  .reverse(true)       # Swap foreground/background\n  .blink(true)         # Terminal support varies\n  .faint(true)         # Dimmed text\n```\n\n### Disabling Styles\n\n```ruby\n# Turn off inherited styles\nstyle.bold(false)\nstyle.underline(false)\n```\n\n## Spacing\n\n### Padding\n\nSpace inside the border:\n\n```ruby\n# All sides\nstyle.padding(2)\n\n# Vertical, horizontal\nstyle.padding(1, 2)\n\n# Top, right, bottom, left\nstyle.padding(1, 2, 1, 2)\n\n# Individual sides\nstyle.padding_top(1)\nstyle.padding_right(2)\nstyle.padding_bottom(1)\nstyle.padding_left(2)\n```\n\n### Margin\n\nSpace outside the border:\n\n```ruby\n# All sides\nstyle.margin(2)\n\n# Vertical, horizontal\nstyle.margin(1, 2)\n\n# Top, right, bottom, left\nstyle.margin(1, 2, 1, 2)\n\n# Individual sides\nstyle.margin_top(1)\nstyle.margin_right(2)\nstyle.margin_bottom(1)\nstyle.margin_left(2)\n```\n\n## Dimensions\n\n### Width and Height\n\n```ruby\n# Fixed width (pads with spaces if shorter)\nstyle.width(40)\n\n# Fixed height (pads with newlines if shorter)\nstyle.height(10)\n\n# Max width (truncates if longer)\nstyle.max_width(80)\n\n# Max height\nstyle.max_height(20)\n```\n\n### Alignment\n\n```ruby\n# Horizontal alignment (requires width to be set)\nstyle.width(40).align(:left)\nstyle.width(40).align(:center)\nstyle.width(40).align(:right)\n\n# Vertical alignment (requires height to be set)\nstyle.height(10).align_vertical(:top)\nstyle.height(10).align_vertical(:middle)\nstyle.height(10).align_vertical(:bottom)\n```\n\n## Borders\n\n### Border Styles\n\n```ruby\n# Built-in styles\nstyle.border(:normal)    # Single line\nstyle.border(:rounded)   # Rounded corners\nstyle.border(:double)    # Double line\nstyle.border(:thick)     # Thick line\nstyle.border(:hidden)    # Space reserved but invisible\n\n# No border\nstyle.border(:none)\n```\n\n### Border Sides\n\n```ruby\n# All sides\nstyle.border(:rounded)\n\n# Specific sides only\nstyle.border(:rounded, true, false, true, false)  # top, right, bottom, left\n\n# Individual methods\nstyle.border_top(true)\nstyle.border_right(false)\nstyle.border_bottom(true)\nstyle.border_left(false)\n```\n\n### Border Colors\n\n```ruby\n# All borders same color\nstyle.border_foreground(\"#FF0000\")\nstyle.border_background(\"#000000\")\n\n# Different colors per side\nstyle.border_top_foreground(\"#FF0000\")\nstyle.border_right_foreground(\"#00FF00\")\nstyle.border_bottom_foreground(\"#0000FF\")\nstyle.border_left_foreground(\"#FFFF00\")\n```\n\n### Custom Borders\n\n```ruby\ncustom_border = Lipgloss::Border.new(\n  top: \"─\",\n  bottom: \"─\",\n  left: \"│\",\n  right: \"│\",\n  top_left: \"╭\",\n  top_right: \"╮\",\n  bottom_left: \"╰\",\n  bottom_right: \"╯\"\n)\nstyle.border(custom_border)\n```\n\n## Layout Helpers\n\n### Joining Text\n\n```ruby\n# Horizontal join\nleft = style1.render(\"Left\")\nright = style2.render(\"Right\")\ncombined = Lipgloss.join_horizontal(:top, left, right)\ncombined = Lipgloss.join_horizontal(:center, left, right)\ncombined = Lipgloss.join_horizontal(:bottom, left, right)\n\n# Vertical join\ntop = style1.render(\"Top\")\nbottom = style2.render(\"Bottom\")\ncombined = Lipgloss.join_vertical(:left, top, bottom)\ncombined = Lipgloss.join_vertical(:center, top, bottom)\ncombined = Lipgloss.join_vertical(:right, top, bottom)\n```\n\n### Placing Text\n\n```ruby\n# Place text at specific position within a larger space\ncontent = style.render(\"Content\")\nresult = Lipgloss.place(\n  80,           # width\n  24,           # height\n  :center,      # horizontal position\n  :middle,      # vertical position\n  content\n)\n```\n\n## Tables\n\nLipgloss includes a table renderer:\n\n```ruby\ntable = Lipgloss::Table.new do |t|\n  t.headers = [\"Name\", \"Age\", \"City\"]\n  t.rows = [\n    [\"Alice\", \"30\", \"New York\"],\n    [\"Bob\", \"25\", \"San Francisco\"],\n    [\"Charlie\", \"35\", \"Chicago\"]\n  ]\n\n  # Styling\n  t.border(:rounded)\n  t.border_foreground(\"#888888\")\n\n  # Column widths\n  t.width(60)\n\n  # Header style\n  t.header_style = Lipgloss::Style.new.bold(true).foreground(\"#FFFFFF\")\n\n  # Cell style\n  t.cell_style = Lipgloss::Style.new.padding(0, 1)\n\n  # Alternating row colors\n  t.row_styles = [\n    Lipgloss::Style.new.background(\"#1A1A2E\"),\n    Lipgloss::Style.new.background(\"#2A2A3E\")\n  ]\nend\n\nputs table.render\n```\n\n## Lists\n\n```ruby\nlist = Lipgloss::List.new do |l|\n  l.items = [\"First item\", \"Second item\", \"Third item\"]\n\n  # Bullet style\n  l.enumerator = \"• \"  # or \"- \", \"→ \", numbers, etc.\n\n  # Item style\n  l.item_style = Lipgloss::Style.new.foreground(\"#AAAAAA\")\n\n  # Nested lists\n  l.items = [\n    \"Parent item\",\n    Lipgloss::List.new { |nested|\n      nested.items = [\"Child 1\", \"Child 2\"]\n      nested.enumerator = \"  ◦ \"\n    }\n  ]\nend\n\nputs list.render\n```\n\n## Trees\n\n```ruby\ntree = Lipgloss::Tree.new do |t|\n  t.root = \"Project\"\n  t.items = [\n    \"src/\",\n    Lipgloss::Tree.new { |sub|\n      sub.root = \"lib/\"\n      sub.items = [\"main.rb\", \"utils.rb\"]\n    },\n    \"README.md\",\n    \"Gemfile\"\n  ]\n\n  # Branch characters\n  t.enumerator = Lipgloss::TreeEnumerator.new(\n    branch: \"├── \",\n    last_branch: \"└── \",\n    indent: \"│   \",\n    last_indent: \"    \"\n  )\nend\n\nputs tree.render\n```\n\n## Style Inheritance\n\n### Copying Styles\n\n```ruby\nbase_style = Lipgloss::Style.new\n  .foreground(\"#FFFFFF\")\n  .padding(1, 2)\n\n# Copy and extend\nhighlight_style = base_style.copy\n  .background(\"#FF0000\")\n  .bold(true)\n```\n\n### Unsetting Properties\n\n```ruby\n# Remove a property (inherit from parent or use default)\nstyle.unset_foreground\nstyle.unset_background\nstyle.unset_padding\nstyle.unset_border\n```\n\n## Common Patterns\n\n### Status Indicators\n\n```ruby\nsuccess_style = Lipgloss::Style.new\n  .foreground(\"#00FF00\")\n  .bold(true)\n\nerror_style = Lipgloss::Style.new\n  .foreground(\"#FF0000\")\n  .bold(true)\n\nwarning_style = Lipgloss::Style.new\n  .foreground(\"#FFFF00\")\n\ninfo_style = Lipgloss::Style.new\n  .foreground(\"#00FFFF\")\n\ndef status_badge(type, text)\n  case type\n  when :success then success_style.render(\"✓ #{text}\")\n  when :error   then error_style.render(\"✗ #{text}\")\n  when :warning then warning_style.render(\"⚠ #{text}\")\n  when :info    then info_style.render(\"ℹ #{text}\")\n  end\nend\n```\n\n### Panels and Boxes\n\n```ruby\npanel_style = Lipgloss::Style.new\n  .border(:rounded)\n  .border_foreground(\"#888888\")\n  .padding(1, 2)\n  .margin(1)\n\ntitle_style = Lipgloss::Style.new\n  .bold(true)\n  .foreground(\"#FFFFFF\")\n  .background(\"#7D56F4\")\n  .padding(0, 1)\n\ndef panel(title, content)\n  header = title_style.render(title)\n  body = panel_style.render(content)\n  Lipgloss.join_vertical(:left, header, body)\nend\n```\n\n### Responsive Width\n\n```ruby\ndef responsive_style(terminal_width)\n  Lipgloss::Style.new\n    .width([terminal_width - 4, 80].min)\n    .padding(1, 2)\nend\n```\n\n### Progress Bar\n\n```ruby\ndef progress_bar(percent, width = 40)\n  filled = (width * percent / 100.0).round\n  empty = width - filled\n\n  filled_style = Lipgloss::Style.new.background(\"#00FF00\")\n  empty_style = Lipgloss::Style.new.background(\"#333333\")\n\n  bar = filled_style.render(\" \" * filled) + empty_style.render(\" \" * empty)\n  \"#{bar} #{percent}%\"\nend\n```\n\n## Performance Tips\n\n1. **Reuse styles**: Create styles once, reuse in `view`\n2. **Avoid in loops**: Don't create new styles inside render loops\n3. **Cache dimensions**: Store terminal width, don't recalculate every frame\n4. **Minimize nesting**: Deep style nesting can slow rendering\n\n```ruby\nclass MyModel\n  def initialize\n    # Create styles once\n    @title_style = Lipgloss::Style.new.bold(true).foreground(\"#FFFFFF\")\n    @item_style = Lipgloss::Style.new.foreground(\"#AAAAAA\")\n    @selected_style = @item_style.copy.reverse(true)\n  end\n\n  def view\n    # Reuse pre-created styles\n    lines = @items.map.with_index do |item, i|\n      style = i == @cursor ? @selected_style : @item_style\n      style.render(item)\n    end\n    lines.join(\"\\n\")\n  end\nend\n```\n",
        "skills/charm-ruby-development/references/ntcharts-visualization.md": "# Nimble Terminal Charts (ntcharts)\n\nntcharts provides terminal-native data visualization for Ruby CLI applications. It renders charts directly in the terminal using Unicode characters, making it ideal for dashboards, monitoring tools, and data exploration CLIs.\n\n## Installation\n\n```ruby\n# Gemfile\ngem \"ntcharts\"\n```\n\n## Chart Types\n\n### Sparklines\n\nCompact inline charts for showing trends in minimal space:\n\n```ruby\nrequire \"ntcharts\"\n\ndata = [4, 2, 1, 6, 3, 9, 1, 4, 2, 15, 14, 9, 8, 6, 10, 13, 15, 12, 10, 5, 3, 6, 1]\n\nsparkline = Ntcharts::Sparkline.new(data)\nputs sparkline.render\n# Output: ▂▁▁▃▂▅▁▂▁█▇▅▄▃▅▇█▆▅▃▂▃▁\n```\n\n**Customization options:**\n\n```ruby\nsparkline = Ntcharts::Sparkline.new(data)\nsparkline.width = 40           # Fixed width\nsparkline.style = Lipgloss::Style.new.foreground(\"#FF69B4\")\n\n# With min/max labels\nsparkline.show_min_max = true\n```\n\n### Bar Charts\n\nHorizontal or vertical bar charts for comparing values:\n\n```ruby\nrequire \"ntcharts\"\n\n# Horizontal bar chart\ndata = [\n  { label: \"Ruby\", value: 85 },\n  { label: \"Python\", value: 72 },\n  { label: \"Go\", value: 68 },\n  { label: \"Rust\", value: 45 }\n]\n\nbar_chart = Ntcharts::BarChart.new(data)\nbar_chart.orientation = :horizontal\nbar_chart.width = 50\nbar_chart.bar_style = Lipgloss::Style.new.foreground(\"#7D56F4\")\n\nputs bar_chart.render\n```\n\n**Output:**\n\n```\nRuby   ████████████████████████████████████████  85\nPython ████████████████████████████████          72\nGo     ██████████████████████████████            68\nRust   ████████████████████                      45\n```\n\n**Vertical bars:**\n\n```ruby\nbar_chart = Ntcharts::BarChart.new(data)\nbar_chart.orientation = :vertical\nbar_chart.height = 10\nbar_chart.show_values = true\n```\n\n### Line Charts\n\nFor time series or continuous data:\n\n```ruby\nrequire \"ntcharts\"\n\n# Single series\ndata = [10, 15, 12, 18, 22, 19, 25, 28, 24, 30]\n\nline_chart = Ntcharts::LineChart.new(data)\nline_chart.width = 60\nline_chart.height = 15\nline_chart.style = Lipgloss::Style.new.foreground(\"#00FF00\")\n\nputs line_chart.render\n```\n\n**Multiple series:**\n\n```ruby\nseries = {\n  \"CPU\" => [45, 52, 48, 55, 60, 58, 62],\n  \"Memory\" => [30, 32, 35, 33, 38, 40, 42]\n}\n\nline_chart = Ntcharts::LineChart.new\nline_chart.add_series(\"CPU\", series[\"CPU\"], color: \"#FF6B6B\")\nline_chart.add_series(\"Memory\", series[\"Memory\"], color: \"#4ECDC4\")\nline_chart.show_legend = true\n\nputs line_chart.render\n```\n\n### Heatmaps\n\nFor visualizing 2D data matrices:\n\n```ruby\nrequire \"ntcharts\"\n\n# Activity heatmap (like GitHub contribution graph)\ndata = [\n  [0, 1, 2, 3, 4, 5, 2, 1],\n  [1, 2, 4, 5, 3, 2, 1, 0],\n  [2, 3, 5, 4, 2, 1, 3, 2],\n  [0, 1, 3, 5, 4, 3, 2, 1],\n  [1, 0, 2, 4, 5, 4, 3, 2]\n]\n\nheatmap = Ntcharts::Heatmap.new(data)\nheatmap.color_scale = [:black, :dark_green, :green, :bright_green]\nheatmap.cell_width = 2\n\nputs heatmap.render\n```\n\n**Custom color scales:**\n\n```ruby\nheatmap.color_scale = [\"#161B22\", \"#0E4429\", \"#006D32\", \"#26A641\", \"#39D353\"]\n```\n\n## Integration with Bubble Tea\n\nUse ntcharts in Bubble Tea models for live-updating dashboards:\n\n```ruby\nrequire \"bubbletea\"\nrequire \"ntcharts\"\nrequire \"lipgloss\"\n\nclass DashboardModel\n  include Bubbletea::Model\n\n  def initialize\n    @data = []\n    @sparkline = Ntcharts::Sparkline.new([])\n    setup_styles\n  end\n\n  def init\n    tick_cmd\n  end\n\n  def update(msg)\n    case msg\n    when TickMsg\n      # Add new data point\n      @data << rand(1..100)\n      @data.shift if @data.length > 50\n      @sparkline = Ntcharts::Sparkline.new(@data)\n      return [self, tick_cmd]\n    when Bubbletea::KeyMsg\n      return [self, Bubbletea.quit] if msg.string == \"q\"\n    end\n    [self, nil]\n  end\n\n  def view\n    title = @title_style.render(\"System Load\")\n    chart = @sparkline.render\n\n    \"#{title}\\n\\n#{chart}\\n\\nPress q to quit\"\n  end\n\n  private\n\n  def tick_cmd\n    Bubbletea.tick(1) { TickMsg.new }\n  end\n\n  def setup_styles\n    @title_style = Lipgloss::Style.new\n      .bold(true)\n      .foreground(\"#FFFFFF\")\n      .background(\"#7D56F4\")\n      .padding(0, 1)\n  end\nend\n\nclass TickMsg; end\n\nBubbletea.run(DashboardModel.new)\n```\n\n## Dashboard Layout\n\nCombine multiple charts with Lipgloss layout:\n\n```ruby\nrequire \"ntcharts\"\nrequire \"lipgloss\"\n\nclass MultiChartDashboard\n  def initialize\n    @cpu_data = Array.new(20) { rand(20..80) }\n    @memory_data = Array.new(20) { rand(30..70) }\n    @disk_usage = [\n      { label: \"/\", value: 65 },\n      { label: \"/home\", value: 82 },\n      { label: \"/var\", value: 45 }\n    ]\n    setup_charts\n    setup_styles\n  end\n\n  def render\n    # Create chart panels\n    cpu_panel = render_panel(\"CPU Usage\", @cpu_sparkline.render)\n    memory_panel = render_panel(\"Memory\", @memory_sparkline.render)\n    disk_panel = render_panel(\"Disk Usage\", @disk_chart.render)\n\n    # Layout: two sparklines on top, bar chart below\n    top_row = Lipgloss.join_horizontal(:top, cpu_panel, memory_panel)\n    Lipgloss.join_vertical(:left, top_row, disk_panel)\n  end\n\n  private\n\n  def render_panel(title, content)\n    @panel_style.render(\"#{@title_style.render(title)}\\n#{content}\")\n  end\n\n  def setup_charts\n    @cpu_sparkline = Ntcharts::Sparkline.new(@cpu_data)\n    @memory_sparkline = Ntcharts::Sparkline.new(@memory_data)\n    @disk_chart = Ntcharts::BarChart.new(@disk_usage)\n    @disk_chart.orientation = :horizontal\n    @disk_chart.width = 30\n  end\n\n  def setup_styles\n    @panel_style = Lipgloss::Style.new\n      .border(:rounded)\n      .padding(1)\n      .margin(0, 1)\n      .width(35)\n\n    @title_style = Lipgloss::Style.new\n      .bold(true)\n      .foreground(\"#FF69B4\")\n  end\nend\n```\n\n## Chart Styling\n\nAll ntcharts components support Lipgloss styling:\n\n```ruby\n# Styled sparkline\nsparkline = Ntcharts::Sparkline.new(data)\nsparkline.style = Lipgloss::Style.new\n  .foreground(\"#7D56F4\")\n  .background(\"#1a1a2e\")\n\n# Styled bar chart with custom bar colors\nbar_chart = Ntcharts::BarChart.new(data)\nbar_chart.bar_style = Lipgloss::Style.new.foreground(\"#FF6B6B\")\nbar_chart.label_style = Lipgloss::Style.new.foreground(\"#888888\")\nbar_chart.value_style = Lipgloss::Style.new.bold(true)\n\n# Adaptive colors for light/dark terminals\nsparkline.style = Lipgloss::Style.new\n  .foreground(Lipgloss.adaptive_color(\"#000000\", \"#FFFFFF\"))\n```\n\n## Performance Considerations\n\n- **Buffer updates**: For real-time charts, buffer data points and update periodically\n- **Fixed dimensions**: Set explicit width/height to avoid recalculation\n- **Data windowing**: Keep only recent data points (e.g., last 100)\n- **Render caching**: Cache chart renders when data hasn't changed\n\n```ruby\nclass OptimizedChart\n  def initialize\n    @data = []\n    @last_render = nil\n    @data_changed = false\n  end\n\n  def add_point(value)\n    @data << value\n    @data.shift if @data.length > 100\n    @data_changed = true\n  end\n\n  def render\n    return @last_render unless @data_changed\n\n    @last_render = @sparkline.render\n    @data_changed = false\n    @last_render\n  end\nend\n```\n\n## Common Patterns\n\n### Progress Dashboard\n\n```ruby\ntasks = [\n  { name: \"Download\", progress: 0.75 },\n  { name: \"Extract\", progress: 0.45 },\n  { name: \"Install\", progress: 0.20 }\n]\n\ntasks.each do |task|\n  bar = Ntcharts::ProgressBar.new(task[:progress])\n  bar.width = 30\n  puts \"#{task[:name].ljust(10)} #{bar.render} #{(task[:progress] * 100).to_i}%\"\nend\n```\n\n### Real-time Metrics\n\n```ruby\ndef render_metrics(cpu, memory, network)\n  cpu_spark = Ntcharts::Sparkline.new(cpu)\n  mem_spark = Ntcharts::Sparkline.new(memory)\n  net_spark = Ntcharts::Sparkline.new(network)\n\n  [\n    \"CPU:     #{cpu_spark.render}\",\n    \"Memory:  #{mem_spark.render}\",\n    \"Network: #{net_spark.render}\"\n  ].join(\"\\n\")\nend\n```\n\n## Resources\n\n- [ntcharts-ruby GitHub](https://github.com/marcoroth/ntcharts-ruby)\n- [Original Go ntcharts](https://github.com/NimbleMarkets/ntcharts)\n",
        "skills/charm-ruby-development/references/testing-tui-applications.md": "# Testing TUI Applications\n\nThis reference covers strategies and patterns for testing terminal user interface applications built with Bubble Tea.\n\n---\n\n## Testing Philosophy\n\n### Separation of Concerns\n\nThe MVU (Model-View-Update) architecture naturally supports testing:\n\n- **Model**: Pure data, easily inspectable\n- **Update**: Pure function, given input → output\n- **View**: String output, easy to assert against\n\n```ruby\n# Model is just data - easy to create test fixtures\nmodel = MyModel.new\nmodel.items = [\"a\", \"b\", \"c\"]\nmodel.cursor = 1\n\n# Update is deterministic - same input = same output\nnew_model, cmd = model.update(Bubbletea::KeyMsg.new(\"down\"))\nexpect(new_model.cursor).to eq(2)\n\n# View is a string - easy to assert\noutput = model.view\nexpect(output).to include(\"b\")  # Selected item\n```\n\n---\n\n## Unit Testing Models\n\n### Testing Initial State\n\n```ruby\nRSpec.describe MyModel do\n  describe \"#initialize\" do\n    it \"starts with default values\" do\n      model = MyModel.new\n\n      expect(model.cursor).to eq(0)\n      expect(model.items).to be_empty\n      expect(model.loading).to be false\n    end\n\n    it \"accepts initial configuration\" do\n      model = MyModel.new(items: [\"a\", \"b\"], selected: 1)\n\n      expect(model.items).to eq([\"a\", \"b\"])\n      expect(model.cursor).to eq(1)\n    end\n  end\nend\n```\n\n### Testing Update Logic\n\nTest each message type and verify state transitions:\n\n```ruby\nRSpec.describe MyModel do\n  describe \"#update\" do\n    let(:model) { MyModel.new(items: %w[one two three]) }\n\n    context \"with KeyMsg\" do\n      it \"moves cursor down on j/down\" do\n        new_model, _ = model.update(key_msg(\"j\"))\n        expect(new_model.cursor).to eq(1)\n\n        new_model, _ = model.update(key_msg(\"down\"))\n        expect(new_model.cursor).to eq(1)\n      end\n\n      it \"moves cursor up on k/up\" do\n        model.cursor = 2\n        new_model, _ = model.update(key_msg(\"k\"))\n        expect(new_model.cursor).to eq(1)\n      end\n\n      it \"wraps at boundaries\" do\n        model.cursor = 2\n        new_model, _ = model.update(key_msg(\"j\"))\n        expect(new_model.cursor).to eq(0)  # Wrapped to start\n      end\n\n      it \"returns quit command on q\" do\n        _, cmd = model.update(key_msg(\"q\"))\n        expect(cmd).to eq(Bubbletea.quit)\n      end\n    end\n\n    context \"with custom messages\" do\n      it \"updates on DataLoaded\" do\n        msg = DataLoaded.new(items: %w[x y z])\n        new_model, _ = model.update(msg)\n\n        expect(new_model.items).to eq(%w[x y z])\n        expect(new_model.loading).to be false\n      end\n\n      it \"handles errors gracefully\" do\n        msg = LoadError.new(message: \"Network failed\")\n        new_model, _ = model.update(msg)\n\n        expect(new_model.error).to eq(\"Network failed\")\n        expect(new_model.loading).to be false\n      end\n    end\n\n    # Helper to create key messages\n    def key_msg(key)\n      Bubbletea::KeyMsg.new(key)\n    end\n  end\nend\n```\n\n### Testing Commands\n\nCommands are functions that produce messages. Test them in isolation:\n\n```ruby\nRSpec.describe \"Commands\" do\n  describe \".fetch_data\" do\n    it \"returns DataLoaded on success\" do\n      allow(API).to receive(:get).and_return({ items: [\"a\"] })\n\n      result = fetch_data_cmd.call\n      expect(result).to be_a(DataLoaded)\n      expect(result.items).to eq([\"a\"])\n    end\n\n    it \"returns LoadError on failure\" do\n      allow(API).to receive(:get).and_raise(StandardError, \"timeout\")\n\n      result = fetch_data_cmd.call\n      expect(result).to be_a(LoadError)\n      expect(result.message).to include(\"timeout\")\n    end\n  end\nend\n```\n\n---\n\n## Testing Views\n\n### String Matching\n\nTest view output contains expected content:\n\n```ruby\nRSpec.describe MyModel do\n  describe \"#view\" do\n    let(:model) { MyModel.new(items: %w[Apple Banana Cherry]) }\n\n    it \"displays all items\" do\n      output = model.view\n      expect(output).to include(\"Apple\")\n      expect(output).to include(\"Banana\")\n      expect(output).to include(\"Cherry\")\n    end\n\n    it \"highlights selected item\" do\n      model.cursor = 1\n      output = model.view\n\n      # Selected item should have indicator\n      expect(output).to include(\"> Banana\")\n      # Others should not\n      expect(output).not_to include(\"> Apple\")\n    end\n\n    it \"shows help text\" do\n      output = model.view\n      expect(output).to include(\"q quit\")\n      expect(output).to include(\"↑/k up\")\n    end\n\n    it \"shows loading state\" do\n      model.loading = true\n      output = model.view\n      expect(output).to include(\"Loading\")\n    end\n\n    it \"shows error message\" do\n      model.error = \"Connection failed\"\n      output = model.view\n      expect(output).to include(\"Error: Connection failed\")\n    end\n  end\nend\n```\n\n### Snapshot Testing\n\nFor complex views, use snapshot testing:\n\n```ruby\nRSpec.describe MyModel do\n  describe \"#view\" do\n    it \"matches expected output\" do\n      model = MyModel.new(\n        items: %w[One Two Three],\n        cursor: 1,\n        title: \"Select Item\"\n      )\n\n      expect(model.view).to match_snapshot(\"item_list_view\")\n    end\n  end\nend\n\n# Snapshots stored in spec/snapshots/item_list_view.txt\n```\n\n---\n\n## Integration Testing\n\n### Golden File Testing\n\nCompare full program output against expected files:\n\n```ruby\nRSpec.describe \"Integration\" do\n  it \"produces expected output\" do\n    output = run_program([\"--items\", \"a,b,c\"])\n    expected = File.read(\"spec/fixtures/expected_output.txt\")\n\n    expect(output).to eq(expected)\n  end\nend\n```\n\n### Testing with Aruba\n\nAruba provides integration testing for CLI applications:\n\n```ruby\n# spec/spec_helper.rb\nrequire \"aruba/rspec\"\n\nRSpec.describe \"CLI\", type: :aruba do\n  it \"displays help\" do\n    run_command(\"mycli --help\")\n    expect(last_command_started).to have_output(/Usage: mycli/)\n  end\n\n  it \"processes files\" do\n    write_file(\"input.txt\", \"hello\")\n    run_command(\"mycli process input.txt\")\n\n    expect(last_command_started).to be_successfully_executed\n    expect(read(\"output.txt\")).to include(\"HELLO\")\n  end\n\n  it \"handles errors gracefully\" do\n    run_command(\"mycli process nonexistent.txt\")\n\n    expect(last_command_started).to have_exit_status(66)\n    expect(last_command_started.stderr).to include(\"File not found\")\n  end\nend\n```\n\n---\n\n## Testing Interactive Behavior\n\n### Simulating User Input\n\nCreate test helpers for common interactions:\n\n```ruby\nmodule TestHelpers\n  def simulate_keystrokes(model, keys)\n    keys.each_char do |key|\n      model, _ = model.update(Bubbletea::KeyMsg.new(key))\n    end\n    model\n  end\n\n  def simulate_sequence(model, messages)\n    messages.each do |msg|\n      model, _ = model.update(msg)\n    end\n    model\n  end\nend\n\nRSpec.configure do |c|\n  c.include TestHelpers\nend\n\n# Usage in tests\nit \"navigates to third item and selects\" do\n  model = MyModel.new(items: %w[a b c d])\n\n  model = simulate_keystrokes(model, \"jj\")  # Down twice\n  expect(model.cursor).to eq(2)\n\n  model, _ = model.update(key_msg(\"enter\"))\n  expect(model.selected).to eq(\"c\")\nend\n```\n\n### Testing State Machines\n\nFor complex flows, test state transitions:\n\n```ruby\nRSpec.describe \"Wizard flow\" do\n  let(:model) { WizardModel.new }\n\n  it \"progresses through screens\" do\n    # Start at welcome\n    expect(model.screen).to eq(:welcome)\n\n    # Move to name input\n    model, _ = model.update(key_msg(\"enter\"))\n    expect(model.screen).to eq(:name_input)\n\n    # Enter name and continue\n    model.name = \"Alice\"\n    model, _ = model.update(key_msg(\"enter\"))\n    expect(model.screen).to eq(:email_input)\n\n    # Complete wizard\n    model.email = \"alice@example.com\"\n    model, cmd = model.update(key_msg(\"enter\"))\n    expect(model.screen).to eq(:complete)\n    expect(model.result).to include(name: \"Alice\", email: \"alice@example.com\")\n  end\nend\n```\n\n---\n\n## Testing Components\n\n### Isolated Component Testing\n\nTest Bubbles components independently:\n\n```ruby\nRSpec.describe Bubbles::TextInput do\n  let(:input) { Bubbles::TextInput.new }\n\n  it \"accumulates typed characters\" do\n    input, _ = input.update(key_msg(\"h\"))\n    input, _ = input.update(key_msg(\"i\"))\n\n    expect(input.value).to eq(\"hi\")\n  end\n\n  it \"handles backspace\" do\n    input.value = \"hello\"\n    input, _ = input.update(key_msg(\"backspace\"))\n\n    expect(input.value).to eq(\"hell\")\n  end\n\n  it \"respects character limit\" do\n    input.char_limit = 5\n    input.value = \"hello\"\n\n    input, _ = input.update(key_msg(\"x\"))\n    expect(input.value).to eq(\"hello\")  # Unchanged\n  end\nend\n```\n\n### Testing Component Composition\n\nTest how components work together:\n\n```ruby\nRSpec.describe FormModel do\n  let(:model) { FormModel.new }\n\n  it \"tabs between fields\" do\n    expect(model.focused_field).to eq(:name)\n\n    model, _ = model.update(key_msg(\"tab\"))\n    expect(model.focused_field).to eq(:email)\n\n    model, _ = model.update(key_msg(\"tab\"))\n    expect(model.focused_field).to eq(:submit)\n  end\n\n  it \"passes input to focused field\" do\n    model, _ = model.update(key_msg(\"A\"))\n    expect(model.name_input.value).to eq(\"A\")\n    expect(model.email_input.value).to be_empty\n  end\nend\n```\n\n---\n\n## Testing Edge Cases\n\n### Terminal Size Handling\n\n```ruby\nRSpec.describe \"Responsive layout\" do\n  it \"renders compact view for narrow terminals\" do\n    model = MyModel.new\n    model.terminal_width = 40\n\n    output = model.view\n    output.lines.each do |line|\n      expect(line.length).to be <= 40\n    end\n  end\n\n  it \"renders full view for wide terminals\" do\n    model = MyModel.new\n    model.terminal_width = 120\n\n    output = model.view\n    expect(output).to include(\"detailed information\")\n  end\nend\n```\n\n### Empty State\n\n```ruby\nit \"handles empty list gracefully\" do\n  model = ListModel.new(items: [])\n  output = model.view\n\n  expect(output).to include(\"No items\")\n  expect(output).not_to include(\"> \")  # No selection indicator\nend\n```\n\n### Error States\n\n```ruby\nit \"recovers from error state\" do\n  model = MyModel.new\n  model.error = \"Previous error\"\n\n  # User action should clear error\n  model, _ = model.update(key_msg(\"enter\"))\n\n  expect(model.error).to be_nil\nend\n```\n\n---\n\n## Mocking External Dependencies\n\n### API Calls\n\n```ruby\nRSpec.describe \"Data loading\" do\n  before do\n    allow(API).to receive(:fetch_items).and_return([\n      { id: 1, name: \"Item 1\" },\n      { id: 2, name: \"Item 2\" }\n    ])\n  end\n\n  it \"loads and displays data\" do\n    model = MyModel.new\n    _, cmd = model.init\n\n    # Execute command\n    msg = cmd.call\n    model, _ = model.update(msg)\n\n    expect(model.items.length).to eq(2)\n    expect(model.view).to include(\"Item 1\")\n  end\nend\n```\n\n### File System\n\n```ruby\nRSpec.describe \"Config loading\" do\n  around do |example|\n    Dir.mktmpdir do |dir|\n      @config_dir = dir\n      example.run\n    end\n  end\n\n  it \"loads config from file\" do\n    config_path = File.join(@config_dir, \"config.yml\")\n    File.write(config_path, \"theme: dark\\n\")\n\n    model = MyModel.new(config_path: config_path)\n    expect(model.config[:theme]).to eq(\"dark\")\n  end\nend\n```\n\n---\n\n## Performance Testing\n\n### Render Performance\n\n```ruby\nRSpec.describe \"Performance\" do\n  it \"renders large lists efficiently\" do\n    model = ListModel.new(items: (1..10000).map { |i| \"Item #{i}\" })\n\n    start = Time.now\n    100.times { model.view }\n    elapsed = Time.now - start\n\n    expect(elapsed).to be < 1.0  # 100 renders under 1 second\n  end\n\n  it \"handles rapid key events\" do\n    model = MyModel.new(items: (1..100).to_a)\n\n    start = Time.now\n    1000.times { model, _ = model.update(key_msg(\"j\")) }\n    elapsed = Time.now - start\n\n    expect(elapsed).to be < 0.5  # 1000 updates under 500ms\n  end\nend\n```\n\n---\n\n## CI/CD Considerations\n\n### GitHub Actions Example\n\n```yaml\nname: Tests\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: ruby/setup-ruby@v1\n        with:\n          ruby-version: '3.2'\n          bundler-cache: true\n      - name: Run tests\n        run: bundle exec rspec\n        env:\n          TERM: xterm-256color  # Ensure color support\n          NO_COLOR: 1           # But disable for reproducible output\n```\n\n### Deterministic Tests\n\nEnsure tests produce consistent results:\n\n```ruby\n# Fix random seed for shuffle operations\nRSpec.configure do |c|\n  c.before(:each) { srand(12345) }\nend\n\n# Mock time-dependent operations\nbefore do\n  allow(Time).to receive(:now).and_return(Time.new(2024, 1, 1, 12, 0, 0))\nend\n```\n\n---\n\n## Resources\n\n- [RSpec Documentation](https://rspec.info/)\n- [Aruba Testing Framework](https://github.com/cucumber/aruba)\n- [Test-Driven Development](https://martinfowler.com/bliki/TestDrivenDevelopment.html)\n"
      },
      "plugins": [
        {
          "name": "charm-ruby",
          "source": "./",
          "description": "Build beautiful, interactive CLI tools in Ruby using the charm-ruby ecosystem (Bubble Tea, Lipgloss, Bubbles, Huh, and more)",
          "version": "1.0.0",
          "author": {
            "name": "Loris Mazloum"
          },
          "homepage": "https://charm-ruby.dev",
          "repository": "https://github.com/lorismaz/charm-ruby-claude-plugin",
          "license": "MIT",
          "keywords": [
            "ruby",
            "cli",
            "tui",
            "terminal",
            "charm",
            "bubbletea",
            "lipgloss"
          ],
          "category": "development",
          "categories": [
            "bubbletea",
            "charm",
            "cli",
            "development",
            "lipgloss",
            "ruby",
            "terminal",
            "tui"
          ],
          "install_commands": [
            "/plugin marketplace add lorismaz/charm-ruby-claude-plugin",
            "/plugin install charm-ruby@charm-ruby"
          ]
        }
      ]
    }
  ]
}