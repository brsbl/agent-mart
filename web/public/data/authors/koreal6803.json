{
  "author": {
    "id": "koreal6803",
    "display_name": "koreal6803",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/7858648?v=4",
    "url": "https://github.com/koreal6803",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 268,
      "total_forks": 44
    }
  },
  "marketplaces": [
    {
      "name": "finlab-plugins",
      "version": null,
      "description": "FinLab quantitative trading skills for Taiwan stock market (å°è‚¡) - includes strategy development, backtesting, data analysis, and factor research",
      "owner_info": {
        "name": "FinLab Community",
        "email": "support@finlab.tw"
      },
      "keywords": [],
      "repo_full_name": "koreal6803/finlab-ai",
      "repo_url": "https://github.com/koreal6803/finlab-ai",
      "repo_description": "Your AI's shortcut to mass-produce alpha-generating quant strategies.",
      "homepage": "",
      "signals": {
        "stars": 268,
        "forks": 44,
        "pushed_at": "2026-01-29T22:14:21Z",
        "created_at": "2026-01-06T07:59:04Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 472
        },
        {
          "path": "finlab-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "finlab-plugin/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "finlab-plugin/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 271
        },
        {
          "path": "finlab-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "finlab-plugin/skills/finlab",
          "type": "tree",
          "size": null
        },
        {
          "path": "finlab-plugin/skills/finlab/SKILL.md",
          "type": "blob",
          "size": 13548
        },
        {
          "path": "finlab-plugin/skills/finlab/backtesting-reference.md",
          "type": "blob",
          "size": 12937
        },
        {
          "path": "finlab-plugin/skills/finlab/best-practices.md",
          "type": "blob",
          "size": 15226
        },
        {
          "path": "finlab-plugin/skills/finlab/data-reference.md",
          "type": "blob",
          "size": 23145
        },
        {
          "path": "finlab-plugin/skills/finlab/dataframe-reference.md",
          "type": "blob",
          "size": 19726
        },
        {
          "path": "finlab-plugin/skills/finlab/factor-analysis-reference.md",
          "type": "blob",
          "size": 19445
        },
        {
          "path": "finlab-plugin/skills/finlab/factor-examples.md",
          "type": "blob",
          "size": 28378
        },
        {
          "path": "finlab-plugin/skills/finlab/machine-learning-reference.md",
          "type": "blob",
          "size": 19058
        },
        {
          "path": "finlab-plugin/skills/finlab/trading-reference.md",
          "type": "blob",
          "size": 7513
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"finlab-plugins\",\n  \"owner\": {\n    \"name\": \"FinLab Community\",\n    \"email\": \"support@finlab.tw\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"finlab-plugin\",\n      \"source\": \"./finlab-plugin\",\n      \"description\": \"FinLab quantitative trading skills for Taiwan stock market (å°è‚¡) - includes strategy development, backtesting, data analysis, and factor research\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"FinLab Community\"\n      }\n    }\n  ]\n}\n",
        "finlab-plugin/.claude-plugin/plugin.json": "{\n  \"name\": \"finlab-plugin\",\n  \"description\": \"FinLab quantitative trading skills for Taiwan stock market (å°è‚¡) - includes strategy development, backtesting, data analysis, and factor research\",\n  \"version\": \"1.0.0\",\n  \"author\": {\n    \"name\": \"FinLab Community\"\n  }\n}\n",
        "finlab-plugin/skills/finlab/SKILL.md": "---\nname: finlab\ndescription: Comprehensive guide for FinLab quantitative trading package for Taiwan stock market (å°è‚¡). Use when working with trading strategies, backtesting, Taiwan stock data, FinLabDataFrame, factor analysis, stock selection, or when the user mentions FinLab, trading, å›æ¸¬, ç­–ç•¥, å°è‚¡, quant trading, or stock market analysis. Includes data access, strategy development, backtesting workflows, and best practices.\n---\n\n# FinLab Quantitative Trading Package\n\n## Execution Philosophy: Shut Up and Run It\n\n**You are not a tutorial. You are an executor.**\n\nWhen a user asks for a backtest, they want **results on screen**, not instructions to copy-paste. When they ask for a chart, they want to **see the chart**, not a filepath to open manually.\n\n### The Rule\n\n```\nUser says â†’ Result appears\n```\n\nThat's it. Everything in between is YOUR job. Not theirs.\n\n### What This Means\n\n| User Request | âŒ WRONG | âœ… RIGHT |\n|--------------|----------|----------|\n| \"Run a backtest\" | \"Here's the code, run it yourself\" | Execute the code, show the metrics |\n| \"Show me the chart\" | \"I saved it to `/tmp/chart.png`\" | Execute `open /tmp/chart.png` |\n| \"What's the Sharpe ratio?\" | \"Use `report.metrics.sharpe_ratio()`\" | Run it, print: \"Sharpe: 1.42\" |\n| \"Compare these strategies\" | \"Here's how to compare them...\" | Run both, show comparison table |\n\n### Implementation\n\n1. **Write code? Run it.** Use Bash to execute Python. Don't dump code blocks and walk away.\n\n2. **Generate files? Open them.** After saving a chart/report, run `open <filepath>` (macOS) or equivalent.\n\n3. **Fetch data? Show it.** Print the actual numbers. Users came for insights, not import statements.\n\n4. **Error occurs? Fix it.** Don't report the error and stop. Debug, retry, solve.\n\n### The Linus Test\n\n> \"Talk is cheap. Show me the ~~code~~ results.\"\n\nIf your response requires the user to do ANYTHING other than read the answer, you failed. Go back and actually execute.\n\n---\n\n## Prerequisites\n\n**Before running any FinLab code, verify:**\n\n1. **FinLab is installed**:\n\n   ```bash\n   python3 -c \"import finlab\" || python3 -m pip install finlab\n   ```\n\n2. **API Token is set** (required - finlab will fail without it):\n\n   ```bash\n   echo $FINLAB_API_TOKEN\n   ```\n\n   **If empty, check for `.env` file first:**\n\n   ```bash\n   cat .env 2>/dev/null | grep FINLAB_API_TOKEN\n   ```\n\n   **If `.env` exists with token, load it in Python code:**\n\n   ```python\n   from dotenv import load_dotenv\n   load_dotenv()  # Loads FINLAB_API_TOKEN from .env\n\n   from finlab import data\n   # ... proceed normally\n   ```\n\n   **If no token anywhere, authenticate the user:**\n\n   ```bash\n   # 1. Initialize session (server generates secure credentials)\n   INIT_RESPONSE=$(curl -s -X POST \"https://www.finlab.finance/api/auth/cli/init\")\n   SESSION_ID=$(echo \"$INIT_RESPONSE\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['sessionId'])\")\n   POLL_SECRET=$(echo \"$INIT_RESPONSE\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['pollSecret'])\")\n   AUTH_URL=$(echo \"$INIT_RESPONSE\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['authUrl'])\")\n\n   # 2. Open browser for user login\n   open \"$AUTH_URL\"\n   ```\n\n   Tell user: **\"Please click 'Sign in with Google' in the browser.\"**\n\n   ```bash\n   # 3. Poll for token with secret and save to .env\n   for i in {1..150}; do\n     RESULT=$(curl -s \"https://www.finlab.finance/api/auth/poll?s=$SESSION_ID&secret=$POLL_SECRET\")\n     if echo \"$RESULT\" | grep -q '\"status\":\"success\"'; then\n       TOKEN=$(echo \"$RESULT\" | python3 -c \"import sys,json; print(json.load(sys.stdin)['token'])\")\n       export FINLAB_API_TOKEN=\"$TOKEN\"\n       echo \"FINLAB_API_TOKEN=$TOKEN\" >> .env\n       grep -q \"^\\.env$\" .gitignore 2>/dev/null || echo \".env\" >> .gitignore\n       echo \"Login successful! Token saved to .env\"\n       break\n     fi\n     sleep 2\n   done\n   ```\n\n### Why `.env`?\n\n| Method                              | Persists?       | Cross-platform?       | AI can read?         |\n| ----------------------------------- | --------------- | --------------------- | -------------------- |\n| Shell profile (`.zshrc`, `.bashrc`) | âœ…              | âŒ varies by OS/shell | âŒ often not sourced |\n| `finlab.login('XXX')`               | âŒ session only | âœ…                    | âœ…                   |\n| `.env` + `python-dotenv`            | âœ…              | âœ…                    | âœ…                   |\n\n**Recommendation:** Always use `.env` for persistent, cross-platform token storage.\n\n## Language\n\n**Respond in the user's language.** If user writes in Chinese, respond in Chinese. If in English, respond in English.\n\n## API Token Tiers & Usage\n\n### Token Tiers\n\n| Tier | Daily Limit | Token Pattern     |\n| ---- | ----------- | ----------------- |\n| Free | 500 MB      | ends with `#free` |\n| VIP  | 5000 MB     | no suffix         |\n\n**Detect tier:**\n\n```python\nis_free = token.endswith('#free')\n```\n\n### Usage Reset\n\n- Resets daily at **8:00 AM Taiwan time (UTC+8)**\n- When limit exceeded, user must wait for reset or upgrade to VIP\n\n### Quota Exceeded Handling\n\nWhen error contains `Usage exceed 500 MB/day` or similar quota error, **proactively** inform user:\n\n1. Daily quota reached (Free: 500 MB)\n2. Auto-resets at 8:00 AM Taiwan time\n3. VIP offers 5000 MB (10x increase)\n4. Upgrade link: https://www.finlab.finance/payment\n\n### Backtest Report Footer\n\nAppend different content based on user tier:\n\n**Free tier** - Add at end of backtest report (adapt to user's language):\n\n```\n---\nğŸ“Š Free Tier Report\n\nWant deeper analysis? Upgrade to VIP for:\nâ€¢ ğŸ“ˆ 10x daily quota (5000 MB)\nâ€¢ ğŸ”„ More backtests and larger datasets\nâ€¢ ğŸ“Š Seamless transition to live trading\n\nğŸ‘‰ Upgrade: https://www.finlab.finance/payment\n---\n```\n\n**VIP tier** - No upgrade prompt needed.\n\n## Quick Start Example\n\n```python\nfrom dotenv import load_dotenv\nload_dotenv()  # Load FINLAB_API_TOKEN from .env\n\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# 1. Fetch data\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\nvol = data.get(\"price:æˆäº¤è‚¡æ•¸\")\npb = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\n\n# 2. Create conditions\ncond1 = close.rise(10)  # Rising last 10 days\ncond2 = vol.average(20) > 1000*1000  # High liquidity\ncond3 = pb.rank(axis=1, pct=True) < 0.3  # Low P/B ratio\n\n# 3. Combine conditions and select stocks\nposition = cond1 & cond2 & cond3\nposition = pb[position].is_smallest(10)  # Top 10 lowest P/B\n\n# 4. Backtest\nreport = sim(position, resample=\"M\", upload=False)\n\n# 5. Print metrics - Two equivalent ways:\n\n# Option A: Using metrics object\nprint(report.metrics.annual_return())\nprint(report.metrics.sharpe_ratio())\nprint(report.metrics.max_drawdown())\n\n# Option B: Using get_stats() dictionary (different key names!)\nstats = report.get_stats()\nprint(f\"CAGR: {stats['cagr']:.2%}\")\nprint(f\"Sharpe: {stats['monthly_sharpe']:.2f}\")\nprint(f\"MDD: {stats['max_drawdown']:.2%}\")\n\nreport\n```\n\n## Core Workflow: 5-Step Strategy Development\n\n### Step 1: Fetch Data\n\nUse `data.get(\"<TABLE>:<COLUMN>\")` to retrieve data:\n\n```python\nfrom finlab import data\n\n# Price data\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\nvolume = data.get(\"price:æˆäº¤è‚¡æ•¸\")\n\n# Financial statements\nroe = data.get(\"fundamental_features:ROEç¨…å¾Œ\")\nrevenue = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\n\n# Valuation\npe = data.get(\"price_earning_ratio:æœ¬ç›Šæ¯”\")\npb = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\n\n# Institutional trading\nforeign_buy = data.get(\"institutional_investors_trading_summary:å¤–é™¸è³‡è²·è³£è¶…è‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†)\")\n\n# Technical indicators\nrsi = data.indicator(\"RSI\", timeperiod=14)\nmacd, macd_signal, macd_hist = data.indicator(\"MACD\", fastperiod=12, slowperiod=26, signalperiod=9)\n```\n\n**Filter by market/category using `data.universe()`:**\n\n```python\n# Limit to specific industry\nwith data.universe(market='TSE_OTC', category=['æ°´æ³¥å·¥æ¥­']):\n    price = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Set globally\ndata.set_universe(market='TSE_OTC', category='åŠå°é«”')\n```\n\nSee [data-reference.md](data-reference.md) for complete data catalog.\n\n### Step 2: Create Factors & Conditions\n\nUse FinLabDataFrame methods to create boolean conditions:\n\n```python\n# Trend\nrising = close.rise(10)  # Rising vs 10 days ago\nsustained_rise = rising.sustain(3)  # Rising for 3 consecutive days\n\n# Moving averages\nsma60 = close.average(60)\nabove_sma = close > sma60\n\n# Ranking\ntop_market_value = data.get('etl:market_value').is_largest(50)\nlow_pe = pe.rank(axis=1, pct=True) < 0.2  # Bottom 20% by P/E\n\n# Industry ranking\nindustry_top = roe.industry_rank() > 0.8  # Top 20% within industry\n```\n\nSee [dataframe-reference.md](dataframe-reference.md) for all FinLabDataFrame methods.\n\n### Step 3: Construct Position DataFrame\n\nCombine conditions with `&` (AND), `|` (OR), `~` (NOT):\n\n```python\n# Simple position: hold stocks meeting all conditions\nposition = cond1 & cond2 & cond3\n\n# Limit number of stocks\nposition = factor[condition].is_smallest(10)  # Hold top 10\n\n# Entry/exit signals with hold_until\nentries = close > close.average(20)\nexits = close < close.average(60)\nposition = entries.hold_until(exits, nstocks_limit=10, rank=-pb)\n```\n\n**Important:** Position DataFrame should have:\n\n- **Index**: DatetimeIndex (dates)\n- **Columns**: Stock IDs (e.g., '2330', '1101')\n- **Values**: Boolean (True = hold) or numeric (position size)\n\n### Step 4: Backtest\n\n```python\nfrom finlab.backtest import sim\n\n# Basic backtest\nreport = sim(position, resample=\"M\")\n\n# With risk management\nreport = sim(\n    position,\n    resample=\"M\",\n    stop_loss=0.08,\n    take_profit=0.15,\n    trail_stop=0.05,\n    position_limit=1/3,\n    fee_ratio=1.425/1000/3,\n    tax_ratio=3/1000,\n    trade_at_price='open',\n    upload=False\n)\n\n# Extract metrics - Two ways:\n# Option A: Using metrics object\nprint(f\"Annual Return: {report.metrics.annual_return():.2%}\")\nprint(f\"Sharpe Ratio: {report.metrics.sharpe_ratio():.2f}\")\nprint(f\"Max Drawdown: {report.metrics.max_drawdown():.2%}\")\n\n# Option B: Using get_stats() dictionary (note: different key names!)\nstats = report.get_stats()\nprint(f\"CAGR: {stats['cagr']:.2%}\")           # 'cagr' not 'annual_return'\nprint(f\"Sharpe: {stats['monthly_sharpe']:.2f}\") # 'monthly_sharpe' not 'sharpe_ratio'\nprint(f\"MDD: {stats['max_drawdown']:.2%}\")     # same name\n```\n\nSee [backtesting-reference.md](backtesting-reference.md) for complete `sim()` API.\n\n### Step 5: Execute Orders (Optional)\n\nConvert backtest results to live trading:\n\n```python\nfrom finlab.online.order_executor import Position, OrderExecutor\nfrom finlab.online.sinopac_account import SinopacAccount\n\n# 1. Convert report to position\nposition = Position.from_report(report, fund=1000000)\n\n# 2. Connect broker account\nacc = SinopacAccount()\n\n# 3. Create executor and preview orders\nexecutor = OrderExecutor(position, account=acc)\nexecutor.create_orders(view_only=True)  # Preview first\n\n# 4. Execute orders (when ready)\nexecutor.create_orders()\n```\n\nSee [trading-reference.md](trading-reference.md) for complete broker setup and OrderExecutor API.\n\n## Reference Files\n\n| File                                                           | Content                                    |\n| -------------------------------------------------------------- | ------------------------------------------ |\n| [data-reference.md](data-reference.md)                         | `data.get()`, `data.universe()`, 900+ æ¬„ä½ |\n| [backtesting-reference.md](backtesting-reference.md)           | `sim()` åƒæ•¸ã€stop-lossã€rebalancing       |\n| [trading-reference.md](trading-reference.md)                   | åˆ¸å•†è¨­å®šã€OrderExecutorã€Position          |\n| [factor-examples.md](factor-examples.md)                       | 60+ ç­–ç•¥ç¯„ä¾‹                               |\n| [dataframe-reference.md](dataframe-reference.md)               | FinLabDataFrame æ–¹æ³•                       |\n| [factor-analysis-reference.md](factor-analysis-reference.md)   | ICã€Shapleyã€å› å­åˆ†æ                      |\n| [best-practices.md](best-practices.md)                         | å¸¸è¦‹éŒ¯èª¤ã€lookahead bias                   |\n| [machine-learning-reference.md](machine-learning-reference.md) | ML ç‰¹å¾µå·¥ç¨‹                                |\n\n## Prevent Lookahead Bias\n\n**Critical:** Avoid using future data to make past decisions:\n\n```python\n# âœ… GOOD: Use shift(1) to get previous value\nprev_close = close.shift(1)\n\n# âŒ BAD: Don't use iloc[-2] (can cause lookahead)\n# prev_close = close.iloc[-2]  # WRONG\n\n# âœ… GOOD: Leave index as-is even with strings like \"2025Q1\"\n# FinLabDataFrame aligns by shape automatically\n\n# âŒ BAD: Don't manually assign to df.index\n# df.index = new_index  # FORBIDDEN\n```\n\nSee [best-practices.md](best-practices.md) for more anti-patterns.\n\n## Feedback\n\nSubmit feedback (with user consent):\n\n```python\nimport requests\nrequests.post(\"https://finlab-ai-plugin.koreal6803.workers.dev/feedback\", json={\n    \"type\": \"bug | feature | improvement | other\",\n    \"message\": \"GitHub issue style: concise title, problem, reproduction steps if applicable\",\n    \"context\": \"optional\"\n})\n```\n\nOne issue per submission. Always ask user permission first.\n\n## Notes\n\n- All strategy code examples use Traditional Chinese (ç¹é«”ä¸­æ–‡) variable names where appropriate\n- This package is specifically designed for Taiwan stock market (TSE/OTC)\n- Data frequency varies: daily (price), monthly (revenue), quarterly (financial statements)\n- Always use `sim(..., upload=False)` for experiments, `upload=True` only for final production strategies\n",
        "finlab-plugin/skills/finlab/backtesting-reference.md": "# Backtesting Reference\n\n## Overview\n\nThe FinLab backtesting framework allows you to simulate trading strategies using historical data. The `backtest.sim()` function is the core tool for evaluating strategy performance, supporting various parameters for rebalancing, transaction costs, stop-loss/take-profit, and more.\n\n---\n\n## backtest.sim\n\nSimulate the equity curve of a stock portfolio based on its position history and market data. This function supports various parameters for rebalancing frequency, transaction costs, stop loss/take profit, and notification via Line.\n\n**Import:**\n```python\nfrom finlab import backtest\n```\n\n**Signature:**\n```python\nsim(\n    position: Union[pd.DataFrame, pd.Series],\n    resample: Union[str, None] = None,\n    resample_offset: Union[str, None] = None,\n    trade_at_price: Union[str, pd.DataFrame] = 'close',\n    position_limit: float = 1,\n    fee_ratio: float = 1.425/1000,\n    tax_ratio: float = 3/1000,\n    name: str = 'æœªå‘½å',\n    stop_loss: Union[float, None] = None,\n    take_profit: Union[float, None] = None,\n    trail_stop: Union[float, None] = None,\n    touched_exit: bool = False,\n    retain_cost_when_rebalance: bool = False,\n    stop_trading_next_period: bool = True,\n    live_performance_start: Union[str, None] = None,\n    mae_mfe_window: int = 0,\n    mae_mfe_window_step: int = 1,\n    market: Union[None, Market] = None,\n    upload: bool = True,\n    fast_mode: bool = False,\n    notification_enable: bool = False,\n    line_access_token: str = ''\n) -> report.Report\n```\n\n### Parameters\n\n#### position\n- **Type:** `Union[pd.DataFrame, pd.Series]`\n- **Required:** Yes\n- **Description:** A pandas DataFrame or Series representing the buy/sell signals (True indicates holding, False indicates no position). For short positions, negative values can be used. The index should be a DatetimeIndex, and the columns should represent stock IDs.\n\n#### resample\n- **Type:** `Union[str, None]`\n- **Default:** `None`\n- **Description:** Trading frequency or rebalancing dates specification. It can be a string (e.g., 'D', 'W', 'M'), a DataFrame, Series, or None. When None, rebalancing only occurs on changes in the position.\n\n#### resample_offset\n- **Type:** `Union[str, None]`\n- **Default:** `None`\n- **Description:** An optional time offset (e.g., '1D', '1H') applied to rebalance dates.\n\n#### trade_at_price\n- **Type:** `Union[str, pd.DataFrame]`\n- **Default:** `'close'`\n- **Description:** Specifies which market price to use in the simulation. Options include 'close', 'open', 'open_close_avg', 'high_low_avg', or a custom DataFrame with price data.\n\n#### position_limit\n- **Type:** `float`\n- **Default:** `1`\n- **Description:** Limit for the maximum weight assigned to any single asset (e.g., 0.2 for 20%).\n\n#### fee_ratio\n- **Type:** `float`\n- **Default:** `1.425/1000`\n- **Description:** Commission fee ratio applied during trades.\n\n#### tax_ratio\n- **Type:** `float`\n- **Default:** `3/1000`\n- **Description:** Transaction tax ratio applied when selling stocks.\n\n#### name\n- **Type:** `str`\n- **Default:** `'æœªå‘½å'`\n- **Description:** Name for the strategy (for reporting purposes).\n\n#### stop_loss\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Stop loss percentage threshold. If set to None, stop loss is disabled.\n\n#### take_profit\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Take profit percentage threshold. If set to None, take profit is disabled.\n\n#### trail_stop\n- **Type:** `Union[float, None]`\n- **Default:** `None`\n- **Description:** Trailing stop threshold. If set to None, trailing stop is disabled.\n\n#### touched_exit\n- **Type:** `bool`\n- **Default:** `False`\n- **Description:** Flag to enable price touch exit logic. Use with caution as it may affect candle details.\n\n#### retain_cost_when_rebalance\n- **Type:** `bool`\n- **Default:** `False`\n- **Description:** Whether to carry forward the original cost basis when rebalancing positions.\n\n#### stop_trading_next_period\n- **Type:** `bool`\n- **Default:** `True`\n- **Description:** If a stop loss/take profit event occurs, trading is suspended for the next period.\n\n#### mae_mfe_window\n- **Type:** `int`\n- **Default:** `0`\n- **Description:** Window length for calculating maximum adverse excursion (MAE) and maximum favorable excursion (MFE).\n\n#### mae_mfe_window_step\n- **Type:** `int`\n- **Default:** `1`\n- **Description:** Step interval for the MAE/MFE analysis.\n\n#### upload\n- **Type:** `bool`\n- **Default:** `True`\n- **Description:** Determines whether to upload the strategy performance report after simulation.\n\n### Returns\n\nAn instance of `Report` containing performance metrics, trades, and additional analyses.\n\n---\n\n## Report Class Reference\n\nThe `sim()` function returns a `Report` object with multiple APIs for accessing performance metrics.\n\n### Method 1: `report.metrics` (Recommended for single metrics)\n\nAccess individual metrics via the `Metrics` instance:\n\n```python\nreport = sim(position, resample=\"M\", upload=False)\n\n# Individual metric methods\nprint(f\"Annual Return: {report.metrics.annual_return():.2%}\")\nprint(f\"Sharpe Ratio: {report.metrics.sharpe_ratio():.2f}\")\nprint(f\"Max Drawdown: {report.metrics.max_drawdown():.2%}\")\n```\n\n### Method 2: `report.get_stats()` (Returns dictionary)\n\nReturns a flat dictionary with all stats. Useful for batch access:\n\n```python\nstats = report.get_stats()\n\n# Dictionary keys (note: different names than metrics methods!)\nprint(f\"Annual Return: {stats['cagr']:.2%}\")\nprint(f\"Sharpe Ratio: {stats['monthly_sharpe']:.2f}\")\nprint(f\"Max Drawdown: {stats['max_drawdown']:.2%}\")\nprint(f\"Win Ratio: {stats['win_ratio']:.2%}\")\nprint(f\"Total Return: {stats['total_return']:.2%}\")\n```\n\n**Available keys in `get_stats()`:**\n- `cagr` - Compound Annual Growth Rate\n- `daily_sharpe` - Daily Sharpe ratio\n- `monthly_sharpe` - Monthly Sharpe ratio\n- `max_drawdown` - Maximum drawdown (negative value)\n- `win_ratio` - Win rate of trades\n- `total_return` - Total cumulative return\n- `start` - Backtest start date (string)\n- `end` - Backtest end date (string)\n- `return_table` - Dict of monthly returns by year\n\n### Method 3: `report.get_metrics()` (Structured nested dictionary)\n\nReturns a nested dictionary organized by category:\n\n```python\nmetrics = report.get_metrics()\n\n# Structured access\nprint(metrics['profitability']['annualReturn'])\nprint(metrics['ratio']['sharpeRatio'])\nprint(metrics['risk']['maxDrawdown'])\n```\n\n**Categories:**\n- `backtest` - startDate, endDate, feeRatio, taxRatio, market, freq\n- `profitability` - annualReturn, alpha, beta, avgNStock, maxNStock\n- `risk` - maxDrawdown, avgDrawdown, avgDrawdownDays, valueAtRisk\n- `ratio` - sharpeRatio, sortinoRatio, calmarRatio, volatility\n- `winrate` - winRate, m12WinRate, expectancy, mae, mfe\n- `liquidity` - capacity, disposalStockRatio, warningStockRatio\n\n### Other Useful Methods\n\n```python\n# Display interactive report\nreport.display()\n\n# Get trade details\ntrades_df = report.get_trades()\n\n# Save to file\nreport.to_html(\"report.html\")\nreport.to_pickle(\"report.pkl\")\n\n# Load from file\nloaded_report = Report.from_pickle(\"report.pkl\")\n\n# Run specific analysis\nreport.run_analysis(\"Drawdown\")\nreport.run_analysis(\"MaeMfe\")\n```\n\n### Key Attribute Mappings\n\n| Desired Metric | `report.metrics.X()` | `report.get_stats()['X']` |\n|----------------|----------------------|---------------------------|\n| Annual Return | `annual_return()` | `'cagr'` |\n| Sharpe Ratio | `sharpe_ratio()` | `'monthly_sharpe'` |\n| Max Drawdown | `max_drawdown()` | `'max_drawdown'` |\n| Win Rate | `win_rate()` | `'win_ratio'` |\n| Total Return | - | `'total_return'` |\n\n---\n\n## Example Usage\n\n### Basic Example\n\n```python\nimport pandas as pd\nfrom finlab import backtest\n\n# Example position DataFrame with dates as index\nposition = pd.DataFrame({\n    '2330': [0, 1, 1],\n    '1101': [0.2, 0, 0],\n    '2454': [0.4, 0, 0]\n}, index=pd.to_datetime(['2021-12-31', '2022-03-31', '2022-06-30']))\n\nreport = backtest.sim(position)\nprint(report)\n```\n\n### Advanced Example with Stop Loss and Take Profit\n\n```python\nfrom finlab import data, backtest\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\npb = data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”')\n\n# Define entry and exit conditions\nentries = close > close.average(20)\nexits = close < close.average(60)\n\n# Create position with ranking\nposition = entries.hold_until(exits, nstocks_limit=10, rank=-pb)\n\n# Backtest with stop loss and take profit\nreport = backtest.sim(\n    position,\n    resample='M',\n    stop_loss=0.1,      # 10% stop loss\n    take_profit=0.2,    # 20% take profit\n    name='MA Strategy with SL/TP'\n)\n\n# Display metrics\nprint(report.get_metrics())\n```\n\n---\n\n## Strategy Development Workflow\n\n### Step 1: Fetching Data\n\nGather the necessary data using `data.get()`, including historical prices, volume, and any relevant indicators.\n\n**Important Notes:**\n- Use `with data.universe(...)` ONLY to scope `data.get(...)` calls; do NOT wrap position DataFrame operations\n- When specifying category/exclude_category, use industry names only (no numeric codes like '28')\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\nvolume = data.get('price:æˆäº¤è‚¡æ•¸')\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\n```\n\n---\n\n### Step 2: Factor Creation\n\nCreate factors or indicators that will be used in your strategy.\n\n**Available Methods:**\n- `average`, `rolling(n).mean`, `rolling(n).std`, `rolling(n).max`, `rolling(n).min`\n- `is_largest`, `is_smallest`\n- `sustain`, `rise`, `fall`\n- `industry_rank`, `quantile_row`\n- Arithmetic operators: `+`, `-`, `*`, `/`\n- Comparison operators: `==`, `!=`, `<`, `<=`, `>`, `>=`\n- Logical operators: `&`, `|`, `~`\n\n**Important Notes:**\n- Do not use `==` for floating point comparisons. Use `np.isclose()` instead\n- Be cautious with `&` and `|` operators; ensure proper parentheses to avoid precedence issues\n- Prevent using reindex to align FinlabDataFrame as it already has aligned indices and columns\n- Do not use for loops to iterate over rows or columns. Use vectorized operations instead\n\n**Example:**\n```python\n# Calculate moving averages\nsma20 = close.average(20)\nsma60 = close.average(60)\n\n# Revenue growth\nrev_growth = revenue.pct_change(12)\n\n# Combine multiple conditions\nstrong_momentum = (close > sma20) & (close > sma60)\n```\n\n---\n\n### Step 3: Construct Position\n\nDefine the DataFrame structure for your trading positions. The index should be a DatetimeIndex, and the columns should represent stock IDs. Use boolean values to indicate whether to hold or not, or numeric values for position sizes.\n\n**Important Notes:**\n- If user does not mention the sell condition, you can just use `position = a & b & c`\n- Without sell condition, the position will be held until the end of the resample period, which is recommended, since we can set stop loss or take profit in the sim function\n- If user mentions the sell condition, it is recommended to use `position = buy.hold_until(sell)` where buy is `(a & b & c)` and sell is `(a | b | c)`\n- Use `&` and `|` to combine multiple conditions, and use parentheses to ensure correct precedence\n- DO NOT use for loop to iterate over rows or columns. FinlabDataFrame already has aligned indices and columns for you\n\n**Example:**\n```python\n# Simple position without explicit sell condition\nposition = (close > sma20) & (rev_growth > 0.1)\n\n# Position with entry and exit signals\nbuy = (close > sma20) & (volume > volume.average(20))\nsell = (close < sma60) | (rev_growth < 0)\nposition = buy.hold_until(sell, nstocks_limit=10)\n```\n\n---\n\n### Step 4: Backtest the Strategy\n\nTest your strategy's performance and make adjustments as needed.\n\n**Associated Methods:**\n- `backtest.sim`\n- `report.display`\n- `report.get_metrics`\n\n**Important Notes:**\n- Use the `sim` function to simulate performance based on your position DataFrame\n- If monthly revenue is used (as variable `rev`), please set `resample` to `rev.index`\n- If user not mention, please set `resample` to 'ME' or 'Q' to avoid overtrading\n- Use `print(report.get_metrics())` to extract performance metrics\n- If scoping tradable universe at simulation time, you may wrap the backtest call with `with data.universe(...)` â€” but NEVER wrap factor/position calculations inside that context\n\n**Example:**\n```python\nfrom finlab import backtest\n\n# Simple backtest\nreport = backtest.sim(position, resample='M')\n\n# Backtest with universe filtering\nwith data.universe(market='TSE_OTC', exclude_category='é‡‘è'):\n    report = backtest.sim(position, resample='Q')\n\n# Display metrics\nprint(report.get_metrics())\nreport.display()\n```\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Learn about enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Explore available data sources\n- [Factor Examples](factor-examples.md) - See complete strategy examples\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n",
        "finlab-plugin/skills/finlab/best-practices.md": "# FinLab Best Practices and Anti-Patterns\n\nThis document contains critical coding patterns, anti-patterns, and best practices for developing FinLab strategies. **Following these guidelines prevents common errors, lookahead bias, and data pollution.**\n\n## Table of Contents\n\n1. [Code Patterns (DO THIS)](#code-patterns-do-this)\n2. [Anti-Patterns (DON'T DO THIS)](#anti-patterns-dont-do-this)\n3. [Preventing Future Data Pollution](#preventing-future-data-pollution)\n4. [Stock Selection Patterns](#stock-selection-patterns)\n5. [Backtesting Patterns](#backtesting-patterns)\n6. [Error Handling](#error-handling)\n\n---\n\n## Code Patterns (DO THIS)\n\n### âœ… Combine Conditions with Logical Operators\n\n**DO:** Use `&`, `|`, `~` to combine conditions into a single position DataFrame.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nfactor1 = data.get(\"price:æ”¶ç›¤åƒ¹\")\nfactor2 = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\nfactor3 = data.get(\"price_earning_ratio:æœ¬ç›Šæ¯”\")\n\ncond1 = factor1.rank(axis=1, pct=True) > 0.5\ncond2 = factor2.rank(axis=1, pct=True) > 0.5\n\ncond_intersection = cond1 & cond2\nposition = factor3[cond_intersection].is_smallest(5)\n\nreport = sim(position, resample=\"M\")\n```\n\n**DON'T:** Create separate functions to generate positions (adds unnecessary complexity).\n\n### âœ… Use `is_smallest()` or `is_largest()` for Stock Selection\n\n**DO:** Limit to top N < 50 stocks using these methods.\n\n```python\n# Select top 10 stocks by lowest P/E\npe = data.get(\"price_earning_ratio:æœ¬ç›Šæ¯”\")\nposition = pe.is_smallest(10)\n\n# Select top 15 stocks by highest momentum, where condition is met\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\nmomentum = close / close.shift(20) - 1\ncondition = close > close.average(60)\nposition = momentum[condition].is_largest(15)\n```\n\n**Note:** The DataFrame used with `is_smallest()`/`is_largest()` must have **float dtype**, not bool. If you have a boolean condition, apply it as a filter first.\n\n### âœ… Use Correct Technical Indicator Syntax\n\n**DO:** Call `data.indicator()` without passing OHLCV data.\n\n```python\n# Correct - no OHLCV parameters\nrsi = data.indicator(\"RSI\", timeperiod=14)\n\n# Correct - multiple return values\nmacd, macd_signal, macd_hist = data.indicator(\n    \"MACD\",\n    fastperiod=12,\n    slowperiod=26,\n    signalperiod=9\n)\n\n# Correct - Bollinger Bands\nupperband, middleband, lowerband = data.indicator(\n    \"BBANDS\",\n    timeperiod=20,\n    nbdevup=2.0,\n    nbdevdn=2.0,\n    matype=0\n)\n```\n\n**DON'T:** Pass close price or OHLCV data to indicators.\n\n```python\n# âŒ WRONG - don't pass close\nrsi = data.indicator(\"RSI\", close, timeperiod=14)  # ERROR\n```\n\n### âœ… Use `df.shift(1)` for Previous Values\n\n**DO:** Use `.shift()` to access historical data.\n\n```python\n# Correct - get previous day's close\nprev_close = close.shift(1)\n\n# Correct - detect crossover\nsma20 = close.average(20)\nsma60 = close.average(60)\ngolden_cross = (sma20 > sma60) & (sma20.shift() < sma60.shift())\n```\n\n**DON'T:** Use `.iloc[-2]` or similar indexing (can cause lookahead bias).\n\n```python\n# âŒ WRONG\nprev_close = close.iloc[-2]  # DON'T USE THIS\n```\n\n### âœ… Use `data.universe()` for Filtering\n\n**DO:** Use context manager or `set_universe()` to filter stocks by market/category.\n\n```python\nfrom finlab import data\n\n# Method 1: Context manager (temporary scope)\nwith data.universe(market='TSE_OTC', category=['æ°´æ³¥å·¥æ¥­']):\n    price = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Method 2: Set globally\ndata.set_universe(market='TSE_OTC', category='åŠå°é«”', exclude_category='é‡‘è')\nprice = data.get('price:æ”¶ç›¤åƒ¹')\n```\n\nSee [data-reference.md](data-reference.md) for complete `data.universe()` usage.\n\n### âœ… Assign `resample` to Prevent Overtrading\n\n**DO:** Always specify `resample` parameter in `sim()`.\n\n```python\n# Monthly rebalancing\nsim(position, resample=\"M\")\n\n# Weekly rebalancing\nsim(position, resample=\"W\")\n\n# Use monthly revenue index\nrev = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\nsim(position, resample=rev.index)\n```\n\n**DON'T:** Omit `resample` (defaults to daily, causes excessive trading).\n\n---\n\n## Anti-Patterns (DON'T DO THIS)\n\n### âŒ Don't Use `==` for Float Comparisons\n\n**Reason:** Floating point precision issues.\n\n```python\n# âŒ BAD\ncondition = (close == 100.0)\n\n# âœ… GOOD - use inequalities or np.isclose()\nimport numpy as np\ncondition = np.isclose(close, 100.0)\n# Or better:\ncondition = (close > 99.9) & (close < 100.1)\n```\n\n### âŒ Don't Use `reindex()` on FinLabDataFrame\n\n**Reason:** FinLabDataFrame already automatically aligns indices/columns.\n\n```python\n# âŒ BAD - unnecessary reindexing\ndf1 = data.get(\"price:æ”¶ç›¤åƒ¹\")\ndf2 = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\ndf2_reindexed = df2.reindex(df1.index, method='ffill')  # DON'T DO THIS\n\n# âœ… GOOD - automatic alignment\nposition = df1 > df1.average(60) & (df2 > df2.shift(1))\n```\n\n**Exception:** Only use `reindex()` for position DataFrame when changing to a specific resampling schedule:\n\n```python\n# âœ… Allowed - reindex position to monthly revenue dates\nrev = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\nposition_resampled = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n```\n\n### âŒ Don't Use For Loops\n\n**Reason:** FinLabDataFrame methods are vectorized and much faster.\n\n```python\n# âŒ BAD - iterating over rows\nfor date in close.index:\n    for stock in close.columns:\n        if close.loc[date, stock] > sma60.loc[date, stock]:\n            position.loc[date, stock] = True\n\n# âœ… GOOD - vectorized operations\nposition = close > sma60\n```\n\n### âŒ Don't Filter æ³¨æ„è‚¡/è™•ç½®è‚¡/å…¨é¡äº¤å‰²è‚¡ Unless Asked\n\n**Reason:** These filters remove many stocks and should only be applied when explicitly requested.\n\n```python\n# âŒ DON'T do this by default\nis_regular = (\n    data.get(\"etl:noticed_stock_filter\") &\n    data.get(\"etl:disposal_stock_filter\") &\n    data.get(\"etl:full_cash_delivery_stock_filter\")\n)\nposition = position & is_regular\n\n# âœ… Only do this if user specifically asks to remove these stocks\n```\n\n### âŒ Don't Pass OHLCV to Technical Indicators\n\n**Reason:** `data.indicator()` automatically uses correct price data.\n\n```python\n# âŒ WRONG\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\nrsi = data.indicator(\"RSI\", close, timeperiod=14)  # ERROR\n\n# âœ… CORRECT\nrsi = data.indicator(\"RSI\", timeperiod=14)  # Automatically uses close\n```\n\n### âŒ Don't Use Boolean Indexing with Mismatched Indices\n\n**Reason:** When extracting `.iloc[-1]` from DataFrames with different columns, the resulting Series have different indices. Boolean indexing then fails with `IndexingError`.\n\n```python\n# âŒ BAD - indices may not match\nselected = latest_pe[latest_combined]  # IndexingError\n\n# âœ… GOOD - align indices first\ncommon = latest_combined.index.intersection(latest_pe.index)\nselected = latest_pe.loc[common][latest_combined.loc[common]]\n```\n\n---\n\n## Preventing Future Data Pollution\n\n**Critical:** Future data pollution (lookahead bias) occurs when you use information that wouldn't have been available at the time of decision-making. This silently corrupts backtests and makes them unrealistic.\n\n### âœ… Leave `df.index` As-Is\n\n**DO:** Keep index intact, even if it contains strings like \"2025Q1\".\n\n```python\n# âœ… GOOD - leave index as-is\nrevenue = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\n# Index may contain strings like \"2022-01\", \"2022-02\", etc.\n# FinLabDataFrame aligns by shape in binary operations\nposition = revenue > revenue.shift(1)\n```\n\n**DON'T:** Manually assign to `df.index`.\n\n```python\n# âŒ FORBIDDEN - can corrupt shared data\ndf.index = new_index  # NEVER DO THIS\n```\n\n### âœ… Use Only Approved Resampling Method\n\n**DO:** Use exactly this pattern for resampling (datetime index required, use `.last()` only).\n\n```python\n# âœ… CORRECT resampling pattern\ndf = df.index_str_to_date().resample('M').last()\n```\n\n**DON'T:** Use other aggregation methods like `.mean()`, `.first()`, `.ffill()`.\n\n```python\n# âŒ WRONG\ndf = df.resample('M').mean()  # Can cause lookahead\ndf = df.resample('M').ffill()  # Can cause lookahead\n```\n\n### âœ… Use Only Approved Reindexing Method\n\n**DO:** Use exactly `method='ffill'` for reindexing.\n\n```python\n# âœ… CORRECT\ndf = df.reindex(target_index, method='ffill')\n```\n\n**DON'T:** Use other methods like `'bfill'` or `None`.\n\n```python\n# âŒ WRONG\ndf = df.reindex(target_index, method='bfill')  # Lookahead bias\ndf = df.reindex(target_index)  # Missing data\n```\n\n---\n\n## Stock Selection Patterns\n\n### Pattern 1: Limit to Top X% of Indicator\n\n```python\n# Select stocks in top 30% by momentum\nmomentum = close / close.shift(60) - 1\ntop_momentum = momentum.rank(axis=1, pct=True) > 0.7\n```\n\n### Pattern 2: Limit to Top N Stocks\n\n```python\n# Select top 10 stocks with lowest P/B ratio\npb = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\nposition = pb.is_smallest(10)\n\n# Select top 15 stocks meeting a condition\nvolume = data.get(\"price:æˆäº¤è‚¡æ•¸\")\nliquid_stocks = volume.average(20) > 1000*1000\nposition = pb[liquid_stocks].is_smallest(15)\n```\n\n### Pattern 3: Entry/Exit with `hold_until()`\n\n```python\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\npb = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\n\n# Define entry and exit signals\nentries = close > close.average(20)\nexits = close < close.average(60)\n\n# Hold until exit, limit to 10 stocks, rank by negative P/B\nposition = entries.hold_until(\n    exits,\n    nstocks_limit=10,\n    rank=-pb  # Negative for ascending order (low P/B preferred)\n)\n```\n\n### Pattern 4: Industry Ranking\n\n```python\n# Select top 20% within each industry\nroe = data.get(\"fundamental_features:ROEç¨…å¾Œ\")\nindustry_top = roe.industry_rank() > 0.8\n```\n\n---\n\n## Backtesting Patterns\n\n### Pattern 1: Basic Backtest\n\n```python\nsim(position, resample=\"M\")\n```\n\n### Pattern 2: Backtest Within Date Range\n\n```python\nsim(position.loc['2020':'2023'], resample=\"M\")\n```\n\n### Pattern 3: Optuna Parameter Optimization\n\n```python\nimport optuna\nfrom finlab.backtest import sim\n\ndef run_strategy(params):\n    \"\"\"Strategy function that returns a report\"\"\"\n    sma_short = close.average(params['short'])\n    sma_long = close.average(params['long'])\n    position = (sma_short > sma_long)\n    report = sim(position, resample=\"M\", upload=False)\n    return report\n\ndef objective(trial):\n    params = {\n        'short': trial.suggest_int('short', 5, 30),\n        'long': trial.suggest_int('long', 40, 120)\n    }\n    report = run_strategy(params)\n    return report.metrics.sharpe_ratio()\n\n# Optimize with n_trials <= 10\nstudy = optuna.create_study(direction='maximize')\nstudy.optimize(objective, n_trials=10)\nprint(f\"Best params: {study.best_params}\")\n```\n\n### Pattern 4: Evaluate Strategy Condition Coverage\n\n```python\n# Check how often the condition is True (on average across stocks)\ncondition = close > close.average(60)\ncoverage = condition.sum(axis=1).loc['2020':].mean()\nprint(f\"Average stocks meeting condition: {coverage:.1f}\")\n```\n\n### Pattern 5: Adjust Rebalance Frequency\n\n```python\n# Weekly\nsim(position, resample=\"W\")\n\n# Monthly\nsim(position, resample=\"M\")\n\n# Quarterly\nsim(position, resample=\"Q\")\n\n# Custom: use monthly revenue index\nrev = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\nsim(position, resample=rev.index)\n```\n\n### Pattern 6: Adjust Rebalance Offset\n\n```python\n# Rebalance 1 week after period start\nsim(position, resample=\"M\", resample_offset=\"1W\")\n\n# Rebalance 1 month after quarter start\nsim(position, resample=\"Q\", resample_offset=\"1M\")\n```\n\n---\n\n## Error Handling\n\n### Error: `_ArrayMemoryError`\n\n**Solution:** Reset kernel and try again.\n\n```python\n# Call this if you encounter _ArrayMemoryError\nresetKernel()\n```\n\n### Error: `requests.exceptions.ConnectionError`\n\n**Solution:** Reset kernel and retry.\n\n```python\nresetKernel()\n```\n\n### Error: ç”¨é‡è¶…é™ (Quota Exceeded)\n\n**å¸¸è¦‹è¨Šæ¯:** `quota exceeded`, `daily limit reached`, `ç”¨é‡å·²é”ä¸Šé™`\n\n**è§£æ±ºæ–¹æ¡ˆ:**\n\n1. **ç­‰å¾…é‡ç½®** - å°ç£æ™‚é–“æ—©ä¸Š 8 é»æœƒè‡ªå‹•é‡ç½®ç”¨é‡\n2. **å‡ç´š VIP** - å…è²»ç‰ˆ 500 MBï¼ŒVIP ç‰ˆ 5000 MBï¼ˆ10 å€ï¼‰\n\n**å‘ŠçŸ¥ç”¨æˆ¶:**\n```\næ‚¨ä»Šæ—¥çš„è³‡æ–™ç”¨é‡å·²é”ä¸Šé™ï¼ˆå…è²»ç‰ˆ 500 MBï¼‰ã€‚\næ‚¨å¯ä»¥ï¼š\n1. ç­‰å¾…å°ç£æ™‚é–“æ—©ä¸Š 8 é»è‡ªå‹•é‡ç½®\n2. å‡ç´š VIP äº«æœ‰ 5000 MB é¡åº¦ï¼ˆ10 å€æå‡ï¼‰\n\nğŸ‘‰ å‡ç´š VIP: https://www.finlab.finance/payment\n```\n\n**æœ€ä½³åŒ–ç”¨é‡çš„å»ºè­°:**\n- é¿å…é‡è¤‡å–å¾—ç›¸åŒæ•¸æ“šï¼Œå°‡å¸¸ç”¨æ•¸æ“šå­˜å…¥è®Šæ•¸\n- ä½¿ç”¨ `data.universe()` é™åˆ¶å–å¾—çš„è‚¡ç¥¨ç¯„åœ\n- æ¸›å°‘ä¸å¿…è¦çš„æ­·å²æ•¸æ“šç¯„åœ\n\n### Debugging Tips\n\n1. **Break down experiments into small steps**\n\n   ```python\n   # Step 1: Fetch data\n   close = data.get(\"price:æ”¶ç›¤åƒ¹\")\n   print(close.head())\n\n   # Step 2: Create condition\n   condition = close > close.average(60)\n   print(condition.head())\n\n   # Step 3: Select stocks\n   position = condition.is_largest(10)\n   print(position.head())\n   ```\n\n2. **Inspect variable values** after each step to ensure correctness.\n\n3. **Use print statements** to display intermediate DataFrames.\n\n---\n\n## Strategy Design Principles\n\n### Principle 1: Be Systematic\n\n- **Good:** Clearly define hypothesis, experiment setup, and evaluation criteria\n- **Good:** Import optuna to systematically explore parameter space\n- **Bad:** Randomly changing parameters without a clear plan\n\n### Principle 2: Start Simple\n\n- Begin with a baseline strategy\n- Add complexity incrementally\n- Test each addition separately\n\n### Principle 3: Write Clear, Maintainable Code\n\n- Use descriptive variable names\n- Add comments where logic isn't self-evident\n- Don't over-comment obvious operations\n\n---\n\n## Complete Pattern Examples\n\n### Example 1: Value + Momentum + Liquidity\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Fetch data\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\npb = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\nvolume = data.get(\"price:æˆäº¤è‚¡æ•¸\")\n\n# Create factors\nvalue = pb.rank(axis=1, pct=True) < 0.3  # Low P/B\nmomentum = close.rise(20)  # Rising\nliquidity = volume.average(20) > 500*1000  # Liquid\n\n# Combine\nposition = value & momentum & liquidity\nposition = pb[position].is_smallest(10)\n\n# Backtest\nreport = sim(position, resample=\"M\", stop_loss=0.08, upload=False)\nprint(f\"Annual Return: {report.metrics.annual_return():.2%}\")\nprint(f\"Sharpe Ratio: {report.metrics.sharpe_ratio():.2f}\")\nprint(f\"Max Drawdown: {report.metrics.max_drawdown():.2%}\")\n```\n\n### Example 2: Monthly Revenue Growth\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Fetch revenue data\nrev = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\nrev_growth = data.get(\"monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)\")\n\n# Revenue momentum\nrev_ma3 = rev.average(3)\nrev_high = (rev_ma3 / rev_ma3.rolling(12).max()) == 1\n\n# Sustained growth\nstrong_growth = (rev_growth > 20).sustain(3)\n\n# Combine\nposition = rev_high & strong_growth\nposition = rev_growth[position].is_largest(10)\n\n# Reindex to monthly revenue dates\nposition_resampled = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n\n# Backtest\nreport = sim(position_resampled, upload=False)\n```\n\n---\n\n## See Also\n\n- [SKILL.md](SKILL.md) - Overview and quick start\n- [dataframe-reference.md](dataframe-reference.md) - FinLabDataFrame methods\n- [backtesting-reference.md](backtesting-reference.md) - Complete `sim()` API\n- [factor-examples.md](factor-examples.md) - 60+ complete examples\n",
        "finlab-plugin/skills/finlab/data-reference.md": "# Data Reference\n\n## Overview\n\nThe FinLab data module provides comprehensive access to Taiwan stock market data, including prices, financial statements, fundamental metrics, institutional trading, and economic indicators. Use `data.get()` to retrieve any dataset using a simple path-based syntax.\n\n---\n\n## Table of Contents\n\n- [Usage](#usage) - Basic data retrieval with `data.get()`\n- [Data Discovery](#data-discovery) - Find datasets with `data.search()`\n- [Technical Indicators](#technical-indicators) - Compute indicators with `data.indicator()`\n- [Universe Filtering](#universe-filtering) - Filter by market/category\n- [Data Catalog](#data-catalog) - Complete dataset reference\n- [Storage Configuration](#storage-configuration) - Cache and storage settings\n- [Plotting Data](#plotting-data) - Visualization examples\n\n---\n\n## Usage\n\n### Basic Syntax\n\n```python\nfrom finlab import data\n\n# Retrieve data using TABLE:COLUMN format\ndf = data.get('price:æ”¶ç›¤åƒ¹')\n\n# For tables without columns, use TABLE directly\ninventory = data.get('inventory')\n```\n\n### Data Path Construction\n\nThe path is constructed using colons (`:`) to navigate hierarchical data structures:\n\n**Format:**\n- `<TABLE>:<COLUMN>` - For tables with multiple columns\n- `<TABLE>` - For tables without column structure\n\n**Example:**\n```python\n# Get closing price\nclosing_price = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Get earnings per share\neps = data.get('financial_statement:æ¯è‚¡ç›ˆé¤˜')\n\n# Get foreign investor trading volume\nforeign_investment = data.get('institutional_investors_trading_summary:å¤–é™¸è³‡è²·è³£è¶…è‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†)')\n```\n\n### Common Field Names\n\n| Term | Field |\n|------|-------|\n| EPS | `financial_statement:æ¯è‚¡ç›ˆé¤˜` |\n| æœ¬ç›Šæ¯” | `price_earning_ratio:æœ¬ç›Šæ¯”` |\n| è‚¡åƒ¹æ·¨å€¼æ¯” | `price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”` |\n| æ®–åˆ©ç‡ | `price_earning_ratio:æ®–åˆ©ç‡(%)` |\n| ROE | `fundamental_features:ROEç¨…å¾Œ` |\n| æ¯›åˆ©ç‡ | `fundamental_features:ç‡Ÿæ¥­æ¯›åˆ©ç‡` |\n| æœˆç‡Ÿæ”¶ | `monthly_revenue:ç•¶æœˆç‡Ÿæ”¶` |\n| ç‡Ÿæ”¶å¹´å¢ç‡ | `monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)` |\n\n---\n\n## Data Discovery\n\nUse `data.search()` to programmatically find datasets from the Data Catalog.\n\n**Signature:**\n```python\ndata.search(keyword: str = None, market: str = 'tw') -> list\n```\n\n**Parameters:**\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `keyword` | str | None | Filter datasets by keyword (case-insensitive substring match). Returns all if omitted. |\n| `market` | str | 'tw' | Market to search: `'tw'` (Taiwan stocks), `'us'` (US stocks, testing), or `'all'` (both markets). |\n\n**Returns:** List of `\"table:column\"` strings, usable directly with `data.get()`.\n\n**Examples:**\n```python\nfrom finlab import data\n\n# List all available datasets (Taiwan market)\nall_data = data.search()\n\n# Search by keyword\ndata.search('æ”¶ç›¤')    # ['price:æ”¶ç›¤åƒ¹']\ndata.search('ç‡Ÿæ”¶')    # ['monthly_revenue:ç•¶æœˆç‡Ÿæ”¶', ...]\n\n# Search US market data (testing)\ndata.search('close', market='us')\n\n# Use result with data.get()\nresults = data.search('æ”¶ç›¤')\ndf = data.get(results[0])\n```\n\n---\n\n## Technical Indicators\n\nUse `data.indicator()` to compute technical indicators using TA-Lib. Returns a FinLabDataFrame with the same structure as price data (date index, stock columns).\n\n**Signature:**\n```python\ndata.indicator(\n    indname: str,\n    adjust_price: bool = False,\n    resample: str = 'D',\n    **kwargs\n) -> FinLabDataFrame | tuple\n```\n\n**Parameters:**\n\n| Parameter | Type | Default | Description |\n|-----------|------|---------|-------------|\n| `indname` | str | required | Indicator name: `SMA`, `EMA`, `RSI`, `MACD`, `STOCH`, `BBANDS`, `ATR`, `ADX`, etc. |\n| `adjust_price` | bool | False | Use adjusted prices for calculation. |\n| `resample` | str | 'D' | Data frequency: `'D'` (daily), `'W'` (weekly), `'M'` (monthly). |\n| `**kwargs` | - | - | Indicator-specific parameters (e.g., `timeperiod`, `fastperiod`, `slowperiod`). |\n\n**Returns:**\n- Single indicator (SMA, RSI, etc.): `FinLabDataFrame`\n- Multi-output indicator (STOCH, MACD, BBANDS): `tuple` of `FinLabDataFrame`\n\n**Common Indicators:**\n\n| Indicator | Parameters | Returns | Description |\n|-----------|------------|---------|-------------|\n| `SMA` | `timeperiod=30` | DataFrame | Simple Moving Average |\n| `EMA` | `timeperiod=30` | DataFrame | Exponential Moving Average |\n| `RSI` | `timeperiod=14` | DataFrame | Relative Strength Index (0-100) |\n| `STOCH` | `fastk_period=5, slowk_period=3, slowd_period=3` | (k, d) tuple | Stochastic Oscillator |\n| `MACD` | `fastperiod=12, slowperiod=26, signalperiod=9` | (macd, signal, hist) tuple | MACD |\n| `BBANDS` | `timeperiod=5, nbdevup=2, nbdevdn=2` | (upper, middle, lower) tuple | Bollinger Bands |\n| `ATR` | `timeperiod=14` | DataFrame | Average True Range |\n| `ADX` | `timeperiod=14` | DataFrame | Average Directional Index |\n\n**Examples:**\n```python\nfrom finlab import data\n\n# Simple moving average\nsma20 = data.indicator('SMA', timeperiod=20)\nsma60 = data.indicator('SMA', timeperiod=60)\n\n# RSI\nrsi = data.indicator('RSI', timeperiod=14)\noversold = rsi < 30\n\n# Stochastic oscillator (returns tuple)\nk, d = data.indicator('STOCH', adjust_price=True)\n\n# MACD (returns tuple)\nmacd, signal, hist = data.indicator('MACD')\n\n# Bollinger Bands (returns tuple)\nupper, middle, lower = data.indicator('BBANDS', timeperiod=20)\n\n# Weekly RSI\nrsi_weekly = data.indicator('RSI', timeperiod=14, resample='W')\n```\n\n---\n\n## Universe Filtering\n\nLimit the data fetch scope by market or industry category using a context manager or global settings.\n\n### Supported Markets\n- `ALL` - All markets\n- `TSE` - Taiwan Stock Exchange (ä¸Šå¸‚)\n- `OTC` - Over-The-Counter (ä¸Šæ«ƒ)\n- `TSE_OTC` - Both TSE and OTC\n- `ETF` - Exchange Traded Funds\n\n### Supported Categories\n\n**Industry Categories:**\nå…‰é›»æ¥­, å…¶ä»–, å…¶ä»–é›»å­æ¥­, åŒ–å­¸å·¥æ¥­, åŠå°é«”, å¡‘è† å·¥æ¥­, å­˜è¨—æ†‘è­‰, å»ºæç‡Ÿé€ , æ–‡åŒ–å‰µæ„æ¥­, æ©¡è† å·¥æ¥­, æ°´æ³¥å·¥æ¥­, æ±½è»Šå·¥æ¥­, æ²¹é›»ç‡ƒæ°£æ¥­, ç»ç’ƒé™¶ç“·, ç”ŸæŠ€é†«ç™‚, ç”ŸæŠ€é†«ç™‚æ¥­, ç´¡ç¹”çº–ç¶­, èˆªé‹æ¥­, è§€å…‰äº‹æ¥­, è²¿æ˜“ç™¾è²¨, è³‡è¨Šæœå‹™æ¥­, è¾²æ¥­ç§‘æŠ€, é€šä¿¡ç¶²è·¯æ¥­, é€ ç´™å·¥æ¥­, é‡‘è, é‹¼éµå·¥æ¥­, é›»å™¨é›»çºœ, é›»å­å•†å‹™, é›»å­é€šè·¯æ¥­, é›»å­é›¶çµ„ä»¶, é›»æ©Ÿæ©Ÿæ¢°, é›»è…¦åŠé€±é‚Š, é£Ÿå“å·¥æ¥­\n\n**ETF Categories:**\ndomestic_etf, foreign_etf, leveraged_etf, vanilla_futures_etf, leveraged_futures_etf\n\n### Parameters\n\n- `market` (str): One of 'ALL', 'TSE', 'OTC', 'TSE_OTC', 'ETF'\n- `category` (str or list): Industry NAMES only (no numeric codes); supports regex fuzzy match (e.g. 'é›»å­' matches multiple electronics categories)\n- `exclude_category` (str or list or None): Excluded industry NAMES only (no numeric codes); same regex rules as category\n\n### Important Notes\n\n- Regex matching is used for categories. To match exact 'å…¶ä»–', use '^å…¶ä»–$'\n- When both category and exclude_category are provided, select category first, then subtract exclude_category\n- Use data.universe ONLY to scope data.get() or backtest.sim() â€” do NOT wrap DataFrame/factor operations (e.g., position = ...)\n- Do NOT use category codes (ä»£è™Ÿ) like '28'; use industry names instead (e.g., exclude_category='é‡‘è')\n\n### Examples\n\n**Context Manager (Recommended):**\n```python\nfrom finlab import data\n\n# Filter by market and category\nwith data.universe(market='TSE_OTC', category=['æ°´æ³¥å·¥æ¥­']):\n    price = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Exact match using regex\nwith data.universe(market='TSE_OTC', category=['^å…¶ä»–$']):\n    close_subset = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Exclude specific categories\nwith data.universe(market='TSE_OTC', category=['æ°´æ³¥å·¥æ¥­'], exclude_category=['é‡‘è']):\n    price = data.get('price:æ”¶ç›¤åƒ¹')\n```\n\n**Global Setting:**\n```python\nfrom finlab import data\n\ndata.set_universe(market='TSE_OTC', category='æ°´æ³¥å·¥æ¥­', exclude_category='é‡‘è')\nprice = data.get('price:æ”¶ç›¤åƒ¹')\n```\n\n---\n\n## Data Catalog\n\n### Price & Trading Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `price` | ä¸Šå¸‚æ«ƒå¸‚å ´æˆäº¤è³‡è¨Š | æˆäº¤è‚¡æ•¸, æˆäº¤ç­†æ•¸, æˆäº¤é‡‘é¡, æ”¶ç›¤åƒ¹, é–‹ç›¤åƒ¹, æœ€ä½åƒ¹, æœ€é«˜åƒ¹, æœ€å¾Œæ­ç¤ºè²·åƒ¹, æœ€å¾Œæ­ç¤ºè³£åƒ¹, æœ€å¾Œæ­ç¤ºè²·é‡, æœ€å¾Œæ­ç¤ºè³£é‡ |\n| `etl` | é‚„åŸæ¬Šå€¼è‚¡åƒ¹ | adj_close, adj_open, adj_high, adj_low |\n| `intraday_odd_lot_trade` | ä¸Šå¸‚æ«ƒç›¤ä¸­é›¶è‚¡æˆäº¤è³‡è¨Š | æˆäº¤è‚¡æ•¸, æˆäº¤ç­†æ•¸, æˆäº¤é‡‘é¡, æ”¶ç›¤åƒ¹, é–‹ç›¤åƒ¹, æœ€ä½åƒ¹, æœ€é«˜åƒ¹, æœ€å¾Œæ­ç¤ºè²·åƒ¹, æœ€å¾Œæ­ç¤ºè³£åƒ¹, æœ€å¾Œæ­ç¤ºè²·é‡, æœ€å¾Œæ­ç¤ºè³£é‡ |\n| `after_market_odd_lot_trade` | ä¸Šå¸‚æ«ƒç›¤å¾Œé›¶è‚¡æˆäº¤è³‡è¨Š | æˆäº¤è‚¡æ•¸, æˆäº¤ç­†æ•¸, æˆäº¤é‡‘é¡, æˆäº¤åƒ¹, æœ€å¾Œæ­ç¤ºè²·åƒ¹, æœ€å¾Œæ­ç¤ºè³£åƒ¹, æœ€å¾Œæ­ç¤ºè²·é‡, æœ€å¾Œæ­ç¤ºè³£é‡ |\n| `intraday_trading` | ç¾è‚¡ç•¶æ²–æˆäº¤è³‡è¨Š | ç•¶æ—¥æ²–éŠ·äº¤æ˜“æˆäº¤è‚¡æ•¸, ç•¶æ—¥æ²–éŠ·äº¤æ˜“è²·é€²æˆäº¤é‡‘é¡, ç•¶æ—¥æ²–éŠ·äº¤æ˜“è³£å‡ºæˆäº¤é‡‘é¡, å¾—å…ˆè³£å¾Œè²·ç•¶æ²– |\n| `rotc_price` | èˆˆæ«ƒå¸‚å ´æˆäº¤è³‡è¨Š | æˆäº¤è‚¡æ•¸, æˆäº¤é‡‘é¡, é–‹ç›¤åƒ¹, æ”¶ç›¤åƒ¹, æœ€é«˜åƒ¹, æœ€ä½åƒ¹, æ—¥å‡åƒ¹, æˆäº¤ç­†æ•¸, æœ€å¾Œæ­ç¤ºè²·åƒ¹, æœ€å¾Œæ­ç¤ºè³£åƒ¹ |\n\n### Valuation Metrics\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `price_earning_ratio` | å€‹è‚¡æ—¥æœ¬ç›Šæ¯”ã€æ®–åˆ©ç‡åŠè‚¡åƒ¹æ·¨å€¼æ¯” | æ®–åˆ©ç‡(%), æœ¬ç›Šæ¯”, è‚¡åƒ¹æ·¨å€¼æ¯” |\n| `etl` | å€‹è‚¡å¸‚å€¼ | market_value |\n\n### Revenue Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `monthly_revenue` | ä¸Šå¸‚æ«ƒæœˆç‡Ÿæ”¶ | ç•¶æœˆç‡Ÿæ”¶, ä¸Šæœˆç‡Ÿæ”¶, å»å¹´ç•¶æœˆç‡Ÿæ”¶, ä¸Šæœˆæ¯”è¼ƒå¢æ¸›(%), å»å¹´åŒæœˆå¢æ¸›(%), ç•¶æœˆç´¯è¨ˆç‡Ÿæ”¶, å»å¹´ç´¯è¨ˆç‡Ÿæ”¶, å‰æœŸæ¯”è¼ƒå¢æ¸›(%) |\n| `rotc_monthly_revenue` | èˆˆæ«ƒæœˆç‡Ÿæ”¶ | ç•¶æœˆç‡Ÿæ”¶, ä¸Šæœˆç‡Ÿæ”¶, å»å¹´ç•¶æœˆç‡Ÿæ”¶, ä¸Šæœˆæ¯”è¼ƒå¢æ¸›(%), å»å¹´åŒæœˆå¢æ¸›(%), ç•¶æœˆç´¯è¨ˆç‡Ÿæ”¶, å»å¹´ç´¯è¨ˆç‡Ÿæ”¶, å‰æœŸæ¯”è¼ƒå¢æ¸›(%), å‚™è¨» |\n\n### Financial Statements\n\nThe `financial_statement` table contains comprehensive balance sheet, income statement, and cash flow data with 100+ columns including:\n\n**Balance Sheet Items:**\n- Assets: ç¾é‡‘åŠç´„ç•¶ç¾é‡‘, æµå‹•è³‡ç”¢, éæµå‹•è³‡ç”¢, è³‡ç”¢ç¸½é¡\n- Liabilities: æµå‹•è² å‚µ, éæµå‹•è² å‚µ, è² å‚µç¸½é¡\n- Equity: è‚¡æœ¬, è³‡æœ¬å…¬ç©åˆè¨ˆ, ä¿ç•™ç›ˆé¤˜, è‚¡æ±æ¬Šç›Šç¸½é¡\n\n**Income Statement Items:**\n- Revenue & Costs: ç‡Ÿæ¥­æ”¶å…¥æ·¨é¡, ç‡Ÿæ¥­æˆæœ¬, ç‡Ÿæ¥­æ¯›åˆ©\n- Expenses: ç ”ç©¶ç™¼å±•è²», æ¨éŠ·è²»ç”¨, ç®¡ç†è²»ç”¨\n- Profit: ç‡Ÿæ¥­åˆ©ç›Š, ç¨…å‰æ·¨åˆ©, æ­¸å±¬æ¯å…¬å¸æ·¨åˆ©(æ), æ¯è‚¡ç›ˆé¤˜\n\n**Cash Flow Items:**\n- Operating: ç‡Ÿæ¥­æ´»å‹•ä¹‹æ·¨ç¾é‡‘æµå…¥(æµå‡º)\n- Investing: æŠ•è³‡æ´»å‹•ä¹‹æ·¨ç¾é‡‘æµå…¥(æµå‡º), å–å¾—ä¸å‹•ç”¢_å» æˆ¿åŠè¨­å‚™\n- Financing: ç±Œè³‡æ´»å‹•ä¹‹æ·¨ç¾é‡‘æµå…¥(æµå‡º), ç™¼æ”¾ç¾é‡‘è‚¡åˆ©\n\n### Fundamental Features\n\nThe `fundamental_features` table contains 50+ calculated financial metrics:\n\n**Profitability Metrics:**\n- ROAç¨…å¾Œæ¯å‰, ROAç¶œåˆæç›Š, ROEç¨…å¾Œ, ROEç¶œåˆæç›Š\n- ç‡Ÿæ¥­æ¯›åˆ©ç‡, ç‡Ÿæ¥­åˆ©ç›Šç‡, ç¨…å‰æ·¨åˆ©ç‡, ç¨…å¾Œæ·¨åˆ©ç‡\n\n**Growth Metrics:**\n- ç‡Ÿæ”¶æˆé•·ç‡, ç‡Ÿæ¥­æ¯›åˆ©æˆé•·ç‡, ç‡Ÿæ¥­åˆ©ç›Šæˆé•·ç‡, ç¨…å‰æ·¨åˆ©æˆé•·ç‡, ç¨…å¾Œæ·¨åˆ©æˆé•·ç‡\n\n**Efficiency Metrics:**\n- ç¸½è³‡ç”¢é€±è½‰æ¬¡æ•¸, æ‡‰æ”¶å¸³æ¬¾é€±è½‰ç‡, å­˜è²¨é€±è½‰ç‡, å›ºå®šè³‡ç”¢é€±è½‰æ¬¡æ•¸\n\n**Liquidity Metrics:**\n- æµå‹•æ¯”ç‡, é€Ÿå‹•æ¯”ç‡, ç¾é‡‘æµé‡æ¯”ç‡\n\n**Leverage Metrics:**\n- è² å‚µæ¯”ç‡, ç¸½è² å‚µé™¤ç¸½æ·¨å€¼\n\n**Per Share Metrics:**\n- æ¯è‚¡ç‡Ÿæ¥­é¡, æ¯è‚¡ç‡Ÿæ¥­åˆ©ç›Š, æ¯è‚¡ç¾é‡‘æµé‡, æ¯è‚¡ç¨…å‰æ·¨åˆ©, æ¯è‚¡ç¶œåˆæç›Š, æ¯è‚¡ç¨…å¾Œæ·¨åˆ©\n\n### Institutional Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `institutional_investors_trading_summary` | ä¸‰å¤§æ³•äººè²·è³£è¶… | å¤–é™¸è³‡è²·é€²è‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†), å¤–é™¸è³‡è³£å‡ºè‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†), å¤–é™¸è³‡è²·è³£è¶…è‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†), å¤–è³‡è‡ªç‡Ÿå•†è²·é€²è‚¡æ•¸, å¤–è³‡è‡ªç‡Ÿå•†è³£å‡ºè‚¡æ•¸, å¤–è³‡è‡ªç‡Ÿå•†è²·è³£è¶…è‚¡æ•¸, æŠ•ä¿¡è²·é€²è‚¡æ•¸, æŠ•ä¿¡è³£å‡ºè‚¡æ•¸, æŠ•ä¿¡è²·è³£è¶…è‚¡æ•¸, è‡ªç‡Ÿå•†è²·é€²è‚¡æ•¸(è‡ªè¡Œè²·è³£), è‡ªç‡Ÿå•†è³£å‡ºè‚¡æ•¸(è‡ªè¡Œè²·è³£), è‡ªç‡Ÿå•†è²·è³£è¶…è‚¡æ•¸(è‡ªè¡Œè²·è³£), è‡ªç‡Ÿå•†è²·é€²è‚¡æ•¸(é¿éšª), è‡ªç‡Ÿå•†è³£å‡ºè‚¡æ•¸(é¿éšª), è‡ªç‡Ÿå•†è²·è³£è¶…è‚¡æ•¸(é¿éšª) |\n| `foreign_investors_shareholding` | å¤–è³‡æŒè‚¡æ¯”ç‡ | ç™¼è¡Œè‚¡æ•¸, å¤–è³‡åŠé™¸è³‡å°šå¯æŠ•è³‡è‚¡æ•¸, å…¨é«”å¤–è³‡åŠé™¸è³‡æŒæœ‰è‚¡æ•¸, å¤–è³‡åŠé™¸è³‡å°šå¯æŠ•è³‡æ¯”ç‡, å…¨é«”å¤–è³‡åŠé™¸è³‡æŒè‚¡æ¯”ç‡, å¤–è³‡åŠé™¸è³‡å…±ç”¨æ³•ä»¤æŠ•è³‡ä¸Šé™æ¯”ç‡, é™¸è³‡æ³•ä»¤æŠ•è³‡ä¸Šé™æ¯”ç‡ |\n\n### Margin Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `margin_transactions` | èè³‡åˆ¸ | èè³‡è²·é€², èè³‡è³£å‡º, èè³‡ç¾é‡‘å„Ÿé‚„, èè³‡å‰æ—¥é¤˜é¡, èè³‡ä»Šæ—¥é¤˜é¡, èè³‡é™é¡, èåˆ¸è²·é€², èåˆ¸è³£å‡º, èåˆ¸ç¾åˆ¸å„Ÿé‚„, èåˆ¸å‰æ—¥é¤˜é¡, èåˆ¸ä»Šæ—¥é¤˜é¡, èåˆ¸é™é¡, è³‡åˆ¸äº’æŠµ, è¨»è¨˜, èè³‡ä½¿ç”¨ç‡, èåˆ¸ä½¿ç”¨ç‡ |\n| `security_lending` | å€Ÿåˆ¸ | å‰æ—¥å€Ÿåˆ¸é¤˜é¡, å€Ÿåˆ¸, å€Ÿåˆ¸é‚„åˆ¸, å€Ÿåˆ¸å¢æ¸›, å€Ÿåˆ¸é¤˜é¡ |\n| `security_lending_sell` | å€Ÿåˆ¸è³£å‡º | å€Ÿåˆ¸è³£å‡º, å€Ÿåˆ¸è³£å‡ºé‚„åˆ¸, å€Ÿåˆ¸è³£å‡ºé¤˜é¡, å€Ÿåˆ¸è³£å‡ºé™é¡ |\n\n### Insider Trading\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `internal_equity_changes` | å…§éƒ¨äººæŒè‚¡è®ŠåŒ– | ç™¼è¡Œè‚¡æ•¸, è‘£ç›£å¢åŠ è‚¡æ•¸, è‘£ç›£æ¸›å°‘è‚¡æ•¸, è‘£ç›£æŒæœ‰è‚¡æ•¸, è‘£ç›£æŒæœ‰è‚¡æ•¸å æ¯”, ç¶“ç†äººæŒæœ‰è‚¡æ•¸, ç™¾åˆ†ä¹‹åä»¥ä¸Šå¤§è‚¡æ±æŒæœ‰è‚¡æ•¸, å¸‚å ´åˆ¥ |\n| `internal_equity_pledge` | å…§éƒ¨äººè³ªæŠ¼ | è‘£ç›£æŒè‚¡, è‘£ç›£è¨­è³ª, è‘£ç›£è§£è³ª, è‘£ç›£ç´¯è¨ˆè¨­è³ª, è‘£ç›£è¨­è³ªè‚¡æ•¸å æ¯”, ç¶“ç†äººæŒè‚¡, ç™¾åˆ†ä¹‹åä»¥ä¸Šå¤§è‚¡æ±æŒæœ‰è‚¡æ•¸, ç¶“ç†äººåŠç™¾åˆ†ä¹‹åä»¥ä¸Šå¤§è‚¡æ±è¨­è³ªè‚¡æ•¸, ç¶“ç†äººåŠç™¾åˆ†ä¹‹åä»¥ä¸Šå¤§è‚¡æ±è¨­è³ªè‚¡æ•¸å æ¯”, å¸‚å ´åˆ¥ |\n| `inventory` | é›†ä¿é¤˜é¡ | (Unstructured table - use directly) |\n\n### Corporate Actions\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `dividend_tse` | ä¸Šå¸‚é™¤æ¬Šæ¯ | é™¤æ¬Šæ¯å‰æ”¶ç›¤åƒ¹, é™¤æ¬Šæ¯åƒè€ƒåƒ¹, æ¬Šå€¼+æ¯å€¼, æ¬Šæ¯, æ¼²åœåƒ¹æ ¼, è·Œåœåƒ¹æ ¼, é–‹ç›¤ç«¶åƒ¹åŸºæº–, æ¸›é™¤è‚¡åˆ©åƒè€ƒåƒ¹, è©³ç´°è³‡æ–™, æœ€è¿‘ä¸€æ¬¡ç”³å ±è³‡æ–™ å­£åˆ¥æ—¥æœŸ, æœ€è¿‘ä¸€æ¬¡ç”³å ±æ¯è‚¡ (å–®ä½)æ·¨å€¼, æœ€è¿‘ä¸€æ¬¡ç”³å ±æ¯è‚¡ (å–®ä½)ç›ˆé¤˜, twse_divide_ratio |\n| `dividend_otc` | ä¸Šæ«ƒé™¤æ¬Šæ¯ | é™¤æ¬Šæ¯å‰æ”¶ç›¤åƒ¹, é™¤æ¬Šæ¯åƒè€ƒåƒ¹, æ¬Šå€¼, æ¯å€¼, æ¬Š+æ¯å€¼, æ¬Šæ¯, æ¼²åœåƒ¹æ ¼, è·Œåœåƒ¹æ ¼, é–‹ç›¤ç«¶åƒ¹åŸºæº–, æ¸›é™¤è‚¡åˆ©åƒè€ƒåƒ¹, ç¾é‡‘è‚¡åˆ©, æ¯åƒè‚¡ç„¡å„Ÿé…è‚¡, ç¾é‡‘å¢è³‡è‚¡æ•¸, ç¾é‡‘å¢è³‡èªè³¼åƒ¹, å…¬é–‹æ‰¿éŠ·è‚¡æ•¸, å“¡å·¥èªè³¼è‚¡æ•¸, åŸè‚¡æ±èªè³¼æ•¸, æŒ‰æŒè‚¡æ¯”ä¾‹åƒè‚¡èªè³¼, otc_divide_ratio |\n| `capital_reduction_tse` | ä¸Šå¸‚æ¸›è³‡ | æ¢å¾©è²·è³£æ—¥æœŸ, æ¸›è³‡åŸå› , æ¢å¾©è²·è³£åƒè€ƒåƒ¹, åœæ­¢è²·è³£å‰æ”¶ç›¤åƒ¹æ ¼, æ¼²åœåƒ¹æ ¼, è·Œåœåƒ¹æ ¼, é–‹ç›¤ç«¶åƒ¹åŸºæº–, é™¤æ¬Šåƒè€ƒåƒ¹, twse_cap_divide_ratio |\n| `capital_reduction_otc` | ä¸Šæ«ƒæ¸›è³‡ | æ¢å¾©è²·è³£æ—¥æœŸ, æ¸›è³‡åŸå› , é–‹å§‹äº¤æ˜“åŸºæº–åƒ¹, æœ€å¾Œäº¤æ˜“ä¹‹æ”¶ç›¤åƒ¹æ ¼, æ¸›è³‡æ¢å¾©è²·è³£é–‹å§‹æ—¥åƒè€ƒåƒ¹æ ¼, æ¼²åœåƒ¹æ ¼, è·Œåœåƒ¹æ ¼, é™¤æ¬Šåƒè€ƒåƒ¹, otc_cap_divide_ratio |\n| `treasury_stock` | åº«è—è‚¡ | è²·å›ç›®çš„, è²·å›è‚¡ä»½ç¸½é‡‘é¡ä¸Šé™, é å®šè²·å›è‚¡æ•¸, è²·å›åƒ¹æ ¼å€é–“-æœ€ä½, è²·å›åƒ¹æ ¼å€é–“-æœ€é«˜, é å®šè²·å›æœŸé–“-èµ·, é å®šè²·å›æœŸé–“-è¿„, æ˜¯å¦åŸ·è¡Œå®Œç•¢, æœ¬æ¬¡å·²è²·å›è‚¡æ•¸, æœ¬æ¬¡åŸ·è¡Œå®Œç•¢å·²è¨»éŠ·æˆ–è½‰è®“è‚¡æ•¸, æœ¬æ¬¡å·²è²·å›è‚¡æ•¸ä½”é å®šè²·å›è‚¡æ•¸æ¯”ä¾‹(%), æœ¬æ¬¡å·²è²·å›ç¸½é‡‘é¡, æœ¬æ¬¡å¹³å‡æ¯è‚¡è²·å›åƒ¹æ ¼, æœ¬æ¬¡è²·å›è‚¡æ•¸ä½”å…¬å¸å·²ç™¼è¡Œè‚¡ä»½ç¸½æ•¸æ¯”ä¾‹(%), æœ¬æ¬¡æœªåŸ·è¡Œå®Œç•¢ä¹‹åŸå›  |\n\n### Market Indices\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `benchmark_return` | å›æ¸¬åŸºæº– | ç™¼è¡Œé‡åŠ æ¬Šè‚¡åƒ¹å ±é…¬æŒ‡æ•¸ |\n| `taiex_total_index` | ç™¼è¡Œé‡åŠ æ¬Šè‚¡åƒ¹æŒ‡æ•¸æ­·å²è³‡æ–™ | é–‹ç›¤æŒ‡æ•¸, æœ€é«˜æŒ‡æ•¸, æœ€ä½æŒ‡æ•¸, æ”¶ç›¤æŒ‡æ•¸ |\n| `stock_index_price` | æŒ‡æ•¸è³‡è¨Š | æ”¶ç›¤æŒ‡æ•¸, æ¼²è·Œç™¾åˆ†æ¯”(%) |\n| `stock_index_vol` | æŒ‡æ•¸æˆäº¤é‡è³‡è¨Š | æˆäº¤è‚¡æ•¸, æˆäº¤é‡‘é¡, æˆäº¤ç­†æ•¸ |\n| `world_index` | ä¸–ç•ŒæŒ‡æ•¸ | open, high, low, close, adj_close, volume |\n\n### Economic Indicators\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `tw_business_indicators` | å°ç£æ™¯æ°£æŒ‡æ¨™ | æ™¯æ°£å°ç­–ä¿¡è™Ÿ(åˆ†), é ˜å…ˆæŒ‡æ¨™ç¶œåˆæŒ‡æ•¸(é»), é ˜å…ˆæŒ‡æ¨™ä¸å«è¶¨å‹¢æŒ‡æ•¸(é»), åŒæ™‚æŒ‡æ¨™ç¶œåˆæŒ‡æ•¸(é»), åŒæ™‚æŒ‡æ¨™ä¸å«è¶¨å‹¢æŒ‡æ•¸(é»), è½å¾ŒæŒ‡æ¨™ç¶œåˆæŒ‡æ•¸(é»), è½å¾ŒæŒ‡æ¨™ä¸å«è¶¨å‹¢æŒ‡æ•¸(é») |\n| `tw_total_pmi` | å°ç£è£½é€ æ¥­æ¡è³¼ç¶“ç†äººæŒ‡æ•¸ | è£½é€ æ¥­PMI, æ–°å¢è¨‚å–®æ•¸é‡, ç”Ÿç”¢æ•¸é‡, äººåŠ›åƒ±ç”¨æ•¸é‡, ä¾›æ‡‰å•†äº¤è²¨æ™‚é–“, å­˜è²¨, å®¢æˆ¶å­˜è²¨, åŸç‰©æ–™åƒ¹æ ¼, æœªå®Œæˆè¨‚å–®, æ–°å¢å‡ºå£è¨‚å–®, é€²å£åŸç‰©æ–™æ•¸é‡, æœªä¾†å…­å€‹æœˆå±•æœ› |\n| `tw_total_nmi` | å°ç£éè£½é€ æ¥­æ¡è³¼ç¶“ç†äººæŒ‡æ•¸ | è‡ºç£éè£½é€ æ¥­NMI, å•†æ¥­æ´»å‹•, æ–°å¢è¨‚å–®, äººåŠ›åƒ±ç”¨, ä¾›æ‡‰å•†äº¤è²¨æ™‚é–“, å­˜è²¨, æ¡è³¼åƒ¹æ ¼, æœªå®Œæˆè¨‚å–®, æœå‹™è¼¸å‡ºå‡ºå£, æœå‹™è¼¸å…¥é€²å£, æœå‹™æ”¶è²»åƒ¹æ ¼, å­˜è²¨è§€æ„Ÿ, æœªä¾†å…­å€‹æœˆå±•æœ› |\n| `tw_monetary_aggregates` | è²¨å¹£ç¸½è¨ˆæ•¸å¹´å¢ç‡ | å¹´å¢ç‡(%) |\n\n### Futures Data\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `futures_price` | æœŸè²¨æ—¥æˆäº¤è³‡è¨Š | åˆ°æœŸæœˆä»½(é€±åˆ¥), é–‹ç›¤åƒ¹, æœ€é«˜åƒ¹, æœ€ä½åƒ¹, æ”¶ç›¤åƒ¹, æ¼²è·Œåƒ¹, æ¼²è·Œå¹…, æˆäº¤é‡, æœªæ²–éŠ·å¥‘ç´„æ•¸ |\n| `futures_institutional_investors_trading_summary` | æœŸè²¨ä¸‰å¤§æ³•äººç›¤å¾Œè³‡è¨Š | å¤šæ–¹äº¤æ˜“å£æ•¸, ç©ºæ–¹äº¤æ˜“å£æ•¸, å¤šç©ºäº¤æ˜“å£æ•¸æ·¨é¡, å¤šæ–¹æœªå¹³å€‰å£æ•¸, ç©ºæ–¹æœªå¹³å€‰å£æ•¸, å¤šç©ºæœªå¹³å€‰å£æ•¸æ·¨é¡, å¤šæ–¹äº¤æ˜“å¥‘ç´„é‡‘é¡(åƒå…ƒ), ç©ºæ–¹äº¤æ˜“å¥‘ç´„é‡‘é¡(åƒå…ƒ), å¤šç©ºäº¤æ˜“å¥‘ç´„é‡‘é¡æ·¨é¡(åƒå…ƒ), å¤šæ–¹æœªå¹³å€‰å¥‘ç´„é‡‘é¡(åƒå…ƒ), ç©ºæ–¹æœªå¹³å€‰å¥‘ç´„é‡‘é¡(åƒå…ƒ), å¤šç©ºæœªå¹³å€‰å¥‘ç´„é‡‘é¡æ·¨é¡(åƒå…ƒ) |\n\n### Convertible Bonds\n\n| Table Name | Description | Available Columns |\n|-----------|-------------|-------------------|\n| `cb_price` | å¯è½‰æ›å…¬å¸å‚µæˆäº¤è³‡è¨Š | æˆäº¤å¼µæ•¸, æˆäº¤ç­†æ•¸, æˆäº¤é‡‘é¡, æ”¶ç›¤åƒ¹, é–‹ç›¤åƒ¹, æœ€ä½åƒ¹, æœ€é«˜åƒ¹ |\n| `cb_converted_status` | å¯è½‰æ›å…¬å¸å‚µæ¯æœˆè½‰æ›æ™®é€šè‚¡ | æœ¬æœˆè½‰æ›å¼µæ•¸, è½‰(äº¤)æ›æˆ–èªè‚¡åƒ¹æ ¼(å…ƒ), å‚µåˆ¸è½‰(äº¤)æ›æˆ–èªè³¼æ™®é€šè‚¡ |\n\n### Company Information\n\n| Table Name | Description |\n|-----------|-------------|\n| `company_basic_info` | ä¼æ¥­åŸºæœ¬è³‡è¨Š |\n| `company_main_business` | ä¼æ¥­ä¸»è¦ç¶“ç‡Ÿæ¥­å‹™ |\n| `important_subsidiary` | ä¼æ¥­é‡è¦å­å…¬å¸è³‡è¨Š |\n| `security_categories` | å°è‚¡è­‰åˆ¸åˆ†é¡ |\n| `security_industry_themes` | ç”¢æ¥­é¡Œæ |\n\n**Stock ID to Name Mapping:**\n```python\n# company_basic_info çš„ index æ˜¯æµæ°´è™Ÿï¼Œéœ€ç”¨ stock_id æ¬„ä½å°æ‡‰\ninfo = data.get(\"company_basic_info\")\nname_map = dict(zip(info[\"stock_id\"], info[\"å…¬å¸ç°¡ç¨±\"]))\n\n# ç”¨æ³•: name_map.get(\"2330\") -> \"å°ç©é›»\"\ndf[\"è‚¡ç¥¨åç¨±\"] = df.index.map(lambda x: name_map.get(x, x))\n```\n\n### Special Status\n\n| Table Name | Description | Usage |\n|-----------|-------------|-------|\n| `etl:disposal_stock_filter` | æ’é™¤è™•ç½®è‚¡ | Boolean filter |\n| `etl:noticed_stock_filter` | æ’é™¤æ³¨æ„è‚¡ | Boolean filter |\n| `etl:full_cash_delivery_stock_filter` | æ’é™¤å…¨é¡äº¤å‰²è‚¡ | Boolean filter |\n| `trading_attention` | æ³¨æ„è‚¡ | Status table |\n| `disposal_information` | è™•ç½®è‚¡ | Status table |\n| `change_transaction` | ä¸Šå¸‚æ«ƒè®Šæ›´äº¤æ˜“ | è®Šæ›´äº¤æ˜“, åˆ†ç›¤äº¤æ˜“ |\n\n### Special Dates\n\n| Table Name | Description |\n|-----------|-------------|\n| `etl:financial_statements_deadline` | è²¡å ±æˆªæ­¢æ—¥ |\n| `etl:financial_statements_disclosure_dates` | è²¡å ±é›»å­æª”ä¸Šå‚³æ—¥ |\n| `financial_statements_upload_detail` | è²¡å ±é›»å­æª”ä¸Šå‚³ç´€éŒ„ |\n\n---\n\n## Plotting Data\n\nUse `etl:adj_close` for historical comparison (backward adjusted, å‘å¾Œé‚„åŸ).\n\n```python\nimport matplotlib.pyplot as plt\nfrom finlab import data, ffn_core\n\nadj_close = data.get('etl:adj_close')\nadj_close[['2330', '2317', '2454']].loc['2020':].rebase().plot(figsize=(12, 6))\nplt.title('è‚¡åƒ¹èµ°å‹¢æ¯”è¼ƒ')\nplt.show()\n```\n\n---\n\n## Storage Configuration\n\nControl how data is cached locally. By default, FinLab caches data to disk to avoid repeated downloads.\n\n### data.set_storage()\n\nConfigure the storage backend for data caching.\n\n**Signature:**\n```python\ndata.set_storage(storage: Storage) -> None\n```\n\n**Parameters:**\n- `storage` (Storage, required): Storage backend instance. Options:\n  - `data.FileStorage()` - Disk-based storage (default)\n  - `data.CacheStorage()` - In-memory storage (faster, but lost on restart)\n\n**Example:**\n```python\nfrom finlab import data\n\n# Use in-memory storage (faster for repeated access in same session)\ndata.set_storage(data.CacheStorage())\n\n# Use disk storage (default, persists across sessions)\ndata.set_storage(data.FileStorage())\n```\n\n### data.clear()\n\nClear all cached data from the current storage backend.\n\n**Signature:**\n```python\ndata.clear() -> None\n```\n\n**Example:**\n```python\nfrom finlab import data\n\n# Clear all cached data\ndata.clear()\n\n# Next data.get() will re-download from cloud\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n```\n\n### Configuration Flags\n\nControl data fetching behavior using module-level flags.\n\n| Flag | Type | Default | Description |\n|------|------|---------|-------------|\n| `data.use_local_data_only` | bool | False | Prevent cloud downloads; use only local cache. Raises error if data not cached. |\n| `data.force_cloud_download` | bool | False | Always download fresh data from cloud, ignoring cache. |\n| `data.prefer_local_if_exists` | bool | False | Use local cache without checking expiry. Faster startup. |\n| `data.truncate_start` | str/None | None | Filter data to start from this date (format: `'YYYY-MM-DD'`). |\n| `data.truncate_end` | str/None | None | Filter data to end at this date (format: `'YYYY-MM-DD'`). |\n\n**Examples:**\n```python\nfrom finlab import data\n\n# Offline mode - use only local cache\ndata.use_local_data_only = True\nclose = data.get('price:æ”¶ç›¤åƒ¹')  # Fails if not cached\n\n# Force fresh download\ndata.force_cloud_download = True\nclose = data.get('price:æ”¶ç›¤åƒ¹')  # Always downloads\n\n# Use local cache without expiry check (faster)\ndata.prefer_local_if_exists = True\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Limit data range\ndata.truncate_start = '2020-01-01'\ndata.truncate_end = '2023-12-31'\nclose = data.get('price:æ”¶ç›¤åƒ¹')  # Only 2020-2023 data\n\n# Reset to defaults\ndata.use_local_data_only = False\ndata.force_cloud_download = False\ndata.prefer_local_if_exists = False\ndata.truncate_start = None\ndata.truncate_end = None\n```\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods for data manipulation\n- [Backtesting Reference](backtesting-reference.md) - How to use data in backtesting\n- [Factor Examples](factor-examples.md) - Practical examples using various datasets\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor effectiveness\n",
        "finlab-plugin/skills/finlab/dataframe-reference.md": "# FinlabDataFrame Reference\n\n## Overview\n\nFinlabDataFrame is a powerful extension of pandas DataFrame specifically designed for financial data analysis and backtesting. It provides enhanced functionality for trading strategy development, including automatic index/column alignment, moving averages, entry/exit signal detection, and industry-based ranking.\n\n## Key Features\n\n- Automatic re-alignment of indices and columns during arithmetic and logical operations\n- Built-in methods for moving averages and technical calculations\n- Entry/exit signal detection for trading strategies\n- Industry-based grouping and ranking\n- Multi-factor and industry neutralization\n- Integration with backtesting workflows\n\n**Contents:** [Constructor](#constructor) | [Index Conversion](#index-conversion-methods) | [Moving Average & Comparison](#moving-average--comparison-methods) | [Selection](#selection-methods) | [Signal Detection](#signal-detection-methods) | [Industry & Category](#industry--category-methods) | [Neutralization](#neutralization-methods) | [Quantile](#quantile-methods) | [Auto Alignment](#automatic-index-alignment) | [Method Chaining](#method-chaining-patterns)\n\n---\n\n## Constructor\n\n### FinlabDataFrame\n\nConverts a regular pandas DataFrame to a FinlabDataFrame with enhanced financial data processing capabilities.\n\n**Signature:**\n```python\nFinlabDataFrame(df: pd.DataFrame)\n```\n\n**Parameters:**\n- `df` (pd.DataFrame, required): A pandas DataFrame to be converted to FinlabDataFrame\n\n**Returns:**\n- An instance of FinlabDataFrame with enhanced financial data processing capabilities\n\n**Example:**\n```python\nfrom finlab.dataframe import FinlabDataFrame\nfrom finlab import data\nimport pandas as pd\n\n# Convert existing pandas DataFrame to FinlabDataFrame\nregular_df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})\ndf = FinlabDataFrame(regular_df)\n\n# FinlabDataFrame is also automatically returned by data.get()\nprice_df = data.get('price:æ”¶ç›¤åƒ¹')  # Returns a FinlabDataFrame\n```\n\n---\n\n## Index Conversion Methods\n\n### index_str_to_date\n\nConverts string-formatted financial report indices (e.g., \"2022-Q1\", \"2022-M01\") to datetime format based on actual disclosure dates. Essential for aligning financial data with daily price data.\n\n**Signature:**\n```python\nindex_str_to_date() -> FinlabDataFrame\n```\n\n**Returns:**\n- FinlabDataFrame with datetime index based on actual disclosure dates\n\n**Example:**\n```python\nfrom finlab import data\n\n# Financial statement data has string index like \"2022-Q1\"\ncash = data.get('financial_statement:ç¾é‡‘åŠç´„ç•¶ç¾é‡‘')\nprint(cash.index[:3])  # ['2013-Q1', '2013-Q2', '2013-Q3']\n\n# Convert to actual disclosure dates\ncash_dated = cash.index_str_to_date()\nprint(cash_dated.index[:3])  # DatetimeIndex(['2013-05-15', '2013-08-14', ...])\n```\n\n**Note:** This method uses actual financial statement disclosure dates from `etl:financial_statements_disclosure_dates`, not simple quarter-end dates.\n\n---\n\n### deadline\n\nConverts financial report indices to regulatory deadline dates (å…¬å‘Šæˆªæ­¢æ—¥). Unlike `index_str_to_date()` which uses actual disclosure dates, this uses the official filing deadlines.\n\n**Signature:**\n```python\ndeadline() -> FinlabDataFrame\n```\n\n**Returns:**\n- FinlabDataFrame with datetime index based on regulatory filing deadlines\n\n**Example:**\n```python\nfrom finlab import data\n\n# Convert quarterly data to deadline dates\ncash = data.get('financial_statement:ç¾é‡‘åŠç´„ç•¶ç¾é‡‘')\ncash_deadline = cash.deadline()\n\n# Convert monthly revenue to deadline dates\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\nrevenue_deadline = revenue.deadline()\n```\n\n**Use Case:** Use `deadline()` when you want conservative signal timing that assumes data arrives at the latest possible date. Use `index_str_to_date()` when you want signal timing based on actual historical disclosure.\n\n---\n\n## Moving Average & Comparison Methods\n\n### average\n\nCalculates a moving average over n periods. Returns NaN if more than half the values in the window are NaN.\n\n**Signature:**\n```python\naverage(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of periods for the moving average\n\n**Returns:**\n- FinlabDataFrame representing the moving average\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\nsma10 = close.average(10)\nsma60 = close.average(60)\n\n# Stock price above moving average\ncond = close > sma60\n```\n\n---\n\n### rise\n\nDetermines if values are rising compared to n periods before. Returns True if current value > value n periods ago.\n\n**Signature:**\n```python\nrise(n: int = 1) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, optional, default=1): Number of periods to compare\n\n**Returns:**\n- Boolean FinlabDataFrame indicating rising trends\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Price higher than 10 days ago\nrising = close.rise(10)\n\n# Consecutive rising days\nconsecutive_rise = close.rise().sustain(3)\n```\n\n---\n\n### fall\n\nDetermines if values are falling compared to n periods before. Returns True if current value < value n periods ago.\n\n**Signature:**\n```python\nfall(n: int = 1) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, optional, default=1): Number of periods to compare\n\n**Returns:**\n- Boolean FinlabDataFrame indicating falling trends\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Price lower than 10 days ago\nfalling = close.fall(10)\n\n# Avoid stocks in downtrend\navoid = close.fall(20)\n```\n\n---\n\n### sustain\n\nChecks whether a condition is sustained over a moving window of n days. Returns True if the sum of True values in the window meets or exceeds the threshold.\n\n**Signature:**\n```python\nsustain(nwindow: int, nsatisfy: int = None) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `nwindow` (int, required): Window length (in days)\n- `nsatisfy` (int, optional): Minimum number of True values required; defaults to `nwindow` if not provided\n\n**Returns:**\n- Boolean FinlabDataFrame\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Price rising for 3 consecutive days\nrising_3days = close.rise().sustain(3)\n\n# Price rising at least 4 out of 5 days\nrising_4of5 = close.rise().sustain(5, 4)\n```\n\n---\n\n## Selection Methods\n\n### is_largest\n\nReturns a boolean DataFrame where True values represent the top n largest values for each date. Eliminates the need for row-by-row iteration with nlargest.\n\n**Signature:**\n```python\nis_largest(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of top values to select on each date\n\n**Returns:**\n- Boolean FinlabDataFrame with True for top n stocks on each date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Select 10 stocks with highest ROA\nroa = data.get('fundamental_features:ROAç¨…å¾Œæ¯å‰')\ntop_roa = roa.is_largest(10)\n\n# Backtest holding top ROA stocks\nreport = sim(top_roa, resample='Q')\n```\n\n---\n\n### is_smallest\n\nReturns a boolean DataFrame where True values represent the n smallest values for each date.\n\n**Signature:**\n```python\nis_smallest(n: int) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `n` (int, required): Number of smallest values to select on each date\n\n**Returns:**\n- Boolean FinlabDataFrame with True for bottom n stocks on each date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Select 10 stocks with lowest P/B ratio\npb = data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”')\nlowest_pb = pb.is_smallest(10)\n\n# Backtest value strategy\nreport = sim(lowest_pb, resample='M')\n```\n\n---\n\n### rank\n\nComputes ranking across rows or columns. **Includes lookahead bias warning when ranking along the time axis.**\n\n**Signature:**\n```python\nrank(*args, **kwargs) -> FinlabDataFrame\n```\n\n**Parameters:**\n- Same parameters as `pandas.DataFrame.rank()`\n- `axis` (int or str, default=0): Axis to rank along. **Warning: axis=0 may cause lookahead bias**\n\n**Returns:**\n- FinlabDataFrame with rankings\n\n**Example:**\n```python\nfrom finlab import data\n\npb = data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”')\n\n# SAFE: Cross-sectional ranking (rank stocks against each other per day)\npb_rank = pb.rank(axis=1, pct=True)\n\n# Select stocks in bottom 30% of P/B each day\ncheap = pb_rank < 0.3\n\n# WARNING: Time-series ranking triggers LookaheadWarning\n# This ranks each stock's current value against its future values\n# pb.rank(axis=0)  # Will emit warning - use rolling().rank() instead\n```\n\n**Warning:** Ranking along `axis=0` (time axis) uses future data and will emit a `LookaheadWarning`. Use `rolling().rank()` or `expanding().rank()` for safe time-series ranking.\n\n---\n\n## Signal Detection Methods\n\n### is_entry\n\nIdentifies entry signal points where the condition switches from False to True.\n\n**Signature:**\n```python\nis_entry() -> FinlabDataFrame\n```\n\n**Returns:**\n- Boolean FinlabDataFrame indicating entry signals\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Condition: price in top 10\nposition = close.is_largest(10)\n\n# Find days when stock enters top 10\nentry_signals = position.is_entry()\n```\n\n---\n\n### is_exit\n\nIdentifies exit signal points where the condition switches from True to False.\n\n**Signature:**\n```python\nis_exit() -> FinlabDataFrame\n```\n\n**Returns:**\n- Boolean FinlabDataFrame indicating exit signals\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Condition: price in top 10\nposition = close.is_largest(10)\n\n# Find days when stock exits top 10\nexit_signals = position.is_exit()\n```\n\n---\n\n### exit_when\n\nCreates a position DataFrame that enters on entry signals and exits when either the original condition becomes False OR the specified exit condition becomes True.\n\n**Signature:**\n```python\nexit_when(exit: pd.DataFrame) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `exit` (pd.DataFrame, required): Additional exit condition DataFrame\n\n**Returns:**\n- Boolean FinlabDataFrame representing positions\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\nvolume = data.get('price:æˆäº¤è‚¡æ•¸')\n\n# Entry: price breaks above 20-day high\nentry_cond = close > close.rolling(20).max().shift()\n\n# Additional exit: volume spike (possible distribution)\nvolume_spike = volume > volume.average(20) * 3\n\n# Position with additional exit condition\nposition = entry_cond.exit_when(volume_spike)\n```\n\n---\n\n### hold_until\n\nGenerates trading positions based on entry signals until exit signals occur. Supports stock rotation limits, stop-loss/take-profit, and ranking-based selection.\n\n**Signature:**\n```python\nhold_until(\n    exit: pd.DataFrame,\n    nstocks_limit: int = None,\n    stop_loss: float = -np.inf,\n    take_profit: float = np.inf,\n    trade_at: str = 'close',\n    rank: pd.DataFrame = None\n) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `exit` (pd.DataFrame, required): Exit signal DataFrame\n- `nstocks_limit` (int, optional): Maximum number of stocks to hold simultaneously\n- `stop_loss` (float, optional, default=-np.inf): Stop loss threshold (e.g., 0.1 = exit if down 10%)\n- `take_profit` (float, optional, default=np.inf): Take profit threshold (e.g., 0.2 = exit if up 20%)\n- `trade_at` (str, optional, default='close'): Price reference for stop/take profit ('close' or 'open')\n- `rank` (pd.DataFrame, optional): Ranking DataFrame for prioritizing entries when limit is reached (higher = priority)\n\n**Returns:**\n- Boolean FinlabDataFrame with positions (True indicates holding)\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\npb = data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”')\n\n# Entry: price above 20-day MA\nentries = close > close.average(20)\n\n# Exit: price below 60-day MA\nexits = close < close.average(60)\n\n# Hold max 10 stocks, prefer lower P/B (use negative for ascending)\nposition = entries.hold_until(\n    exits,\n    nstocks_limit=10,\n    stop_loss=0.1,      # 10% stop loss\n    take_profit=0.3,    # 30% take profit\n    rank=-pb            # Lower P/B = higher priority\n)\n\nreport = sim(position)\n```\n\n---\n\n## Industry & Category Methods\n\n### groupby_category\n\nGroups DataFrame columns by their industry category. Similar to `pandas.DataFrame.groupby()` but groups stocks by industry.\n\n**Signature:**\n```python\ngroupby_category() -> pd.core.groupby.DataFrameGroupBy\n```\n\n**Returns:**\n- A GroupBy object with groups defined by industry categories\n\n**Example:**\n```python\nfrom finlab import data\n\npb = data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”')\n\n# Average P/B by industry\nindustry_pb = pb.groupby_category().mean()\n\n# Plot semiconductor industry P/B over time\nindustry_pb['åŠå°é«”'].plot(title='Semiconductor P/B Ratio')\n```\n\n---\n\n### industry_rank\n\nCalculates percentile ranking for stocks within their respective industries. Returns values from 0 (lowest in industry) to 1 (highest in industry).\n\n**Signature:**\n```python\nindustry_rank(categories: list = None) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `categories` (list, optional): List of industry categories to consider. If None, uses all industries from `data.get('security_industry_themes')`\n\n**Returns:**\n- FinlabDataFrame with industry-relative ranking scores (0 to 1)\n\n**Example:**\n```python\nfrom finlab import data\n\npe = data.get('price_earning_ratio:æœ¬ç›Šæ¯”')\n\n# Rank P/E within each industry\npe_industry_rank = pe.industry_rank()\n\n# Select stocks that are cheap relative to their industry\ncheap_in_industry = pe_industry_rank < 0.3\n```\n\n---\n\n### entry_price\n\nRetrieves the adjusted price at entry signal points.\n\n**Signature:**\n```python\nentry_price(trade_at: str = 'close') -> FinlabDataFrame\n```\n\n**Parameters:**\n- `trade_at` (str, optional, default='close'): Price type ('close' or 'open')\n\n**Returns:**\n- FinlabDataFrame with entry prices (forward-filled)\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n\n# Position signal\nposition = close.is_largest(10)\n\n# Get entry prices for calculating returns\nentry_prices = position.entry_price()\ncurrent_return = close / entry_prices - 1\n```\n\n---\n\n## Neutralization Methods\n\n### neutralize\n\nPerforms cross-sectional regression to neutralize factors from the data. Returns residuals after regressing on specified neutralizer factors.\n\n**Signature:**\n```python\nneutralize(\n    neutralizers: Union[pd.DataFrame, list[pd.DataFrame], dict[str, pd.DataFrame]],\n    add_const: bool = True\n) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `neutralizers` (DataFrame, list, or dict, required): Factor(s) to neutralize against\n  - Single DataFrame: neutralize against one factor\n  - List of DataFrames: neutralize against multiple factors\n  - Dict of DataFrames: neutralize with named factors\n- `add_const` (bool, optional, default=True): Whether to include intercept in regression\n\n**Returns:**\n- FinlabDataFrame containing regression residuals (neutralized values)\n\n**Example:**\n```python\nfrom finlab import data\n\n# Original factor\npe = data.get('price_earning_ratio:æœ¬ç›Šæ¯”')\n\n# Neutralize against size (market cap)\nsize = data.get('etl:market_value')\npe_size_neutral = pe.neutralize(size)\n\n# Neutralize against multiple factors\npb = data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”')\npe_multi_neutral = pe.neutralize([size, pb])\n\n# Neutralize with named factors (for clarity)\npe_named_neutral = pe.neutralize({\n    'size': size,\n    'size_squared': size ** 2,\n    'pb': pb\n})\n```\n\n**Use Case:** Factor neutralization removes unwanted exposures. For example, if you want a value factor that isn't just picking small-cap stocks, neutralize against market cap.\n\n---\n\n### neutralize_industry\n\nPerforms cross-sectional regression to neutralize industry effects. Each stock is regressed on industry dummy variables, returning industry-neutral residuals.\n\n**Signature:**\n```python\nneutralize_industry(\n    categories: pd.DataFrame = None,\n    add_const: bool = True\n) -> FinlabDataFrame\n```\n\n**Parameters:**\n- `categories` (pd.DataFrame, optional): DataFrame with 'stock_id' and 'category' columns. If None, uses `data.get('security_categories')`\n- `add_const` (bool, optional, default=True): Whether to include intercept (one dummy is dropped to avoid multicollinearity)\n\n**Returns:**\n- FinlabDataFrame containing industry-neutralized values\n\n**Example:**\n```python\nfrom finlab import data\n\n# P/E ratio varies significantly by industry\npe = data.get('price_earning_ratio:æœ¬ç›Šæ¯”')\n\n# Remove industry effects\npe_industry_neutral = pe.neutralize_industry()\n\n# Now pe_industry_neutral represents deviation from industry average\n# Positive = expensive relative to industry peers\n# Negative = cheap relative to industry peers\n\n# Custom industry categories\ncustom_cats = pd.DataFrame({\n    'stock_id': ['2330', '2317', '1101', '2412'],\n    'category': ['åŠå°é«”', 'é›»å­', 'æ°´æ³¥', 'é›»ä¿¡']\n})\npe_custom_neutral = pe.neutralize_industry(categories=custom_cats)\n```\n\n---\n\n## Quantile Methods\n\n### quantile_row\n\nComputes the specified quantile across all stocks for each date.\n\n**Signature:**\n```python\nquantile_row(c: float) -> pd.Series\n```\n\n**Parameters:**\n- `c` (float, required): Quantile value between 0 and 1 (e.g., 0.9 for 90th percentile)\n\n**Returns:**\n- pandas Series containing the quantile value per date\n\n**Example:**\n```python\nfrom finlab import data\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\n\n# 90th percentile price each day\nq90 = close.quantile_row(0.9)\n\n# Median price each day\nmedian = close.quantile_row(0.5)\n\n# Select stocks above 90th percentile\nexpensive = close > close.quantile_row(0.9)\n```\n\n---\n\n## Automatic Index Alignment\n\nFinlabDataFrame automatically aligns indices and columns when performing operations between DataFrames with different frequencies or shapes.\n\n**Supported Operations:**\n- Arithmetic: `+`, `-`, `*`, `/`, `//`, `%`, `**`\n- Comparison: `>`, `>=`, `==`, `!=`, `<`, `<=`\n- Logical: `&`, `|`, `^`\n\n**Example:**\n```python\nfrom finlab import data\n\n# Daily data\nclose = data.get('price:æ”¶ç›¤åƒ¹')  # Daily frequency\n\n# Quarterly data\nroa = data.get('fundamental_features:ROAç¨…å¾Œæ¯å‰')  # Quarterly frequency\n\n# Operations automatically align - no manual reindex needed\ncond1 = close > close.average(60)  # Daily condition\ncond2 = roa > 0                     # Quarterly condition\n\n# Intersection works across frequencies\n# Quarterly data is forward-filled to daily\nposition = cond1 & cond2\n```\n\n**Alignment Rules:**\n1. Index: Union of both indices, forward-filled\n2. Columns: Intersection of both column sets\n3. String indices (e.g., \"2022-Q1\") are converted to datetime using disclosure dates\n\n---\n\n## Method Chaining Patterns\n\nFinlabDataFrame methods can be chained for concise strategy expression.\n\n**Example: Complete Strategy**\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get('price:æ”¶ç›¤åƒ¹')\npb = data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”')\nroa = data.get('fundamental_features:ROAç¨…å¾Œæ¯å‰')\n\n# Chain conditions and selection\nposition = (\n    pb[\n        (close > close.average(60)) &     # Above 60-day MA\n        (roa > 0) &                        # Profitable\n        (close.rise(5))                    # Rising momentum\n    ]\n    .neutralize_industry()                 # Industry-neutral P/B\n    .is_smallest(10)                       # Cheapest 10 stocks\n)\n\nreport = sim(position, resample='M')\n```\n\n---\n\n## Related References\n\n- [Backtesting Reference](backtesting-reference.md) - Learn how to backtest strategies using FinlabDataFrame\n- [Data Reference](data-reference.md) - Explore available data sources\n- [Factor Examples](factor-examples.md) - See practical examples of using FinlabDataFrame in strategies\n- [Best Practices](best-practices.md) - Avoid common pitfalls including lookahead bias\n",
        "finlab-plugin/skills/finlab/factor-analysis-reference.md": "# Factor Analysis Reference\n\n## Overview\n\nThe FinLab factor analysis module provides comprehensive tools for evaluating factor effectiveness, calculating Information Coefficient (IC), analyzing factor trends, and computing factor contributions using Shapley values. These tools help you understand which factors drive returns and how to construct better trading strategies.\n\n**Import:**\n```python\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return,\n    calc_ic,\n    ic,\n    calc_metric,\n    calc_shapley_values,\n    calc_centrality,\n    calc_regression_stats\n)\n```\n\n**Contents:** [Quick Start](#quick-start) | [Functions](#functions) | [Advanced Examples](#advanced-analysis-examples) | [Best Practices](#best-practices)\n\n---\n\n## Quick Start\n\n### Basic Factor Analysis Workflow\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import generate_features_and_labels, calc_factor_return, calc_ic\n\n# Get data\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\nprint(factor_return.head())\n\n# Calculate IC (Information Coefficient)\nic_df = calc_ic(features, labels, rank=True)\nprint(ic_df.mean())\n```\n\n---\n\n## Functions\n\n### generate_features_and_labels\n\nGenerate factor features and labels: combines factors into a feature DataFrame and generates excess return labels.\n\n**Signature:**\n```python\ngenerate_features_and_labels(\n    dfs: Dict[str, Union[pd.DataFrame, Callable]],\n    resample: str\n) -> tuple[pd.DataFrame, pd.Series]\n```\n\n**Parameters:**\n- `dfs` (dict, required): Factor dictionary where keys are factor names and values are DataFrame or callable functions that return DataFrame (standard input for feature.combine)\n- `resample` (str, required): Resampling frequency string (e.g., 'M', 'Q', 'Y'), used for feature and label generation\n\n**Returns:**\n- `tuple[pd.DataFrame, pd.Series]`: (features, labels). features has date index with columns as factor names; labels are excess returns with the same index\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\n\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\nprint(f'Features shape: {features.shape}')\nprint(f'Labels shape: {labels.shape}')\n```\n\n---\n\n### calc_factor_return\n\nCalculate equal-weight portfolio returns based on features and labels. Automatically validates features as boolean values, calculates equal-weight portfolio returns per factor, and outputs starting from the first non-empty row.\n\n**Signature:**\n```python\ncalc_factor_return(\n    features: pd.DataFrame,\n    labels: pd.Series\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with date index, factor names as columns, and boolean values\n- `labels` (pd.Series, required): Label Series with date index and excess returns as values\n\n**Returns:**\n- `pd.DataFrame`: Equal-weight portfolio period returns indexed by date with factor names as columns, starting from the first non-empty row\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_factor_return, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\nprint(factor_return.head())\n\n# Analyze cumulative returns\ncumulative_return = (1 + factor_return).cumprod()\ncumulative_return.plot(figsize=(12, 6))\n```\n\n---\n\n### calc_ic\n\nCalculate the correlation coefficient (IC) between features and labels. Optionally rank features first for Rank IC. Outputs starting from the first non-empty row.\n\n**Signature:**\n```python\ncalc_ic(\n    features: pd.DataFrame,\n    labels: pd.Series,\n    rank: bool = False\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with MultiIndex (date, stock_id) and factor names as columns\n- `labels` (pd.Series, required): Label Series with MultiIndex (date, stock_id)\n- `rank` (bool, optional, default=False): Whether to rank features first for calculating Rank IC\n\n**Returns:**\n- `pd.DataFrame`: IC values for each date and factor, starting from the first non-empty row\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_ic, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\n\n# Generate features and labels (MultiIndex: date, stock_id)\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate Rank IC\nic_df = calc_ic(features, labels, rank=True)\nprint(ic_df.head())\n\n# Analyze IC statistics\nprint(ic_df.mean())  # Mean IC\nprint(ic_df.std())   # IC volatility\nprint(ic_df.mean() / ic_df.std())  # IC IR (Information Ratio)\n```\n\n---\n\n### ic\n\nCalculate Information Coefficient (IC) for factors. Internally calls calc_metric with cross-sectional correlation as the evaluation function.\n\n**Signature:**\n```python\nic(\n    factor: pd.DataFrame | Dict[str, pd.DataFrame],\n    adj_close: pd.DataFrame,\n    days: list[int] = [10, 20, 60, 120]\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `factor` (pd.DataFrame or dict, required): Factor data as DataFrame (columns are stock IDs) or dict[str, DataFrame] (keys are factor names)\n- `adj_close` (pd.DataFrame, required): Adjusted closing price DataFrame (columns are stock IDs) for calculating future returns\n- `days` (list[int], optional, default=[10, 20, 60, 120]): Prediction horizon list for calculating d-day future returns\n\n**Returns:**\n- `pd.DataFrame`: IC for each factor at different prediction horizons. Column names are <factor>_<days>, indexed by date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import ic\n\n# Build factor and price\nfactor = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate IC (correlation coefficient)\nic_df = ic(factor, adj_close)\nprint(ic_df.head())\n\n# Analyze IC at different horizons\nprint(ic_df.mean())\nic_df.plot(figsize=(12, 6))\n```\n\n---\n\n### calc_metric\n\nCalculate evaluation metrics for factors and future returns at multiple prediction horizons. Supports single DataFrame or mapping of factor names to DataFrames. Automatically aligns and trims time series.\n\n**Signature:**\n```python\ncalc_metric(\n    factor: pd.DataFrame | Dict[str, pd.DataFrame],\n    adj_close: pd.DataFrame,\n    days: list[int] = [10, 20, 60, 120],\n    func = corr\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `factor` (pd.DataFrame or dict, required): Factor data as DataFrame (columns are stock IDs) or dict[str, DataFrame] (keys are factor names)\n- `adj_close` (pd.DataFrame, required): Adjusted closing price DataFrame (columns are stock IDs) for calculating future returns\n- `days` (list[int], optional, default=[10, 20, 60, 120]): Prediction horizon list for calculating d-day future returns\n- `func` (callable, optional): Aggregation function for each date group. Takes DataFrame with 'ret' and 'f' columns and returns a single statistic. Default is corr (correlation coefficient)\n\n**Returns:**\n- `pd.DataFrame`: Evaluation results for each factor at different prediction horizons. Column names are <factor>_<days>, indexed by date\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_metric\n\n# Build factor and price\nfactor = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate evaluation metric (default: correlation coefficient)\nmetric_df = calc_metric(factor, adj_close)\nprint(metric_df.head())\n\n# Use custom metric function\ndef custom_metric(df):\n    # Calculate Spearman correlation\n    return df['f'].corr(df['ret'], method='spearman')\n\nmetric_df = calc_metric(factor, adj_close, func=custom_metric)\n```\n\n---\n\n### calc_shapley_values\n\nCalculate Shapley values for each factor to measure marginal contribution to portfolio performance using cooperative game theory. Enumerates all factor subsets and averages marginal contributions. Computational complexity is O(2^n) where n is the number of factors.\n\n**Signature:**\n```python\ncalc_shapley_values(\n    features: pd.DataFrame,\n    labels: pd.Series\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `features` (pd.DataFrame, required): Feature DataFrame with date index, factor names as columns, and boolean values (True indicates selected)\n- `labels` (pd.Series, required): Label Series with MultiIndex ('datetime', 'stock_id') and excess returns as values\n\n**Returns:**\n- `pd.DataFrame`: Daily Shapley values for each factor. Indexed by date with factor names as columns\n\n**Example:**\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import calc_shapley_values, generate_features_and_labels\n\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\n\n# Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'marketcap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample=revenue.index)\n\n# Calculate Shapley values\nshapley_df = calc_shapley_values(features, labels)\nprint(shapley_df.head())\n\n# Analyze average contribution\nprint(shapley_df.mean())\nshapley_df.plot(figsize=(12, 6))\n```\n\n**Note:** Due to computational complexity, this function is best used with a small number of factors (typically < 10).\n\n---\n\n### calc_centrality\n\nCalculate rolling asset centrality for time series data. This is a generic function applicable to any DataFrame with time index and asset columns (e.g., factor returns). It is frequency-agnostic with rolling window specified by integer window_periods.\n\n**Signature:**\n```python\ncalc_centrality(\n    return_df: pd.DataFrame,\n    window_periods: int,\n    n_components: int = 1\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `return_df` (pd.DataFrame, required): Time series DataFrame indexed by date with assets (e.g., factor names) as columns. Despite the name return_df, it can be any asset time series\n- `window_periods` (int, required): Rolling window length in number of data points. For monthly data, 3 means 3 months\n- `n_components` (int, optional, default=1): Number of principal components for PCA calculation\n\n**Returns:**\n- `pd.DataFrame`: DataFrame with rolling centrality scores. Indexed by date (window end date) with assets as columns\n\n**Example:**\n```python\nimport pandas as pd\nfrom finlab.tools.factor_analysis import calc_centrality\n\n# Assume we have factor return time series data\ndata = {\n    'FactorA': [0.1, 0.2, 0.15, 0.12, 0.11],\n    'FactorB': [0.05, 0.04, 0.06, 0.07, 0.08],\n}\nindex = pd.to_datetime(['2025-01-01','2025-01-02','2025-01-03','2025-01-04','2025-01-05'])\nreturn_df = pd.DataFrame(data, index=index)\n\ncentrality_df = calc_centrality(return_df, window_periods=3, n_components=1)\nprint(centrality_df.head())\n```\n\n---\n\n### calc_regression_stats\n\nPerform linear regression on each time series in a DataFrame and return statistics (slope, p-value, RÂ², tail estimate, and trend classification). Uses vectorized implementation without SciPy dependency.\n\n**Signature:**\n```python\ncalc_regression_stats(\n    df: pd.DataFrame,\n    p_value_threshold: float = 0.05,\n    r_squared_threshold: float = 0.1\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `df` (pd.DataFrame, required): Time series DataFrame indexed by DatetimeIndex with different metrics as columns\n- `p_value_threshold` (float, optional, default=0.05): P-value threshold for trend significance\n- `r_squared_threshold` (float, optional, default=0.1): RÂ² threshold for trend explanatory power\n\n**Returns:**\n- `pd.DataFrame`: Regression statistics for each column including slope, p_value, r_squared, tail_estimate, and trend\n\n**Example:**\n```python\n# Assume ic_df is a time series of factor IC\nfrom finlab.tools.factor_analysis import calc_regression_stats\n\ntrend_stats = calc_regression_stats(ic_df)\nprint(trend_stats.head())\n\n# Filter for statistically significant upward trends\nsignificant_up = trend_stats[(trend_stats['p_value'] < 0.05) & (trend_stats['slope'] > 0)]\nprint(significant_up)\n```\n\n---\n\n## Advanced Analysis Examples\n\n### Complete Factor Analysis Pipeline\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return,\n    calc_ic,\n    calc_regression_stats,\n    calc_shapley_values\n)\nimport matplotlib.pyplot as plt\n\n# 1. Define factors\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\npb = data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”')\n\n# 2. Generate features and labels\nfeatures, labels = generate_features_and_labels({\n    'small_cap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue_growth': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n    'low_pb': pb.rank(pct=True, axis=1) < 0.3,\n}, resample='M')\n\n# 3. Calculate factor returns\nfactor_return = calc_factor_return(features, labels)\ncumulative_return = (1 + factor_return).cumprod()\n\n# 4. Calculate IC\nic_df = calc_ic(features, labels, rank=True)\nprint(\"Average IC:\")\nprint(ic_df.mean())\n\n# 5. Analyze IC trends\nic_trends = calc_regression_stats(ic_df)\nprint(\"\\nIC Trend Statistics:\")\nprint(ic_trends)\n\n# 6. Calculate Shapley values (factor contributions)\nshapley_df = calc_shapley_values(features, labels)\nprint(\"\\nAverage Shapley Values:\")\nprint(shapley_df.mean())\n\n# 7. Visualization\nfig, axes = plt.subplots(3, 1, figsize=(14, 12))\n\n# Plot cumulative returns\ncumulative_return.plot(ax=axes[0])\naxes[0].set_title('Cumulative Factor Returns')\naxes[0].set_ylabel('Cumulative Return')\naxes[0].grid(True)\n\n# Plot IC over time\nic_df.plot(ax=axes[1])\naxes[1].set_title('Information Coefficient (IC) Over Time')\naxes[1].set_ylabel('IC')\naxes[1].axhline(y=0, color='r', linestyle='--', alpha=0.3)\naxes[1].grid(True)\n\n# Plot Shapley values\nshapley_df.plot(ax=axes[2])\naxes[2].set_title('Shapley Values (Factor Contributions)')\naxes[2].set_ylabel('Shapley Value')\naxes[2].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n---\n\n### Multi-Horizon IC Analysis\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import ic\nimport matplotlib.pyplot as plt\n\n# Calculate factor\nrsi = data.indicator('RSI')\nadj_close = data.get('etl:adj_close')\n\n# Calculate IC at multiple horizons\nic_df = ic(rsi, adj_close, days=[5, 10, 20, 40, 60, 120])\n\n# Analyze IC statistics\nprint(\"IC Mean:\")\nprint(ic_df.mean())\nprint(\"\\nIC Std:\")\nprint(ic_df.std())\nprint(\"\\nIC IR (Mean/Std):\")\nprint(ic_df.mean() / ic_df.std())\n\n# Visualization\nfig, axes = plt.subplots(2, 1, figsize=(14, 10))\n\n# IC time series\nic_df.plot(ax=axes[0])\naxes[0].set_title('IC Across Different Horizons')\naxes[0].set_ylabel('IC')\naxes[0].axhline(y=0, color='r', linestyle='--', alpha=0.3)\naxes[0].grid(True)\n\n# IC distribution\nic_df.plot(kind='box', ax=axes[1])\naxes[1].set_title('IC Distribution Across Horizons')\naxes[1].set_ylabel('IC')\naxes[1].grid(True)\n\nplt.tight_layout()\nplt.show()\n```\n\n---\n\n### Factor Combination Analysis\n\n```python\nfrom finlab import data\nfrom finlab.tools.factor_analysis import (\n    generate_features_and_labels,\n    calc_factor_return\n)\nimport pandas as pd\n\n# Define multiple factors\nprice = data.get('etl:adj_close')\nmarketcap = data.get('etl:market_value')\nrevenue = data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶')\n\n# Generate individual features\nindividual_features, labels = generate_features_and_labels({\n    'small_cap': marketcap.rank(pct=True, axis=1) < 0.3,\n    'revenue_growth': (revenue.average(3) / revenue.average(12)).rank(pct=True, axis=1) < 0.3,\n    'momentum': price / price.shift(20) - 1 > 0,\n}, resample='M')\n\n# Create combined features\ncombined_features = pd.DataFrame(index=individual_features.index)\ncombined_features['small_cap'] = individual_features['small_cap']\ncombined_features['revenue_growth'] = individual_features['revenue_growth']\ncombined_features['momentum'] = individual_features['momentum']\ncombined_features['small_cap+revenue'] = individual_features['small_cap'] & individual_features['revenue_growth']\ncombined_features['all_three'] = individual_features['small_cap'] & individual_features['revenue_growth'] & individual_features['momentum']\n\n# Calculate returns for all combinations\nfactor_return = calc_factor_return(combined_features, labels)\ncumulative_return = (1 + factor_return).cumprod()\n\n# Compare performance\nprint(\"Cumulative Return (Final):\")\nprint(cumulative_return.iloc[-1])\n\nprint(\"\\nAnnualized Return:\")\nprint(factor_return.mean() * 12)\n\nprint(\"\\nAnnualized Volatility:\")\nprint(factor_return.std() * (12 ** 0.5))\n\nprint(\"\\nSharpe Ratio:\")\nprint((factor_return.mean() / factor_return.std()) * (12 ** 0.5))\n\n# Visualization\ncumulative_return.plot(figsize=(14, 6))\nplt.title('Factor Combination Performance Comparison')\nplt.ylabel('Cumulative Return')\nplt.grid(True)\nplt.show()\n```\n\n---\n\n## Best Practices\n\n1. **Use Rank IC for robustness** - Rank IC is more stable than raw IC\n2. **Analyze IC over time** - Look for consistent positive IC, not just average IC\n3. **Check IC trend** - Use calc_regression_stats to identify deteriorating factors\n4. **Calculate Shapley values** - Understand true factor contributions in multi-factor strategies\n5. **Test multiple horizons** - Different factors may work at different time scales\n6. **Combine complementary factors** - Factors with low correlation often work better together\n7. **Monitor factor centrality** - High centrality may indicate overcrowding\n8. **Validate out-of-sample** - Always test on unseen data periods\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Available data sources\n- [Factor Examples](factor-examples.md) - Practical factor calculations\n- [Machine Learning Reference](machine-learning-reference.md) - ML-based factor analysis\n- [Backtesting Reference](backtesting-reference.md) - Test factor-based strategies\n",
        "finlab-plugin/skills/finlab/factor-examples.md": "# Factor Examples and Strategy Reference\n\n## Overview\n\nThis comprehensive guide provides practical examples of factor calculations, stock selection conditions, and complete trading strategies using the FinLab framework. All examples are organized by category for easy reference.\n\n---\n\n## Table of Contents\n\n1. [Common Data Paths](#common-data-paths)\n2. [Technical Indicators](#technical-indicators)\n3. [Calculation Examples](#calculation-examples)\n4. [Stock Selection Conditions](#stock-selection-conditions)\n   - [Technical Analysis](#technical-analysis)\n   - [Fundamental Analysis](#fundamental-analysis)\n   - [Chip Analysis](#chip-analysis)\n   - [Market Indicators](#market-indicators)\n   - [Filter Tools](#filter-tools)\n5. [Complete Strategy Examples](#complete-strategy-examples)\n\n---\n\n## Common Data Paths\n\n```python\nfrom finlab import data\n\n# Price data\næ”¶ç›¤åƒ¹ = data.get(\"price:æ”¶ç›¤åƒ¹\")\næˆäº¤è‚¡æ•¸ = data.get(\"price:æˆäº¤è‚¡æ•¸\")\n\n# Revenue data\nç•¶æœˆç‡Ÿæ”¶ = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\nå»å¹´åŒæœˆå¢æ¸› = data.get(\"monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)\")\n\n# Valuation metrics\næœ¬ç›Šæ¯” = data.get(\"price_earning_ratio:æœ¬ç›Šæ¯”\")\næ®–åˆ©ç‡ = data.get(\"price_earning_ratio:æ®–åˆ©ç‡(%)\")\nè‚¡åƒ¹æ·¨å€¼æ¯” = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\n\n# Fundamental features\nROEç¨…å¾Œ = data.get(\"fundamental_features:ROEç¨…å¾Œ\")\nç‡Ÿæ¥­æ¯›åˆ©ç‡ = data.get(\"fundamental_features:ç‡Ÿæ¥­æ¯›åˆ©ç‡\")\nè‡ªç”±ç¾é‡‘æµé‡ = data.get(\"fundamental_features:è‡ªç”±ç¾é‡‘æµé‡\")\n\n# Market value and institutional trading\nå¸‚å€¼ = data.get(\"etl:market_value\")\nå¤–é™¸è³‡è²·è³£è¶…è‚¡æ•¸ = data.get(\"institutional_investors_trading_summary:å¤–é™¸è³‡è²·è³£è¶…è‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†)\")\næŠ•ä¿¡è²·è³£è¶…è‚¡æ•¸ = data.get(\"institutional_investors_trading_summary:æŠ•ä¿¡è²·è³£è¶…è‚¡æ•¸\")\n```\n\n---\n\n## Technical Indicators\n\n### Momentum Indicators\n\n```python\nfrom finlab import data\n\n# ADX - Average Directional Index\nadx = data.indicator(\"ADX\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# RSI - Relative Strength Index\nrsi = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# MACD - Moving Average Convergence Divergence\nmacd, macdsignal, macdhist = data.indicator(\"MACD\", adjust_price=False, resample=\"D\",\n                                              fastperiod=12, slowperiod=26, signalperiod=9)\n\n# MOM - Momentum\nmom = data.indicator(\"MOM\", adjust_price=False, resample=\"D\", timeperiod=10)\n\n# ROC - Rate of Change\nroc = data.indicator(\"ROC\", adjust_price=False, resample=\"D\", timeperiod=10)\n\n# Stochastic Oscillator\nslowk, slowd = data.indicator(\"STOCH\", adjust_price=False, resample=\"D\",\n                               fastk_period=5, slowk_period=3, slowk_matype=0,\n                               slowd_period=3, slowd_matype=0)\n\n# Williams %R\nwillr = data.indicator(\"WILLR\", adjust_price=False, resample=\"D\", timeperiod=14)\n```\n\n### Moving Averages and Bands\n\n```python\n# Simple Moving Average\nsma = data.indicator(\"SMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# Exponential Moving Average\nema = data.indicator(\"EMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# Bollinger Bands\nupperband, middleband, lowerband = data.indicator(\"BBANDS\", timeperiod=20,\n                                                    nbdevup=2.0, nbdevdn=2.0, matype=0)\n\n# Weighted Moving Average\nwma = data.indicator(\"WMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n\n# TEMA - Triple Exponential Moving Average\ntema = data.indicator(\"TEMA\", adjust_price=False, resample=\"D\", timeperiod=30)\n```\n\n### Volatility Indicators\n\n```python\n# ATR - Average True Range\natr = data.indicator(\"ATR\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# NATR - Normalized ATR\nnatr = data.indicator(\"NATR\", adjust_price=False, resample=\"D\", timeperiod=14)\n\n# TRANGE - True Range\ntrange = data.indicator(\"TRANGE\", adjust_price=False, resample=\"D\")\n```\n\n### Volume Indicators\n\n```python\n# AD - Chaikin A/D Line\nad = data.indicator(\"AD\", adjust_price=False, resample=\"D\")\n\n# OBV - On Balance Volume\nobv = data.indicator(\"OBV\", adjust_price=False, resample=\"D\")\n\n# ADOSC - Chaikin A/D Oscillator\nadosc = data.indicator(\"ADOSC\", adjust_price=False, resample=\"D\",\n                        fastperiod=3, slowperiod=10)\n```\n\n---\n\n## Calculation Examples\n\n### Price-Based Calculations\n\n```python\nfrom finlab import data\n\næ”¶ç›¤åƒ¹ = data.get(\"price:æ”¶ç›¤åƒ¹\")\n\n# 60-day moving average\nsma = æ”¶ç›¤åƒ¹.average(60)\n\n# 60-day maximum price\nprice_max = æ”¶ç›¤åƒ¹.rolling(60).max()\n\n# 60-day minimum price\nprice_min = æ”¶ç›¤åƒ¹.rolling(60).min()\n\n# 20-day price change percentage\nprice_pct = æ”¶ç›¤åƒ¹.pct_change(periods=20)\n\n# Price rising compared to 60 days ago\nprice_rise = æ”¶ç›¤åƒ¹.rise(60)\n\n# Price falling compared to 60 days ago\nprice_fall = æ”¶ç›¤åƒ¹.fall(60)\n\n# Price rising for 3 consecutive days\nrise_sustain = æ”¶ç›¤åƒ¹.rise().sustain(3)\n\n# Price rising at least 2 out of last 3 days\nrise_nsatisfy = æ”¶ç›¤åƒ¹.rise().sustain(nwindow=3, nsatisfy=2)\n\n# Price falling for 3 consecutive days\nfall_sustain = æ”¶ç›¤åƒ¹.fall().sustain(3)\n\n# Top 10 highest prices in market\nprice_largest = æ”¶ç›¤åƒ¹.is_largest(10)\n\n# Top 10 lowest prices in market\nprice_smallest = æ”¶ç›¤åƒ¹.is_smallest(10)\n```\n\n### Volume-Based Calculations\n\n```python\næˆäº¤è‚¡æ•¸ = data.get(\"price:æˆäº¤è‚¡æ•¸\")\n\n# 20-day average volume\nvol_ma = æˆäº¤è‚¡æ•¸.average(20)\n\n# 20-day cumulative volume\nvol_cumsum = æˆäº¤è‚¡æ•¸.rolling(20).sum()\n```\n\n### Revenue-Based Calculations\n\n```python\nç•¶æœˆç‡Ÿæ”¶ = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\nå»å¹´åŒæœˆå¢æ¸› = data.get(\"monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)\")\n\n# 3-month average revenue\nrev_ma = ç•¶æœˆç‡Ÿæ”¶.average(3)\n\n# Revenue YoY growth > 20% for 3 consecutive months\nrev_rise_sustain = (å»å¹´åŒæœˆå¢æ¸› > 20).sustain(3)\n\n# Revenue YoY growth ranking (percentile)\nrev_rise_nsatisfy = å»å¹´åŒæœˆå¢æ¸›.rank(pct=True, axis=1)\n```\n\n### Special Calculations\n\n```python\n# Align position to monthly revenue dates\nrev = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\nposition = position.reindex(rev.index_str_to_date().index, method=\"ffill\")\n\n# Replace infinity with NaN\ninf_ratio = (data.get(\"financial_statement:ç ”ç©¶ç™¼å±•è²»\") /\n             data.get(\"financial_statement:ç‡Ÿæ¥­æ”¶å…¥æ·¨é¡\")).replace(np.inf, np.nan)\n\n# Inventory - large holders (>400 lots)\ninventory = data.get(\"inventory\")\nboss_inventory = inventory[\n    (inventory.æŒè‚¡åˆ†ç´š.astype(int) >= 12) &\n    (inventory.æŒè‚¡åˆ†ç´š.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\"]\n\n# Inventory - retail investors (<50 lots)\nsmall_inv = inventory[\n    (inventory.æŒè‚¡åˆ†ç´š.astype(int) <= 8)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\"]\n```\n\n---\n\n## Stock Selection Conditions\n\n### Technical Analysis\n\n#### Moving Average Strategies\n\n```python\næ”¶ç›¤åƒ¹ = data.get(\"price:æ”¶ç›¤åƒ¹\")\n\n# Price above 60-day MA\nsma60 = æ”¶ç›¤åƒ¹ > æ”¶ç›¤åƒ¹.average(60)\n\n# Price breaks above 60-day MA\nsma60_breakout = (æ”¶ç›¤åƒ¹ > æ”¶ç›¤åƒ¹.average(60)) & (æ”¶ç›¤åƒ¹.shift() < æ”¶ç›¤åƒ¹.average(60).shift())\n\n# Price breaks below 60-day MA\nsma60_breakdown = (æ”¶ç›¤åƒ¹ < æ”¶ç›¤åƒ¹.average(60)) & (æ”¶ç›¤åƒ¹.shift() > æ”¶ç›¤åƒ¹.average(60).shift())\n\n# Bullish alignment (5/10/20 MA)\nlong_ma_pattern = (æ”¶ç›¤åƒ¹ > æ”¶ç›¤åƒ¹.average(5)) & (æ”¶ç›¤åƒ¹ > æ”¶ç›¤åƒ¹.average(10)) & (æ”¶ç›¤åƒ¹ > æ”¶ç›¤åƒ¹.average(20))\n\n# Bearish alignment (5/10/20 MA)\nshort_ma_pattern = (æ”¶ç›¤åƒ¹ < æ”¶ç›¤åƒ¹.average(5)) & (æ”¶ç›¤åƒ¹ < æ”¶ç›¤åƒ¹.average(10)) & (æ”¶ç›¤åƒ¹ < æ”¶ç›¤åƒ¹.average(20))\n```\n\n#### Price Extreme Conditions\n\n```python\n# New 5-day high\nnew_high = (æ”¶ç›¤åƒ¹ / æ”¶ç›¤åƒ¹.rolling(5).max()) == 1\n\n# New 5-day low\nnew_low = (æ”¶ç›¤åƒ¹ / æ”¶ç›¤åƒ¹.rolling(5).min()) == 1\n\n# Making new 3-day highs for 5 consecutive days\nprice_boost = ((æ”¶ç›¤åƒ¹ / æ”¶ç›¤åƒ¹.rolling(3).max()) == 1).sustain(5)\n\n# Making new 3-day lows for 5 consecutive days\nprice_crash = ((æ”¶ç›¤åƒ¹ / æ”¶ç›¤åƒ¹.rolling(3).min()) == 1).sustain(5)\n\n# Not making new 3-day highs for 5 consecutive days\nprice_pressure = ((æ”¶ç›¤åƒ¹ / æ”¶ç›¤åƒ¹.rolling(3).max()) < 1).sustain(5)\n\n# Not making new 3-day lows for 5 consecutive days\nprice_support = ((æ”¶ç›¤åƒ¹ / æ”¶ç›¤åƒ¹.rolling(3).min()) > 1).sustain(5)\n\n# 20-day price change less than 20%\nprice_pct_cond = æ”¶ç›¤åƒ¹.pct_change(periods=20) < 0.20\n```\n\n#### Volume Conditions\n\n```python\næˆäº¤è‚¡æ•¸ = data.get(\"price:æˆäº¤è‚¡æ•¸\")\n\n# 20-day average volume > 1,000,000\nvol_ma = æˆäº¤è‚¡æ•¸.average(20) > 1000000\n\n# Volume above 60-day MA\nvol_ma = æˆäº¤è‚¡æ•¸ > æˆäº¤è‚¡æ•¸.average(60)\n\n# Volume making new 3-day highs for 5 consecutive days\nvol_boost = ((æˆäº¤è‚¡æ•¸ / æˆäº¤è‚¡æ•¸.rolling(3).max()) == 1).sustain(5)\n\n# Volume making new 3-day lows for 5 consecutive days\nvol_crash = ((æˆäº¤è‚¡æ•¸ / æˆäº¤è‚¡æ•¸.rolling(3).min()) == 1).sustain(5)\n```\n\n#### Technical Indicator Conditions\n\n```python\n# RSI golden cross\nrsi1 = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=14)\nrsi2 = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=28)\nrsi_gold_cross = (rsi1 > rsi2) & (rsi1.shift() < rsi2.shift())\n\n# RSI overbought for 5 consecutive days\nrsi = data.indicator(\"RSI\", adjust_price=False, resample=\"D\", timeperiod=5)\nrsi_high_trend = (rsi > 80).sustain(5)\n\n# KD golden cross\nslowk, slowd = data.indicator(\"STOCH\", adjust_price=False, resample=\"D\",\n                               fastk_period=5, slowk_period=3, slowk_matype=0,\n                               slowd_period=3, slowd_matype=0)\nkd_gold_cross = (slowk > slowd) & (slowk.shift() < slowd.shift())\n\n# 10-day volatility (ATR)\nadj_close = data.get(\"etl:adj_close\")\nvolatility = data.indicator(\"ATR\", adjust_price=True, resample=\"D\", timeperiod=10) / adj_close\n\n# Breaking above Keltner Channel upper band\nema = data.indicator(\"EMA\", adjust_price=True, resample=\"D\", timeperiod=10)\natr = data.indicator(\"ATR\", adjust_price=True, resample=\"D\", timeperiod=10)\nkeltner_up = ema + 2 * atr\ncond = (adj_close > keltner_up) & (adj_close.shift() < keltner_up.shift())\n\n# Breaking above Bollinger upper band\nupperband, middleband, lowerband = data.indicator(\"BBANDS\", timeperiod=10)\ncond = (æ”¶ç›¤åƒ¹ > upperband) & (æ”¶ç›¤åƒ¹.shift() < upperband.shift())\n\n# Breaking below Bollinger lower band\ncond = (æ”¶ç›¤åƒ¹ < lowerband) & (æ”¶ç›¤åƒ¹.shift() > lowerband.shift())\n\n# MACD golden cross\nmacd, macd_signal, macd_hist = data.indicator(\"MACD\", fastperiod=12, slowperiod=26, signalperiod=9)\nmacd_golden = (macd > macd_signal) & (macd.shift() < macd_signal.shift())\n\n# MACD histogram turns positive\nmacd_hist_positive = (macd_hist > 0) & (macd_hist.shift() < 0)\n\n# RSI oversold breakout (breaks above 30)\nrsi = data.indicator(\"RSI\", timeperiod=14)\nrsi_oversold_breakout = (rsi > 30) & (rsi.shift() < 30)\n\n# RSI overbought breakdown (drops below 70)\nrsi_overbought_breakdown = (rsi < 70) & (rsi.shift() > 70)\n\n# KD low-level golden cross (K < 50)\nslowk, slowd = data.indicator(\"STOCH\", fastk_period=9, slowk_period=3, slowk_matype=0, slowd_period=3, slowd_matype=0)\nkd_low_golden = (slowk > slowd) & (slowk.shift() < slowd.shift()) & (slowk < 50)\n```\n\n---\n\n### Fundamental Analysis\n\n#### Revenue Growth\n\n```python\nå»å¹´åŒæœˆå¢æ¸› = data.get(\"monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)\")\nä¸Šæœˆæ¯”è¼ƒå¢æ¸› = data.get(\"monthly_revenue:ä¸Šæœˆæ¯”è¼ƒå¢æ¸›(%)\")\nç•¶æœˆç‡Ÿæ”¶ = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\n\n# Revenue YoY growth > 30%\nrev_yy = å»å¹´åŒæœˆå¢æ¸› > 30\n\n# Revenue MoM growth > 30%\nrev_mm = ä¸Šæœˆæ¯”è¼ƒå¢æ¸› > 30\n\n# 3-month average revenue > 12-month average revenue\nrev_sl_compare = (ç•¶æœˆç‡Ÿæ”¶.average(3) > ç•¶æœˆç‡Ÿæ”¶.average(12))\n\n# 3-month average revenue YoY growth > 12-month average revenue YoY growth\nrev_sl_growth = ç•¶æœˆç‡Ÿæ”¶.average(3).pct_change(12) > ç•¶æœˆç‡Ÿæ”¶.average(12).pct_change(12)\n\n# 2-month average revenue at 12-month high\nrev_new_high = (ç•¶æœˆç‡Ÿæ”¶.average(2) / ç•¶æœˆç‡Ÿæ”¶.average(2).rolling(12, min_periods=6).max()) == 1\n\n# At least 2 out of last 3 months with YoY growth > 20%\nrev_rise_nsatisfy = (å»å¹´åŒæœˆå¢æ¸› > 20).sustain(nwindow=3, nsatisfy=2)\n\n# Revenue YoY growth ranking > 80th percentile\nrev_rise_nsatisfy = å»å¹´åŒæœˆå¢æ¸›.rank(pct=True, axis=1) > 0.80\n```\n\n#### Valuation Metrics\n\n```python\næœ¬ç›Šæ¯” = data.get(\"price_earning_ratio:æœ¬ç›Šæ¯”\")\nè‚¡åƒ¹æ·¨å€¼æ¯” = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\næ®–åˆ©ç‡ = data.get(\"price_earning_ratio:æ®–åˆ©ç‡(%)\")\n\n# PE ratio between 5 and 20\npe_range = (5 <= æœ¬ç›Šæ¯”) & (æœ¬ç›Šæ¯” <= 20)\n\n# PB ratio between 0.5 and 2\npb_range = (0.5 <= è‚¡åƒ¹æ·¨å€¼æ¯”) & (è‚¡åƒ¹æ·¨å€¼æ¯” <= 2)\n\n# Dividend yield between 3% and 10%\nyield_range = (3 <= æ®–åˆ©ç‡) & (æ®–åˆ©ç‡ <= 10)\n```\n\n#### Profitability Metrics\n\n```python\nç‡Ÿé‹ç¾é‡‘æµ = data.get(\"fundamental_features:ç‡Ÿé‹ç¾é‡‘æµ\")\nç‡Ÿæ¥­æ¯›åˆ©ç‡ = data.get(\"fundamental_features:ç‡Ÿæ¥­æ¯›åˆ©ç‡\")\nç‡Ÿæ¥­åˆ©ç›Šç‡ = data.get(\"fundamental_features:ç‡Ÿæ¥­åˆ©ç›Šç‡\")\nç¨…å‰æ·¨åˆ©ç‡ = data.get(\"fundamental_features:ç¨…å‰æ·¨åˆ©ç‡\")\nç¨…å¾Œæ·¨åˆ©ç‡ = data.get(\"fundamental_features:ç¨…å¾Œæ·¨åˆ©ç‡\")\næ¥­å¤–æ”¶æ”¯ç‡Ÿæ”¶ç‡ = data.get(\"fundamental_features:æ¥­å¤–æ”¶æ”¯ç‡Ÿæ”¶ç‡\")\næ¯è‚¡ç›ˆé¤˜ = data.get(\"financial_statement:æ¯è‚¡ç›ˆé¤˜\")\nROAç¶œåˆæç›Š = data.get(\"fundamental_features:ROAç¶œåˆæç›Š\")\nROEç¶œåˆæç›Š = data.get(\"fundamental_features:ROEç¶œåˆæç›Š\")\n\n# Operating cash flow > 0 for 1 quarter\nope_cashflow_trend = (ç‡Ÿé‹ç¾é‡‘æµ > 0).sustain(1)\n\n# Gross margin > 3% for 1 quarter\ngpm_trend = (ç‡Ÿæ¥­æ¯›åˆ©ç‡ > 3).sustain(1)\n\n# Operating margin > 3% for 1 quarter\nopm_trend = (ç‡Ÿæ¥­åˆ©ç›Šç‡ > 3).sustain(1)\n\n# Pre-tax margin > 3% for 1 quarter\nbtpm_trend = (ç¨…å‰æ·¨åˆ©ç‡ > 3).sustain(1)\n\n# After-tax margin > 3% for 1 quarter\natpm_trend = (ç¨…å¾Œæ·¨åˆ©ç‡ > 3).sustain(1)\n\n# Non-operating income ratio > 3% for 1 quarter\nopm_trend = (æ¥­å¤–æ”¶æ”¯ç‡Ÿæ”¶ç‡ > 3).sustain(1)\n\n# EPS > 0 for 4 consecutive quarters\neps_trend = (æ¯è‚¡ç›ˆé¤˜ > 0).sustain(4)\n\n# ROA > 0% for 4 consecutive quarters\nroa_trend = (ROAç¶œåˆæç›Š > 0).sustain(4)\n\n# ROE > 0% for 4 consecutive quarters\nroe_trend = (ROEç¶œåˆæç›Š > 0).sustain(4)\n```\n\n#### Leverage Metrics\n\n```python\nè² å‚µæ¯”ç‡ = data.get(\"fundamental_features:è² å‚µæ¯”ç‡\")\n\n# Debt ratio < 50% for 4 consecutive quarters\ndebt_trend = (è² å‚µæ¯”ç‡ < 50).sustain(4)\n```\n\n---\n\n### Chip Analysis\n\n#### Institutional Trading\n\n```python\nfrom finlab import data\n\n# Foreign institutional net buy ratio > 10% in 1 day\niit = data.get(\"institutional_investors_trading_summary:å¤–é™¸è³‡è²·è³£è¶…è‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†)\")\nvol = data.get(\"price:æˆäº¤è‚¡æ•¸\")\niit_ratio = iit.rolling(1).sum() / vol.rolling(1).sum() > 0.1\n\n# Investment trust net buy ratio > 10% in 1 day\næŠ•ä¿¡è²·è³£è¶…è‚¡æ•¸ = data.get(\"institutional_investors_trading_summary:æŠ•ä¿¡è²·è³£è¶…è‚¡æ•¸\")\næˆäº¤è‚¡æ•¸ = data.get(\"price:æˆäº¤è‚¡æ•¸\")\nict_ratio = æŠ•ä¿¡è²·è³£è¶…è‚¡æ•¸.rolling(1).sum() / æˆäº¤è‚¡æ•¸.rolling(1).sum() > 0.1\n\n# Foreign net buy > 200,000 shares for 2 consecutive days\nitt = data.get(\"institutional_investors_trading_summary:å¤–é™¸è³‡è²·è³£è¶…è‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†)\")\nitt_trend = (itt > 200000).sustain(2)\n\n# Investment trust net buy > 200,000 shares for 2 consecutive days\nict_trend = (æŠ•ä¿¡è²·è³£è¶…è‚¡æ•¸ > 200000).sustain(2)\n\n# Three major institutional investors all buying (ä¸‰å¤§æ³•äººåŒè²·)\nå¤–è³‡ = data.get(\"institutional_investors_trading_summary:å¤–é™¸è³‡è²·è³£è¶…è‚¡æ•¸(ä¸å«å¤–è³‡è‡ªç‡Ÿå•†)\")\næŠ•ä¿¡ = data.get(\"institutional_investors_trading_summary:æŠ•ä¿¡è²·è³£è¶…è‚¡æ•¸\")\nè‡ªç‡Ÿå•† = data.get(\"institutional_investors_trading_summary:è‡ªç‡Ÿå•†è²·è³£è¶…è‚¡æ•¸(è‡ªè¡Œè²·è³£)\")\nä¸‰å¤§æ³•äººåŒè²· = (å¤–è³‡ > 0) & (æŠ•ä¿¡ > 0) & (è‡ªç‡Ÿå•† > 0)\né€£çºŒåŒè²· = ä¸‰å¤§æ³•äººåŒè²·.sustain(3)\nposition = å¤–è³‡[é€£çºŒåŒè²·].is_largest(10)\n```\n\n#### Shareholding Distribution\n\n```python\ninventory = data.get(\"inventory\")\nè‘£ç›£æŒæœ‰è‚¡æ•¸å æ¯” = data.get(\"internal_equity_changes:è‘£ç›£æŒæœ‰è‚¡æ•¸å æ¯”\")\n\n# Large holders (>400 lots) shareholding >= 30%\nboss_inv = inventory[\n    (inventory.æŒè‚¡åˆ†ç´š.astype(int) >= 12) &\n    (inventory.æŒè‚¡åˆ†ç´š.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\"] >= 30\n\n# Large holders (>800 lots) shareholding >= 30%\nboss_inv = inventory[\n    (inventory.æŒè‚¡åˆ†ç´š.astype(int) >= 14) &\n    (inventory.æŒè‚¡åˆ†ç´š.astype(int) <= 15)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\"] >= 30\n\n# Large holders (>400 lots) increasing for 3 consecutive periods\nfrom finlab import dataframe\nboss_inv_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.æŒè‚¡åˆ†ç´š.astype(int) >= 12) &\n        (inventory.æŒè‚¡åˆ†ç´š.astype(int) <= 15)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\"]\n).rise().sustain(3)\n\n# Retail investors (<50 lots) shareholding <= 30%\nsmall_inv = inventory[\n    (inventory.æŒè‚¡åˆ†ç´š.astype(int) <= 8)\n].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n    \"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\": \"sum\"\n}).reset_index().pivot(\"date\", \"stock_id\")[\"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\"] <= 30\n\n# Retail investors (<50 lots) decreasing for 3 consecutive periods\nfrom finlab import dataframe\nsmall_inv_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.æŒè‚¡åˆ†ç´š.astype(int) <= 8)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"å é›†ä¿åº«å­˜æ•¸æ¯”ä¾‹\"]\n).fall().sustain(3)\n\n# Total number of shareholders decreasing for 3 consecutive periods\ninv_small_people_trend = dataframe.FinlabDataFrame(\n    inventory[\n        (inventory.äººæ•¸.astype(int) == 17)\n    ].reset_index().groupby([\"date\", \"stock_id\"]).agg({\n        \"äººæ•¸\": \"sum\"\n    }).reset_index().pivot(\"date\", \"stock_id\")[\"äººæ•¸\"]\n).fall().sustain(3)\n\n# Director/supervisor shareholding > 30%\nboss_hold = è‘£ç›£æŒæœ‰è‚¡æ•¸å æ¯” > 30\n\n# Director/supervisor shareholding increasing compared to 1 month ago\nboss_hold_rise = è‘£ç›£æŒæœ‰è‚¡æ•¸å æ¯”.rise(1)\n```\n\n#### Day Trading and Margin\n\n```python\nç•¶æ—¥æ²–éŠ·äº¤æ˜“æˆäº¤è‚¡æ•¸ = data.get(\"intraday_trading:ç•¶æ—¥æ²–éŠ·äº¤æ˜“æˆäº¤è‚¡æ•¸\")\næˆäº¤è‚¡æ•¸ = data.get(\"price:æˆäº¤è‚¡æ•¸\")\nèè³‡ä½¿ç”¨ç‡ = data.get(\"margin_transactions:èè³‡ä½¿ç”¨ç‡\")\nèåˆ¸ä½¿ç”¨ç‡ = data.get(\"margin_transactions:èåˆ¸ä½¿ç”¨ç‡\")\nèåˆ¸ä»Šæ—¥é¤˜é¡ = data.get(\"margin_transactions:èåˆ¸ä»Šæ—¥é¤˜é¡\")\nèè³‡ä»Šæ—¥é¤˜é¡ = data.get(\"margin_transactions:èè³‡ä»Šæ—¥é¤˜é¡\")\n\n# Day trading ratio < 10%\nday_trade_ratio = ç•¶æ—¥æ²–éŠ·äº¤æ˜“æˆäº¤è‚¡æ•¸ / æˆäº¤è‚¡æ•¸ / 2 < 0.1\n\n# Margin utilization > 0% for 1 day\nmargin_used_raio = (èè³‡ä½¿ç”¨ç‡ > 0).sustain(1)\n\n# Short selling utilization > 0% for 1 day\nmargin_sell_used_raio = (èåˆ¸ä½¿ç”¨ç‡ > 0).sustain(1)\n\n# Short/Margin ratio > 0% for 1 day\nmargin_trend = (èåˆ¸ä»Šæ—¥é¤˜é¡ / èè³‡ä»Šæ—¥é¤˜é¡ > 0).sustain(1)\n```\n\n---\n\n### Market Indicators\n\n```python\n# ADLs (Advance-Decline Line with Smoothing)\ndef ADLs_position(short_par=20, long_par=55):\n    close = data.get(\"price:æ”¶ç›¤åƒ¹\")\n    close_diff = close.diff()\n    total_stocks = (~close.isna()).sum(1)\n    rise_stocks = (close_diff > 0).sum(1)\n    ADLs = rise_stocks / total_stocks - 0.5\n    short_ADLs_ma = ADLs.rolling(short_par).mean()\n    long_ADLs_ma = ADLs.rolling(long_par).mean()\n    cond = ~close.isna()\n    cond1 = short_ADLs_ma >= long_ADLs_ma\n    position = cond & cond1\n    return position\n\n# VIX (Volatility Index)\ndef vix_position(short_par=5, long_par=20):\n    df = data.get(\"world_index:open\")\n    vix = df[\"^VIX\"].dropna()\n    short_vix_ma = vix.rolling(short_par).mean()\n    long_vix_ma = vix.rolling(long_par).mean()\n    close = data.get(\"price:æ”¶ç›¤åƒ¹\")\n    cond = ~close.isna()\n    cond1 = short_vix_ma <= long_vix_ma\n    cond1 = cond1.reindex(close.index)\n    position = cond & cond1\n    return position\n\n# Market Long/Short Alignment Count\ndef ls_order_position(short=5, mid=10, long=30):\n    close = data.get(\"price:æ”¶ç›¤åƒ¹\")\n    short_ma = close.average(short)\n    mid_ma = close.average(mid)\n    long_ma = close.average(long)\n    long_order = (short_ma >= mid_ma) & (mid_ma >= long_ma)\n    long_order = long_order.sum(1)\n    short_order = (short_ma < mid_ma) & (mid_ma < long_ma)\n    short_order = short_order.sum(1)\n    entry = long_order > short_order\n    cond = ~close.isna()\n    position = cond & entry\n    return position\n\n# Margin Maintenance Ratio\ndef margin_position(short_par=5, long_par=30):\n    èè³‡åˆ¸ç¸½é¤˜é¡ = data.get(\"margin_balance:èè³‡åˆ¸ç¸½é¤˜é¡\").fillna(method=\"ffill\")\n    èè³‡ä»Šæ—¥é¤˜é¡ = data.get(\"margin_transactions:èè³‡ä»Šæ—¥é¤˜é¡\")\n    close = data.get(\"price:æ”¶ç›¤åƒ¹\")\n    èè³‡ç¸½é¤˜é¡ = èè³‡åˆ¸ç¸½é¤˜é¡[[\"ä¸Šå¸‚èè³‡äº¤æ˜“é‡‘é¡\", \"ä¸Šæ«ƒèè³‡äº¤æ˜“é‡‘é¡\"]].sum(axis=1)\n    èè³‡é¤˜é¡å¸‚å€¼ = (èè³‡ä»Šæ—¥é¤˜é¡ * close * 1000).sum(axis=1)[èè³‡ä»Šæ—¥é¤˜é¡.index]\n    mt_rate = (èè³‡é¤˜é¡å¸‚å€¼ / èè³‡ç¸½é¤˜é¡)\n    mt_rate = mt_rate.dropna()\n    short_ma = mt_rate.rolling(short_par).mean()\n    long_ma = mt_rate.rolling(long_par).mean()\n    entry = short_ma >= long_ma\n    cond = ~close.isna()\n    position = cond & entry\n    return position\n```\n\n---\n\n### Filter Tools\n\n```python\nfrom finlab import data\n\n# Filter out attention stocks\nnoticed_stock_filter = data.get(\"etl:noticed_stock_filter\")\n\n# Filter out disposal stocks\ndisposal_stock_filter = data.get(\"etl:disposal_stock_filter\")\n\n# Filter out full cash delivery stocks\nfull_cash_delivery_stock_filter = data.get(\"etl:full_cash_delivery_stock_filter\")\n\n# Filter out KY stocks\nsc = data.get(\"security_categories\")\nposition_col = position.columns\nky_filter = position_col[~position_col.isin(list(sc[sc[\"name\"].str.contains(\"KY\")][\"stock_id\"]))]\nposition = position[ky_filter]\n\n# Limit backtest to specific industry\ndata.set_universe(market=\"TSE_OTC\", category=\"å»ºæç‡Ÿé€ \")\n```\n\n---\n\n## Complete Strategy Examples\n\n### 1. New High Strategy\n\nSelect stocks making 250-day new highs.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\nposition = (close == close.rolling(250).max())\nsim(position, resample=\"M\", name=\"å‰µå¹´æ–°é«˜ç­–ç•¥\")\n```\n\n---\n\n### 2. Revenue Momentum Strategy\n\nSelect stocks with strong recent revenue performance.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\nimport pandas as pd\n\nrev = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\nrev_rf = data.get(\"monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)\")\nvol = data.get(\"price:æˆäº¤è‚¡æ•¸\") / 1000\n\nrev_recent_3 = rev.rolling(3).sum()\nvol_avg = vol.average(10)\n\ncond1 = (rev_recent_3 / rev_recent_3.rolling(24, min_periods=12).max()) == 1\ncond2 = vol_avg > 300\ncond_all = cond1 & cond2\n\nresult = rev_rf * (cond_all)\nposition = result[result > 0].is_largest(10).reindex(rev.index_str_to_date().index, method=\"ffill\")\n\nsim(position=position, stop_loss=0.3, position_limit=0.1)\n```\n\n---\n\n### 3. Cash Flow Strategy\n\nSelect stocks with positive cash flows across all categories.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nç‡Ÿæ¥­ç¾é‡‘æµ = data.get(\"financial_statement:ç‡Ÿæ¥­æ´»å‹•ä¹‹æ·¨ç¾é‡‘æµå…¥_æµå‡º\")\næŠ•è³‡ç¾é‡‘æµ = data.get(\"financial_statement:æŠ•è³‡æ´»å‹•ä¹‹æ·¨ç¾é‡‘æµå…¥_æµå‡º\")\nèè³‡ç¾é‡‘æµ = data.get(\"financial_statement:ç±Œè³‡æ´»å‹•ä¹‹æ·¨ç¾é‡‘æµå…¥_æµå‡º\")\n\nposition = (ç‡Ÿæ¥­ç¾é‡‘æµ > 0) & (æŠ•è³‡ç¾é‡‘æµ > 0) & (èè³‡ç¾é‡‘æµ > 0)\nreport = sim(position, resample=\"M\", name=\"ç¾é‡‘æµæ­£æ•¸\")\n```\n\n---\n\n### 4. PEG Strategy\n\nPrice-Earnings to Growth ratio strategy.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\npe = data.get(\"price_earning_ratio:æœ¬ç›Šæ¯”\")\nrev = data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\")\nrev_ma3 = rev.average(3)\nrev_ma12 = rev.average(12)\nç‡Ÿæ¥­åˆ©ç›Šæˆé•·ç‡ = data.get(\"fundamental_features:ç‡Ÿæ¥­åˆ©ç›Šæˆé•·ç‡\")\n\npeg = (pe / ç‡Ÿæ¥­åˆ©ç›Šæˆé•·ç‡)\ncond1 = rev_ma3 / rev_ma12 > 1.1\ncond2 = rev / rev.shift(1) > 0.9\ncond_all = cond1 & cond2\n\nresult = peg * (cond_all)\nposition = result[result > 0].is_smallest(10).reindex(rev.index_str_to_date().index, method=\"ffill\")\n\nsim(position=position, name=\"peg_rev\", fee_ratio=1.425/1000/3, stop_loss=0.1)\n```\n\n---\n\n### 5. Momentum + ROE Filter Strategy\n\nCombine price momentum with ROE filter.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\n# Download ROE and closing price\nroe = data.get(\"fundamental_features:ROEç¨…å¾Œ\")\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\n\nposition = ((close / close.shift(60)).is_largest(30) & (roe > 0))\n\n# Backtest, rebalance monthly (M)\nreport = sim(position, resample=\"M\")\n```\n\n---\n\n### 6. Low PB Strategy\n\nPrice-to-Book ratio strategy with technical filter.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\npb = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\n\nbuy = (1 / (pb * close) * (close > close.average(60)) * (close > 5)).is_largest(20)\nsim(buy, resample=\"Q\")\n```\n\n---\n\n### 7. Triple RSI Strategy\n\nAdvanced RSI-based strategy with multiple timeframes.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\nimport pandas as pd\nfrom finlab import dataframe\n\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\nroe = data.get(\"fundamental_features:ROEç¨…å¾Œ\")\n\nrsi1 = data.indicator(\"RSI\", timeperiod=20)\nrsi2 = data.indicator(\"RSI\", freq=\"D\", timeperiod=60)\nrsi3 = data.indicator(\"RSI\", freq=\"D\", timeperiod=120)\n\nbuy = (rsi3 > 55) & (rsi1 / rsi1.shift(3) > 1.02) & (roe > 0) & \\\n      dataframe.FinlabDataFrame(rsi1 > 75).sustain(3) & (rsi2 < 75)\nsell = buy.shift(60) | (close < close.average(60))\n\nposition = pd.DataFrame(np.nan, index=buy.index, columns=buy.columns)\nposition[buy] = 1\nposition[sell] = 0\nposition = position.ffill().fillna(0)\n\nreport = sim(position.loc[\"2014\":], resample=\"W\")\n```\n\n---\n\n### 8. High RSI Strategy\n\nSimple high RSI momentum strategy.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nrsi = data.indicator(\"RSI\")\nposition = rsi.is_largest(20)\nreport = sim(position, resample=\"W\", name=\"é«˜RSIç­–ç•¥\")\n```\n\n---\n\n### 9. Entry/Exit Signal Example\n\nUsing hold_until for explicit entry and exit signals.\n\n```python\nfrom finlab import data\nfrom finlab.backtest import sim\n\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\npb = data.get(\"price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”\")\n\nsma20 = close.average(20)\nsma60 = close.average(60)\n\nentries = close > sma20\nexits = close < sma60\n\nposition = entries.hold_until(exits, nstocks_limit=10, rank=-pb)\nsim(position)\n```\n\n---\n\n### 10. Long/Short Strategy\n\nExample of simultaneous long and short positions.\n\n```python\nfrom finlab import data\nfrom finlab import backtest\n\nclose = data.get(\"price:æ”¶ç›¤åƒ¹\")\nposition = close < 0  # Start with all False\n\nposition[\"2330\"] = 0.5   # Long TSMC with 50% weight\nposition[\"1101\"] = -0.5  # Short Taiwan Cement with 50% weight\n\nreport = backtest.sim(position)\n```\n\n---\n\n## Best Practices\n\n1. **Use vectorized operations** - Never use for loops on FinlabDataFrame\n2. **Set appropriate resample periods** - Use 'M', 'Q', or revenue.index to avoid overtrading\n3. **Combine multiple factors** - Single factor strategies are often less robust\n4. **Apply filters** - Remove special status stocks (disposal, attention, full cash delivery)\n5. **Control position size** - Use position_limit and nstocks_limit\n6. **Set stop loss/take profit** - Protect against large losses\n7. **Universe filtering** - Use data.universe() to scope data.get() calls only\n8. **Proper alignment** - Let FinlabDataFrame handle index/column alignment automatically\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Backtesting Reference](backtesting-reference.md) - Backtest your strategies\n- [Data Reference](data-reference.md) - Complete data catalog\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n- [Machine Learning Reference](machine-learning-reference.md) - ML-based strategies\n",
        "finlab-plugin/skills/finlab/machine-learning-reference.md": "# Machine Learning Reference\n\n## Overview\n\nThe FinLab machine learning module provides tools for creating ML-based trading strategies. It includes feature engineering, label generation, and integration with popular ML libraries like scikit-learn, XGBoost, and LightGBM.\n\n**Import:**\n```python\nfrom finlab.ml import feature, label\n```\n\n---\n\n## Table of Contents\n\n1. [Feature Engineering](#feature-engineering)\n2. [Label Generation](#label-generation)\n3. [Complete ML Workflow](#complete-ml-workflow)\n4. [Best Practices](#best-practices)\n\n---\n\n## Feature Engineering\n\n### feature.ta_names\n\nGenerate a list of technical indicator feature names with randomized parameters.\n\n**Signature:**\n```python\nfeature.ta_names(\n    lb: int = 1,\n    ub: int = 10,\n    n: int = 1,\n    factory: Optional[Factory] = None\n) -> List[str]\n```\n\n**Parameters:**\n- `lb` (int, optional, default=1): Lower bound of the multiplier for default technical indicator parameters\n- `ub` (int, optional, default=10): Upper bound of the multiplier for default technical indicator parameters\n- `n` (int, optional, default=1): Number of random samples for each technical indicator\n- `factory` (optional, default=None): Factory object to generate technical indicators. Defaults to TalibIndicatorFactory\n\n**Returns:**\n- `List[str]`: A list of technical indicator feature names\n\n**Example:**\n```python\nimport finlab.ml.feature as f\n\n# Generate 5 random variations for each TA-Lib indicator\nfeature_names = f.ta_names(n=5)\nprint(feature_names[:10])\n```\n\n---\n\n### feature.ta\n\nCalculate technical indicator values for a list of feature names.\n\n**Signature:**\n```python\nfeature.ta(\n    feature_names: Optional[List[str]],\n    factories = None,\n    resample = None,\n    start_time = None,\n    end_time = None,\n    adj = False,\n    cpu = -1,\n    **kwargs\n) -> pd.DataFrame\n```\n\n**Parameters:**\n- `feature_names` (list, optional, default=None): List of technical indicator feature names. Defaults to None (generates default names)\n- `factories` (dict, optional, default=None): Dictionary of factories to generate technical indicators. Defaults to {'talib': TalibIndicatorFactory()}\n- `resample` (str, optional, default=None): Frequency to resample data (e.g., 'W', 'M'). Defaults to None\n- `start_time` (str, optional, default=None): Start time of the data\n- `end_time` (str, optional, default=None): End time of the data\n- `adj` (bool, optional, default=False): Whether to use adjusted prices\n- `cpu` (int, optional, default=-1): Number of CPU cores for parallel processing. -1 uses all available cores\n- `**kwargs`: Additional keyword arguments to pass to the resampler function\n\n**Returns:**\n- `pd.DataFrame`: Technical indicator feature names and values, indexed by ('datetime', 'instrument')\n\n**Example:**\n```python\nimport finlab.ml.feature as f\n\n# Method 1: Generate default indicators with random parameters\nfeatures1 = f.ta()\nprint(features1.head())\n\n# Method 2: Generate specific indicator with defined parameters, resampled weekly\nfeature_names = ['talib.MACD__macdhist__fastperiod__52__slowperiod__212__signalperiod__75__']\nfeatures2 = f.ta(feature_names, resample='W')\nprint(features2.head())\n```\n\n**Important Notes:**\n- `feature.ta` can only calculate values for feature names generated by `feature.ta_names` randomly\n- Do NOT use `feature.ta` and `feature.ta_names` by default. Use `data.indicator` instead for static feature names\n- If you want static feature names, use `data.indicator('SMA', timeperiod=20)` which supports all TA-Lib indicators\n\n---\n\n### feature.combine\n\nCombine multiple feature DataFrames into a single DataFrame.\n\n**Signature:**\n```python\nfeature.combine(\n    features: Dict[str, pd.DataFrame],\n    resample = None,\n    sample_filter = None,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `features` (dict, required): Dictionary where keys are feature names and values are DataFrames (index=datetime, columns=instrument)\n- `resample` (str, optional, default=None): Optional argument to resample data in features (e.g., 'W', 'M')\n- `sample_filter` (pd.DataFrame, optional, default=None): Boolean DataFrame (index=date, columns=instrument) representing the filter of features\n- `**kwargs`: Additional keyword arguments to pass to the resampler function\n\n**Returns:**\n- `pd.DataFrame`: All input features combined, indexed by ('datetime', 'instrument')\n\n**Example:**\n```python\nfrom finlab import data\nimport finlab.ml.feature as f\n\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”'),\n    'rsi': data.indicator('RSI')\n}\n\ncombined_features = f.combine(features_dict, resample='M')\nprint(combined_features.head())\n```\n\n**Important Notes:**\n- `feature.combine` can handle misaligned indices and missing data automatically\n- Set `resample` to 'W', '2W', `data.get(\"monthly_revenue:ç•¶æœˆç‡Ÿæ”¶\").index`, `data.get(\"fundamental_features:ROEç¨…å¾Œ\").deadline().index`, 'ME', 'QE', etc. to avoid excessive data points and high RAM consumption\n- Use `sample_filter` parameter to filter unwanted data points (e.g., `sample_filter = data.get('price:æˆäº¤è‚¡æ•¸') > 200_000`)\n\n---\n\n## Label Generation\n\n### label.return_percentage\n\nCalculate the percentage change of market prices over a given period.\n\n**Signature:**\n```python\nlabel.return_percentage(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    bfill = False,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency for output data (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods to calculate percentage change over\n- `trade_at_price` (str, optional, default='close'): Price for execution ('open', 'high', 'low', 'close')\n- `bfill` (bool, optional, default=False): Whether to backfill missing price data before calculation\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Percentage change of stock prices, aligned to input index\n\n**Example:**\n```python\nfrom finlab.ml import label\n\n# Assume features is your feature DataFrame\ny = label.return_percentage(features.index, resample='M', period=1)\n```\n\n---\n\n### label.excess_over_mean\n\nCalculate the excess return over the cross-sectional mean return for a given period.\n\n**Signature:**\n```python\nlabel.excess_over_mean(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods for return calculation\n- `trade_at_price` (str, optional, default='close'): Price for return calculation ('open', 'high', 'low', 'close')\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Excess return over the mean, aligned to input index\n\n**Example:**\n```python\nfrom finlab.ml import label\n\n# Excess return over market mean\ny = label.excess_over_mean(features.index, resample='M', period=1)\n```\n\n---\n\n### label.excess_over_median\n\nCalculate the excess return over the cross-sectional median return for a given period.\n\n**Signature:**\n```python\nlabel.excess_over_median(\n    index: pd.Index,\n    resample = None,\n    period = 1,\n    trade_at_price = 'close',\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `resample` (str, optional, default=None): Resample frequency (e.g., 'W', 'M')\n- `period` (int, optional, default=1): Number of periods for return calculation\n- `trade_at_price` (str, optional, default='close'): Price for return calculation\n- `**kwargs`: Additional arguments passed to resampler function\n\n**Returns:**\n- `pd.Series`: Excess return over the median, aligned to input index\n\n---\n\n### label.daytrading_percentage\n\nCalculate the intraday percentage change (close / open - 1).\n\n**Signature:**\n```python\nlabel.daytrading_percentage(\n    index: pd.Index,\n    **kwargs\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument, typically from a feature DataFrame\n- `**kwargs`: Additional arguments passed to internal resampler function\n\n**Returns:**\n- `pd.Series`: Intraday percentage change, aligned to input index\n\n---\n\n### label.maximum_adverse_excursion\n\nCalculate the maximum adverse excursion (lowest price relative to entry) over a given period.\n\n**Signature:**\n```python\nlabel.maximum_adverse_excursion(\n    index: pd.Index,\n    period = 1,\n    trade_at_price = 'close'\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `period` (int, optional, default=1): Number of periods to look forward for minimum price\n- `trade_at_price` (str, optional, default='close'): Entry price to compare against ('open', 'high', 'low', 'close')\n\n**Returns:**\n- `pd.Series`: Maximum adverse excursion, aligned to input index\n\n---\n\n### label.maximum_favorable_excursion\n\nCalculate the maximum favorable excursion (highest price relative to entry) over a given period.\n\n**Signature:**\n```python\nlabel.maximum_favorable_excursion(\n    index: pd.Index,\n    period = 1,\n    trade_at_price = 'close'\n)\n```\n\n**Parameters:**\n- `index` (pd.Index, required): Multi-level index of datetime and instrument\n- `period` (int, optional, default=1): Number of periods to look forward for maximum price\n- `trade_at_price` (str, optional, default='close'): Entry price to compare against\n\n**Returns:**\n- `pd.Series`: Maximum favorable excursion, aligned to input index\n\n---\n\n## Complete ML Workflow\n\n### Basic LightGBM Regression Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom finlab.backtest import sim\nfrom finlab.dataframe import FinlabDataFrame\nfrom lightgbm import LGBMRegressor\nimport pandas as pd\n\n# Step 1: Feature Engineering\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”'),\n    'pe': data.get('price_earning_ratio:æœ¬ç›Šæ¯”'),\n    'rsi': data.indicator('RSI', timeperiod=14),\n    'revenue_growth': data.get('monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)'),\n    'roe': data.get('fundamental_features:ROEç¨…å¾Œ'),\n}\n\n# Combine features with filtering\nsample_filter = data.get('price:æˆäº¤è‚¡æ•¸') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\n\n# Step 2: Label Generation\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Step 3: Train/Test Split\ntrain_mask = X.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X[train_mask]\ny_train = y[train_mask]\nX_test = X[test_mask]\ny_test = y[test_mask]\n\n# Step 4: Model Training\nmodel = LGBMRegressor(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=42)\nmodel.fit(X_train, y_train)\n\n# Step 5: Prediction and Position Construction\ny_pred = model.predict(X_test)\ndf_y = FinlabDataFrame(y_pred, index=X_test.index).unstack().T\n\n# Step 6: Create Trading Position\nposition = df_y.is_largest(10)  # Select top 10 stocks\n\n# Step 7: Backtest\nreport = sim(position)\nprint(report.get_metrics())\n```\n\n---\n\n### Advanced Feature Selection Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom lightgbm import LGBMRegressor\nfrom sklearn.feature_selection import SelectKBest, f_regression\nimport pandas as pd\n\n# Generate many features\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”'),\n    'pe': data.get('price_earning_ratio:æœ¬ç›Šæ¯”'),\n    'ps': data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”') * data.get('fundamental_features:æ¯è‚¡ç‡Ÿæ¥­é¡'),\n    'rsi_14': data.indicator('RSI', timeperiod=14),\n    'rsi_28': data.indicator('RSI', timeperiod=28),\n    'macd': data.indicator('MACD')[0],  # MACD line\n    'revenue_growth': data.get('monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)'),\n    'revenue_ma3': data.get('monthly_revenue:ç•¶æœˆç‡Ÿæ”¶').average(3),\n    'roe': data.get('fundamental_features:ROEç¨…å¾Œ'),\n    'roa': data.get('fundamental_features:ROAç¶œåˆæç›Š'),\n    'gross_margin': data.get('fundamental_features:ç‡Ÿæ¥­æ¯›åˆ©ç‡'),\n    'debt_ratio': data.get('fundamental_features:è² å‚µæ¯”ç‡'),\n}\n\n# Combine and clean\nsample_filter = data.get('price:æˆäº¤è‚¡æ•¸') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Feature selection\nselector = SelectKBest(score_func=f_regression, k=6)\nX_selected = selector.fit_transform(X, y)\nselected_features = X.columns[selector.get_support()].tolist()\n\nprint(\"Selected Features:\", selected_features)\n\n# Train model with selected features\nX_selected_df = pd.DataFrame(X_selected, index=X.index, columns=selected_features)\n\n# Split\ntrain_mask = X_selected_df.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X_selected_df.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X_selected_df[train_mask]\ny_train = y[train_mask]\nX_test = X_selected_df[test_mask]\n\n# Train and predict\nmodel = LGBMRegressor(n_estimators=200, learning_rate=0.05, max_depth=6)\nmodel.fit(X_train, y_train)\ny_pred = model.predict(X_test)\n\n# Feature importance\nimportance_df = pd.DataFrame({\n    'feature': selected_features,\n    'importance': model.feature_importances_\n}).sort_values('importance', ascending=False)\n\nprint(\"\\nFeature Importance:\")\nprint(importance_df)\n```\n\n---\n\n### Classification Example\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom finlab.dataframe import FinlabDataFrame\nfrom finlab.backtest import sim\nfrom lightgbm import LGBMClassifier\nimport pandas as pd\n\n# Feature engineering\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”'),\n    'rsi': data.indicator('RSI'),\n    'revenue_growth': data.get('monthly_revenue:å»å¹´åŒæœˆå¢æ¸›(%)'),\n}\n\nsample_filter = data.get('price:æˆäº¤è‚¡æ•¸') > 200_000\nX = feature.combine(features_dict, resample='M', sample_filter=sample_filter)\n\n# Binary classification label (outperform market or not)\ny_continuous = label.excess_over_mean(X.index, resample='M', period=1)\ny = (y_continuous > 0).astype(int)  # 1 if outperforms, 0 otherwise\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Split\ntrain_mask = X.index.get_level_values('datetime') < '2020-01-01'\ntest_mask = X.index.get_level_values('datetime') >= '2020-01-01'\n\nX_train = X[train_mask]\ny_train = y[train_mask]\nX_test = X[test_mask]\n\n# Train classifier\nmodel = LGBMClassifier(n_estimators=100, learning_rate=0.1, max_depth=5)\nmodel.fit(X_train, y_train)\n\n# Predict probabilities\ny_pred_proba = model.predict_proba(X_test)[:, 1]  # Probability of class 1\ndf_y = FinlabDataFrame(y_pred_proba, index=X_test.index).unstack().T\n\n# Create position based on probability\nposition = df_y.is_largest(10)  # Top 10 highest probability\n\n# Backtest\nreport = sim(position)\nprint(report.get_metrics())\n```\n\n---\n\n### Time Series Cross-Validation\n\n```python\nfrom finlab import data\nfrom finlab.ml import feature, label\nfrom lightgbm import LGBMRegressor\nfrom sklearn.model_selection import TimeSeriesSplit\nimport pandas as pd\nimport numpy as np\n\n# Prepare features and labels\nfeatures_dict = {\n    'pb': data.get('price_earning_ratio:è‚¡åƒ¹æ·¨å€¼æ¯”'),\n    'rsi': data.indicator('RSI'),\n}\n\nX = feature.combine(features_dict, resample='M')\ny = label.excess_over_mean(X.index, resample='M', period=1)\n\n# Remove NaN\nmask = ~(X.isna().any(axis=1) | y.isna())\nX = X[mask]\ny = y[mask]\n\n# Get unique dates for time series split\ndates = X.index.get_level_values('datetime').unique().sort_values()\ndate_to_idx = {date: idx for idx, date in enumerate(dates)}\nX['date_idx'] = X.index.get_level_values('datetime').map(date_to_idx)\n\n# Time series cross-validation\ntscv = TimeSeriesSplit(n_splits=5)\nscores = []\n\nfor train_idx, val_idx in tscv.split(dates):\n    train_dates = dates[train_idx]\n    val_dates = dates[val_idx]\n\n    X_train = X[X['date_idx'].isin([date_to_idx[d] for d in train_dates])].drop('date_idx', axis=1)\n    y_train = y[X_train.index]\n    X_val = X[X['date_idx'].isin([date_to_idx[d] for d in val_dates])].drop('date_idx', axis=1)\n    y_val = y[X_val.index]\n\n    model = LGBMRegressor(n_estimators=100)\n    model.fit(X_train, y_train)\n    score = model.score(X_val, y_val)\n    scores.append(score)\n    print(f\"Fold RÂ²: {score:.4f}\")\n\nprint(f\"\\nAverage RÂ²: {np.mean(scores):.4f} (+/- {np.std(scores):.4f})\")\n```\n\n---\n\n## Best Practices\n\n### Feature Engineering\n1. **Start with static indicators** - Use `data.indicator()` instead of `feature.ta()` for reproducibility\n2. **Set appropriate resample frequency** - Use 'W', 'ME', 'QE', or `revenue.index` to control data density\n3. **Apply sample filters** - Filter low-volume or special-status stocks using `sample_filter`\n4. **Handle missing data** - Always check and handle NaN values before training\n5. **Normalize features** - Consider scaling features for better model performance\n6. **Ensure proper alignment** - `feature.combine` handles this automatically\n\n### Label Generation\n1. **Match resample frequency** - Ensure label `resample` matches feature `resample`\n2. **Use excess returns** - `excess_over_mean` or `excess_over_median` for better signal\n3. **Consider prediction horizon** - Match `period` to your trading frequency\n4. **Align indices** - Use `features.index` when generating labels\n\n### Model Training\n1. **Time-based splits** - Use `X.index.get_level_values('datetime') > '2020-01-01'` for proper train/test split\n2. **Avoid look-ahead bias** - Never use future information in features\n3. **Cross-validate** - Use time series cross-validation, not random splits\n4. **Tune hyperparameters** - Use validation set for hyperparameter optimization\n5. **Monitor overfitting** - Compare train and test performance regularly\n\n### Position Construction\n1. **Use FinlabDataFrame** - Convert predictions with `FinlabDataFrame(y_pred, index=X_test.index).unstack().T`\n2. **Limit positions** - Use `is_largest(n)` or `is_smallest(n)` for position sizing\n3. **Apply filters** - Combine ML predictions with fundamental or technical filters\n4. **Set stop-loss/take-profit** - Protect against large losses in backtesting\n\n### Backtesting\n1. **Use realistic assumptions** - Include transaction costs and slippage\n2. **Test out-of-sample** - Always backtest on unseen data\n3. **Monitor metrics** - Check Sharpe ratio, max drawdown, and win rate\n4. **Avoid overfitting** - Be wary of perfect backtest results\n\n---\n\n## Related References\n\n- [FinlabDataFrame Reference](dataframe-reference.md) - Enhanced DataFrame methods\n- [Data Reference](data-reference.md) - Available data sources\n- [Factor Examples](factor-examples.md) - Factor-based strategies\n- [Factor Analysis Reference](factor-analysis-reference.md) - Analyze factor performance\n- [Backtesting Reference](backtesting-reference.md) - Backtest ML strategies\n",
        "finlab-plugin/skills/finlab/trading-reference.md": "# Trading & Order Execution Reference\n\n## Overview\n\nThis reference covers the complete workflow for executing trades from backtest results to live orders. The process involves:\n\n1. **Position Calculation**: Convert backtest results to share quantities\n2. **Broker Connection**: Configure and connect to your broker account\n3. **Order Execution**: Create, update, and manage orders via OrderExecutor\n\n---\n\n## Position Class\n\nThe `Position` class represents target holdings and provides methods for converting backtest results to executable positions.\n\n**Import:**\n```python\nfrom finlab.online.order_executor import Position\n```\n\n### Position.from_report()\n\nConvert a backtest report to tradeable positions.\n\n**Signature:**\n```python\nPosition.from_report(\n    report,\n    fund: float,\n    odd_lot: bool = False\n) -> Position\n```\n\n**Parameters:**\n- `report` (Report, required): Backtest report object from `sim()`\n- `fund` (float, required): Total capital in TWD for position sizing\n- `odd_lot` (bool, default=False): Enable odd lot (é›¶è‚¡) trading for smaller positions\n\n**Returns:**\n- `Position`: List of position dictionaries with stock_id, quantity, and order_condition\n\n**Example:**\n```python\nfrom finlab import backtest\nfrom finlab.online.order_executor import Position\n\nreport = backtest.sim(position, resample=\"M\")\n\n# Standard lot trading\nposition = Position.from_report(report, fund=1000000)\nprint(position)\n# [{'stock_id': '2330', 'quantity': 1, 'order_condition': <OrderCondition.CASH: 1>}]\n\n# Odd lot trading (smaller positions)\nposition = Position.from_report(report, fund=1000000, odd_lot=True)\n```\n\n---\n\n### Custom Position\n\nCreate a position manually without backtest.\n\n**Signature:**\n```python\nPosition(holdings: dict) -> Position\n```\n\n**Example:**\n```python\n# Simple position with share counts\nposition = Position({'2330': 1, '1101': 2})\n\n# Fractional shares (for odd lot)\nposition = Position({'2330': 1, '1101': 1.001})\n```\n\n---\n\n### Position Arithmetic\n\nCombine or modify positions using arithmetic operations.\n\n**Subtraction:**\n```python\n# Remove stocks from position\nnew_position = position - Position({'2330': 1})\n```\n\n**Addition:**\n```python\n# Add stocks to position\nnew_position = position + Position({'1101': 1})\n```\n\n**Multi-strategy combination:**\n```python\n# Combine positions from multiple strategies\nposition1 = Position.from_report(report1, fund=500000)\nposition2 = Position.from_report(report2, fund=500000)\ntotal_position = position1 + position2\n```\n\n---\n\n## Broker Account Setup\n\n### Environment Variables Summary\n\n| Broker | Required Environment Variables |\n|--------|-------------------------------|\n| Esun (ç‰å±±) | `ESUN_CONFIG_PATH`, `ESUN_MARKET_API_KEY`, `ESUN_ACCOUNT_PASSWORD`, `ESUN_CERT_PASSWORD` |\n| Sinopac (æ°¸è±) | `SHIOAJI_API_KEY`, `SHIOAJI_SECRET_KEY`, `SHIOAJI_CERT_PERSON_ID`, `SHIOAJI_CERT_PATH`, `SHIOAJI_CERT_PASSWORD` |\n| Masterlink (å…ƒå¯Œ) | `MASTERLINK_NATIONAL_ID`, `MASTERLINK_ACCOUNT`, `MASTERLINK_ACCOUNT_PASS`, `MASTERLINK_CERT_PATH`, `MASTERLINK_CERT_PASS` |\n| Fubon (å¯Œé‚¦) | `FUBON_NATIONAL_ID`, `FUBON_ACCOUNT_PASS`, `FUBON_CERT_PATH` |\n\n---\n\n### Esun (ç‰å±±è­‰åˆ¸)\n\n**Import:**\n```python\nfrom finlab.online.esun_account import EsunAccount\n```\n\n**Environment Variables:**\n```bash\nexport ESUN_CONFIG_PATH='/path/to/config.ini'\nexport ESUN_MARKET_API_KEY='your_market_api_key'\nexport ESUN_ACCOUNT_PASSWORD='your_password'\nexport ESUN_CERT_PASSWORD='your_cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['ESUN_CONFIG_PATH'] = '/path/to/config.ini'\nos.environ['ESUN_MARKET_API_KEY'] = 'your_market_api_key'\nos.environ['ESUN_ACCOUNT_PASSWORD'] = 'your_password'\nos.environ['ESUN_CERT_PASSWORD'] = 'your_cert_password'\n\nacc = EsunAccount()\n```\n\n**Install SDK:**\n```bash\npip install esun-trade\n```\n\n---\n\n### Sinopac (æ°¸è±è­‰åˆ¸)\n\n**Import:**\n```python\nfrom finlab.online.sinopac_account import SinopacAccount\n```\n\n**Environment Variables:**\n```bash\nexport SHIOAJI_API_KEY='api_key'\nexport SHIOAJI_SECRET_KEY='secret_key'\nexport SHIOAJI_CERT_PERSON_ID='A123456789'\nexport SHIOAJI_CERT_PATH='/path/to/cert'\nexport SHIOAJI_CERT_PASSWORD='cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['SHIOAJI_API_KEY'] = 'api_key'\nos.environ['SHIOAJI_SECRET_KEY'] = 'secret_key'\nos.environ['SHIOAJI_CERT_PERSON_ID'] = 'A123456789'\nos.environ['SHIOAJI_CERT_PATH'] = '/path/to/cert'\nos.environ['SHIOAJI_CERT_PASSWORD'] = 'cert_password'\n\nacc = SinopacAccount()\n```\n\n**Install SDK:**\n```bash\npip install shioaji\n```\n\n---\n\n### Masterlink (å…ƒå¯Œè­‰åˆ¸)\n\n**Import:**\n```python\nfrom finlab.online.masterlink_account import MasterlinkAccount\n```\n\n**Environment Variables:**\n```bash\nexport MASTERLINK_NATIONAL_ID='A123456789'\nexport MASTERLINK_ACCOUNT='account'\nexport MASTERLINK_ACCOUNT_PASS='password'\nexport MASTERLINK_CERT_PATH='/path/to/cert'\nexport MASTERLINK_CERT_PASS='cert_password'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['MASTERLINK_NATIONAL_ID'] = 'A123456789'\nos.environ['MASTERLINK_ACCOUNT'] = 'account'\nos.environ['MASTERLINK_ACCOUNT_PASS'] = 'password'\nos.environ['MASTERLINK_CERT_PATH'] = '/path/to/cert'\nos.environ['MASTERLINK_CERT_PASS'] = 'cert_password'\n\nacc = MasterlinkAccount()\n```\n\n---\n\n### Fubon (å¯Œé‚¦è­‰åˆ¸)\n\n**Import:**\n```python\nfrom finlab.online.fubon_account import FubonAccount\n```\n\n**Environment Variables:**\n```bash\nexport FUBON_NATIONAL_ID='A123456789'\nexport FUBON_ACCOUNT_PASS='password'\nexport FUBON_CERT_PATH='/path/to/cert.pfx'\n```\n\n**Usage:**\n```python\nimport os\n\nos.environ['FUBON_NATIONAL_ID'] = 'A123456789'\nos.environ['FUBON_ACCOUNT_PASS'] = 'password'\nos.environ['FUBON_CERT_PATH'] = '/path/to/cert.pfx'\n\nacc = FubonAccount()\n```\n\n---\n\n## OrderExecutor Class\n\nThe `OrderExecutor` manages order creation, modification, and cancellation.\n\n**Import:**\n```python\nfrom finlab.online.order_executor import OrderExecutor\n```\n\n**Signature:**\n```python\nOrderExecutor(\n    position: Position,\n    account: BrokerAccount\n) -> OrderExecutor\n```\n\n**Parameters:**\n- `position` (Position, required): Target position to execute\n- `account` (BrokerAccount, required): Connected broker account instance\n\n**Example:**\n```python\nfrom finlab.online.order_executor import OrderExecutor, Position\nfrom finlab.online.sinopac_account import SinopacAccount\n\n# Setup\nposition = Position.from_report(report, fund=1000000)\nacc = SinopacAccount()\nexecutor = OrderExecutor(position, account=acc)\n```\n\n---\n\n### OrderExecutor Methods\n\n#### show_alerting_stocks()\n\nDisplay stocks that require pre-deposit (è™•ç½®è‚¡/è­¦ç¤ºè‚¡).\n\n```python\nexecutor.show_alerting_stocks()\n```\n\n---\n\n#### create_orders()\n\nCreate orders based on the target position.\n\n**Signature:**\n```python\ncreate_orders(view_only: bool = False) -> None\n```\n\n**Parameters:**\n- `view_only` (bool, default=False): If True, preview orders without execution\n\n**Example:**\n```python\n# Preview orders first (recommended)\nexecutor.create_orders(view_only=True)\n\n# Execute orders\nexecutor.create_orders()\n```\n\n---\n\n#### update_order_price()\n\nUpdate limit price for pending orders.\n\n```python\nexecutor.update_order_price()\n```\n\n---\n\n#### cancel_orders()\n\nCancel all pending orders.\n\n```python\nexecutor.cancel_orders()\n```\n\n---\n\n## Check Account Position\n\nQuery current holdings from broker.\n\n```python\n# Get current holdings\nprint(acc.get_position())\n```\n\n---\n\n## Related References\n\n- [backtesting-reference.md](backtesting-reference.md): Backtest configuration and report generation\n- [best-practices.md](best-practices.md): Coding patterns and anti-patterns\n"
      },
      "plugins": [
        {
          "name": "finlab-plugin",
          "source": "./finlab-plugin",
          "description": "FinLab quantitative trading skills for Taiwan stock market (å°è‚¡) - includes strategy development, backtesting, data analysis, and factor research",
          "version": "1.0.0",
          "author": {
            "name": "FinLab Community"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add koreal6803/finlab-ai",
            "/plugin install finlab-plugin@finlab-plugins"
          ]
        }
      ]
    }
  ]
}