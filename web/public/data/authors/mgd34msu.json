{
  "author": {
    "id": "mgd34msu",
    "display_name": "Michael Davis",
    "avatar_url": "https://avatars.githubusercontent.com/u/18431027?u=948c04c86a72ea649007575eedcaa5e083e89a00&v=4"
  },
  "marketplaces": [
    {
      "name": "goodvibes-market",
      "version": null,
      "description": "goodvibes plugin marketplace",
      "repo_full_name": "mgd34msu/goodvibes-plugin",
      "repo_url": "https://github.com/mgd34msu/goodvibes-plugin",
      "repo_description": "Claude Code plugin that replaces native tools with token-efficient precision equivalents. 75 MCP tools, 11 specialized agents, persistent cross-session memory, and 7-layer token optimization that compounds savings from per-operation verbosity control through dual-layer caching to orchestration-level efficiency.",
      "signals": {
        "stars": 3,
        "forks": 0,
        "pushed_at": "2026-02-11T01:08:01Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"goodvibes-market\",\n  \"owner\": {\n    \"name\": \"Mike Davis\",\n    \"email\": \"mgd34msu@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"goodvibes plugin marketplace\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"goodvibes\",\n      \"source\": \"./plugins/goodvibes\",\n      \"description\": \"Comprehensive Claude Code plugin with agents, skills, tools, hooks, and MCP servers for full-stack development.\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"Mike Davis\"\n      }\n    }\n  ]\n}\n",
        "README.md": "# GoodVibes Plugin\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Version](https://img.shields.io/badge/version-1.2.0-blue.svg)](https://github.com/mgd34msu/goodvibes-plugin)\n[![Claude Code Plugin](https://img.shields.io/badge/Claude%20Code-Plugin-purple.svg)](https://claude.com/claude-code)\n\n> Plug in. Receive good vibes.\n\nA Claude Code plugin that replaces native tools with token-efficient precision equivalents, adds 75 MCP tools across 6 engines, and orchestrates 11 specialized agents with persistent cross-session memory.\n\n## At a Glance\n\n| Component | Count | What You Get |\n|-----------|-------|-------------|\n| Agents | 11 | Specialized roles (Opus/Sonnet) for engineering, review, testing, architecture, deployment, integration, planning |\n| Skills | 173 | Technology-specific knowledge modules covering modern web stacks |\n| MCP Tools | 75 | Token-efficient tools across 6 specialized engines |\n| Hooks | 10 | Lifecycle automation (tool redirection, context injection, error recovery) |\n| Output Styles | 2 | Interactive (vibecoding) or fully autonomous (justvibes) |\n| Templates | 3 | Production scaffolds for Next.js and React |\n\n## Why GoodVibes?\n\n### Token Efficiency\n\nToken consumption in AI coding sessions follows a layered pattern: individual operations add tokens, round trips resend conversation context, sessions accumulate state, and knowledge either persists or gets rediscovered. GoodVibes optimizes all seven layers.\n\n#### Layer 1: Per-Operation Savings\n\nNative tools return maximum output regardless of need. Precision tools let you request exactly the detail level required.\n\n*Note: Token estimates below are for typical small-to-medium files (~50-100 lines). Savings scale linearly with file size (e.g., a 500-line file would be ~5,000 tokens native vs. the same low precision overhead).*\n\n| Operation | Native Tool | Precision Tool | Savings |\n|-----------|-------------|----------------|---------|\n| Check if a file exists | `Read` returns full content (~500+ tokens) | `precision_read` with `count_only` (~15 tokens) | ~97% |\n| Count files matching a pattern | `Glob` returns all paths (~200+ tokens) | `precision_glob` with `count_only` (~15 tokens) | ~92% |\n| Check if a pattern exists in code | `Grep` returns all matches with context (~300+ tokens) | `precision_grep` with `count_only` (~15 tokens) | ~95% |\n| Re-read an unchanged file | `Read` returns full content again (~500+ tokens) | `precision_read` returns cache hit (~20 tokens) | ~96% |\n| Get function signatures from a file | `Read` returns entire file (~500+ tokens) | `precision_read` with `symbols` extract (~50 tokens) | ~90% |\n\n**Mechanisms:**\n- **Verbosity levels** (4-6 per tool): `count_only`, `files_only`, `minimal`, `standard`, `verbose`. Tools default to minimal output automatically — `precision_edit` defaults to `minimal`, `precision_grep` to `files_only`, `precision_glob` to `paths_only`. Savings are automatic even without explicit requests.\n- **Extract modes** (`precision_read`): `content`, `outline`, `symbols`, `ast`, `lines`. Get function signatures (~50 tokens) instead of full file content (~500+ tokens). 75-95% savings.\n- **Token budget pagination**: Large results auto-paginate to stay within a specified token limit. Prevents single responses from consuming disproportionate context.\n- **AST pattern matching** (`precision_edit`): More precise than regex, fewer false positives, fewer failed edits requiring retry.\n\n#### Layer 2: Per-Round-Trip Savings\n\nEvery API call resends the entire conversation (system prompt + tool definitions + all messages). Fewer calls = less overhead.\n\n- **Batch operations**: Read 10 files, edit 5 files, run 3 commands, fetch 5 URLs — each in a single tool call. Eliminates N-1 round trips.\n- **discover tool**: Runs grep + glob + symbol queries simultaneously in one call. Results keyed by query ID. 5 searches → 1 round trip instead of 5.\n- **Atomic transactions**: `precision_edit` and `precision_write` in atomic mode. If any operation fails, all roll back. Prevents partial failures that require re-investigation (which costs more round trips).\n\nQuick example:\n```\nReading 10 files:\n  Native: 10 calls × (full conversation prefix resent each time)\n  Precision: 1 call × (conversation prefix sent once)\n  = 9 fewer prefix resends\n```\n\n#### Layer 3: Per-Session Savings\n\nState tracked within a session avoids redundant work.\n\n- **File state caching**: SHA256 hash-based. Re-reading an unchanged file returns ~20 tokens instead of full content. In edit-verify-edit cycles, this compounds rapidly.\n- **Search cache**: Last 20 grep results stored by query ID. Enables incremental refinement without re-running expensive searches.\n- **Stack detection caching**: `detect_stack` results cached to `.goodvibes/detected-stack.json`. Re-detection skipped within session.\n- **Context injection at session start**: SessionStart hook gathers 8 context types in parallel (stack, git, environment, TODOs, health, folder structure, memory, ports) and injects them upfront. Agents skip discovery.\n- **Conditional context sections**: Context builder omits healthy sections entirely. If no health warnings exist, no health section is injected. Saves 200-500 tokens on healthy projects.\n- **Subagent context pre-loading**: SubagentStart hook injects project name, git branch, and stack info into every subagent at spawn. No per-agent discovery needed.\n\n#### Layer 4: Cross-Session Savings\n\nKnowledge persists across conversations. Same problem next week? Already documented.\n\n- **Memory system**: `.goodvibes/memory/` stores decisions, patterns, failures, and preferences in structured JSON. Agents read memory before acting. An agent that would spend 5K+ tokens debugging a known issue instead reads a 200-token failure record.\n- **PostToolUseFailure logging**: Failed tool attempts are logged with root cause and prevention guidance. Future sessions inherit this knowledge automatically.\n- **Learn-and-abandon pattern**: Fix attempts are capped. If the issue is upstream (in a package you can't change), you don't burn tokens trying to fix it again — every future session reads the failure record and skips the investigation entirely.\n\n#### Layer 5: Infrastructure Savings (Dual-Layer Caching)\n\nPrecision engine's local file cache and Anthropic's remote prompt cache operate at different layers and compound:\n\n| Layer | What It Does | Impact |\n|-------|--------------|--------|\n| **Local (MCP)** | Caches file state by content hash | Shrinks token volume added to conversation |\n| **Remote (Anthropic)** | Caches conversation prefix | Discounts per-token cost for cached turns |\n\nWithout local caching, re-reading a file adds full content to the conversation every time. With local caching, only the first read adds full content; subsequent reads return cache hits (~20 tokens each). This keeps the conversation prefix smaller.\n\nSince Anthropic's prompt cache pricing uses multipliers (cache reads at ~10% of base input price), a smaller prefix means cheaper cache operations on every turn.\n\n```\nRe-reading a 500-line file 3 times during a session:\n  Native tools:  5,000 + 5,000 + 5,000 = 15,000 tokens added to conversation\n  Precision:     5,000 + 20 + 20       = 5,040 tokens added\n\nOver 20 files read multiple times:\n  Native:    ~100K+ tokens × cache rates = expensive prefix\n  Precision: ~20K tokens × cache rates   = 80% reduction in cache cost\n```\n\n**Context window longevity:** Slower conversation growth delays context compaction. Compaction rewrites the conversation prefix, which means the remote cache no longer matches, requiring a new cache write. Precision caching keeps the remote cache hot longer, avoiding repeated cold starts.\n\n#### Layer 6: Prevention Savings\n\nStructured error handling prevents expensive failure cascades.\n\n- **3-phase fix loop**: Systematic escalation (internal → docs → community → internet) with capped attempts instead of random debugging that burns tokens.\n- **Blocker classification**: Output style classifies blockers by type (issue/error/other) with specific recovery strategies. Structured response = targeted fix = fewer wasted tokens.\n- **Atomic transactions with rollback**: Failed batch operations roll back cleanly. No partial corruption requiring manual investigation.\n\n#### Layer 7: Orchestration Savings\n\nThe output style enforces patterns that keep the entire agent tree efficient.\n\n- **Orchestrator stays lean**: \"You ARE the orchestrator. Coordination, NOT implementation.\" The main context — the most expensive one because it persists across the whole session — never bloats with file contents or grep results. All implementation happens in subagent contexts that are discarded after completion.\n- **Mandatory precision tools for all agents**: The output style and PreToolUse hook force precision tools across the entire agent tree. One rogue subagent using native `Read` in a loop would burn thousands of tokens. This prevents it.\n- **Planned execution**: \"Plan all work\" instruction means agents execute targeted operations instead of speculative exploration. Pre-meditated work = fewer wasted reads and searches.\n- **Parallel agents with background execution**: Up to 6 agents run concurrently in background. Parallel execution plus explicit instructions not to monitor agents via Task Output unless absolutely necessary (and even then to use the non-blocking version), and to wait for a Task Completion notification means fewer wasted tokens and the ability to keep conversing and planning in the main conversation context while work is done in the background.\n- **Cost analysis engine**: Built-in analytics track native vs MCP tool costs with empirical per-call pricing. Enables data-driven optimization of which tools to use and how.\n\n#### Summary\n\nThese seven layers compound: per-operation savings reduce round-trip overhead, which shrinks per-session context growth, which delays compaction, which keeps the remote cache hot, while cross-session memory prevents rediscovering solved problems, and orchestration patterns ensure the entire agent tree operates efficiently. For API users paying per token, this directly reduces cost. For Pro/Max subscribers, it means less of your weekly allocation consumed per session, allowing more work before hitting limits.\n\n### Transparent Tool Upgrade\n\nA PreToolUse hook intercepts Claude's native Read, Edit, Write, Glob, and Grep calls and redirects them to precision equivalents. The hook fires on every tool call — Claude requests `Read`, the hook blocks it and tells Claude to use `precision_read` instead. This happens for all agents including subagents.\n\nThis means the efficiency gains are automatic — Claude uses precision tools automatically. No configuration needed.\n\n### 11 Specialized Agents\n\nDomain-specific agents (engineer, reviewer, tester, architect, deployer, 3 integrators, planner, 2 factories) each bring focused expertise. Opus-powered agents handle complex work; Sonnet-powered agents handle high-volume tasks.\n\n### Persistent Memory\n\nA two-tier memory system stores decisions, patterns, failures, and preferences in `.goodvibes/memory/`. Agents read these files before acting. The PostToolUseFailure hook automatically logs failures after exhausting its 3-phase fix loop. Same bug next session? Already documented.\n\n### Quality Loops\n\nWRFC (Write-Review-Fix-Check) loops enforce a mandatory review cycle on every unit of work. No code reaches a commit without passing review.\n\n**The loop:**\n\n```\n1. WORK   →  Spawn agent to implement the task (background)\n2. REVIEW →  Spawn reviewer to check the work (background)\n3. Evaluate:\n   │  PASS → Proceed to step 5\n   │  FAIL → Enter Fix-Check cycle:\n   │         FIX   →  Spawn agent to address all issues (background)\n   │         CHECK →  Spawn reviewer to re-check (background)\n   │         Repeat until PASS (or max attempts reached)\n4. COMMIT →  Git commit the verified work\n5. LOG    →  Update .goodvibes/ memory and logs\n6. REPORT →  \"✓ [task] complete.\" then loop for next task.\n```\n\n**Key properties:**\n\n- **Per-task, not per-batch.** Each unit of work gets its own WRFC cycle. A phase with 4 tasks runs 4 independent loops.\n- **All agents run in background.** The orchestrator coordinates; it never implements. Up to 6 agents run concurrently.\n- **No issue is too minor.** Reviewers flag everything — major, minor, nitpick. All must be addressed before the loop passes.\n- **Fix-Check is iterative.** If the fix introduces new issues, the reviewer catches them. The loop continues until the reviewer returns zero issues.\n- **Failures are logged.** If max fix attempts are exhausted, the failure is recorded in `.goodvibes/memory/failures.json` with root cause and prevention guidance.\n- **Commit gates on review.** Code is only committed after the reviewer confirms zero issues. No exceptions.\n\nThe orchestrator maintains WRFC loops across concurrent tasks — when one task's reviewer returns PASS, the orchestrator commits that work and checks for newly unblocked tasks, keeping agent utilization high.\n\n### Two Execution Modes\n\nvibecoding (interactive: shows progress, explains decisions, asks on ambiguity) and justvibes (autonomous: silent execution, auto-chains tasks, logs everything).\n\n## Installation\n\n```bash\nclaude plugin marketplace add mgd34msu/goodvibes-plugin\nclaude plugin install goodvibes@goodvibes-market\n```\n\nOn first session, the SessionStart hook:\n- Detects your project stack (frameworks, languages, tools)\n- Analyzes git status (branch, uncommitted changes)\n- Checks project health (missing dependencies, build issues)\n- Creates or updates CLAUDE.md with GoodVibes instructions\n- Injects project context into Claude's system message\n\nSet your output style:\n```bash\n/output-style goodvibes:vibecoding   # Interactive mode\n/output-style goodvibes:justvibes    # Autonomous mode\n```\n\n## Precision Engine - 11 Tools\n\nThe core of GoodVibes. 11 tools that replace Claude Code's native tools with enhanced, token-efficient alternatives.\n\n### Tool Overview\n\n| Tool | Replaces | Key Enhancements |\n|------|----------|------------------|\n| precision_read | Read | Batch reads, extract modes (content/outline/symbols/ast/lines), image viewing (PNG/JPG/GIF/WebP/BMP/ICO/TIFF/AVIF/SVG as visual blocks with magic byte validation), PDF text extraction with page ranges, Jupyter notebook cells, token budgets with pagination, file state caching |\n| precision_write | Write | Batch writes, fail_if_exists/overwrite/backup modes, atomic transactions with rollback, Handlebars/EJS templates, dry run, auto directory creation, base64 content support |\n| precision_edit | Edit | Batch edits, match modes (exact/fuzzy/regex/ast_pattern with AST-Grep captures), occurrence selection (first/last/Nth/all), context hints (near_line/in_function/in_class/after/before), atomic transactions with rollback, dry run, whitespace/case sensitivity toggles |\n| precision_grep | Grep | Batch queries with parallel execution, output modes (count_only/files_only/locations/matches/context), context expansion (line/block/function/class), negation search, find-replace preview with backreference support, relevance ranking, cross-file relationship tracing, whole word matching |\n| precision_glob | Glob | Presets (typescript/javascript/styles/config/tests), size/date/content filters, output modes (count_only/paths_only/with_stats/with_preview), backend selection (fast-glob/ripgrep), symlink following |\n| precision_exec | Bash | Batch commands with parallel execution, expectation checking (exit code/stdout/stderr), retry engine (configurable backoff for transient failures), progress tracking with milestones, pattern-based termination, safe mode (blocks rm -rf, dd, etc.), background process lifecycle management |\n| precision_fetch | WebFetch | Full HTTP client: 7 methods (GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS), service registry with auto-auth, per-request auth (none/bearer/basic/api-key/custom-headers), 12 extraction modes (raw/text/json/markdown/structured/summary/code_blocks/tables/links/metadata/readable/pdf), body encoding (json/form/multipart/raw), query params, CSS selectors, response headers/cookies/redirect chains/timing, 15-min TTL cache |\n| precision_notebook | NotebookEdit | Batch operations with auto-index adjustment, cell targeting by cell_id (with metadata.id fallback), output clearing per cell, auto cell_id generation for nbformat 4.5+ |\n| discover | (unique) | Parallel multi-query: run grep + glob + symbol + structural (AST pattern) queries simultaneously, results keyed by query ID |\n| precision_symbols | (unique) | Workspace-wide or per-file symbol search, kind filtering (10 kinds), export/private filtering, signature extraction with JSDoc/docstrings, grouping by file/kind, multi-language (TypeScript, JavaScript, Python, Rust, Go) |\n| precision_config | (unique) | Runtime configuration for precision engine (get/set/reload), sandbox mode, cache tuning, execution defaults |\n\n### Batch Operations\n\nRead 10 files, edit 5 files, run 3 commands, fetch 5 URLs — each in a single tool call. Reduces round trips and context overhead.\n\n### Atomic Transactions\n\nprecision_edit and precision_write support transaction modes (atomic/partial/none). In atomic mode, if any operation fails, all changes roll back. Every edit generates a rollback ID for manual undo.\n\n### Advanced Matching\n\nprecision_edit supports 4 match modes:\n- **exact**: literal string match (default)\n- **fuzzy**: whitespace-insensitive matching\n- **regex**: full regex with capture group support ($1-$9, $$, $&, $`, $')\n- **ast_pattern**: AST-Grep structural patterns with captures ($VAR for single nodes, $$$VAR for sequences) across 18 languages (JavaScript, TypeScript, Python, Rust, Go, C, C++, Java, Kotlin, Swift, Ruby, PHP, C#, Scala, Bash, HTML, CSS, Lua)\n\n### Multi-Format Reading\n\nprecision_read handles more than text:\n- **Images** (.png, .jpg, .gif, .webp, .svg): returned as MCP ImageContent blocks — Claude sees them visually\n- **PDFs**: per-page text extraction via pdf-parse, `pages` parameter for ranges (e.g., \"1-5\"), max 20 pages per request\n- **Jupyter notebooks** (.ipynb): parsed as JSON, formatted with cell types (code/markdown) and outputs\n- **SVG files** get both text content and visual image representation\n\n### Safety\n\nprecision_exec includes a safe mode that blocks destructive commands matching patterns like `rm -rf /`, `rmdir /`, `dd if=/dev/`. Expectation checking verifies exit codes and output content after execution.\n\n### Context Expansion\n\nprecision_grep can expand matches beyond the matched line to enclosing block, function, or class scope using Tree-Sitter AST analysis.\n\n### HTTP Client & Authentication\n\nprecision_fetch operates as a full HTTP client, not just a page fetcher:\n- **Service registry**: Named API services with stored base URLs and credentials. Auto-auth resolves service name to authenticated requests without passing credentials each time\n- **Per-request auth**: 5 auth types (none, bearer, basic, api-key, custom-headers) configurable per URL\n- **Body encoding**: 4 body types (json, form, multipart, raw) with automatic content-type headers\n- **Query parameters**: Key-value params auto-appended to URLs\n- **Response inspection**: Response headers, cookies (with domain/path/expiry), redirect chains, and request timing (DNS/connect/TTFB/total)\n- **401 retry**: Automatic token refresh and retry on authentication failures\n\n## Analysis Engine - 19 Tools\n\n| Category | Tools |\n|----------|-------|\n| Detection | detect-stack, check-versions, scan-patterns, read-config, get-conventions |\n| Code Quality | find-dead-code, get-api-surface, safe-delete-check, identify-tech-debt |\n| Validation | detect-breaking-changes, semantic-diff, validate-implementation, validate-edits-preview, validate-api-contract |\n| Security | env-audit, scan-for-secrets, check-permissions |\n| Debugging | parse-error-stack, explain-type-error |\n\n## Project Engine - 22 Tools\n\n| Category | Tools |\n|----------|-------|\n| Scaffolding | scaffold-project, list-templates |\n| Status | plugin-status, project-issues |\n| API | generate-openapi, get-api-routes |\n| Database | get-database-schema, get-prisma-operations, query-database |\n| Maintenance | upgrade-package, analyze-bundle, analyze-dependencies, find-circular-deps |\n| Testing | find-tests-for-file, get-test-coverage, suggest-test-cases, generate-fixture |\n| TypeScript | generate-types, sync-api-types, explain-codebase |\n| Git | create-pull-request, resolve-merge-conflict |\n\n## Frontend Engine - 11 Tools\n\n| Tool | Purpose |\n|------|----------|\n| get-react-component-tree | Extract component hierarchy |\n| analyze-stacking-context | Debug z-index issues |\n| analyze-responsive-breakpoints | Audit responsive design |\n| trace-component-state | Trace state flow through components |\n| analyze-render-triggers | Find unnecessary re-renders |\n| analyze-layout-hierarchy | Debug layout issues |\n| diagnose-overflow | Find overflow causes |\n| get-accessibility-tree | Generate accessibility tree |\n| get-sizing-strategy | Analyze CSS sizing approach |\n| analyze-event-flow | Trace event propagation |\n| analyze-tailwind-conflicts | Find conflicting Tailwind classes |\n\n## Batch Engine - 6 Tools\n\n| Tool | Purpose |\n|------|----------|\n| batch | Execute batch operations with checkpoints |\n| batch-status | Check running batch status |\n| batch-list | List all batches |\n| batch-recover | Recover from checkpoint after failure |\n| batch-checkpoints | List available checkpoints |\n| batch-state | Query batch execution state |\n\n## Registry Engine - 7 Tools\n\n| Tool | Purpose |\n|------|----------|\n| search-skills | Search skills by query and category |\n| search-agents | Search agents by capability |\n| search-tools | Search MCP tools |\n| recommend-skills | Context-aware skill recommendations |\n| get-skill-content | Load skill content into context |\n| get-agent-content | Load agent definition |\n| skill-dependencies | Resolve skill dependency chain |\n\n## Agents\n\n11 specialized agents with distinct expertise. The orchestrator spawns them for focused tasks — each consults memory, applies relevant skills, and returns results.\n\n| Agent | Model | Specialization |\n|-------|-------|----------------|\n| engineer | Opus | Full-stack: APIs, databases, auth, components, routing, styling |\n| reviewer | Opus | Code quality, security, type safety, WRFC loop execution |\n| tester | Sonnet | Test generation, coverage analysis, fixture creation, 100% coverage goal |\n| architect | Opus | System design, architecture decisions, dependency mapping |\n| deployer | Sonnet | CI/CD, Docker, cloud deployment (Vercel, AWS, Railway, Fly.io) |\n| integrator-ai | Opus | AI/LLM integrations (OpenAI, Anthropic, Vercel AI SDK, RAG, embeddings) |\n| integrator-services | Sonnet | Payments (Stripe), email (Resend), CMS (Sanity, Contentful), uploads (S3, Cloudinary) |\n| integrator-state | Sonnet | State management (Zustand, Redux, Jotai, TanStack Query), forms, real-time |\n| planner | Opus | Task breakdown, batch planning, workflow orchestration |\n| agent-factory | Opus | Create new specialized agents |\n| skill-factory | Opus | Create new skills and slash commands |\n\n## Skills - 173 Total\n\n| Category | Count | Coverage |\n|----------|-------|----------|\n| Common | 29 | Development, quality, review, tooling, workflow |\n| WebDev | 138 | 20+ subcategories covering modern web stack |\n| Creation | 5 | Agent SDK, hooks, scripts, workflow patterns |\n| Special | 1 | goodvibes-codebase-review (full audit with parallel remediation) |\n\n### WebDev Breakdown (Selected Subcategories)\n\n- **API Layer** (8): tRPC, GraphQL, REST, Express, Fastify, Hono, Apollo, OpenAPI\n- **Authentication** (7): Clerk, NextAuth, Lucia, Auth0, Firebase Auth, Supabase Auth, Passport\n- **Databases & ORMs** (10): Prisma, Drizzle, Kysely, PostgreSQL, MongoDB, Redis, Supabase, PlanetScale, Turso, SQLite\n- **Frontend Core** (10): React, Vue, Svelte, TypeScript, SolidJS, Preact, htmx, Alpine.js, Web Components\n- **Meta Frameworks** (8): Next.js, Remix, Nuxt, Astro, SvelteKit, Qwik, SolidStart, Gatsby\n- **State Management** (7): Zustand, Jotai, Redux Toolkit, TanStack Query, Valtio, Nanostores, Pinia\n- **Styling** (8): Tailwind, Styled Components, CSS Modules, Sass, Panda CSS, Vanilla Extract, UnoCSS\n- **Testing** (8): Vitest, Playwright, Jest, Testing Library, Cypress, Storybook, MSW, Chromatic\n- **Plus 50+ specialized skills**: Stripe, Resend, Sentry, Socket.IO, MDX, Framer Motion, and more\n\n## Hooks - 10 Types\n\nLifecycle hooks run transparently on every session. They're the mechanism behind tool redirection, context injection, and automatic error recovery.\n\n| Hook | Trigger | What It Does |\n|------|---------|-------------|\n| PreToolUse (Bash) | Before Bash execution | Platform path mapping (Windows/Linux), shell safety analysis, git commit quality gates |\n| PreToolUse (Native) | Before Read/Edit/Write/Glob/Grep | Blocks native tool, redirects to precision-engine equivalent |\n| PostToolUseFailure | After Bash failure | 3-phase progressive fix loop: Phase 1 (internal knowledge) -> Phase 2 (official docs hints) -> Phase 3 (community docs hints). Logs failures to `.goodvibes/memory/failures.json` after all phases exhausted |\n| SessionStart | Session begins | Detects project stack, analyzes git status, checks project health, creates/updates CLAUDE.md, injects context into system message |\n| SessionEnd | Session ends | Persists session state |\n| SubagentStart | Agent spawns | Injects context for GoodVibes agents (stack info, git branch, project name), tracks agent telemetry |\n| SubagentStop | Agent completes | Cleans up agent tracking, updates analytics |\n| PreCompact | Before context compaction | Creates checkpoint commit if uncommitted changes exist, generates session summary, backs up analytics |\n| Stop | Stop button pressed | Saves current state |\n| Notification | External event | Processes notifications |\n| UserPromptSubmit | User sends message | Processes user input |\n\n## Output Styles\n\nTwo execution modes for different workflows. Set via `/output-style goodvibes:vibecoding` or `/output-style goodvibes:justvibes`.\n\n| Setting | vibecoding | justvibes |\n|---------|-----------|------------|\n| Description | Autonomous coding with communication | Fully autonomous silent execution |\n| show_progress | true | false |\n| explain_decisions | true | false |\n| ask_on_ambiguity | true | false |\n| auto_chain | false | true |\n| max_autonomous_batches | 1 | unlimited |\n| checkpoint_frequency | per_batch | per_phase |\n| parallel_agents | 6 | 6 |\n| recovery (issues/errors) | ask_user_with_options | fix_review_loop |\n| recovery (other) | ask_user | choose_best_option_silent |\n| max_fix_attempts | 3 | 3 |\n| fix_attempt strategy | one_shot (all sources at once) | cumulative (staged escalation) |\n| default output mode | standard | minimal |\n| show_diffs | true | false |\n| show_telemetry | summary | none |\n| log_activity | false | true |\n\n## Memory System\n\nTwo-tier persistent memory. Session logs track the current session. Cross-session memory persists across conversations.\n\n### Session Logs (`.goodvibes/logs/`)\n\n- `decisions.md` — Architectural choices with options considered, rationale, implications\n- `errors.md` — Failures categorized by type (TOOL_FAILURE, BUILD_ERROR, TEST_FAILURE, etc.) with root cause and resolution\n- `activity.md` — Completed work that passed review (primarily used in justvibes mode)\n\n### Cross-Session Memory (`.goodvibes/memory/`)\n\n- `decisions.json` — Decision records with category, scope, confidence (max 1000 entries, auto-prunes oldest)\n- `patterns.json` — Proven approaches with example files and keywords (max 500)\n- `failures.json` — Failed approaches with root cause and prevention guidance (max 500)\n- `preferences.json` — User conventions (code style, naming, patterns)\n\nAgents read memory before acting. The PostToolUseFailure hook automatically records failures after its 3-phase fix loop is exhausted.\n\n## Templates\n\n| Template | Stack | Use Case |\n|----------|-------|----------|\n| next-saas | Next.js 15, NextAuth, Prisma, Stripe, shadcn/ui, Tailwind, Resend, Sentry | Full SaaS starter |\n| next-app | Next.js 15, TypeScript, Tailwind, ESLint | Minimal App Router starter |\n| vite-react | Vite, React, TypeScript, Tailwind | Client-side React app |\n\n## Configuration\n\nGoodVibes works out of the box. Minimal configuration needed.\n\n### Path Sandboxing\n\nControls whether precision tools can access files outside the project root. Disabled by default.\n\n```bash\n/goodvibes:sandbox true    # Enable (restrict to project root)\n/goodvibes:sandbox false   # Disable (allow external paths, default)\n```\n\n### Output Style\n\nSwitch execution modes:\n\n```bash\n/output-style goodvibes:vibecoding\n/output-style goodvibes:justvibes\n```\n\n## Slash Commands\n\n| Command | Purpose |\n|---------|----------|\n| `/goodvibes:sandbox` | Toggle path sandboxing (true/false) |\n| `/goodvibes:plugin` | Plugin management (update, status, config) |\n| `/goodvibes:search` | Search skills, agents, or tools |\n| `/goodvibes:load-skill` | Load a skill's content into context |\n| `/goodvibes:codebase-review` | Full codebase audit with parallel agent remediation |\n\n## License\n\nMIT License - see [LICENSE](LICENSE) for details.\n\n---\n\n<p align=\"center\">\n  <b>Plug in, receive good vibes</b>\n  <br><br>\n  <code>claude plugin marketplace add mgd34msu/goodvibes-plugin</code>\n  <br>\n  <code>claude plugin install goodvibes@goodvibes-market</code>\n</p>",
        "plugins/goodvibes/README.md": "# GoodVibes Plugin\n\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![Version](https://img.shields.io/badge/version-1.1.11-blue.svg)](https://github.com/mgd34msu/goodvibes-plugin)\n[![Claude Code Plugin](https://img.shields.io/badge/Claude%20Code-Plugin-purple.svg)](https://claude.com/claude-code)\n\n> Plug in. Receive good vibes.\n\nA Claude Code plugin that replaces native tools with token-efficient precision equivalents, adds 75 MCP tools across 6 engines, and orchestrates 11 specialized agents with persistent cross-session memory.\n\n## At a Glance\n\n| Component | Count | What You Get |\n|-----------|-------|-------------|\n| Agents | 11 | Specialized roles (Opus/Sonnet) for engineering, review, testing, architecture, deployment, integration, planning |\n| Skills | 173 | Technology-specific knowledge modules covering modern web stacks |\n| MCP Tools | 75 | Token-efficient tools across 6 specialized engines |\n| Hooks | 10 | Lifecycle automation (tool redirection, context injection, error recovery) |\n| Output Styles | 2 | Interactive (vibecoding) or fully autonomous (justvibes) |\n| Templates | 3 | Production scaffolds for Next.js and React |\n\n## Why GoodVibes?\n\n### Token Efficiency\n\nNative Claude Code tools are all-or-nothing. `Read` returns the entire file. `Grep` returns every match with full context. There's no way to say \"just give me the count\" or \"just give me the file paths.\" Every operation consumes the maximum amount of tokens whether you need that information or not.\n\nPrecision tools fix this. Every tool lets the AI request exactly the amount of information needed to fulfill a task:\n\n- **Need a file count?** `precision_glob` with `count_only` returns just the number — not hundreds of file paths\n- **Need file paths?** `paths_only` returns paths without file contents or metadata\n- **Need a function signature?** `precision_read` with `symbols` extract mode returns signatures without reading the entire file\n- **Need specific lines?** Read a range instead of the whole document\n- **Need to check if a pattern exists?** `precision_grep` with `count_only` tells you how many matches without returning any content\n\nThis adds up fast. A `count_only` operation averages ~95% fewer tokens than its verbose equivalent. For API users paying per token, that's direct cost savings. For Pro/Max users, it means fewer tokens consuming less of their allotted weekly usage.\n\nBatch operations compound the savings further: `precision_read` can read 10 or more files in one call instead of 10+ separate `Read` calls. `discover` runs grep + glob + symbol queries in parallel, returning all results in a single response. `precision_edit` applies multiple edits across multiple files atomically.\n\n### Transparent Tool Upgrade\n\nA PreToolUse hook intercepts Claude's native Read, Edit, Write, Glob, and Grep calls and redirects them to precision equivalents. The hook fires on every tool call — Claude requests `Read`, the hook blocks it and tells Claude to use `precision_read` instead. This happens for all agents including subagents.\n\n### 11 Specialized Agents\n\nDomain-specific agents (engineer, reviewer, tester, architect, deployer, 3 integrators, planner, 2 factories) each bring focused expertise. Opus-powered agents handle complex work; Sonnet-powered agents handle high-volume tasks.\n\n### Persistent Memory\n\nA two-tier memory system stores decisions, patterns, failures, and preferences in `.goodvibes/memory/`. Agents read these files before acting. The PostToolUseFailure hook automatically logs failures after exhausting its 3-phase fix loop. Same bug next session? Already documented.\n\n### Quality Loops\n\nWRFC (Write-Review-Fix-Check) loops ensure code is reviewed before commit. The orchestrator spawns a reviewer after implementation, fixes issues, and re-reviews until verified, then creates a commit.\n\n### Two Execution Modes\n\nvibecoding (interactive: shows progress, explains decisions, asks on ambiguity) and justvibes (autonomous: silent execution, auto-chains tasks, logs everything).\n\n## Installation\n\n```bash\nclaude plugin marketplace add mgd34msu/goodvibes-plugin\nclaude plugin install goodvibes@goodvibes-market\n```\n\nOn first session, the SessionStart hook:\n- Detects your project stack (frameworks, languages, tools)\n- Analyzes git status (branch, uncommitted changes)\n- Checks project health (missing dependencies, build issues)\n- Creates or updates CLAUDE.md with GoodVibes instructions\n- Injects project context into Claude's system message\n\nSet your output style:\n```bash\n/output-style goodvibes:vibecoding   # Interactive mode\n/output-style goodvibes:justvibes    # Autonomous mode\n```\n\n## Precision Engine - 10 Tools\n\nThe core of GoodVibes. 10 tools that replace Claude Code's native tools with enhanced, token-efficient alternatives.\n\n### Tool Overview\n\n| Tool | Replaces | Key Enhancements |\n|------|----------|------------------|\n| precision_read | Read | Batch reads, extract modes (content/outline/symbols/ast/lines), image viewing (PNG/JPG/GIF/WebP/SVG as visual blocks), PDF text extraction with page ranges, Jupyter notebook cells |\n| precision_write | Write | Batch writes, fail_if_exists/overwrite/backup modes, atomic transactions with rollback, Handlebars/EJS templates, dry run |\n| precision_edit | Edit | Batch edits, match modes (exact/fuzzy/regex/AST/AST-Grep), occurrence selection, context hints (near_line/in_function/in_class), atomic transactions with rollback, dry run |\n| precision_grep | Grep | Batch queries with parallel execution, output modes (count_only/files_only/locations/matches/context), context expansion (line/block/function/class), whole word matching |\n| precision_glob | Glob | Presets (typescript/javascript/styles/config/tests), size/date/content filters, output modes (count_only/paths_only/with_stats/with_preview), backend selection (fast-glob/ripgrep) |\n| precision_exec | Bash | Batch commands with parallel execution, expectation checking (exit code/stdout/stderr), safe mode (blocks rm -rf, dd, etc.), timeout per command |\n| precision_fetch | WebFetch | Batch fetching, extract modes (raw/text/json/markdown/structured/summary), CSS selector extraction, 15-min TTL cache, HTTP method support |\n| discover | (unique) | Parallel multi-query: run grep + glob + symbol + structural queries simultaneously, results keyed by query ID |\n| precision_symbols | (unique) | Workspace-wide or per-file symbol search, kind filtering, export filtering, signature extraction, grouping by file/kind |\n| precision_config | (unique) | Runtime configuration for precision engine (get/set/reload) |\n\n### Batch Operations\n\nRead 10 files, edit 5 files, run 3 commands — each in a single tool call. Reduces round trips and context overhead.\n\n### Atomic Transactions\n\nprecision_edit and precision_write support transaction modes (atomic/partial/none). In atomic mode, if any operation fails, all changes roll back. Every edit generates a rollback ID for manual undo.\n\n### Advanced Matching\n\nprecision_edit supports 5 match modes:\n- **exact**: literal string match (default)\n- **fuzzy**: Levenshtein distance-based with configurable similarity threshold (default 70%)\n- **regex**: full regex with multiline support\n- **ast**: AST structure matching for JavaScript and TypeScript (.js, .jsx, .ts, .tsx)\n- **ast_pattern**: AST-Grep structural patterns across 18 languages (JavaScript, TypeScript, Python, Rust, Go, C, C++, Java, Kotlin, Swift, Ruby, PHP, C#, Scala, Bash, HTML, CSS)\n\n### Multi-Format Reading\n\nprecision_read handles more than text:\n- **Images** (.png, .jpg, .gif, .webp, .svg): returned as MCP ImageContent blocks — Claude sees them visually\n- **PDFs**: per-page text extraction via pdf-parse, `pages` parameter for ranges (e.g., \"1-5\"), max 20 pages per request\n- **Jupyter notebooks** (.ipynb): parsed as JSON, formatted with cell types (code/markdown) and outputs\n- **SVG files** get both text content and visual image representation\n\n### Safety\n\nprecision_exec includes a safe mode that blocks destructive commands matching patterns like `rm -rf /`, `rmdir /`, `dd if=/dev/`. Expectation checking verifies exit codes and output content after execution.\n\n### Context Expansion\n\nprecision_grep can expand matches beyond the matched line to enclosing block, function, or class scope using Tree-Sitter AST analysis.\n\n## Analysis Engine - 19 Tools\n\n| Category | Tools |\n|----------|-------|\n| Detection | detect-stack, check-versions, scan-patterns, read-config, get-conventions |\n| Code Quality | find-dead-code, get-api-surface, safe-delete-check, identify-tech-debt |\n| Validation | detect-breaking-changes, semantic-diff, validate-implementation, validate-edits-preview, validate-api-contract |\n| Security | env-audit, scan-for-secrets, check-permissions |\n| Debugging | parse-error-stack, explain-type-error |\n\n## Project Engine - 22 Tools\n\n| Category | Tools |\n|----------|-------|\n| Scaffolding | scaffold-project, list-templates |\n| Status | plugin-status, project-issues |\n| API | generate-openapi, get-api-routes |\n| Database | get-database-schema, get-prisma-operations, query-database |\n| Maintenance | upgrade-package, analyze-bundle, analyze-dependencies, find-circular-deps |\n| Testing | find-tests-for-file, get-test-coverage, suggest-test-cases, generate-fixture |\n| TypeScript | generate-types, sync-api-types, explain-codebase |\n| Git | create-pull-request, resolve-merge-conflict |\n\n## Frontend Engine - 11 Tools\n\n| Tool | Purpose |\n|------|----------|\n| get-react-component-tree | Extract component hierarchy |\n| analyze-stacking-context | Debug z-index issues |\n| analyze-responsive-breakpoints | Audit responsive design |\n| trace-component-state | Trace state flow through components |\n| analyze-render-triggers | Find unnecessary re-renders |\n| analyze-layout-hierarchy | Debug layout issues |\n| diagnose-overflow | Find overflow causes |\n| get-accessibility-tree | Generate accessibility tree |\n| get-sizing-strategy | Analyze CSS sizing approach |\n| analyze-event-flow | Trace event propagation |\n| analyze-tailwind-conflicts | Find conflicting Tailwind classes |\n\n## Batch Engine - 6 Tools\n\n| Tool | Purpose |\n|------|----------|\n| batch | Execute batch operations with checkpoints |\n| batch-status | Check running batch status |\n| batch-list | List all batches |\n| batch-recover | Recover from checkpoint after failure |\n| batch-checkpoints | List available checkpoints |\n| batch-state | Query batch execution state |\n\n## Registry Engine - 7 Tools\n\n| Tool | Purpose |\n|------|----------|\n| search-skills | Search skills by query and category |\n| search-agents | Search agents by capability |\n| search-tools | Search MCP tools |\n| recommend-skills | Context-aware skill recommendations |\n| get-skill-content | Load skill content into context |\n| get-agent-content | Load agent definition |\n| skill-dependencies | Resolve skill dependency chain |\n\n## Agents\n\n11 specialized agents with distinct expertise. The orchestrator spawns them for focused tasks — each consults memory, applies relevant skills, and returns results.\n\n| Agent | Model | Specialization |\n|-------|-------|----------------|\n| engineer | Opus | Full-stack: APIs, databases, auth, components, routing, styling |\n| reviewer | Opus | Code quality, security, type safety, WRFC loop execution |\n| tester | Sonnet | Test generation, coverage analysis, fixture creation, 100% coverage goal |\n| architect | Opus | System design, architecture decisions, dependency mapping |\n| deployer | Sonnet | CI/CD, Docker, cloud deployment (Vercel, AWS, Railway, Fly.io) |\n| integrator-ai | Opus | AI/LLM integrations (OpenAI, Anthropic, Vercel AI SDK, RAG, embeddings) |\n| integrator-services | Sonnet | Payments (Stripe), email (Resend), CMS (Sanity, Contentful), uploads (S3, Cloudinary) |\n| integrator-state | Sonnet | State management (Zustand, Redux, Jotai, TanStack Query), forms, real-time |\n| planner | Opus | Task breakdown, batch planning, workflow orchestration |\n| agent-factory | Opus | Create new specialized agents |\n| skill-factory | Opus | Create new skills and slash commands |\n\n## Skills - 173 Total\n\n| Category | Count | Coverage |\n|----------|-------|----------|\n| Common | 29 | Development, quality, review, tooling, workflow |\n| WebDev | 138 | 20+ subcategories covering modern web stack |\n| Creation | 5 | Agent SDK, hooks, scripts, workflow patterns |\n| Special | 1 | goodvibes-codebase-review (full audit with parallel remediation) |\n\n### WebDev Breakdown (Selected Subcategories)\n\n- **API Layer** (8): tRPC, GraphQL, REST, Express, Fastify, Hono, Apollo, OpenAPI\n- **Authentication** (7): Clerk, NextAuth, Lucia, Auth0, Firebase Auth, Supabase Auth, Passport\n- **Databases & ORMs** (10): Prisma, Drizzle, Kysely, PostgreSQL, MongoDB, Redis, Supabase, PlanetScale, Turso, SQLite\n- **Frontend Core** (10): React, Vue, Svelte, TypeScript, SolidJS, Preact, htmx, Alpine.js, Web Components\n- **Meta Frameworks** (8): Next.js, Remix, Nuxt, Astro, SvelteKit, Qwik, SolidStart, Gatsby\n- **State Management** (7): Zustand, Jotai, Redux Toolkit, TanStack Query, Valtio, Nanostores, Pinia\n- **Styling** (8): Tailwind, Styled Components, CSS Modules, Sass, Panda CSS, Vanilla Extract, UnoCSS\n- **Testing** (8): Vitest, Playwright, Jest, Testing Library, Cypress, Storybook, MSW, Chromatic\n- **Plus 50+ specialized skills**: Stripe, Resend, Sentry, Socket.IO, MDX, Framer Motion, and more\n\n## Hooks - 10 Types\n\nLifecycle hooks run transparently on every session. They're the mechanism behind tool redirection, context injection, and automatic error recovery.\n\n| Hook | Trigger | What It Does |\n|------|---------|-------------|\n| PreToolUse (Bash) | Before Bash execution | Platform path mapping (Windows/Linux), shell safety analysis, git commit quality gates |\n| PreToolUse (Native) | Before Read/Edit/Write/Glob/Grep | Blocks native tool, redirects to precision-engine equivalent |\n| PostToolUseFailure | After Bash failure | 3-phase progressive fix loop: Phase 1 (internal knowledge) -> Phase 2 (official docs hints) -> Phase 3 (community docs hints). Logs failures to `.goodvibes/memory/failures.json` after all phases exhausted |\n| SessionStart | Session begins | Detects project stack, analyzes git status, checks project health, creates/updates CLAUDE.md, injects context into system message |\n| SessionEnd | Session ends | Persists session state |\n| SubagentStart | Agent spawns | Injects context for GoodVibes agents (stack info, git branch, project name), tracks agent telemetry |\n| SubagentStop | Agent completes | Cleans up agent tracking, updates analytics |\n| PreCompact | Before context compaction | Creates checkpoint commit if uncommitted changes exist, generates session summary, backs up analytics |\n| Stop | Stop button pressed | Saves current state |\n| Notification | External event | Processes notifications |\n| UserPromptSubmit | User sends message | Processes user input |\n\n## Output Styles\n\nTwo execution modes for different workflows. Set via `/output-style goodvibes:vibecoding` or `/output-style goodvibes:justvibes`.\n\n| Setting | vibecoding | justvibes |\n|---------|-----------|------------|\n| Description | Autonomous coding with communication | Fully autonomous silent execution |\n| show_progress | true | false |\n| explain_decisions | true | false |\n| ask_on_ambiguity | true | false |\n| auto_chain | false | true |\n| max_autonomous_batches | 1 | unlimited |\n| checkpoint_frequency | per_batch | per_phase |\n| parallel_agents | 6 | 6 |\n| recovery (issues/errors) | ask_user_with_options | fix_review_loop |\n| recovery (other) | ask_user | choose_best_option_silent |\n| max_fix_attempts | 3 | 3 |\n| fix_attempt strategy | one_shot (all sources at once) | cumulative (staged escalation) |\n| default output mode | standard | minimal |\n| show_diffs | true | false |\n| show_telemetry | summary | none |\n| log_activity | false | true |\n\n## Memory System\n\nTwo-tier persistent memory. Session logs track the current session. Cross-session memory persists across conversations.\n\n### Session Logs (`.goodvibes/logs/`)\n\n- `decisions.md` — Architectural choices with options considered, rationale, implications\n- `errors.md` — Failures categorized by type (TOOL_FAILURE, BUILD_ERROR, TEST_FAILURE, etc.) with root cause and resolution\n- `activity.md` — Completed work that passed review (primarily used in justvibes mode)\n\n### Cross-Session Memory (`.goodvibes/memory/`)\n\n- `decisions.json` — Decision records with category, scope, confidence (max 1000 entries, auto-prunes oldest)\n- `patterns.json` — Proven approaches with example files and keywords (max 500)\n- `failures.json` — Failed approaches with root cause and prevention guidance (max 500)\n- `preferences.json` — User conventions (code style, naming, patterns)\n\nAgents read memory before acting. The PostToolUseFailure hook automatically records failures after its 3-phase fix loop is exhausted.\n\n## Templates\n\n| Template | Stack | Use Case |\n|----------|-------|----------|\n| next-saas | Next.js 15, NextAuth, Prisma, Stripe, shadcn/ui, Tailwind, Resend, Sentry | Full SaaS starter |\n| next-app | Next.js 15, TypeScript, Tailwind, ESLint | Minimal App Router starter |\n| vite-react | Vite, React, TypeScript, Tailwind | Client-side React app |\n\n## Configuration\n\nGoodVibes works out of the box. Minimal configuration needed.\n\n### Path Sandboxing\n\nControls whether precision tools can access files outside the project root. Disabled by default.\n\n```bash\n/goodvibes:sandbox true    # Enable (restrict to project root)\n/goodvibes:sandbox false   # Disable (allow external paths, default)\n```\n\n### Output Style\n\nSwitch execution modes:\n\n```bash\n/output-style goodvibes:vibecoding\n/output-style goodvibes:justvibes\n```\n\n## Slash Commands\n\n| Command | Purpose |\n|---------|----------|\n| `/goodvibes:sandbox` | Toggle path sandboxing (true/false) |\n| `/goodvibes:plugin` | Plugin management (update, status, config) |\n| `/goodvibes:search` | Search skills, agents, or tools |\n| `/goodvibes:load-skill` | Load a skill's content into context |\n| `/goodvibes:codebase-review` | Full codebase audit with parallel agent remediation |\n\n## License\n\nMIT License - see [LICENSE](LICENSE) for details.\n\n---\n\n<p align=\"center\">\n  <b>Plug in, receive good vibes</b>\n  <br><br>\n  <code>claude plugin marketplace add mgd34msu/goodvibes-plugin</code>\n  <br>\n  <code>claude plugin install goodvibes@goodvibes-market</code>\n</p>\n"
      },
      "plugins": [
        {
          "name": "goodvibes",
          "source": "./plugins/goodvibes",
          "description": "Comprehensive Claude Code plugin with agents, skills, tools, hooks, and MCP servers for full-stack development.",
          "version": "1.0.0",
          "author": {
            "name": "Mike Davis"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add mgd34msu/goodvibes-plugin",
            "/plugin install goodvibes@goodvibes-market"
          ]
        }
      ]
    }
  ]
}