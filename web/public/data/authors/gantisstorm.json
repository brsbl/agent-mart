{
  "author": {
    "id": "GantisStorm",
    "display_name": "GantisStorm",
    "avatar_url": "https://avatars.githubusercontent.com/u/246917469?u=12d956231e04a0d20a33d7cc07333e13628a5e91&v=4"
  },
  "marketplaces": [
    {
      "name": "essentials-claude-code",
      "version": "3.43.0",
      "description": "Loops, swarms, and teams powered by Claude Code's built-in Task System. Plans define exit criteria. Executors run until tests pass. Done means actually done.",
      "repo_full_name": "GantisStorm/essentials-claude-code",
      "repo_url": "https://github.com/GantisStorm/essentials-claude-code",
      "repo_description": "All-in-one workflow plugin—loops, swarms, and teams on Claude Code's Task System. All enforce exit criteria—swarm is   faster with parallel queue execution, teams add contract-first coordination. Plan your way, execute your way. Optional:    Beads for persistent memory, Ralph TUI for dashboard.",
      "signals": {
        "stars": 71,
        "forks": 7,
        "pushed_at": "2026-02-15T22:10:23Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"essentials-claude-code\",\n  \"version\": \"3.43.0\",\n  \"description\": \"Loops, swarms, and teams powered by Claude Code's built-in Task System. Plans define exit criteria. Executors run until tests pass. Done means actually done.\",\n  \"author\": \"GantisStorm\",\n  \"owner\": {\n    \"name\": \"GantisStorm\"\n  },\n  \"homepage\": \"https://github.com/GantisStorm/essentials-claude-code\",\n  \"plugins\": [\n    {\n      \"name\": \"essentials\",\n      \"version\": \"3.43.0\",\n      \"description\": \"24 commands, 8 agents. Loops, swarms, and teams powered by Claude Code's built-in Task System. Native task dependencies, ctrl+t progress, automatic persistence.\",\n      \"source\": \"./essentials\"\n    }\n  ]\n}\n",
        "README.md": "<div align=\"center\">\n\n<img src=\"logo.png\" alt=\"Essentials for Claude Code\" width=\"450\"/>\n\n# Essentials for Claude Code\n\n[![Unlicense](https://img.shields.io/badge/license-Unlicense-blue.svg)](https://unlicense.org/)\n[![Claude Code](https://img.shields.io/badge/Built%20for-Claude%20Code-blueviolet)](https://claude.ai/code)\n[![PRs Welcome](https://img.shields.io/badge/PRs-welcome-brightgreen.svg)](http://makeapullrequest.com)\n\n**Loops, swarms, and teams powered by Claude Code's built-in Task System.**\n\nLoop, swarm, and team are three execution modes. Loop runs sequentially. Swarm runs parallel subagents. Team spawns full Claude Code instances with shared contracts via [Agent Teams](https://www.anthropic.com/news/claude-opus-4-6). All use Claude's native task dependencies, `ctrl+t` progress, and automatic persistence.\n\nPlans define exit criteria. Loops run until tests pass. Done means actually done.\n\n</div>\n\n---\n\n## The Problem\n\n```\nYou: \"Add authentication\"\nAI:  *writes code* \"Done!\"\nYou: *runs tests* — 3 failing\nYou: \"Fix these\"\nAI:  \"Fixed!\"\nYou: *runs tests* — still failing\n     [repeat until you give up]\n```\n\n## The Solution\n\n```\n# Option A: Discuss in chat, then execute from context\nYou: \"I need to fix this auth bug...\" [back and forth discussion]\nYou: /implement-loop fix the auth bug we discussed\nAI:  *implements, tests fail, fixes, tests fail, fixes...*\nAI:  \"Exit criteria passed\" ✓\n\n# Option B: Create plan first, then execute\nYou: /plan-creator Add authentication\nYou: /plan-loop .claude/plans/auth-plan.md       # Sequential\nYou: /plan-swarm .claude/plans/auth-plan.md      # Parallel subagents\nYou: /plan-team .claude/plans/auth-plan.md       # Agent Teams with contracts\nAI:  \"Exit criteria passed\" ✓\n```\n\n---\n\n## Quick Start\n\n```bash\n# Install\n/plugin marketplace add GantisStorm/essentials-claude-code\n/plugin install essentials@essentials-claude-code\nmkdir -p .claude/plans .claude/prompts .claude/prd\n\n# Option A: From conversation (after discussing a bug/feature)\n/implement-loop fix the auth bug we discussed    # Sequential\n/implement-swarm refactor the API handlers       # Parallel subagents\n/implement-team build the full-stack feature     # Agent Teams with contracts\n\n# Option B: With plan file\n/plan-creator Add user authentication with JWT\n/plan-loop .claude/plans/user-auth-3k7f2-plan.md   # Sequential\n/plan-swarm .claude/plans/user-auth-3k7f2-plan.md  # Parallel subagents\n/plan-team .claude/plans/user-auth-3k7f2-plan.md   # Agent Teams with contracts\n\n# Visual progress\nctrl+t   # Toggle task tree view\n```\n\n**Zero external dependencies.** All three modes enforce exit criteria. Swarm defaults to 3 concurrent workers. Team requires tmux and `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`.\n\n---\n\n## Powered by Claude Code's Task System\n\nOur loop, swarm, and team commands use Claude Code's **built-in Task Management System** (v2.1.19+).\n\n> **Ralph TUI and Beads integrate seamlessly.** Use [Ralph TUI](https://github.com/subsy/ralph-tui) for dashboard visualization. Use [Beads](https://github.com/steveyegge/beads) for persistent task tracking across sessions.\n\n### What We Used Before\n\nThe community built Ralph Wiggum loops with workarounds:\n\n- **Stop hooks**: Shell scripts (`.sh` files) that ran after each Claude response, grepping output for keywords like \"complete\" or \"done\" to decide whether to continue the loop\n- **External plan files**: Markdown files tracking task state since Claude had no built-in persistence\n- **TodoWrite**: Flat task lists with no dependency ordering — tasks could run out of order\n- **Fresh sessions**: Starting new conversations to fight context rot, manually re-establishing state each time\n\n### What We Use Now\n\nClaude Code v2.1.19+ provides native tools that replace all of this:\n\n| Old Workaround | Native Replacement | Why It's Better |\n|----------------|-------------------|-----------------|\n| Stop hooks (shell scripts) | `TaskUpdate({ status: \"completed\" })` | No external scripts, status is structured data |\n| External plan.md for state | `~/.claude/tasks/` storage | Survives context compaction automatically |\n| TodoWrite flat lists | `TaskUpdate({ addBlockedBy: [...] })` | Dependencies enforced — tasks can't run out of order |\n| Manual session coordination | `CLAUDE_CODE_TASK_LIST_ID` env var | Same task list across sessions |\n| Single agent | `TaskList` + parallel workers | Multiple agents coordinate via shared state |\n\n**The core loop is unchanged:** Plan → Implement → Verify → Loop if fail → Done when pass.\n\n### What Tasks Do Well\n\n- **Dependency management**: Task #3 blocked by #1 and #2 literally cannot start until both complete\n- **Visual progress**: Press `ctrl+t` to see live task tree with status\n- **Parallel coordination**: Multiple workers share one task list, no conflicts\n- **Persistence**: Survives context compaction, stored in `~/.claude/tasks/`\n\n### What Tasks Don't Do\n\n`TaskList` shows ID, subject, status, and blockedBy — **but NOT description**. To see implementation details, you must call `TaskGet` for each task individually.\n\n**This is why we still use plan files.** Tasks track status. Plans hold implementation details.\n\n```\nPlan file (.claude/plans/)     →  Full implementation code (50-200+ lines per task)\nTask System (~/.claude/tasks/) →  Status tracking, dependencies, parallel coordination\n```\n\n### The Four Core Tools\n\n| Tool | Purpose |\n|------|---------|\n| `TaskCreate` | Create task with subject, description, activeForm |\n| `TaskUpdate` | Change status, set owner, add `blockedBy` dependencies |\n| `TaskGet` | Get full details of ONE task (including description) |\n| `TaskList` | See ALL tasks (but only subject, status, blockedBy) |\n\n### How Dependencies Work\n\nDependencies flow through the entire pipeline:\n\n```\nPlan Creator                    Converter                      Executor\n┌──────────────┐    ┌─────────────────────────┐    ┌──────────────────────┐\n│ Dependency   │ →  │ dependsOn (prd.json)    │ →  │ addBlockedBy (task   │\n│ Graph        │    │ depends_on (beads)      │    │ primitive)           │\n│              │    │                         │    │                      │\n│ Phase 1: A,B │    │ US-003: [\"US-001\",\"002\"]│    │ taskId \"3\":          │\n│ Phase 2: C   │    │                         │    │  blockedBy: [\"1\",\"2\"]│\n└──────────────┘    └─────────────────────────┘    └──────────────────────┘\n```\n\nPlan creators write a `## Dependency Graph` table. Converters read it to build `dependsOn` (prd.json) or `depends_on` (beads). Loop/swarm commands translate those to `addBlockedBy` using an ID map.\n\n**Task lifecycle**: `pending` → (blocked until deps complete) → `in_progress` → `completed`\n\nA task with non-empty `blockedBy` shows as **blocked** in `ctrl+t`. When a blocking task is marked `completed`, it's automatically removed from the blocked list. A task becomes **ready** (executable) when its `blockedBy` list is empty.\n\n```\nTaskCreate({ subject: \"Set up database\" })           // → task \"1\"\nTaskCreate({ subject: \"Create auth middleware\" })     // → task \"2\"\nTaskUpdate({ taskId: \"2\", addBlockedBy: [\"1\"] })      // #2 waits for #1\n```\n\nTask #2 **cannot start** until #1 completes. The system enforces this.\n\n### Visual Progress (`ctrl+t`)\n\n```\nTasks (2 done, 1 in progress, 3 open)\n✓ #1 Set up database schema\n■ #2 Create auth middleware (Worker-1)\n□ #3 Add login routes > blocked by #2\n□ #4 Write tests > blocked by #3\n```\n\n### Queue-Based Swarm Coordination\n\nMain agent controls a queue of background agents:\n\n```\nMain:    Mark #1-3 in_progress → Spawn Agent-1, Agent-2, Agent-3\n         ↓\nMain:    Stop and wait — background agents notify on completion\n         ↓\nAgent-1: Completes Task #1 → notifies main → exits\n         ↓\nMain:    Woken → Mark #1 completed → TaskList → #4 unblocked → Mark #4 in_progress → Spawn Agent-4\n         ↓\nMain:    Stop and wait — next notification\n         ... repeat until all tasks complete ...\n```\n\nEach agent does ONE task then exits. No racing. No stuck loops.\nMain agent marks tasks in_progress on spawn, completed on return, and refills queue as slots open.\n\n### Multi-Session Persistence\n\nTasks persist across sessions with `CLAUDE_CODE_TASK_LIST_ID`:\n\n```bash\n# Per terminal session\nCLAUDE_CODE_TASK_LIST_ID=\"my-project\" claude\n\n# Or in .claude/settings.json\n{ \"env\": { \"CLAUDE_CODE_TASK_LIST_ID\": \"my-project\" } }\n```\n\nStart a new session tomorrow — your task list is still there.\n\n---\n\n## Workflows\n\n| Workflow | Best For | Converter | Loop | Swarm | Team |\n|----------|----------|-----------|------|-------|------|\n| **Simple** | 80% of tasks | — | `/implement-loop`, `/plan-loop` | `/implement-swarm`, `/plan-swarm` | `/implement-team`, `/plan-team` |\n| **Tasks** | prd.json format | `/tasks-converter` | `/tasks-loop` | `/tasks-swarm` | — |\n| **Beads** | Persistent memory | `/beads-converter` | `/beads-loop` | `/beads-swarm` | — |\n\n**Converters** transform plans into executable formats. `/tasks-converter` creates prd.json files with `dependsOn` arrays. `/beads-converter` creates beads with epic→task hierarchy and `depends_on` via `bd dep add`. Both read the plan's `## Dependency Graph` table to build dependencies that maximize parallel execution.\n\n**All use Claude Code's built-in Task System** for dependencies, `ctrl+t` progress, and persistence.\n\n**Alternative executor:** [Ralph TUI](https://github.com/subsy/ralph-tui) runs Tasks/Beads with the classic Ralph Wiggum loop style (community approach before Claude Code had native tasks).\n\n### Loop vs Swarm vs Team\n\n| Aspect | Loop | Swarm | Team |\n|--------|------|-------|------|\n| **Executor** | Main agent (foreground) | Background subagents | Full Claude Code instances (tmux panes) |\n| **Concurrency** | 1 task at a time | Up to N tasks (`--workers`) | All agents in parallel |\n| **Context** | Full conversation history | Each agent gets task description only | Each agent gets contracts + ownership scope |\n| **Communication** | N/A (single agent) | Workers isolated | Agents message each other via lead |\n| **Lead role** | Implements directly | Queue manager | Contract author + coordinator (no coding) |\n| **Pre-work** | Parse plan, create tasks | Parse plan, create tasks | Parse plan, **define contracts**, create tasks |\n| **Visibility** | See work live | Check with `ctrl+t` or TaskList | Each agent visible in tmux pane |\n| **Best for** | Sequential tasks | Independent parallel tasks | Multi-component builds requiring integration |\n| **Task system** | Same | Same | Same |\n| **Dependencies** | Same | Same | Same |\n\n**All three use the same task graph with dependencies.** Loop executes sequentially. Swarm spawns isolated subagents for independent parallel work. Team defines integration contracts upfront and spawns full Claude Code instances that can communicate — use when components must agree on interfaces (frontend + backend + database).\n\n### Simple (Start Here)\n\n```bash\n# From conversation context (after discussing)\n/implement-loop fix the auth bug       # Sequential\n/implement-swarm refactor API handlers  # Parallel subagents\n/implement-team build the dashboard    # Agent Teams with contracts\n\n# Or with plan file\n/plan-creator Add JWT authentication\n/plan-loop .claude/plans/jwt-auth-plan.md    # Sequential\n/plan-swarm .claude/plans/jwt-auth-plan.md   # Parallel subagents\n/plan-team .claude/plans/jwt-auth-plan.md    # Agent Teams with contracts\n```\n\n### Tasks (prd.json Format)\n\n```bash\n/plan-creator Add JWT authentication\n/tasks-converter .claude/plans/jwt-auth-plan.md\n\n# Execute with Claude Code's Task System (recommended)\n/tasks-loop .claude/prd/jwt-auth.json             # Sequential\n/tasks-swarm .claude/prd/jwt-auth.json            # Parallel\n\n# Or execute with Ralph TUI (classic Ralph loop)\nralph-tui run --prd .claude/prd/jwt-auth.json\n```\n\n### Beads (Persistent Memory)\n\n```bash\nbd init\n/plan-creator Add JWT authentication\n/beads-converter .claude/plans/jwt-auth-plan.md\n\n# Execute with Claude Code's Task System (recommended)\n/beads-loop                                        # Sequential\n/beads-swarm                                       # Parallel\n\n# Or execute with Ralph TUI (classic Ralph loop)\nralph-tui run --tracker beads --epic <epic-id>\n```\n\n---\n\n## How Loops Work\n\n```\n                    ┌─────────────────┐\n                    │  Read Source    │\n                    │ (plan/context)  │\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │  Create Tasks   │\n                    │  + Dependencies │\n                    │ (from Dep Graph)│\n                    └────────┬────────┘\n                             │\n        ┌────────────────────┴────────────────────┐\n        │              MAIN AGENT                 │\n        │                                         │\n        │   ┌─────────────────┐                   │\n        │   │    TaskList     │◄──────┐           │\n        │   │ (find unblocked)│       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │  Mark task      │       │           │\n        │   │  in_progress    │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │   Implement     │       │           │\n        │   │   (read, edit)  │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │  Mark task      │       │           │\n        │   │   completed     │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │      ┌─────┴─────┐          │           │\n        │      │           │          │           │\n        │  More tasks   All done      │           │\n        │      │           │          │           │\n        │      └───────────┼──────────┘           │\n        │                  │                      │\n        └──────────────────┼──────────────────────┘\n                           │\n                           ▼\n                    ┌─────────────────┐\n                    │  Run Exit       │\n                    │  Criteria       │\n                    └────────┬────────┘\n                             │\n                       ┌─────┴─────┐\n                       │           │\n                     FAIL        PASS\n                       │           │\n                       │           ▼\n                       │    ┌─────────────────┐\n                       │    │ Loop complete ✓ │\n                       │    └─────────────────┘\n                       │\n                       ▼\n                ┌─────────────────┐\n                │   Fix issues    │\n                │   (loop back)   │\n                └─────────────────┘\n```\n\n**Sequential execution.** Main agent works through tasks one at a time in dependency order. Blocked tasks wait until their dependencies complete. Exit criteria verified at end. Loops until all tests pass.\n\n---\n\n## How Swarms Work\n\n```\n                    ┌─────────────────┐\n                    │  Read Source    │\n                    │ (plan/context)  │\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │  Create Tasks   │\n                    │  + Dependencies │\n                    │ (from Dep Graph)│\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │  Spawn up to N  │\n                    │ background agents│\n                    │ (ready tasks)   │\n                    └────────┬────────┘\n                             │\n         ┌───────────────────┼───────────────────┐\n         │                   │                   │\n         ▼                   ▼                   ▼\n  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n  │  Agent 1    │     │  Agent 2    │     │  Agent N    │\n  │─────────────│     │─────────────│     │─────────────│\n  │ implement   │     │ implement   │     │ implement   │\n  │ EXIT        │     │ EXIT        │     │ EXIT        │\n  └──────┬──────┘     └──────┬──────┘     └──────┬──────┘\n         │                   │                   │\n         └───────────────────┼───────────────────┘\n                             │\n        ┌────────────────────┴────────────────────┐\n        │              MAIN AGENT                 │\n        │                                         │\n        │   ┌─────────────────┐                   │\n        │   │  Stop & wait    │◄──────┐           │\n        │   │  (notification) │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │  Agent done     │       │           │\n        │   │  Mark completed │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │            ▼                │           │\n        │   ┌─────────────────┐       │           │\n        │   │  Find ready     │       │           │\n        │   │ (pending+empty  │       │           │\n        │   │  blockedBy)     │       │           │\n        │   │  Mark in_progress│      │           │\n        │   │  Spawn workers  │       │           │\n        │   └────────┬────────┘       │           │\n        │            │                │           │\n        │      ┌─────┴─────┐          │           │\n        │      │           │          │           │\n        │  More tasks   All done      │           │\n        │      │           │          │           │\n        │      └───────────┼──────────┘           │\n        │                  │                      │\n        └──────────────────┼──────────────────────┘\n                           │\n                           ▼\n                    ┌─────────────────┐\n                    │ Swarm complete ✓│\n                    └─────────────────┘\n```\n\n**Queue-based parallel execution (default: 3 workers).** Main agent marks tasks in_progress and spawns up to N background agents. Each agent does ONE task then exits. On completion notification, main agent marks the task completed, checks TaskList for newly unblocked tasks (status=`pending`, empty `blockedBy`), marks them in_progress, and spawns workers. Dependencies enforced — blocked tasks wait until all their blockers complete.\n\n---\n\n## How Teams Work\n\n```\n                    ┌─────────────────┐\n                    │  Read Source    │\n                    │ (plan/context)  │\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │ Determine Team  │\n                    │ Structure       │\n                    │ (2-5+ agents)   │\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │ Define Contracts│\n                    │ (exact URLs,    │\n                    │  JSON shapes,   │\n                    │  status codes)  │\n                    └────────┬────────┘\n                             │\n                             ▼\n                    ┌─────────────────┐\n                    │ Enter Delegate  │\n                    │ Mode + Spawn    │\n                    │ all agents      │\n                    └────────┬────────┘\n                             │\n         ┌───────────────────┼───────────────────┐\n         │                   │                   │\n         ▼                   ▼                   ▼\n  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐\n  │  Agent 1    │     │  Agent 2    │     │  Agent N    │\n  │ (Backend)   │     │ (Database)  │     │ (Frontend)  │\n  │─────────────│     │─────────────│     │─────────────│\n  │ contracts + │     │ contracts + │     │ contracts + │\n  │ ownership   │◄───►│ ownership   │◄───►│ ownership   │\n  │ scope       │relay│ scope       │relay│ scope       │\n  └──────┬──────┘     └──────┬──────┘     └──────┬──────┘\n         │                   │                   │\n         └───────────────────┼───────────────────┘\n                             │\n        ┌────────────────────┴────────────────────┐\n        │              LEAD AGENT                 │\n        │         (Delegate Mode)                 │\n        │                                         │\n        │   ┌─────────────────┐                   │\n        │   │ Relay messages   │                   │\n        │   │ Mediate changes  │                   │\n        │   │ Resolve conflicts│                   │\n        │   └────────┬────────┘                   │\n        │            │                            │\n        │            ▼                            │\n        │   ┌─────────────────┐                   │\n        │   │ Contract diff   │                   │\n        │   │ (built vs spec) │                   │\n        │   └────────┬────────┘                   │\n        │            │                            │\n        └────────────┼────────────────────────────┘\n                     │\n                     ▼\n              ┌─────────────────┐\n              │ End-to-end      │\n              │ validation      │\n              └────────┬────────┘\n                       │\n                 ┌─────┴─────┐\n                 │           │\n               FAIL        PASS\n                 │           │\n                 │           ▼\n                 │    ┌─────────────────┐\n                 │    │ Team complete ✓ │\n                 │    └─────────────────┘\n                 │\n                 ▼\n          ┌─────────────────┐\n          │ Re-spawn agent  │\n          │ with fix        │\n          └─────────────────┘\n```\n\n**Contract-first parallel execution.** Lead agent reads the plan, defines exact integration contracts (API URLs, JSON shapes, status codes, SSE formats), then spawns full Claude Code instances in tmux panes via Delegate Mode. Each agent gets contracts it produces, contracts it consumes, and ownership boundaries. Agents communicate through the lead for contract changes. After all agents complete, lead runs a contract diff and end-to-end validation.\n\n**Key difference from swarms:** Swarm workers are isolated — they can't talk to each other. Team agents share contracts and communicate through the lead, making teams ideal for multi-component builds where interfaces must align.\n\n---\n\n## Commands\n\n### Plan Creators\n\n| Command | Use For |\n|---------|---------|\n| `/plan-creator <feature>` | New features (brownfield development) |\n| `/bug-plan-creator <error> <desc>` | Bug fixes, root cause analysis |\n| `/code-quality-plan-creator <files>` | Refactoring, dead code, security |\n\nAll three produce plans with the same structure: per-file implementation details, `## Dependency Graph` table, and exit criteria. Pass a code map, design doc, or any reference file as additional context. Any plan can be fed to any converter or executed directly via `/plan-loop`, `/plan-swarm`, or `/plan-team`.\n\n### Execute Loops (Sequential)\n\n| Command | Source |\n|---------|--------|\n| `/implement-loop <task>` | Conversation context |\n| `/plan-loop <plan>` | Plan file (required) |\n| `/tasks-loop [prd.json]` | prd.json |\n| `/beads-loop [--label]` | Beads DB |\n\nCancel any loop: `/cancel-loop`\n\n### Execute Swarms (Parallel)\n\n| Command | Source |\n|---------|--------|\n| `/implement-swarm <task>` | Conversation context |\n| `/plan-swarm <plan>` | Plan file (required) |\n| `/tasks-swarm [prd.json]` | prd.json |\n| `/beads-swarm [--epic]` | Beads DB |\n\nCancel any swarm: `/cancel-swarm`\n\n### Execute Teams (Agent Teams)\n\n| Command | Source |\n|---------|--------|\n| `/implement-team <task>` | Conversation context |\n| `/plan-team <plan>` | Plan file (required) |\n\nCancel any team: `/cancel-team`\n\n**Requires:** tmux + `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`. Lead defines integration contracts, spawns full Claude Code instances in tmux panes via Delegate Mode. Agents communicate through the lead. Based on [Cole Medin's build-with-agent-team pattern](https://github.com/coleam00/context-engineering-intro/tree/main/use-cases/build-with-agent-team).\n\n### Convert Formats\n\n| Command | Output | Dependency Source |\n|---------|--------|-------------------|\n| `/tasks-converter <plan>` | prd.json with `dependsOn` arrays | Plan's `## Dependency Graph` table |\n| `/beads-converter <plan>` | Beads issues with `bd dep add` | Plan's `## Dependency Graph` table |\n\nConverters read the plan's `## Dependency Graph` to build file→task/bead ID maps and translate file dependencies to task dependencies. Falls back to per-file `Dependencies`/`Provides` for older plans without a Dependency Graph.\n\n### Schema References\n\n| Command | Purpose |\n|---------|---------|\n| `/plan-schema [validate <path>]` | Plan file format — sections, per-file format, dependency graph rules |\n| `/prd-schema [validate <path>]` | prd.json schema — required fields, rejected fields, examples |\n| `/beads-schema [validate]` | Beads CLI — issue types, statuses, priorities, commands |\n\nInvoke without arguments for a quick reference. Invoke with `validate` to check an existing file against the schema.\n\n### Utilities\n\n| Command | Purpose |\n|---------|---------|\n| `/codemap-creator <dir>` | Create JSON code map via LSP |\n| `/codemap-creator --update <map> [--diff\\|--mr\\|--pr]` | Update existing codemap with changed files |\n| `/document-creator <dir>` | DEVGUIDE.md generation |\n| `/mr-description-creator` | PR/MR descriptions via gh/glab |\n| `/show-status <json\\|beads> [path\\|epic-id]` | Task/bead status dashboard |\n| `/reset-prd <path>` | Reset prd.json to initial state |\n| `/reset-beads <epic-id>` | Reopen all tasks in a beads epic |\n| `/ralph-config <json\\|beads>` | Write RalphTUI config for workflow |\n\n---\n\n## What's In A Plan?\n\nPlans are markdown files in `.claude/plans/` with structured sections:\n\n```markdown\n## Implementation Plan\n\n### src/types/auth.ts [create]\n[Complete code — not pseudocode]\nDependencies: —\nProvides: AuthToken type, validateToken() function\n\n### src/services/auth.ts [create]\n[Complete code]\nDependencies: src/types/auth.ts\nProvides: AuthService class\n\n## Dependency Graph\n\n| Phase | File                    | Action | Depends On              |\n|-------|-------------------------|--------|-------------------------|\n| 1     | `src/types/auth.ts`     | create | —                       |\n| 2     | `src/services/auth.ts`  | create | `src/types/auth.ts`     |\n\n## Exit Criteria\nnpm test -- auth && npm run typecheck\n```\n\n**Self-Contained Rule:** Each task must be implementable with ONLY its description. No \"see design.md\" allowed.\n\n**Dependency Graph Rule:** The `## Dependency Graph` table is the source of truth for execution order. Converters read it to build `dependsOn`/`depends_on`. Files in the same phase can execute in parallel. Only real code dependencies should create phase boundaries.\n\n---\n\n## Project Structure\n\n```\nyour-project/\n├── .claude/\n│   ├── plans/          # Source of truth (plan files with Dependency Graphs)\n│   ├── prd/            # prd.json files (from /tasks-converter)\n│   ├── maps/           # Code maps (from /codemap-creator)\n│   └── prompts/        # Generated prompts\n├── .ralph-tui/         # RalphTUI config (if using)\n│   └── config.toml     # Tracker, agent settings\n└── .beads/             # Beads DB (if using)\n```\n\n**RalphTUI setup:** Run `ralph-tui setup` per project. See [Managing .ralph-tui/](WORKFLOW-TASKS.md#managing-ralph-tui-folder) for config details and switching trackers.\n\n---\n\n## Requirements\n\n| Tool | Required? | Purpose |\n|------|-----------|---------|\n| None | — | Simple workflow (loop/swarm) works out of the box |\n| tmux | For Team mode | Agent Teams use tmux for split-pane visualization |\n| [Beads CLI](https://github.com/steveyegge/beads) | For Beads workflow | Persistent memory across sessions |\n| [Ralph TUI](https://github.com/subsy/ralph-tui) | Optional | Classic Ralph loop executor with TUI dashboard |\n\n**Simple workflow has zero dependencies** for loop and swarm. Team mode requires tmux and `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS=1`. Add Beads for persistent memory. Add Ralph TUI if you prefer the classic Ralph Wiggum loop style.\n\n---\n\n## Model Configuration\n\nEdit YAML frontmatter in `essentials/commands/*.md` or `essentials/agents/*.md`:\n\n```yaml\n---\nmodel: opus    # opus | sonnet | haiku\n---\n```\n\n---\n\n## Troubleshooting\n\n| Problem | Solution |\n|---------|----------|\n| Loop won't stop | Exit criteria must return exit code 0 |\n| Wrong exit criteria | Edit plan directly, re-run loop |\n| Context filling up | Plans persist outside conversation |\n| prd.json not found | Use `userStories` and `passes` fields |\n| Beads CLI missing | `brew tap steveyegge/beads && brew install bd` |\n| Swarm runs sequentially | Check plan's Dependency Graph — every task chained to previous degrades swarm to sequential. Only declare real code dependencies. |\n\n---\n\n## Documentation\n\n- [WORKFLOW-SIMPLE.md](WORKFLOW-SIMPLE.md) — Default workflow, zero dependencies\n- [WORKFLOW-TASKS.md](WORKFLOW-TASKS.md) — Dashboard visualization with Ralph TUI\n- [WORKFLOW-BEADS.md](WORKFLOW-BEADS.md) — Persistent task tracking with Beads\n- [COMPARISON.md](COMPARISON.md) — Why verification-driven loops matter\n\n---\n\n## Contributing\n\n1. Fork it\n2. Create your branch (`git checkout -b feature/thing`)\n3. Commit changes\n4. Push and open a PR\n\n---\n\n## Credits\n\n- [Ralph Wiggum pattern](https://ghuntley.com/ralph/) by Geoffrey Huntley\n- [Beads](https://github.com/steveyegge/beads) by Steve Yegge — Persistent memory\n- [Ralph TUI](https://github.com/subsy/ralph-tui) by subsy — Classic Ralph loop executor\n- [build-with-agent-team](https://github.com/coleam00/context-engineering-intro/tree/main/use-cases/build-with-agent-team) by Cole Medin — Contract-first Agent Teams pattern\n- Built for [Claude Code](https://claude.ai/code)\n\n---\n\n<div align=\"center\">\n\n*Plans define exit criteria. Loops, swarms, and teams run until tests pass. Done means actually done.*\n\n</div>\n"
      },
      "plugins": [
        {
          "name": "essentials",
          "version": "3.43.0",
          "description": "24 commands, 8 agents. Loops, swarms, and teams powered by Claude Code's built-in Task System. Native task dependencies, ctrl+t progress, automatic persistence.",
          "source": "./essentials",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/essentials-claude-code",
            "/plugin install essentials@essentials-claude-code"
          ]
        }
      ]
    },
    {
      "name": "claude-code-repoprompt-codex-plugins",
      "version": null,
      "description": "Claude Code plugin collection with RepoPrompt, Codex CLI, and Gemini CLI integrations",
      "repo_full_name": "GantisStorm/claude-code-pair-planning-framework",
      "repo_url": "https://github.com/GantisStorm/claude-code-pair-planning-framework",
      "repo_description": "The Pair Planning Framework: A pluggable multi-agent planning framework for Claude Code. Swap planning engines (Claude, RepoPrompt, Codex) while keeping the same discovery agents and execution patterns.",
      "signals": {
        "stars": 5,
        "forks": 0,
        "pushed_at": "2025-12-21T14:07:23Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-code-repoprompt-codex-plugins\",\n  \"owner\": {\n    \"name\": \"GantisStorm\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugin collection with RepoPrompt, Codex CLI, and Gemini CLI integrations\",\n    \"version\": \"2.1.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"repoprompt-pair-pipeline\",\n      \"source\": \"./repoprompt-pair-pipeline\",\n      \"description\": \"Multi-agent orchestration for complex coding tasks with RepoPrompt. Scouts gather raw context, planners synthesize XML architectural instructions with structured sections: task, architecture, selected_context, relationships, implementation_notes, ambiguities. RepoPrompt creates detailed plans with minimal ambiguity. Parallel coders execute with self-verification. Uses rp-cli for RepoPrompt integration.\",\n      \"version\": \"1.8.0\"\n    },\n    {\n      \"name\": \"pair-pipeline\",\n      \"source\": \"./pair-pipeline\",\n      \"description\": \"Multi-agent orchestration for complex coding tasks without MCP. Scouts gather raw context, planner synthesizes structured narrative (task, architecture, context, relationships, implementation notes, ambiguities) into per-file instructions. Full discovery loop with user checkpoints and parallel execution.\",\n      \"version\": \"1.7.0\"\n    },\n    {\n      \"name\": \"pair-swarm\",\n      \"source\": \"./pair-swarm\",\n      \"description\": \"One-shot swarm commands for planning and coding. Scouts gather context in parallel, planner synthesizes structured narrative (task, architecture, context, relationships, implementation notes), parallel coders execute. No iterative loops - fast parallel execution.\",\n      \"version\": \"1.6.0\"\n    },\n    {\n      \"name\": \"repoprompt-swarm\",\n      \"source\": \"./repoprompt-swarm\",\n      \"description\": \"One-shot swarm commands with RepoPrompt planning. Scouts gather context in parallel, planner synthesizes XML architectural instructions for RepoPrompt, parallel coders execute. No iterative loops - fast parallel execution. Uses rp-cli for RepoPrompt integration.\",\n      \"version\": \"1.8.0\"\n    },\n    {\n      \"name\": \"codex-pair-pipeline\",\n      \"source\": \"./codex-pair-pipeline\",\n      \"description\": \"Multi-agent orchestration for complex coding tasks with Codex CLI (gpt-5.2). Scouts gather raw context, planners synthesize XML architectural instructions. Returns full plan with per-file instructions. Iterative discovery with user checkpoints and parallel execution. Session continuation via codex resume.\",\n      \"version\": \"1.12.0\"\n    },\n    {\n      \"name\": \"codex-swarm\",\n      \"source\": \"./codex-swarm\",\n      \"description\": \"One-shot swarm commands with Codex CLI planning. Scouts gather context in parallel, planner synthesizes XML architectural instructions for Codex (gpt-5.2), parallel coders execute. No iterative loops - fast parallel execution.\",\n      \"version\": \"1.11.0\"\n    },\n    {\n      \"name\": \"gemini-pair-pipeline\",\n      \"source\": \"./gemini-pair-pipeline\",\n      \"description\": \"Multi-agent orchestration for complex coding tasks with Gemini CLI (gemini-3-flash-preview). Scouts gather raw context, planners synthesize XML architectural instructions. Returns full plan with per-file instructions. Iterative discovery with user checkpoints and parallel execution. Session continuation via -r flag.\",\n      \"version\": \"1.3.0\"\n    },\n    {\n      \"name\": \"gemini-swarm\",\n      \"source\": \"./gemini-swarm\",\n      \"description\": \"One-shot swarm commands with Gemini CLI planning. Scouts gather context in parallel, planner synthesizes XML architectural instructions for Gemini (gemini-3-flash-preview), parallel coders execute. No iterative loops - fast parallel execution.\",\n      \"version\": \"1.3.0\"\n    }\n  ]\n}\n",
        "README.md": "# The Pair Planning Framework\n\nA **pluggable multi-agent planning framework** for Claude Code. Swap planning engines (Claude, RepoPrompt, Codex, Gemini) while keeping the same discovery agents and execution patterns.\n\n> **The Core Insight:** All planning engines follow the same meta-pattern: **Discovery → Planning → Execution**. The framework standardizes discovery (code-scout, doc-scout) and execution (plan-coder) while making the planning layer pluggable. This means you can switch between Claude's speed, RepoPrompt's file intelligence, Codex's reasoning depth, or Gemini's stateless simplicity - all using identical workflows.\n\n## Core Concept: Pluggable Planning\n\n```\n┌───────────────────────────────────────────────────────────────────────┐\n│                     PAIR PLANNING FRAMEWORK                           │\n│                                                                       │\n│   DISCOVERY (same for all)          PLANNING (choose one)             │\n│   ────────────────────────          ─────────────────────             │\n│                                                                       │\n│   ┌─────────────┐                   ┌─────────────────────────────┐   │\n│   │ code-scout  │                   │     Claude    (pair-*)      │   │\n│   │ (codebase)  │                   ├─────────────────────────────┤   │\n│   └──────┬──────┘    CONTEXT        │   RepoPrompt  (repoprompt-*)│   │\n│          │          ─────────►      ├─────────────────────────────┤   │\n│   ┌──────┴──────┐                   │     Codex     (codex-*)     │   │\n│   │  doc-scout  │                   ├─────────────────────────────┤   │\n│   │ (external)  │                   │     Gemini    (gemini-*)    │   │\n│   └─────────────┘                   └──────────────┬──────────────┘   │\n│                                                    │                  │\n│                                                    │ PLAN             │\n│                                                    ▼                  │\n│                                                                       │\n│   EXECUTION (same for all)                                            │\n│   ────────────────────────                                            │\n│                                                                       │\n│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                   │\n│   │ plan-coder  │  │ plan-coder  │  │ plan-coder  │  (parallel)       │\n│   │   file 1    │  │   file 2    │  │   file 3    │                   │\n│   └─────────────┘  └─────────────┘  └─────────────┘                   │\n└───────────────────────────────────────────────────────────────────────┘\n```\n\n**The framework provides:**\n- **Shared agents**: code-scout, doc-scout, plan-coder (same implementation across plugins)\n- **Pluggable planners**: Swap between Claude, RepoPrompt (rp-cli), Codex CLI, or Gemini CLI\n- **Two execution patterns**: Pipeline (iterative) or Swarm (one-shot)\n\n---\n\n## Execution Patterns\n\nThe framework offers **two execution patterns** that work with any planning engine.\n\n### Pipeline Pattern (Iterative, Human-in-the-Loop)\n\n```\n┌────────────────────────────────────────────────────────────────────────┐\n│                       ITERATIVE DISCOVERY LOOP                         │\n│                                                                        │\n│  code-scout ───► CHECKPOINT ───► doc-scout ───► CHECKPOINT ───► ...    │\n│  (background)         │         (background)         │                 │\n│       │          User decides         │         User decides           │\n│       ▼         \"Add research\"        ▼        \"Complete\"              │\n│  TaskOutput           │          TaskOutput          │                 │\n│       │               │               │              │                 │\n│       └───────────────┴───────────────┴──────────────┘                 │\n│                               │                                        │\n│                       context_package                                  │\n└───────────────────────────────┼────────────────────────────────────────┘\n                                │\n                                ▼\n                     ┌────────────────────┐\n                     │      PLANNER       │\n                     │    (pluggable)     │\n                     └─────────┬──────────┘\n                               │\n               ┌───────────────┼───────────────┐\n               ▼               ▼               ▼\n        ┌────────────┐  ┌────────────┐  ┌────────────┐\n        │ plan-coder │  │ plan-coder │  │ plan-coder │  (background)\n        │   file1    │  │   file2    │  │   file3    │\n        └──────┬─────┘  └──────┬─────┘  └──────┬─────┘\n               │               │               │\n               └───────────────┼───────────────┘\n                               ▼\n                          TaskOutput\n                        (collect all)\n```\n\n**Characteristics:**\n- Single `/orchestrate` command handles entire workflow\n- User controls discovery via checkpoints (AskUserQuestion)\n- Incrementally add research until context is complete\n- Best for: exploratory tasks, unfamiliar codebases, complex features\n\n**Plugins:** `pair-pipeline`, `repoprompt-pair-pipeline`, `codex-pair-pipeline`, `gemini-pair-pipeline`\n\n---\n\n### Swarm Pattern (One-Shot, Fast Execution)\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                            /plan COMMAND                                │\n│                                                                         │\n│        task: \"Add logout button\" | research: \"Session handling\"         │\n│                                    │                                    │\n│                    ┌───────────────┴───────────────┐                    │\n│                    ▼                               ▼                    │\n│              ┌───────────┐                   ┌───────────┐              │\n│              │code-scout │                   │ doc-scout │              │\n│              │(background│                   │(background│              │\n│              └─────┬─────┘                   └─────┬─────┘              │\n│                    │           (parallel)          │                    │\n│                    └───────────────┬───────────────┘                    │\n│                                    ▼                                    │\n│                               TaskOutput                                │\n│                            (collect both)                               │\n│                                    │                                    │\n│                                    ▼                                    │\n│                          ┌─────────────────┐                            │\n│                          │     PLANNER     │                            │\n│                          │   (pluggable)   │                            │\n│                          └────────┬────────┘                            │\n│                                   │                                     │\n│                                   ▼                                     │\n│                        IMPLEMENTATION PLAN                              │\n│                        (files + instructions)                           │\n└─────────────────────────────────────────────────────────────────────────┘\n\n┌─────────────────────────────────────────────────────────────────────────┐\n│                            /code COMMAND                                │\n│                                                                         │\n│                   plan: [...] or chat_id: [...]                         │\n│                                    │                                    │\n│                              Parse input                                │\n│                                    │                                    │\n│                    ┌───────────────┼───────────────┐                    │\n│                    ▼               ▼               ▼                    │\n│              ┌──────────┐   ┌──────────┐   ┌──────────┐                 │\n│              │plan-coder│   │plan-coder│   │plan-coder│                 │\n│              │  file1   │   │  file2   │   │  file3   │                 │\n│              │(backgrnd)│   │(backgrnd)│   │(backgrnd)│                 │\n│              └────┬─────┘   └────┬─────┘   └────┬─────┘                 │\n│                   │    (parallel)│              │                       │\n│                   └──────────────┼──────────────┘                       │\n│                                  ▼                                      │\n│                             TaskOutput                                  │\n│                           (collect all)                                 │\n│                                  │                                      │\n│                                  ▼                                      │\n│                           RESULTS TABLE                                 │\n│                    (file | status | summary)                            │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n**Characteristics:**\n- Two separate commands: `/plan` then `/code`\n- No checkpoints - review the plan, then execute\n- Scouts always run in parallel\n- Best for: well-defined tasks, fast execution\n\n**Plugins:** `pair-swarm`, `repoprompt-swarm`, `codex-swarm`, `gemini-swarm`\n\n---\n\n## Planning Engines\n\n### How Plans Flow: Direct vs MCP Fetch\n\nThe key architectural difference is **how plans move from planner to coders**.\n\n#### Direct Plan Distribution (pair-*, codex-*, gemini-*)\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                             ORCHESTRATOR                                │\n│                                                                         │\n│  ┌───────────┐         ┌─────────────────────────────────────────────┐  │\n│  │  PLANNER  │────────►│             FULL PLAN TEXT                  │  │\n│  └───────────┘         │    (returned directly to orchestrator)      │  │\n│                        └─────────────────────┬───────────────────────┘  │\n│                                              │                          │\n│                 ┌────────────────────────────┼────────────────────┐     │\n│                 │                            │                    │     │\n│                 ▼                            ▼                    ▼     │\n│       ┌──────────────┐            ┌──────────────┐      ┌──────────────┐│\n│       │  plan-coder  │            │  plan-coder  │      │  plan-coder  ││\n│       │              │            │              │      │              ││\n│       │target: file1 │            │target: file2 │      │target: file3 ││\n│       │plan: [instr1]│            │plan: [instr2]│      │plan: [instr3]││\n│       │              │            │              │      │              ││\n│       │(plan passed  │            │(plan passed  │      │(plan passed  ││\n│       │ IN PROMPT)   │            │ IN PROMPT)   │      │ IN PROMPT)   ││\n│       └──────────────┘            └──────────────┘      └──────────────┘│\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n**How it works:**\n1. Planner returns the full implementation plan to orchestrator\n2. Orchestrator parses and extracts per-file instructions\n3. Plan-coders receive instructions **embedded in their prompt**\n4. No MCP dependency for coders\n\n**Used by:** pair-*, codex-*, gemini-*\n\n---\n\n#### CLI Plan Storage & Fetch (repoprompt-*)\n\n```\n┌─────────────────────────────────────────────────────────────────────────┐\n│                             ORCHESTRATOR                                │\n│                                                                         │\n│  ┌───────────┐         ┌─────────────────────────────────────────────┐  │\n│  │  PLANNER  │────────►│              RepoPrompt (rp-cli)            │  │\n│  │           │         │  ┌───────────────────────────────────────┐  │  │\n│  │   calls   │         │  │     PLAN STORED IN CHAT SESSION       │  │  │\n│  │ rp-cli    │         │  │         chat_id: abc123               │  │  │\n│  │  builder  │         │  └───────────────────────────────────────┘  │  │\n│  └───────────┘         └──────────────────────┬──────────────────────┘  │\n│        │                                      │                         │\n│        │ returns: chat_id + file_lists        │                         │\n│        ▼                                      │                         │\n│  ┌─────────────────┐                          │                         │\n│  │  Orchestrator   │                          │                         │\n│  │   only knows    │                          │                         │\n│  │   chat_id &     │                          │                         │\n│  │   file list     │                          │                         │\n│  └────────┬────────┘                          │                         │\n│           │                                   │                         │\n│           ▼                                   ▼                         │\n│  ┌─────────────────┐                 ┌─────────────────┐                │\n│  │   plan-coder    │                 │   plan-coder    │                │\n│  │                 │                 │                 │                │\n│  │ chat_id: abc123 │                 │ chat_id: abc123 │                │\n│  │ target: file1   │                 │ target: file2   │                │\n│  │                 │                 │                 │                │\n│  │  FETCHES plan   │                 │  FETCHES plan   │                │\n│  │  via rp-cli     │                 │  via rp-cli     │                │\n│  │  chats log      │                 │  chats log      │                │\n│  └────────┬────────┘                 └────────┬────────┘                │\n│           │                                   │                         │\n│           ▼                                   ▼                         │\n│  ┌───────────────────────────────────────────────────────────────────┐  │\n│  │                        RepoPrompt (rp-cli)                        │  │\n│  │           (each coder fetches from same chat_id)                  │  │\n│  └───────────────────────────────────────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────────────────┘\n```\n\n**How it works:**\n1. Planner stores plan in RepoPrompt via `rp-cli builder`, returns `chat_id`\n2. Orchestrator only receives `chat_id` + file lists\n3. Each plan-coder **fetches** its instructions via `rp-cli chats log`\n4. Plan persists for review/resumption\n\n**Used by:** repoprompt-*\n\n---\n\n### Planning Engine Comparison\n\n| Aspect | pair-* (Claude) | codex-* (Codex) | repoprompt-* (RepoPrompt) | gemini-* (Gemini) |\n|--------|-----------------|-----------------|---------------------------|-------------------|\n| **Plan storage** | Orchestrator memory | Orchestrator memory | RepoPrompt (rp-cli) | Orchestrator memory |\n| **Plan delivery** | In prompt | In prompt | Via `chat_id` fetch | In prompt |\n| **External CLI** | None | codex | rp-cli | gemini |\n| **Planning model** | Claude | gpt-5.2 (via CLI) | RepoPrompt builder | gemini-3-flash-preview (via CLI) |\n| **Session continuation** | Accumulated context | Session ID | `chat_id` | Session index |\n\n---\n\n### The Meta Framework: What's Shared vs What's Different\n\nAll four planning engines implement the **same meta framework**. This is what makes them interchangeable:\n\n```\n┌─────────────────────────────────────────────────────────────────────────────┐\n│                        THE PAIR PLANNING FRAMEWORK                          │\n│                                                                             │\n│   ┌─────────────────────────────────────────────────────────────────────┐   │\n│   │                    SHARED ACROSS ALL ENGINES                        │   │\n│   │                                                                     │   │\n│   │  • code-scout agent (identical implementation)                      │   │\n│   │  • doc-scout agent (identical implementation)                       │   │\n│   │  • plan-coder agent (identical implementation*)                     │   │\n│   │  • Orchestrator patterns (Pipeline or Swarm)                        │   │\n│   │  • Input format: task: | research: | mode:                          │   │\n│   │  • Output format: files_to_edit, files_to_create, per-file instrs   │   │\n│   │                                                                     │   │\n│   │  *repoprompt plan-coder adds rp-cli fetch capability                │   │\n│   └─────────────────────────────────────────────────────────────────────┘   │\n│                                                                             │\n│   ┌─────────────────────────────────────────────────────────────────────┐   │\n│   │                    DIFFERENT PER ENGINE                             │   │\n│   │                                                                     │   │\n│   │  • Planner implementation (how context → plan)                      │   │\n│   │  • Plan format (Narrative vs XML)                                   │   │\n│   │  • Plan delivery (direct vs CLI fetch)                              │   │\n│   │  • External dependencies (none vs CLI)                              │   │\n│   └─────────────────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────────────────┘\n```\n\n---\n## Installation\n\n### Step 1: Add the Marketplace\n\n```bash\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n```\n\n### Step 2: Install Plugins\n\n```bash\n# Standalone (no dependencies)\n/plugin install pair-pipeline@claude-code-repoprompt-codex-plugins\n/plugin install pair-swarm@claude-code-repoprompt-codex-plugins\n\n# RepoPrompt planning (requires rp-cli)\n/plugin install repoprompt-pair-pipeline@claude-code-repoprompt-codex-plugins\n/plugin install repoprompt-swarm@claude-code-repoprompt-codex-plugins\n\n# Codex planning (requires CLI)\n/plugin install codex-pair-pipeline@claude-code-repoprompt-codex-plugins\n/plugin install codex-swarm@claude-code-repoprompt-codex-plugins\n\n# Gemini planning (requires CLI)\n/plugin install gemini-pair-pipeline@claude-code-repoprompt-codex-plugins\n/plugin install gemini-swarm@claude-code-repoprompt-codex-plugins\n```\n\nOr enable in `.claude/settings.local.json`:\n\n```json\n{\n  \"enabledPlugins\": {\n    \"pair-pipeline@claude-code-repoprompt-codex-plugins\": true,\n    \"pair-swarm@claude-code-repoprompt-codex-plugins\": true,\n    \"repoprompt-pair-pipeline@claude-code-repoprompt-codex-plugins\": true,\n    \"repoprompt-swarm@claude-code-repoprompt-codex-plugins\": true,\n    \"codex-pair-pipeline@claude-code-repoprompt-codex-plugins\": true,\n    \"codex-swarm@claude-code-repoprompt-codex-plugins\": true,\n    \"gemini-pair-pipeline@claude-code-repoprompt-codex-plugins\": true,\n    \"gemini-swarm@claude-code-repoprompt-codex-plugins\": true\n  }\n}\n```\n\n---\n\n## Usage\n\n### Pipeline Plugins (Iterative Discovery)\n\n```bash\n# Claude planning (standalone)\n/pair-pipeline:orchestrate command:start | task:Add user authentication\n\n# RepoPrompt planning\n/repoprompt-pair-pipeline:orchestrate command:start | task:Add user authentication\n\n# Codex planning\n/codex-pair-pipeline:orchestrate command:start | task:Add user authentication\n\n# Gemini planning\n/gemini-pair-pipeline:orchestrate command:start | task:Add user authentication\n\n# With initial research\n/pair-pipeline:orchestrate command:start | task:Add OAuth2 | research:Google OAuth2 best practices\n\n# Continue session with new task\n/pair-pipeline:orchestrate command:continue | task:Add password reset\n```\n\n### Swarm Plugins (One-Shot)\n\n```bash\n# Step 1: Create plan\n/pair-swarm:plan task:Add logout button | research:Session handling best practices\n/repoprompt-swarm:plan task:Add logout button | research:Session handling\n/codex-swarm:plan task:Add logout button | research:Session handling\n/gemini-swarm:plan task:Add logout button | research:Session handling\n\n# Step 2: Execute plan\n/pair-swarm:code plan:[paste plan from above]\n/repoprompt-swarm:code chat_id:[chat_id from /plan]\n/codex-swarm:code plan:[paste plan from above]\n/gemini-swarm:code plan:[paste plan from above]\n```\n\n---\n\n## Requirements\n\n### Base Requirements (All Plugins)\n\n- **Claude Code** - The CLI for orchestration and execution\n- **Node.js 18+** - For running Claude Code\n\n### External Requirements by Planning Engine\n\n| Planning Engine | Requirement | Setup |\n|-----------------|-------------|-------|\n| pair-* (Claude) | None | No additional setup |\n| repoprompt-* | rp-cli | See below |\n| codex-* | Codex CLI | See below |\n| gemini-* | Gemini CLI | See below |\n\n#### rp-cli Setup\n\n```bash\n# Install rp-cli via RepoPrompt\n# RepoPrompt Settings → MCP Server → \"Install CLI to PATH\"\n\n# Verify\nrp-cli --version\n```\n\n#### Codex CLI Setup\n\n```bash\n# Install Codex CLI\nnpm install -g @openai/codex\n# or: brew install codex\n\n# Authenticate\ncodex login\n\n# Verify\ncodex --version\n```\n\n#### Gemini CLI Setup\n\n```bash\n# Install Gemini CLI\nnpm install -g @google/gemini-cli\n# or: brew install gemini-cli (macOS)\n\n# Verify\ngemini --version\n```\n\n---\n\n## Directory Structure\n\n```\n.\n├── .claude-plugin/\n│   └── marketplace.json          # Plugin registry\n├── pair-pipeline/                # Claude planning + Pipeline\n│   ├── agents/                   # code-scout, doc-scout, plan-coder, planners\n│   ├── commands/                 # orchestrate\n│   └── skills/                   # code-quality\n├── pair-swarm/                   # Claude planning + Swarm\n│   ├── agents/                   # code-scout, doc-scout, plan-coder, planner\n│   ├── commands/                 # plan, code\n│   └── skills/                   # code-quality\n├── repoprompt-pair-pipeline/     # RepoPrompt planning + Pipeline\n│   ├── agents/                   # scouts, plan-coder (rp-cli), planners, planner-context\n│   ├── commands/                 # orchestrate\n│   └── skills/                   # code-quality, rp-cli\n├── repoprompt-swarm/             # RepoPrompt planning + Swarm\n│   ├── agents/                   # scouts, plan-coder (rp-cli), planner\n│   ├── commands/                 # plan, code\n│   └── skills/                   # code-quality, rp-cli\n├── codex-pair-pipeline/          # Codex planning + Pipeline\n│   ├── agents/                   # scouts, plan-coder, planners\n│   ├── commands/                 # orchestrate\n│   └── skills/                   # code-quality, codex-cli\n├── codex-swarm/                  # Codex planning + Swarm\n│   ├── agents/                   # scouts, plan-coder, planner\n│   ├── commands/                 # plan, code\n│   └── skills/                   # code-quality, codex-cli\n├── gemini-pair-pipeline/         # Gemini planning + Pipeline\n│   ├── agents/                   # scouts, plan-coder, planners\n│   ├── commands/                 # orchestrate\n│   └── skills/                   # code-quality, gemini-cli\n├── gemini-swarm/                 # Gemini planning + Swarm\n│   ├── agents/                   # scouts, plan-coder, planner\n│   ├── commands/                 # plan, code\n│   └── skills/                   # code-quality, gemini-cli\n└── README.md\n```\n\n---\n",
        "repoprompt-pair-pipeline/README.md": "# RepoPrompt Pair Pipeline\n\nCoordinates specialized agents to implement complex, multi-file coding tasks with RepoPrompt. Uses **iterative discovery** where users build context incrementally, then RepoPrompt creates detailed architectural plans.\n\n## Quick Start\n\n```bash\n# Add the marketplace from GitHub\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n\n# Install the plugin\n/plugin install repoprompt-pair-pipeline@claude-code-repoprompt-codex-plugins\n```\n\n## Commands\n\n### command:start - Discovery Loop\n\nIterative discovery with checkpoints. Best for complex features.\n\n```bash\n/repoprompt-pair-pipeline:orchestrate command:start | task:Add user authentication with JWT tokens\n/repoprompt-pair-pipeline:orchestrate command:start | task:Fix login button not responding on mobile\n/repoprompt-pair-pipeline:orchestrate command:start | task:Add OAuth2 login | research:Google OAuth2 best practices\n```\n\n**Flow:** code-scout -> checkpoints -> optional doc-scout -> RepoPrompt planning -> execution\n\n**With `research:` provided:** code-scout + doc-scout (parallel) -> checkpoints -> RepoPrompt planning -> execution\n\n### command:continue - Continue Previous Plan\n\nDiscovery loop, then continue in the same RepoPrompt chat. Preserves file selection context. Runs context optimization before planning.\n\n```bash\n/repoprompt-pair-pipeline:orchestrate command:continue | task:Add password reset flow\n/repoprompt-pair-pipeline:orchestrate command:continue | task:Add rate limiting to the new endpoints\n/repoprompt-pair-pipeline:orchestrate command:continue | task:Add email verification | research:SendGrid API best practices\n```\n\n**Flow:** code-scout -> checkpoints -> optional doc-scout -> **planner-context** -> RepoPrompt planning -> execution (continues existing RepoPrompt chat)\n\n**With `research:` provided:** code-scout + doc-scout (parallel) -> checkpoints -> **planner-context** -> RepoPrompt planning -> execution\n\n### command:fetch - Execute Existing Plan\n\nExecute an existing RepoPrompt plan by chat ID.\n\n```bash\n/repoprompt-pair-pipeline:orchestrate command:fetch | task:parti-url-cleanup-EA6D74\n```\n\n**Flow:** planner-fetch -> execution\n\n## How It Works\n\nThe orchestrator spawns specialized agents via the `Task` tool with `run_in_background: true`, then retrieves results via `TaskOutput`:\n\n1. **Discovery** - code-scout gathers CODE_CONTEXT; doc-scout adds EXTERNAL_CONTEXT (spawned in parallel when `research:` is provided upfront, otherwise optional at checkpoint)\n2. **Checkpoints** - User answers clarifying questions, decides when context is complete\n3. **Planning** - RepoPrompt receives XML architectural instructions and creates detailed plan\n4. **Execution** - Coders run in parallel as background tasks, results collected via TaskOutput\n\n**Background execution pattern:**\n- Agents spawn with `run_in_background: true`\n- Orchestrator uses `TaskOutput task_id: [agent-id]` to retrieve results\n- Enables true parallel execution of scouts and coders\n\n| Command | Discovery | Planning |\n|---------|-----------|----------|\n| `command:start` | Checkpoints + optional research | RepoPrompt (planner-start) |\n| `command:continue` | Checkpoints + optional research | planner-context -> RepoPrompt (planner-continue) |\n| `command:fetch` | None | Fetches existing plan |\n\n## Architecture Diagram\n\n```\n                                    ORCHESTRATOR\n                                         │\n           ┌─────────────────────────────┼─────────────────────────────┐\n           │                             │                             │\n           ▼                             ▼                             ▼\n┌────────────────────┐        ┌────────────────────┐        ┌────────────────────┐\n│   command:start    │        │  command:continue  │        │   command:fetch    │\n└─────────┬──────────┘        └─────────┬──────────┘        └─────────┬──────────┘\n          │                             │                             │\n          ▼                             ▼                             │\n┌─────────────────────────────────────────────────────────────────────┐    │\n│                    ITERATIVE DISCOVERY LOOP                         │    │\n│                    (Human-in-the-loop control)                      │    │\n│                                                                     │    │\n│  ┌─────────────────┐                                                │    │\n│  │   code-scout    │  ◄── run_in_background: true                   │    │\n│  └────────┬────────┘                                                │    │\n│  ┌────────┴────────┐                                                │    │\n│  │   TaskOutput    │  ◄── collect results                           │    │\n│  └────────┬────────┘                                                │    │\n│           │ CODE_CONTEXT                                            │    │\n│           ▼                                                         │    │\n│  ┌─────────────────┐                                                │    │\n│  │   CHECKPOINT    │◄────────────────────────┐                      │    │\n│  │ 1. Clarifying Qs│                         │                      │    │\n│  │ 2. \"Add research│                         │                      │    │\n│  │  or \"Complete\"  │                         │                      │    │\n│  └────────┬────────┘                         │                      │    │\n│           │                                  │                      │    │\n│      ┌────┴────┐                             │                      │    │\n│      ▼         ▼                             │                      │    │\n│  ┌─────────┐  \"Complete\"                     │                      │    │\n│  │doc-scout│      │  ◄── run_in_background   │                      │    │\n│  └────┬────┘      │                     (loop back)                 │    │\n│  ┌────┴────┐      │                          │                      │    │\n│  │TaskOutput      │                          │                      │    │\n│  └────┬────┘      │                          │                      │    │\n│       │ EXTERNAL  │                          │                      │    │\n│       │ _CONTEXT  │                          │                      │    │\n│       ▼           │                          │                      │    │\n│  ┌─────────────────┐                         │                      │    │\n│  │   CHECKPOINT    │─────────────────────────┘                      │    │\n│  └───┬─────────────┘                                                │    │\n│      │ \"Complete\"                                                   │    │\n│      │                                                              │    │\n│      │ context_package                                              │    │\n└──────┼──────────────────────────────────────────────────────────────┘    │\n       │                                                                   │\n       ├─────────────────────────────────┐                                 │\n       │                                 │                                 │\n       ▼ (command:start)                 ▼ (command:continue)              │\n┌─────────────────┐             ┌─────────────────┐                        │\n│  planner-start  │             │ planner-context │                        │\n│                 │             │                 │                        │\n│ Creates new     │             │ Evaluates       │                        │\n│ RepoPrompt chat │             │ workspace       │                        │\n│ via rp-cli      │             │ selection,      │                        │\n│ builder         │             │ adjusts files   │                        │\n└────────┬────────┘             └────────┬────────┘                        │\n         │                               │                                 │\n         │                               ▼                                 │\n         │                      ┌─────────────────┐                        │\n         │                      │planner-continue │                        │\n         │                      │                 │                        │\n         │                      │ Continues chat  │                        │\n         │                      │ via chat_send   │                        │\n         │                      └────────┬────────┘                        │\n         │                               │                                 │\n         │ chat_id + file_lists          │ chat_id + file_lists            │\n         └───────────────┬───────────────┘                                 │\n                         │                                                 │\n                         │                                      ┌──────────┴─────────┐\n                         │                                      │   planner-fetch    │\n                         │                                      │                    │\n                         │                                      │ Fetches existing   │\n                         │                                      │ plan from          │\n                         │                                      │ RepoPrompt         │\n                         │                                      └──────────┬─────────┘\n                         │                                                 │\n                         │                                                 │ chat_id + file_lists\n                         └─────────────────────────┬───────────────────────┘\n                                                   │\n                                                   ▼\n                        ┌───────────────────────────────────────────────────────┐\n                        │              PARALLEL BACKGROUND CODERS               │\n                        │                                                       │\n                        │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐     │\n                        │  │ plan-coder  │ │ plan-coder  │ │ plan-coder  │     │\n                        │  │   file 1    │ │   file 2    │ │   file 3    │     │\n                        │  │run_in_back- │ │run_in_back- │ │run_in_back- │     │\n                        │  │ground: true │ │ground: true │ │ground: true │     │\n                        │  │             │ │             │ │             │     │\n                        │  │ Fetches plan│ │ Fetches plan│ │ Fetches plan│     │\n                        │  │ via rp-cli  │ │ via rp-cli  │ │ via rp-cli  │     │\n                        │  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘     │\n                        │         │               │               │             │\n                        │         └───────────────┼───────────────┘             │\n                        │                         ▼                             │\n                        │               ┌─────────────────┐                     │\n                        │               │   TaskOutput    │                     │\n                        │               │ (collect all)   │                     │\n                        │               └─────────────────┘                     │\n                        └───────────────────────┬───────────────────────────────┘\n                                                │\n                                                │ status: COMPLETE/BLOCKED\n                                                ▼\n                                    ┌───────────────────────────┐\n                                    │  ORCHESTRATOR Review      │\n                                    │                           │\n                                    │  Collects results,        │\n                                    │  reports to user          │\n                                    └───────────────────────────┘\n```\n\n**Key flows:**\n- `command:start` -> discovery -> planner-start -> plan-coder\n- `command:continue` -> discovery -> planner-context -> planner-continue -> plan-coder\n- `command:fetch` -> planner-fetch -> plan-coder\n\n## Agents\n\n| Agent | Purpose | Tools | Output |\n|-------|---------|-------|--------|\n| code-scout | Investigate codebase | Glob, Grep, Read, Bash | Raw CODE_CONTEXT + clarification |\n| doc-scout | Fetch external docs | Any research tools | Raw EXTERNAL_CONTEXT + clarification |\n| planner-start | Synthesize prompt, create plan via RepoPrompt | Bash (rp-cli builder) | chat_id + file lists |\n| planner-context | Evaluate and optimize workspace selection | Bash (rp-cli select, context, etc.) | selection_summary + ready_for_planning |\n| planner-continue | Synthesize prompt for new task in existing chat | Bash (rp-cli chat) | chat_id + file lists |\n| planner-fetch | Fetch existing plan (NO synthesis) | Bash (rp-cli chats) | chat_id + file lists |\n| plan-coder | Implement single file (RepoPrompt mode) | Read, Edit, Write, Glob, Grep, Bash (rp-cli) | status + verified |\n\n## Tips\n\n**Choosing the right command:**\n- `command:start` - Explore unfamiliar code, want checkpoints\n- `command:continue` - Continue in same RepoPrompt chat\n- `command:fetch` - Re-execute existing plan\n\n**Getting good results:**\n- Be specific: \"Add logout button that clears session and redirects to /login\" not \"Add logout\"\n- For bugs, describe symptoms: \"Login button doesn't respond on mobile Safari\" not \"Login broken\"\n- Use `research:` for external APIs\n\n**When things go wrong:**\n- BLOCKED status includes error details - read them\n- Re-run with `command:continue` after fixing blockers\n- Incomplete context? Add research at checkpoints\n- Check if RepoPrompt is running and rp-cli is installed (`rp-cli --version`)\n\n## Comparison with Other Plugins\n\n| Feature | repoprompt-pair-pipeline | codex-pair-pipeline | repoprompt-swarm |\n|---------|--------------------------|---------------------|------------------|\n| Execution | Iterative with checkpoints | Iterative with checkpoints | One-shot |\n| Planning | RepoPrompt (rp-cli) | Codex CLI (gpt-5.2) | RepoPrompt (rp-cli) |\n| User control | Checkpoints during discovery | Checkpoints during discovery | Review plan, then execute |\n| Commands | /orchestrate (all-in-one) | /orchestrate (all-in-one) | /plan + /code (separate) |\n| Use case | Exploratory tasks with RepoPrompt | Exploratory tasks with Codex | Well-defined tasks |\n| Session | chat_id based continuation | Direct plan passing | chat_id based |\n\nUse **repoprompt-pair-pipeline** when you need iterative discovery with RepoPrompt's context management.\n\nUse **codex-pair-pipeline** when you prefer Codex's gpt-5.2 with high reasoning effort.\n\nUse **repoprompt-swarm** when you know what you want and just need fast parallel execution.\n\n## See Also\n\nFor a simpler pipeline without RepoPrompt dependency, see **pair-pipeline** which uses full discovery with checkpoints but direct planning (no external CLI required).\n\n## Requirements\n\n- **RepoPrompt** - Required (running in background)\n- **rp-cli** - Install via RepoPrompt Settings → MCP Server → \"Install CLI to PATH\"\n- **Claude Code** - Orchestration, discovery, and execution\n",
        "pair-pipeline/README.md": "# Pair Pipeline\n\nCoordinates specialized agents to implement complex, multi-file coding tasks. Uses **iterative discovery with checkpoints** and direct planning.\n\n## Quick Start\n\n```bash\n# Add the marketplace from GitHub\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n\n# Install the plugin\n/plugin install pair-pipeline@claude-code-repoprompt-codex-plugins\n```\n\n## Commands\n\n### command:start - Discovery Loop\n\nIterative discovery with checkpoints. Best for complex features.\n\n```bash\n/pair-pipeline:orchestrate command:start | task:Add user authentication with JWT tokens\n/pair-pipeline:orchestrate command:start | task:Fix login button not responding on mobile\n/pair-pipeline:orchestrate command:start | task:Add OAuth2 login | research:Google OAuth2 best practices\n```\n\n**Flow:** code-scout -> checkpoints -> optional doc-scout -> planning -> execution\n\n**With `research:` provided:** code-scout + doc-scout (parallel) -> checkpoints -> planning -> execution\n\n### command:continue - Continue Previous Context\n\nDiscovery loop using accumulated context from previous run.\n\n```bash\n/pair-pipeline:orchestrate command:continue | task:Add password reset flow\n/pair-pipeline:orchestrate command:continue | task:Add rate limiting | research:Express rate limiting\n```\n\n**Flow:** code-scout (if needed) -> checkpoints -> optional doc-scout -> planning -> execution (uses accumulated context)\n\n**With `research:` provided:** code-scout + doc-scout (parallel) -> checkpoints -> planning -> execution\n\n## How It Works\n\nThe orchestrator spawns specialized agents via the `Task` tool with `run_in_background: true`, then retrieves results via `TaskOutput`:\n\n1. **Discovery** - code-scout gathers CODE_CONTEXT; doc-scout adds EXTERNAL_CONTEXT (spawned in parallel when `research:` is provided upfront, otherwise optional at checkpoint)\n2. **Checkpoints** - User answers clarifying questions, decides when context is complete\n3. **Planning** - planner-start creates implementation plan with per-file instructions\n4. **Execution** - plan-coders run in parallel as background tasks, results collected via TaskOutput\n\n**Background execution pattern:**\n- Agents spawn with `run_in_background: true`\n- Orchestrator uses `TaskOutput task_id: [agent-id]` to retrieve results\n- Enables true parallel execution of scouts and coders\n\n**Flow:** code-scout -> checkpoints -> optional doc-scout -> planner-start (or planner-continue) -> plan-coder -> review\n\n## Architecture Diagram\n\n```\n                              ORCHESTRATOR\n                                   │\n                                   ▼\n                        ┌────────────────────┐\n                        │  command:start or  │\n                        │  continue          │\n                        └─────────┬──────────┘\n                                  │\n                                  ▼\n┌─────────────────────────────────────────────────────────┐\n│              ITERATIVE DISCOVERY LOOP                   │\n│              (Human-in-the-loop control)                │\n│                                                         │\n│  ┌─────────────────┐                                    │\n│  │   code-scout    │  ◄── run_in_background: true       │\n│  └────────┬────────┘                                    │\n│           │                                             │\n│  ┌────────┴────────┐                                    │\n│  │   TaskOutput    │  ◄── collect results               │\n│  └────────┬────────┘                                    │\n│           │ CODE_CONTEXT                                │\n│           ▼                                             │\n│  ┌─────────────────┐                                    │\n│  │   CHECKPOINT    │                                    │\n│  │ (AskUserQuestion│                                    │\n│  │ 1. Clarifying Qs│                                    │\n│  │ 2. \"Add research│                                    │\n│  │  or \"Complete\"  │                                    │\n│  └────────┬────────┘                                    │\n│           │                                             │\n│      ┌────┴────┐                                        │\n│      │         │                                        │\n│      ▼         │                                        │\n│  ┌─────────┐   │                                        │\n│  │doc-scout│   │  ◄── run_in_background: true           │\n│  └────┬────┘   │                                        │\n│  ┌────┴────┐   │                                        │\n│  │TaskOutput   │                                        │\n│  └────┬────┘   │                                        │\n│       │ EXTERNAL_CONTEXT                                │\n│       ▼        │                                        │\n│  ┌─────────────────┐                                    │\n│  │   CHECKPOINT    │                                    │\n│  │ 1. Clarifying Qs│                                    │\n│  │ 2. \"Add more\"   │                                    │\n│  │  or \"Complete\"  │                                    │\n│  └───┬────┬────────┘                                    │\n│      │    │                                             │\n│      │    └───► (loop back)                             │\n│      │                                                  │\n│      │ context_package                                  │\n└──────┼──────────────────────────────────────────────────┘\n       │\n       ▼\n┌─────────────────┐\n│  planner-start  │\n│       or        │\n│ planner-continue│\n│                 │\n└────────┬────────┘\n         │\n         │ file_lists + per-file plan\n         ▼\n┌───────────────────────────────────────────────────────┐\n│              PARALLEL BACKGROUND CODERS               │\n│                                                       │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐     │\n│  │ plan-coder  │ │ plan-coder  │ │ plan-coder  │     │\n│  │   file 1    │ │   file 2    │ │   file 3    │     │\n│  │run_in_back- │ │run_in_back- │ │run_in_back- │     │\n│  │ground: true │ │ground: true │ │ground: true │     │\n│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘     │\n│         │               │               │             │\n│         └───────────────┼───────────────┘             │\n│                         ▼                             │\n│               ┌─────────────────┐                     │\n│               │   TaskOutput    │                     │\n│               │ (collect all)   │                     │\n│               └─────────────────┘                     │\n└───────────────────────┬───────────────────────────────┘\n                        │\n                        │ status: COMPLETE/BLOCKED\n                        ▼\n              ┌─────────────────┐\n              │  ORCHESTRATOR   │\n              │ Phase 3 Review  │\n              │                 │\n              │ Collects results│\n              │ Reports to user │\n              └─────────────────┘\n```\n\n## Agents\n\n| Agent | Purpose | Tools | Output |\n|-------|---------|-------|--------|\n| code-scout | Investigate codebase | Glob, Grep, Read, Bash | Raw CODE_CONTEXT + clarification |\n| doc-scout | Fetch external docs | Any research tools | Raw EXTERNAL_CONTEXT + clarification |\n| planner-start | Create implementation plan (new task) | Read, Glob, Grep, Bash | file lists + instructions |\n| planner-continue | Create implementation plan (continue mode) | Read, Glob, Grep, Bash | file lists + instructions |\n| plan-coder | Implement single file | Read, Edit, Write, Glob, Grep, Bash | status + verified |\n\n## Plan Distribution\n\nPlans are embedded directly in the orchestrator's output - coders receive their per-file instructions directly. This avoids any external dependencies and ensures each coder has exactly the instructions it needs.\n\nFor `command:continue`, the accumulated context (CODE_CONTEXT, EXTERNAL_CONTEXT, Q&A) is preserved and passed to the planner.\n\n## Tips\n\n**Getting good results:**\n- Be specific: \"Add logout button that clears session and redirects to /login\" not \"Add logout\"\n- For bugs, describe symptoms: \"Login button doesn't respond on mobile Safari\" not \"Login broken\"\n- Use `research:` for external APIs\n\n**Using command:continue:**\n- Use `command:continue` when adding related features to the same area of code\n- The accumulated context (CODE_CONTEXT, EXTERNAL_CONTEXT, Q&A) is preserved\n- You can add new research with `command:continue | task:... | research:...`\n\n**When things go wrong:**\n- BLOCKED status includes error details - read them\n- Re-run with `command:continue` after fixing blockers\n- Incomplete context? Add research at checkpoints\n\n## Comparison with Other Plugins\n\n| Feature | pair-pipeline | codex-pair-pipeline | pair-swarm |\n|---------|---------------|---------------------|------------|\n| Execution | Iterative with checkpoints | Iterative with checkpoints | One-shot |\n| Planning | Direct (no MCP) | Codex MCP (gpt-5.2) | Direct (no MCP) |\n| User control | Checkpoints during discovery | Checkpoints during discovery | Review plan, then execute |\n| Commands | /orchestrate (all-in-one) | /orchestrate (all-in-one) | /plan + /code (separate) |\n| Use case | Exploratory tasks, no MCP | Exploratory tasks with Codex | Well-defined tasks |\n\nUse **pair-pipeline** for standalone operation with no external dependencies.\n\nUse **codex-pair-pipeline** when you want Codex's gpt-5.2 architectural planning with iterative discovery.\n\nUse **pair-swarm** when you know what you want and just need fast parallel execution.\n\n## See Also\n\nFor RepoPrompt-based planning, see **repoprompt-pair-pipeline** which uses RepoPrompt's context_builder for planning and chat_id for session management.\n\n## Requirements\n\n- **Claude Code** - Orchestration, discovery, and execution\n",
        "pair-swarm/README.md": "# Pair Swarm\n\nOne-shot swarm commands for planning and coding. No iterative loops or checkpoints - just parallel agent execution.\n\n## Quick Start\n\n```bash\n# Add the marketplace from GitHub\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n\n# Install the plugin\n/plugin install pair-swarm@claude-code-repoprompt-codex-plugins\n```\n\n## Commands\n\n### /plan - Create Implementation Plan\n\nSpawns code-scout and doc-scout as background tasks (parallel), then creates an implementation plan. Uses `TaskOutput` to retrieve results.\n\n```bash\n/pair-swarm:plan task:Add user authentication with JWT tokens | research:JWT best practices Node.js\n/pair-swarm:plan task:Fix login button not responding on mobile | research:React touch event handling\n/pair-swarm:plan task:Add OAuth2 login | research:Google OAuth2 Node.js\n```\n\n**Flow:** code-scout + doc-scout (parallel) -> planner -> plan output\n\n**Output:** A structured implementation plan with per-file instructions, ready for `/code`.\n\n### /code - Execute Implementation Plan\n\nTakes a plan and spawns plan-coders as background tasks (parallel). Uses `TaskOutput` to collect results from all coders.\n\n```bash\n/pair-swarm:code plan:[paste plan from /plan output]\n```\n\n**Flow:** Parse plan -> spawn all plan-coders (parallel) -> collect results\n\n**Output:** Status table showing which files were completed/blocked.\n\n## Architecture Diagram\n\n```\n       /plan command                      /code command\n             │                                  │\n             ▼                                  ▼\n     ┌───────────────┐                  ┌───────────────┐\n     │  Parse Input  │                  │  Parse Plan   │\n     │  task:        │                  │ files_to_edit │\n     │  research:    │                  │files_to_create│\n     └───────┬───────┘                  └───────┬───────┘\n             │                                  │\n             ▼                                  ▼\n     ┌───────┴───────┐                  ┌───────┴───────┐\n     │  BACKGROUND   │                  │  BACKGROUND   │\n     │    SPAWN      │                  │    SPAWN      │\n     ▼               ▼                  ▼               ▼\n┌──────────┐  ┌──────────┐        ┌──────────┐  ┌──────────┐\n│code-scout│  │doc-scout │        │plan-coder│  │plan-coder│\n│run_in_   │  │run_in_   │        │  file1   │  │  file2   │\n│background│  │background│        │run_in_   │  │run_in_   │\n│  :true   │  │  :true   │        │background│  │background│\n└────┬─────┘  └────┬─────┘        └────┬─────┘  └────┬─────┘\n     │             │                   │             │\n     ▼             ▼                   ▼             ▼\n┌─────────────────────┐          ┌─────────────────────┐\n│    TaskOutput       │          │    TaskOutput       │\n│  (collect results)  │          │  (collect results)  │\n└──────────┬──────────┘          └──────────┬──────────┘\n           │                                │\n CODE_CONTEXT + EXTERNAL_CONTEXT    COMPLETE + COMPLETE\n           │                                │\n           ▼                                ▼\n     ┌───────────┐                  ┌───────────────┐\n     │  planner  │                  │ Results Table │\n     └─────┬─────┘                  └───────────────┘\n           │\n           ▼\n   ┌────────────────┐\n   │ IMPLEMENTATION │\n   │     PLAN       │\n   │ files_to_edit  │\n   │files_to_create │\n   │ per-file instr │\n   └────────────────┘\n```\n\n## Agents\n\n| Agent | Purpose | Tools | Output |\n|-------|---------|-------|--------|\n| code-scout | Investigate codebase | Glob, Grep, Read, Bash | Raw CODE_CONTEXT |\n| doc-scout | Fetch external docs | Any research tools | Raw EXTERNAL_CONTEXT |\n| planner | Create implementation plan | Read, Glob, Grep, Bash | File lists + instructions |\n| plan-coder | Implement single file | Read, Edit, Write, Glob, Grep, Bash | Status + verified |\n\n## Plan Distribution\n\nPlans are embedded directly in the `/plan` output - the orchestrator displays the full plan for the user to review and pass to `/code`. This avoids any external dependencies and ensures each coder receives exactly the instructions it needs.\n\nNo MCP is required - the entire workflow runs natively in Claude Code.\n\n## Tips\n\n**Getting good results with /plan:**\n- Be specific: \"Add logout button that clears session and redirects to /login\" not \"Add logout\"\n- Include relevant research: \"JWT best practices Node.js\" not just \"JWT\"\n- For bugs, describe symptoms: \"Login button doesn't respond on mobile Safari\"\n\n**Using /code:**\n- Review the plan before executing - make adjustments if needed\n- If some files are BLOCKED, fix issues and re-run `/code` with the same plan\n\n**When things go wrong:**\n- BLOCKED status includes error details - read them\n- Check if the plan had ambiguous instructions\n- Try regenerating the plan with more specific task/research\n\n## Comparison with Other Plugins\n\n| Feature | pair-swarm | codex-swarm | pair-pipeline |\n|---------|------------|-------------|---------------|\n| Execution | One-shot | One-shot | Iterative with checkpoints |\n| Planning | Direct (no MCP) | Codex MCP (gpt-5.2) | Direct (no MCP) |\n| User control | Review plan, then execute | Review plan, then execute | Checkpoints during discovery |\n| Commands | /plan + /code (separate) | /plan + /code (separate) | /orchestrate (all-in-one) |\n| Use case | Well-defined tasks, no MCP | Well-defined tasks with Codex | Exploratory tasks |\n\nUse **pair-swarm** when you know what you want and just need fast parallel execution with no external dependencies.\n\nUse **codex-swarm** when you want Codex's gpt-5.2 architectural planning with high reasoning effort.\n\nUse **pair-pipeline** when you need iterative discovery with user checkpoints.\n\n## Requirements\n\n- **Claude Code** - Orchestration and execution\n",
        "repoprompt-swarm/README.md": "# RepoPrompt Swarm\n\nOne-shot swarm commands with RepoPrompt planning. No iterative loops or checkpoints - just parallel agent execution with RepoPrompt's intelligent planning.\n\n## Quick Start\n\n```bash\n# Add the marketplace from GitHub\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n\n# Install the plugin\n/plugin install repoprompt-swarm@claude-code-repoprompt-codex-plugins\n```\n\n## Commands\n\n### /plan - Create Implementation Plan via RepoPrompt\n\nSpawns code-scout and doc-scout as background tasks (parallel), then uses RepoPrompt to create an implementation plan. Uses `TaskOutput` to retrieve results.\n\n```bash\n/repoprompt-swarm:plan task:Add user authentication with JWT tokens | research:JWT best practices Node.js\n/repoprompt-swarm:plan task:Fix login button not responding on mobile | research:React touch event handling\n/repoprompt-swarm:plan task:Add OAuth2 login | research:Google OAuth2 Node.js\n```\n\n**Flow:** code-scout + doc-scout (parallel) -> RepoPrompt planner -> chat_id output\n\n**Output:** A chat_id referencing the RepoPrompt plan, ready for `/code`.\n\n### /code - Execute RepoPrompt Plan\n\nTakes a chat_id and spawns plan-coders as background tasks (parallel). Uses `TaskOutput` to collect results. Coders fetch their instructions from RepoPrompt.\n\n```bash\n/repoprompt-swarm:code chat_id:[chat_id from /plan output]\n```\n\n**Flow:** Fetch plan from RepoPrompt -> spawn all plan-coders (parallel) -> collect results\n\n**Output:** Status table showing which files were completed/blocked.\n\n## Architecture Diagram\n\n```\n       /plan command                      /code command\n             │                                  │\n             ▼                                  ▼\n     ┌───────────────┐                  ┌───────────────┐\n     │  Parse Input  │                  │  Fetch Plan   │\n     │  task:        │                  │from RepoPrompt│\n     │  research:    │                  │  (chat_id)    │\n     └───────┬───────┘                  └───────┬───────┘\n             │                                  │\n             ▼                                  ▼\n     ┌───────┴───────┐                  ┌───────┴───────┐\n     │  BACKGROUND   │                  │  BACKGROUND   │\n     │    SPAWN      │                  │    SPAWN      │\n     ▼               ▼                  ▼               ▼\n┌──────────┐  ┌──────────┐        ┌──────────┐  ┌──────────┐\n│code-scout│  │doc-scout │        │plan-coder│  │plan-coder│\n│run_in_   │  │run_in_   │        │  file1   │  │  file2   │\n│background│  │background│        │(fetches  │  │(fetches  │\n│  :true   │  │  :true   │        │ from RP) │  │ from RP) │\n└────┬─────┘  └────┬─────┘        │run_in_   │  │run_in_   │\n     │             │              │background│  │background│\n     ▼             ▼              └────┬─────┘  └────┬─────┘\n┌─────────────────────┐                │             │\n│    TaskOutput       │                ▼             ▼\n│  (collect results)  │          ┌─────────────────────┐\n└──────────┬──────────┘          │    TaskOutput       │\n           │                     │  (collect results)  │\n CODE_CONTEXT + EXTERNAL_CONTEXT └──────────┬──────────┘\n           │                                │\n           ▼                        COMPLETE + COMPLETE\n     ┌───────────┐                          │\n     │  planner  │                          ▼\n     │  (uses    │                  ┌───────────────┐\n     │ RepoPrompt│                  │ Results Table │\n     └─────┬─────┘                  └───────────────┘\n           │\n           ▼\n   ┌────────────────┐\n   │    CHAT_ID     │\n   │  + file lists  │\n   └────────────────┘\n```\n\n## Agents\n\n| Agent | Purpose | Tools | Output |\n|-------|---------|-------|--------|\n| code-scout | Investigate codebase | Glob, Grep, Read, Bash | Raw CODE_CONTEXT |\n| doc-scout | Fetch external docs | Any research tools | Raw EXTERNAL_CONTEXT |\n| planner | Synthesize context, send to RepoPrompt | Bash (rp-cli) | chat_id + file lists |\n| plan-coder | Implement single file (fetches from RepoPrompt) | Read, Edit, Write, Glob, Grep, Bash (rp-cli) | Status + verified |\n\n## Plan Distribution\n\nPlans are stored in RepoPrompt - the planner returns a `chat_id` that coders use to fetch their instructions. This enables:\n- Centralized plan storage in RepoPrompt\n- Each coder fetches its instructions independently via rp-cli\n- Plan remains accessible for re-execution\n\nAgents use rp-cli commands via Bash for both planning (`builder`) and plan retrieval (`chats log`).\n\n## Tips\n\n**Getting good results with /plan:**\n- Be specific: \"Add logout button that clears session and redirects to /login\" not \"Add logout\"\n- Include relevant research: \"JWT best practices Node.js\" not just \"JWT\"\n- For bugs, describe symptoms: \"Login button doesn't respond on mobile Safari\"\n\n**Using /code:**\n- The plan is stored in RepoPrompt - just pass the chat_id\n- If some files are BLOCKED, fix issues and re-run `/code` with the same chat_id\n- Each coder fetches its instructions from RepoPrompt independently\n\n**When things go wrong:**\n- BLOCKED status includes error details - read them\n- Check if RepoPrompt is running and rp-cli is installed (`rp-cli --version`)\n- Try regenerating the plan with more specific task/research\n\n## Comparison with Other Plugins\n\n| Feature | repoprompt-swarm | pair-swarm | repoprompt-pair-pipeline |\n|---------|------------------|------------|--------------------------|\n| Execution | One-shot | One-shot | Iterative with checkpoints |\n| Planning | RepoPrompt (rp-cli) | Direct (no CLI) | RepoPrompt (rp-cli) |\n| User control | Review plan, then execute | Review plan, then execute | Checkpoints during discovery |\n| Commands | /plan + /code (separate) | /plan + /code (separate) | /orchestrate (all-in-one) |\n| Use case | Well-defined tasks with RepoPrompt | Well-defined tasks, no CLI | Exploratory tasks |\n\nUse **repoprompt-swarm** when you know what you want and want RepoPrompt's intelligent planning.\n\nUse **pair-swarm** when you don't need RepoPrompt (no external CLI dependency).\n\nUse **repoprompt-pair-pipeline** when you need iterative discovery with user checkpoints.\n\n## Requirements\n\n- **RepoPrompt** - Required (running in background)\n- **rp-cli** - Install via RepoPrompt Settings → MCP Server → \"Install CLI to PATH\"\n- **Claude Code** - Orchestration and execution\n",
        "codex-pair-pipeline/README.md": "# Codex Pair Pipeline\n\nCoordinates specialized agents to implement complex, multi-file coding tasks with Codex CLI. Uses **iterative discovery** where users build context incrementally, then Codex creates detailed architectural plans using the Architect system prompt.\n\n## Quick Start\n\n```bash\n# Add the marketplace from GitHub\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n\n# Install the plugin\n/plugin install codex-pair-pipeline@claude-code-repoprompt-codex-plugins\n```\n\n## Requirements\n\n- **Codex CLI** - Install with `npm install -g @openai/codex` and authenticate via `codex login`\n- **Claude Code** - Orchestration, discovery, and execution\n\n## Commands\n\n### command:start - Discovery Loop\n\nIterative discovery with checkpoints. Best for complex features.\n\n```bash\n/codex-pair-pipeline:orchestrate command:start | task:Add user authentication with JWT tokens\n/codex-pair-pipeline:orchestrate command:start | task:Fix login button not responding on mobile\n/codex-pair-pipeline:orchestrate command:start | task:Add OAuth2 login | research:Google OAuth2 best practices\n```\n\n**Flow:** code-scout -> checkpoints -> optional doc-scout -> Codex planning -> execution\n\n**With `research:` provided:** code-scout + doc-scout (parallel) -> checkpoints -> Codex planning -> execution\n\n### command:continue - Continue with New Plan\n\nDiscovery loop, then create a new plan (builds on previous context).\n\n```bash\n/codex-pair-pipeline:orchestrate command:continue | task:Add password reset flow\n/codex-pair-pipeline:orchestrate command:continue | task:Add rate limiting to the new endpoints\n/codex-pair-pipeline:orchestrate command:continue | task:Add email verification | research:SendGrid API best practices\n```\n\n**Flow:** code-scout -> checkpoints -> optional doc-scout -> Codex planning -> execution\n\n**With `research:` provided:** code-scout + doc-scout (parallel) -> checkpoints -> Codex planning -> execution\n\n## How It Works\n\nThe orchestrator spawns specialized agents via the `Task` tool with `run_in_background: true`, then retrieves results via `TaskOutput`:\n\n1. **Discovery** - code-scout gathers CODE_CONTEXT; doc-scout adds EXTERNAL_CONTEXT (spawned in parallel when `research:` is provided upfront, otherwise optional at checkpoint)\n2. **Checkpoints** - User answers clarifying questions, decides when context is complete\n3. **Planning** - Codex CLI (using `gpt-5.2` model with high reasoning effort) receives Architect system prompt + CODE_CONTEXT + architectural narrative and creates detailed plan with per-file instructions\n4. **Execution** - Coders run in parallel as background tasks, results collected via TaskOutput\n\n**Background execution pattern:**\n- Agents spawn with `run_in_background: true`\n- Orchestrator uses `TaskOutput task_id: [agent-id]` to retrieve results\n- Enables true parallel execution of scouts and coders\n\n| Command | Discovery | Planning |\n|---------|-----------|----------|\n| `command:start` | Checkpoints + optional research | Codex (planner-start) |\n| `command:continue` | Checkpoints + optional research | Codex (planner-continue) |\n\n## Architecture Diagram\n\n```\n                              ORCHESTRATOR\n                                   │\n                                   ▼\n                        ┌────────────────────┐\n                        │  command:start or  │\n                        │  continue          │\n                        └─────────┬──────────┘\n                                  │\n                                  ▼\n┌─────────────────────────────────────────────────────────┐\n│              ITERATIVE DISCOVERY LOOP                   │\n│              (Human-in-the-loop control)                │\n│                                                         │\n│  ┌─────────────────┐                                    │\n│  │   code-scout    │  ◄── run_in_background: true       │\n│  └────────┬────────┘                                    │\n│           │                                             │\n│  ┌────────┴────────┐                                    │\n│  │   TaskOutput    │  ◄── collect results               │\n│  └────────┬────────┘                                    │\n│           │ CODE_CONTEXT                                │\n│           ▼                                             │\n│  ┌─────────────────┐                                    │\n│  │   CHECKPOINT    │                                    │\n│  │ (AskUserQuestion│                                    │\n│  │ 1. Clarifying Qs│                                    │\n│  │ 2. \"Add research│                                    │\n│  │  or \"Complete\"  │                                    │\n│  └────────┬────────┘                                    │\n│           │                                             │\n│      ┌────┴────┐                                        │\n│      │         │                                        │\n│      ▼         │                                        │\n│  ┌─────────┐   │                                        │\n│  │doc-scout│   │  ◄── run_in_background: true           │\n│  └────┬────┘   │                                        │\n│  ┌────┴────┐   │                                        │\n│  │TaskOutput   │                                        │\n│  └────┬────┘   │                                        │\n│       │ EXTERNAL_CONTEXT                                │\n│       ▼        │                                        │\n│  ┌─────────────────┐                                    │\n│  │   CHECKPOINT    │                                    │\n│  │ 1. Clarifying Qs│                                    │\n│  │ 2. \"Add more\"   │                                    │\n│  │  or \"Complete\"  │                                    │\n│  └───┬────┬────────┘                                    │\n│      │    │                                             │\n│      │    └───► (loop back)                             │\n│      │                                                  │\n│      │ context_package                                  │\n└──────┼──────────────────────────────────────────────────┘\n       │\n       ▼\n┌─────────────────┐\n│  planner-start  │\n│       or        │\n│ planner-continue│\n│ (Codex gpt-5.2) │\n│                 │\n└────────┬────────┘\n         │\n         │ FULL PLAN + file_lists\n         ▼\n┌───────────────────────────────────────────────────────┐\n│              PARALLEL BACKGROUND CODERS               │\n│                                                       │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐     │\n│  │ plan-coder  │ │ plan-coder  │ │ plan-coder  │     │\n│  │   file 1    │ │   file 2    │ │   file 3    │     │\n│  │run_in_back- │ │run_in_back- │ │run_in_back- │     │\n│  │ground: true │ │ground: true │ │ground: true │     │\n│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘     │\n│         │               │               │             │\n│         └───────────────┼───────────────┘             │\n│                         ▼                             │\n│               ┌─────────────────┐                     │\n│               │   TaskOutput    │                     │\n│               │ (collect all)   │                     │\n│               └─────────────────┘                     │\n└───────────────────────┬───────────────────────────────┘\n                        │\n                        │ status: COMPLETE/BLOCKED\n                        ▼\n              ┌─────────────────┐\n              │  ORCHESTRATOR   │\n              │ Phase 3 Review  │\n              │                 │\n              │ Collects results│\n              │ Reports to user │\n              └─────────────────┘\n```\n\n**Key flows:**\n- `command:start` -> discovery -> planner-start -> plan-coder\n- `command:continue` -> discovery -> planner-continue -> plan-coder\n\n## Agents\n\n| Agent | Purpose | Tools | Output |\n|-------|---------|-------|--------|\n| code-scout | Investigate codebase | Glob, Grep, Read, Bash | Raw CODE_CONTEXT + clarification |\n| doc-scout | Fetch external docs | Any research tools | Raw EXTERNAL_CONTEXT + clarification |\n| planner-start | Synthesize prompt, create plan via Codex CLI | Bash | Full plan + file lists |\n| planner-continue | Synthesize prompt, create new plan via Codex CLI | Bash | Full plan + file lists |\n| plan-coder | Implement single file | Read, Edit, Write, Glob, Grep, Bash | status + verified |\n\n## Plan Distribution\n\nPlans are passed directly from planners to coders - the orchestrator distributes per-file instructions. This avoids session continuation issues and ensures each coder has exactly the instructions it needs.\n\n## Tips\n\n**Choosing the right command:**\n- `command:start` - Explore unfamiliar code, want checkpoints\n- `command:continue` - Build on previous context with a new plan\n\n**Getting good results:**\n- Be specific: \"Add logout button that clears session and redirects to /login\" not \"Add logout\"\n- For bugs, describe symptoms: \"Login button doesn't respond on mobile Safari\" not \"Login broken\"\n- Use `research:` for external APIs\n\n**When things go wrong:**\n- BLOCKED status includes error details - read them\n- Re-run with `command:continue` after fixing blockers\n- Incomplete context? Add research at checkpoints\n\n## Comparison with Other Plugins\n\n| Feature | codex-pair-pipeline | gemini-pair-pipeline | codex-swarm |\n|---------|---------------------|----------------------|-------------|\n| Execution | Iterative with checkpoints | Iterative with checkpoints | One-shot |\n| Planning | Codex CLI (gpt-5.2) | Gemini MCP (3-flash-preview) | Codex CLI (gpt-5.2) |\n| User control | Checkpoints during discovery | Checkpoints during discovery | Review plan, then execute |\n| Commands | /orchestrate (all-in-one) | /orchestrate (all-in-one) | /plan + /code (separate) |\n| Use case | Exploratory tasks with Codex | Exploratory tasks with Gemini | Well-defined tasks |\n\nUse **codex-pair-pipeline** when you need iterative discovery with Codex's gpt-5.2 planning.\n\nUse **gemini-pair-pipeline** when you prefer Gemini's architectural planning.\n\nUse **codex-swarm** when you know what you want and just need fast parallel execution.\n\n## See Also\n\nFor RepoPrompt-based planning, see **repoprompt-pair-pipeline** which uses RepoPrompt's context_builder for planning and chat_id for session management.\n",
        "codex-swarm/README.md": "# Codex Swarm\n\nOne-shot swarm commands with Codex CLI planning. No iterative loops or checkpoints - just parallel agent execution with Codex's intelligent planning using `gpt-5.2` with high reasoning effort.\n\n## Quick Start\n\n```bash\n# Add the marketplace from GitHub\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n\n# Install the plugin\n/plugin install codex-swarm@claude-code-repoprompt-codex-plugins\n```\n\n## Requirements\n\n- **Codex CLI** - Install with `npm install -g @openai/codex` and authenticate via `codex login`\n- **Claude Code** - Orchestration and execution\n\n## Commands\n\n### /plan - Create Implementation Plan via Codex\n\nSpawns code-scout and doc-scout as background tasks (parallel), then uses Codex CLI with the Architect system prompt to create an implementation plan. Uses `TaskOutput` to retrieve results.\n\n```bash\n/codex-swarm:plan task:Add user authentication with JWT tokens | research:JWT best practices Node.js\n/codex-swarm:plan task:Fix login button not responding on mobile | research:React touch event handling\n/codex-swarm:plan task:Add OAuth2 login | research:Google OAuth2 Node.js\n```\n\n**Flow:** code-scout + doc-scout (parallel) -> Codex planner (gpt-5.2) -> full plan output\n\n**Output:** A complete implementation plan with per-file instructions, ready for `/code`.\n\n### /code - Execute Implementation Plan\n\nTakes the plan from `/plan` and spawns plan-coders as background tasks (parallel). Uses `TaskOutput` to collect results. Each coder receives its instructions directly.\n\n```bash\n/codex-swarm:code plan:[paste plan from /plan output]\n```\n\n**Flow:** Parse plan -> spawn all plan-coders (parallel) -> collect results\n\n**Output:** Status table showing which files were completed/blocked.\n\n## Architecture Diagram\n\n```\n       /plan command                      /code command\n             │                                  │\n             ▼                                  ▼\n     ┌───────────────┐                  ┌───────────────┐\n     │  Parse Input  │                  │  Parse Plan   │\n     │  task:        │                  │ files_to_edit │\n     │  research:    │                  │files_to_create│\n     └───────┬───────┘                  └───────┬───────┘\n             │                                  │\n             ▼                                  ▼\n     ┌───────┴───────┐                  ┌───────┴───────┐\n     │  BACKGROUND   │                  │  BACKGROUND   │\n     │    SPAWN      │                  │    SPAWN      │\n     ▼               ▼                  ▼               ▼\n┌──────────┐  ┌──────────┐        ┌──────────┐  ┌──────────┐\n│code-scout│  │doc-scout │        │plan-coder│  │plan-coder│\n│run_in_   │  │run_in_   │        │  file1   │  │  file2   │\n│background│  │background│        │run_in_   │  │run_in_   │\n│  :true   │  │  :true   │        │background│  │background│\n└────┬─────┘  └────┬─────┘        └────┬─────┘  └────┬─────┘\n     │             │                   │             │\n     ▼             ▼                   ▼             ▼\n┌─────────────────────┐          ┌─────────────────────┐\n│    TaskOutput       │          │    TaskOutput       │\n│  (collect results)  │          │  (collect results)  │\n└──────────┬──────────┘          └──────────┬──────────┘\n           │                                │\n CODE_CONTEXT + EXTERNAL_CONTEXT    COMPLETE + COMPLETE\n           │                                │\n           ▼                                ▼\n     ┌───────────┐                  ┌───────────────┐\n     │  planner  │                  │ Results Table │\n     │  (Codex   │                  └───────────────┘\n     │  gpt-5.2) │\n     └─────┬─────┘\n           │\n           ▼\n   ┌────────────────┐\n   │   FULL PLAN    │\n   │  + file lists  │\n   └────────────────┘\n```\n\n## Agents\n\n| Agent | Purpose | Tools | Output |\n|-------|---------|-------|--------|\n| code-scout | Investigate codebase | Glob, Grep, Read, Bash | Raw CODE_CONTEXT |\n| doc-scout | Fetch external docs | Any research tools | Raw EXTERNAL_CONTEXT |\n| planner | Synthesize context, send to Codex CLI | Bash | Full plan + file lists |\n| plan-coder | Implement single file | Read, Edit, Write, Glob, Grep, Bash | Status + verified |\n\n## Plan Distribution\n\nPlans are passed directly from `/plan` to `/code` - the orchestrator distributes per-file instructions to coders. This avoids session continuation issues and ensures each coder has exactly the instructions it needs.\n\n## Tips\n\n**Getting good results with /plan:**\n- Be specific: \"Add logout button that clears session and redirects to /login\" not \"Add logout\"\n- Include relevant research: \"JWT best practices Node.js\" not just \"JWT\"\n- For bugs, describe symptoms: \"Login button doesn't respond on mobile Safari\"\n\n**Using /code:**\n- Copy the Implementation Plan section from `/plan` output\n- If some files are BLOCKED, fix issues and re-run `/plan` with a modified task\n- Each coder receives its instructions directly\n\n**When things go wrong:**\n- BLOCKED status includes error details - read them\n- Verify Codex CLI is installed: `codex --version`\n- Try regenerating the plan with more specific task/research\n\n## Comparison with Other Plugins\n\n| Feature | codex-swarm | repoprompt-swarm | codex-pair-pipeline |\n|---------|-------------|------------------|---------------------|\n| Execution | One-shot | One-shot | Iterative with checkpoints |\n| Planning | Codex CLI (gpt-5.2) | RepoPrompt MCP | Codex CLI (gpt-5.2) |\n| User control | Review plan, then execute | Review plan, then execute | Checkpoints during discovery |\n| Commands | /plan + /code (separate) | /plan + /code (separate) | /orchestrate (all-in-one) |\n| Use case | Well-defined tasks with Codex | Well-defined tasks with RepoPrompt | Exploratory tasks |\n\nUse **codex-swarm** when you know what you want and want Codex's gpt-5.2 architectural planning with high reasoning effort.\n\nUse **repoprompt-swarm** when you prefer RepoPrompt's context handling.\n\nUse **codex-pair-pipeline** when you need iterative discovery with user checkpoints.\n",
        "gemini-pair-pipeline/README.md": "# Gemini Pair Pipeline\n\nCoordinates specialized agents to implement complex, multi-file coding tasks with Gemini CLI. Uses **iterative discovery** where users build context incrementally, then Gemini creates detailed architectural plans using the Architect system prompt.\n\n## Quick Start\n\n```bash\n# Add the marketplace from GitHub\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n\n# Install the plugin\n/plugin install gemini-pair-pipeline@claude-code-repoprompt-codex-plugins\n```\n\n## Requirements\n\n- **Gemini CLI** - Install with `npm install -g @google/gemini-cli` or `brew install gemini-cli` (macOS)\n- **Claude Code** - Orchestration, discovery, and execution\n\n## Commands\n\n### command:start - Discovery Loop\n\nIterative discovery with checkpoints. Best for complex features.\n\n```bash\n/gemini-pair-pipeline:orchestrate command:start | task:Add user authentication with JWT tokens\n/gemini-pair-pipeline:orchestrate command:start | task:Fix login button not responding on mobile\n/gemini-pair-pipeline:orchestrate command:start | task:Add OAuth2 login | research:Google OAuth2 best practices\n```\n\n**Flow:** code-scout -> checkpoints -> optional doc-scout -> Gemini planning -> execution\n\n**With `research:` provided:** code-scout + doc-scout (parallel) -> checkpoints -> Gemini planning -> execution\n\n### command:continue - Continue with New Plan\n\nDiscovery loop, then create a new plan (builds on previous context).\n\n```bash\n/gemini-pair-pipeline:orchestrate command:continue | task:Add password reset flow\n/gemini-pair-pipeline:orchestrate command:continue | task:Add rate limiting to the new endpoints\n/gemini-pair-pipeline:orchestrate command:continue | task:Add email verification | research:SendGrid API best practices\n```\n\n**Flow:** code-scout -> checkpoints -> optional doc-scout -> Gemini planning -> execution\n\n**With `research:` provided:** code-scout + doc-scout (parallel) -> checkpoints -> Gemini planning -> execution\n\n## How It Works\n\nThe orchestrator spawns specialized agents via the `Task` tool with `run_in_background: true`, then retrieves results via `TaskOutput`:\n\n1. **Discovery** - code-scout gathers CODE_CONTEXT; doc-scout adds EXTERNAL_CONTEXT (spawned in parallel when `research:` is provided upfront, otherwise optional at checkpoint)\n2. **Checkpoints** - User answers clarifying questions, decides when context is complete\n3. **Planning** - Gemini CLI (using `gemini-3-flash-preview` model) receives Architect system prompt + CODE_CONTEXT + architectural narrative and creates detailed plan with per-file instructions\n4. **Execution** - Coders run in parallel as background tasks, results collected via TaskOutput\n\n**Background execution pattern:**\n- Agents spawn with `run_in_background: true`\n- Orchestrator uses `TaskOutput task_id: [agent-id]` to retrieve results\n- Enables true parallel execution of scouts and coders\n\n| Command | Discovery | Planning |\n|---------|-----------|----------|\n| `command:start` | Checkpoints + optional research | Gemini (planner-start) |\n| `command:continue` | Checkpoints + optional research | Gemini (planner-continue) |\n\n## Architecture Diagram\n\n```\n                              ORCHESTRATOR\n                                   │\n                                   ▼\n                        ┌────────────────────┐\n                        │  command:start or  │\n                        │  continue          │\n                        └─────────┬──────────┘\n                                  │\n                                  ▼\n┌─────────────────────────────────────────────────────────┐\n│              ITERATIVE DISCOVERY LOOP                   │\n│              (Human-in-the-loop control)                │\n│                                                         │\n│  ┌─────────────────┐                                    │\n│  │   code-scout    │  ◄── run_in_background: true       │\n│  └────────┬────────┘                                    │\n│           │                                             │\n│  ┌────────┴────────┐                                    │\n│  │   TaskOutput    │  ◄── collect results               │\n│  └────────┬────────┘                                    │\n│           │ CODE_CONTEXT                                │\n│           ▼                                             │\n│  ┌─────────────────┐                                    │\n│  │   CHECKPOINT    │                                    │\n│  │ (AskUserQuestion│                                    │\n│  │ 1. Clarifying Qs│                                    │\n│  │ 2. \"Add research│                                    │\n│  │  or \"Complete\"  │                                    │\n│  └────────┬────────┘                                    │\n│           │                                             │\n│      ┌────┴────┐                                        │\n│      │         │                                        │\n│      ▼         │                                        │\n│  ┌─────────┐   │                                        │\n│  │doc-scout│   │  ◄── run_in_background: true           │\n│  └────┬────┘   │                                        │\n│  ┌────┴────┐   │                                        │\n│  │TaskOutput   │                                        │\n│  └────┬────┘   │                                        │\n│       │ EXTERNAL_CONTEXT                                │\n│       ▼        │                                        │\n│  ┌─────────────────┐                                    │\n│  │   CHECKPOINT    │                                    │\n│  │ 1. Clarifying Qs│                                    │\n│  │ 2. \"Add more\"   │                                    │\n│  │  or \"Complete\"  │                                    │\n│  └───┬────┬────────┘                                    │\n│      │    │                                             │\n│      │    └───► (loop back)                             │\n│      │                                                  │\n│      │ context_package                                  │\n└──────┼──────────────────────────────────────────────────┘\n       │\n       ▼\n┌─────────────────┐\n│  planner-start  │\n│       or        │\n│ planner-continue│\n│(Gemini 3-flash) │\n│                 │\n└────────┬────────┘\n         │\n         │ FULL PLAN + file_lists\n         ▼\n┌───────────────────────────────────────────────────────┐\n│              PARALLEL BACKGROUND CODERS               │\n│                                                       │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐     │\n│  │ plan-coder  │ │ plan-coder  │ │ plan-coder  │     │\n│  │   file 1    │ │   file 2    │ │   file 3    │     │\n│  │run_in_back- │ │run_in_back- │ │run_in_back- │     │\n│  │ground: true │ │ground: true │ │ground: true │     │\n│  └──────┬──────┘ └──────┬──────┘ └──────┬──────┘     │\n│         │               │               │             │\n│         └───────────────┼───────────────┘             │\n│                         ▼                             │\n│               ┌─────────────────┐                     │\n│               │   TaskOutput    │                     │\n│               │ (collect all)   │                     │\n│               └─────────────────┘                     │\n└───────────────────────┬───────────────────────────────┘\n                        │\n                        │ status: COMPLETE/BLOCKED\n                        ▼\n              ┌─────────────────┐\n              │  ORCHESTRATOR   │\n              │ Phase 3 Review  │\n              │                 │\n              │ Collects results│\n              │ Reports to user │\n              └─────────────────┘\n```\n\n**Key flows:**\n- `command:start` -> discovery -> planner-start -> plan-coder\n- `command:continue` -> discovery -> planner-continue -> plan-coder\n\n## Agents\n\n| Agent | Purpose | Tools | Output |\n|-------|---------|-------|--------|\n| code-scout | Investigate codebase | Glob, Grep, Read, Bash | Raw CODE_CONTEXT + clarification |\n| doc-scout | Fetch external docs | Any research tools | Raw EXTERNAL_CONTEXT + clarification |\n| planner-start | Synthesize prompt, create plan via Gemini CLI | Bash | Full plan + file lists |\n| planner-continue | Synthesize prompt, create new plan via Gemini CLI | Bash | Full plan + file lists |\n| plan-coder | Implement single file | Read, Edit, Write, Glob, Grep, Bash | status + verified |\n\n## Plan Distribution\n\nPlans are passed directly from planners to coders - the orchestrator distributes per-file instructions. This avoids session continuation issues and ensures each coder has exactly the instructions it needs.\n\n## Tips\n\n**Choosing the right command:**\n- `command:start` - Explore unfamiliar code, want checkpoints\n- `command:continue` - Build on previous context with a new plan\n\n**Getting good results:**\n- Be specific: \"Add logout button that clears session and redirects to /login\" not \"Add logout\"\n- For bugs, describe symptoms: \"Login button doesn't respond on mobile Safari\" not \"Login broken\"\n- Use `research:` for external APIs\n\n**When things go wrong:**\n- BLOCKED status includes error details - read them\n- Re-run with `command:continue` after fixing blockers\n- Incomplete context? Add research at checkpoints\n- Verify Gemini CLI is installed: `gemini --version`\n\n## Comparison with Other Plugins\n\n| Feature | gemini-pair-pipeline | codex-pair-pipeline | gemini-swarm |\n|---------|----------------------|---------------------|--------------|\n| Execution | Iterative with checkpoints | Iterative with checkpoints | One-shot |\n| Planning | Gemini CLI (3-flash-preview) | Codex CLI (gpt-5.2) | Gemini CLI (3-flash-preview) |\n| User control | Checkpoints during discovery | Checkpoints during discovery | Review plan, then execute |\n| Commands | /orchestrate (all-in-one) | /orchestrate (all-in-one) | /plan + /code (separate) |\n| Use case | Exploratory tasks with Gemini | Exploratory tasks with Codex | Well-defined tasks |\n\nUse **gemini-pair-pipeline** when you need iterative discovery with Gemini's architectural planning.\n\nUse **codex-pair-pipeline** when you prefer Codex's gpt-5.2 with high reasoning effort.\n\nUse **gemini-swarm** when you know what you want and just need fast parallel execution.\n\n## See Also\n\nFor RepoPrompt-based planning, see **repoprompt-pair-pipeline** which uses RepoPrompt's context_builder for planning and chat_id for session management.\n",
        "gemini-swarm/README.md": "# Gemini Swarm\n\nOne-shot swarm commands with Gemini CLI planning. No iterative loops or checkpoints - just parallel agent execution with Gemini's intelligent planning using `gemini-3-flash-preview`.\n\n## Quick Start\n\n```bash\n# Add the marketplace from GitHub\n/plugin marketplace add GantisStorm/claude-code-repoprompt-codex-plugins\n\n# Install the plugin\n/plugin install gemini-swarm@claude-code-repoprompt-codex-plugins\n```\n\n## Requirements\n\n- **Gemini CLI** - Install with `npm install -g @google/gemini-cli` or `brew install gemini-cli` (macOS)\n- **Claude Code** - Orchestration and execution\n\n## Commands\n\n### /plan - Create Implementation Plan via Gemini\n\nSpawns code-scout and doc-scout as background tasks (parallel), then uses Gemini CLI with the Architect system prompt to create an implementation plan. Uses `TaskOutput` to retrieve results.\n\n```bash\n/gemini-swarm:plan task:Add user authentication with JWT tokens | research:JWT best practices Node.js\n/gemini-swarm:plan task:Fix login button not responding on mobile | research:React touch event handling\n/gemini-swarm:plan task:Add OAuth2 login | research:Google OAuth2 Node.js\n```\n\n**Flow:** code-scout + doc-scout (parallel) -> Gemini planner (gemini-3-flash-preview) -> full plan output\n\n**Output:** A complete implementation plan with per-file instructions, ready for `/code`.\n\n### /code - Execute Implementation Plan\n\nTakes the plan from `/plan` and spawns plan-coders as background tasks (parallel). Uses `TaskOutput` to collect results. Each coder receives its instructions directly.\n\n```bash\n/gemini-swarm:code plan:[paste plan from /plan output]\n```\n\n**Flow:** Parse plan -> spawn all plan-coders (parallel) -> collect results\n\n**Output:** Status table showing which files were completed/blocked.\n\n## Architecture Diagram\n\n```\n       /plan command                      /code command\n             │                                  │\n             ▼                                  ▼\n     ┌───────────────┐                  ┌───────────────┐\n     │  Parse Input  │                  │  Parse Plan   │\n     │  task:        │                  │ files_to_edit │\n     │  research:    │                  │files_to_create│\n     └───────┬───────┘                  └───────┬───────┘\n             │                                  │\n             ▼                                  ▼\n     ┌───────┴───────┐                  ┌───────┴───────┐\n     │  BACKGROUND   │                  │  BACKGROUND   │\n     │    SPAWN      │                  │    SPAWN      │\n     ▼               ▼                  ▼               ▼\n┌──────────┐  ┌──────────┐        ┌──────────┐  ┌──────────┐\n│code-scout│  │doc-scout │        │plan-coder│  │plan-coder│\n│run_in_   │  │run_in_   │        │  file1   │  │  file2   │\n│background│  │background│        │run_in_   │  │run_in_   │\n│  :true   │  │  :true   │        │background│  │background│\n└────┬─────┘  └────┬─────┘        └────┬─────┘  └────┬─────┘\n     │             │                   │             │\n     ▼             ▼                   ▼             ▼\n┌─────────────────────┐          ┌─────────────────────┐\n│    TaskOutput       │          │    TaskOutput       │\n│  (collect results)  │          │  (collect results)  │\n└──────────┬──────────┘          └──────────┬──────────┘\n           │                                │\n CODE_CONTEXT + EXTERNAL_CONTEXT    COMPLETE + COMPLETE\n           │                                │\n           ▼                                ▼\n     ┌───────────┐                  ┌───────────────┐\n     │  planner  │                  │ Results Table │\n     │  (Gemini  │                  └───────────────┘\n     │ 3-flash)  │\n     └─────┬─────┘\n           │\n           ▼\n   ┌────────────────┐\n   │   FULL PLAN    │\n   │  + file lists  │\n   └────────────────┘\n```\n\n## Agents\n\n| Agent | Purpose | Tools | Output |\n|-------|---------|-------|--------|\n| code-scout | Investigate codebase | Glob, Grep, Read, Bash | Raw CODE_CONTEXT |\n| doc-scout | Fetch external docs | Any research tools | Raw EXTERNAL_CONTEXT |\n| planner | Synthesize context, send to Gemini CLI | Bash | Full plan + file lists |\n| plan-coder | Implement single file | Read, Edit, Write, Glob, Grep, Bash | Status + verified |\n\n## Plan Distribution\n\nPlans are passed directly from `/plan` to `/code` - the orchestrator distributes per-file instructions to coders. This ensures each coder has exactly the instructions it needs.\n\n## Tips\n\n**Getting good results with /plan:**\n- Be specific: \"Add logout button that clears session and redirects to /login\" not \"Add logout\"\n- Include relevant research: \"JWT best practices Node.js\" not just \"JWT\"\n- For bugs, describe symptoms: \"Login button doesn't respond on mobile Safari\"\n\n**Using /code:**\n- Copy the Implementation Plan section from `/plan` output\n- If some files are BLOCKED, fix issues and re-run `/plan` with a modified task\n- Each coder receives its instructions directly\n\n**When things go wrong:**\n- BLOCKED status includes error details - read them\n- Verify Gemini CLI is installed: `gemini --version`\n- Try regenerating the plan with more specific task/research\n\n## Comparison with Other Plugins\n\n| Feature | gemini-swarm | codex-swarm | gemini-pair-pipeline |\n|---------|--------------|-------------|----------------------|\n| Execution | One-shot | One-shot | Iterative with checkpoints |\n| Planning | Gemini CLI (3-flash-preview) | Codex CLI (gpt-5.2) | Gemini CLI (3-flash-preview) |\n| User control | Review plan, then execute | Review plan, then execute | Checkpoints during discovery |\n| Commands | /plan + /code (separate) | /plan + /code (separate) | /orchestrate (all-in-one) |\n| Use case | Well-defined tasks with Gemini | Well-defined tasks with Codex | Exploratory tasks |\n\nUse **gemini-swarm** when you know what you want and want Gemini's architectural planning.\n\nUse **codex-swarm** when you prefer OpenAI's Codex with high reasoning effort.\n\nUse **gemini-pair-pipeline** when you need iterative discovery with user checkpoints.\n"
      },
      "plugins": [
        {
          "name": "repoprompt-pair-pipeline",
          "source": "./repoprompt-pair-pipeline",
          "description": "Multi-agent orchestration for complex coding tasks with RepoPrompt. Scouts gather raw context, planners synthesize XML architectural instructions with structured sections: task, architecture, selected_context, relationships, implementation_notes, ambiguities. RepoPrompt creates detailed plans with minimal ambiguity. Parallel coders execute with self-verification. Uses rp-cli for RepoPrompt integration.",
          "version": "1.8.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/claude-code-pair-planning-framework",
            "/plugin install repoprompt-pair-pipeline@claude-code-repoprompt-codex-plugins"
          ]
        },
        {
          "name": "pair-pipeline",
          "source": "./pair-pipeline",
          "description": "Multi-agent orchestration for complex coding tasks without MCP. Scouts gather raw context, planner synthesizes structured narrative (task, architecture, context, relationships, implementation notes, ambiguities) into per-file instructions. Full discovery loop with user checkpoints and parallel execution.",
          "version": "1.7.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/claude-code-pair-planning-framework",
            "/plugin install pair-pipeline@claude-code-repoprompt-codex-plugins"
          ]
        },
        {
          "name": "pair-swarm",
          "source": "./pair-swarm",
          "description": "One-shot swarm commands for planning and coding. Scouts gather context in parallel, planner synthesizes structured narrative (task, architecture, context, relationships, implementation notes), parallel coders execute. No iterative loops - fast parallel execution.",
          "version": "1.6.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/claude-code-pair-planning-framework",
            "/plugin install pair-swarm@claude-code-repoprompt-codex-plugins"
          ]
        },
        {
          "name": "repoprompt-swarm",
          "source": "./repoprompt-swarm",
          "description": "One-shot swarm commands with RepoPrompt planning. Scouts gather context in parallel, planner synthesizes XML architectural instructions for RepoPrompt, parallel coders execute. No iterative loops - fast parallel execution. Uses rp-cli for RepoPrompt integration.",
          "version": "1.8.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/claude-code-pair-planning-framework",
            "/plugin install repoprompt-swarm@claude-code-repoprompt-codex-plugins"
          ]
        },
        {
          "name": "codex-pair-pipeline",
          "source": "./codex-pair-pipeline",
          "description": "Multi-agent orchestration for complex coding tasks with Codex CLI (gpt-5.2). Scouts gather raw context, planners synthesize XML architectural instructions. Returns full plan with per-file instructions. Iterative discovery with user checkpoints and parallel execution. Session continuation via codex resume.",
          "version": "1.12.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/claude-code-pair-planning-framework",
            "/plugin install codex-pair-pipeline@claude-code-repoprompt-codex-plugins"
          ]
        },
        {
          "name": "codex-swarm",
          "source": "./codex-swarm",
          "description": "One-shot swarm commands with Codex CLI planning. Scouts gather context in parallel, planner synthesizes XML architectural instructions for Codex (gpt-5.2), parallel coders execute. No iterative loops - fast parallel execution.",
          "version": "1.11.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/claude-code-pair-planning-framework",
            "/plugin install codex-swarm@claude-code-repoprompt-codex-plugins"
          ]
        },
        {
          "name": "gemini-pair-pipeline",
          "source": "./gemini-pair-pipeline",
          "description": "Multi-agent orchestration for complex coding tasks with Gemini CLI (gemini-3-flash-preview). Scouts gather raw context, planners synthesize XML architectural instructions. Returns full plan with per-file instructions. Iterative discovery with user checkpoints and parallel execution. Session continuation via -r flag.",
          "version": "1.3.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/claude-code-pair-planning-framework",
            "/plugin install gemini-pair-pipeline@claude-code-repoprompt-codex-plugins"
          ]
        },
        {
          "name": "gemini-swarm",
          "source": "./gemini-swarm",
          "description": "One-shot swarm commands with Gemini CLI planning. Scouts gather context in parallel, planner synthesizes XML architectural instructions for Gemini (gemini-3-flash-preview), parallel coders execute. No iterative loops - fast parallel execution.",
          "version": "1.3.0",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add GantisStorm/claude-code-pair-planning-framework",
            "/plugin install gemini-swarm@claude-code-repoprompt-codex-plugins"
          ]
        }
      ]
    }
  ]
}