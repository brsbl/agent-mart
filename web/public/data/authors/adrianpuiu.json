{
  "author": {
    "id": "adrianpuiu",
    "display_name": "agpro",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/187078?v=4",
    "url": "https://github.com/adrianpuiu",
    "bio": "savage ",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 1,
      "total_stars": 80,
      "total_forks": 6
    }
  },
  "marketplaces": [
    {
      "name": "claude-skills-marketplace",
      "version": null,
      "description": "Claude Skills Marketplace - A centralized repository for Claude Code skills and plugins",
      "owner_info": {
        "name": "George A Puiu",
        "email": "puiu.adrian@gmail.com"
      },
      "keywords": [],
      "repo_full_name": "adrianpuiu/claude-skills-marketplace",
      "repo_url": "https://github.com/adrianpuiu/claude-skills-marketplace",
      "repo_description": "A comprehensive skill that establishes Claude as a Project Architect to generate detailed planning documents that serve as blueprints for AI-assisted software development.  ",
      "homepage": "",
      "signals": {
        "stars": 80,
        "forks": 6,
        "pushed_at": "2025-10-26T22:54:41Z",
        "created_at": "2025-10-19T14:37:08Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 943
        },
        {
          "path": "project-planner-skill",
          "type": "tree",
          "size": null
        },
        {
          "path": "project-planner-skill/README.md",
          "type": "blob",
          "size": 5354
        },
        {
          "path": "project-planner-skill/SKILL.md",
          "type": "blob",
          "size": 24171
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-skills-marketplace\",\n  \"id\": \"claude-skills-marketplace\",\n  \"owner\": {\n    \"name\": \"George A Puiu\",\n    \"email\": \"puiu.adrian@gmail.com\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Skills Marketplace - A centralized repository for Claude Code skills and plugins\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"project-planner-skill\",\n      \"source\": \"./project-planner-skill\",\n      \"description\": \"Comprehensive project planning and documentation generator for software projects. Creates structured requirements documents, system design documents, and task breakdown plans with implementation tracking.\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"George A Puiu\",\n        \"email\": \"puiu.adrian@gmail.com\"\n      },\n      \"keywords\": [\"project-planning\", \"documentation\", \"requirements\", \"design\", \"implementation\"],\n      \"category\": \"productivity\",\n      \"strict\": false\n    }\n  ]\n}",
        "project-planner-skill/README.md": "# Project Planner Skill\n\nA comprehensive skill that establishes Claude as a **Project Architect** to generate detailed planning documents that serve as blueprints for AI-assisted software development.\n\n## What This Skill Does\n\nThis skill transforms Claude into a System Architect who creates comprehensive project documentation by:\n\n1. **Defining the complete system architecture upfront** - All components, data flows, and integration points\n2. **Setting clear project boundaries** - What's in scope, out of scope, and key constraints\n3. **Creating traceable documentation** - Requirements → Design → Implementation tasks\n\nThe skill generates three essential documents:\n\n1. **Requirements Document** - User stories with testable acceptance criteria and traceable IDs\n2. **Design Document** - Complete system architecture with component maps, data flows, and integration specifications\n3. **Implementation Plan** - Hierarchical task breakdown with requirement tracing and clear deliverables\n\n## The Architect Approach\n\n**Why it works:** Setting clear roles, responsibilities, and deliverables upfront dramatically improves output quality. By explicitly defining system components, data flows, and integration points before diving into details, the documentation becomes comprehensive and actionable.\n\n## Quick Start\n\n### Generate Documents Using the Script\n\n```bash\n# Basic usage\npython scripts/generate_project_docs.py \"My Project Name\"\n\n# Specify project type\npython scripts/generate_project_docs.py \"Trading Bot\" --type web-app\n\n# Custom features and components\npython scripts/generate_project_docs.py \"E-commerce Site\" \\\n  --features \"user authentication\" \"product catalog\" \"shopping cart\" \\\n  --components \"Auth Service\" \"Product Service\" \"Order Service\" \\\n  --output ./docs\n```\n\n### Validate Your Documents\n\n```bash\n# Validate all documents\npython scripts/validate_documents.py \\\n  --requirements requirements.md \\\n  --design design.md \\\n  --tasks tasks.md\n```\n\n## Document Types\n\n### Requirements Document\n- User stories in standard format\n- Testable acceptance criteria using SHALL statements\n- Requirement numbering for traceability\n- Glossary of domain terms\n\n### Design Document  \n- System architecture diagrams\n- Component responsibilities and interfaces\n- Data models and schemas\n- Error handling strategies\n- Deployment configuration\n\n### Implementation Plan\n- Hierarchical task breakdown\n- Requirement tracing (links tasks to requirements)\n- Dependency management between tasks\n- Progress tracking with checkboxes\n\n## Project Types Supported\n\n- **web-app**: Full-stack web applications\n- **cli-tool**: Command-line tools and utilities\n- **api-service**: REST/GraphQL API services\n- **generic**: General purpose projects\n\n## Files Included\n\n### Scripts\n- `generate_project_docs.py` - Automated document generation\n- `validate_documents.py` - Document validation and completeness checking\n\n### References\n- `domain-templates.md` - Domain-specific templates and patterns\n\n### Assets\n- `requirements-template.md` - Basic requirements document template\n\n## Best Practices\n\n1. **Start with Requirements** - Define what the system should do before how\n2. **Be Specific** - Use measurable criteria (e.g., \"within 100ms\" not \"fast\")\n3. **Trace Requirements** - Link every task back to requirements\n4. **Include Non-Functional Requirements** - Performance, security, scalability\n5. **Define Clear Interfaces** - Specify how components interact\n6. **Plan Incrementally** - Break large tasks into smaller, manageable pieces\n\n## Common Use Cases\n\n### Starting a New Project\n```\nUser: \"I want to build a real-time chat application\"\nAI: [Uses this skill to generate complete project documentation]\n```\n\n### Expanding Existing Project\n```\nUser: \"Add user authentication to my project requirements\"\nAI: [Adds properly formatted requirements with acceptance criteria]\n```\n\n### Creating Technical Specification\n```\nUser: \"Design the architecture for a microservices e-commerce platform\"\nAI: [Generates design document with components, interfaces, and deployment]\n```\n\n## Tips for AI Implementation\n\nWhen using these documents for AI-assisted development:\n\n1. **Requirements First** - Implement in order of requirement priority\n2. **Follow Task Dependencies** - Complete prerequisite tasks first\n3. **Test Against Acceptance Criteria** - Each SHALL statement is a test case\n4. **Reference Design Interfaces** - Use the specified APIs and data models\n5. **Track Progress** - Check off completed tasks in the implementation plan\n\n## Validation Checklist\n\nBefore using documents for implementation:\n\n- [ ] All placeholders ([PLACEHOLDER]) filled in\n- [ ] Requirements have testable acceptance criteria\n- [ ] Design includes all major components\n- [ ] Tasks reference requirement IDs\n- [ ] Dependencies between tasks identified\n- [ ] Non-functional requirements specified\n- [ ] Deployment configuration included\n\n## Example Output\n\nThe generated documents follow industry-standard formats that are:\n- **Machine-readable** - Structured for AI parsing\n- **Human-readable** - Clear for developers to understand  \n- **Version-control friendly** - Plain text Markdown format\n- **Traceable** - Requirements linked through all documents\n\nThis skill transforms high-level project ideas into actionable specifications that AI agents can use to build working software.\n",
        "project-planner-skill/SKILL.md": "---\nname: project-planner\ndescription: Comprehensive project planning and documentation generator for software projects. Creates structured requirements documents, system design documents, and task breakdown plans with implementation tracking. Use when starting a new project, defining specifications, creating technical designs, or breaking down complex systems into implementable tasks. Supports user story format, acceptance criteria, component design, API specifications, and hierarchical task decomposition with requirement traceability.\n---\n\n# Project Planner Skill\n\nThis skill provides templates and guidance for generating comprehensive project planning documents that serve as blueprints for AI-assisted implementation.\n\n## Quick Start\n\nWhen a user wants to start a new project, generate three core documents:\n1. **Requirements Document** - User stories with acceptance criteria\n2. **Design Document** - Technical architecture and component specifications  \n3. **Implementation Plan** - Hierarchical task breakdown with requirement tracing\n\n## Why Explicit Architectural Planning Works\n\nSetting clear roles, responsibilities, and deliverables upfront dramatically improves project outcomes:\n\n### Benefits of Upfront Definition\n\n1. **Component Clarity** - Defining all system components first prevents scope creep and ensures complete coverage\n2. **Data Flow Visibility** - Mapping data movement early reveals integration complexities and performance bottlenecks\n3. **Integration Planning** - Identifying all touchpoints upfront prevents surprise dependencies during implementation\n4. **Clear Boundaries** - Explicitly stating what's in/out of scope focuses effort and prevents feature drift\n5. **Measurable Success** - Specific goals and constraints enable objective progress tracking\n\n### The Architect Mindset\n\nWhen acting as a **Project Architect**, approach planning with:\n- **Systems Thinking** - See the whole before diving into parts\n- **Interface-First Design** - Define contracts between components before internals\n- **Traceability Focus** - Every requirement maps to design elements and tasks\n- **Constraint Awareness** - Acknowledge limitations upfront to guide decisions\n- **Deliverable Orientation** - Know exactly what artifacts you're producing\n\n## Document Generation Workflow\n\n### 1. Project Architect Role Definition\n\nWhen starting a project, explicitly establish Claude as the **Project Architect** with clear responsibilities:\n\n**Role:** System Architect and Planning Specialist\n**Responsibilities:**\n- Define complete system architecture with all components\n- Map data flow between system elements\n- Identify all integration points and interfaces\n- Establish clear project boundaries and constraints\n- Create traceable requirements to implementation tasks\n\n### 2. Initial Project Understanding\n\nBefore generating documents, gather key information and architectural elements:\n\n```\nRequired Project Information:\n- Project name and purpose\n- Target users (single-user local, multi-tenant SaaS, etc.)\n- Core functionality (3-5 main features)\n- Technical preferences (languages, frameworks, deployment)\n- Non-functional requirements (performance, security, scalability)\n\nRequired Architectural Elements (define upfront):\n- System Components: All major modules/services and their purposes\n- Data Flow: How data moves through the entire system\n- Integration Points: All external APIs, services, databases\n- System Boundaries: What's in scope vs out of scope\n- Constraints: Technical, business, and resource limitations\n- Success Metrics: Clear, measurable goals for the system\n```\n\n### 3. Deliverable Definition (Set Upfront)\n\nDefine all deliverables explicitly before starting documentation:\n\n```\nStandard Deliverables Package:\n1. Requirements Document\n   - User stories with measurable acceptance criteria\n   - Complete glossary of terms\n   - Traceable requirement IDs\n   \n2. System Design Document  \n   - Component architecture diagram\n   - Data flow diagrams for all major processes\n   - Integration point specifications\n   - API/Interface contracts\n   - Performance and scaling targets\n   \n3. Implementation Plan\n   - Hierarchical task breakdown\n   - Requirement-to-task mapping\n   - Dependency graph\n   - Phase-based delivery schedule\n\nOptional Deliverables (specify if needed):\n- API Documentation\n- Database Schema Design\n- Security Threat Model\n- Deployment Guide\n- Testing Strategy Document\n```\n\n### 4. Generate Requirements Document\n\nUse the requirements template to create user-focused specifications:\n\n```python\n# Execute this to generate requirements structure\nrequirements = {\n    \"introduction\": \"System purpose and scope\",\n    \"glossary\": \"Domain-specific terms\",\n    \"requirements\": [\n        {\n            \"id\": \"REQ-X\",\n            \"user_story\": \"As a [role], I want [feature], so that [benefit]\",\n            \"acceptance_criteria\": [\n                \"WHEN [condition], THE system SHALL [behavior]\",\n                \"WHERE [context], THE system SHALL [behavior]\",\n                \"IF [condition], THEN THE system SHALL [behavior]\"\n            ]\n        }\n    ]\n}\n```\n\n### 5. Generate Design Document\n\nCreate technical specifications with explicit architectural elements:\n\n```python\n# Execute this to generate comprehensive design structure\ndesign = {\n    \"overview\": \"High-level system description\",\n    \"architecture\": {\n        \"diagram\": \"ASCII or visual representation of all components\",\n        \"components\": [\n            {\n                \"id\": \"COMP-1\",\n                \"name\": \"Component Name\",\n                \"type\": \"Frontend/Backend/Service/Database\",\n                \"responsibility\": \"Single clear purpose\",\n                \"boundaries\": \"What it does and doesn't do\"\n            }\n        ]\n    },\n    \"data_flow\": {\n        \"primary_flows\": [\n            {\n                \"name\": \"User Registration Flow\",\n                \"steps\": [\n                    \"1. User submits form → Frontend\",\n                    \"2. Frontend validates → API Gateway\",\n                    \"3. API Gateway → Auth Service\",\n                    \"4. Auth Service → User Database\",\n                    \"5. Response flows back\"\n                ],\n                \"data_transformations\": \"How data changes at each step\"\n            }\n        ]\n    },\n    \"integration_points\": [\n        {\n            \"name\": \"External Payment API\",\n            \"type\": \"REST/GraphQL/WebSocket/Database\",\n            \"purpose\": \"Process payments\",\n            \"interface\": \"API contract definition\",\n            \"authentication\": \"Method used\",\n            \"error_handling\": \"Retry/fallback strategy\"\n        }\n    ],\n    \"components_detail\": [\n        {\n            \"name\": \"Component Name\",\n            \"responsibility\": \"What it does\",\n            \"key_classes\": [\"Class descriptions\"],\n            \"interfaces\": \"API/method signatures\",\n            \"dependencies\": \"What it needs to function\",\n            \"performance\": \"Targets and constraints\"\n        }\n    ],\n    \"data_models\": \"Entity definitions with relationships\",\n    \"system_boundaries\": {\n        \"in_scope\": [\"What the system handles\"],\n        \"out_of_scope\": [\"What it delegates or ignores\"],\n        \"assumptions\": [\"External dependencies assumed available\"]\n    },\n    \"error_handling\": \"Strategies for failures\",\n    \"testing_strategy\": \"Unit, integration, performance\",\n    \"deployment\": \"Docker, environment, configuration\"\n}\n```\n\n### 6. Generate Implementation Plan\n\nBreak down the project into executable tasks with clear scope boundaries:\n\n```python\n# Execute this to generate task structure with boundaries\ntasks = {\n    \"project_boundaries\": {\n        \"must_have\": [\"Core features for MVP\"],\n        \"nice_to_have\": [\"Enhancement features\"],\n        \"out_of_scope\": [\"Features explicitly excluded\"],\n        \"technical_constraints\": [\"Framework/library limitations\"]\n    },\n    \"phases\": [\n        {\n            \"id\": 1,\n            \"name\": \"Infrastructure Setup\",\n            \"deliverables\": [\"What this phase produces\"],\n            \"tasks\": [\n                {\n                    \"id\": \"1.1\",\n                    \"description\": \"Task description\",\n                    \"subtasks\": [\"Specific actions\"],\n                    \"requirements_fulfilled\": [\"REQ-1.1\", \"REQ-2.3\"],\n                    \"components_involved\": [\"COMP-1\", \"COMP-3\"],\n                    \"dependencies\": [],\n                    \"estimated_hours\": 4,\n                    \"success_criteria\": \"How to verify completion\"\n                }\n            ]\n        }\n    ]\n}\n```\n\n## Requirements Document Template\n\n```markdown\n# Requirements Document\n\n## Introduction\n\n[System description in 2-3 sentences. Target user and deployment model.]\n\n## Glossary\n\n- **Term**: Definition specific to this system\n- **Component**: Major system module or service\n[Add all domain-specific terms]\n\n## Requirements\n\n### Requirement [NUMBER]\n\n**User Story:** As a [user type], I want [capability], so that [benefit]\n\n#### Acceptance Criteria\n\n1. WHEN [trigger/condition], THE [component] SHALL [action/behavior]\n2. WHERE [mode/context], THE [component] SHALL [action/behavior]  \n3. IF [condition], THEN THE [component] SHALL [action/behavior]\n4. THE [component] SHALL [capability with measurable target]\n\n[Repeat for each requirement]\n```\n\n### Requirements Best Practices\n\n1. **One capability per requirement** - Each requirement should address a single feature\n2. **Testable criteria** - Every criterion must be verifiable\n3. **Use SHALL for mandatory** - Consistent RFC 2119 keywords\n4. **Include performance targets** - \"within X milliseconds/seconds\"\n5. **Specify all states** - Success, failure, edge cases\n6. **Number systematically** - REQ-1, REQ-2 for traceability\n\n### Acceptance Criteria Patterns\n\n```\nBehavior criteria:\n- WHEN [event occurs], THE system SHALL [respond]\n- THE system SHALL [provide capability]\n- THE system SHALL [enforce rule/limit]\n\nConditional criteria:\n- IF [condition], THEN THE system SHALL [action]\n- WHERE [mode is active], THE system SHALL [behavior]\n\nPerformance criteria:\n- THE system SHALL [complete action] within [time]\n- THE system SHALL support [number] concurrent [operations]\n- THE system SHALL maintain [metric] above/below [threshold]\n\nData criteria:\n- THE system SHALL persist [data type] with [attributes]\n- THE system SHALL validate [input] against [rules]\n- THE system SHALL return [data] in [format]\n```\n\n## Design Document Template\n\n```markdown\n# Design Document\n\n## Overview\n\n[System architecture summary in 3-4 sentences. Key design decisions and priorities.]\n\n## System Architecture\n\n### Component Map\n\n| Component ID | Name | Type | Responsibility | Interfaces With |\n|-------------|------|------|----------------|-----------------|\n| COMP-1 | Web Frontend | UI | User interface | COMP-2 |\n| COMP-2 | API Gateway | Service | Request routing | COMP-3, COMP-4 |\n| COMP-3 | Business Logic | Service | Core processing | COMP-5 |\n[Complete component inventory]\n\n### High-Level Architecture Diagram\n\n[ASCII diagram showing all components and their relationships]\n\n## Data Flow Specifications\n\n### Primary Data Flows\n\n#### 1. [Flow Name] (e.g., User Authentication)\n\n```\n1. [Source] → [Component]: [Data description]\n2. [Component] → [Component]: [Transformation applied]\n3. [Component] → [Destination]: [Final data format]\n```\n\n**Data Transformations:**\n- Step 2: [How data changes]\n- Step 3: [Validation/Processing applied]\n\n[Repeat for each major data flow]\n\n## Integration Points\n\n### Internal Integration Points\n\n| Source | Target | Protocol | Data Format | Purpose |\n|--------|--------|----------|-------------|---------|\n| Frontend | API Gateway | HTTPS/REST | JSON | API calls |\n| API Gateway | Auth Service | gRPC | Protobuf | Authentication |\n[All internal integrations]\n\n### External Integration Points\n\n#### [External System Name]\n\n**Type:** REST API / Database / Message Queue / etc.\n**Purpose:** [What this integration provides]\n**Endpoint:** [URL/Connection string pattern]\n**Authentication:** [Method - OAuth2, API Key, etc.]\n**Rate Limits:** [Any constraints]\n\n**Interface Contract:**\n```language\n// Request format\nPOST /api/endpoint\n{\n    \"field\": \"type\"\n}\n\n// Response format  \n{\n    \"result\": \"type\"\n}\n```\n\n**Error Handling:**\n- Retry strategy: [Exponential backoff, circuit breaker]\n- Fallback: [What happens if unavailable]\n- Monitoring: [How to detect issues]\n\n[Repeat for each external integration]\n\n## Components and Interfaces\n\n### 1. [Component Name]\n\n**Responsibility:** [Single sentence description]\n\n**Key Classes:**\n- `ClassName`: [Purpose and main methods]\n- `ServiceName`: [What it manages]\n\n**Interfaces:**\n```language\nclass InterfaceName:\n    def method_name(params) -> ReturnType\n    # Core methods only\n```\n\n**Data Flow:**\n- Receives [input] from [source]\n- Processes by [algorithm/logic]\n- Outputs [result] to [destination]\n\n**Performance:**\n- Target: [metric and value]\n- Constraints: [limitations]\n\n[Repeat for each major component]\n\n## Data Models\n\n### [Entity Name]\n```language\n@dataclass\nclass EntityName:\n    field: Type\n    field: Optional[Type]\n    # Core fields only\n```\n\n## Error Handling\n\n### [Error Category]\n**Types:** [List of error scenarios]\n**Handling:** [Strategy and recovery]\n\n## Testing Strategy\n\n### Unit Tests\n- [Component]: Test [aspects]\n- Coverage target: 80%\n\n### Integration Tests\n- [Flow]: Test [end-to-end scenario]\n\n### Performance Tests\n- [Operation]: Target [metric]\n\n## Deployment\n\n### Docker Configuration\n```yaml\n# Essential service definitions only\n```\n\n### Environment Variables\n```\nCATEGORY_VAR=description\n```\n\n## Performance Targets\n\n- [Operation]: <[time]\n- [Throughput]: >[rate]\n- [Resource]: <[limit]\n\n## Security Considerations\n\n- [Authentication method if applicable]\n- [Data protection approach]\n- [Access control model]\n```\n\n### Design Best Practices\n\n1. **Component responsibilities** - Single, clear purpose per component\n2. **Interface first** - Define contracts before implementation\n3. **Data flow clarity** - Show how data moves through system\n4. **Error categories** - Group related failures with consistent handling\n5. **Performance targets** - Specific, measurable goals\n6. **Deployment ready** - Include Docker and configuration\n\n## Implementation Plan Template\n\n```markdown\n# Implementation Plan\n\n- [x] 1. [Phase Name]\n  \n  - [x] 1.1 [Task name]\n    - [Subtask description]\n    - [Subtask description]\n    - _Requirements: [REQ-X.Y, REQ-A.B]_\n    \n  - [ ] 1.2 [Task name]\n    - [Subtask description]\n    - _Requirements: [REQ-X.Y]_\n    - _Dependencies: Task 1.1_\n\n- [ ] 2. [Phase Name]\n\n  - [ ] 2.1 [Task name]\n    - [Detailed steps or subtasks]\n    - _Requirements: [REQ-X.Y]_\n    - _Dependencies: Phase 1_\n\n[Continue for all phases]\n```\n\n### Task Planning Best Practices\n\n1. **Hierarchical structure** - Phases > Tasks > Subtasks\n2. **Requirement tracing** - Link each task to requirements\n3. **Dependency marking** - Identify blockers and prerequisites  \n4. **Checkbox format** - [x] for complete, [ ] for pending\n5. **Atomic tasks** - Each task independently completable\n6. **Progressive implementation** - Infrastructure → Core → Features → Polish\n\n### Common Implementation Phases\n\n```markdown\n1. **Infrastructure Setup**\n   - Project structure\n   - Database schema\n   - Docker configuration\n   - Core dependencies\n\n2. **Data Layer**\n   - Models/entities\n   - Database operations\n   - Migrations\n\n3. **Business Logic**\n   - Core algorithms\n   - Service classes\n   - Validation rules\n\n4. **API/Interface Layer**\n   - REST/GraphQL endpoints\n   - WebSocket handlers\n   - Authentication\n\n5. **Frontend/UI**\n   - Component structure\n   - State management\n   - API integration\n   - Responsive design\n\n6. **Integration**\n   - External services\n   - Third-party APIs\n   - Message queues\n\n7. **Testing**\n   - Unit tests\n   - Integration tests\n   - End-to-end tests\n\n8. **DevOps**\n   - CI/CD pipeline\n   - Monitoring\n   - Logging\n   - Deployment scripts\n\n9. **Documentation**\n   - API documentation\n   - User guides\n   - Deployment guide\n   - README\n```\n\n## Document Patterns by Project Type\n\n### Web Application (Full-Stack)\n\nRequirements focus:\n- User authentication and authorization\n- CRUD operations for entities\n- Real-time updates\n- Responsive UI\n- API design\n\nDesign focus:\n- 3-tier architecture (Frontend, Backend, Database)\n- REST/GraphQL API design\n- State management strategy\n- Component hierarchy\n- Database schema\n\nTasks focus:\n1. Database and backend setup\n2. API implementation\n3. Frontend components\n4. Integration and testing\n\n### Microservices System\n\nRequirements focus:\n- Service boundaries\n- Inter-service communication\n- Data consistency\n- Service discovery\n- Fault tolerance\n\nDesign focus:\n- Service decomposition\n- API contracts between services\n- Message queue/event bus\n- Distributed tracing\n- Container orchestration\n\nTasks focus:\n1. Service scaffolding\n2. Shared libraries/contracts\n3. Individual service implementation\n4. Integration layer\n5. Orchestration setup\n\n### Data Pipeline/ETL\n\nRequirements focus:\n- Data sources and formats\n- Transformation rules\n- Data quality checks\n- Schedule/triggers\n- Error handling and retry\n\nDesign focus:\n- Pipeline stages\n- Data flow diagram\n- Schema evolution\n- Monitoring and alerting\n- Storage strategy\n\nTasks focus:\n1. Data source connectors\n2. Transformation logic\n3. Validation and quality checks\n4. Scheduling setup\n5. Monitoring implementation\n\n### CLI Tool/Library\n\nRequirements focus:\n- Command structure\n- Input/output formats\n- Configuration options\n- Error messages\n- Performance requirements\n\nDesign focus:\n- Command parser architecture\n- Plugin system (if applicable)\n- Configuration management\n- Output formatters\n- Testing strategy\n\nTasks focus:\n1. Core command structure\n2. Business logic implementation\n3. Input/output handlers\n4. Configuration system\n5. Documentation and examples\n\n## Generating Documents for Specific Domains\n\n### Trading/Financial Systems\n\nAdditional requirements:\n- Risk management rules\n- Order execution logic\n- Market data handling\n- Compliance requirements\n- Audit trail\n\nAdditional design:\n- High-frequency data handling\n- Position tracking\n- Risk calculations\n- Order routing\n- Failover strategies\n\n### Real-time Systems (Chat, Gaming, IoT)\n\nAdditional requirements:\n- Latency targets\n- Connection handling\n- State synchronization\n- Offline support\n- Push notifications\n\nAdditional design:\n- WebSocket/SSE architecture\n- State management\n- Caching strategy\n- Message queuing\n- Horizontal scaling\n\n### Machine Learning Systems\n\nAdditional requirements:\n- Model training pipeline\n- Feature engineering\n- Model versioning\n- Prediction API\n- Monitoring/drift detection\n\nAdditional design:\n- Training infrastructure\n- Feature store\n- Model registry\n- Serving architecture\n- A/B testing framework\n\n## Quality Checklist\n\nBefore finalizing documents, verify:\n\n### Requirements Document\n- [ ] Every requirement has a clear user story\n- [ ] All acceptance criteria are testable\n- [ ] Non-functional requirements specified (performance, security)\n- [ ] Glossary covers all domain terms\n- [ ] Requirements are numbered for tracing\n\n### Design Document\n- [ ] Architecture diagram included\n- [ ] All components have clear responsibilities\n- [ ] Interfaces defined for integration points\n- [ ] Error handling strategy documented\n- [ ] Performance targets specified\n- [ ] Deployment configuration included\n\n### Implementation Plan\n- [ ] Tasks grouped into logical phases\n- [ ] Dependencies identified between tasks\n- [ ] Requirements traced to tasks\n- [ ] Tasks are atomic and completable\n- [ ] Checkbox format for progress tracking\n\n## Example Usage Patterns\n\n### Starting a New Project (With Explicit Architecture Focus)\n\n```\nUser: \"I want to build an order flow trading automation system\"\n\nResponse: \"I'll act as your Project Architect to create comprehensive planning documents. \n\nFirst, let me establish the architectural foundation:\n\n**System Components I need to define:**\n- Market data ingestion service\n- Order flow analysis engine  \n- Trading signal generator\n- Risk management module\n- Order execution service\n- Monitoring dashboard\n\n**Data Flows to map:**\n- Market data → Analysis → Signals → Execution\n- Position tracking → Risk calculation → Trading limits\n- All events → Audit trail\n\n**Integration Points to specify:**\n- Exchange APIs (which ones?)\n- Database system (time-series data needs?)\n- Notification services (alerts/reporting?)\n\n**Key Questions:**\n1. Is this for personal use (single-user) or a platform (multi-user)?\n2. Which specific exchanges/brokers will it connect to?\n3. What are your latency requirements (milliseconds matter)?\n4. What's your risk tolerance and position sizing approach?\n5. Do you need backtesting capabilities?\n\n**Deliverables I'll create:**\n1. Requirements document with traceable user stories\n2. System design with complete component map and data flows\n3. Implementation plan with phased delivery milestones\n\nThis architectural blueprint will ensure nothing is overlooked during implementation.\"\n```\n\n### Starting a New Project (Simple Approach)\n\n```\nUser: \"I want to build an order flow trading automation system\"\n\nResponse: \"I'll help you create comprehensive planning documents for your trading system. Let me gather some key information:\n\n1. Is this for personal use (single-user) or a multi-user platform?\n2. Which markets/exchanges will it connect to?\n3. What are the core trading strategies or patterns?\n4. Any specific performance requirements (latency, throughput)?\n\nBased on this, I'll generate:\n- Requirements document with user stories\n- System design with components and data flow\n- Implementation plan with phases and tasks\"\n```\n\n### Expanding Existing Requirements\n\n```\nUser: \"Add real-time monitoring dashboard to the requirements\"\n\nResponse: \"I'll add dashboard requirements to your document:\n\n### Requirement 15\n**User Story:** As a trader, I want a real-time dashboard, so that I can monitor system performance and trading activity\n\n#### Acceptance Criteria\n1. THE Dashboard SHALL display active positions with current P&L\n2. THE Dashboard SHALL update market data within 1 second\n3. THE Dashboard SHALL provide filtering by symbol, timeframe, and date range\n4. WHEN a trade executes, THE Dashboard SHALL reflect it within 100ms\"\n```\n\n## Common Pitfalls to Avoid\n\n### Planning Pitfalls\n1. **Skipping architectural planning** - Jumping to requirements without mapping components first\n2. **Vague role definition** - Not establishing the architect role leads to unfocused documentation\n3. **Hidden integration points** - Discovering external dependencies during implementation\n4. **Undefined boundaries** - No clear scope leads to feature creep and timeline slippage\n5. **Missing data flow analysis** - Not mapping how data moves reveals issues late\n\n### Requirements Pitfalls\n1. **Over-specifying implementation** - Requirements should define \"what\" not \"how\"\n2. **Vague acceptance criteria** - Avoid \"user-friendly\" or \"fast\" without metrics\n3. **Missing error cases** - Include failure scenarios in requirements\n4. **Untraceable requirements** - Every requirement should map to tasks\n\n### Design Pitfalls\n1. **Monolithic components** - Break down large components into focused services\n2. **Circular dependencies** - Ensure task dependencies form a DAG\n3. **Missing data models** - Define core entities early\n4. **Ignoring deployment** - Include Docker/deployment from the start\n5. **Unclear component boundaries** - Each component needs explicit responsibilities\n\n## Output Format\n\nGenerate documents in Markdown format for easy editing and version control. Use:\n- Clear hierarchical headings (##, ###, ####)\n- Code blocks with language hints\n- Bulleted and numbered lists\n- Tables for structured data\n- Checkboxes for task tracking\n- Bold for emphasis on key terms\n- Inline code for technical terms\n\nSave documents as:\n- `requirements.md` - Requirements document\n- `design.md` - Design document\n- `tasks.md` - Implementation plan\n\nThese documents serve as the foundation for AI-assisted implementation, providing clear specifications that can be referenced throughout development.\n"
      },
      "plugins": [
        {
          "name": "project-planner-skill",
          "source": "./project-planner-skill",
          "description": "Comprehensive project planning and documentation generator for software projects. Creates structured requirements documents, system design documents, and task breakdown plans with implementation tracking.",
          "version": "1.0.0",
          "author": {
            "name": "George A Puiu",
            "email": "puiu.adrian@gmail.com"
          },
          "keywords": [
            "project-planning",
            "documentation",
            "requirements",
            "design",
            "implementation"
          ],
          "category": "productivity",
          "strict": false,
          "categories": [
            "design",
            "documentation",
            "implementation",
            "productivity",
            "project-planning",
            "requirements"
          ],
          "install_commands": [
            "/plugin marketplace add adrianpuiu/claude-skills-marketplace",
            "/plugin install project-planner-skill@claude-skills-marketplace"
          ]
        }
      ]
    }
  ]
}