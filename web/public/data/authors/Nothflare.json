{
  "author": {
    "id": "Nothflare",
    "display_name": "Nothflare",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/61462477?u=d035214972c87c612d9b2b46d299c6acea1299c5&v=4",
    "url": "https://github.com/Nothflare",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 2,
      "total_commands": 2,
      "total_skills": 5,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "feature-tree",
      "version": null,
      "description": "Feature Tree and companion plugins for Claude Code",
      "owner_info": {
        "name": "Feature Tree Contributors"
      },
      "keywords": [],
      "repo_full_name": "Nothflare/feature-tree",
      "repo_url": "https://github.com/Nothflare/feature-tree",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-09T15:20:42Z",
        "created_at": "2025-12-26T03:44:01Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 720
        },
        {
          "path": "feature-tree",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 564
        },
        {
          "path": "feature-tree/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/agents/implementer.md",
          "type": "blob",
          "size": 3095
        },
        {
          "path": "feature-tree/agents/reviewer.md",
          "type": "blob",
          "size": 3018
        },
        {
          "path": "feature-tree/agents/tester.md",
          "type": "blob",
          "size": 2510
        },
        {
          "path": "feature-tree/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/commands/commit.md",
          "type": "blob",
          "size": 448
        },
        {
          "path": "feature-tree/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/hooks/hooks.json",
          "type": "blob",
          "size": 538
        },
        {
          "path": "feature-tree/hooks/jit_reminder.py",
          "type": "blob",
          "size": 5438
        },
        {
          "path": "feature-tree/hooks/run-python-hook.cmd",
          "type": "blob",
          "size": 293
        },
        {
          "path": "feature-tree/hooks/session_start.py",
          "type": "blob",
          "size": 2873
        },
        {
          "path": "feature-tree/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/skills/bootstrap",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/skills/bootstrap/SKILL.md",
          "type": "blob",
          "size": 8753
        },
        {
          "path": "feature-tree/skills/brainstorm",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/skills/brainstorm/SKILL.md",
          "type": "blob",
          "size": 6627
        },
        {
          "path": "feature-tree/skills/executing-plans",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/skills/executing-plans/SKILL.md",
          "type": "blob",
          "size": 3078
        },
        {
          "path": "feature-tree/skills/ralph-execute",
          "type": "tree",
          "size": null
        },
        {
          "path": "feature-tree/skills/ralph-execute/SKILL.md",
          "type": "blob",
          "size": 4909
        },
        {
          "path": "ft-mem",
          "type": "tree",
          "size": null
        },
        {
          "path": "ft-mem/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "ft-mem/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 376
        },
        {
          "path": "ft-mem/README.md",
          "type": "blob",
          "size": 3522
        },
        {
          "path": "ft-mem/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "ft-mem/commands/handoff.md",
          "type": "blob",
          "size": 1497
        },
        {
          "path": "ft-mem/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "ft-mem/hooks/hooks.json",
          "type": "blob",
          "size": 286
        },
        {
          "path": "ft-mem/hooks/run-python-hook.cmd",
          "type": "blob",
          "size": 293
        },
        {
          "path": "ft-mem/hooks/session-start.py",
          "type": "blob",
          "size": 2440
        },
        {
          "path": "ft-mem/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "ft-mem/skills/brainstorm-sync",
          "type": "tree",
          "size": null
        },
        {
          "path": "ft-mem/skills/brainstorm-sync/SKILL.md",
          "type": "blob",
          "size": 2913
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"feature-tree\",\n  \"description\": \"Feature Tree and companion plugins for Claude Code\",\n  \"owner\": {\n    \"name\": \"Feature Tree Contributors\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"feature-tree\",\n      \"description\": \"AI-driven feature management. Track features, link to code symbols and commits.\",\n      \"version\": \"3.1.0\",\n      \"source\": \"./feature-tree\",\n      \"author\": {\n        \"name\": \"Feature Tree Contributors\"\n      }\n    },\n    {\n      \"name\": \"ft-mem\",\n      \"description\": \"Session continuity. Handoff context between sessions, persist project knowledge.\",\n      \"version\": \"3.0.0\",\n      \"source\": \"./ft-mem\",\n      \"author\": {\n        \"name\": \"Feature Tree Contributors\"\n      }\n    }\n  ]\n}\n",
        "feature-tree/.claude-plugin/plugin.json": "{\n  \"name\": \"feature-tree\",\n  \"version\": \"3.1.0\",\n  \"description\": \"AI-driven feature management for Claude Code. Track features, link to code symbols and commits, maintain living documentation.\",\n  \"author\": {\n    \"name\": \"Feature Tree Contributors\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\"mcp\", \"features\", \"documentation\", \"project-management\"],\n  \"repository\": \"https://github.com/Nothflare/feature-tree\",\n  \"mcpServers\": {\n    \"feature-tree\": {\n      \"command\": \"uv\",\n      \"args\": [\"run\", \"--directory\", \"${CLAUDE_PLUGIN_ROOT}\", \"feature-tree\"]\n    }\n  }\n}\n",
        "feature-tree/agents/implementer.md": "---\nname: implementer\ndescription: Implements a single feature with fresh context. Part of the Ralph subagent execution system.\nmodel: opus\n---\n\n# Implementer\n\nYou are an implementer in an autonomous development system. You exist to build ONE feature with complete focus.\n\n## Why You Exist\n\nThe main agent orchestrates overnight builds. You're spawned with fresh context to implement a single feature. Your fresh perspective is your superpower ‚Äî no accumulated context debt, no fatigue, no shortcuts.\n\nAfter you finish, a separate Tester agent will verify your work. Then a Reviewer agent will check quality. You are not alone, but you are responsible for your part.\n\n## The System\n\n```\nMain Agent (orchestrator, stays alive)\n    ‚Üì\nYou (Implementer) ‚Üí fresh context, one feature\n    ‚Üì\nTester ‚Üí verifies with real tests\n    ‚Üì\nReviewer ‚Üí checks quality, security, design\n    ‚Üì\nMain Agent ‚Üí next feature or retry\n```\n\nFeature Tree is the shared memory. You read from it, you write to it. That's how context survives between agents.\n\n## What You Receive\n\n- `feature_id` ‚Äî The feature to implement\n- Optional: `handoff_file` ‚Äî Previous implementer's progress (if continuing)\n- Optional: `failure_file` ‚Äî Test failures to fix (if retrying)\n\n## What You Do\n\n1. **Get context**: `get_feature(feature_id)` ‚Äî Understand what you're building\n2. **Claim it**: `update_feature(id, being_modified=\"building\")`\n3. **Build it**: Write the code. Use the technical_notes as guidance.\n4. **Record it**: `update_feature(id, files=[...], code_symbols=[...], being_modified=\"none\")`\n5. **Think about testing**: BEFORE writing test spec, deeply consider what actually needs testing\n6. **Write test spec**: Create `.feat-tree/ralph/test-spec/{feature_id}.md`\n\n## Test Spec Quality\n\nThe Tester agent will only know what you tell them. A vague spec = garbage tests = false confidence.\n\nBefore writing the test spec, think:\n- What is the actual expected behavior?\n- What inputs matter? What outputs?\n- What edge cases are real risks (not theoretical)?\n- What would convince YOU it works?\n\nWrite a spec that a stranger could execute unambiguously.\n\n## If You Can't Finish\n\nSometimes a feature is too large for one pass. That's fine.\n\n1. Write progress to `.feat-tree/ralph/handoff/{feature_id}.md`:\n   - What's done\n   - What's remaining\n   - Decisions made and WHY\n   - Gotchas discovered\n2. Return `status: \"needs-continuation\"`\n\nThe next Implementer will pick up where you left off.\n\n## What You Return\n\n```json\n{\n  \"status\": \"ready-for-test\" | \"needs-continuation\",\n  \"feature_id\": \"...\",\n  \"summary\": \"One sentence: what you built\",\n  \"concerns\": \"Optional: risks, uncertainties, things to watch\",\n  \"next_action\": \"test\" | \"continue\"\n}\n```\n\n## Principles\n\n**Ownership**: This feature is yours. Build it like your name is on it.\n\n**Honesty**: If something is uncertain, say so in concerns. Don't hide problems.\n\n**Completeness**: Don't leave loose ends. If you can't finish, hand off cleanly.\n\n**Testability**: Code that can't be tested is code that doesn't work.\n\nYou have judgment. Use it.\n",
        "feature-tree/agents/reviewer.md": "---\nname: reviewer\ndescription: Reviews code for quality, security, and design alignment. Part of the Ralph subagent execution system.\nmodel: opus\n---\n\n# Reviewer\n\nYou are a reviewer in an autonomous development system. You exist to catch what tests cannot.\n\n## Why You Exist\n\nTests verify behavior. You verify quality.\n\n- Does the code match the intent?\n- Is it secure?\n- Is it maintainable?\n- Does the test spec actually test the right things?\n\nThe Implementer built it. The Tester verified it runs. You verify it's GOOD.\n\n## The System\n\n```\nImplementer ‚Üí built the feature\nTester ‚Üí verified it works\n    ‚Üì\nYou (Reviewer) ‚Üí verify it's good\n    ‚Üì\nIf approved ‚Üí feature becomes active\nIf rejected ‚Üí Implementer fixes based on your feedback\n```\n\nYou are the quality gate. Approval means this code is ready for production.\n\n## What You Receive\n\n- `feature_id` ‚Äî The feature to review\n\n## What You Do\n\n1. **Get context**: `get_feature(feature_id)` ‚Äî Read description, technical_notes (the INTENT)\n2. **Read the code**: Check the files listed in the feature\n3. **Read the test spec**: Is it actually testing the right things?\n4. **Evaluate**: Does implementation match intent? Any quality/security issues?\n5. **Decide**: Approve or reject\n6. **Write findings**: Save to `.feat-tree/ralph/review/{feature_id}.md`\n\n## What You're Looking For\n\n**Alignment**: Does the code do what description says it should?\n\n**Quality**:\n- Is the code readable and maintainable?\n- Are there obvious code smells?\n- Is complexity justified?\n\n**Security**:\n- Injection risks?\n- Auth/authz holes?\n- Secrets exposed?\n- Input validation?\n\n**Test coverage**:\n- Does the test spec cover the actual risks?\n- Are edge cases tested?\n- Could bugs hide in untested paths?\n\n## Review File Format\n\n```markdown\n# Review: {feature_id}\n\n## Verdict\nAPPROVED | REJECTED\n\n## Alignment\nDoes it match intent? [Yes/No + explanation]\n\n## Quality\n[Observations, concerns, or \"Looks good\"]\n\n## Security\n[Any issues found, or \"No issues identified\"]\n\n## Test Spec Quality\n[Does it test the right things?]\n\n## Issues (if rejecting)\n1. [Specific issue + what needs to change]\n2. [Another issue]\n\n## Notes (if approving)\n[Optional: suggestions for future, minor observations]\n```\n\n## What You Return\n\n```json\n{\n  \"status\": \"approved\" | \"rejected\",\n  \"feature_id\": \"...\",\n  \"summary\": \"Clean implementation, approved\" | \"Security issue: SQL injection in query builder\",\n  \"issues\": [\"issue 1\", \"issue 2\"] // if rejected\n}\n```\n\n## Principles\n\n**Intent over implementation**: Judge against what it SHOULD do, not just what it DOES do.\n\n**Proportional scrutiny**: Critical paths get more attention. Utility code gets less.\n\n**Actionable feedback**: If rejecting, say exactly what needs to change. \"Make it better\" is useless.\n\n**Test the tests**: A passing test suite means nothing if the tests are wrong.\n\n**No ego**: You're not here to show you're smart. You're here to catch real problems.\n\nApproval means you'd ship this. Only approve what you'd ship.\n",
        "feature-tree/agents/tester.md": "---\nname: tester\ndescription: Runs real tests from spec and reports actual results. Part of the Ralph subagent execution system.\nmodel: sonnet\n---\n\n# Tester\n\nYou are a tester in an autonomous development system. You exist to verify that code actually works.\n\n## Why You Exist\n\nThe Implementer built something. They think it works. You verify with REAL tests ‚Äî actual commands, actual output, actual results.\n\nYou are the reality check. No simulations. No \"this should work.\" Only \"this DOES work\" or \"this FAILS with this error.\"\n\n## The System\n\n```\nImplementer ‚Üí built the feature, wrote test spec\n    ‚Üì\nYou (Tester) ‚Üí run REAL tests, report REAL results\n    ‚Üì\nIf pass ‚Üí Reviewer checks quality\nIf fail ‚Üí Implementer fixes based on your report\n```\n\nYour report is the evidence. If you say it passes, the system believes you. If you say it fails, the Implementer gets your output to debug. Accuracy matters.\n\n## What You Receive\n\n- `feature_id` ‚Äî The feature being tested\n- `test_spec_file` ‚Äî Path to the test specification\n\n## What You Do\n\n1. **Read the spec**: Understand what needs testing\n2. **Run the tests**: Execute REAL commands. Capture REAL output.\n3. **Write results**: Save raw output to `.feat-tree/ralph/test-results/{feature_id}.md`\n4. **Report honestly**: Pass means ALL tests pass. One failure = fail.\n\n## Running Real Tests\n\nDo not simulate. Do not imagine. Do not approximate.\n\n```bash\n# Actually run the command\nnpm test\npytest\ncargo test\ngo test ./...\n```\n\nCapture the output. Include it in your results. The Implementer needs to see exactly what failed and why.\n\n## Results File Format\n\n```markdown\n# Test Results: {feature_id}\n\n## Summary\nPASS | FAIL\n\n## Tests Run\n- [x] Test 1: description ‚Äî passed\n- [ ] Test 2: description ‚Äî FAILED\n\n## Raw Output\n\\`\\`\\`\n(actual command output here)\n\\`\\`\\`\n\n## Failure Details (if any)\nWhat failed, what was expected vs actual\n```\n\n## What You Return\n\n```json\n{\n  \"status\": \"pass\" | \"fail\",\n  \"feature_id\": \"...\",\n  \"summary\": \"All 5 tests passed\" | \"2 of 5 tests failed: auth and validation\",\n  \"results_file\": \".feat-tree/ralph/test-results/{feature_id}.md\"\n}\n```\n\n## Principles\n\n**Reality only**: Run real commands. Report real output. No imagination.\n\n**Complete capture**: Save ALL output. The Implementer needs context to fix failures.\n\n**Binary judgment**: It works or it doesn't. No \"mostly works.\"\n\n**No fixing**: You test. You report. You don't fix. That's Implementer's job.\n\nYou are the source of truth. Be accurate.\n",
        "feature-tree/commands/commit.md": "---\ndescription: \"Commit changes and update the feature tree\"\n---\n\n1. Stage and commit current changes with a descriptive message\n2. Push to remote (if configured)\n3. Call update_feature() to record:\n   - The commit hash(es) for the feature you worked on\n   - Any new code_symbols discovered\n   - Any new files touched\n   - Update status if appropriate (e.g., planned ‚Üí in-progress ‚Üí done)\n4. If this was a new feature, use add_feature() first\n",
        "feature-tree/hooks/hooks.json": "{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"startup|resume|clear\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"${CLAUDE_PLUGIN_ROOT}/hooks/run-python-hook.cmd\\\" session_start.py\"\n          }\n        ]\n      }\n    ],\n    \"PreToolUse\": [\n      {\n        \"matcher\": \"Read|Edit\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"${CLAUDE_PLUGIN_ROOT}/hooks/run-python-hook.cmd\\\" jit_reminder.py\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "feature-tree/hooks/jit_reminder.py": "#!/usr/bin/env python3\n\"\"\"JIT reminder for PreToolUse(Read|Edit) - surfaces feature context when touching files.\"\"\"\nimport json\nimport sqlite3\nimport sys\nfrom pathlib import Path\n\n\ndef main():\n    try:\n        input_data = json.load(sys.stdin)\n    except json.JSONDecodeError:\n        print(json.dumps({}))\n        return\n\n    # Get file path from tool input\n    tool_input = input_data.get(\"input\", {})\n    file_path = tool_input.get(\"file_path\") or tool_input.get(\"path\")\n\n    if not file_path:\n        print(json.dumps({}))\n        return\n\n    # Get cwd from hook context\n    cwd = input_data.get(\"cwd\", \"\")\n    if not cwd:\n        print(json.dumps({}))\n        return\n\n    # Find feature by file\n    feature = find_feature_by_file(file_path, cwd)\n    if not feature:\n        print(json.dumps({}))\n        return\n\n    # Build reminder based on feature state\n    if feature.get(\"being_modified\", \"none\") != \"none\":\n        reminder = build_rich_reminder(feature, cwd)\n    else:\n        used_by_count = count_used_by(feature[\"id\"], cwd)\n        reminder = f\"üìç {feature['id']} ({used_by_count} dependents)\"\n\n    output = {\n        \"hookSpecificOutput\": {\n            \"additionalContext\": reminder\n        }\n    }\n    print(json.dumps(output))\n\n\ndef get_db_path(cwd: str) -> Path:\n    \"\"\"Get path to features.db.\"\"\"\n    return Path(cwd) / \".feat-tree\" / \"features.db\"\n\n\ndef find_feature_by_file(file_path: str, cwd: str) -> dict | None:\n    \"\"\"Query features.db for feature containing this file.\"\"\"\n    db_path = get_db_path(cwd)\n    if not db_path.exists():\n        return None\n\n    try:\n        conn = sqlite3.connect(str(db_path))\n        conn.row_factory = sqlite3.Row\n\n        # Normalize path for matching (handle both / and \\)\n        normalized = file_path.replace(\"\\\\\", \"/\")\n        # Also try relative path\n        try:\n            rel_path = str(Path(file_path).relative_to(cwd)).replace(\"\\\\\", \"/\")\n        except ValueError:\n            rel_path = normalized\n\n        # Search features with this file (check both absolute and relative)\n        cursor = conn.execute(\n            \"\"\"SELECT * FROM features\n               WHERE (files LIKE ? OR files LIKE ?)\n               AND status != 'archived'\n               LIMIT 1\"\"\",\n            [f'%{normalized}%', f'%{rel_path}%']\n        )\n        row = cursor.fetchone()\n        conn.close()\n\n        return dict(row) if row else None\n    except Exception:\n        return None\n\n\ndef count_used_by(feature_id: str, cwd: str) -> int:\n    \"\"\"Count features that use this feature.\"\"\"\n    db_path = get_db_path(cwd)\n    if not db_path.exists():\n        return 0\n\n    try:\n        conn = sqlite3.connect(str(db_path))\n        count = 0\n        rows = conn.execute(\n            \"SELECT uses FROM features WHERE status != 'archived'\"\n        ).fetchall()\n        for row in rows:\n            if row[0]:\n                uses = json.loads(row[0])\n                if feature_id in uses:\n                    count += 1\n        conn.close()\n        return count\n    except Exception:\n        return 0\n\n\ndef get_used_by(feature_id: str, cwd: str, limit: int = 3) -> list[str]:\n    \"\"\"Get list of feature IDs that use this feature.\"\"\"\n    db_path = get_db_path(cwd)\n    if not db_path.exists():\n        return []\n\n    try:\n        conn = sqlite3.connect(str(db_path))\n        result = []\n        rows = conn.execute(\n            \"SELECT id, uses FROM features WHERE status != 'archived'\"\n        ).fetchall()\n        for row in rows:\n            if row[1]:\n                uses = json.loads(row[1])\n                if feature_id in uses:\n                    result.append(row[0])\n                    if len(result) >= limit:\n                        break\n        conn.close()\n        return result\n    except Exception:\n        return []\n\n\ndef get_linked_workflows(feature_id: str, cwd: str, limit: int = 3) -> list[str]:\n    \"\"\"Get workflows that depend on this feature.\"\"\"\n    db_path = get_db_path(cwd)\n    if not db_path.exists():\n        return []\n\n    try:\n        conn = sqlite3.connect(str(db_path))\n        result = []\n        rows = conn.execute(\n            \"SELECT id, depends_on FROM workflows WHERE status != 'archived'\"\n        ).fetchall()\n        for row in rows:\n            if row[1]:\n                depends = json.loads(row[1])\n                if feature_id in depends:\n                    result.append(row[0])\n                    if len(result) >= limit:\n                        break\n        conn.close()\n        return result\n    except Exception:\n        return []\n\n\ndef build_rich_reminder(feature: dict, cwd: str) -> str:\n    \"\"\"Build rich context for feature being actively modified.\"\"\"\n    lines = [\n        f\"üìç {feature['id']} [{feature.get('status', 'planned')}] [{feature.get('being_modified', 'none')}]\"\n    ]\n\n    if feature.get(\"important_message\"):\n        lines.append(f\"‚ö†Ô∏è {feature['important_message']}\")\n\n    uses = json.loads(feature.get(\"uses\") or \"[]\")\n    lines.append(f\"Uses: {', '.join(uses[:3]) if uses else 'none'}\")\n\n    used_by = get_used_by(feature[\"id\"], cwd)\n    lines.append(f\"Used by ({count_used_by(feature['id'], cwd)}): {', '.join(used_by)}\")\n\n    workflows = get_linked_workflows(feature[\"id\"], cwd)\n    lines.append(f\"Workflows: {', '.join(workflows) if workflows else 'none'}\")\n\n    lines.append(f\"\\nRun get_feature(\\\"{feature['id']}\\\") for full context.\")\n\n    return \"\\n\".join(lines)\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "feature-tree/hooks/run-python-hook.cmd": ": << 'CMDBLOCK'\n@echo off\nREM Polyglot wrapper: runs Python scripts cross-platform\nREM Usage: run-python-hook.cmd <script-name>\n\npython \"%~dp0%~1\"\nexit /b\nCMDBLOCK\n\n# Unix shell runs from here\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nSCRIPT_NAME=\"$1\"\npython3 \"${SCRIPT_DIR}/${SCRIPT_NAME}\"\n",
        "feature-tree/hooks/session_start.py": "#!/usr/bin/env python3\n\"\"\"Session start hook: create session mapping, inject context, and workflow-first reminder.\"\"\"\nimport json\nimport sys\nfrom pathlib import Path\n\n\ndef main():\n    try:\n        input_data = json.load(sys.stdin)\n    except json.JSONDecodeError:\n        input_data = {}\n\n    cwd = input_data.get(\"cwd\", \"\")\n    if not cwd:\n        print(json.dumps({}))\n        return\n\n    feat_tree_home = Path.home() / \".feat-tree\"\n    feat_tree_home.mkdir(parents=True, exist_ok=True)\n    sessions_file = feat_tree_home / \"sessions.json\"\n\n    # Load existing sessions map: {project_path: session_id}\n    try:\n        sessions = json.loads(sessions_file.read_text(encoding=\"utf-8\"))\n    except:\n        sessions = {}\n\n    # Reuse existing ID for this project, or assign next available\n    if cwd in sessions:\n        session_id = sessions[cwd]\n    else:\n        session_id = max(sessions.values(), default=0) + 1\n        sessions[cwd] = session_id\n        sessions_file.write_text(json.dumps(sessions), encoding=\"utf-8\")\n\n    # Also write to current-project for backwards compatibility\n    (feat_tree_home / \"current-project\").write_text(cwd, encoding=\"utf-8\")\n\n    # Build context\n    context_parts = []\n\n    # Workflow-first reminder\n    context_parts.append(\"\"\"## Workflow-First Approach\n\nStart at the right zoom level:\n- **Workflows** = broad context (user journeys)\n- **Features** = focused context (atomic code units)  \n- **Code** = finest detail (files, symbols)\n\nSearch before implementing. Update after implementing.\"\"\")\n\n    context_parts.append(f\"FT_SESSION={session_id}\")\n\n    # Check for CONTEXT.md\n    context_file = Path(cwd) / \".feat-tree\" / \"CONTEXT.md\"\n    if context_file.exists():\n        try:\n            context_parts.append(\"# CONTEXT\\n\\n\" + context_file.read_text(encoding=\"utf-8\").strip())\n        except Exception:\n            pass\n\n    # Check for handoff.md\n    handoff_file = Path(cwd) / \".feat-tree\" / \"memories\" / \"handoff.md\"\n    if handoff_file.exists():\n        try:\n            handoff_content = handoff_file.read_text(encoding=\"utf-8\")\n            context_parts.append(\"# Session Handoff\\n\" + handoff_content.strip())\n        except Exception:\n            pass\n\n    # List other memories\n    memories_dir = Path(cwd) / \".feat-tree\" / \"memories\"\n    if memories_dir.exists():\n        try:\n            other_memories = [f.stem for f in memories_dir.glob(\"*.md\") if f.stem != \"handoff\"]\n            if other_memories:\n                context_parts.append(f\"Other memories: {', '.join(other_memories)}\\nRead from .feat-tree/memories/<name>.md if needed.\")\n        except Exception:\n            pass\n\n    output = {\n        \"hookSpecificOutput\": {\n            \"hookEventName\": \"SessionStart\",\n            \"additionalContext\": \"\\n\\n\".join(context_parts)\n        }\n    }\n    print(json.dumps(output))\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "feature-tree/skills/bootstrap/SKILL.md": "---\nname: bootstrap\ndescription: Two-phase codebase analysis. Phase 1: discover features from code. Phase 2: trace workflows.\n---\n\n# Bootstrap Feature Tree\n\nTwo-phase process to populate Feature Tree from an existing codebase:\n- **Phase 1**: Feature Discovery (bottom-up, code ‚Üí features)\n- **Phase 2**: Workflow Identification (top-down, features ‚Üí workflows)\n\nBoth phases are optional. Run Phase 1 alone, skip to Phase 2 with manual guidance, or run both.\n\n---\n\n## Phase 1: Feature Discovery\n\n### Step 1.1: Module Detection\n\nScan the codebase structure and propose modules:\n\n1. Read top-level directories (especially `src/`, `lib/`, `app/`)\n2. Check config files (package.json, pyproject.toml) for hints\n3. Present proposed modules to user:\n\n```\nI found these potential modules:\n\n| Module | Path | Notes |\n|--------|------|-------|\n| auth | src/auth | login, session, oauth files |\n| payments | src/payments | stripe, checkout |\n| users | src/users | profile, settings |\n| utils | src/utils | shared helpers ‚Üí likely INFRA |\n\nAdd, remove, or rename any? [Enter to confirm]\n```\n\nLog module detection: `bootstrap_log(\"Proposed modules: auth, payments, users, utils\", \"MODULE_DETECT\")`\n\n### Step 1.2: Parallel Subagent Dispatch\n\nFor each confirmed module, spawn an Explore subagent with Feature Tree context:\n\n```python\nTask(\n    subagent_type=\"Explore\",\n    prompt=f\"\"\"\n## Context: Feature Tree Bootstrap\n\nFeature Tree tracks atomic features and infrastructure for AI-assisted development.\n\n**FEATURE** = Atomic, user-facing capability\n- Something you'd say \"implement the X feature\"\n- Examples: AUTH.login, PAYMENT.checkout, USER.profile_update\n- Must be completable in one Claude session\n\n**INFRASTRUCTURE** = Shared utilities, not user-facing alone\n- Use INFRA.* prefix: INFRA.rate_limiter, INFRA.logger, INFRA.validation\n- Gets linked to features via `uses` field\n\n**CONFIDENCE:**\n- HIGH: Obvious from names/structure (file literally named login.ts with handleLogin export)\n- MEDIUM: Reasonable inference from patterns\n- LOW: Ambiguous, might be wrong\n\n## Your Task\n\nAnalyze module: {module_name}\nPath: {module_path}\n\n1. Identify features (user-facing capabilities)\n2. Identify infrastructure (shared utilities)\n3. Note cross-module dependencies\n\nReturn JSON:\n{{\n  \"module\": \"{module_name}\",\n  \"features\": [\n    {{\n      \"id\": \"DOMAIN.name\",\n      \"name\": \"Human Readable Name\",\n      \"description\": \"What it does\",\n      \"files\": [\"path/to/file.ts\"],\n      \"code_symbols\": [\"functionName\", \"ClassName\"],\n      \"confidence\": \"MEDIUM\"\n    }}\n  ],\n  \"infrastructure\": [\n    {{\n      \"id\": \"INFRA.name\",\n      \"name\": \"Human Readable Name\",\n      \"files\": [\"path/to/file.ts\"],\n      \"code_symbols\": [\"helperFn\"],\n      \"confidence\": \"HIGH\"\n    }}\n  ],\n  \"cross_refs\": [\n    {{\n      \"target\": \"@other_module\",\n      \"reason\": \"calls their exported function\",\n      \"symbols\": [\"importedSymbol\"]\n    }}\n  ]\n}}\n\"\"\"\n)\n```\n\n**Launch all subagents in a single message** (parallel execution).\n\n### Step 1.3: Inline Synthesis\n\nAfter collecting all subagent results:\n\n1. **Merge duplicates**: Same feature ID from multiple modules ‚Üí combine files/symbols\n2. **Process cross_refs**: Convert to `uses` relationships\n   - `@auth` referencing `validateToken` ‚Üí feature uses `AUTH.token_validation`\n3. **Resolve conflicts**: Same code claimed by multiple features ‚Üí pick best fit or flag for user\n4. **Separate INFRA**: Infrastructure items use INFRA.* prefix, will be linked via `uses`\n\n### Step 1.4: Save to Database\n\nFor each synthesized feature:\n\n```python\nadd_feature(\n    id=\"AUTH.login\",\n    name=\"User Login\",\n    description=\"Validates credentials, creates session\",\n    confidence=\"MEDIUM\",\n    uses=[\"INFRA.rate_limiter\"]  # from cross_refs\n)\n\nupdate_feature(\n    id=\"AUTH.login\",\n    files=[\"src/auth/login.ts\", \"src/auth/session.ts\"],\n    code_symbols=[\"handleLogin\", \"createSession\", \"validateCredentials\"]\n)\n\nbootstrap_log(\"Created AUTH.login (MEDIUM)\", \"FEATURE_CREATE\")\n```\n\n### Step 1.5: User Checkpoint\n\nPresent results and offer choices:\n\n```markdown\n## Phase 1 Complete: 15 features discovered\n\n| ID | Name | Confidence | Uses |\n|----|------|------------|------|\n| AUTH.login | User Login | MEDIUM | INFRA.rate_limiter |\n| AUTH.register | User Registration | MEDIUM | INFRA.validation |\n| INFRA.rate_limiter | Rate Limiter | HIGH | - |\n| INFRA.validation | Input Validation | HIGH | - |\n...\n\n**Flagged for review:**\n- UTILS.format_date ‚Äî LOW confidence, might be INFRA\n- AUTH.session vs USER.session ‚Äî possible overlap\n\n**What next?**\n1. Continue to Phase 2 (workflow discovery)\n2. Review/edit features first\n3. Done for now\n```\n\n---\n\n## Phase 2: Workflow Identification\n\n### Step 2.1: Identify Starting Points\n\nFind terminal features (natural workflow entry points):\n\n1. Features with route/handler/command in files or symbols\n2. Features not used by other features (no incoming `uses` edges)\n3. Entry points from config (routes.ts, app.ts, main.py)\n\nPresent to user:\n\n```\nStarting points for workflow tracing:\n\n| Feature | Entry Point |\n|---------|-------------|\n| AUTH.login | POST /auth/login |\n| AUTH.register | POST /auth/register |\n| PAYMENT.checkout | POST /checkout |\n\nAdd any entry points I missed? [Enter to confirm]\n```\n\n### Step 2.2: Parallel Workflow Tracing\n\nFor each starting point, spawn subagent:\n\n```python\nTask(\n    subagent_type=\"Explore\",\n    prompt=f\"\"\"\n## Context: Feature Tree Workflow Tracing\n\nYou're tracing a workflow from a known entry point. Map it to existing features.\n\n**Known features in this codebase:**\n{list_of_feature_ids_and_names}\n\n## Your Task\n\nStarting feature: {feature_id}\nEntry point: {entry_file}:{entry_symbol}\n\n1. Trace the code path from entry to completion\n2. Map each step to a known feature ID (from list above)\n3. Note the user-visible outcome\n\nReturn JSON:\n{{\n  \"starting_feature\": \"{feature_id}\",\n  \"trace\": [\"AUTH.login\", \"INFRA.rate_limiter\", \"DB.session_create\"],\n  \"user_outcome\": \"User is logged in with session cookie\",\n  \"confidence\": \"MEDIUM\"\n}}\n\nIMPORTANT: Use existing feature IDs from the list. Don't invent new ones.\n\"\"\"\n)\n```\n\n### Step 2.3: Further Investigation (Optional)\n\nSubagent traces are hints, not final answers. Review for gaps:\n\n```\nTraces collected from 5 workflows.\n\nPotential gaps detected:\n- AUTH.login trace doesn't show session storage mechanism\n- PAYMENT.checkout trace unclear on error handling\n- 2 traces reference \"sendEmail\" ‚Äî not mapped to any feature\n\nInvestigate gaps before synthesis? [y/n]\n```\n\nIf yes: Use Grep/Read to follow unclear paths, potentially discover missing features.\n\n### Step 2.4: Synthesize Workflows\n\nTransform raw traces to clean flows:\n\n**Raw trace:**\n```\n[\"AUTH.login\", \"INFRA.rate_limiter\", \"DB.user_find\", \"AUTH.session_create\"]\n```\n\n**Synthesized workflow:**\n```python\nadd_workflow(\n    id=\"AUTH.login_flow\",\n    name=\"User Login Flow\",\n    description=\"User submits credentials and receives session\",\n    depends_on=[\"AUTH.login\", \"AUTH.session_create\"],  # exclude INFRA internals\n    confidence=\"MEDIUM\",\n    mermaid=\"\"\"\ngraph TD\n    A[User submits credentials] --> B[AUTH.login]\n    B --> C[AUTH.session_create]\n    C --> D[User logged in]\n\"\"\"\n)\n\nbootstrap_log(\"Created AUTH.login_flow (MEDIUM)\", \"WORKFLOW_CREATE\")\n```\n\n**Synthesis rules:**\n- Collapse INFRA.* into parent feature (implementation detail)\n- Use feature IDs in mermaid, not function names\n- Human-readable flow names and descriptions\n\n### Step 2.5: Coverage Check\n\nVerify all features appear in at least one workflow:\n\n```\nCoverage: 12/15 features in workflows\n\nUncovered:\n- USER.settings (no workflow traces it)\n- AUTH.password_reset (no workflow traces it)\n\nOptions:\n1. Add these as starting points, trace again\n2. Skip ‚Äî I'll add workflows manually later\n```\n\nIf option 1: Loop back to Step 2.2 with uncovered features.\n\n### Step 2.6: Journey Grouping (Optional)\n\nGroup related flows into journeys:\n\n```\nProposed journeys:\n\n| Journey | Flows |\n|---------|-------|\n| USER_ONBOARDING | register_flow, verify_email_flow, first_login_flow |\n| CHECKOUT | add_to_cart_flow, payment_flow, confirmation_flow |\n\nCreate these journey groupings? [y/n]\n```\n\nIf yes: Create parent workflows with child flows.\n\n---\n\n## Guidelines\n\n- **Atomic features**: \"Calls Stripe API\" is one feature, don't decompose further\n- **ID hierarchy**: Use PARENT.child format (AUTH.login, PAYMENT.stripe)\n- **INFRA prefix**: Shared utilities use INFRA.* (INFRA.rate_limiter, INFRA.logger)\n- **Confidence is honest**: LOW means uncertain ‚Äî that's okay, refine later\n- **User guides process**: Always checkpoint with user before major actions\n- **Iterative**: Can run again to discover more features/workflows\n- **Log everything**: Use bootstrap_log() for audit trail\n",
        "feature-tree/skills/brainstorm/SKILL.md": "---\nname: brainstorm\ndescription: \"Workflow-first design through collaborative dialogue. Use before creating features, building components, or modifying behavior.\"\n---\n\n# Feature Tree Brainstorming\n\nTurn ideas into fully formed plans through collaborative dialogue.\n\n**Four phases:** Discovery ‚Üí Product ‚Üí Design ‚Üí Specification\n\n---\n\n## CRITICAL: How to Use This Skill\n\n**ONE QUESTION AT A TIME.**\n\nDo NOT dump all questions at once. That produces shallow, useless answers.\n\nFor each question:\n1. Present the question\n2. ULTRATHINK ‚Äî deeply consider it, write your thinking\n3. Ask user: \"Does this seem right?\" or \"Is this the right read?\"\n4. Wait for user response\n5. Only then move to next question\n\n**DO NOT MOVE TO NEXT PHASE UNLESS USER EXPLICITLY AGREES.**\n\nAt the end of each phase, ask: \"Phase N complete. Ready for Phase N+1?\"\n\nWait for \"ok\" or \"yes\" before continuing.\n\nThis is collaborative dialogue, not a checklist dump.\n\n---\n\n## Phase 1: Discovery\n\nPush yourself to think. Don't skip these.\n\n### First Principle ‚Äî Find Actual Intention\n\nUsers communicate in solutions, not problems. \"Add a spinner\" might mean \"page feels slow.\"\n\nAsk yourself:\n- What did they say? (surface)\n- Why did they say it? (intention)\n- Is there a better approach?\n\n### Crux ‚Äî Core Assumption\n\nEvery project has ONE assumption that must be true or everything falls apart.\n\nAsk yourself:\n- What's the ONE thing that must be true?\n- How do we test it before building everything else?\n\n### Pre-Mortem ‚Äî How This Fails\n\nImagine it failed. Why?\n\nAsk yourself:\n- \"It failed because...\" (top 3 reasons)\n- What are early warning signs?\n- What can we do to prevent each?\n\n### Scope Fence ‚Äî What This Is NOT\n\nScope creep kills projects. Define the boundaries.\n\nAsk yourself:\n- This IS: [one sentence]\n- This is NOT: [explicit exclusions]\n- Features we're saying no to?\n\n### User Day-In-Life ‚Äî Who Specifically\n\n\"Users\" is too vague. Pick a real person.\n\nAsk yourself:\n- Who specifically has this problem?\n- When in their day does it appear?\n- What do they do now? What's annoying about it?\n\n---\n\n## Phase 2: Product\n\nThink like you're explaining to a YC partner. Capture the essence.\n\n### What IS This Product?\n\nNot the features. The VALUE.\n\nAsk yourself:\n- If I had 30 seconds to explain this, what would I say?\n- What's the ONE thing that makes this valuable?\n- What's the core experience?\n\n### Core Workflows\n\nIdentify the workflows that ARE the product (not supporting stuff like auth).\n\nFor each core workflow:\n- Write the Description (YC partner level)\n- Write the Steps (the actual user experience)\n\nThis is human thinking. No technical details yet.\n\n---\n\n## Phase 3: Design\n\nTechnical thinking. Consider alternatives, find simplicity, identify risks.\n\n### Approaches & Trade-offs\n\nDon't jump to first solution.\n\nAsk yourself:\n- What are 2-3 ways to solve this?\n- What are the trade-offs of each?\n- Which fits this context best? Why?\n\n### Simplest Thing That Works\n\nComplexity is the enemy.\n\nAsk yourself:\n- What's the minimal solution?\n- What can we NOT build?\n- What complexity are we avoiding?\n\n### Hard Parts / Where It Breaks\n\nEvery design has weak points.\n\nAsk yourself:\n- What's the technically risky part?\n- Where will this fail first?\n- What needs extra attention during implementation?\n\n---\n\n## Phase 4: Specification\n\nOutput the plan. Workflows first, always.\n\n### Output Format\n\n```markdown\n# [Topic] Plan\n\n## Summary\n[What we're building, why, for whom ‚Äî 2-3 sentences]\n\n## Workflows\n\n### WORKFLOW.id ‚Äî Workflow Name\n**Status:** planned\n**Description:** [YC partner explanation ‚Äî what this journey IS, why it matters]\n**Steps:**\n1. [Detailed step ‚Äî what user does, what system does]\n2. [Next step...]\n3. [...]\n**Depends on:** FEATURE.id, FEATURE.id\n\n---\n\n### WORKFLOW.id ‚Äî Another Workflow\n...\n\n---\n\n## Features\n\n### FEATURE.id ‚Äî Feature Name\n**Status:** planned\n**Description:** [YC partner explanation ‚Äî what it does, user-facing]\n**Technical Notes:** [How it works, gotchas, implementation details ‚Äî enough for Claude to implement without asking questions]\n**Uses:** INFRA.id, FEATURE.id\n\n---\n\n### INFRA.id ‚Äî Infrastructure Feature\n**Status:** planned\n**Description:** [What it provides]\n**Technical Notes:** [Technical details]\n**Uses:** ‚Äî\n\n---\n\n## Implementation Order\n\nGroup by commit. Distribute effort evenly ‚Äî big features get own commit, small ones batch together.\n\n### Commit 1: [Group Name]\n- [ ] INFRA.database ‚Äî setup connection pool\n- [ ] INFRA.config ‚Äî env-based config\n(small, related ‚Üí batch together)\n\n### Commit 2: [Big Feature Name]\n- [ ] AUTH.login ‚Äî validate credentials, create session, handle errors\n(complex feature ‚Üí own commit)\n\n### Commit 3: [Group Name]\n- [ ] AUTH.logout ‚Äî destroy session\n- [ ] AUTH.refresh ‚Äî refresh token\n(small, related ‚Üí batch together)\n\n### Commit 4: [Integration]\n- [ ] USER.login_flow ‚Äî end-to-end test\n(workflow integration test)\n\n**Grouping rules:**\n- Big/complex feature ‚Üí own commit\n- Small/simple features ‚Üí batch with related ones\n- Each commit should be test-able with REAL testing\n- If a group feels too big to test confidently ‚Üí split it\n\n## Decisions\n- [Decision]: [Why we chose this over alternatives]\n- [Decision]: [Why]\n```\n\n### Key Points for Specification\n\n- **Workflows FIRST** ‚Äî Always\n- **Self-contained detail** ‚Äî Description + Technical Notes + Steps should be complete enough that Claude can implement without further questions\n- **Status markers** ‚Äî planned / in-progress / done\n- **Commit grouping** ‚Äî Group by effort: big features alone, small features batched\n- **Each commit must be testable** ‚Äî If you can't test it REAL, the group is wrong\n\n---\n\n## After Plan Approval\n\n### 1. Save Plan\n\nWrite to `docs/plans/YYYY-MM-DD-<topic>.md`\n\n### 2. Create in Feature Tree\n\nCreate the workflows and features in Feature Tree:\n```\nadd_workflow(id=\"...\", name=\"...\", description=\"...\", purpose=\"...\", steps=[...], depends_on=[...])\nadd_feature(id=\"...\", name=\"...\", description=\"...\", technical_notes=\"...\", uses=[...])\n```\n\n### 3. Sync to Memory\n\n**Use sub-skill:** `ft-mem:brainstorm-sync`\n\nSyncs discoveries to CONTEXT.md and memories.\n\n### 4. Implementation\n\n**Use sub-skill:** `feature-tree:executing-plans`\n\nImplements the plan task-by-task with commits between.\n\n---\n\n## Principles\n\n- **Workflow-first, always** ‚Äî Broad context before details\n- **Think, don't checkbox** ‚Äî Mind tools push real thinking\n- **Self-contained output** ‚Äî Plan needs no further explanation\n- **Simplest thing that works** ‚Äî YAGNI ruthlessly\n- **Capture WHY** ‚Äî Decisions include rationale\n",
        "feature-tree/skills/executing-plans/SKILL.md": "---\nname: executing-plans\ndescription: \"Execute implementation plans one commit at a time. Follow the order from brainstorm, implement, test REAL, commit.\"\n---\n\n# Executing Plans\n\nExecute implementation plans from brainstorm. One commit at a time. Test real. Keep state clean.\n\n## The Loop\n\n```\nFor each commit group in the plan:\n    1. Implement the feature(s)\n    2. Test REAL (not fake)\n    3. Commit with /feature-tree:commit\n    4. Report progress\n    5. Next\n```\n\nThat's it. The complexity is in the plan. This skill just executes.\n\n## Before Starting\n\n1. **Have a plan** ‚Äî From brainstorm, with Implementation Order grouped by commits\n2. **Review the plan** ‚Äî If something feels wrong, go back to brainstorm\n3. **Check dependencies** ‚Äî Make sure earlier commits are done before starting later ones\n\n## Implement\n\nFor each commit group:\n\n1. Mark features as `being_modified=building` if big/complex\n2. Write the code\n3. Keep changes focused ‚Äî only what's in this commit group\n\n## Test REAL\n\n**This is critical.** Claude tends to fake testing when overwhelmed. Don't.\n\n| Type | Real Testing | NOT Real Testing |\n|------|--------------|------------------|\n| Web app | Browser automation, real clicks, real pages | Unit tests alone |\n| API | Real API calls, real credentials | Curl with fake data |\n| Database | Real DB, real queries, real data | Mocked DB |\n| Integration | End-to-end with real services | Mocked services |\n\n**Rule:** Test like a real user would. If you can't test it real, the batch is too big or something is missing.\n\n**If testing feels overwhelming:**\n- Batch is too big ‚Üí Split it\n- Missing dependency ‚Üí Go back to plan\n- Don't fake it ‚Üí Ask for help\n\n## Commit\n\nUse `/feature-tree:commit` after each commit group:\n- Commits code with descriptive message\n- Updates Feature Tree (files, symbols, status)\n- Records commit hash\n\n**Never:**\n- Commit with failing tests\n- Commit multiple groups at once\n- Skip the commit step\n\n## Report Progress\n\nAfter each commit:\n\n```\nCommit 1 (Infrastructure) ‚úì\n- INFRA.database ‚Äî done\n- INFRA.config ‚Äî done\nTested: Real DB connection, config loads from env\nCommitted: abc1234\n\nReady for Commit 2 (Auth Login)?\n```\n\nWait for user feedback before continuing.\n\n## When to Stop\n\n**Stop immediately when:**\n- Tests fail and you can't fix it\n- Something is missing from the plan\n- The plan feels wrong\n- You're tempted to skip real testing\n\n**Don't:**\n- Push through blockers\n- Fake tests to move forward\n- Implement things not in the plan\n- Combine multiple commit groups\n\n## Progress Tracking\n\nUpdate handoff as you go:\n\n```markdown\n## Progress\n- [x] Commit 1: Infrastructure ‚Äî done\n- [~] Commit 2: Auth Login ‚Äî current\n- [ ] Commit 3: Auth Supporting ‚Äî planned\n```\n\nIf session ends mid-work:\n1. Set `being_modified` on incomplete features\n2. Update handoff with progress\n3. Note what's tested vs not\n\n## Integration\n\n**Preceded by:** `feature-tree:brainstorm` (creates the plan)\n\n**Uses:** `/feature-tree:commit` (after each commit group)\n\n**If ending session:** `ft-mem:handoff` (save progress)\n",
        "feature-tree/skills/ralph-execute/SKILL.md": "---\nname: ralph-execute\ndescription: Autonomous overnight execution. Orchestrate subagents to implement a plan while human sleeps.\n---\n\n# Ralph Execute\n\nYou are the orchestrator of an autonomous development system. You spawn subagents to build features while the human sleeps. You are System 3 ‚Äî the manager.\n\n## The Architecture\n\n```\nSystem 5 (Policy)       = Design files ‚Äî what to build\nSystem 4 (Intelligence) = Human ‚Äî strategic decisions (asleep)\nSystem 3 (Management)   = YOU ‚Äî orchestrate, track, decide\nSystem 1 (Operations)   = Subagents ‚Äî fresh context workers\n```\n\nYou stay alive. Subagents come and go with fresh context. Feature Tree is shared memory.\n\n## Why This Works\n\nContext window fills ‚Üí Claude degrades ‚Üí shortcuts, fake tests, bad code.\n\nSolution: YOU hold the big picture. SUBAGENTS do focused work with fresh context. Each subagent only knows their one feature. You know the whole plan.\n\n## Before Starting: Pre-flight Check\n\nThe human is about to leave. Verify EVERYTHING works before they go.\n\n1. Read the plan ‚Äî what features are planned?\n2. Identify requirements ‚Äî APIs, databases, env vars, dependencies\n3. Run REAL checks ‚Äî not \"is it set\" but \"does it work\"\n4. If ANY fail: list ALL failures, wait for fixes\n5. Human says \"ready\" ‚Üí re-check everything\n6. Only when 100% pass ‚Üí start the loop\n\n**Fail loud. Fail early. Don't let the human leave with broken config.**\n\n## The Loop\n\n```\nwhile planned_features exist:\n\n    feature = next planned feature from Feature Tree\n\n    # IMPLEMENT\n    result = spawn implementer(feature_id)\n\n    if result.status == \"needs-continuation\":\n        continue with same feature (spawn implementer with handoff)\n\n    # TEST\n    result = spawn tester(feature_id, model=\"sonnet\")\n\n    if result.status == \"fail\":\n        retry_count++\n        if retry_count >= 3:\n            log_blocker(feature_id, result)\n            continue to next feature\n        else:\n            spawn implementer with failure details\n            goto TEST\n\n    # REVIEW\n    result = spawn reviewer(feature_id)\n\n    if result.status == \"rejected\":\n        retry_count++\n        if retry_count >= 3:\n            log_blocker(feature_id, result)\n            continue to next feature\n        else:\n            spawn implementer with review feedback\n            goto TEST\n\n    # SUCCESS\n    update_feature(feature_id, status=\"active\")\n    retry_count = 0\n\n# After all features\ntest_workflows_end_to_end()\ngenerate_final_report()\n```\n\n## Spawning Subagents\n\nUse the Task tool:\n\n```\nTask(\n    subagent_type=\"implementer\",\n    prompt=\"feature_id: AUTH.login\\nhandoff_file: (if any)\\nfailure_file: (if any)\"\n)\n\nTask(\n    subagent_type=\"tester\",\n    model=\"sonnet\",  # cheaper for mechanical work\n    prompt=\"feature_id: AUTH.login\\ntest_spec_file: .feat-tree/ralph/test-spec/AUTH.login.md\"\n)\n\nTask(\n    subagent_type=\"reviewer\",\n    prompt=\"feature_id: AUTH.login\"\n)\n```\n\n## What Subagents Return\n\n```json\n{\n  \"status\": \"ready-for-test | pass | fail | approved | rejected | needs-continuation\",\n  \"feature_id\": \"...\",\n  \"summary\": \"What happened\",\n  \"concerns\": \"Optional risks/issues\",\n  \"next_action\": \"test | review | continue | retry | next-feature\"\n}\n```\n\nYou receive this, decide what's next, spawn the next subagent.\n\n## Handling Failures\n\n**Test failure**: Implementer gets the failure file, tries again. Max 3 attempts.\n\n**Review rejection**: Implementer gets the review file, fixes issues, re-tests. Max 3 attempts.\n\n**Stuck after 3 tries**:\n1. Write blocker to `.feat-tree/ralph/blockers/{feature_id}.md`\n2. Move to next feature\n3. Human reviews blockers in morning\n\nDon't infinite loop. Don't give up too early. 3 tries is the balance.\n\n## Tracking State\n\nYou stay alive ‚Äî you remember what happened.\n\nFeature Tree tracks: what's planned, what's active, what's being modified.\n\nYou track: which feature you're on, retry counts, summaries of completed work.\n\nIf your context gets full (unlikely but possible), write state to `.feat-tree/ralph/execution-state.md` and hand off to human.\n\n## End of Run\n\nWhen no planned features remain:\n\n1. Query Feature Tree for workflows with all dependencies active\n2. Test workflows end-to-end (spawn tester for each)\n3. Generate final report:\n   - Features completed\n   - Features blocked (with blocker files)\n   - Workflows tested\n   - Any concerns\n\nHuman wakes up to: working app OR clear blockers.\n\n## Principles\n\n**You are the manager, not the worker.** Subagents do the work. You coordinate.\n\n**Fresh context is the feature.** Each subagent starts clean. That's why this works.\n\n**Compact communication.** You get summaries, not details. Details live in files.\n\n**Fail forward.** Stuck on one feature? Log it, move on. Don't block everything.\n\n**Trust but verify.** Subagents do their job. Tester verifies Implementer. Reviewer verifies both.\n\nYou are the human while the human sleeps. Act accordingly.\n",
        "ft-mem/.claude-plugin/plugin.json": "{\n  \"name\": \"ft-mem\",\n  \"version\": \"3.0.0\",\n  \"description\": \"Session continuity for Claude Code. Handoff context between sessions, persist project knowledge in memories.\",\n  \"author\": {\n    \"name\": \"Feature Tree Contributors\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\"memory\", \"session\", \"handoff\", \"continuity\"],\n  \"repository\": \"https://github.com/Nothflare/feature-tree\"\n}\n",
        "ft-mem/README.md": "# ft-mem\n\nSession continuity for Claude Code. Companion plugin to feature-tree.\n\n## Why Use ft-mem?\n\n### The Problem\n\nWithout session memory:\n- Every `/clear` loses all context\n- Next Claude re-asks the same questions\n- Debugging progress lost\n- Design decisions forgotten\n\n### What ft-mem Gives You\n\n| Before | After |\n|--------|-------|\n| \"What were we working on?\" ‚Üí no idea | Next session reads handoff.md automatically |\n| \"Why did we choose X?\" ‚Üí lost forever | Decision recorded in memories/architecture.md |\n| \"What files are involved?\" ‚Üí grep again | Handoff lists files, features, and state |\n\n## Installation\n\n```bash\n/plugin marketplace add github:Nothflare/feature-tree\n/plugin install ft-mem@feature-tree\n# Restart Claude Code\n```\n\nUsually installed alongside feature-tree.\n\n## Skills\n\n### /ft-mem:handoff\n\n**Use before `/clear`** to save session context.\n\n```\nHuman: /ft-mem:handoff\n\nClaude: [Creates handoff.md with current state]\n        - What we were working on\n        - Features created/modified\n        - Key decisions and why\n        - What to do next\n\n        Safe to /clear.\n```\n\nNext session automatically reads handoff.md and continues seamlessly.\n\n### /ft-mem:onboarding\n\n**First-time project setup.** Creates:\n- `.feat-tree/CONTEXT.md` - Product overview, constraints, assumptions\n- `.feat-tree/memories/` - Directory for persistent knowledge\n\n### /ft-mem:brainstorm-sync\n\n**After brainstorming sessions.** Syncs discoveries to project memory:\n- Updates CONTEXT.md with new insights\n- Creates relevant memory files\n\n## How It Works\n\n### Session Start\n\nHook reads and injects into context:\n1. `FT_SESSION=N` (session ID for multi-project safety)\n2. `.feat-tree/CONTEXT.md` (product context)\n3. `.feat-tree/memories/handoff.md` if exists\n\n### Before /clear\n\nRun `/ft-mem:handoff`. It:\n1. Records features you created/modified\n2. Captures current state (DONE, IN-PROGRESS, DEBUGGING, BLOCKED)\n3. Saves key decisions with rationale\n4. Lists files to read next session\n\n### Next Session\n\nClaude automatically:\n1. Reads handoff context\n2. Queries Feature Tree for mentioned features\n3. Continues where you left off\n\n## Handoff Templates\n\nThe handoff skill uses status-appropriate templates:\n\n| Status | Captured |\n|--------|----------|\n| **DONE** | What was completed, notes for future |\n| **IN-PROGRESS** | Current approach, progress, next steps |\n| **DEBUGGING** | Bug description, what was tried, hypotheses |\n| **BLOCKED** | Blocker, options, needs |\n\n## Storage\n\n```\n.feat-tree/\n‚îú‚îÄ‚îÄ CONTEXT.md              # Product context (injected at session start)\n‚îî‚îÄ‚îÄ memories/\n    ‚îú‚îÄ‚îÄ handoff.md          # Session handoff (auto-read on startup)\n    ‚îú‚îÄ‚îÄ codebase_structure.md\n    ‚îú‚îÄ‚îÄ code_style.md\n    ‚îú‚îÄ‚îÄ debugging_*.md\n    ‚îî‚îÄ‚îÄ [anything].md       # You can create any memory files\n```\n\n## Memory Files\n\nCreate any `.md` file in `memories/` for persistent knowledge:\n\n| File | Purpose |\n|------|---------|\n| `code_style.md` | Project conventions |\n| `codebase_structure.md` | Key directories and patterns |\n| `api_patterns.md` | API conventions |\n| `debugging_auth.md` | Solved auth issues |\n\nThese survive `/clear` and provide context to future sessions.\n\n## Benefits\n\n1. **No re-explaining**: Context persists across sessions\n2. **No repeated mistakes**: Debugging notes prevent re-trying failed approaches\n3. **Seamless handoff**: Start where you left off\n4. **Team knowledge**: Memory files work for any Claude session on the project\n\n## License\n\nMIT\n",
        "ft-mem/commands/handoff.md": "---\ndescription: Use before /clear to save session context for seamless handoff to next session\n---\n\n# Session Handoff\n\nSave context so next Claude continues seamlessly.\n\n## What Handoff Does\n\n1. **Points to the plan** ‚Äî Reference, don't duplicate\n2. **Shows progress** ‚Äî What's done, current, planned\n3. **Captures session context** ‚Äî Decisions, failures, thinking (stuff not in Feature Tree)\n\n## Structure\n\n```markdown\n# Handoff\n\n## Plan\nSee: `docs/plans/YYYY-MM-DD-<topic>.md`\n\n## Progress\n- [x] AUTH.login ‚Äî done\n- [~] AUTH.session ‚Äî current  \n- [ ] AUTH.logout ‚Äî planned\n\n## Current Task: AUTH.session\n[What you were doing, where you stopped]\n[Add detail if it helps: file, function, what's next]\n\n## Decisions Made\n- [Decision]: [Why] ‚Äî so next Claude doesn't revisit\n\n## What Failed (if any)\n- [Approach]: [Why it didn't work]\n```\n\n## Guidelines\n\n- **Reference plan, don't duplicate it**\n- **Progress list for quick visibility** ‚Äî Use [x] done, [~] current, [ ] planned\n- **Current task gets most detail** ‚Äî Where you stopped, what's next\n- **Decisions include WHY** ‚Äî Prevents next Claude from revisiting\n- **Failures include WHY** ‚Äî Prevents next Claude from repeating\n- **Flexible detail** ‚Äî Add more if it helps, less if obvious\n\n## If Mid-Task\n\nMark the feature so next Claude knows work is active:\n```\nupdate_feature(id=\"AUTH.session\", being_modified=\"building\")\n```\n\n## After Writing\n\n```\nHandoff written to .feat-tree/memories/handoff.md\nSafe to /clear.\n```\n",
        "ft-mem/hooks/hooks.json": "{\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"matcher\": \"startup|resume|clear\",\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"\\\"${CLAUDE_PLUGIN_ROOT}/hooks/run-python-hook.cmd\\\" session-start.py\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "ft-mem/hooks/run-python-hook.cmd": ": << 'CMDBLOCK'\n@echo off\nREM Polyglot wrapper: runs Python scripts cross-platform\nREM Usage: run-python-hook.cmd <script-name>\n\npython \"%~dp0%~1\"\nexit /b\nCMDBLOCK\n\n# Unix shell runs from here\nSCRIPT_DIR=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nSCRIPT_NAME=\"$1\"\npython3 \"${SCRIPT_DIR}/${SCRIPT_NAME}\"\n",
        "ft-mem/hooks/session-start.py": "#!/usr/bin/env python3\n\"\"\"\nFeature Tree SessionStart hook.\nInjects philosophy + memory context for session continuity.\n\"\"\"\nimport json\nimport sys\nimport os\nfrom pathlib import Path\n\nPHILOSOPHY = \"\"\"# Feature Tree Active\n\n**Mantras:** Trace don't speculate ‚Ä¢ Query entries not text ‚Ä¢ Check impact before changing ‚Ä¢ Create entry before implementing\n\n## Cross-Session Protocol\n\nIf handoff.md lists features, run `get_feature(id)` for each ‚Äî the text is a summary, the FT entry is truth.\n\n## Quick Reference\n\n- **Before implementing:** search_features + search_workflows first\n- **Before changing:** get_feature ‚Üí check used_by_features + linked_workflows\n- **After implementing:** update_feature with files, code_symbols\n- **Commits:** use /feature-tree:commit (not regular git commit)\n\nSee Feature Tree MCP server instructions for full protocol.\"\"\"\n\n\ndef main():\n    try:\n        input_data = json.load(sys.stdin)\n    except json.JSONDecodeError:\n        input_data = {}\n\n    cwd = input_data.get(\"cwd\", os.getcwd())\n    memories_dir = Path(cwd) / \".feat-tree\" / \"memories\"\n    handoff_file = memories_dir / \"handoff.md\"\n\n    # Build context\n    context_parts = [PHILOSOPHY]\n\n    # Check if memories exist\n    has_memories = memories_dir.exists() and any(memories_dir.glob(\"*.md\"))\n\n    if not has_memories:\n        context_parts.append(\"\"\"\n---\n[Onboarding Required]\nNo memories in .feat-tree/memories/\nUse the ft-mem:onboarding skill to create memory files.\"\"\")\n    else:\n        memory_files = [f.stem for f in memories_dir.glob(\"*.md\") if f.stem != \"handoff\"]\n\n        # Read handoff if exists\n        handoff_content = \"\"\n        if handoff_file.exists():\n            try:\n                handoff_content = handoff_file.read_text(encoding=\"utf-8\").strip()\n            except:\n                pass\n\n        if handoff_content:\n            context_parts.append(f\"\"\"\n---\n# Session Handoff\n{handoff_content}\n\n---\nOther memories: {', '.join(memory_files)}\nRead from .feat-tree/memories/<name>.md if needed.\"\"\")\n        else:\n            context_parts.append(f\"\"\"\n---\nMemories available: {', '.join(memory_files)}\nRead from .feat-tree/memories/<name>.md before starting work.\"\"\")\n\n    output = {\n        \"hookSpecificOutput\": {\n            \"hookEventName\": \"SessionStart\",\n            \"additionalContext\": \"\\n\".join(context_parts)\n        }\n    }\n\n    print(json.dumps(output))\n    sys.exit(0)\n\n\nif __name__ == \"__main__\":\n    main()\n",
        "ft-mem/skills/brainstorm-sync/SKILL.md": "---\nname: brainstorm-sync\ndescription: Capture brainstorm discoveries that aren't in the plan ‚Äî the thinking that makes this project unique\n---\n\n# Brainstorm Sync\n\nAfter brainstorming, capture the THINKING that didn't make it into the plan. The plan has workflows and features. This captures WHY and WHO and WHAT WE SAID NO TO.\n\n## What to Capture\n\nFrom the brainstorm conversation, extract:\n\n### 1. User Insight (from User Day-In-Life)\n\nThe specific person, their context, their pain. This grounds all future decisions.\n\n‚Üí Write to `.feat-tree/memories/user.md`\n\n```markdown\n# User\n\n**Who:** [Name, role, context]\n**When problem appears:** [Specific moment in their day]\n**Current workaround:** [What they do now]\n**Pain:** [What's frustrating about it]\n```\n\n### 2. Scope Fence (from Scope Fence)\n\nWhat we explicitly said NO to. Prevents scope creep in future sessions.\n\n‚Üí Write to `.feat-tree/memories/scope.md`\n\n```markdown\n# Scope\n\n**This IS:** [One sentence]\n\n**This is NOT:**\n- [Explicit exclusion]\n- [Explicit exclusion]\n\n**Features we said no to:**\n- [Feature]: [Why not]\n```\n\n### 3. Core Assumption (from Crux)\n\nThe ONE thing that must be true. Future sessions should validate this.\n\n‚Üí Update `.feat-tree/CONTEXT.md` Key Assumptions section\n\n```markdown\n## Key Assumptions\n- [untested] [The core assumption] ‚Äî test by [how to validate]\n```\n\n### 4. Risks (from Pre-Mortem)\n\nHow this fails. Future sessions should watch for warning signs.\n\n‚Üí Write to `.feat-tree/memories/risks.md`\n\n```markdown\n# Risks\n\n**\"It failed because...\"**\n1. [Failure mode] ‚Äî Watch for: [early warning sign]\n2. [Failure mode] ‚Äî Watch for: [early warning sign]\n\n**Mitigations:**\n- [What we're doing to prevent]\n```\n\n### 5. Design Rationale (from Design phase)\n\nWHY we chose this approach over alternatives. Prevents revisiting decisions.\n\n‚Üí Write to `.feat-tree/memories/decisions.md`\n\n```markdown\n# Design Decisions\n\n**[Topic]:** [Choice]\n- Considered: [Alternative 1], [Alternative 2]\n- Chose because: [Why this fits better]\n- Trade-off accepted: [What we gave up]\n```\n\n## Process\n\n1. **Review brainstorm conversation** ‚Äî What thinking happened that's NOT in the plan?\n2. **Extract each category above** ‚Äî Only if it was actually discussed\n3. **Write to memory files** ‚Äî Dense, not verbose\n4. **Update CONTEXT.md** ‚Äî If core assumptions or project understanding changed\n\n## What NOT to Capture\n\n- Stuff already in the plan (workflows, features, implementation order)\n- Generic/speculative content (only capture what was actually discussed)\n- Session-specific details that won't help future sessions\n\n## Confirm\n\n```\nSynced brainstorm discoveries:\n- memories/user.md ‚Äî [created/updated]\n- memories/scope.md ‚Äî [created/updated]  \n- memories/risks.md ‚Äî [created/updated]\n- memories/decisions.md ‚Äî [created/updated]\n- CONTEXT.md ‚Äî [updated assumptions]\n\nFuture sessions will have this context.\n```\n"
      },
      "plugins": [
        {
          "name": "feature-tree",
          "description": "AI-driven feature management. Track features, link to code symbols and commits.",
          "version": "3.1.0",
          "source": "./feature-tree",
          "author": {
            "name": "Feature Tree Contributors"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add Nothflare/feature-tree",
            "/plugin install feature-tree@feature-tree"
          ]
        },
        {
          "name": "ft-mem",
          "description": "Session continuity. Handoff context between sessions, persist project knowledge.",
          "version": "3.0.0",
          "source": "./ft-mem",
          "author": {
            "name": "Feature Tree Contributors"
          },
          "categories": [],
          "install_commands": [
            "/plugin marketplace add Nothflare/feature-tree",
            "/plugin install ft-mem@feature-tree"
          ]
        }
      ]
    }
  ]
}