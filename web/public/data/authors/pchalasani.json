{
  "author": {
    "id": "pchalasani",
    "display_name": "Prasad Chalasani",
    "avatar_url": "https://avatars.githubusercontent.com/u/554347?u=2ef8e4aacffd0d952c88f6bd9a0b62dc66a54de8&v=4"
  },
  "marketplaces": [
    {
      "name": "cctools-plugins",
      "version": "1.0.0",
      "description": "Provides safety guards to block or require confirmation for risky CLI operations (e.g., rm, destructive git actions, .env access, large file operations)",
      "repo_full_name": "pchalasani/claude-code-tools",
      "repo_url": "https://github.com/pchalasani/claude-code-tools",
      "repo_description": "Practical productivity tools for Claude Code, Codex-CLI, and similar CLI coding agents.",
      "signals": {
        "stars": 1329,
        "forks": 85,
        "pushed_at": "2026-01-30T14:03:17Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"cctools-plugins\",\n  \"version\": \"1.0.0\",\n  \"owner\": {\n    \"name\": \"Prasad Chalasani\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"safety-hooks\",\n      \"source\": \"./plugins/safety-hooks\",\n      \"description\": \"Provides safety guards to block or require confirmation for risky CLI operations (e.g., rm, destructive git actions, .env access, large file operations)\"\n    },\n    {\n      \"name\": \"aichat\",\n      \"source\": \"./plugins/aichat\",\n      \"description\": \"Adds `aichat`-related capabilities (agent support, reusable skills, hooks, and a slash command) for continuing work in CLI agent sessions without compaction, and for searching sessions\"\n    },\n    {\n      \"name\": \"tmux-cli\",\n      \"source\": \"./plugins/tmux-cli\",\n      \"description\": \"Introduces tmux-cli skill for interacting with CLI scripts and other code agents inside tmux panes using the `tmux-cli` command\"\n    },\n    {\n      \"name\": \"workflow\",\n      \"source\": \"./plugins/workflow\",\n      \"description\": \"Workflow utilities and agents including code walkthrough tools, work logging, issue specification helpers, and a UI testing agent for browser-based validation\"\n    },\n    {\n      \"name\": \"langroid\",\n      \"source\": \"./plugins/langroid\",\n      \"description\": \"Design patterns for the Langroid multi-agent LLM framework, with a skill to add new patterns as you learn them\"\n    },\n    {\n      \"name\": \"voice\",\n      \"source\": \"./plugins/voice\",\n      \"description\": \"Audio feedback when Claude Code agent completes tasks using pocket-tts\"\n    }\n  ]\n}\n",
        "README.md": "# claude-code-tools\n\n[![claude-code-tools](https://img.shields.io/github/v/release/pchalasani/claude-code-tools?filter=v*&label=claude-code-tools&color=blue)](https://pypi.org/project/claude-code-tools/)\n[![aichat-search](https://img.shields.io/github/v/release/pchalasani/claude-code-tools?filter=rust-v*&label=aichat-search&color=orange)](https://github.com/pchalasani/claude-code-tools/releases?q=rust)\n\nProductivity tools for Claude Code, Codex-CLI, and similar CLI coding agents:\nCLI commands, skills, agents, hooks, plugins. Click on a card below to navigate.\n\n\n<div align=\"center\">\n\n<table>\n<tr>\n<td align=\"center\">\n<a href=\"#quick-start\">\n<img src=\"assets/card-quickstart.svg\" alt=\"quick start\" width=\"300\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"#claude-code-plugins\">\n<img src=\"assets/card-plugins.svg\" alt=\"plugins\" width=\"300\"/>\n</a>\n</td>\n</tr>\n</table>\n\n<table>\n<tr>\n<td align=\"center\">\n<a href=\"#aichat-session-management\">\n<img src=\"assets/card-aichat.svg\" alt=\"aichat\" width=\"200\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"#tmux-cli-terminal-automation\">\n<img src=\"assets/card-tmux.svg\" alt=\"tmux-cli\" width=\"200\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"#lmsh-experimental\">\n<img src=\"assets/card-lmsh.svg\" alt=\"lmsh\" width=\"200\"/>\n</a>\n</td>\n</tr>\n<tr>\n<td align=\"center\">\n<a href=\"#vault\">\n<img src=\"assets/card-vault.svg\" alt=\"vault\" width=\"200\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"#env-safe\">\n<img src=\"assets/card-env-safe.svg\" alt=\"env-safe\" width=\"200\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"#claude-code-safety-hooks\">\n<img src=\"assets/card-safety.svg\" alt=\"safety\" width=\"200\"/>\n</a>\n</td>\n</tr>\n<tr>\n<td align=\"center\">\n<a href=\"#status-line\">\n<img src=\"assets/card-statusline.svg\" alt=\"statusline\" width=\"200\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"#google-docs-tools\">\n<img src=\"assets/card-gdocs.svg\" alt=\"gdocs\" width=\"200\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"#google-sheets-tools\">\n<img src=\"assets/card-gsheets.svg\" alt=\"gsheets\" width=\"200\"/>\n</a>\n</td>\n</tr>\n<tr>\n<td align=\"center\">\n<a href=\"#using-claude-code-with-open-weight-anthropic-api-compatible-llm-providers\">\n<img src=\"assets/card-alt.svg\" alt=\"alt\" width=\"200\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"#voice\">\n<img src=\"assets/card-voice.svg\" alt=\"voice\" width=\"200\"/>\n</a>\n</td>\n<td align=\"center\">\n</td>\n</tr>\n</table>\n\n<table>\n<tr>\n<td align=\"center\">\n<a href=\"#development\">\n<img src=\"assets/card-dev.svg\" alt=\"development\" width=\"300\"/>\n</a>\n</td>\n<td align=\"center\">\n<a href=\"LICENSE\">\n<img src=\"assets/card-license.svg\" alt=\"license\" width=\"300\"/>\n</a>\n</td>\n</tr>\n</table>\n\n</div>\n\n---\n\n<a id=\"quick-start\"></a>\n## üöÄ Quick Start\n\n**Prerequisites:** Node.js 16+ (required for action menus)\n\n**Step 1:** Install the Python package (includes Node.js UI components):\n```bash\nuv tool install claude-code-tools\n```\n\n**Step 2:** Install the Rust-based search engine (powers both human TUI and agent search).\nChoose **one** of these methods:\n\n- **Homebrew** (macOS/Linux): `brew install pchalasani/tap/aichat-search`\n- **Cargo**: `cargo install aichat-search` (compiles from source, ~5 min)\n- **Pre-built binary**: Download from [Releases](https://github.com/pchalasani/claude-code-tools/releases) (look for `rust-v*` releases)\n\nThat's it! No `npm install` needed ‚Äî the Python package includes pre-installed Node.js dependencies.\n\nWithout `aichat-search`, search won't work, but other `aichat` commands (resume, trim, rollover, etc.) still function.\n\n### What You Get\n\nFour commands are installed:\n\n| Command | Description |\n|---------|-------------|\n| [`aichat`](#aichat-session-management) | Continue work with session lineage and truncation, avoiding compaction;<br>fast (Rust/Tantivy) full-text session search TUI for humans, CLI for agents  |\n| [`tmux-cli`](#tmux-cli-terminal-automation) | Terminal automation for AI agents (\"Playwright for terminals\") |\n| [`vault`](#vault) | Encrypted .env backup and sync |\n| [`env-safe`](#env-safe) | Safe .env inspection without exposing values |\n\n<a id=\"claude-code-plugins\"></a>\n\n### Claude Code Plugins\n\n<details>\n<summary>üì¶ <b>Click to expand plugin details</b></summary>\n\nThis repo also provides plugins for the\n[Claude Code marketplace](https://code.claude.com/docs/en/discover-plugins):\n\n| Plugin | Description |\n|--------|-------------|\n| `aichat` | hooks (`>resume`), commands, skills, agents for continuing session work and fast full-text search of sessions|\n| `tmux-cli` | Terminal automation skill for interacting with other tmux panes |\n| `workflow` | Work logging, code walk-through, issue specs, UI testing |\n| `safety-hooks` | Prevent destructive git/docker/rm commands |\n| `langroid` | Design patterns for the [Langroid](https://github.com/langroid/langroid) multi-agent LLM framework |\n| `voice` | Spoken audio summaries when agent stops; uses [pocket-tts](https://github.com/kyutai-labs/pocket-tts) |\n\n**Install the plugins:**\n\nFirst, add the marketplace (from terminal or within a Claude Code session):\n\n```bash\nclaude plugin marketplace add pchalasani/claude-code-tools   # CLI\n/plugin marketplace add pchalasani/claude-code-tools         # in-session\n```\n\nThis creates the `cctools-plugins` plugin group. Then install plugins from it:\n\n```bash\n# CLI\nclaude plugin install \"aichat@cctools-plugins\"\nclaude plugin install \"tmux-cli@cctools-plugins\"\nclaude plugin install \"workflow@cctools-plugins\"\nclaude plugin install \"safety-hooks@cctools-plugins\"\nclaude plugin install \"langroid@cctools-plugins\"\nclaude plugin install \"voice@cctools-plugins\"\n\n# Or in-session\n/plugin install aichat@cctools-plugins\n/plugin install tmux-cli@cctools-plugins\n/plugin install workflow@cctools-plugins\n/plugin install safety-hooks@cctools-plugins\n/plugin install langroid@cctools-plugins\n/plugin install voice@cctools-plugins\n```\n\nYou can also use `/plugin` without arguments to launch a TUI for browsing and installing.\n\n<a id=\"aichat-plugin-details\"></a>\n\n#### aichat Plugin Details\n\nThe `aichat` plugin provides:\n\n| Type | Name | What it does |\n|------|------|--------------|\n| Hook | `>resume` | Type `>resume` (or `>continue`, `>handoff`) to copy session ID + show resume instructions |\n| Hook | `>session` | Type `>session` (or `>session-id`) to copy session ID to clipboard |\n| Skill | `/session-search` | Search past sessions (for agents without sub-agent support, e.g. Codex) |\n| Skill | `/recover-context` | Extract context from parent sessions into current conversation |\n| Agent | `session-searcher` | Sub-agent to search/retrieve context from past sessions |\n\n#### tmux-cli Plugin Details\n\nThe `tmux-cli` plugin provides:\n\n| Type | Name | What it does |\n|------|------|--------------|\n| Skill | `/tmux-cli` | Interact with CLI apps/agents in other tmux panes |\n\n#### safety-hooks Plugin Details\n\nThe `safety-hooks` plugin provides hooks that block or require approval for dangerous operations:\n\n| Hook | What it blocks/modifies |\n|------|------------------------|\n| `rm` protection | Blocks `rm -rf` on critical paths, requires approval for others |\n| `git add` protection | Blocks `git add -A`, requires approval for modified files |\n| `git checkout` protection | Warns before discarding uncommitted changes |\n| `git commit` protection | Blocks commits without user review |\n| `.env` protection | Blocks all read/write/edit of `.env` files; suggests `env-safe` CLI |\n| File length limit | Blocks reading files >500 lines to prevent context bloat |\n\n#### Workflow Plugin Details\n\nThe `workflow` plugin provides:\n\n| Skill/Agent | What it does |\n|-------------|--------------|\n| `/code-walk-thru` | Walk through files in your editor to explain code or show changes |\n| `/log-work` | Log work progress to `WORKLOG/YYYYMMDD.md` |\n| `/make-issue-spec` | Create task specs at `issues/YYYYMMDD-topic.md` |\n| `ui-tester` agent | Browser-based UI testing via Chrome DevTools MCP |\n\n#### Langroid Plugin Details\n\nThe `langroid` plugin provides design pattern knowledge for the\n[Langroid](https://github.com/langroid/langroid) multi-agent LLM framework:\n\n| Skill | What it does |\n|-------|--------------|\n| `/patterns` | Index of Langroid design patterns (agent config, tools, task control, MCP integration) |\n| `/add-pattern` | Record new patterns as you learn them from the Langroid codebase |\n\n#### Voice Plugin Details\n\nSee the [Voice Plugin](#voice) section below for details.\n\n</details>\n\n---\n\n<a id=\"aichat-session-management\"></a>\n# üí¨ aichat ‚Äî Session Search, and Continuation without Compaction\n\n## Why I built this\n\nThis probably belongs in a blog post or reddit post, but I think knowing the thought process and motivation helps understand what the `aichat` command-group does and why it might be useful to you.\n(For those wondering, this section is one\nof the few parts of the entire repo that is 100% hand-crafted since I just cannot\ntrust today's LLMs to write just the way I want.)\n\n<details>\n<summary>üìñ <b>Click to expand the full background</b></summary>\n\n#### Compaction is lossy: instead, clone the session and truncate long tool-results and older assistant messages\n\nSo, here's how this all started. Session compaction is\n**lossy:** there are very often situations where compaction loses important details,\nso I wanted to find ways to continue my work without compaction.\nA typical scenario is this -- I am at 90% context usage, and I wish I can go on a bit longer to finish the current work-phase. So I thought,\n> I wish I could **truncate** some long tool results (e.g. file reads or API results) or older assistant messages (can include write/edit tool-calls) and clear out some context to continue my work.\n\nThis lead to the [`aichat trim`](#three-resume-strategies) utility. It provides two variants:\n\n- a \"blind\" [`trim`](#three-resume-strategies) mode that truncates all tool-results longer than a threshold (default 500 chars), and optionally all-but-recent assistant messages (which may include long write/edit tool-calls)\n-- all user-configurable. This can free up 40-60% context, depending on what's been going on in the session.\n\n- a [`smart-trim`](#three-resume-strategies) mode that uses a headless Claude/Codex \nagent to determine which\nmessages can be safely truncated in order to continue the current work. The precise\ntruncation criteria can be customized (e.g. the user may want to continue some\nprior work rather than the current task).\n\n\nBoth of these modes *clone* the current session before truncation, and inject two\ntypes of [*lineage*](#lineage-nothing-is-lost):\n- *Session-lineage* is injected into the first user message: a chronological listing\nof sessions from which the current session was derived. This allows the (sub-) agent\nto extract needed context from ancestor sessions, either when prompted by the user,\nor on its own initiative.\n- Each truncated message also carries a pointer to the specific message index in the parent session so full details can always be looked up if needed.\n\n#### A cleaner alternative: Start new session with lineage and context summary\n\nSession trimming can be a quick way to clear out context in order to continue the current task for a bit longer, but after a couple of trims, does not yield as much benefit. But the lineage-injection lead to a different idea to avoid compaction:\n\n> Create a fresh session, inject parent-session lineage into the first user message, along with instructions to extract (using sub-agents if available) context of the latest\ntask from the parent session, or skip context extraction and leave it to the user to extract context once the session starts.\n\nThis is the idea behind the [`aichat rollover`](#three-resume-strategies) functionality, which is the variant I use the most frequently, and I use this\ninstead of first trimming a session. I usually choose\nto skip the summarization (this is the `quick` rollover option in the TUI) so that\nthe new session starts quickly and I can instruct Claude-Code/Codex-CLI to extract\nneeded context (usually from the latest chat session shown in the lineage), as shown\nin the [demo video](#resume-demo-video) below.\n\n#### A hook to simplify continuing work from a session\n\nI wanted to make it seamless to pick any of the above three task continuation modes, when inside a Claude Code session, so I set up a `UserPromptSubmit` [hook](#resume-options) (via the `aichat` plugin) that is triggered when the user types `>resume` (or `>continue` or `>handoff`). When I am close to full context usage,\nI type `>resume`, and the hook script copies the current session id into the clipboard and shows instructions asking the user to run\n`aichat resume <pasted-session-id>`; this launches a TUI that offering options to choose\none of the above [session resumption modes](#three-resume-strategies).\nSee the [demo video](#resume-demo-video) below.\n\n#### Fast full-text session search for humans/agents to find prior work context\n\nThe above session resumption methods are useful to continue your work from the\n*current* session, but often you want to continue work that was done in an\n*older* Claude-Code/Codex-CLI session. This is why I added this:\n\n> Super-fast Rust/Tantivy-based [full-text search](#aichat-search--find-and-select-sessions) of all sessions across Claude-Code and\nCodex-CLI, with a pleasant self-explanatory TUI for humans, and a CLI mode for Agents\nto find past work. (The Rust/Tantivy-based search and TUI was inspired by the excellent\nTUI in the [zippoxer/recall](https://github.com/zippoxer/recall) repo).\n\nUsers can launch the search TUI using [`aichat search ...`](#aichat-search--find-and-select-sessions) and (sub-)\n[agents can run](#agent-access-to-history-the-session-searcher-sub-agent)\n`aichat search ... --json` and get results in JSONL format\nfor quick analysis and filtering using `jq` which of course CLI agents are\ngreat at using. There is a corresponding *skill* called `session-search` and a *sub-agent* called `session-searcher`, both\navailable via the `aichat` [plugin](#claude-code-plugins).\nFor example in Claude Code,\nusers can recover context of some older work by simply saying something like:\n\n> Use your session-searcher sub-agent to recover the context of how we worked on\nconnecting the Rust search TUI with the node-based Resume Action menus.\n\n</details>\n\n## Overview\n\n\n`aichat` is your unified CLI command-group for managing Claude Code and Codex sessions.\nTwo main capabilities are available:\n\n1. **Resume with lineage** ‚Äî Continue sessions when context fills up, preserving\n   links to parent sessions, avoiding lossy compaction.\n\n2. **Search** ‚Äî *Full-text search* across all sessions with a fast Rust/Tantivy-based \nTUI for humans, and CLI (with `--json` flag for jsonl output) for Codex or Claude (sub) \nAgent to search for past work. (Note that Claude Code's built-in search is not full-text\n; it only searches the ad-hoc session titles created by CC, or renamed sessions). \n\nExamples:\n\n```bash\naichat resume <session_id>     # Resume specific session with trim/rollover options\naichat resume                  # Resume latest session with trim/rollover options\naichat search \"topic\"          # Find sessions by keyword: for humans\naichat search \"langroid mcp\" --json # fast full-text search with jsonl output for agents\n```\n\nFor detailed CLI options, run:\n```bash\naichat --help              # See all subcommands\naichat <subcommand> --help # Help for specific subcommand\n```\n\n> [!NOTE]\n> Most `aichat` commands accept `--claude-home` and `--codex-home` to override\n> the default session directories (`~/.claude` and `~/.codex`). You can also set\n> the `CLAUDE_CONFIG_DIR` and `CODEX_HOME` environment variables.\n\n---\n\n<a id=\"resume-options\"></a>\n## Resume Options ‚Äî Continuing work in a trimmed or fresh session, with lineage.\n\n\nYou have three ways to access the resume functionality:\n\n**1. In-session trigger** ‚Äî This is likely to be used the most frequently: while already in a Claude Code session, when you're close to filling up context, type:\n\n```bash\n>resume # or >continue, >handoff; MUST include the \">\" at the start\n```\n\nThis triggers a `UserPromptSubmit` hook that blocks handling by Claude-Code \n(hence no further tokens consumed), copies the current session ID to your \nclipboard, and shows instructions to quit Claude Code and run `aichat resume <paste>`. \nThis is a quick escape hatch when context is filling up ‚Äî no need to manually find the \nsession ID.\n\n*Requires the `aichat` plugin. See [Claude Code Plugins](#claude-code-plugins)\nfor installation.*\n\n\n<a id=\"resume-demo-video\"></a>\n\nhttps://github.com/user-attachments/assets/310dfa5b-a13b-4a2b-aef8-f73954ef8fe9\n\n\n\n**2. [Search TUI](#aichat-search--find-and-select-sessions)** ‚Äî Run `aichat search`, select a session, then choose a resume\naction from the menu.\n\n**3. Direct CLI** ‚Äî Use these commands directly:\n\n```bash\naichat resume abc123         # Resume specific session\naichat resume                # Auto-find latest for this project\n```\n\n\n---\n\n\n### Three Resume Strategies\n\n> [!TIP]\n> It's highly recommended to turn off auto-compaction when using `aichat resume`.\n> - **Claude Code:** Use the `/config` command to disable auto-compaction\n> - **Codex CLI:** Set `model_auto_compact_token_limit = 0` in `~/.codex/config.toml`\n\nWhen you access the resume menu using any of the above 3 mechanisms, you will\nbe presented with 3 resume strategies, as described below.\nAll strategies create a new session with **lineage** ‚Äî links back to\nparent sessions that the agent (or preferable a sub-agent if available)\ncan reference at any time.\n\n**1. Trim + Resume**\n\nTruncates large tool call results and assistant messages to free up space.\nQuick and deterministic ‚Äî you control what gets cut. The default is to trim\n*all* tool results longer than 500 characters, and *none* of the\nassistant messages. This can\noften free up 30-50% of context when applied the first time to a normal session\n(depending on what's in the session). A quick way to extend a session a bit\nlonger without lossy compaction.\n\nThe TUI lets you specify:\n\n- Which tool types to truncate (e.g., bash, read, edit, or all)\n- Length threshold in characters (default: 500)\n- How many assistant messages to truncate \n  (N => first N, or -N => all except last N; defaults to 0). \n  For example to truncate all except the last 10 assistant messages, use `-10`.\n\nSame options available via CLI: `aichat trim --help`\n\n**2. Smart Trim + Resume**\n\nUses headless (non-interactive) Claude/Codex agent to analyze the session and\nstrategically identify what can user/assistant messages or tool results can \nbe safely truncated without affecting the *last* task being worked on. Slower than \ndeterministic trim, but smarter and more selective.\n\nThe TUI lets you specify:\n\n- Message types to never trim (default: user messages)\n- How many recent messages to always preserve (default: 10)\n- Minimum content threshold for extraction (default: 200 chars)\n- Custom instructions for what to prioritize when truncating\n\nSame options available via CLI: `aichat smart-trim --help`\n\n**3. Rollover**\n\nThe trim strategies work well once or twice but eventually stop freeing much\ncontext. *Rollover* is a better alternative after a couple of trim iterations,\nor directly from a normal session. This strategy hands off work to a fresh\nsession, injecting *session-lineage* pointers and an optional agent-generated summary of the current task. The session lineage pointers are a chronologically ordered\nlist of session jsonl file paths, of the parent session, parent's parent, and so on,\nall the way back to the original session.\nThe new session typically starts with 15-20% context usage, \nand the agent or sub-agent can retrieve details from ancestor sessions on demand,\neither if prompted by the user, or on its own when looking up prior work.\n\n\nThe TUI lets you specify:\n\n- Which agent (Claude or Codex) to resume with ‚Äî start in Claude Code, hand off\n  to Codex for heavy refactoring, then back to Claude Code for finishing touches\n- Rollover type:\n  - **Quick rollover** ‚Äî Just preserves lineage pointers, no context extraction.\n    Fast, but you'll need to ask the agent to look up prior work as needed.\n    If you install the `aichat` [plugin](#claude-code-plugins), you'll have access\n    to the `/recover-context` command ‚Äî the agent reads parent sessions and pulls\n    relevant context into the current conversation.\n  - **Rollover with context** ‚Äî Uses a headless Claude/Codex agent to extract summary   \n     of current work into the new session.\n- Custom context recovery instructions (e.g., \"focus on the authentication changes\")\n  ‚Äî only available when using \"Rollover with context\"\n\nSame options available via CLI: `aichat rollover --help` (use `--quick` for\nquick mode, `-p \"prompt\"` for custom extraction instructions)\n\n### Lineage: Nothing Is Lost\n\nUnlike compaction (which permanently loses information), all strategies preserve\nthe complete parent session:\n\n- **Lineage chain** ‚Äî file paths of all ancestor sessions\n- **On-demand retrieval** ‚Äî agent can read any past session when needed\n\n```\nOriginal Session (abc123)\n ‚îî‚îÄ‚ñ∫ Trimmed/Rollover 1 (def456)\n      ‚îî‚îÄ‚ñ∫ Trimmed/Rollover 2 (ghi789)\n           ‚îî‚îÄ‚ñ∫ ... chain continues\n```\n\nSee [here](docs/rollover-details.md) for details on how rollover works.\n\n--- \n\n## aichat search ‚Äî Find and Select Sessions\n\nUses Tantivy (Rust full-text search) to provide fast search across all your Claude and Codex sessions.\n\nHere's what it looks like:\n\n![aichat search demo](demos/aichat-search-asciinema.gif)\n\n```bash\naichat search                      # Interactive TUI for current project\naichat search \"langroid MCP\"       # Pre-fill search query\naichat search -g                   # Global search (all projects)\naichat search --json -g \"error\"    # JSONL output for CLI-agents\n```\n\n**How it works:**\n\n- **Auto-indexing:** Sessions are automatically indexed on startup‚Äîno manual\n  export or build steps needed.\n- **Self-explanatory TUI for humans:** Filter by session type, agent, date range, and more. All options are visible in the UI.\n- **CLI options:** All search options are available as command-line arguments. Run\n  `aichat search --help` for details.\n- **JSON mode for Agents:** Use `--json` for JSONL output that CLI-agents can process with\n  `jq` or other tools. See [Session-Searcher sub-agent](#agent-access-to-history-the-session-searcher-sub-agent), which is available\nwhen you install the `aichat` plugin mentioned above.\n\n**Session type filters:**\n\nBy default, search includes original, trimmed, and rollover sessions (but not\nsub-agents). Use flags to customize:\n\n```bash\naichat search                       # Default: original + trimmed + rollover\naichat search --sub-agent           # Add sub-agents to defaults\naichat search --no-original         # Exclude originals (show trimmed + rollover)\naichat search --no-trimmed          # Exclude trimmed (show original + rollover)\naichat search --sub-agent --no-rollover  # Add sub-agents, exclude rollovers\n```\n\n**Subtractive flags** (exclude from defaults): `--no-original`, `--no-trimmed`,\n`--no-rollover`\n\n**Additive flag** (add to defaults): `--sub-agent`\n\n---\n\n## Conceptual Flow: Search ‚Üí Select ‚Üí Actions\n\nThe typical workflow:\n\n1. **Search** ‚Äî Use `aichat search` to find sessions by keywords, date, or filters\n2. **Select** ‚Äî Choose a session from the results\n3. **Actions** ‚Äî Perform operations on the selected session\n\nAfter selecting a session, you see the **actions menu**. This is equivalent to\nrunning `aichat <session-id>` or `aichat menu <session-id>` directly.\n\n**Session ID formats** (accepted by most commands):\n\n- Full path: `~/.claude/projects/.../abc123.jsonl`\n- Full ID: `abc123-def456-789-...`\n- Partial ID: `abc123` (if unique)\n\n---\n\n## Session Actions\n\nAfter selecting a session, the action menu offers:\n\n- **Show path / Copy / Export** ‚Äî File operations\n- **Query** ‚Äî Ask questions about the session using a headless Claude-Code/Codex agent\n- **Resume options** ‚Äî Various strategies for continuing work (see below)\n\n---\n\n\n### Agent Access to History; the Session-Searcher sub-agent\n\nYour agent can search across all historical sessions using the JSON output\nmode:\n\n```bash\naichat search --json -g \"error handling\"  # Returns JSONL for programmatic use\naichat search --json --by-time            # Sort by last-modified time\n```\n\nThis enables agents to find and retrieve context from any past session in the\nlineage, either on their own initiative or when you prompt them to look up\nhistorical context.\n\nInstalling the `aichat` plugin mentioned above provides two ways to search past sessions:\n\n- **`Session-Searcher` sub-agent** (Claude Code) ‚Äî A sub-agent with instructions to\n  search a known session file if clear from context, or use `aichat search --json`\n  to search past sessions. E.g. in Claude Code you can say:\n  > From past sessions, recover details of our work on task-termination specification.\n\n- **`session-search` skill** (Claude Code, Codex CLI) ‚Äî A skill that invokes the same\n  search functionality. Useful for CLI agents like Codex that don't yet support sub-agents.\n  E.g. you can say:\n  > Use your session-search skill to find our work on error handling.\n\n---\n\n## All Subcommands\n\n| Command | Description |\n|---------|-------------|\n| `aichat search [query]` | Full-text search TUI across all sessions |\n| `aichat menu [session]` | Interactive action menu for a session |\n| `aichat resume [session]` | Resume options (resume, clone, trim, rollover) |\n| `aichat info [session]` | Show session metadata, path, and lineage |\n| `aichat export [session]` | Export session to text |\n| `aichat copy [session]` | Copy session file to new location |\n| `aichat move <session> <new-project>` | Move session to a different project directory |\n| `aichat query [session] [question]` | Query session with AI |\n| `aichat clone [session]` | Clone session and resume the clone |\n| `aichat rollover [session]` | Hand off to fresh session with lineage |\n| `aichat lineage [session]` | Show parent lineage chain |\n| `aichat trim [session]` | Trim large tool outputs |\n| `aichat smart-trim [session]` | AI-powered trimming (EXPERIMENTAL) |\n| `aichat delete [session]` | Delete with confirmation |\n| `aichat find-original [session]` | Trace back to original session |\n| `aichat find-derived [session]` | Find all derived sessions |\n\n**Index management:**\n\n| Command | Description |\n|---------|-------------|\n| `aichat build-index` | Manually rebuild the search index |\n| `aichat clear-index` | Clear the index for a fresh rebuild |\n| `aichat index-stats` | Show index statistics and reconciliation |\n\nThe search index is powered by [Tantivy](https://github.com/quickwit-oss/tantivy)\n(Rust full-text search). You typically don't need to manage it manually:\n\n- **Auto-updates**: Index updates incrementally on every `aichat` command\n- **Version rebuilds**: Index rebuilds automatically when the tool version changes\n- **Manual rebuild**: Use `aichat clear-index && aichat build-index` if needed\n\nRun `aichat <command> --help` for options\n\n<a id=\"tmux-cli-terminal-automation\"></a>\n# üéÆ tmux-cli ‚Äî Terminal Automation\n\n> **Note**: While the description below focuses on Claude Code, tmux-cli works with any CLI coding agent.\n\n![tmux-cli demo](demos/tmux-cli-demo-short.gif)\n\n**Think Playwright for terminals** - Terminal automation for AI agents.\n\ntmux-cli enables Claude Code to programmatically control terminal applications:\ntest interactive scripts, debug with pdb, launch and interact with other CLI agents.\n\n**Important**: You don't need to learn tmux-cli commands. Claude Code handles\neverything automatically‚Äîjust describe what you want.\n\n**Works anywhere**: Automatically handles both local tmux panes and remote sessions.\n\n### Why tmux-cli instead of vanilla tmux?\n\nVanilla tmux can do everything tmux-cli does. The problem is that LLMs frequently make\nmistakes with raw tmux: forgetting the Enter key, not adding delays between text and\nEnter (causing race conditions with fast CLI apps), or incorrect escaping. `tmux-cli`\nbakes in defaults that address these: Enter is sent automatically with a 1.5-second delay\n(configurable), pane targeting accepts simple numbers instead of `session:window.pane`,\nbuilt-in `wait_idle` to detect when a CLI is ready for input, and **Enter key verification\nwith automatic retry** to handle intermittent failures.\n\n> **Important: Instruct your AI agent to use `tmux-cli` instead of plain `tmux`**\n>\n> Add this directive to your project's `CLAUDE.md` or agent instructions:\n>\n> ```markdown\n> When interacting with tmux panes, ALWAYS use `tmux-cli send` instead of plain\n> `tmux send-keys`. Plain tmux commands are unreliable because they send text and\n> Enter simultaneously without any delay, causing race conditions where the Enter\n> key is lost before the target application can process the text input.\n> ```\n>\n> **Why plain tmux is unreliable:** When you run `tmux send-keys \"text\" Enter`, both\n> the text and Enter key are sent in rapid succession. If the target shell or application\n> hasn't fully processed the text input buffer, the Enter key can be lost. This is\n> especially common during shell initialization, with slow terminal emulators, or under\n> system load. `tmux-cli` addresses this by:\n> 1. Sending text first, then waiting 1.5 seconds before sending Enter\n> 2. Verifying the Enter was received by checking if pane content changed\n> 3. Automatically retrying the Enter key (up to 3 times) if verification fails\n\n## Tmux-cli skill\n\nTo make it easier to have Claude-Code use this command, there's a **tmux-cli plugin** in this repo; once you install it, you can simply say \"use your tmux-cli skill to get help from Codex running in tmux pane 3\".\n\nFor detailed instructions, see [docs/tmux-cli-instructions.md](docs/tmux-cli-instructions.md) and [Claude Code tmux tutorials](docs/claude-code-tmux-tutorials.md).\n\nAll of this assumes you're familiar and comfortable with tmux, and (like me) run\nall CLI coding sessions inside tmux sessions.\n\n\n## What Claude Code Can Do With tmux-cli\n\n1. **Test Interactive Scripts** - CC can run and interact with scripts that \n   require user input, answering prompts automatically based on your instructions.\n\n2. **UI Development & Testing** - CC can launch web servers and coordinate with \n   browser automation tools to test your applications.\n\n3. **Interactive Debugging** - CC can use debuggers (pdb, node inspect, gdb) to \n   step through code, examine variables, and help you understand program flow.\n\n4. **Claude-to-Claude Communication** - CC can launch another Claude Code instance \n   to get specialized help or code reviews.\n\n\nClaude Code can find out how to use tmux-cli through its built-in help. \nYou just describe what you want, and CC handles the technical details.\n\nFor complete command reference, see [docs/tmux-cli-instructions.md](docs/tmux-cli-instructions.md).\n\n\n\n<a id=\"lmsh-experimental\"></a>\n# üöÄ lmsh (Experimental)\n\nNatural language shell - type what you want in plain English, get an editable command.\n\n```bash\n# Direct usage - translate, edit, execute, then enter interactive mode\n$ lmsh \"show me all python files modified today\"\nfind . -name \"*.py\" -mtime 0  # <-- Edit before running\n\n# Or interactive mode\n$ lmsh\nlmsh> show recent docker containers\ndocker ps -n 5  # <-- Edit before running\n```\n\n**Features:**\n- Rust-based for instant startup (<1ms binary load time)\n- Translates natural language to shell commands using Claude Code CLI\n- Commands are editable before execution - full control\n- Preserves your shell environment\n\n**Note:** Requires Claude Code CLI (`claude` command) to be installed. The translation adds ~2-3s due to Claude Code CLI startup.\n\n**Installation:**\n```bash\n# Install from crates.io (easiest, requires Rust)\ncargo install lmsh\n\n# Or build from source\ncd lmsh && cargo build --release\ncp target/release/lmsh ~/.cargo/bin/\n# Or: make lmsh-install\n```\n\nSee [docs/lmsh.md](docs/lmsh.md) for details.\n\n<a id=\"status-line\"></a>\n## üìä Status Line\n\nA custom status line script for Claude Code is available at\n[`scripts/statusline.sh`](scripts/statusline.sh). It displays model name,\nproject directory, git branch, git status indicators, and a context window\nprogress bar that changes color as you approach the limit.\n\n![green](demos/statusline-green.png)\n![yellow](demos/statusline-yellow.png)\n![orange](demos/statusline-orange.png)\n![red](demos/statusline-red.png)\n\nTo use it, copy the script and configure Claude Code:\n\n```bash\ncp scripts/statusline.sh ~/.claude/\nchmod +x ~/.claude/statusline.sh\n```\n\nAdd to `~/.claude/settings.json`:\n\n```json\n{\n  \"statusLine\": {\n    \"type\": \"command\",\n    \"command\": \"~/.claude/statusline.sh\"\n  }\n}\n```\n\nRequires `jq` and a [Nerd Font](https://www.nerdfonts.com/) for powerline symbols.\n\n<a id=\"vault\"></a>\n# üîê vault\n\nCentralized encrypted backup for .env files across all your projects using SOPS.\n\n```bash\nvault sync      # Smart sync (auto-detect direction)\nvault encrypt   # Backup .env to ~/Git/dotenvs/\nvault decrypt   # Restore .env from centralized vault\nvault list      # Show all project backups\nvault status    # Check sync status for current project\n```\n\n### Key Features\n\n- Stores all encrypted .env files in `~/Git/dotenvs/`\n- Automatic sync direction detection\n- GPG encryption via SOPS\n- Timestamped backups for safety\n\nFor detailed documentation, see [docs/vault-documentation.md](docs/vault-documentation.md).\n\n<a id=\"env-safe\"></a>\n# üîç env-safe\n\nSafely inspect .env files without exposing sensitive values. Designed for Claude Code and other automated tools that need to work with environment files without accidentally leaking secrets.\n\n```bash\nenv-safe list                    # List all environment variable keys\nenv-safe list --status           # Show keys with defined/empty status  \nenv-safe check API_KEY           # Check if a specific key exists\nenv-safe count                   # Count total, defined, and empty variables\nenv-safe validate                # Validate .env file syntax\nenv-safe --help                  # See all options\n```\n\n### Key Features\n\n- **No Value Exposure** - Never displays actual environment values\n- **Safe Inspection** - Check which keys exist without security risks\n- **Syntax Validation** - Verify .env file format is correct\n- **Status Checking** - See which variables are defined vs empty\n- **Claude Code Integration** - Works with protection hooks to provide safe alternative\n\n### Why env-safe?\n\nThe [`safety-hooks` plugin](#claude-code-safety-hooks) in this repo blocks Claude Code from directly accessing .env files ‚Äî no reading, writing, or editing allowed. This prevents both accidental exposure of API keys and unintended modifications. The `env-safe` command provides the only approved way for Claude Code to inspect environment configuration safely, while any modifications must be done manually outside of Claude Code.\n\n\n<a id=\"claude-code-safety-hooks\"></a>\n# üõ°Ô∏è Claude Code Safety Hooks\n\nThis repository includes a comprehensive set of safety hooks that enhance Claude\nCode's behavior and prevent dangerous operations.\n\n### Key Safety Features\n\n- **File Deletion Protection** - Blocks `rm` commands, enforces TRASH directory\n  pattern\n- **Git Commit Protection** - Requires user approval before any git commit\n  (uses Claude Code's permission prompt UI)\n- **Git Add Protection** - Smart staging control:\n  - Hard blocks: `git add .`, `git add ../`, `git add *`, `git add -A/--all`\n  - New files: Allowed without permission\n  - Modified files: Requires user approval (permission prompt)\n  - Directories: Uses dry-run to detect files, asks permission if modified files\n- **Environment Security** - Blocks all .env file operations (read/write/edit),\n  suggests `env-safe` command for safe inspection\n- **Context Management** - Blocks reading files >500 lines to prevent context\n  bloat\n- **Command Enhancement** - Enforces ripgrep (`rg`) over grep for better\n  performance\n\n### Installation\n\nInstall the `safety-hooks` plugin as described in\n[Claude Code Plugins](#claude-code-plugins).\n\n### Available Hooks\n\n- `bash_hook.py` - Main hook that orchestrates all bash command checks\n- `git_commit_block_hook.py` - User permission prompt for git commits\n- `git_add_block_hook.py` - Smart staging: blocks dangerous patterns, prompts\n  for modified files\n- `env_file_protection_hook.py` - Blocks all .env file operations\n- `file_size_conditional_hook.py` - Prevents reading huge files\n- `grep_block_hook.py` - Enforces ripgrep usage\n- `notification_hook.sh` - Sends ntfy.sh notifications\n\nFor complete documentation, see [hooks/README.md](hooks/README.md).\n\n<a id=\"voice\"></a>\n# üîä Voice Plugin\n\nGet spoken audio feedback when Claude Code completes a task. The agent\nautomatically speaks a 1-2 sentence summary before stopping, so you can\nmultitask while Claude works.\n\n### Prerequisites\n\n- **UV** - Required for running pocket-tts. Install via:\n  `curl -LsSf https://astral.sh/uv/install.sh | sh`\n- **FFmpeg** (recommended) - Enables streaming audio for lower latency. Install\n  via `brew install ffmpeg` (macOS) or `sudo apt install ffmpeg` (Linux)\n\n### How It Works\n\nThe plugin uses [pocket-tts](https://github.com/kyutai-labs/pocket-tts), a\nlightweight text-to-speech library. On first use, it automatically:\n\n1. Starts a pocket-tts server (via `uvx pocket-tts serve`)\n2. Downloads the voice model (~50MB, one-time)\n\nThe server persists in the background (via `nohup`) so subsequent requests\nare instant. Server logs are written to `/tmp/pocket-tts-server.log`.\n\nTo stop the server manually (works on both macOS and Linux):\n\n```bash\npkill -f \"pocket-tts serve\"\n```\n\n### Installation\n\n```bash\n# Add the marketplace (if not already added)\nclaude plugin marketplace add pchalasani/claude-code-tools\n\n# Install the plugin\nclaude plugin install voice@cctools-plugins\n```\n\n### Usage\n\nOnce installed, the plugin works automatically:\n\n- **Automatic feedback**: When the agent finishes a task, it speaks a summary\n  before stopping\n- **Explicit requests**: Ask Claude to \"use your voice\" and it will speak\n  its response\n\n### Configuration\n\nUse the `/voice:speak` command to configure:\n\n```bash\n/voice:speak                  # Enable voice feedback with current voice\n/voice:speak alba             # Set voice to \"alba\" and enable feedback\n/voice:speak azure            # Set voice to \"azure\" and enable\n/voice:speak stop             # Disable voice feedback\n/voice:speak prompt <text>    # Set custom instruction for summaries\n/voice:speak prompt           # Clear custom prompt\n```\n\n**Custom prompts** let you personalize how summaries are delivered:\n\n```bash\n/voice:speak prompt \"be upbeat and encouraging\"\n/voice:speak prompt \"always end with 'back to you, boss'\"\n```\n\nSee the [pocket-tts repo](https://github.com/kyutai-labs/pocket-tts) for the\nlatest available voices.\n\n### Recommended: Speech-to-Text Companion\n\nFor a complete voice workflow, pair this TTS plugin with\n[Handy](https://github.com/cjpais/Handy) (open-source) using the **Parakeet V3**\nmodel for speech-to-text. It's stunningly fast with near-instant transcription.\n\nThe slight accuracy drop compared to larger models is immaterial when talking to\nan AI. **Pro tip**: Ask the agent to restate what it understood ‚Äî this confirms\nunderstanding and helps keep the CLI agent on track.\n\n### Architecture\n\nThe plugin uses a multi-hook strategy for fast, reliable voice summaries:\n\n- **UserPromptSubmit hook**: Silently injects voice instructions each turn,\n  telling Claude to end longer responses with a `üì¢` spoken summary marker\n- **PostToolUse hook**: Brief reminder after each tool call to keep instructions\n  fresh during long tool chains\n- **Stop hook**: Extracts the `üì¢` marker instantly (no API call), or falls back\n  to headless Claude summarization only if the agent forgot\n\nThis ensures:\n\n- **Fast feedback**: Most summaries are instant (marker extraction, no API call)\n- **Reliable**: Headless Claude fallback catches cases where agent forgets\n- **Silent operation**: Hooks use `additionalContext` for noise-free injection\n- **Tone matching**: Summaries match user's style (casual, colorful, etc.)\n\n<a id=\"using-claude-code-with-open-weight-anthropic-api-compatible-llm-providers\"></a>\n## ü§ñ Using Claude Code with Open-weight Anthropic API-compatible LLM Providers\n\nYou can use Claude Code with alternative LLMs served via Anthropic-compatible\nAPIs, e.g. Kimi-k2, GLM4.5 (from zai), Deepseek-v3.1, [MiniMax-M2.1](https://platform.minimax.io/docs/guides/text-ai-coding-tools).\nAdd these functions to your shell config (.bashrc/.zshrc):\n\n```bash\nkimi() {\n    (\n        export ANTHROPIC_BASE_URL=https://api.moonshot.ai/anthropic\n        export ANTHROPIC_AUTH_TOKEN=$KIMI_API_KEY\n        claude \"$@\"\n    )\n}\n\nzai() {\n    (\n        export ANTHROPIC_BASE_URL=https://api.z.ai/api/anthropic\n        export ANTHROPIC_AUTH_TOKEN=$Z_API_KEY\n        claude \"$@\"\n    )\n}\n\ndseek() {\n    (\n        export ANTHROPIC_BASE_URL=https://api.deepseek.com/anthropic\n        export ANTHROPIC_AUTH_TOKEN=${DEEPSEEK_API_KEY}\n        export ANTHROPIC_MODEL=deepseek-chat\n        export ANTHROPIC_SMALL_FAST_MODEL=deepseek-chat\n        claude \"$@\"\n    )\n}\n\nccmm() {\n    (\n        export ANTHROPIC_BASE_URL=https://api.minimax.io/anthropic\n        export ANTHROPIC_AUTH_TOKEN=$MINIMAX_API_KEY\n        export API_TIMEOUT_MS=3000000\n        export CLAUDE_CODE_DISABLE_NONESSENTIAL_TRAFFIC=1\n        export ANTHROPIC_MODEL=MiniMax-M2.1\n        export ANTHROPIC_SMALL_FAST_MODEL=MiniMax-M2.1\n        export ANTHROPIC_DEFAULT_SONNET_MODEL=MiniMax-M2.1\n        export ANTHROPIC_DEFAULT_OPUS_MODEL=MiniMax-M2.1\n        export ANTHROPIC_DEFAULT_HAIKU_MODEL=MiniMax-M2.1\n        claude \"$@\"\n    )\n}\n```\n\nAfter adding these functions:\n- Set your API keys: `export KIMI_API_KEY=your-kimi-key`,\n  `export Z_API_KEY=your-z-key`, `export DEEPSEEK_API_KEY=your-deepseek-key`,\n  `export MINIMAX_API_KEY=your-minimax-key`\n- Run `kimi` to use Claude Code with the Kimi K2 LLM\n- Run `zai` to use Claude Code with the GLM-4.5 model\n- Run `dseek` to use Claude Code with the DeepSeek model\n- Run `ccmm` to use Claude Code with the MiniMax M2.1 model\n\nThe functions use subshells to ensure the environment variables don't affect\nyour main shell session, so you could be running multiple instances of Claude Code,\neach using a different LLM.\n\n### Using Claude Code and Codex with Local LLMs\n\nYou can run **Claude Code** and **OpenAI Codex CLI** with local models using\n[llama.cpp](https://github.com/ggml-org/llama.cpp)'s server for fully offline usage.\n\n- **Claude Code** uses the Anthropic-compatible `/v1/messages` endpoint with models\n  like GPT-OSS-20B, Qwen3-Coder-30B, Qwen3-Next-80B, and Nemotron-3-Nano\n- **Codex CLI** uses the OpenAI-compatible `/v1/chat/completions` endpoint with GPT-OSS\n\nFor complete setup instructions including llama-server commands, config files, and\ncommand-line options for switching models, see\n**[docs/local-llm-setup.md](docs/local-llm-setup.md)**.\n\n<a id=\"google-docs-tools\"></a>\n## üìù Google Docs Tools (md2gdoc, gdoc2md)\n\nWhen working with CLI agents like Claude-Code on writing projects, the most natural \ngeneration format is markdown. But iterating on these docs via Google Docs is a pain\nsince Gdocs are especially unfriendly to markdown:\nuploading a Markdown file to Google Drive with proper formatting\nis a pain. You have to:\n\n1. Upload the `.md` file to Google Drive\n2. Click \"Open in Google Docs\" to trigger conversion\n3. This creates a *new* document with proper formatting\n4. Delete the original raw `.md` file\n5. Rename the new document\n\n`md2gdoc` reduces this to one command. `gdoc2md` does the reverse.\n\n### Installation\n\nThese tools require additional dependencies. Install with the `gdocs` extra:\n\n```bash\nuv tool install 'claude-code-tools[gdocs]'\n```\n\n### First-Time Setup (One-Time)\n\n1. Go to [Google Cloud Console](https://console.cloud.google.com/)\n2. Create/select a project and enable the **Google Drive API**\n   and the **Google Docs API**\n3. Go to **APIs & Services** ‚Üí **Credentials** ‚Üí **Create Credentials** ‚Üí\n   **OAuth client ID**\n4. Choose **Desktop app**, then download the JSON file\n5. Save it as `.gdoc-credentials.json` in your project directory\n6. First run will open browser for OAuth consent (one-time per project)\n\nCredentials are project-specific (`.gdoc-credentials.json` and `.gdoc-token.json`\nin the current directory), so different projects can use different Google\naccounts.\n\n### md2gdoc ‚Äî Markdown to Google Docs\n\nUpload Markdown files as native Google Docs:\n\n```bash\nmd2gdoc report.md                           # Upload to root of Drive\nmd2gdoc report.md --folder \"Perf/Reports\"    # Upload to specific folder\nmd2gdoc report.md --name \"Q4 Summary\"       # Upload with custom name\n```\n\nIf a file with the same name exists, `--on-existing` controls behavior:\n- `ask` (default): prompt for action\n- `version`: auto-add suffix (`report-1`, `report-2`, etc.)\n- `overwrite`: replace existing file\n\nFeatures:\n\n- Native markdown conversion (same quality as manual\n  upload + \"Open in Docs\")\n- **Image upload**: local images referenced in markdown\n  (e.g., `![alt](diagram.png)`) are uploaded to Drive\n  at full resolution, then inserted into the Google Doc\n  via the Docs API with proper sizing to fit the page\n- `--max-image-width` controls display width in inches\n  (default: 6.5 = full page width)\n- `--no-images` skips image processing entirely\n- Follows Drive shortcuts to shared folders\n- Conflict detection with version suffix or overwrite\n  options\n- Creates folders if they don't exist\n\n### gdoc2md ‚Äî Google Docs to Markdown\n\nDownload Google Docs as Markdown files:\n\n```bash\ngdoc2md \"My Document\"                        # Download from root\ngdoc2md \"My Document\" --folder \"PNL/Reports\" # Download from folder\ngdoc2md \"My Document\" -o report.md           # Save with custom name\ngdoc2md --list --folder PNL                  # List docs in folder\n```\n\nBy default, embedded images are extracted to local files\n(e.g., `report_001.png`, `report_002.png`) alongside the\nmarkdown, with references rewritten to use local paths:\n\n- Default: extract images to files\n- `--no-images`: strip images to placeholders\n- `--keep-base64`: keep base64 data inline\n\n<a id=\"google-sheets-tools\"></a>\n## üìä Google Sheets Tools (csv2gsheet, gsheet2csv)\n\nUpload CSV files to Google Sheets and download Sheets as CSV. Uses the same\nOAuth credentials as md2gdoc/gdoc2md (see setup above).\n\n### csv2gsheet ‚Äî CSV to Google Sheets\n\n```bash\ncsv2gsheet data.csv                          # Upload to root\ncsv2gsheet data.csv --folder \"Reports/Data\"  # Upload to folder\ncsv2gsheet data.csv --name \"Q4 Sales\"        # Custom name\ncsv2gsheet data.csv --on-existing overwrite  # Overwrite if exists\n```\n\n### gsheet2csv ‚Äî Google Sheets to CSV\n\n```bash\ngsheet2csv \"My Spreadsheet\"                      # Download from root\ngsheet2csv \"My Spreadsheet\" --folder \"Reports\"   # From folder\ngsheet2csv \"My Spreadsheet\" -o data.csv          # Custom output name\ngsheet2csv \"My Spreadsheet\" --sheet \"Sheet2\"     # Specific tab\ngsheet2csv --list --folder Reports               # List spreadsheets\ngsheet2csv \"My Spreadsheet\" --list-tabs          # List tabs\n```\n\nFor multi-tab spreadsheets, use `--sheet` to export a specific tab (default\nexports first tab).\n\n<a id=\"development\"></a>\n## üõ†Ô∏è Development\n\n### Architecture\n\nThe `aichat` command has three layers:\n\n- **Python** (`claude_code_tools/`) - CLI entry points, backend logic, session parsing\n- **Rust** (`rust-search-ui/`) - Search TUI with Tantivy full-text search\n- **Node.js** (`node_ui/`) - Action menus (resume, export, trim, etc.)\n\nFlow: Python CLI (`aichat search`) invokes Rust binary ‚Üí Rust TUI for search ‚Üí\nuser selects session ‚Üí hands off to Node.js menus ‚Üí menus call Python backend.\n\n### Prerequisites\n\n- **UV** - `curl -LsSf https://astral.sh/uv/install.sh | sh`\n- **Rust/Cargo** - `curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh`\n- **Node.js 16+** - Required for action menus\n\n### Setup\n\n```bash\ngit clone https://github.com/pchalasani/claude-code-tools\ncd claude-code-tools\nuv venv --python 3.11\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\nuv sync\ncd node_ui && npm install && cd ..\nmake install                  # Python (editable mode)\nmake aichat-search-install    # Rust binary\n```\n\n### Testing Changes\n\n- **Python**: No action needed (editable mode - changes apply immediately)\n- **Node.js**: No action needed (runs directly from `node_ui/`)\n- **Rust**: Run `make aichat-search-install` to rebuild and install\n\n### Publishing (Python Package)\n\nFor releasing to PyPI:\n\n```bash\nmake all-patch   # Bump patch, push, GitHub release, build\nmake all-minor   # Bump minor, push, GitHub release, build\nmake all-major   # Bump major, push, GitHub release, build\nuv publish       # Publish to PyPI (after any of the above)\n```\n\nThese commands automatically:\n\n1. Run `make prep-node` to ensure `node_ui/node_modules/` is up-to-date\n2. Bump version ‚Üí push to GitHub ‚Üí create GitHub release\n3. Build package (includes `node_modules/` so users don't need `npm install`)\n\nThen run `uv publish` to upload to PyPI.\n\n**Note:** Users need Node.js 16+ installed to run `aichat` action menus, but\nthey do NOT need npm ‚Äî the package includes pre-installed dependencies.\n\n### Publishing (Rust Binaries)\n\n```bash\nmake aichat-search-publish  # Bump version and publish to crates.io\nmake lmsh-publish           # Bump version and publish to crates.io\n```\n\n### Contributing\n\n1. Fork the repository\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\n3. Make your changes\n4. Test thoroughly\n5. Commit your changes\n6. Push to your fork\n7. Open a Pull Request\n\n### Available Make Commands\n\nRun `make help` for full list. Key commands:\n\n| Command | Description |\n|---------|-------------|\n| `make install` | Install Python in editable mode |\n| `make aichat-search-install` | Build and install Rust binary |\n| `make prep-node` | Install node_modules (auto-runs before publish) |\n| `make all-patch/minor/major` | Bump + push + build (for PyPI) |\n| `make aichat-search-publish` | Publish Rust binary to crates.io |\n\n<a id=\"license\"></a>\n## üìÑ License\n\nMIT\n",
        "plugins/safety-hooks/README.md": "Provides safety hooks to block (or require user approval) various commands.\n\n## Hook Decision Types\n\nThe hooks in this collection use three decision types:\n\n- **block** (deny): Hard block, command cannot proceed\n- **ask**: Prompts user for approval in the UI before proceeding\n- **allow** (approve): Command proceeds without intervention\n\n## Safety Hooks\n\n### 1. bash_hook.py (PreToolUse for Bash)\n\nA unified Bash hook that combines multiple safety checks. It runs all sub-checks\nand applies priority: block > ask > allow.\n\nUses `hookSpecificOutput` format with `permissionDecision` field to communicate\ndecisions to Claude Code.\n\n**Sub-hooks it imports:**\n\n#### 1a. rm_block_hook.py\n\n- **Decision**: block\n- **Trigger**: Any `rm` command (including `/bin/rm`, `/usr/bin/rm`)\n- **Behavior**: Blocks deletion and suggests moving files to a TRASH/ directory\n  instead, with logging in TRASH-FILES.md\n- **Purpose**: Prevent accidental/permanent file deletion\n\n#### 1b. git_add_block_hook.py\n\n- **Decisions**: block, ask, or allow depending on context\n- **Hard blocks** (blanket commands that add files indiscriminately, without\n  explicit selection):\n\n  - `git add -A`, `git add -a`, `git add --all` - stages everything including\n    untracked files across the entire repo\n  - `git add .` - stages entire current directory blindly\n  - `git add ../` (parent directory patterns) - stages outside current scope\n  - `git add *` (wildcard patterns) - shell expansion can match unexpected files\n  - `git commit -a` without `-m` flag - would open an editor (not interactive)\n\n- **Ask (user approval required)**:\n\n  - Staging **modified** files (files already tracked that have changes)\n  - Staging a directory that contains modified files\n\n- **Allow without prompting**:\n\n  - Staging **new/untracked** files (no approval needed)\n  - `--dry-run` or `-n` flag (used internally)\n  - Directories containing only new files\n\n- **How it works**: Uses `git add --dry-run` to detect what would be staged,\n  then checks `git status --porcelain` to distinguish new vs modified files.\n- **Purpose**: Prevent accidental staging while allowing smooth workflow for\n  new files\n\n#### 1c. git_checkout_safety_hook.py\n\n- **Decision**: block\n- **Hard blocks** (these commands discard uncommitted work permanently with no\n  recovery option):\n\n  - `git checkout -f` / `--force` - forces checkout, discarding all local\n    changes without warning\n  - `git checkout .` - reverts ALL files in current directory to last commit\n  - `git checkout <branch> -- .` - overwrites all files with version from\n    another branch\n  - `git checkout <branch> -- <file>` - overwrites specific file from another\n    branch\n\n- **Conditional blocks**: If there are uncommitted changes, blocks and shows\n  list of modified files with safer alternatives (stash, commit, restore,\n  switch)\n- **Allows**: `git checkout -b` (new branch), `--help`, `-h`\n- **Purpose**: Protect uncommitted work from being discarded\n\n#### 1d. git_commit_block_hook.py\n\n- **Decision**: ask\n- **Trigger**: Any `git commit` command\n- **Behavior**: Prompts user for approval in the UI with message \"Git commit\n  requires your approval.\"\n- **Purpose**: Ensure user is aware of and approves commits\n- **Note**: Uses `hookSpecificOutput` with `permissionDecision: \"ask\"` to\n  trigger UI prompt\n\n#### 1e. env_file_protection_hook.py\n\n- **Decision**: block\n- **Trigger**: Any command that reads, writes, searches, or edits `.env` files\n- **Blocked operations**:\n\n  - Reading: cat, less, more, head, tail\n  - Editing: nano, vim, vi, emacs, code, subl, atom, gedit\n  - Writing: redirects (>, >>), echo, printf, sed -i, tee, cp, mv, touch\n  - Searching: grep, rg, ag, ack, find\n\n- **Alternative**: Suggests using `env-safe` command for safe inspection\n- **Purpose**: Prevent exposure of secrets and sensitive environment variables\n\n### 2. read_env_protection_hook.py (PreToolUse for Read)\n\n- **Decision**: block\n- **Trigger**: Read tool calls targeting `.env` files\n- **Blocked patterns**:\n\n  - `.env` - exact match\n  - `.env.*` - variants like `.env.local`, `.env.production`, etc.\n\n- **Alternative**: Suggests using `env-safe` command for safe inspection\n- **Purpose**: Closes the gap where the Read tool could bypass Bash-level .env\n  protections\n\n### 3. file_length_limit_hook.py (PreToolUse for Edit and Write)\n\n- **Decision**: block (with speed bump pattern)\n- **Trigger**: Edit or Write operations on source code files that would exceed\n  line limit\n- **Default limit**: 10000 lines\n- **Supported extensions**: .py, .tsx, .ts, .jsx, .js, .rs, .c, .cpp, .go,\n  .java, .kt, .swift, .rb, .php, .cs, .scala, .m, .mm, .r, .jl, and more\n- **Behavior**: Uses flag file speed bump - blocks first attempt with warning,\n  allows on second attempt if user approves\n- **Purpose**: Encourage modular, maintainable code\n\n## Summary Table\n\n| Hook | Decision Type | Description |\n|------|---------------|-------------|\n| bash_hook.py | block/ask/allow | Unified hook combining all bash safety checks |\n| rm_block_hook.py | block | Blocks rm, suggests TRASH |\n| git_add_block_hook.py | block/ask/allow | Blocks dangerous patterns; asks for modified files; allows new files |\n| git_checkout_safety_hook.py | block | Protects uncommitted changes |\n| git_commit_block_hook.py | ask | Prompts user for commit approval |\n| env_file_protection_hook.py | block | Protects .env files from Bash commands |\n| read_env_protection_hook.py | block | Protects .env files from Read tool |\n| file_length_limit_hook.py | block (speed bump) | Limits source file size |\n",
        "plugins/aichat/README.md": "# aichat\n\nTools for searching, resuming, and recovering context from CLI coding agent\nsessions (Claude Code, Codex CLI).\n\n## Components\n\n### Agent: `session-searcher`\n\nSearches previous sessions for specific work, decisions, or code patterns.\nAuto-invoked by Claude when you ask about past sessions. Returns concise\nsummaries without polluting main context.\n\n**Triggers:** Ask naturally:\n\n- \"What did we work on yesterday?\"\n- \"Find sessions where we discussed authentication\"\n- \"What design decisions did we make for the API?\"\n\n**How it works:**\n\n1. Runs `aichat search --json` to find matching sessions\n2. Reads up to 3 session files for details\n3. Returns formatted markdown summary\n\n### Skills\n\n#### `recover-context`\n\nExtracts context from a parent session when resuming work. Uses session lineage\n(shown in first user message) to find the most recent parent session.\n\n**What it extracts:**\n\n- Last task being worked on\n- Current state (completed, in-progress, blocked)\n- Pending items or next steps\n- Associated docs (issue specs, work logs, design docs)\n\n#### `session-search`\n\nFor CLI agents WITHOUT subagent support (e.g., Codex CLI). Provides the same\nsession search capability as the `session-searcher` agent, but as inline\ninstructions.\n\n> **Claude Code users:** Don't use this directly. The `session-searcher` agent\n> is more efficient.\n\n### Command: `/recover-context`\n\nSlash command that invokes the `recover-context` skill. Use when you've resumed\na session and want to quickly recover what you were working on.\n\n### Hooks (Quick Commands)\n\nType these directly in Claude to trigger special actions:\n\n| Command | What it does |\n|---------|--------------|\n| `>resume` | Copy session ID to clipboard + show resume instructions |\n| `>continue` | Same as `>resume` |\n| `>handoff` | Same as `>resume` |\n| `>session` | Copy session ID to clipboard (simple confirmation) |\n| `>session-id` | Same as `>session` |\n\nThe resume commands guide you through continuing work in a new session using\n`aichat resume <paste>`.\n\n## CLI Usage\n\n### Searching sessions\n\n```bash\n# Interactive TUI search\naichat search \"authentication bug fix\"\n\n# JSON output for scripting\naichat search --json -n 10 \"authentication\"\n\n# Filter by project\naichat search --json -g \"my-project\" \"query\"\n\n# See all options\naichat search --help\n```\n\n### Resuming sessions\n\n```bash\n# Resume a session (paste session ID from >resume command)\naichat resume <session-id>\n```\n\n### JSON output fields\n\nWhen using `--json`, each result line contains:\n\n- `session_id` - unique session identifier\n- `agent` - claude or codex\n- `project`, `branch`, `cwd` - project context\n- `lines` - number of lines in session\n- `created`, `modified` - timestamps\n- `first_msg`, `last_msg` - first and last user messages\n- `file_path` - path to session file\n- `snippet` - matching text snippet\n\n## Installation\n\nThis plugin requires the `claude-code-tools` and `aichat-search` packages:\n\n```bash\nuv tool install claude-code-tools   # Python package\ncargo install aichat-search         # Rust search TUI\n```\n\nPrerequisites:\n\n- Node.js 16+ - for action menus (resume, export, etc.)\n- Rust/Cargo - for aichat search\n\nIf you don't have uv or cargo:\n\n```bash\ncurl -LsSf https://astral.sh/uv/install.sh | sh                # uv\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh # Rust\n```\n",
        "plugins/tmux-cli/README.md": "# tmux-cli\n\nAdds the `tmux-cli` skill so Claude Code can interact with CLI scripts or other\ncode-agents running in tmux panes.\n\n## What it does\n\nThis skill enables Claude Code to communicate with other processes running in tmux\npanes, such as:\n\n- Other AI code agents (Claude Code, Codex CLI, etc.)\n- Interactive scripts waiting for input\n- Long-running processes that need monitoring\n- Debuggers (e.g., pdb) for stepping through code\n\n## Usage\n\nUse the `tmux-cli` command to send input to and capture output from other tmux panes.\n\nRun `tmux-cli --help` to see all available options.\n\nCommon use cases:\n\n- Launch another Claude instance for parallel work\n- Consult another CLI code-agent (e.g. Claude Code, Codex-CLI, or Gemini-CLI) - for help in debugging, reviewing code, or discussing ideas.\n- Send commands to a running Python debugger\n- Interact with a script that prompts for input\n- Monitor output from a background process\n\n## Key Commands\n\n### `execute` - Run command with exit code\n\nThe `execute` subcommand runs a shell command and returns both the output and exit\ncode, making it ideal for build/test automation:\n\n```bash\ntmux-cli execute \"pytest tests/\" --timeout 60\n```\n\nReturns JSON with `output` and `exit_code` fields. Use this when you need to know\nif a command succeeded or failed (e.g., builds, tests, linters).\n\nFor interactive or long-running commands, use `send` + `capture` instead.\n\n## Installation\n\nThis skill requires the `claude-code-tools` package:\n\n```bash\nuv tool install claude-code-tools\n```\n\nIf you don't have uv:\n\n```bash\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n```\n",
        "plugins/workflow/README.md": "# workflow\n\nA collection of skills and agents to enhance developer workflow with Claude Code.\n\n## Skills\n\n### 1. code-walk-thru\n\nWalk through code files in your editor to explain how code works or show changes\nyou've made.\n\n**How it works:**\n\n- Claude opens files in your editor (VSCode, Cursor, etc.) at specific line numbers\n- Walks through files one by one, waiting for you to confirm before moving on\n- Great for reviewing Claude Code's code changes, or understanding a code-base.\n\n**Example commands:**\n\n```bash\n# VSCode\ncode --goto src/main.py:42\n\n# Cursor\ncursor --goto src/main.py:42\n```\n\n### 2. log-work\n\nLog work progress to `WORKLOG/YYYYMMDD.md` files.\n\n**How it works:**\n\n- Creates/appends to a daily worklog file\n- Each entry has a timestamp and concise topic\n- Includes session ID, files created/read, and short description\n- Follows progressive disclosure - references detailed docs instead of duplicating\n\n**Example entry:**\n\n```markdown\n# 13:45 Added feature xyz\n\n- Session: abc-123\n- Created: src/feature.py\n- Read: docs/spec.md\n- Added new authentication middleware\n```\n\n### 3. make-issue-spec\n\nCreate task specification documents at `issues/YYYYMMDD-topic.md`.\n\n**How it works:**\n\n- Creates a markdown document describing a specific task\n- Includes concise implementation plan\n- Claude asks clarifying questions for underspecified parts\n- Stages the file in git if permissions allow\n\n## Agents\n\n### ui-tester\n\nA specialized agent for browser-based UI testing and validation using Chrome\nDevTools MCP Server.\n\n**When to use:**\n\n- Verify that a new feature renders correctly in the browser\n- Check responsive design at different viewport sizes\n- Validate CSS changes look correct\n- Inspect for console errors or network issues\n\n**How it works:**\n\n- Runs in isolation to prevent context pollution in the main agent\n- Uses Chrome DevTools MCP Server for all browser interactions\n- Takes screenshots, inspects DOM elements, checks console errors\n- Returns structured reports with findings organized by severity\n\n**Capabilities:**\n\n- Navigate to URLs and local dev servers\n- Inspect DOM elements and CSS properties\n- Capture screenshots at various viewport sizes\n- Check for console errors and network issues\n- Validate responsive behavior and accessibility\n\n## Installation\n\nNo additional dependencies required for skills. The ui-tester agent requires the\nChrome DevTools MCP Server to be configured.\n",
        "plugins/voice/README.md": "# Voice Plugin\n\nAudio feedback for Claude Code using [pocket-tts](https://github.com/kyutai-labs/pocket-tts).\n\nWhen the Claude Code agent completes a task, it provides a spoken summary of what\nwas accomplished.\n\n## Recommended: Speech-to-Text Companion\n\nFor a complete voice workflow, pair this TTS plugin with\n[Handy](https://github.com/cjpais/Handy) (open-source) using the **Parakeet V3**\nmodel for speech-to-text. It's stunningly fast with near-instant transcription.\n\nThe slight accuracy drop compared to larger models is immaterial when talking to\nan AI. **Pro tip**: Ask the agent to restate what it understood - this confirms\nunderstanding and helps keep the CLI agent on track.\n\n## Requirements\n\n- [uv](https://docs.astral.sh/uv/) (for running pocket-tts via `uvx`)\n- macOS (with `afplay`) or Linux (with `aplay` or `paplay`)\n- **Recommended**: [FFmpeg](https://ffmpeg.org/) (provides `ffplay` for lower-latency\n  streaming audio)\n\n## Installation\n\nInstall from the cctools-plugins marketplace:\n\n```bash\nclaude plugin add voice\n```\n\n## How It Works\n\n### Architecture Overview\n\nThe plugin uses a multi-hook strategy to get fast, reliable voice summaries:\n\n```\nUserPromptSubmit hook     ‚Üí  Injects full voice instructions each turn\n         ‚Üì\nPostToolUse hook          ‚Üí  Short reminder after each tool call\n         ‚Üì\nAgent generates üì¢ marker ‚Üí  \"üì¢ Done, fixed the auth bug!\"\n         ‚Üì\nStop hook extracts it     ‚Üí  Instant playback (no API call!)\n         ‚Üì\n[Fallback: headless Claude if agent forgets the marker]\n```\n\n### The Hooks\n\n**UserPromptSubmit hook** ‚Äî Silently injects voice instructions at the start of\neach turn, telling Claude to end longer responses with a `üì¢` spoken summary.\nUses `additionalContext` for silent injection (no terminal noise).\n\n**PostToolUse hook** ‚Äî Injects a brief reminder after each tool call to keep the\nvoice instructions fresh during long tool chains where Claude might forget.\n\n**Stop hook** ‚Äî When the agent stops, this hook:\n\n1. Checks if voice is enabled (via `~/.claude/voice.local.md`)\n2. Looks for a `üì¢` marker in the last assistant message (instant extraction)\n3. If no marker but response is short (‚â§25 words), speaks it directly\n4. Falls back to headless Claude summarization only if needed\n5. Plays the audio via pocket-tts\n\n### Word Limits\n\n- **Short responses** (‚â§25 words): Spoken directly, no summary needed\n- **Explicit summaries** (üì¢ marker or headless Claude): Flexible 1.5√ó limit (37 words)\n- **Last resort truncation**: Strict limit (25 words)\n\nThe limit is configurable via `MAX_SPOKEN_WORDS` in `hooks/voice_common.py`.\n\n### The `/voice:speak` Command\n\nControl voice feedback with the slash command:\n\n- `/voice:speak` - Enable voice feedback\n- `/voice:speak <voice>` - Set voice (e.g., azure, alba) and enable\n- `/voice:speak stop` - Disable voice feedback\n- `/voice:speak prompt <text>` - Set custom instruction for summaries\n- `/voice:speak prompt` - Clear custom prompt\n\nConfig is stored in `~/.claude/voice.local.md`.\n\n### Custom Prompts\n\nUse custom prompts to personalize how summaries are delivered:\n\n```bash\n# Be more enthusiastic\n/voice:speak prompt \"be upbeat and encouraging\"\n\n# Keep it ultra-brief\n/voice:speak prompt \"use 5 words or less\"\n\n# Add a sign-off\n/voice:speak prompt \"always end with 'back to you, boss'\"\n```\n\nThe custom prompt is appended as an additional instruction to the summarizer.\n\n### The `say` Script\n\nThe `scripts/say` script is a standalone TTS utility that:\n\n1. Checks if the pocket-tts server is running\n2. Starts the server if needed (first run may take ~30-60 seconds)\n3. Sends text to the TTS endpoint\n4. Plays the generated audio\n\n## Standalone Usage\n\nYou can use the `say` script directly from the command line:\n\n```bash\n# Basic usage\n./scripts/say \"Hello, world!\"\n\n# With a specific voice\n./scripts/say --voice azure \"Hello, world!\"\n\n# Show help\n./scripts/say --help\n```\n\n### Environment Variables\n\n- `TTS_HOST`: TTS server host (default: `localhost`)\n- `TTS_PORT`: TTS server port (default: `8000`)\n\n## Disabling\n\nDisable voice feedback temporarily:\n\n```\n/voice:speak stop\n```\n\nOr uninstall the plugin entirely:\n\n```bash\nclaude plugin remove voice\n```\n\n## Troubleshooting\n\n### Server won't start\n\nCheck the server log:\n\n```bash\ncat /tmp/pocket-tts-server.log\n```\n\n### No audio playing\n\n- **macOS**: Ensure `afplay` is available (built-in)\n- **Linux**: Ensure `aplay` or `paplay` is installed\n\n### Slow audio playback\n\nIf there's a noticeable delay before audio starts, install FFmpeg to enable\nstreaming mode:\n\n```bash\n# macOS\nbrew install ffmpeg\n\n# Ubuntu/Debian\nsudo apt install ffmpeg\n```\n\nWith FFmpeg installed, audio streams directly to `ffplay` as it's generated,\nreducing latency. Without it, the script waits for the full audio file before\nplaying.\n"
      },
      "plugins": [
        {
          "name": "safety-hooks",
          "source": "./plugins/safety-hooks",
          "description": "Provides safety guards to block or require confirmation for risky CLI operations (e.g., rm, destructive git actions, .env access, large file operations)",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add pchalasani/claude-code-tools",
            "/plugin install safety-hooks@cctools-plugins"
          ]
        },
        {
          "name": "aichat",
          "source": "./plugins/aichat",
          "description": "Adds `aichat`-related capabilities (agent support, reusable skills, hooks, and a slash command) for continuing work in CLI agent sessions without compaction, and for searching sessions",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add pchalasani/claude-code-tools",
            "/plugin install aichat@cctools-plugins"
          ]
        },
        {
          "name": "tmux-cli",
          "source": "./plugins/tmux-cli",
          "description": "Introduces tmux-cli skill for interacting with CLI scripts and other code agents inside tmux panes using the `tmux-cli` command",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add pchalasani/claude-code-tools",
            "/plugin install tmux-cli@cctools-plugins"
          ]
        },
        {
          "name": "workflow",
          "source": "./plugins/workflow",
          "description": "Workflow utilities and agents including code walkthrough tools, work logging, issue specification helpers, and a UI testing agent for browser-based validation",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add pchalasani/claude-code-tools",
            "/plugin install workflow@cctools-plugins"
          ]
        },
        {
          "name": "langroid",
          "source": "./plugins/langroid",
          "description": "Design patterns for the Langroid multi-agent LLM framework, with a skill to add new patterns as you learn them",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add pchalasani/claude-code-tools",
            "/plugin install langroid@cctools-plugins"
          ]
        },
        {
          "name": "voice",
          "source": "./plugins/voice",
          "description": "Audio feedback when Claude Code agent completes tasks using pocket-tts",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add pchalasani/claude-code-tools",
            "/plugin install voice@cctools-plugins"
          ]
        }
      ]
    }
  ]
}