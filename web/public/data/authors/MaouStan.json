{
  "author": {
    "id": "MaouStan",
    "display_name": "MaouStan",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/82369729?v=4",
    "url": "https://github.com/MaouStan",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 0,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "marketplaces": [
    {
      "name": "ralph-local",
      "version": null,
      "description": "Local fork of Ralph Wiggum - self-referential AI loops for iterative development",
      "owner_info": {
        "name": "MaouStan"
      },
      "keywords": [],
      "repo_full_name": "MaouStan/ralph-local",
      "repo_url": "https://github.com/MaouStan/ralph-local",
      "repo_description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-10T20:25:50Z",
        "created_at": "2026-01-10T20:10:56Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/hooks.json",
          "type": "blob",
          "size": 484
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 330
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 193
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 19754
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/cancel-ralph.md",
          "type": "blob",
          "size": 559
        },
        {
          "path": "commands/check-updates.md",
          "type": "blob",
          "size": 1954
        },
        {
          "path": "commands/help.md",
          "type": "blob",
          "size": 3229
        },
        {
          "path": "commands/ralph-loop.md",
          "type": "blob",
          "size": 1706
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 484
        },
        {
          "path": "hooks/session-start-hook.sh",
          "type": "blob",
          "size": 753
        },
        {
          "path": "hooks/stop-hook.sh",
          "type": "blob",
          "size": 7369
        }
      ],
      "files": {
        ".claude-plugin/hooks.json": "{\n  \"description\": \"Ralph Wiggum plugin hooks for self-referential loops\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/session-start-hook.sh\"\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/stop-hook.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        ".claude-plugin/marketplace.json": "{\n  \"$schema\": \"https://anthropic.com/claude-code/marketplace.schema.json\",\n  \"name\": \"ralph-local\",\n  \"owner\": {\n    \"name\": \"MaouStan\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"ralph-local\",\n      \"source\": \"./\",\n      \"description\": \"Local fork of Ralph Wiggum - self-referential AI loops for iterative development\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"ralph-local\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Local fork of Ralph Wiggum - self-referential AI loops for iterative development\",\n  \"author\": {\n    \"name\": \"MaouStan\"\n  }\n}\n",
        "README.md": "# Ralph Local\n\n> **Forked from**: [claude-plugins-official/ralph-wiggum](https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum) (Anthropic)\n> **Enhancements**: Parse error fixes, absolute path support for worktree isolation, Oracle Forum integration\n>\n> üì¢ **Upstream PR**: [#15853](https://github.com/anthropics/claude-code/pull/15853) - Session isolation fix contributed back to official plugin\n\nImplementation of the Ralph Wiggum technique for iterative, self-referential AI development loops in Claude Code.\n\n## üì¶ Installation\n\n### Step 1: Add the marketplace\n\n```bash\n/plugin marketplace add Soul-Brews-Studio/ralph-local\n```\n\n### Step 2: Install the plugin\n\n```bash\n/plugin install ralph-local@ralph-local\n```\n\n### Or: Clone locally\n\n```bash\n# Clone into your project\ngit clone https://github.com/Soul-Brews-Studio/ralph-local.git plugins/ralph-local\n\n# Add as local marketplace\n/plugin marketplace add ./plugins/ralph-local\n/plugin install ralph-local@ralph-local\n```\n\n---\n\n<details open>\n<summary>ü§ñ <strong>AI Assistant Installation Prompt</strong></summary>\n\n```\nInstall the ralph-local plugin for iterative AI development loops.\n\nSteps:\n1. Add marketplace: /plugin marketplace add Soul-Brews-Studio/ralph-local\n2. Install plugin: /plugin install ralph-local@ralph-local\n3. Verify: /ralph-loop --help\n4. Confirm to user:\n   - ‚úÖ Ralph Local plugin installed\n   - ‚úÖ Commands: /ralph-loop, /cancel-ralph, /check-updates\n   - ‚úÖ Ready to use\n\nUsage example:\n/ralph-loop \"Build a REST API with tests\" --max-iterations 30 --completion-promise \"COMPLETE\"\n```\n\n</details>\n\n---\n\n## üöÄ Quick Start\n\n```bash\n# Start a Ralph loop\n/ralph-loop \"Build a REST API for todos. Requirements: CRUD operations, input validation, tests. Output <promise>COMPLETE</promise> when done.\" --completion-promise \"COMPLETE\" --max-iterations 50\n```\n\nClaude will:\n- Implement the API iteratively\n- Run tests and see failures\n- Fix bugs based on test output\n- Iterate until all requirements met\n- Output the completion promise when done\n\n---\n\n## Why This Fork?\n\nThis is a local fork of the official `ralph-wiggum` plugin with significant engineering improvements.\n\n### üîß What We Engineered (laris-co)\n\n| Feature | Description | Files Changed |\n|---------|-------------|---------------|\n| **Extensive Error Handling** | Validates numeric fields, handles corrupt state files gracefully, detailed error messages | `hooks/stop-hook.sh` |\n| **Worktree Isolation** | Uses `CLAUDE_PROJECT_DIR` for multi-agent worktree support (MAW) | `hooks/stop-hook.sh` |\n| **Oracle Forum Integration** | EXIT_LOOP signal support for multi-agent coordination | Pattern documentation |\n| **Write Tool Usage** | Uses Write tool instead of bash to preserve special characters | `commands/ralph-loop.md` |\n| **Parse Error Fixes** | Fixed backtick pattern that broke eval in cancel command | `commands/cancel-ralph.md` |\n| **`/check-updates` Command** | Track upstream changes and PR status | `commands/check-updates.md` |\n| **AI Installation Prompt** | Ready-to-use prompt for AI assistants to install | `README.md` |\n| **Comprehensive Documentation** | 500+ lines of docs with history, examples, troubleshooting | `README.md` |\n\n### üîÑ Synced from Upstream (PR #15853)\n\n| Feature | Description | Source |\n|---------|-------------|--------|\n| **Session Isolation** | Each session has own state file (`state/${SESSION_ID}.md`) | [PR #15853](https://github.com/anthropics/claude-code/pull/15853) |\n| **SessionStart Hook** | Captures `session_id` and persists as `CLAUDE_SESSION_ID` | [PR #15853](https://github.com/anthropics/claude-code/pull/15853) |\n| **Plugin-relative State** | State files in `${PLUGIN_ROOT}/state/` instead of `.claude/` | [PR #15853](https://github.com/anthropics/claude-code/pull/15853) |\n\n### üìä Engineering Stats\n\n```\nTotal commits: 10\nLines added: 567+\nFiles modified: 8\nNew commands: 1 (/check-updates)\nNew hooks: 1 (SessionStart)\n```\n\n> üéâ **Contributing Back**: We merged upstream session isolation from [PR #15853](https://github.com/anthropics/claude-code/pull/15853) while keeping our extensive error handling and multi-agent features.\n\n**Credit**: Original concept by [Geoffrey Huntley](https://ghuntley.com/ralph/). Base implementation by Anthropic's Claude Code team. Enhanced by [laris-co](https://github.com/laris-co).\n\n---\n\n## What is Ralph?\n\nRalph is a development methodology based on continuous AI agent loops. As Geoffrey Huntley describes it: **\"Ralph is a Bash loop\"** - a simple `while true` that repeatedly feeds an AI agent a prompt file, allowing it to iteratively improve its work until completion.\n\nThe technique is named after Ralph Wiggum from The Simpsons, embodying the philosophy of persistent iteration despite setbacks.\n\n### Core Concept\n\nThis plugin implements Ralph using a **Stop hook** that intercepts Claude's exit attempts:\n\n```bash\n# You run ONCE:\n/ralph-loop \"Your task description\" --completion-promise \"DONE\"\n\n# Then Claude Code automatically:\n# 1. Works on the task\n# 2. Tries to exit\n# 3. Stop hook blocks exit\n# 4. Stop hook feeds the SAME prompt back\n# 5. Repeat until completion\n```\n\nThe loop happens **inside your current session** - you don't need external bash loops. The Stop hook in `hooks/stop-hook.sh` creates the self-referential feedback loop by blocking normal session exit.\n\nThis creates a **self-referential feedback loop** where:\n- The prompt never changes between iterations\n- Claude's previous work persists in files\n- Each iteration sees modified files and git history\n- Claude autonomously improves by reading its own past work in files\n\n---\n\n## Commands\n\n### /ralph-loop\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```bash\n/ralph-loop \"<prompt>\" --max-iterations <n> --completion-promise \"<text>\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Stop after N iterations (default: unlimited)\n- `--completion-promise <text>` - Phrase that signals completion\n\n**Examples:**\n\n```bash\n# Basic usage with safety limit\n/ralph-loop \"Build a todo CLI app with tests\" --max-iterations 30\n\n# With completion promise\n/ralph-loop \"Implement feature X. Output DONE when complete.\" --completion-promise \"DONE\" --max-iterations 20\n\n# Long-running task\n/ralph-loop \"Refactor codebase to use TypeScript. Output COMPLETE when all files converted and tests pass.\" --completion-promise \"COMPLETE\" --max-iterations 100\n```\n\n### /cancel-ralph\n\nCancel the active Ralph loop.\n\n**Usage:**\n```bash\n/cancel-ralph\n```\n\nThis will:\n1. Show current iteration count if loop is active\n2. Remove `.claude/ralph-loop.local.md` to stop the loop\n3. Allow normal session exit\n\n---\n\n## Prompt Writing Best Practices\n\n### 1. Clear Completion Criteria\n\n‚ùå Bad: \"Build a todo API and make it good.\"\n\n‚úÖ Good:\n```markdown\nBuild a REST API for todos.\n\nWhen complete:\n- All CRUD endpoints working\n- Input validation in place\n- Tests passing (coverage > 80%)\n- README with API docs\n- Output: <promise>COMPLETE</promise>\n```\n\n### 2. Incremental Goals\n\n‚ùå Bad: \"Create a complete e-commerce platform.\"\n\n‚úÖ Good:\n```markdown\nPhase 1: User authentication (JWT, tests)\nPhase 2: Product catalog (list/search, tests)\nPhase 3: Shopping cart (add/remove, tests)\n\nOutput <promise>COMPLETE</promise> when all phases done.\n```\n\n### 3. Self-Correction\n\n‚ùå Bad: \"Write code for feature X.\"\n\n‚úÖ Good:\n```markdown\nImplement feature X following TDD:\n1. Write failing tests\n2. Implement feature\n3. Run tests\n4. If any fail, debug and fix\n5. Refactor if needed\n6. Repeat until all green\n7. Output: <promise>COMPLETE</promise>\n```\n\n### 4. Escape Hatches\n\nAlways use `--max-iterations` as a safety net to prevent infinite loops on impossible tasks:\n\n```bash\n# Recommended: Always set a reasonable iteration limit\n/ralph-loop \"Try to implement feature X\" --max-iterations 20\n\n# In your prompt, include what to do if stuck:\n# \"After 15 iterations, if not complete:\n#  - Document what's blocking progress\n#  - List what was attempted\n#  - Suggest alternative approaches\"\n```\n\n**Note**: The `--completion-promise` uses exact string matching, so you cannot use it for multiple completion conditions (like \"SUCCESS\" vs \"BLOCKED\"). Always rely on `--max-iterations` as your primary safety mechanism.\n\n---\n\n## Philosophy\n\nRalph embodies several key principles:\n\n### 1. Iteration > Perfection\nDon't aim for perfect on first try. Let the loop refine the work.\n\n### 2. Failures Are Data\n\"Deterministically bad\" means failures are predictable and informative. Use them to tune prompts.\n\n### 3. Operator Skill Matters\nSuccess depends on writing good prompts, not just having a good model.\n\n### 4. Persistence Wins\nKeep trying until success. The loop handles retry logic automatically.\n\n---\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement (e.g., getting tests to pass)\n- Greenfield projects where you can walk away\n- Tasks with automatic verification (tests, linters)\n- Long-running development sessions (hours+)\n- After planning sessions when context is established\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Production debugging (use targeted debugging instead)\n- Cold starts without shared context\n\n---\n\n## Real-World Results\n\n- Successfully generated 6 repositories overnight in Y Combinator hackathon testing\n- One $50k contract completed for $297 in API costs\n- Created entire programming language (\"cursed\") over 3 months using this approach\n- **PhD thesis documentation**: 90+ consecutive iterations (iterations 84-115) capturing research progress\n- **Speckit workflow mastery**: 5 iterations building 3 complete apps with 2x speed improvement each time\n- **Oracle v2 infrastructure**: 66 minutes, 28 tasks, 4,479 documents indexed in one session\n\n---\n\n## Integration with Other Tools\n\nRalph Loop works exceptionally well when combined with other development patterns:\n\n### Ralph + Speckit + Subagents\n\n```\nSpeckit    ‚Üí Creates structure (spec ‚Üí plan ‚Üí tasks)\nSubagents  ‚Üí Handle bulk work in parallel\nRalph Loop ‚Üí Ensures completion (iterate until done)\n```\n\n**Example workflow:**\n1. Use `/speckit.specify` to create feature spec\n2. Use `/speckit.plan` to generate implementation plan\n3. Use `/speckit.tasks` to break down into actionable tasks\n4. Launch Ralph loop to execute: `/ralph-loop \"Complete all tasks in tasks.md\" --max-iterations 50`\n\n### Multi-Agent Coordination (Advanced)\n\n**Oracle Forum + Ralph Loop** enables multiple agents in simultaneous loops:\n\n```bash\n# Agent 1 starts Ralph loop\n/ralph-loop \"Build backend API. Check oracle_threads() for EXIT_LOOP signal.\" --max-iterations 50\n\n# Agent 2 starts Ralph loop\n/ralph-loop \"Build frontend UI. Check oracle_threads() for EXIT_LOOP signal.\" --max-iterations 50\n\n# Coordinator sends EXIT_LOOP via Oracle Forum Thread when both complete\n```\n\n**Why Forum > Search:**\n- Status visible across all agents\n- Full context history preserved\n- Async communication without polling\n- Natural completion detection\n\n---\n\n## Development History & Evolution\n\n### Timeline\n\n| Date | Event | Details |\n|------|-------|---------|\n| **2026-01-04** | Forum Integration | Multi-agent coordination via Oracle Forum proven |\n| **2026-01-03** | `/gogogo-ralph` | Fast iteration command for shared context sessions |\n| **2026-01-02** | Absolute Path Fix | Worktree isolation improvements for multi-agent work |\n| **2026-01-01** | PhD Thesis Session | 90+ iterations (84-115) documenting thesis - MILESTONE |\n| **2025-12-31** | Speckit Mastery | 5 iterations, 15 tasks, 3 apps with 2x speed improvement |\n| **2025-12-30** | Plugin Fork | `ralph-local` created to fix parse errors from official plugin |\n| **2025-12-29** | Initial Exploration | InfluxDB + Ralph Wiggum discovery, pattern documentation |\n\n### Key Milestones\n\n**Pattern Discovery (Dec 29, 2025)**\n- First documentation of Ralph loop pattern for long-running tasks\n- Core insight: \"Self-referential cycle - same prompt feeds back automatically\"\n- Session result: 66 minutes, 28 tasks, 4,479 documents indexed\n\n**Exit Condition Problem (Dec 30, 2025)**\n- Discovered: No auto-stop mechanism leads to infinite loops\n- Example: After 65/65 tasks complete, loop continued firing 100+ times\n- Solution: Manual cancellation via `rm .claude/ralph-loop.local.md`\n- Lesson: Focus tools need clear exit strategy\n\n**Plugin Fork (Dec 30, 2025)**\n- Forked from official `ralph-wiggum` to fix `````!` parse error in eval\n- Changed to use Write tool instead of bash to preserve special characters\n- Tested MAW (multi-agent worktree) delegation - all 5 agents verified\n- Checkpoint system tested successfully\n\n**Speckit Integration (Dec 31, 2025)**\n- 9 iterations building 3 apps: session-timer, quick-note, focus-log\n- Pattern emerged: 2x faster per app (muscle memory effect)\n- Key insight: \"Tools should feel like extensions of thinking, not interruptions\"\n- Proved: Ralph + Speckit = productive workflow\n\n**Multi-Agent Breakthrough (Jan 4, 2026)**\n- Pure MCP AI-to-AI coordination proven\n- Two agents in simultaneous Ralph loops\n- Communication via Oracle Forum Thread #11\n- Exit pattern: `oracle_threads()` check for EXIT_LOOP signal\n- Result: Forum-based exit conditions work reliably\n\n### Major Sessions\n\n**29 Retrospective Sessions** document Ralph usage across:\n- Infrastructure work (Oracle v2, MCP integration)\n- Plugin development and debugging\n- Philosophy sessions (execution mode, 90/10 oracle)\n- Multi-agent coordination testing\n\n**19 Learning Documents** capture patterns:\n- Core pattern documentation\n- Exit condition strategies\n- Multi-agent coordination\n- Integration with Speckit and subagents\n\n**11 Handoff Documents** preserve context:\n- Session state transfers\n- Plugin test results\n- Multi-agent coordination proofs\n\n---\n\n## Knowledge Base\n\n### Core Learning Documents\n\n**Primary Patterns:**\n\n1. **`ralph-loop-pattern-for-long-running-tasks`** (Dec 29, 2025)\n   - What: Self-referential iteration cycle\n   - When: Complex multi-phase implementations\n   - Why: \"Ralph Loop + Speckit + Subagents = Powerful combination\"\n\n2. **`ralph-loop-practice-complete-session-pattern`** (Dec 31, 2025)\n   - 9 iterations building 3 apps\n   - Pattern: 2x faster per app\n   - Insight: Tools as thinking extensions\n\n3. **`ralph-loop-needs-exit-condition`** (Dec 30, 2025)\n   - Problem: No \"done\" detection\n   - Fix: Manual cancellation required\n   - Lesson: Clear exit strategy essential\n\n4. **`ralph-loop-forum-integration-proven`** (Jan 4, 2026)\n   - Multi-agent coordination via Oracle Forum\n   - Exit pattern: Thread-based EXIT_LOOP signals\n   - Why: Status visible, full context history\n\n### File Structure\n\n```\nplugins/ralph-local/\n‚îú‚îÄ‚îÄ .claude-plugin/\n‚îÇ   ‚îî‚îÄ‚îÄ plugin.json          # Plugin metadata\n‚îú‚îÄ‚îÄ commands/\n‚îÇ   ‚îú‚îÄ‚îÄ ralph-loop.md        # Main command implementation\n‚îÇ   ‚îú‚îÄ‚îÄ cancel-ralph.md      # Cancellation command\n‚îÇ   ‚îî‚îÄ‚îÄ help.md             # Usage guide\n‚îú‚îÄ‚îÄ scripts/\n‚îÇ   ‚îî‚îÄ‚îÄ setup-ralph-loop.sh  # Setup script\n‚îú‚îÄ‚îÄ hooks/\n‚îÇ   ‚îú‚îÄ‚îÄ stop-hook.sh        # Exit interception logic\n‚îÇ   ‚îî‚îÄ‚îÄ hooks.json          # Hook configuration\n‚îî‚îÄ‚îÄ README.md               # This file\n```\n\n### State Files\n\n**Active Loop State**: `.claude/ralph-loop.local.md`\n- Tracks iteration count\n- Stores loop context\n- Removed to cancel loop\n\n**Usage:**\n```bash\n# Check if loop is active\ntest -f .claude/ralph-loop.local.md && cat .claude/ralph-loop.local.md\n\n# Cancel loop manually\nrm .claude/ralph-loop.local.md\n```\n\n---\n\n## Advanced Usage\n\n### GoGoGo Mode\n\nFor sessions where context is already established:\n\n```bash\n/gogogo-ralph \"MQTT backend working\"\n```\n\n**Philosophy**: \"We talked enough. Now build.\"\n\n**Pattern:**\n1. Plan in regular session (establish shared context)\n2. Switch to GoGoGo mode (remove decision overhead)\n3. Ralph executes until completion promise\n4. Auto-handoff at 90% context\n5. Auto-learning at 70%, blog draft at 85%\n\n**When to use:**\n- ‚úÖ After planning session (context exists)\n- ‚úÖ After spec discussion (shared understanding)\n- ‚úÖ Greenfield projects (can walk away)\n- ‚ùå Cold start (no context)\n- ‚ùå Unclear requirements\n\n### Multi-Agent Pattern\n\n**Setup:**\n1. Each agent has own worktree (via MAW - Multi-Agent Worktree)\n2. Each agent runs independent Ralph loop\n3. Coordination via Oracle Forum threads\n4. EXIT_LOOP signal for completion\n\n**Example:**\n\n```bash\n# Agent 1: Backend\ncd agents/1\n/ralph-loop \"Build API backend. Check Thread #10 for EXIT_LOOP.\" --max-iterations 50\n\n# Agent 2: Frontend\ncd agents/2\n/ralph-loop \"Build React UI. Check Thread #10 for EXIT_LOOP.\" --max-iterations 50\n\n# Coordinator: Monitor progress, send EXIT_LOOP when both complete\n```\n\n---\n\n## Troubleshooting\n\n### Loop Won't Stop\n\n**Symptom**: Claude keeps iterating even after task completion\n\n**Solutions:**\n1. Use `/cancel-ralph` command\n2. Manually remove: `rm .claude/ralph-loop.local.md`\n3. Add `--max-iterations` safety limit\n4. Use clear `--completion-promise` with exact match\n\n### Parse Errors in Cancel Command\n\n**Symptom**: `eval: ... syntax error near unexpected token`\n\n**Solution**: This fork fixes the `````!` pattern error. Ensure you're using `ralph-local`, not the official `ralph-wiggum`.\n\n### Hook Not Firing\n\n**Symptom**: Loop exits normally instead of continuing\n\n**Check:**\n1. Plugin enabled in `.claude/settings.json`\n2. Stop hook installed: `ls -la hooks/stop-hook.sh`\n3. Hook permissions: `chmod +x hooks/stop-hook.sh`\n4. Claude Code version supports stop hooks\n\n### Worktree Isolation Issues\n\n**Symptom**: Multi-agent loops interfering with each other\n\n**Solution**: This fork uses absolute paths. Update to latest version:\n```bash\ncd plugins/ralph-local\ngit pull origin main\n```\n\n---\n\n## Learn More\n\n### Original Resources\n\n- **Original technique**: https://ghuntley.com/ralph/\n- **Ralph Orchestrator**: https://github.com/mikeyobrien/ralph-orchestrator\n- **Official Plugin**: https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum\n\n### Related Patterns\n\n- **Speckit**: Structured feature development (spec ‚Üí plan ‚Üí tasks)\n- **Oracle MCP**: Knowledge base search and consultation\n- **Claude Mem**: Persistent memory across sessions\n- **MAW**: Multi-agent worktree coordination\n\n### Community\n\n- Share your Ralph loop success stories\n- Report issues: https://github.com/Soul-Brews-Studio/ralph-local/issues\n- Contribute improvements via PR\n\n---\n\n## For Help\n\nRun `/help` in Claude Code for detailed command reference and examples.\n\n---\n\n## üîç AI Trace Instructions\n\n> **For AI Assistants**: To trace the complete development history of this plugin:\n\n```\n/trace ralph-local in repo laris-co/Nat-s-Agents\n\nParent commit: c4920605\n(contains all development history before graduation)\n```\n\n**What you'll find** (64+ files):\n- 29 retrospective sessions documenting usage and evolution\n- 19 learning documents capturing patterns\n- 11 handoff documents preserving session context\n- Full commit history from Dec 29, 2025 to Jan 6, 2026\n\n**Quick clone for history access**:\n```bash\ngit clone https://github.com/laris-co/Nat-s-Agents.git\ngit checkout c4920605\n# Now you can trace: plugins/ralph-local/, œà/memory/retrospectives/, œà/memory/learnings/\n```\n\n**Key retrospectives**:\n- `œà/memory/retrospectives/2026-01/06/07.38_ralph-local-graduation.md` - Final graduation session\n- `œà/memory/retrospectives/2026-01/04/` - Multi-agent Oracle Forum integration\n- `œà/memory/retrospectives/2025-12/31/` - Speckit mastery sessions\n\n---\n\n## License\n\nSame as original ralph-wiggum plugin.\n\n**Credit**: Original concept by Geoffrey Huntley. Implementation by Anthropic's Claude Code team. Fork enhancements by Nat (laris-co).\n",
        "commands/cancel-ralph.md": "---\ndescription: \"Cancel active Ralph Wiggum loop\"\nallowed-tools: [\"Bash\"]\n---\n\n# Cancel Ralph\n\nCheck if a Ralph loop is active and cancel it.\n\n## Step 1: Check for active loop\n\nRun this bash command:\n```bash\ntest -f .claude/ralph-loop.local.md && grep '^iteration:' .claude/ralph-loop.local.md | head -1 || echo \"NO_LOOP\"\n```\n\n## Step 2: Based on output\n\n- **If output is \"NO_LOOP\"**: Say \"No active Ralph loop found.\"\n\n- **If output shows \"iteration: N\"**:\n  1. Run: `rm .claude/ralph-loop.local.md`\n  2. Report: \"Cancelled Ralph loop (was at iteration N)\"\n",
        "commands/check-updates.md": "# Check for Ralph Wiggum Updates\n\nCheck for new versions and updates from the official ralph-wiggum plugin.\n\n## Instructions\n\n1. **Check upstream repository for changes:**\n\n```bash\n# Fetch latest from official ralph-wiggum\ngh api repos/anthropics/claude-code/contents/plugins/ralph-wiggum --jq '.[] | \"\\(.name) \\(.sha | .[0:7])\"' 2>/dev/null || echo \"Check manually: https://github.com/anthropics/claude-code/tree/main/plugins/ralph-wiggum\"\n```\n\n2. **Check recent commits to ralph-wiggum:**\n\n```bash\ngh api repos/anthropics/claude-code/commits --jq '[.[] | select(.commit.message | test(\"ralph\"; \"i\"))] | .[0:5] | .[] | \"\\(.sha | .[0:7]) \\(.commit.message | split(\"\\n\")[0])\"' 2>/dev/null\n```\n\n3. **Check open PRs related to ralph:**\n\n```bash\ngh pr list --repo anthropics/claude-code --search \"ralph\" --state all --limit 10 --json number,title,state,url --jq '.[] | \"#\\(.number) [\\(.state)] \\(.title)\"'\n```\n\n4. **Check our fork's PR status:**\n\n```bash\ngh pr view 15853 --repo anthropics/claude-code --json state,title,mergedAt --jq '\"PR #15853: \\(.state) - \\(.title)\"'\n```\n\n5. **Compare local version with upstream:**\n\n```bash\n# Show local ralph-local version\necho \"=== Local ralph-local ===\"\ngit -C plugins/ralph-local log --oneline -3 2>/dev/null || echo \"Not in ralph-local directory\"\n\n# Show what's different from upstream\necho \"\"\necho \"=== Key differences from upstream ===\"\necho \"1. Session isolation (PR #15853)\"\necho \"2. Parse error fixes\"\necho \"3. Worktree isolation\"\necho \"4. Oracle Forum integration\"\necho \"5. Write tool usage\"\n```\n\n## Report Format\n\nAfter running checks, report to user:\n\n```\nüì¶ Ralph Updates Check\n\n**Upstream Status:**\n- Latest commits: [list recent ralph-related commits]\n- Open PRs: [list any open PRs]\n\n**Our PR #15853:**\n- Status: [OPEN/MERGED/CLOSED]\n- Session isolation fix\n\n**Local Version:**\n- Last commit: [hash] [message]\n- Sync status: [UP TO DATE / NEEDS SYNC]\n\n**Recommendations:**\n- [Any actions needed]\n```\n",
        "commands/help.md": "---\ndescription: \"Explain Ralph Wiggum technique and available commands\"\n---\n\n# Ralph Wiggum Plugin Help\n\nPlease explain the following to the user:\n\n## What is the Ralph Wiggum Technique?\n\nThe Ralph Wiggum technique is an iterative development methodology based on continuous AI loops, pioneered by Geoffrey Huntley.\n\n**Core concept:**\n```bash\nwhile :; do\n  cat PROMPT.md | claude-code --continue\ndone\n```\n\nThe same prompt is fed to Claude repeatedly. The \"self-referential\" aspect comes from Claude seeing its own previous work in the files and git history, not from feeding output back as input.\n\n**Each iteration:**\n1. Claude receives the SAME prompt\n2. Works on the task, modifying files\n3. Tries to exit\n4. Stop hook intercepts and feeds the same prompt again\n5. Claude sees its previous work in the files\n6. Iteratively improves until completion\n\nThe technique is described as \"deterministically bad in an undeterministic world\" - failures are predictable, enabling systematic improvement through prompt tuning.\n\n## Available Commands\n\n### /ralph-loop <PROMPT> [OPTIONS]\n\nStart a Ralph loop in your current session.\n\n**Usage:**\n```\n/ralph-loop \"Refactor the cache layer\" --max-iterations 20\n/ralph-loop \"Add tests\" --completion-promise \"TESTS COMPLETE\"\n```\n\n**Options:**\n- `--max-iterations <n>` - Max iterations before auto-stop\n- `--completion-promise <text>` - Promise phrase to signal completion\n\n**How it works:**\n1. Creates `.claude/.ralph-loop.local.md` state file\n2. You work on the task\n3. When you try to exit, stop hook intercepts\n4. Same prompt fed back\n5. You see your previous work\n6. Continues until promise detected or max iterations\n\n---\n\n### /cancel-ralph\n\nCancel an active Ralph loop (removes the loop state file).\n\n**Usage:**\n```\n/cancel-ralph\n```\n\n**How it works:**\n- Checks for active loop state file\n- Removes `.claude/.ralph-loop.local.md`\n- Reports cancellation with iteration count\n\n---\n\n## Key Concepts\n\n### Completion Promises\n\nTo signal completion, Claude must output a `<promise>` tag:\n\n```\n<promise>TASK COMPLETE</promise>\n```\n\nThe stop hook looks for this specific tag. Without it (or `--max-iterations`), Ralph runs infinitely.\n\n### Self-Reference Mechanism\n\nThe \"loop\" doesn't mean Claude talks to itself. It means:\n- Same prompt repeated\n- Claude's work persists in files\n- Each iteration sees previous attempts\n- Builds incrementally toward goal\n\n## Example\n\n### Interactive Bug Fix\n\n```\n/ralph-loop \"Fix the token refresh logic in auth.ts. Output <promise>FIXED</promise> when all tests pass.\" --completion-promise \"FIXED\" --max-iterations 10\n```\n\nYou'll see Ralph:\n- Attempt fixes\n- Run tests\n- See failures\n- Iterate on solution\n- In your current session\n\n## When to Use Ralph\n\n**Good for:**\n- Well-defined tasks with clear success criteria\n- Tasks requiring iteration and refinement\n- Iterative development with self-correction\n- Greenfield projects\n\n**Not good for:**\n- Tasks requiring human judgment or design decisions\n- One-shot operations\n- Tasks with unclear success criteria\n- Debugging production issues (use targeted debugging instead)\n\n## Learn More\n\n- Original technique: https://ghuntley.com/ralph/\n- Ralph Orchestrator: https://github.com/mikeyobrien/ralph-orchestrator\n",
        "commands/ralph-loop.md": "---\ndescription: \"Start Ralph loop in current session\"\nargument-hint: \"PROMPT [--max-iterations N] [--completion-promise TEXT]\"\nallowed-tools: [\"Bash\", \"Write\"]\n---\n\n# Ralph Loop\n\nStart a self-referential development loop.\n\n## Execute\n\nExecute the setup script to initialize the Ralph loop:\n\n```bash\n\"${CLAUDE_PLUGIN_ROOT}/scripts/setup-ralph-loop.sh\" $ARGUMENTS\n```\n\n## State File Location\n\nState files are now stored in the plugin's state directory with session ID for isolation:\n\n```bash\n# State files are stored in the plugin's state directory with session ID\nRALPH_STATE_FILE=\"${CLAUDE_PLUGIN_ROOT}/state/${CLAUDE_SESSION_ID}.md\"\nif [ -f \"$RALPH_STATE_FILE\" ]; then\n  PROMISE=$(grep '^completion_promise:' \"$RALPH_STATE_FILE\" | sed 's/completion_promise: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n  if [ -n \"$PROMISE\" ] && [ \"$PROMISE\" != \"null\" ]; then\n    echo \"\"\n    echo \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\"\n    echo \"  To complete: output <promise>$PROMISE</promise>\"\n    echo \"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\"\n  fi\nfi\n```\n\n## Instructions\n\nWork on the task. When you try to exit, the Ralph loop feeds the SAME PROMPT back. You'll see previous work in files and git history.\n\n**CRITICAL**: If completion promise is set, ONLY output `<promise>TEXT</promise>` when TRUE. Do not lie to escape.\n\n**Session Isolation**: Each Claude Code session has its own state file, so multiple sessions won't interfere with each other.\n",
        "hooks/hooks.json": "{\n  \"description\": \"Ralph Wiggum plugin hooks for self-referential loops\",\n  \"hooks\": {\n    \"SessionStart\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/session-start-hook.sh\"\n          }\n        ]\n      }\n    ],\n    \"Stop\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"${CLAUDE_PLUGIN_ROOT}/hooks/stop-hook.sh\"\n          }\n        ]\n      }\n    ]\n  }\n}\n",
        "hooks/session-start-hook.sh": "#!/bin/bash\n\n# Ralph Wiggum Session Start Hook\n# Extracts session_id from hook input and persists it as CLAUDE_SESSION_ID\n# This makes the session ID available to command scripts via environment variable\n\nset -euo pipefail\n\n# Read hook input from stdin\nHOOK_INPUT=$(cat)\n\n# Extract session_id from hook input\nSESSION_ID=$(echo \"$HOOK_INPUT\" | jq -r '.session_id // empty')\n\nif [[ -z \"$SESSION_ID\" ]]; then\n  # No session ID available - this shouldn't happen but exit gracefully\n  exit 0\nfi\n\n# CLAUDE_ENV_FILE is provided by Claude Code for SessionStart hooks\n# Writing to this file persists environment variables for the session\nif [[ -n \"${CLAUDE_ENV_FILE:-}\" ]]; then\n  echo \"export CLAUDE_SESSION_ID=\\\"$SESSION_ID\\\"\" >> \"$CLAUDE_ENV_FILE\"\nfi\n\nexit 0\n",
        "hooks/stop-hook.sh": "#!/bin/bash\n\n# Ralph Wiggum Stop Hook\n# Prevents session exit when a ralph-loop is active\n# Feeds Claude's output back as input to continue the loop\n# Now with session isolation - each session has its own state file\n\nset -euo pipefail\n\n# Read hook input from stdin (advanced stop hook API)\nHOOK_INPUT=$(cat)\n\n# Determine state directory (plugin-relative for session isolation)\nif [[ -n \"${CLAUDE_PLUGIN_ROOT:-}\" ]]; then\n  STATE_DIR=\"$CLAUDE_PLUGIN_ROOT/state\"\nelse\n  # Fallback: derive from script location (hooks/stop-hook.sh -> plugin root)\n  STATE_DIR=\"$(dirname \"$(dirname \"$0\")\")/state\"\nfi\n\n# Extract session_id from hook input\nSESSION_ID=$(echo \"$HOOK_INPUT\" | jq -r '.session_id // empty')\nif [[ -z \"$SESSION_ID\" ]]; then\n  # No session ID available - allow exit\n  exit 0\nfi\n\n# Check if ralph-loop is active for THIS session\nRALPH_STATE_FILE=\"$STATE_DIR/${SESSION_ID}.md\"\n\nif [[ ! -f \"$RALPH_STATE_FILE\" ]]; then\n  # No active loop for this session - allow exit\n  exit 0\nfi\n\n# Parse markdown frontmatter (YAML between ---) and extract values\nFRONTMATTER=$(sed -n '/^---$/,/^---$/{ /^---$/d; p; }' \"$RALPH_STATE_FILE\")\n\n# Check if loop is active (must be first check after parsing frontmatter)\nACTIVE=$(echo \"$FRONTMATTER\" | grep '^active:' | sed 's/active: *//')\nif [[ \"$ACTIVE\" != \"true\" ]]; then\n  # Loop is deactivated - allow exit\n  exit 0\nfi\nITERATION=$(echo \"$FRONTMATTER\" | grep '^iteration:' | sed 's/iteration: *//')\nMAX_ITERATIONS=$(echo \"$FRONTMATTER\" | grep '^max_iterations:' | sed 's/max_iterations: *//')\n# Extract completion_promise and strip surrounding quotes if present\nCOMPLETION_PROMISE=$(echo \"$FRONTMATTER\" | grep '^completion_promise:' | sed 's/completion_promise: *//' | sed 's/^\"\\(.*\\)\"$/\\1/')\n\n# Validate numeric fields before arithmetic operations\nif [[ ! \"$ITERATION\" =~ ^[0-9]+$ ]]; then\n  echo \"‚ö†Ô∏è  Ralph loop: State file corrupted\" >&2\n  echo \"   File: $RALPH_STATE_FILE\" >&2\n  echo \"   Problem: 'iteration' field is not a valid number (got: '$ITERATION')\" >&2\n  echo \"\" >&2\n  echo \"   This usually means the state file was manually edited or corrupted.\" >&2\n  echo \"   Ralph loop is stopping. Run /ralph-loop again to start fresh.\" >&2\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\nif [[ ! \"$MAX_ITERATIONS\" =~ ^[0-9]+$ ]]; then\n  echo \"‚ö†Ô∏è  Ralph loop: State file corrupted\" >&2\n  echo \"   File: $RALPH_STATE_FILE\" >&2\n  echo \"   Problem: 'max_iterations' field is not a valid number (got: '$MAX_ITERATIONS')\" >&2\n  echo \"\" >&2\n  echo \"   This usually means the state file was manually edited or corrupted.\" >&2\n  echo \"   Ralph loop is stopping. Run /ralph-loop again to start fresh.\" >&2\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Check if max iterations reached\nif [[ $MAX_ITERATIONS -gt 0 ]] && [[ $ITERATION -ge $MAX_ITERATIONS ]]; then\n  echo \"üõë Ralph loop: Max iterations ($MAX_ITERATIONS) reached.\"\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Get transcript path from hook input\nTRANSCRIPT_PATH=$(echo \"$HOOK_INPUT\" | jq -r '.transcript_path')\n\nif [[ ! -f \"$TRANSCRIPT_PATH\" ]]; then\n  echo \"‚ö†Ô∏è  Ralph loop: Transcript file not found\" >&2\n  echo \"   Expected: $TRANSCRIPT_PATH\" >&2\n  echo \"   This is unusual and may indicate a Claude Code internal issue.\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Read last assistant message from transcript (JSONL format - one JSON per line)\n# First check if there are any assistant messages\nif ! grep -q '\"role\":\"assistant\"' \"$TRANSCRIPT_PATH\"; then\n  echo \"‚ö†Ô∏è  Ralph loop: No assistant messages found in transcript\" >&2\n  echo \"   Transcript: $TRANSCRIPT_PATH\" >&2\n  echo \"   This is unusual and may indicate a transcript format issue\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Extract last assistant message with explicit error handling\nLAST_LINE=$(grep '\"role\":\"assistant\"' \"$TRANSCRIPT_PATH\" | tail -1)\nif [[ -z \"$LAST_LINE\" ]]; then\n  echo \"‚ö†Ô∏è  Ralph loop: Failed to extract last assistant message\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Parse JSON with error handling\nLAST_OUTPUT=$(echo \"$LAST_LINE\" | jq -r '\n  .message.content |\n  map(select(.type == \"text\")) |\n  map(.text) |\n  join(\"\\n\")\n' 2>&1)\n\n# Check if jq succeeded\nif [[ $? -ne 0 ]]; then\n  echo \"‚ö†Ô∏è  Ralph loop: Failed to parse assistant message JSON\" >&2\n  echo \"   Error: $LAST_OUTPUT\" >&2\n  echo \"   This may indicate a transcript format issue\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\nif [[ -z \"$LAST_OUTPUT\" ]]; then\n  echo \"‚ö†Ô∏è  Ralph loop: Assistant message contained no text content\" >&2\n  echo \"   Ralph loop is stopping.\" >&2\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Check for completion promise (only if set)\nif [[ \"$COMPLETION_PROMISE\" != \"null\" ]] && [[ -n \"$COMPLETION_PROMISE\" ]]; then\n  # Extract text from <promise> tags using Perl for multiline support\n  # -0777 slurps entire input, s flag makes . match newlines\n  # .*? is non-greedy (takes FIRST tag), whitespace normalized\n  PROMISE_TEXT=$(echo \"$LAST_OUTPUT\" | perl -0777 -pe 's/.*?<promise>(.*?)<\\/promise>.*/$1/s; s/^\\s+|\\s+$//g; s/\\s+/ /g' 2>/dev/null || echo \"\")\n\n  # Use = for literal string comparison (not pattern matching)\n  # == in [[ ]] does glob pattern matching which breaks with *, ?, [ characters\n  if [[ -n \"$PROMISE_TEXT\" ]] && [[ \"$PROMISE_TEXT\" = \"$COMPLETION_PROMISE\" ]]; then\n    echo \"‚úÖ Ralph loop: Detected <promise>$COMPLETION_PROMISE</promise>\"\n    rm \"$RALPH_STATE_FILE\"\n    exit 0\n  fi\nfi\n\n# Not complete - continue loop with SAME PROMPT\nNEXT_ITERATION=$((ITERATION + 1))\n\n# Extract prompt (everything after the closing ---)\n# Skip first --- line, skip until second --- line, then print everything after\n# Use i>=2 instead of i==2 to handle --- in prompt content\nPROMPT_TEXT=$(awk '/^---$/{i++; next} i>=2' \"$RALPH_STATE_FILE\")\n\nif [[ -z \"$PROMPT_TEXT\" ]]; then\n  echo \"‚ö†Ô∏è  Ralph loop: State file corrupted or incomplete\" >&2\n  echo \"   File: $RALPH_STATE_FILE\" >&2\n  echo \"   Problem: No prompt text found\" >&2\n  echo \"\" >&2\n  echo \"   This usually means:\" >&2\n  echo \"     ‚Ä¢ State file was manually edited\" >&2\n  echo \"     ‚Ä¢ File was corrupted during writing\" >&2\n  echo \"\" >&2\n  echo \"   Ralph loop is stopping. Run /ralph-loop again to start fresh.\" >&2\n  rm \"$RALPH_STATE_FILE\"\n  exit 0\nfi\n\n# Update iteration in frontmatter (portable across macOS and Linux)\n# Create temp file, then atomically replace\nTEMP_FILE=\"${RALPH_STATE_FILE}.tmp.$$\"\nsed \"s/^iteration: .*/iteration: $NEXT_ITERATION/\" \"$RALPH_STATE_FILE\" > \"$TEMP_FILE\"\nmv \"$TEMP_FILE\" \"$RALPH_STATE_FILE\"\n\n# Build system message with iteration count and completion promise info\nif [[ \"$COMPLETION_PROMISE\" != \"null\" ]] && [[ -n \"$COMPLETION_PROMISE\" ]]; then\n  SYSTEM_MSG=\"üîÑ Ralph iteration $NEXT_ITERATION | To stop: output <promise>$COMPLETION_PROMISE</promise> (ONLY when statement is TRUE - do not lie to exit!)\"\nelse\n  SYSTEM_MSG=\"üîÑ Ralph iteration $NEXT_ITERATION | No completion promise set - loop runs infinitely\"\nfi\n\n# Output JSON to block the stop and feed prompt back\n# The \"reason\" field contains the prompt that will be sent back to Claude\njq -n \\\n  --arg prompt \"$PROMPT_TEXT\" \\\n  --arg msg \"$SYSTEM_MSG\" \\\n  '{\n    \"decision\": \"block\",\n    \"reason\": $prompt,\n    \"systemMessage\": $msg\n  }'\n\n# Exit 0 for successful hook execution\nexit 0\n"
      },
      "plugins": [
        {
          "name": "ralph-local",
          "source": "./",
          "description": "Local fork of Ralph Wiggum - self-referential AI loops for iterative development",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add MaouStan/ralph-local",
            "/plugin install ralph-local@ralph-local"
          ]
        }
      ]
    }
  ]
}