{
  "author": {
    "id": "elvismdev",
    "display_name": "Elvis Morales",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/3847077?u=922e17acc8ac31b318d69b3a5019b6cf19828441&v=4",
    "url": "https://github.com/elvismdev",
    "bio": "I dabble „Ñ•(‚∏ù ÿå ‚∏ç )‚Äæ‚Äæ‚Äæ‚Äæ‚Äæ",
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 2,
      "total_skills": 1,
      "total_stars": 65,
      "total_forks": 2
    }
  },
  "marketplaces": [
    {
      "name": "claude-wordpress-skills",
      "version": null,
      "description": "WordPress engineering skills collection for Claude Code",
      "owner_info": {
        "name": "Elvis Morales",
        "email": "yo@elvismdev.io"
      },
      "keywords": [],
      "repo_full_name": "elvismdev/claude-wordpress-skills",
      "repo_url": "https://github.com/elvismdev/claude-wordpress-skills",
      "repo_description": "Professional WordPress engineering skills for Claude Code - performance optimization, security auditing, Gutenberg block development, and theme/plugin best practices.",
      "homepage": "",
      "signals": {
        "stars": 65,
        "forks": 2,
        "pushed_at": "2025-11-29T03:57:26Z",
        "created_at": "2025-11-26T06:05:47Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 591
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 704
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 5499
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/wp-perf-review.md",
          "type": "blob",
          "size": 570
        },
        {
          "path": "commands/wp-perf.md",
          "type": "blob",
          "size": 566
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/wp-performance-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/wp-performance-review/SKILL.md",
          "type": "blob",
          "size": 18165
        },
        {
          "path": "skills/wp-performance-review/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/wp-performance-review/references/anti-patterns.md",
          "type": "blob",
          "size": 35960
        },
        {
          "path": "skills/wp-performance-review/references/caching-guide.md",
          "type": "blob",
          "size": 11906
        },
        {
          "path": "skills/wp-performance-review/references/measurement-guide.md",
          "type": "blob",
          "size": 9760
        },
        {
          "path": "skills/wp-performance-review/references/wp-query-guide.md",
          "type": "blob",
          "size": 8147
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"claude-wordpress-skills\",\n  \"description\": \"WordPress engineering skills collection for Claude Code\",\n  \"owner\": {\n    \"name\": \"Elvis Morales\",\n    \"email\": \"yo@elvismdev.io\"\n  },\n  \"metadata\": {\n    \"description\": \"WordPress engineering skills for Claude Code\",\n    \"version\": \"1.3.1\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"claude-wordpress-skills\",\n      \"source\": \"./\",\n      \"description\": \"Professional WordPress engineering skills for Claude Code ‚Äî performance optimization, security auditing, Gutenberg block development, and theme/plugin best practices\"\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"claude-wordpress-skills\",\n  \"description\": \"Professional WordPress engineering skills for Claude Code ‚Äî performance optimization, security auditing, Gutenberg block development, and theme/plugin best practices\",\n  \"version\": \"1.3.1\",\n  \"author\": {\n    \"name\": \"Elvis Morales\",\n    \"url\": \"https://github.com/elvismdev\"\n  },\n  \"homepage\": \"https://github.com/elvismdev/claude-wordpress-skills\",\n  \"repository\": \"https://github.com/elvismdev/claude-wordpress-skills\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"wordpress\",\n    \"performance\",\n    \"security\",\n    \"gutenberg\",\n    \"blocks\",\n    \"themes\",\n    \"plugins\",\n    \"woocommerce\",\n    \"php\",\n    \"claude-code\",\n    \"claude-skills\"\n  ]\n}\n",
        "README.md": "# Claude WordPress Skills\n\nProfessional WordPress engineering skills for [Claude Code](https://claude.ai/code) - performance optimization, security auditing, Gutenberg block development, and theme/plugin best practices.\n\n## Available Skills\n\n| Skill | Description | Status |\n|-------|-------------|--------|\n| **wp-performance-review** | Performance code review and optimization analysis | ‚úÖ |\n| **wp-security-review** | Security audit and hardening code review | üöß |\n| **wp-gutenberg-blocks** | Block Editor / Gutenberg development | üöß |\n| **wp-theme-development** | Theme development best practices | üöß |\n| **wp-plugin-development** | Plugin architecture and standards | üöß |\n\n## Installation\n\n### Option 1: Add as Marketplace\n\nSubscribe to receive all skills and updates (Recommended):\n\n```bash\n# In Claude Code CLI\n/plugin marketplace add elvismdev/claude-wordpress-skills\n\n# Install specific skills\n/plugin install claude-wordpress-skills@claude-wordpress-skills\n```\n\n### Option 2: Clone Locally\n\n```bash\ngit clone https://github.com/elvismdev/claude-wordpress-skills.git ~/.claude/plugins/wordpress\n```\n\n### Option 3: Add to Project\n\nAdd as a git submodule for team-wide access:\n\n```bash\n# In your project root\ngit submodule add https://github.com/elvismdev/claude-wordpress-skills.git .claude/plugins/wordpress\ngit commit -m \"Add WordPress Claude skills\"\n```\n\nTeam members get the skills automatically when they clone or update the repo.\n\n### Option 4: Copy Individual Skills\n\nDownload and extract specific skills:\n\n```bash\n# Copy just the performance review skill\ncp -r skills/wp-performance-review ~/.claude/skills/\n```\n\n## Slash Commands\n\nWhen installed, these commands become available:\n\n| Command | Description |\n|---------|-------------|\n| `/wp-perf-review [path]` | Full WordPress performance code review with detailed analysis and fixes |\n| `/wp-perf [path]` | Quick triage scan using grep patterns (fast, critical issues only) |\n\n### Usage Examples\n\n```bash\n# Full review of current directory\n/wp-perf-review\n\n# Full review of specific plugin\n/wp-perf-review wp-content/plugins/my-plugin\n\n# Quick scan of a theme (fast triage)\n/wp-perf wp-content/themes/my-theme\n\n# Quick scan to check for critical issues before deploy\n/wp-perf .\n```\n\n### Command Comparison\n\n| Aspect | `/wp-perf-review` | `/wp-perf` |\n|--------|-------------------|------------|\n| **Speed** | Thorough (slower) | Fast triage |\n| **Depth** | Full analysis + fixes | Critical patterns only |\n| **Output** | Grouped by severity with line numbers | Quick list of matches |\n| **Use case** | Code review, PR review, optimization | Pre-deploy check, quick audit |\n\nWhen installed via marketplace, commands are namespaced:\n\n```bash\n/claude-wordpress-skills:wp-perf-review [path]\n/claude-wordpress-skills:wp-perf [path]\n```\n\n## Natural Language Usage\n\nSkills also activate automatically based on context. Just ask naturally:\n\n```\nReview this plugin for performance issues\nAudit this theme for scalability problems\nCheck this code for slow database queries\nHelp me optimize this WP_Query\nCheck my theme before launch\nFind anti-patterns in this plugin\n```\n\nClaude will detect the context and apply the appropriate skill.\n\n### Trigger Phrases\n\n| Skill | Trigger Phrases |\n|-------|-----------------|\n| wp-performance-review | \"performance review\", \"optimization audit\", \"slow WordPress\", \"slow queries\", \"scale WordPress\", \"high-traffic\", \"code review\", \"before launch\", \"anti-patterns\", \"timeout\", \"500 error\", \"out of memory\" |\n\n## What's Included\n\n### wp-performance-review\n\nComprehensive performance code review covering:\n\n- **Database Query Anti-Patterns** - Unbounded queries, missing WHERE clauses, slow LIKE patterns, NOT IN performance\n- **Hooks & Actions** - Expensive code on init, database writes on page load, inefficient hook placement\n- **Caching Issues** - Uncached function calls, object cache patterns, transient best practices\n- **AJAX & External Requests** - admin-ajax.php alternatives, polling patterns, HTTP timeouts\n- **Template Performance** - N+1 queries, get_template_part optimization\n- **PHP Code Patterns** - in_array() performance, heredoc escaping issues\n- **JavaScript Bundles** - Full library imports, defer/async strategies\n- **Block Editor** - registerBlockStyle overhead, InnerBlocks handling\n- **Platform Guidance** - Patterns for WordPress VIP, WP Engine, Pantheon, self-hosted\n\nOutput includes severity levels (Critical/Warning/Info) with line numbers and fix recommendations.\n\n## Requirements\n\n- [Claude Code](https://claude.ai/code) CLI installed\n- Skills are loaded automatically - no additional dependencies\n\n## Contributing\n\nü§ù Super welcome to contributions, please! See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.\n\nWays to contribute:\n\n- üêõ Report issues or incorrect/deprecated advice\n- üí° Suggest new anti-patterns or best practices\n- üìù Improve documentation or examples\n- üîß Submit new skills\n\n## License\n\nMIT License ‚Äî see [LICENSE](LICENSE) for details.\n\n## Changelog\n\nSee [CHANGELOG.md](CHANGELOG.md) for version history.\n\n---\n\n**Note**: These skills represent community best practices for WordPress development and are not affiliated with or endorsed by any specific company or platform. Some patterns reflect my own experience with WordPress and from years of working alongside engineers far smarter than me - so bias is inevitable. Contributions are always welcome; I'm genuinely curious to hear different approaches and learn together.\n",
        "commands/wp-perf-review.md": "---\ndescription: WordPress performance code review - detects database anti-patterns, caching issues, hook problems, and scalability concerns\nargument-hint: [file-or-directory]\n---\n\nUse and follow the **wp-performance-review** skill to perform a comprehensive WordPress performance code review.\n\n**Target**: $ARGUMENTS (if empty, use current working directory)\n\nExecute the full Code Review Workflow from the skill, load reference files as needed for deeper analysis, and format output using the skill's Output Format section with severity levels (Critical/Warning/Info).",
        "commands/wp-perf.md": "---\ndescription: Quick WordPress performance scan - fast triage using critical pattern detection\nargument-hint: [path]\n---\n\nUse the **wp-performance-review** skill to perform a quick triage scan.\n\n**Target**: $ARGUMENTS (if empty, use current working directory)\n\nFocus only on the \"Search Patterns for Quick Detection\" section‚Äîrun the grep commands to find critical issues fast. Report matches with file:line references and severity levels. Skip deep analysis.\n\nIf critical issues are found, suggest running `/wp-perf-review` for comprehensive analysis with fixes.",
        "skills/wp-performance-review/SKILL.md": "---\nname: wp-performance-review\ndescription: WordPress performance code review and optimization analysis. Use when reviewing WordPress PHP code for performance issues, auditing themes/plugins for scalability, optimizing WP_Query, analyzing caching strategies, checking code before launch, or detecting anti-patterns, or when user mentions \"performance review\", \"optimization audit\", \"slow WordPress\", \"slow queries\", \"high-traffic\", \"scale WordPress\", \"code review\", \"timeout\", \"500 error\", \"out of memory\", or \"site won't load\". Detects anti-patterns in database queries, hooks, object caching, AJAX, and template loading.\n---\n\n# WordPress Performance Review Skill\n\n## Overview\n\nSystematic performance code review for WordPress themes, plugins, and custom code. **Core principle:** Scan critical issues first (OOM, unbounded queries, cache bypass), then warnings, then optimizations. Report with line numbers and severity levels.\n\n## When to Use\n\n**Use when:**\n- Reviewing PR/code for WordPress theme or plugin\n- User reports slow page loads, timeouts, or 500 errors\n- Auditing before high-traffic event (launch, sale, viral moment)\n- Optimizing WP_Query or database operations\n- Investigating memory exhaustion or DB locks\n\n**Don't use for:**\n- Security-only audits (use wp-security-review when available)\n- Gutenberg block development patterns (use wp-gutenberg-blocks when available)\n- General PHP code review not specific to WordPress\n\n## Code Review Workflow\n\n1. **Identify file type** and apply relevant checks below\n2. **Scan for critical patterns first** (OOM, unbounded queries, cache bypass)\n3. **Check warnings** (inefficient but not catastrophic)\n4. **Note optimizations** (nice-to-have improvements)\n5. **Report with line numbers** using output format below\n\n## File-Type Specific Checks\n\n### Plugin/Theme PHP Files (`functions.php`, `plugin.php`, `*.php`)\nScan for:\n- `query_posts()` ‚Üí CRITICAL: Never use - breaks main query\n- `posts_per_page.*-1` or `numberposts.*-1` ‚Üí CRITICAL: Unbounded query\n- `session_start()` ‚Üí CRITICAL: Bypasses page cache\n- `add_action.*init.*` or `add_action.*wp_loaded` ‚Üí Check if expensive code runs every request\n- `update_option` or `add_option` in non-admin context ‚Üí WARNING: DB writes on page load\n- `wp_remote_get` or `wp_remote_post` without caching ‚Üí WARNING: Blocking HTTP\n\n### WP_Query / Database Code\nScan for:\n- Missing `posts_per_page` argument ‚Üí WARNING: Defaults to blog setting\n- `'meta_query'` with `'value'` comparisons ‚Üí WARNING: Unindexed column scan\n- `post__not_in` with large arrays ‚Üí WARNING: Slow exclusion\n- `LIKE '%term%'` (leading wildcard) ‚Üí WARNING: Full table scan\n- Missing `no_found_rows => true` when not paginating ‚Üí INFO: Unnecessary count\n\n### AJAX Handlers (`wp_ajax_*`, REST endpoints)\nScan for:\n- `admin-ajax.php` usage ‚Üí INFO: Consider REST API instead\n- POST method for read operations ‚Üí WARNING: Bypasses cache\n- `setInterval` or polling patterns ‚Üí CRITICAL: Self-DDoS risk\n- Missing nonce verification ‚Üí Security issue (not performance, but flag it)\n\n### Template Files (`*.php` in theme)\nScan for:\n- `get_template_part` in loops ‚Üí WARNING: Consider caching output\n- Database queries inside loops (N+1) ‚Üí CRITICAL: Query multiplication\n- `wp_remote_get` in templates ‚Üí WARNING: Blocks rendering\n\n### JavaScript Files\nScan for:\n- `$.post(` for read operations ‚Üí WARNING: Use GET for cacheability\n- `setInterval.*fetch\\|ajax` ‚Üí CRITICAL: Polling pattern\n- `import _ from 'lodash'` ‚Üí WARNING: Full library import bloats bundle\n- Inline `<script>` making AJAX calls on load ‚Üí Check necessity\n\n### Block Editor / Gutenberg Files (`block.json`, `*.js` in blocks/)\nScan for:\n- Many `registerBlockStyle()` calls ‚Üí WARNING: Each creates preview iframe\n- `wp_kses_post($content)` in render callbacks ‚Üí WARNING: Breaks InnerBlocks\n- Static blocks without `render_callback` ‚Üí INFO: Consider dynamic for maintainability\n\n### Asset Registration (`functions.php`, `*.php`)\nScan for:\n- `wp_enqueue_script` without version ‚Üí INFO: Cache busting issues\n- `wp_enqueue_script` without `defer`/`async` strategy ‚Üí INFO: Blocks rendering\n- Missing `THEME_VERSION` constant ‚Üí INFO: Version management\n- `wp_enqueue_script` without conditional check ‚Üí WARNING: Assets load globally when only needed on specific pages\n\n### Transients & Options\nScan for:\n- `set_transient` with dynamic keys (e.g., `user_{$id}`) ‚Üí WARNING: Table bloat without object cache\n- `set_transient` for frequently-changing data ‚Üí WARNING: Defeats caching purpose\n- Large data in transients on shared hosting ‚Üí WARNING: DB bloat without object cache\n\n### WP-Cron\nScan for:\n- Missing `DISABLE_WP_CRON` constant ‚Üí INFO: Cron runs on page requests\n- Long-running cron callbacks (loops over all users/posts) ‚Üí CRITICAL: Blocks cron queue\n- `wp_schedule_event` without checking if already scheduled ‚Üí WARNING: Duplicate schedules\n\n## Search Patterns for Quick Detection\n\n```bash\n# Critical issues - scan these first\ngrep -rn \"posts_per_page.*-1\\|numberposts.*-1\" .\ngrep -rn \"query_posts\\s*(\" .\ngrep -rn \"session_start\\s*(\" .\ngrep -rn \"setInterval.*fetch\\|setInterval.*ajax\\|setInterval.*\\\\\\$\\.\" .\n\n# Database writes on frontend\ngrep -rn \"update_option\\|add_option\" . | grep -v \"admin\\|activate\\|install\"\n\n# Uncached expensive functions\ngrep -rn \"url_to_postid\\|attachment_url_to_postid\\|count_user_posts\" .\n\n# External HTTP without caching\ngrep -rn \"wp_remote_get\\|wp_remote_post\\|file_get_contents.*http\" .\n\n# Cache bypass risks\ngrep -rn \"setcookie\\|session_start\" .\n\n# PHP code anti-patterns\ngrep -rn \"in_array\\s*(\" . | grep -v \"true\\s*)\" # Missing strict comparison\ngrep -rn \"<<<\" .  # Heredoc/nowdoc syntax\ngrep -rn \"cache_results.*false\" .\n\n# JavaScript bundle issues\ngrep -rn \"import.*from.*lodash['\\\"]\" .  # Full lodash import\ngrep -rn \"registerBlockStyle\" .  # Many block styles = performance issue\n\n# Asset loading issues\ngrep -rn \"wp_enqueue_script\\|wp_enqueue_style\" . | grep -v \"is_page\\|is_singular\\|is_admin\"\n\n# Transient misuse\ngrep -rn \"set_transient.*\\\\\\$\" .  # Dynamic transient keys\ngrep -rn \"set_transient\" . | grep -v \"get_transient\"  # Set without checking first\n\n# WP-Cron issues\ngrep -rn \"wp_schedule_event\" . | grep -v \"wp_next_scheduled\"  # Missing schedule check\n```\n\n## Platform Context\n\nDifferent hosting environments require different approaches:\n\n**Managed WordPress Hosts** (WP Engine, Pantheon, Pressable, WordPress VIP, etc.):\n- Often provide object caching out of the box\n- May have platform-specific helper functions (e.g., `wpcom_vip_*` on VIP)\n- Check host documentation for recommended patterns\n\n**Self-Hosted / Standard Hosting**:\n- Implement object caching wrappers manually for expensive functions\n- Consider Redis or Memcached plugins for persistent object cache\n- More responsibility for caching layer configuration\n\n**Shared Hosting**:\n- Be extra cautious about unbounded queries and external HTTP\n- Limited resources mean performance issues surface faster\n- May lack persistent object cache entirely\n\n## Quick Reference: Critical Anti-Patterns\n\n### Database Queries\n```php\n// ‚ùå CRITICAL: Unbounded query.\n'posts_per_page' => -1\n\n// ‚úÖ GOOD: Set reasonable limit, paginate if needed.\n'posts_per_page' => 100,\n'no_found_rows'  => true, // Skip count if not paginating.\n\n// ‚ùå CRITICAL: Never use query_posts().\nquery_posts( 'cat=1' ); // Breaks pagination, conditionals.\n\n// ‚úÖ GOOD: Use WP_Query or pre_get_posts filter.\n$query = new WP_Query( array( 'cat' => 1 ) );\n// Or modify main query:\nadd_action( 'pre_get_posts', function( $query ) {\n    if ( $query->is_main_query() && ! is_admin() ) {\n        $query->set( 'cat', 1 );\n    }\n} );\n\n// ‚ùå CRITICAL: Missing WHERE clause (falsy ID becomes 0).\n$query = new WP_Query( array( 'p' => intval( $maybe_false_id ) ) );\n\n// ‚úÖ GOOD: Validate ID before querying.\nif ( ! empty( $maybe_false_id ) ) {\n    $query = new WP_Query( array( 'p' => intval( $maybe_false_id ) ) );\n}\n\n// ‚ùå WARNING: LIKE with leading wildcard (full table scan).\n$wpdb->get_results( \"SELECT * FROM wp_posts WHERE post_title LIKE '%term%'\" );\n\n// ‚úÖ GOOD: Use trailing wildcard only, or use WP_Query 's' parameter.\n$wpdb->get_results( $wpdb->prepare(\n    \"SELECT * FROM wp_posts WHERE post_title LIKE %s\",\n    $wpdb->esc_like( $term ) . '%'\n) );\n\n// ‚ùå WARNING: NOT IN queries (filter in PHP instead).\n'post__not_in' => $excluded_ids\n\n// ‚úÖ GOOD: Fetch all, filter in PHP (faster for large exclusion lists).\n$posts = get_posts( array( 'posts_per_page' => 100 ) );\n$posts = array_filter( $posts, function( $post ) use ( $excluded_ids ) {\n    return ! in_array( $post->ID, $excluded_ids, true );\n} );\n```\n\n### Hooks & Actions\n```php\n// ‚ùå WARNING: Code runs on every request via init.\nadd_action( 'init', 'expensive_function' );\n\n// ‚úÖ GOOD: Check context before running expensive code.\nadd_action( 'init', function() {\n    if ( is_admin() || wp_doing_cron() ) {\n        return;\n    }\n    // Frontend-only code here.\n} );\n\n// ‚ùå CRITICAL: Database writes on every page load.\nadd_action( 'wp_head', 'prefix_bad_tracking' );\nfunction prefix_bad_tracking() {\n    update_option( 'last_visit', time() );\n}\n\n// ‚úÖ GOOD: Use object cache buffer, flush via cron.\nadd_action( 'shutdown', function() {\n    wp_cache_incr( 'page_views_buffer', 1, 'counters' );\n} );\n\n// ‚ùå WARNING: Using admin-ajax.php instead of REST API.\n// Prefer: register_rest_route() - leaner bootstrap.\n```\n\n### PHP Code\n```php\n// ‚ùå WARNING: O(n) lookup - use isset() with associative array.\nin_array( $value, $array ); // Also missing strict = true.\n\n// ‚úÖ GOOD: O(1) lookup with isset().\n$allowed = array( 'foo' => true, 'bar' => true );\nif ( isset( $allowed[ $value ] ) ) {\n    // Process.\n}\n\n// ‚ùå WARNING: Heredoc prevents late escaping.\n$html = <<<HTML\n<div>$unescaped_content</div>\nHTML;\n\n// ‚úÖ GOOD: Escape at output.\nprintf( '<div>%s</div>', esc_html( $content ) );\n```\n\n### Caching Issues\n```php\n// ‚ùå WARNING: Uncached expensive function calls.\nurl_to_postid( $url );\nattachment_url_to_postid( $attachment_url );\ncount_user_posts( $user_id );\nwp_oembed_get( $url );\n\n// ‚úÖ GOOD: Wrap with object cache (works on any host).\nfunction prefix_cached_url_to_postid( $url ) {\n    $cache_key = 'url_to_postid_' . md5( $url );\n    $post_id   = wp_cache_get( $cache_key, 'url_lookups' );\n\n    if ( false === $post_id ) {\n        $post_id = url_to_postid( $url );\n        wp_cache_set( $cache_key, $post_id, 'url_lookups', HOUR_IN_SECONDS );\n    }\n\n    return $post_id;\n}\n\n// ‚úÖ GOOD: On WordPress VIP, use platform helpers instead.\n// wpcom_vip_url_to_postid(), wpcom_vip_attachment_url_to_postid(), etc.\n\n// ‚ùå WARNING: Large autoloaded options.\nadd_option( 'prefix_large_data', $data ); // Add: , '', 'no' for autoload.\n\n// ‚ùå INFO: Missing wp_cache_get_multiple for batch lookups.\nforeach ( $ids as $id ) {\n    wp_cache_get( \"key_{$id}\" );\n}\n```\n\n### AJAX & External Requests\n```javascript\n// ‚ùå WARNING: AJAX POST request (bypasses cache).\n$.post( ajaxurl, data ); // Prefer: $.get() for read operations.\n\n// ‚ùå CRITICAL: Polling pattern (self-DDoS).\nsetInterval( () => fetch( '/wp-json/...' ), 5000 );\n```\n\n```php\n// ‚ùå WARNING: Synchronous external HTTP in page load.\nwp_remote_get( $url ); // Cache result or move to cron.\n\n// ‚úÖ GOOD: Set timeout and handle errors.\n$response = wp_remote_get( $url, array( 'timeout' => 2 ) );\nif ( is_wp_error( $response ) ) {\n    return get_fallback_data();\n}\n```\n\n### WP Cron\n```php\n// ‚ùå WARNING: WP Cron runs on page requests.\n// Add to wp-config.php:\ndefine( 'DISABLE_WP_CRON', true );\n// Run via server cron: * * * * * wp cron event run --due-now\n\n// ‚ùå CRITICAL: Long-running cron blocks entire queue.\nadd_action( 'my_daily_sync', function() {\n    foreach ( get_users() as $user ) { // 50k users = hours.\n        sync_user_data( $user );\n    }\n} );\n\n// ‚úÖ GOOD: Batch processing with rescheduling.\nadd_action( 'my_batch_sync', function() {\n    $offset = (int) get_option( 'sync_offset', 0 );\n    $users  = get_users( array( 'number' => 100, 'offset' => $offset ) );\n\n    if ( empty( $users ) ) {\n        delete_option( 'sync_offset' );\n        return;\n    }\n\n    foreach ( $users as $user ) {\n        sync_user_data( $user );\n    }\n\n    update_option( 'sync_offset', $offset + 100 );\n    wp_schedule_single_event( time() + 60, 'my_batch_sync' );\n} );\n\n// ‚ùå WARNING: Scheduling without checking if already scheduled.\nwp_schedule_event( time(), 'hourly', 'my_task' ); // Creates duplicates!\n\n// ‚úÖ GOOD: Check before scheduling.\nif ( ! wp_next_scheduled( 'my_task' ) ) {\n    wp_schedule_event( time(), 'hourly', 'my_task' );\n}\n```\n\n### Cache Bypass Issues\n```php\n// ‚ùå CRITICAL: Plugin starts PHP session on frontend (bypasses ALL page cache).\nsession_start(); // Check plugins for this - entire site becomes uncacheable!\n\n// ‚ùå WARNING: Unique query params create cache misses.\n// https://example.com/?utm_source=fb&utm_campaign=123&fbclid=abc\n// Each unique URL = separate cache entry = cache miss.\n// Solution: Strip marketing params at CDN/edge level.\n\n// ‚ùå WARNING: Setting cookies on public pages.\nsetcookie( 'visitor_id', $id ); // Prevents caching for that user.\n```\n\n### Transients Misuse\n```php\n// ‚ùå WARNING: Dynamic transient keys create table bloat (without object cache).\nset_transient( \"user_{$user_id}_cart\", $data, HOUR_IN_SECONDS );\n// 10,000 users = 10,000 rows in wp_options!\n\n// ‚úÖ GOOD: Use object cache for user-specific data.\nwp_cache_set( \"cart_{$user_id}\", $data, 'user_carts', HOUR_IN_SECONDS );\n\n// ‚ùå WARNING: Transients for frequently-changing data defeats purpose.\nset_transient( 'visitor_count', $count, 60 ); // Changes every minute.\n\n// ‚úÖ GOOD: Use object cache for volatile data.\nwp_cache_set( 'visitor_count', $count, 'stats' );\n\n// ‚ùå WARNING: Large data in transients on shared hosting.\nset_transient( 'api_response', $megabytes_of_json, DAY_IN_SECONDS );\n// Without object cache = serialized blob in wp_options.\n\n// ‚úÖ GOOD: Check hosting before using transients for large data.\nif ( wp_using_ext_object_cache() ) {\n    set_transient( 'api_response', $data, DAY_IN_SECONDS );\n} else {\n    // Store in files or skip caching on shared hosting.\n}\n```\n\n### Asset Loading\n```php\n// ‚ùå WARNING: Assets load globally when only needed on specific pages.\nadd_action( 'wp_enqueue_scripts', function() {\n    wp_enqueue_script( 'contact-form-js', ... );\n    wp_enqueue_style( 'contact-form-css', ... );\n} );\n\n// ‚úÖ GOOD: Conditional enqueue based on page/template.\nadd_action( 'wp_enqueue_scripts', function() {\n    if ( is_page( 'contact' ) || is_page_template( 'contact-template.php' ) ) {\n        wp_enqueue_script( 'contact-form-js', ... );\n        wp_enqueue_style( 'contact-form-css', ... );\n    }\n} );\n\n// ‚úÖ GOOD: Only load WooCommerce assets on shop pages.\nadd_action( 'wp_enqueue_scripts', function() {\n    if ( ! is_woocommerce() && ! is_cart() && ! is_checkout() ) {\n        wp_dequeue_style( 'woocommerce-general' );\n        wp_dequeue_script( 'wc-cart-fragments' );\n    }\n} );\n```\n\n### External API Requests\n```php\n// ‚ùå WARNING: No timeout set (default is 5 seconds).\nwp_remote_get( $url ); // Set timeout: array( 'timeout' => 2 ).\n\n// ‚ùå WARNING: Missing error handling for API failures.\n$response = wp_remote_get( $url );\necho $response['body']; // Check is_wp_error() first!\n```\n\n### Sitemaps & Redirects\n```php\n// ‚ùå WARNING: Generating sitemaps for deep archives (crawlers hammer these).\n// Solution: Exclude old post types, cache generated sitemaps.\n\n// ‚ùå CRITICAL: Redirect loops consuming CPU.\n// Debug with: x-redirect-by header, wp_debug_backtrace_summary().\n```\n\n### Post Meta Queries\n```php\n// ‚ùå WARNING: Searching meta_value without index.\n'meta_query' => array(\n    array(\n        'key'   => 'color',\n        'value' => 'red',\n    ),\n)\n// Better: Use taxonomy or encode value in meta_key name.\n\n// ‚ùå WARNING: Binary meta values requiring value scan.\n'meta_key'   => 'featured',\n'meta_value' => 'true',\n// Better: Presence of 'is_featured' key = true, absence = false.\n```\n\n**For deeper context on any pattern:** Load `references/anti-patterns.md`\n\n## Severity Definitions\n\n| Severity | Description |\n|----------|-------------|\n| **Critical** | Will cause failures at scale (OOM, 500 errors, DB locks) |\n| **Warning** | Degrades performance under load |\n| **Info** | Optimization opportunity |\n\n## Output Format\n\nStructure findings as:\n\n```markdown\n## Performance Review: [filename/component]\n\n### Critical Issues\n- **Line X**: [Issue] - [Explanation] - [Fix]\n\n### Warnings  \n- **Line X**: [Issue] - [Explanation] - [Fix]\n\n### Recommendations\n- [Optimization opportunities]\n\n### Summary\n- Total issues: X Critical, Y Warnings, Z Info\n- Estimated impact: [High/Medium/Low]\n```\n\n## Common Mistakes\n\nWhen performing performance reviews, avoid these errors:\n\n| Mistake | Why It's Wrong | Fix |\n|---------|----------------|-----|\n| Flagging `posts_per_page => -1` in admin-only code | Admin queries don't face public scale | Check context - admin, CLI, cron are lower risk |\n| Missing the `session_start()` buried in a plugin | Cache bypass affects entire site | Always grep for `session_start` across all code |\n| Ignoring `no_found_rows` for non-paginated queries | Small optimization but adds up | Flag as INFO, not WARNING |\n| Recommending object cache on shared hosting | Many shared hosts lack persistent cache | Check hosting environment first |\n| Only reviewing PHP, missing JS polling | JS `setInterval` + fetch = self-DDoS | Review `.js` files for polling patterns |\n\n## Deep-Dive References\n\nLoad these references based on the task:\n\n| Task | Reference to Load |\n|------|-------------------|\n| Reviewing PHP code for issues | `references/anti-patterns.md` |\n| Optimizing WP_Query calls | `references/wp-query-guide.md` |\n| Implementing caching | `references/caching-guide.md` |\n| High-traffic event prep | `references/measurement-guide.md` |\n\n**Note**: For standard code reviews, `anti-patterns.md` contains all patterns needed. Other references provide deeper context when specifically optimizing queries, implementing caching strategies, or preparing for traffic events.\n",
        "skills/wp-performance-review/references/anti-patterns.md": "# WordPress Performance Anti-Patterns\n\nComplete catalog of performance anti-patterns for WordPress code review.\n\n## Quick Lookup Table\n\n| Pattern to Find | Severity | Issue |\n|-----------------|----------|-------|\n| `posts_per_page => -1` | CRITICAL | Unbounded query |\n| `numberposts => -1` | CRITICAL | Unbounded query |\n| `query_posts()` | CRITICAL | Replaces main query, breaks pagination |\n| `session_start()` | CRITICAL | Cache bypass |\n| `setInterval.*fetch` | CRITICAL | Polling/self-DDoS |\n| `intval($var)` in query args | CRITICAL | Falsy ‚Üí 0 ‚Üí no WHERE |\n| `update_option` on frontend | CRITICAL | DB write per request |\n| `cache_results => false` | WARNING | Disables query cache |\n| `LIKE '%...%'` | WARNING | Full table scan |\n| `post__not_in` | WARNING | Slow exclusion, filter in PHP instead |\n| `meta_query` with `value` | WARNING | Unindexed scan |\n| `wp_remote_get` uncached | WARNING | Blocking HTTP |\n| `$.post(` for reads | WARNING | Bypasses cache |\n| `add_option` without autoload=no | WARNING | Bloats alloptions |\n| `setcookie()` on public pages | WARNING | Prevents caching |\n| `url_to_postid()` | WARNING | Uncached lookup |\n| `get_template_part` in loops | WARNING | Repeated file I/O |\n| `admin-ajax.php` | WARNING | Full WP bootstrap |\n| `in_array()` without strict | WARNING | O(n) complexity at scale |\n| `import _ from 'lodash'` | WARNING | Full library import bloats bundle |\n| Heredoc/nowdoc syntax | WARNING | Prevents late escaping |\n| Page builder plugins | WARNING | High query count |\n| Infinite scroll with POST | WARNING | Uncached requests |\n| Many `registerBlockStyle()` | WARNING | Creates iframe per style |\n| Missing script version | INFO | Cache busting issues |\n| Missing `no_found_rows` | INFO | Unnecessary count |\n\n## Database Query Anti-Patterns\n\n### Unbounded Queries (CRITICAL)\nQueries without limits can return millions of rows, causing OOM errors and timeouts.\n\n```php\n// ‚ùå BAD: No limit - returns ALL posts.\n$query = new WP_Query(\n    array(\n        'post_type'      => 'post',\n        'posts_per_page' => -1, // CRITICAL: Unbounded.\n    )\n);\n\n// ‚úÖ GOOD: Always set reasonable limits.\n$query = new WP_Query(\n    array(\n        'post_type'      => 'post',\n        'posts_per_page' => 100,\n        'no_found_rows'  => true, // Skip counting total rows if not paginating.\n    )\n);\n```\n\n### Using query_posts() (CRITICAL)\n`query_posts()` replaces the main query, breaking pagination and conditional functions. Never use it.\n\n```php\n// ‚ùå CRITICAL: Never use query_posts().\nquery_posts( 'cat=1&posts_per_page=5' );\n// Breaks: is_single(), is_page(), pagination, etc.\n\n// ‚úÖ GOOD: Use pre_get_posts to modify main query.\nadd_action( 'pre_get_posts', 'prefix_modify_main_query' );\n\nfunction prefix_modify_main_query( $query ) {\n    if ( ! is_admin() && $query->is_main_query() && $query->is_home() ) {\n        $query->set( 'posts_per_page', 5 );\n        $query->set( 'cat', 1 );\n    }\n}\n\n// ‚úÖ GOOD: Use WP_Query for secondary queries.\n$custom_query = new WP_Query(\n    array(\n        'cat'            => 1,\n        'posts_per_page' => 5,\n    )\n);\n```\n\n### Disabling Query Cache (WARNING)\nSetting `cache_results => false` prevents WordPress from caching query results.\n\n```php\n// ‚ùå BAD: Disables query result caching.\n$query = new WP_Query(\n    array(\n        'post_type'     => 'post',\n        'cache_results' => false, // Forces fresh DB query every time.\n    )\n);\n\n// ‚úÖ GOOD: Let WordPress cache results (default behavior).\n$query = new WP_Query(\n    array(\n        'post_type' => 'post',\n        // cache_results defaults to true.\n    )\n);\n```\n\n### Missing WHERE Clause (CRITICAL)\nFalsy values cast to int become 0, removing the WHERE clause entirely.\n\n```php\n// ‚ùå BAD: If $post_id is false/null, this becomes p=0 (no filter!).\n$post_id = get_some_id_that_might_fail(); // Returns false.\n$query   = new WP_Query(\n    array(\n        'p'              => intval( $post_id ), // intval( false ) = 0.\n        'posts_per_page' => -1,\n    )\n);\n// Result: SELECT * FROM wp_posts WHERE 1=1... (returns ALL posts).\n\n// ‚úÖ GOOD: Validate before querying.\n$post_id = get_some_id_that_might_fail();\n\nif ( $post_id ) {\n    $query = new WP_Query(\n        array(\n            'p' => $post_id,\n        )\n    );\n}\n```\n\n### LIKE with Leading Wildcard (WARNING)\nLeading wildcards force full table scans - indexes cannot be used.\n\n```php\n// ‚ùå BAD: Full table scan.\n$results = $wpdb->get_results(\n    $wpdb->prepare(\n        \"SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s\",\n        '%search%'\n    )\n);\n\n// ‚úÖ BETTER: Trailing wildcard can use index.\n$results = $wpdb->get_results(\n    $wpdb->prepare(\n        \"SELECT * FROM {$wpdb->posts} WHERE post_title LIKE %s\",\n        'search%'\n    )\n);\n\n// ‚úÖ BEST: Offload to ElasticSearch for full-text search.\n// Use ElasticPress plugin for search queries.\n```\n\n### NOT IN Queries (WARNING)\n`post__not_in` and `NOT IN` clauses scale poorly with large exclusion lists. A better approach is filtering in PHP instead.\n\n```php\n// ‚ùå BAD: Slow with many IDs - creates expensive SQL.\n$query = new WP_Query(\n    array(\n        'post__not_in'   => $hundreds_of_ids, // Each ID checked per row.\n        'posts_per_page' => 10,\n    )\n);\n\n// ‚úÖ GOOD: Use positive filtering when possible.\n$query = new WP_Query(\n    array(\n        'post__in'       => $desired_ids,\n        'posts_per_page' => 10,\n        'orderby'        => 'post__in',\n    )\n);\n\n// ‚úÖ BETTER: Filter in PHP after fetching extra posts.\n$posts_to_exclude = array( 1, 2, 3, 4, 5 );\n$query            = new WP_Query(\n    array(\n        'posts_per_page' => 10 + count( $posts_to_exclude ), // Fetch extra.\n        'no_found_rows'  => true,\n    )\n);\n\n$count = 0;\nwhile ( $query->have_posts() && $count < 10 ) {\n    $query->the_post();\n\n    if ( in_array( get_the_ID(), $posts_to_exclude, true ) ) {\n        continue; // Skip excluded posts.\n    }\n\n    // Process post.\n    $count++;\n}\nwp_reset_postdata();\n```\n\n### Over-use of Taxonomies (WARNING)\nInclude child terms multiplies query complexity.\n\n```php\n// ‚ùå BAD: Queries all child categories too.\n$query = new WP_Query(\n    array(\n        'cat' => 6, // include_children defaults to true.\n    )\n);\n\n// ‚úÖ GOOD: Exclude children when not needed.\n$query = new WP_Query(\n    array(\n        'cat'              => 6,\n        'include_children' => false,\n    )\n);\n```\n\n### Missing Date Limits (INFO)\nMature sites accumulate millions of posts over years.\n\n```php\n// ‚ùå BAD: Scans entire posts table.\n$query = new WP_Query(\n    array(\n        'category_name'  => 'news',\n        'posts_per_page' => 10,\n    )\n);\n\n// ‚úÖ GOOD: Limit to recent content.\n$query = new WP_Query(\n    array(\n        'category_name'  => 'news',\n        'posts_per_page' => 10,\n        'date_query'     => array(\n            array(\n                'after' => '3 months ago',\n            ),\n        ),\n    )\n);\n```\n\n## Hooks & Actions Anti-Patterns\n\n### Expensive Code on Every Request (WARNING)\nCode hooked to `init`, `wp_loaded`, or `plugins_loaded` runs on EVERY request.\n\n```php\n// ‚ùå BAD: Runs on every page load.\nadd_action( 'init', 'prefix_fetch_external_data_bad' );\n\nfunction prefix_fetch_external_data_bad() {\n    $data = wp_remote_get( 'https://api.example.com/data' ); // HTTP call every request!\n}\n\n// ‚úÖ GOOD: Use transients or object cache.\nadd_action( 'init', 'prefix_fetch_external_data_good' );\n\nfunction prefix_fetch_external_data_good() {\n    $data = get_transient( 'prefix_external_data' );\n\n    if ( false === $data ) {\n        $response = wp_remote_get( 'https://api.example.com/data' );\n\n        if ( ! is_wp_error( $response ) ) {\n            $data = wp_remote_retrieve_body( $response );\n            set_transient( 'prefix_external_data', $data, HOUR_IN_SECONDS );\n        }\n    }\n}\n```\n\n### Database Writes on Page Load (CRITICAL)\nINSERT/UPDATE on every request causes database contention and binlog growth.\n\n```php\n// ‚ùå CRITICAL: DB write on every page view.\nadd_action( 'wp_head', 'prefix_track_views_bad' );\n\nfunction prefix_track_views_bad() {\n    $views = get_option( 'prefix_page_views', 0 );\n    update_option( 'prefix_page_views', $views + 1 );\n}\n\n// ‚úÖ GOOD: Batch via object cache, flush periodically via cron.\nadd_action( 'shutdown', 'prefix_track_views_good' );\n\nfunction prefix_track_views_good() {\n    wp_cache_incr( 'prefix_page_views_buffer', 1, 'counters' );\n}\n\n// Cron job flushes buffer to database.\nadd_action( 'prefix_flush_view_counts', 'prefix_flush_views_to_db' );\n\nfunction prefix_flush_views_to_db() {\n    $buffer = wp_cache_get( 'prefix_page_views_buffer', 'counters' );\n\n    if ( $buffer ) {\n        $current = get_option( 'prefix_page_views', 0 );\n        update_option( 'prefix_page_views', $current + $buffer );\n        wp_cache_delete( 'prefix_page_views_buffer', 'counters' );\n    }\n}\n```\n\n### Inefficient Hook Placement (WARNING)\nRunning code in hooks that fire when not needed.\n\n```php\n// ‚ùå BAD: Runs on admin AND frontend.\nadd_action( 'init', 'prefix_frontend_only_function' );\n\n// ‚úÖ GOOD: Conditional execution.\nadd_action( 'init', 'prefix_maybe_run_frontend_code' );\n\nfunction prefix_maybe_run_frontend_code() {\n    if ( is_admin() ) {\n        return;\n    }\n    prefix_frontend_only_function();\n}\n\n// ‚úÖ BETTER: Use appropriate hook that only fires on frontend.\nadd_action( 'template_redirect', 'prefix_frontend_only_function' );\n```\n\n### Excessive Hook Callbacks (WARNING)\nMany callbacks on the same hook add function call overhead.\n\n```php\n// ‚ùå BAD: 50 separate callbacks.\nfor ( $i = 0; $i < 50; $i++ ) {\n    add_filter( 'the_content', \"prefix_filter_{$i}\" );\n}\n\n// ‚úÖ GOOD: Consolidate into single callback.\nadd_filter( 'the_content', 'prefix_process_content' );\n\nfunction prefix_process_content( $content ) {\n    // All transformations in one place.\n    $content = prefix_transform_links( $content );\n    $content = prefix_add_schema( $content );\n    $content = prefix_lazy_load_images( $content );\n\n    return $content;\n}\n```\n\n## AJAX & External Request Anti-Patterns\n\n### Using admin-ajax.php (WARNING)\nadmin-ajax.php loads full WordPress, including `admin_init` hooks.\n\n```php\n// ‚ùå BAD: Full WP bootstrap for simple data.\nadd_action( 'wp_ajax_nopriv_prefix_get_posts', 'prefix_ajax_handler' );\n\nfunction prefix_ajax_handler() {\n    // Handle AJAX request.\n    wp_send_json_success( $data );\n}\n\n// ‚úÖ GOOD: Use REST API - leaner bootstrap.\nadd_action( 'rest_api_init', 'prefix_register_rest_routes' );\n\nfunction prefix_register_rest_routes() {\n    register_rest_route(\n        'prefix/v1',\n        '/posts',\n        array(\n            'methods'             => 'GET',\n            'callback'            => 'prefix_rest_get_posts',\n            'permission_callback' => '__return_true',\n        )\n    );\n}\n\nfunction prefix_rest_get_posts( $request ) {\n    // Handle REST request.\n    return rest_ensure_response( $data );\n}\n```\n\n### POST for Read Operations (WARNING)\nPOST requests bypass page cache, causing unnecessary server load.\n\n```javascript\n// ‚ùå BAD: POST bypasses cache\n$.post(ajaxurl, { action: 'get_items' }, callback);\n\n// ‚úÖ GOOD: GET requests can be cached\n$.get('/wp-json/myapp/v1/items', callback);\n```\n\n### AJAX Polling (CRITICAL)\nPolling creates sustained uncached load - effectively a self-DDoS.\n\n```javascript\n// ‚ùå CRITICAL: Self-DDoS\nsetInterval(() => {\n    fetch('/wp-json/myapp/v1/updates');\n}, 5000);  // Every 5 seconds per user!\n\n// ‚úÖ GOOD: Use WebSockets, SSE, or long-polling with backoff\n// ‚úÖ GOOD: Poll less frequently with exponential backoff\n// ‚úÖ BEST: Push notifications instead of polling\n```\n\n### Uncached External HTTP (WARNING)\nSynchronous HTTP calls block page generation.\n\n```php\n// ‚ùå BAD: Blocks page render.\nfunction prefix_get_weather_widget() {\n    $response = wp_remote_get( 'https://api.weather.com/current' );\n    return prefix_process_weather( $response );\n}\n\n// ‚úÖ GOOD: Cache external responses.\nfunction prefix_get_weather_widget_cached() {\n    $weather = wp_cache_get( 'prefix_weather_data', 'external_api' );\n\n    if ( false === $weather ) {\n        $response = wp_remote_get(\n            'https://api.weather.com/current',\n            array( 'timeout' => 2 )\n        );\n\n        if ( ! is_wp_error( $response ) ) {\n            $weather = wp_remote_retrieve_body( $response );\n            wp_cache_set( 'prefix_weather_data', $weather, 'external_api', 300 );\n        }\n    }\n\n    return prefix_process_weather( $weather );\n}\n\n// ‚úÖ BEST: Fetch via cron, display from cache.\nadd_action( 'prefix_fetch_weather', 'prefix_cron_fetch_weather' );\n\nfunction prefix_cron_fetch_weather() {\n    $response = wp_remote_get( 'https://api.weather.com/current' );\n\n    if ( ! is_wp_error( $response ) ) {\n        $weather = wp_remote_retrieve_body( $response );\n        wp_cache_set( 'prefix_weather_data', $weather, 'external_api', HOUR_IN_SECONDS );\n    }\n}\n```\n\n## Template Anti-Patterns\n\n### Over-use of get_template_part (WARNING)\nEach template part requires file system access and additional processing.\n\n```php\n// ‚ùå BAD: Template part called 50 times in loop.\nwhile ( have_posts() ) {\n    the_post();\n    get_template_part( 'partials/card' ); // File access each iteration.\n}\n\n// ‚úÖ GOOD: Use template part with data passing (WordPress 5.5+).\nwhile ( have_posts() ) {\n    the_post();\n    get_template_part(\n        'partials/card',\n        null,\n        array(\n            'post_id' => get_the_ID(),\n            'title'   => get_the_title(),\n        )\n    );\n}\n\n// ‚úÖ ALTERNATIVE: Cache rendered output for identical partials.\n$card_cache = array();\n\nwhile ( have_posts() ) {\n    the_post();\n    $post_id = get_the_ID();\n\n    if ( ! isset( $card_cache[ $post_id ] ) ) {\n        ob_start();\n        get_template_part( 'partials/card' );\n        $card_cache[ $post_id ] = ob_get_clean();\n    }\n\n    echo $card_cache[ $post_id ]; // phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped\n}\n```\n\n### N+1 Query Problem (CRITICAL)\nQuerying inside loops multiplies database calls.\n\n```php\n// ‚ùå CRITICAL: 1 query per post.\nwhile ( have_posts() ) {\n    the_post();\n    $author = get_user_by( 'id', get_the_author_meta( 'ID' ) ); // Query per post!\n    $meta   = get_post_meta( get_the_ID(), 'views', true );     // Another query per post!\n}\n\n// ‚úÖ GOOD: Prime caches before the loop.\n$post_ids = wp_list_pluck( $query->posts, 'ID' );\nupdate_postmeta_cache( $post_ids ); // Single query for all meta.\n\nwhile ( have_posts() ) {\n    the_post();\n    // Now get_post_meta() uses cached data - no additional queries.\n    $meta = get_post_meta( get_the_ID(), 'views', true );\n}\n```\n\n## PHP Code Anti-Patterns\n\n### in_array() Without Strict Comparison (WARNING)\n`in_array()` has O(n) complexity - at scale, use associative array with `isset()` for O(1) lookups.\n\n```php\n// ‚ùå BAD: O(n) lookup - slow with large arrays.\n$allowed = array( 'foo', 'bar', 'baz' );\nif ( in_array( $value, $allowed ) ) {\n    // Process.\n}\n\n// ‚ùå ALSO BAD: Missing strict comparison (type coercion issues).\nif ( in_array( $value, $allowed ) ) {\n    // 0 == 'foo' is true due to type juggling!\n}\n\n// ‚úÖ GOOD: O(1) lookup with isset().\n$allowed = array(\n    'foo' => true,\n    'bar' => true,\n    'baz' => true,\n);\n\nif ( isset( $allowed[ $value ] ) ) {\n    // Process.\n}\n\n// ‚úÖ ACCEPTABLE: in_array() with strict comparison for small arrays.\nif ( in_array( $value, $allowed, true ) ) {\n    // Third parameter enables strict type checking.\n}\n```\n\n### Heredoc/Nowdoc Syntax (WARNING)\nHeredoc/nowdoc prevents late escaping - escape data at point of output, not before.\n\n```php\n// ‚ùå BAD: Can't escape inside heredoc.\n$html = <<<HTML\n<div class=\"$class\">$user_content</div>\nHTML;\n// XSS vulnerability - $user_content not escaped.\n\n// ‚úÖ GOOD: Late escaping at output.\nprintf(\n    '<div class=\"%s\">%s</div>',\n    esc_attr( $class ),\n    esc_html( $user_content )\n);\n\n// ‚úÖ GOOD: Use template part for complex HTML.\nget_template_part(\n    'partials/card',\n    null,\n    array(\n        'class'   => $class,\n        'content' => $user_content,\n    )\n);\n```\n\n### Storing Large Data in Options (WARNING)\nThe wp_options table should stay lean. Best practice: under 500 rows, autoloaded data under 1MB total. Large autoloaded options slow every page load.\n\n```php\n// ‚ùå BAD: Storing HTML/large data in options.\nupdate_option( 'prefix_plugin_cache', $huge_html_string );\n\n// ‚úÖ GOOD: Store IDs, fetch data on demand.\nupdate_option( 'prefix_plugin_post_ids', array( 1, 2, 3 ) ); // Small data.\n\n// ‚úÖ GOOD: Use transients with expiration for cache-like data.\nset_transient( 'prefix_cache', $data, HOUR_IN_SECONDS );\n\n// ‚úÖ GOOD: Use object cache for large frequently-accessed data.\nwp_cache_set( 'prefix_data', $large_data, 'prefix_plugin', HOUR_IN_SECONDS );\n```\n\n## Options & Transients Anti-Patterns\n\n### Large Autoloaded Options (WARNING)\nAll autoloaded options load on every request into `alloptions` cache.\n\n```php\n// ‚ùå BAD: Large data autoloaded.\nadd_option( 'prefix_plugin_log', $massive_array ); // autoload defaults to 'yes'.\n\n// ‚úÖ GOOD: Disable autoload for large/infrequent data.\nadd_option( 'prefix_plugin_log', $massive_array, '', 'no' );\n\n// ‚úÖ GOOD: Use update_option with explicit autoload (WordPress 4.2+).\nupdate_option( 'prefix_plugin_log', $data, false ); // false = no autoload.\n```\n\n### Transients in Database (WARNING)\nWithout object cache, transients bloat wp_options table.\n\n```php\n// ‚ùå BAD on hosts without persistent object cache: DB bloat.\nset_transient( 'prefix_data', $data, DAY_IN_SECONDS );\n\n// ‚úÖ GOOD: Check for object cache availability.\nif ( wp_using_ext_object_cache() ) {\n    set_transient( 'prefix_data', $data, DAY_IN_SECONDS );\n} else {\n    // Use file cache or skip caching on shared hosting.\n}\n```\n\n## WP Cron Anti-Patterns\n\n### Default WP Cron Behavior (WARNING)\nBy default, WP Cron runs on page requests, adding latency.\n\n```php\n// ‚ùå BAD: Cron tasks run during user requests (default behavior).\n\n// ‚úÖ GOOD: Disable WP Cron and use server cron.\n// In wp-config.php:\ndefine( 'DISABLE_WP_CRON', true );\n\n// Server crontab:\n// * * * * * cd /path/to/wp && wp cron event run --due-now\n```\n\n## Uncached Function Calls\n\n### Functions That Need Caching (WARNING)\nThese WordPress core functions query the database on every call without caching. At scale, they cause significant performance issues.\n\n| Function | Issue | Solution |\n|----------|-------|----------|\n| `url_to_postid()` | Full posts table scan | Wrap with object cache |\n| `attachment_url_to_postid()` | Expensive meta lookup | Wrap with object cache |\n| `count_user_posts()` | COUNT query per call | Cache result per user |\n| `get_adjacent_post()` | Complex query | Cache or avoid in loops |\n| `wp_oembed_get()` | External HTTP + parsing | Cache with transient |\n| `wp_old_slug_redirect()` | Meta table lookup | Cache result |\n| `file_get_contents()` | Filesystem/HTTP call | Cache external content |\n\n### Generic Caching Wrapper Pattern\n\n```php\n/**\n * Cached version of url_to_postid() - works on any WordPress installation.\n *\n * @param string $url The URL to look up.\n * @return int Post ID, or 0 if not found.\n */\nfunction prefix_cached_url_to_postid( $url ) {\n    $cache_key = 'url_to_postid_' . md5( $url );\n    $post_id   = wp_cache_get( $cache_key, 'url_lookups' );\n\n    if ( false === $post_id ) {\n        $post_id = url_to_postid( $url );\n        wp_cache_set( $cache_key, $post_id, 'url_lookups', HOUR_IN_SECONDS );\n    }\n\n    return $post_id;\n}\n\n/**\n * Cached version of count_user_posts().\n *\n * @param int    $user_id   User ID.\n * @param string $post_type Post type to count.\n * @return int Number of posts.\n */\nfunction prefix_cached_count_user_posts( $user_id, $post_type = 'post' ) {\n    $cache_key = 'user_post_count_' . $user_id . '_' . $post_type;\n    $count     = wp_cache_get( $cache_key, 'user_counts' );\n\n    if ( false === $count ) {\n        $count = count_user_posts( $user_id, $post_type );\n        wp_cache_set( $cache_key, $count, 'user_counts', HOUR_IN_SECONDS );\n    }\n\n    return $count;\n}\n\n/**\n * Reusable wrapper for any expensive function call.\n *\n * @param string   $cache_key Unique cache key.\n * @param callable $callback  Function to call if cache miss.\n * @param string   $group     Cache group.\n * @param int      $ttl       Time to live in seconds.\n * @return mixed Cached or fresh result.\n */\nfunction prefix_cached_call( $cache_key, $callback, $group = '', $ttl = 3600 ) {\n    $result = wp_cache_get( $cache_key, $group );\n\n    if ( false === $result ) {\n        $result = call_user_func( $callback );\n        wp_cache_set( $cache_key, $result, $group, $ttl );\n    }\n\n    return $result;\n}\n```\n\n### WordPress VIP Platform Helpers\n\nOn WordPress VIP, use the platform's pre-built cached helper functions instead of writing your own wrappers:\n\n```php\n// ‚ùå AVOID on VIP: Uncached core functions.\n$post_id    = url_to_postid( $url );\n$attach_id  = attachment_url_to_postid( $image_url );\n$post_count = count_user_posts( $user_id );\n$prev_post  = get_adjacent_post( false, '', true );\n$embed_html = wp_oembed_get( $video_url );\n$response   = wp_remote_get( $api_url );\n\n// ‚úÖ USE on VIP: Cached platform alternatives.\n$post_id    = wpcom_vip_url_to_postid( $url );\n$attach_id  = wpcom_vip_attachment_url_to_postid( $image_url );\n$post_count = wpcom_vip_count_user_posts( $user_id );\n$prev_post  = wpcom_vip_get_adjacent_post( false, '', true );\n$embed_html = wpcom_vip_wp_oembed_get( $video_url );\n$response   = vip_safe_wp_remote_get( $api_url );\n\n// VIP-specific: Safe remote request with built-in fallback and caching.\n$response = vip_safe_wp_remote_get(\n    $api_url,\n    array(\n        'fallback_value' => '',           // Return this on failure.\n        'threshold'      => 3,            // Failures before fallback.\n        'timeout'        => 2,            // Request timeout in seconds.\n    )\n);\n```\n\n### Platform Guidance\n\n| Platform | Recommendation |\n|----------|----------------|\n| **WordPress VIP** | Use `wpcom_vip_*` helpers - they handle caching, fallbacks, and edge cases |\n| **WP Engine, Pantheon, etc.** | Check host documentation for platform-specific optimizations |\n| **Self-hosted with object cache** | Use the generic caching wrapper pattern above |\n| **Shared hosting (no object cache)** | Use transients, but be aware they fall back to database storage |\n\n## External API Anti-Patterns\n\n### Plugin-Initiated PHP Sessions (CRITICAL)\nPlugins that call `session_start()` on frontend requests make the entire site uncacheable.\n\n```php\n// ‚ùå CRITICAL: This single line can disable page caching site-wide\nsession_start();\n\n// Detection: Search codebase for session_start()\ngrep -r \"session_start\" wp-content/plugins/ wp-content/themes/\n\n// ‚úÖ SOLUTION: Use cookies or wp_cache for non-sensitive data\n// ‚úÖ SOLUTION: Only use sessions for logged-in users\nif (is_user_logged_in()) {\n    session_start();\n}\n```\n\n### Query Parameter Cache Busting (WARNING)\nMarketing UTM parameters and tracking IDs create unique URLs, causing cache misses.\n\n```php\n// ‚ùå BAD: Each unique URL = separate cache entry\n// https://example.com/?utm_source=facebook&utm_campaign=summer&fbclid=abc123\n// https://example.com/?utm_source=twitter&utm_campaign=summer\n// Result: Homepage cached hundreds of times with different params\n\n// ‚úÖ SOLUTION: Configure CDN to ignore/strip marketing params\n// Cloudflare, Fastly, Varnish can all strip query params before cache lookup\n\n// ‚úÖ SOLUTION: Canonical redirect in WordPress\nadd_action('template_redirect', function() {\n    $strip_params = ['utm_source', 'utm_medium', 'utm_campaign', 'fbclid', 'gclid'];\n    $dominated_query = array_diff_key($_GET, array_flip($strip_params));\n    \n    if (count($_GET) !== count($dominated_query)) {\n        $url = remove_query_arg($strip_params);\n        wp_redirect($url, 301);\n        exit;\n    }\n});\n```\n\n### Unnecessary Cookies on Public Pages (WARNING)\nSetting cookies prevents CDN caching for that visitor.\n\n```php\n// ‚ùå BAD: Cookie set on every visit\nadd_action('init', function() {\n    setcookie('visitor_tracking', uniqid(), time() + 86400, '/');\n});\n// Result: No page caching for any visitor with this cookie\n\n// ‚úÖ GOOD: Set tracking cookies via JavaScript (doesn't affect server cache)\n// ‚úÖ GOOD: Use analytics services instead of custom cookies\n// ‚úÖ GOOD: If cookie needed, set only on specific actions (not every page)\n```\n\n### Missing Timeout Set (WARNING)\nDefault timeout is 5 seconds - too long for page generation.\n\n```php\n// ‚ùå BAD: Default 5 second timeout blocks page render\n$response = wp_remote_get('https://api.example.com/data');\n\n// ‚úÖ GOOD: Short timeout with fallback\n$response = wp_remote_get('https://api.example.com/data', [\n    'timeout' => 2,  // 2 seconds max\n]);\n\nif (is_wp_error($response)) {\n    // Return cached/default data\n    return get_fallback_data();\n}\n```\n\n### No Error Handling (WARNING)\nAPI failures can break page output or cause PHP errors.\n\n```php\n// ‚ùå BAD: Assumes success\n$response = wp_remote_get($url);\n$data = json_decode($response['body']);\n\n// ‚úÖ GOOD: Handle failures gracefully\n$response = wp_remote_get($url, ['timeout' => 2]);\n\nif (is_wp_error($response)) {\n    error_log('API Error: ' . $response->get_error_message());\n    return $cached_fallback;\n}\n\n$code = wp_remote_retrieve_response_code($response);\nif (200 !== $code) {\n    error_log(\"API returned status: $code\");\n    return $cached_fallback;\n}\n\n$body = wp_remote_retrieve_body($response);\n$data = json_decode($body, true);\n```\n\n### Synchronous API Calls Without Caching (WARNING)\nEvery page load waits for external API response.\n\n```php\n// ‚ùå BAD: Blocks every page load\nfunction get_weather() {\n    return wp_remote_get('https://api.weather.com/...');\n}\n\n// ‚úÖ GOOD: Cache responses, fetch via cron\nfunction get_weather() {\n    $cached = wp_cache_get('weather_data');\n    if (false !== $cached) {\n        return $cached;\n    }\n    \n    // Fallback to slightly stale data if API fails\n    $stale = get_transient('weather_data_stale');\n    \n    $response = wp_remote_get('https://api.weather.com/...', ['timeout' => 2]);\n    if (!is_wp_error($response)) {\n        $data = wp_remote_retrieve_body($response);\n        wp_cache_set('weather_data', $data, '', 300);\n        set_transient('weather_data_stale', $data, DAY_IN_SECONDS);\n        return $data;\n    }\n    \n    return $stale ?: '';\n}\n```\n\n## Sitemap Anti-Patterns\n\n### Uncached Dynamic Sitemaps (WARNING)\nCrawlers can hammer sitemap endpoints, generating expensive queries.\n\n```php\n// ‚ùå BAD: Sitemap generated on every request\n// WordPress core sitemaps can be slow for large archives\n\n// ‚úÖ GOOD: Pre-generate and cache sitemaps.\n// Use msm-sitemaps plugin for large sites.\n// Or cache sitemap output:\nfunction cached_sitemap() {\n    $cache_key = 'sitemap_' . get_query_var('sitemap');\n    $sitemap = wp_cache_get($cache_key, 'sitemaps');\n    \n    if (false === $sitemap) {\n        $sitemap = generate_sitemap();\n        wp_cache_set($cache_key, $sitemap, 'sitemaps', HOUR_IN_SECONDS);\n    }\n    \n    return $sitemap;\n}\n```\n\n### Including Deep Archives (INFO)\nSitemaps for years-old content trigger unnecessary query load.\n\n```php\n// ‚úÖ GOOD: Exclude old content from sitemaps\nadd_filter('wp_sitemaps_posts_query_args', function($args) {\n    $args['date_query'] = [\n        'after' => '2 years ago'\n    ];\n    return $args;\n});\n\n// ‚úÖ GOOD: Exclude specific post types\nadd_filter('wp_sitemaps_post_types', function($post_types) {\n    unset($post_types['attachment']);\n    unset($post_types['revision']);\n    return $post_types;\n});\n```\n\n## Plugin & Theme Anti-Patterns\n\n### Page Builder Performance (WARNING)\nPage builder plugins add significant overhead - extra code, database queries, and processing.\n\n```php\n// ‚ùå WARNING: Page builders at scale.\n// - Generate inefficient HTML/CSS.\n// - Add many database queries per page.\n// - May compile templates on every request (especially problematic on read-only filesystems).\n// - Block editor (Gutenberg) is more performant than most page builders.\n\n// ‚úÖ RECOMMENDATIONS:\n// - Use Gutenberg/block editor for new projects.\n// - Custom code for high-traffic landing pages.\n// - If using page builders, test query count and generation time.\n// - Avoid page builders on pages receiving high traffic.\n```\n\n### Infinite Scroll with POST Requests (WARNING)\nInfinite scroll plugins often use POST requests, bypassing cache entirely.\n\n```php\n// ‚ùå BAD: POST request for each scroll (bypasses cache)\n// As user scrolls, each AJAX request = uncached hit to origin\njQuery.post(ajaxurl, { action: 'load_more_posts', page: 2 });\n\n// ‚úÖ GOOD: Use GET requests for infinite scroll (cacheable)\njQuery.get('/wp-json/mysite/v1/posts', { page: 2 });\n\n// ‚úÖ GOOD: Pre-render next page URLs that can be cached\n// /page/2/, /page/3/ etc. are cacheable at CDN level\n\n// ‚úÖ GOOD: Implement cache warming for paginated content\n```\n\n## JavaScript Bundle Anti-Patterns\n\n### Full Library Imports (WARNING)\nImporting entire libraries when only parts are needed bloats JavaScript bundles.\n\n```javascript\n// ‚ùå BAD: Imports entire lodash library (~70KB)\nimport _ from 'lodash';\nconst result = _.map(items, transform);\n\n// ‚úÖ GOOD: Import only what you need (~2KB)\nimport map from 'lodash/map';\nconst result = map(items, transform);\n\n// ‚ùå BAD: Barrel file exports pull in everything\n// utils/index.js: export * from './heavy-module';\nimport { smallFunction } from './utils';  // Loads entire utils\n\n// ‚úÖ GOOD: Import directly from module\nimport { smallFunction } from './utils/small-module';\n```\n\n### Missing Script Loading Strategy (INFO)\nWordPress 6.3+ supports native defer/async for non-blocking script loading.\n\n```php\n// ‚ùå BAD: Blocks rendering (default behavior)\nwp_enqueue_script('my-script', get_template_directory_uri() . '/js/script.js');\n\n// ‚úÖ GOOD: Defer non-critical scripts (WordPress 6.3+)\nwp_enqueue_script('my-script', get_template_directory_uri() . '/js/script.js', [], '1.0.0', [\n    'strategy' => 'defer',  // or 'async'\n]);\n\n// ‚úÖ GOOD: Load in footer for older WP versions\nwp_enqueue_script('my-script', get_template_directory_uri() . '/js/script.js', [], '1.0.0', true);\n```\n\n### Missing Asset Version Strings (INFO)\nWithout version strings, browser caches may serve stale assets after deployments.\n\n```php\n// ‚ùå BAD: No version - cache busting issues\nwp_enqueue_script('my-script', get_template_directory_uri() . '/js/script.js');\nwp_enqueue_style('my-style', get_template_directory_uri() . '/css/style.css');\n\n// ‚úÖ GOOD: Use theme/plugin version constant\ndefine('THEME_VERSION', '1.0.0');\nwp_enqueue_script('my-script', get_template_directory_uri() . '/js/script.js', [], THEME_VERSION);\nwp_enqueue_style('my-style', get_template_directory_uri() . '/css/style.css', [], THEME_VERSION);\n\n// ‚úÖ GOOD: Use file modification time for development\nwp_enqueue_script('my-script', get_template_directory_uri() . '/js/script.js', [], \n    filemtime(get_template_directory() . '/js/script.js'));\n```\n\n## Block Editor Anti-Patterns\n\n### Too Many Custom Block Styles (WARNING)\nEach block style creates a preview iframe in the editor, causing severe performance degradation.\n\n```javascript\n// ‚ùå BAD: Each style = separate iframe for preview\nregisterBlockStyle('core/group', { name: 'green-dots', label: 'Green Dots' });\nregisterBlockStyle('core/group', { name: 'blue-waves', label: 'Blue Waves' });\nregisterBlockStyle('core/group', { name: 'red-stripes', label: 'Red Stripes' });\n// 10+ styles = editor becomes unusable\n\n// ‚úÖ GOOD: Use custom attributes with block filters\nimport { addFilter } from '@wordpress/hooks';\n\naddFilter('blocks.registerBlockType', 'namespace/bg-patterns', (settings, name) => {\n    if (name !== 'core/group') return settings;\n    \n    return {\n        ...settings,\n        attributes: {\n            ...settings.attributes,\n            backgroundPattern: { type: 'string', default: '' }\n        }\n    };\n});\n// Add UI via BlockEdit filter, style via render_block filter\n```\n\n### Re-sanitizing InnerBlocks Content (WARNING)\nInnerBlocks content is already sanitized - running wp_kses_post breaks embeds and core functionality.\n\n```php\n// ‚ùå BAD: Breaks embeds, iframes, and other allowed content\nfunction render_my_block($attributes, $content) {\n    return '<div class=\"my-block\">' . wp_kses_post($content) . '</div>';\n}\n\n// ‚úÖ GOOD: InnerBlocks content is pre-sanitized\nfunction render_my_block($attributes, $content) {\n    return '<div class=\"my-block\">' . $content . '</div>';\n}\n\n// ‚úÖ GOOD: Escape attributes, not InnerBlocks content\nfunction render_my_block($attributes, $content) {\n    $class = esc_attr($attributes['className'] ?? '');\n    return '<div class=\"my-block ' . $class . '\">' . $content . '</div>';\n}\n```\n\n### Static Blocks for Client Builds (INFO)\nStatic blocks store markup in the database, requiring deprecations for any design changes.\n\n```php\n// ‚ùå PROBLEMATIC: Static block - markup stored in DB\n// Any HTML change requires deprecation handler or manual re-save of all posts\n\n// ‚úÖ GOOD: Dynamic block - only attributes stored, markup rendered on request\nregister_block_type('namespace/my-block', [\n    'render_callback' => 'render_my_block',  // Dynamic rendering\n    'attributes' => [\n        'title' => ['type' => 'string'],\n    ]\n]);\n\n// Design changes update all instances automatically without re-saving posts\n```\n\n## Redirect Anti-Patterns\n\n### Redirect Loops (CRITICAL)\nInfinite server-side redirects consume CPU without easy detection.\n\n```php\n// Debug redirect source using x-redirect-by header\nadd_filter('x_redirect_by', function($x_redirect_by, $status, $location) {\n    // Log for debugging\n    error_log(\"Redirect to $location by: $x_redirect_by (status: $status)\");\n    \n    // For deep debugging, output stack trace:\n    // error_log(wp_debug_backtrace_summary());\n    \n    return $x_redirect_by;\n}, 10, 3);\n\n// Always set x_redirect_by when creating redirects\nwp_redirect($url, 301, 'My Plugin Name');\n```\n\n### Redirect Chains (WARNING)\nMultiple sequential redirects add latency and confuse caches.\n\n```php\n// ‚ùå BAD: A ‚Üí B ‚Üí C ‚Üí D (chain of redirects)\n// Each redirect = full HTTP round-trip\n\n// ‚úÖ GOOD: Direct redirect A ‚Üí D\n// Audit redirects regularly, collapse chains\n```\n\n## Post Meta Anti-Patterns\n\n### Querying meta_value Without Index (WARNING)\nThe `meta_value` column isn't indexed by default - full table scan.\n\n```php\n// ‚ùå BAD: Scans entire postmeta table\n$query = new WP_Query([\n    'meta_query' => [\n        ['key' => 'color', 'value' => 'red']\n    ]\n]);\n\n// ‚úÖ BETTER: Use taxonomy for filterable attributes\n// Register 'color' taxonomy, term 'red'\n$query = new WP_Query([\n    'tax_query' => [\n        ['taxonomy' => 'color', 'field' => 'slug', 'terms' => 'red']\n    ]\n]);\n```\n\n### Binary Meta Values (WARNING)\nChecking `meta_value = 'true'` requires scanning all matching keys.\n\n```php\n// ‚ùå BAD: Must scan meta_value column\n$query = new WP_Query([\n    'meta_key' => 'is_featured',\n    'meta_value' => 'true'\n]);\n\n// ‚úÖ GOOD: Key presence = true, absence = false\n$query = new WP_Query([\n    'meta_key' => 'is_featured',\n    'meta_compare' => 'EXISTS'\n]);\n\n// ‚úÖ ALTERNATIVE: Encode value in key name\n// Instead of: meta_key='category', meta_value='sports'\n// Use: meta_key='category_sports' (just check EXISTS)\n```\n\n### Excessive Post Meta (INFO)\n`wp_postmeta` table grows to multiples of `wp_posts` - optimize storage.\n\n```php\n// ‚ùå BAD: Storing large data in post meta\nupdate_post_meta($id, 'full_api_response', $huge_json);\n\n// ‚úÖ GOOD: Store minimal data, fetch details on demand\nupdate_post_meta($id, 'api_resource_id', $resource_id);\n\n// ‚ùå BAD: Many separate meta entries\nupdate_post_meta($id, 'address_line1', $line1);\nupdate_post_meta($id, 'address_line2', $line2);\nupdate_post_meta($id, 'address_city', $city);\n// ... 10 more fields\n\n// ‚úÖ GOOD: Serialize related data\nupdate_post_meta($id, 'address', [\n    'line1' => $line1,\n    'city' => $city,\n    // ...\n]);\n```\n",
        "skills/wp-performance-review/references/caching-guide.md": "# WordPress Caching Strategy Guide\n\nComprehensive guide to caching strategies for high-performance WordPress applications.\n\n## Caching Review Checklist\n\nWhen reviewing caching implementation:\n\n**Page Cache Compatibility**\n- [ ] No `session_start()` on frontend\n- [ ] No `setcookie()` on public pages (unless necessary)\n- [ ] No `$_SESSION` usage on cacheable pages\n- [ ] POST used only for writes, GET for reads\n\n**Object Cache Usage**\n- [ ] Expensive queries wrapped with `wp_cache_get`/`wp_cache_set`\n- [ ] Cache keys include relevant variables (locale, user role if needed)\n- [ ] TTL set appropriately (not too long, not too short)\n- [ ] `wp_cache_get_multiple` for batch lookups\n- [ ] Cache invalidation on relevant `save_post` hooks\n\n**Race Condition Prevention**\n- [ ] `wp_cache_add` used for locking when needed\n- [ ] Stale-while-revalidate for high-traffic cached items\n- [ ] Cache pre-warming via cron for critical data\n\n## Caching Layers Overview\n\n```\nUser Request\n    ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   CDN / Edge    ‚îÇ ‚Üê Full page cache (HTML)\n‚îÇ   Cache         ‚îÇ   Static assets (JS, CSS, images)\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Page Cache     ‚îÇ ‚Üê Full page cache (server-level)\n‚îÇ  (Varnish, etc) ‚îÇ   Bypassed by: cookies, POST, query vars\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ  Object Cache   ‚îÇ ‚Üê Database query results\n‚îÇ  (Redis/Memcached)‚îÇ   Transients, options, computed data\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n         ‚Üì\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ   Database      ‚îÇ ‚Üê MySQL query cache (if enabled)\n‚îÇ   (MySQL)       ‚îÇ   InnoDB buffer pool\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n## Page Cache\n\n### Cache Headers\n\n```php\n// Set cache-friendly headers\nfunction set_cache_headers() {\n    if (!is_user_logged_in() && !is_admin()) {\n        header('Cache-Control: public, max-age=300, s-maxage=3600');\n        header('Vary: Accept-Encoding');\n    }\n}\nadd_action('send_headers', 'set_cache_headers');\n\n// Prevent caching for dynamic pages\nfunction prevent_page_cache() {\n    if (is_user_specific_page()) {\n        header('Cache-Control: private, no-cache, no-store');\n        nocache_headers();\n    }\n}\n```\n\n### Cache Bypass Triggers (Avoid These)\n\n```php\n// ‚ùå Starting PHP sessions bypasses cache\nsession_start();  // Avoid on frontend\n\n// ‚ùå Unique query parameters create cache misses\n// https://example.com/?utm_source=twitter&utm_campaign=123\n// Solution: Strip marketing params at CDN level\n\n// ‚ùå POST requests always bypass cache\n// Use GET for read operations\n\n// ‚ùå Setting cookies prevents caching\nsetcookie('my_cookie', 'value');  // Use sparingly\n```\n\n### TTL (Time To Live) Strategy\n\n| Content Type | Recommended TTL |\n|--------------|-----------------|\n| Homepage | 5-15 minutes |\n| Archive pages | 15-60 minutes |\n| Single posts | 1-24 hours |\n| Static pages | 24+ hours |\n| Media files | 1 year (versioned) |\n\n## Object Cache\n\n### Basic Usage\n\n```php\n// Store data\nwp_cache_set('my_key', $data, 'my_group', 3600);  // 1 hour expiry\n\n// Retrieve data\n$data = wp_cache_get('my_key', 'my_group');\nif (false === $data) {\n    $data = expensive_computation();\n    wp_cache_set('my_key', $data, 'my_group', 3600);\n}\n\n// Delete data\nwp_cache_delete('my_key', 'my_group');\n\n// Add only if doesn't exist (atomic)\n$added = wp_cache_add('my_key', $data, 'my_group', 3600);\n```\n\n### Batch Operations (Efficient)\n\n```php\n// ‚ùå BAD: Multiple round-trips\nforeach ($ids as $id) {\n    $data[$id] = wp_cache_get(\"item_$id\", 'items');\n}\n\n// ‚úÖ GOOD: Single round-trip\n$keys = array_map(fn($id) => \"item_$id\", $ids);\n$data = wp_cache_get_multiple($keys, 'items');\n```\n\n### Cache Groups\n\n```php\n// Use groups to organize and bulk-delete\nwp_cache_set('post_123', $data, 'my_plugin_posts');\nwp_cache_set('post_456', $data, 'my_plugin_posts');\n\n// Clear entire group (if supported by backend)\nwp_cache_flush_group('my_plugin_posts');  // Redis supports this\n```\n\n### Cache Key Versioning\n\n```php\n// Version cache keys for easy invalidation\nfunction get_cache_key($base) {\n    $version = wp_cache_get('cache_version', 'my_plugin') ?: 1;\n    return \"{$base}_v{$version}\";\n}\n\n// Invalidate all by incrementing version\nfunction invalidate_all_cache() {\n    wp_cache_incr('cache_version', 1, 'my_plugin');\n}\n```\n\n## Race Conditions\n\n### Problem: Concurrent Cache Regeneration\n\nWhen cache expires, multiple requests may simultaneously regenerate it.\n\n```\nRequest A ‚îÄ‚î¨‚îÄ Cache miss ‚îÄ‚Üí Start regeneration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Set cache\n           ‚îÇ\nRequest B ‚îÄ‚î¥‚îÄ Cache miss ‚îÄ‚Üí Start regeneration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Set cache (duplicate!)\n           ‚îÇ\nRequest C ‚îÄ‚î¥‚îÄ Cache miss ‚îÄ‚Üí Start regeneration ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí Set cache (duplicate!)\n```\n\n### Solution: Locking Pattern\n\n```php\nfunction get_expensive_data() {\n    $cache_key = 'expensive_data';\n    $lock_key = 'expensive_data_lock';\n    \n    // Try to get cached data\n    $data = wp_cache_get($cache_key);\n    if (false !== $data) {\n        return $data;\n    }\n    \n    // Try to acquire lock (atomic operation)\n    $lock_acquired = wp_cache_add($lock_key, true, '', 30);  // 30 second lock\n    \n    if ($lock_acquired) {\n        // We got the lock - regenerate cache\n        $data = expensive_computation();\n        wp_cache_set($cache_key, $data, '', 3600);\n        wp_cache_delete($lock_key);  // Release lock\n        return $data;\n    }\n    \n    // Another process is regenerating - wait and retry\n    usleep(100000);  // 100ms\n    return get_expensive_data();  // Retry (add max retries in production)\n}\n```\n\n### Solution: Stale-While-Revalidate\n\n```php\nfunction get_data_with_stale() {\n    $cache_key = 'my_data';\n    $stale_key = 'my_data_stale';\n    \n    $data = wp_cache_get($cache_key);\n    if (false !== $data) {\n        return $data;\n    }\n    \n    // Try to get stale data while regenerating\n    $stale_data = wp_cache_get($stale_key);\n    \n    // Regenerate in background (non-blocking)\n    if (false === $stale_data) {\n        // No stale data - must wait\n        $data = regenerate_data();\n        wp_cache_set($cache_key, $data, '', 300);\n        wp_cache_set($stale_key, $data, '', 3600);  // Keep stale longer\n        return $data;\n    }\n    \n    // Schedule background regeneration\n    wp_schedule_single_event(time(), 'regenerate_my_data');\n    \n    // Return stale data immediately\n    return $stale_data;\n}\n```\n\n## Cache Stampede Prevention\n\n### Problem\n\nCache expires ‚Üí Thousands of requests hit database simultaneously.\n\n### Solution 1: Jitter (Randomized Expiry)\n\n```php\nfunction set_cache_with_jitter($key, $data, $base_ttl) {\n    // Add ¬±10% randomization to TTL\n    $jitter = rand(-($base_ttl * 0.1), $base_ttl * 0.1);\n    $ttl = $base_ttl + $jitter;\n    wp_cache_set($key, $data, '', $ttl);\n}\n```\n\n### Solution 2: Pre-warming via Cron\n\n```php\n// Regenerate cache before it expires\nadd_action('pre_warm_popular_caches', function() {\n    $popular_queries = ['homepage_posts', 'featured_products', 'menu_items'];\n    \n    foreach ($popular_queries as $query) {\n        // Force regeneration\n        wp_cache_delete($query);\n        get_cached_query($query);  // Regenerates and caches\n    }\n});\n\n// Schedule to run before typical expiry\nif (!wp_next_scheduled('pre_warm_popular_caches')) {\n    wp_schedule_event(time(), 'hourly', 'pre_warm_popular_caches');\n}\n```\n\n### Solution 3: Early Expiry Check\n\n```php\nfunction get_with_early_expiry($key, $ttl, $regenerate_callback) {\n    $data = wp_cache_get($key);\n    \n    if (false !== $data) {\n        // Check if we should pre-regenerate (last 10% of TTL)\n        $meta = wp_cache_get(\"{$key}_meta\");\n        if ($meta && (time() - $meta['created']) > ($ttl * 0.9)) {\n            // Trigger background regeneration\n            wp_schedule_single_event(time(), 'regenerate_cache', [$key]);\n        }\n        return $data;\n    }\n    \n    // Cache miss - regenerate\n    $data = call_user_func($regenerate_callback);\n    wp_cache_set($key, $data, '', $ttl);\n    wp_cache_set(\"{$key}_meta\", ['created' => time()], '', $ttl);\n    \n    return $data;\n}\n```\n\n## Transients\n\n### When to Use Transients\n\n- Data with known expiration\n- External API responses\n- Computed data that's expensive to regenerate\n\n### Transient Best Practices\n\n```php\n// ‚úÖ GOOD: Named clearly, reasonable TTL\nset_transient('weather_data_seattle', $data, HOUR_IN_SECONDS);\n\n// ‚ùå BAD: Dynamic keys create transient bloat\nset_transient(\"user_{$user_id}_preferences\", $data, DAY_IN_SECONDS);\n// Better: Use user meta or object cache\n```\n\n### Transient Storage Warning\n\nWithout persistent object cache, transients are stored in wp_options table:\n\n```php\n// Check if object cache is available\nif (wp_using_ext_object_cache()) {\n    // Transients use object cache (good)\n    set_transient('my_data', $data, HOUR_IN_SECONDS);\n} else {\n    // Transients go to database (potentially bad)\n    // Consider: file cache, skip caching, or warn admin\n}\n```\n\n## Partial Output Caching\n\nCache rendered HTML fragments for repeated use:\n\n```php\nfunction get_cached_sidebar() {\n    $cache_key = 'sidebar_html_' . get_locale();\n    $html = wp_cache_get($cache_key, 'partials');\n    \n    if (false === $html) {\n        ob_start();\n        get_sidebar();\n        $html = ob_get_clean();\n        wp_cache_set($cache_key, $html, 'partials', HOUR_IN_SECONDS);\n    }\n    \n    return $html;\n}\n```\n\n## In-Memory Caching (Request-Scoped)\n\n### Static Variables\n\n```php\nfunction get_current_user_data() {\n    static $user_data = null;\n    \n    if (null === $user_data) {\n        $user_data = expensive_user_query();\n    }\n    \n    return $user_data;\n}\n```\n\n### Global Variable Pattern\n\n```php\n// Store request-scoped data\nglobal $my_plugin_cache;\n$my_plugin_cache = [];\n\nfunction get_item($id) {\n    global $my_plugin_cache;\n    \n    if (!isset($my_plugin_cache[$id])) {\n        $my_plugin_cache[$id] = fetch_item($id);\n    }\n    \n    return $my_plugin_cache[$id];\n}\n```\n\n## Cache Invalidation Strategy\n\n### Event-Based Invalidation\n\n```php\n// Clear post-related caches when post is updated\nadd_action('save_post', function($post_id, $post) {\n    // Clear specific post cache\n    wp_cache_delete(\"post_{$post_id}\", 'posts');\n    \n    // Clear related caches\n    wp_cache_delete('recent_posts', 'listings');\n    wp_cache_delete('homepage_posts', 'listings');\n    \n    // Clear category archive caches\n    $categories = wp_get_post_categories($post_id);\n    foreach ($categories as $cat_id) {\n        wp_cache_delete(\"category_{$cat_id}_posts\", 'archives');\n    }\n}, 10, 2);\n```\n\n### Tag-Based Invalidation (Advanced)\n\n```php\n// Store cache tags\nfunction set_tagged_cache($key, $data, $tags, $ttl) {\n    wp_cache_set($key, $data, '', $ttl);\n    \n    foreach ($tags as $tag) {\n        $tag_keys = wp_cache_get(\"tag_{$tag}\", 'cache_tags') ?: [];\n        $tag_keys[] = $key;\n        wp_cache_set(\"tag_{$tag}\", array_unique($tag_keys), 'cache_tags');\n    }\n}\n\n// Invalidate by tag\nfunction invalidate_tag($tag) {\n    $keys = wp_cache_get(\"tag_{$tag}\", 'cache_tags') ?: [];\n    foreach ($keys as $key) {\n        wp_cache_delete($key);\n    }\n    wp_cache_delete(\"tag_{$tag}\", 'cache_tags');\n}\n```\n\n## Memcached vs Redis\n\n| Feature | Memcached | Redis |\n|---------|-----------|-------|\n| Speed | Slightly faster | Fast |\n| Data types | String only | Strings, lists, sets, hashes |\n| Persistence | No | Optional |\n| Memory efficiency | Higher | Lower |\n| Cache groups | Limited | Full support |\n| Complexity | Simple | More features |\n\n**Recommendation**: Use what your host provides. Memcached for simple caching, Redis if you need advanced features.\n",
        "skills/wp-performance-review/references/measurement-guide.md": "# High-Traffic Event Preparation & Performance Measurement\n\nGuide for preparing WordPress sites for traffic surges and measuring performance.\n\n## When to Use This Reference\n\nThis guide is for:\n- **Pre-launch audits** - Checklist before high-traffic events\n- **Performance testing** - How to load test with K6\n- **Monitoring setup** - Query Monitor, New Relic integration\n- **Alert configuration** - Threshold recommendations\n\n**For code review**, use `anti-patterns.md` instead. This guide covers operational preparation.\n\n## Code-Level Pre-Event Checks\n\nBefore a high-traffic event, scan the codebase for:\n\n```bash\n# Things that WILL break under load\ngrep -rn \"posts_per_page.*-1\" .                    # Unbounded queries\ngrep -rn \"session_start\" .                          # Cache bypass\ngrep -rn \"setInterval.*fetch\\|setInterval.*ajax\" . # Polling\n\n# Things that DEGRADE under load  \ngrep -rn \"wp_remote_get\\|wp_remote_post\" .         # Uncached HTTP\ngrep -rn \"update_option\\|add_option\" .             # DB writes\n```\n\n## Pre-Event Checklist\n\nBefore a high-traffic event (product launch, viral content, marketing campaign), verify:\n\n### Cache Hit Rate\n- [ ] **Page cache hit rate > 90%** - Check CDN/edge cache analytics\n- [ ] **Object cache (memcached) hit rate > 90%** - Check cache stats\n- [ ] **InnoDB buffer pool hit rate > 95%** - MySQL performance schema\n- [ ] Identify pages consistently missing cache - optimize or exclude from event\n\n### Database Health\n- [ ] **No INSERT/UPDATE on uncached page loads** - Use Query Monitor\n  - Plugins persistently updating options = high DB CPU + binlog growth\n- [ ] **Review P95 upstream response times** - Identify slowest endpoints\n  - High traffic to slow endpoints ties up PHP workers\n- [ ] **Check for slow queries** - Queries > 100ms under normal load\n- [ ] **Verify indexes** - Run EXPLAIN on common queries\n\n### Error Monitoring\n- [ ] **Clean PHP logs** - No fatal errors, minimize warnings\n  - Easier to debug issues if logs aren't full of noise\n- [ ] **Zero 500 errors in 24h** - Check application error rate\n- [ ] **Review error tracking** - New Relic, Sentry, etc.\n\n### Load Testing\n- [ ] **Run load test simulating expected traffic**\n- [ ] **Test specific high-traffic URLs** - Homepage, landing pages\n- [ ] **Monitor during test** - CPU, memory, DB connections, response times\n\n## Traffic Pattern Types\n\n### Sustained High Traffic on Multiple URLs\n**Impact**: Strain on PHP workers, database connections, memory\n**Preparation**:\n- Scale horizontally (more app servers)\n- Increase PHP worker count\n- Optimize database queries\n- Implement aggressive caching\n\n### Large Spikes on Few URLs\n**Impact**: Bottleneck on specific endpoints, potential cache stampede\n**Preparation**:\n- Pre-warm caches for target URLs\n- Implement cache locking to prevent stampede\n- Consider static HTML fallback for extreme cases\n\n### Uncached Content Under Load\n**Impact**: Every request hits origin, database overload\n**Preparation**:\n- Identify why pages bypass cache (cookies, sessions, query params)\n- Implement partial caching for personalized pages\n- Use ESI (Edge Side Includes) for dynamic fragments\n\n## Load Testing with K6\n\nK6 is an open-source load testing tool for simulating traffic.\n\n### Installation\n```bash\n# macOS\nbrew install k6\n\n# Linux\nsudo apt-get install k6\n\n# Docker\ndocker run -i grafana/k6 run - <script.js\n```\n\n### Basic Load Test Script\n```javascript\n// load-test.js\nimport http from 'k6/http';\nimport { check, sleep } from 'k6';\n\nexport const options = {\n    vus: 100,           // 100 virtual users\n    duration: '5m',     // 5 minute test\n    thresholds: {\n        http_req_duration: ['p(95)<500'],  // 95% of requests under 500ms\n        http_req_failed: ['rate<0.01'],    // Less than 1% failures\n    },\n};\n\nexport default function() {\n    // Test homepage\n    let homeResponse = http.get('https://example.com/');\n    check(homeResponse, {\n        'homepage status 200': (r) => r.status === 200,\n        'homepage < 500ms': (r) => r.timings.duration < 500,\n    });\n    \n    // Test archive page\n    let archiveResponse = http.get('https://example.com/category/news/');\n    check(archiveResponse, {\n        'archive status 200': (r) => r.status === 200,\n    });\n    \n    sleep(1);  // Wait 1 second between iterations\n}\n```\n\n### Running Load Tests\n```bash\n# Basic run\nk6 run load-test.js\n\n# With more virtual users\nk6 run --vus 200 --duration 10m load-test.js\n\n# Output to JSON for analysis\nk6 run --out json=results.json load-test.js\n```\n\n### Key Metrics to Monitor\n| Metric | Good | Concerning |\n|--------|------|------------|\n| `http_req_duration` (p95) | < 500ms | > 1000ms |\n| `http_req_failed` | < 1% | > 5% |\n| `http_reqs` (throughput) | Stable | Declining under load |\n| `vus` vs response time | Linear | Exponential degradation |\n\n## Measuring with Query Monitor\n\nQuery Monitor plugin provides detailed performance insights per page.\n\n### Key Panels\n\n**Overview Panel**\n- Total page generation time\n- Database query time\n- HTTP API call time\n\n**Database Queries Panel**\n- Individual query times\n- Duplicate queries (same query run multiple times)\n- Slow queries highlighted\n- Query origin (which plugin/theme)\n\n**Object Cache Panel**\n- Cache hit/miss ratio\n- Total cache operations\n- Cache groups usage\n\n### Custom Timing with Query Monitor\n```php\n// Start timer\ndo_action('qm/start', 'my_operation');\n\n// Your code here\nexpensive_operation();\n\n// Stop timer\ndo_action('qm/stop', 'my_operation');\n\n// For loops, use lap:\ndo_action('qm/start', 'loop_operation');\nforeach ($items as $item) {\n    process_item($item);\n    do_action('qm/lap', 'loop_operation');\n}\ndo_action('qm/stop', 'loop_operation');\n```\n\n### Target Metrics in Query Monitor\n| Metric | Target | Investigate |\n|--------|--------|-------------|\n| Page generation | < 200ms | > 500ms |\n| Database queries | < 50 | > 100 |\n| Duplicate queries | 0 | > 5 |\n| Slowest query | < 50ms | > 100ms |\n| Object cache hits | > 90% | < 80% |\n\n## Measuring with PHP Logging\n\nManual timing for specific code sections.\n\n### Basic Timing\n```php\nfunction my_function() {\n    $start_time = microtime(true);\n    \n    // Code to measure\n    expensive_operation();\n    \n    $end_time = microtime(true);\n    $execution_time = $end_time - $start_time;\n    \n    error_log(sprintf(\n        'my_function execution time: %.4f seconds',\n        $execution_time\n    ));\n}\n```\n\n### Timing Wrapper Function\n```php\nfunction measure_execution($callback, $label) {\n    $start = microtime(true);\n    $result = $callback();\n    $duration = microtime(true) - $start;\n    \n    if ($duration > 0.1) {  // Log if > 100ms\n        error_log(sprintf('[SLOW] %s: %.4fs', $label, $duration));\n    }\n    \n    return $result;\n}\n\n// Usage\n$data = measure_execution(function() {\n    return expensive_query();\n}, 'expensive_query');\n```\n\n### Memory Measurement\n```php\n$mem_start = memory_get_usage();\n\n// Code that might use lots of memory\n$large_array = process_data();\n\n$mem_end = memory_get_usage();\n$mem_used = ($mem_end - $mem_start) / 1024 / 1024;\n\nerror_log(sprintf('Memory used: %.2f MB', $mem_used));\n```\n\n## Measuring with New Relic\n\nNew Relic provides APM (Application Performance Monitoring) for production.\n\n### Custom Transaction Naming\n```php\n// Name transactions for better grouping\nif (function_exists('newrelic_name_transaction')) {\n    if (is_single()) {\n        newrelic_name_transaction('single-post');\n    } elseif (is_archive()) {\n        newrelic_name_transaction('archive');\n    }\n}\n```\n\n### Custom Instrumentation\n```php\n// Track custom code segments\nif (function_exists('newrelic_start_transaction')) {\n    newrelic_start_transaction('my_custom_process');\n    \n    // Your code\n    process_data();\n    \n    newrelic_end_transaction();\n}\n\n// Add custom attributes for filtering\nif (function_exists('newrelic_add_custom_parameter')) {\n    newrelic_add_custom_parameter('post_type', get_post_type());\n    newrelic_add_custom_parameter('user_role', $current_user_role);\n}\n```\n\n### Key New Relic Metrics\n- **Apdex score** - User satisfaction (target: > 0.9)\n- **Web transaction time** - Average response time\n- **Throughput** - Requests per minute\n- **Error rate** - Percentage of failed requests\n- **Database time** - Time spent in DB queries\n\n## Performance Alerting\n\nSet up alerts for performance degradation.\n\n### Key Alert Thresholds\n| Metric | Warning | Critical |\n|--------|---------|----------|\n| Response time (p95) | > 1s | > 3s |\n| Error rate | > 1% | > 5% |\n| CPU usage | > 70% | > 90% |\n| Memory usage | > 80% | > 95% |\n| Database connections | > 80% of max | > 95% of max |\n\n### Alert Channels\n- **Immediate**: PagerDuty, Slack, SMS for critical\n- **Batched**: Email digest for warnings\n- **Dashboard**: Real-time visibility for operations team\n\n## Performance Regression Detection\n\nCatch performance issues before production.\n\n### Baseline Metrics\nEstablish baseline performance metrics:\n```\nHomepage: < 200ms, < 30 queries\nArchive:  < 300ms, < 50 queries\nSingle:   < 250ms, < 40 queries\nSearch:   < 500ms (with ElasticSearch)\n```\n\n### CI/CD Integration\n```yaml\n# Example: Run performance check in CI\n- name: Performance Check\n  run: |\n    RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' https://staging.example.com/)\n    if (( $(echo \"$RESPONSE_TIME > 0.5\" | bc -l) )); then\n      echo \"Warning: Response time ${RESPONSE_TIME}s exceeds threshold\"\n      exit 1\n    fi\n```\n\n### Query Count Monitoring\n```php\n// Add to theme's functions.php for staging\nadd_action('shutdown', function() {\n    if (!defined('SAVEQUERIES') || !SAVEQUERIES) return;\n    \n    global $wpdb;\n    $query_count = count($wpdb->queries);\n    \n    if ($query_count > 100) {\n        error_log(\"[PERFORMANCE] High query count: $query_count\");\n    }\n});\n```\n",
        "skills/wp-performance-review/references/wp-query-guide.md": "# WP_Query Optimization Guide\n\nBest practices for efficient database queries in WordPress applications.\n\n## WP_Query Review Checklist\n\nWhen reviewing WP_Query code, verify:\n\n- [ ] `posts_per_page` is set (not -1, not missing)\n- [ ] `no_found_rows => true` if not paginating\n- [ ] `fields => 'ids'` if only IDs needed\n- [ ] `update_post_meta_cache => false` if meta not used\n- [ ] `update_post_term_cache => false` if terms not used\n- [ ] Date limits on archive queries (recent content only)\n- [ ] `include_children => false` if child terms not needed\n- [ ] No `post__not_in` with large arrays\n- [ ] No `meta_query` on `meta_value` (use taxonomy or key presence)\n- [ ] Results cached with `wp_cache_set` if repeated\n\n## Core Principles\n\n1. **Always set limits** - Never use `posts_per_page => -1`\n2. **Validate inputs** - Check IDs before querying\n3. **Limit scope** - Use date ranges, taxonomies to narrow results\n4. **Skip unnecessary work** - Use `no_found_rows`, `fields`\n5. **Pre-fetch related data** - Avoid N+1 queries\n6. **Cache results** - Use object cache for repeated queries\n\n## Essential Query Arguments\n\n### Limiting Results\n\n```php\n// REQUIRED: Always limit results\n'posts_per_page' => 10,\n\n// Skip counting total posts if not paginating\n'no_found_rows' => true,  // Skips SQL_CALC_FOUND_ROWS\n\n// Return only IDs when you don't need full post objects\n'fields' => 'ids',\n\n// Suppress filters when you need raw results\n'suppress_filters' => true,\n```\n\n### Date-Based Limiting\n\nFor sites with years of content, limit queries to relevant time ranges:\n\n```php\n// Limit to recent content\n$query = new WP_Query([\n    'post_type' => 'post',\n    'posts_per_page' => 10,\n    'date_query' => [\n        [\n            'after' => '3 months ago',\n            'inclusive' => true\n        ]\n    ]\n]);\n\n// Specific date range\n'date_query' => [\n    'after' => '2024-01-01',\n    'before' => '2024-12-31'\n]\n\n// Dynamic date filtering via pre_get_posts\nadd_action('pre_get_posts', function($query) {\n    if (!is_admin() && $query->is_main_query() && $query->is_category('news')) {\n        $query->set('date_query', [\n            'after' => date('Y-m-d', strtotime('-3 months'))\n        ]);\n    }\n});\n```\n\n### Taxonomy Query Optimization\n\n```php\n// Exclude child terms to reduce query complexity\n'tax_query' => [\n    [\n        'taxonomy' => 'category',\n        'field' => 'term_id',\n        'terms' => [6],\n        'include_children' => false  // Important for performance\n    ]\n]\n\n// Use term_id instead of slug (avoids extra lookup)\n'field' => 'term_id',  // Faster than 'slug' or 'name'\n```\n\n### Meta Query Optimization\n\nMeta queries are expensive - minimize usage:\n\n```php\n// ‚ùå AVOID: Multiple meta conditions\n'meta_query' => [\n    'relation' => 'AND',\n    ['key' => 'color', 'value' => 'red'],\n    ['key' => 'size', 'value' => 'large'],\n    ['key' => 'price', 'compare' => '>=', 'value' => 100]\n]\n\n// ‚úÖ BETTER: Use taxonomies for filterable attributes\n// Register 'color' and 'size' as taxonomies instead\n\n// ‚úÖ ALTERNATIVE: Offload to ElasticSearch\n// Configure ElasticPress to index post meta\n```\n\n## Pre-fetching & Cache Priming\n\n### Update Meta Cache in Bulk\n\n```php\n// After running WP_Query, prime the meta cache\n$query = new WP_Query($args);\n$post_ids = wp_list_pluck($query->posts, 'ID');\n\n// Prime meta cache (single query vs N queries)\nupdate_postmeta_cache($post_ids);\n\n// Prime term cache\nupdate_object_term_cache($post_ids, 'post');\n\n// Prime user cache for authors\n$author_ids = wp_list_pluck($query->posts, 'post_author');\ncache_users($author_ids);\n```\n\n### WP_Query Built-in Cache Updates\n\n```php\n// These are on by default but be aware:\n'update_post_meta_cache' => true,   // Updates meta cache after query\n'update_post_term_cache' => true,   // Updates term cache after query\n\n// Disable if you don't need meta/terms (saves queries)\n'update_post_meta_cache' => false,\n'update_post_term_cache' => false,\n```\n\n## Caching Query Results\n\n### Object Cache for Repeated Queries\n\n```php\nfunction get_featured_posts() {\n    $cache_key = 'featured_posts_v1';\n    $posts = wp_cache_get($cache_key, 'my_plugin');\n    \n    if (false === $posts) {\n        $query = new WP_Query([\n            'post_type' => 'post',\n            'posts_per_page' => 5,\n            'meta_key' => 'featured',\n            'meta_value' => '1'\n        ]);\n        \n        $posts = $query->posts;\n        wp_cache_set($cache_key, $posts, 'my_plugin', HOUR_IN_SECONDS);\n    }\n    \n    return $posts;\n}\n\n// Invalidate when posts are updated\nadd_action('save_post', function($post_id) {\n    wp_cache_delete('featured_posts_v1', 'my_plugin');\n});\n```\n\n### Static Variable Caching (Request-Scoped)\n\n```php\nfunction get_expensive_data($id) {\n    static $cache = [];\n    \n    if (!isset($cache[$id])) {\n        $cache[$id] = expensive_computation($id);\n    }\n    \n    return $cache[$id];\n}\n```\n\n## ElasticSearch Offloading\n\nFor complex searches, offload to ElasticSearch via ElasticPress:\n\n### When to Offload\n\n- Full-text search queries\n- Complex meta queries\n- Faceted search / filtering\n- Large result sets with sorting\n- Aggregations / analytics\n\n### When NOT to Offload\n\n- Simple primary key lookups\n- Transactional data requiring ACID\n- Data requiring immediate consistency\n- Small data sets\n\n```php\n// ElasticPress automatically intercepts WP_Query\n// for search queries when configured\n\n// Force MySQL for specific queries\n$query = new WP_Query([\n    'ep_integrate' => false,  // Skip ElasticSearch\n    // ... args\n]);\n```\n\n## Analyzing Queries with EXPLAIN\n\nUse EXPLAIN to identify slow queries:\n\n```sql\nEXPLAIN SELECT * FROM wp_posts \nWHERE post_type = 'post' \nAND post_status = 'publish' \nORDER BY post_date DESC \nLIMIT 10;\n```\n\n### Key EXPLAIN Indicators\n\n| Column | Good Value | Bad Value |\n|--------|------------|-----------|\n| `type` | `const`, `eq_ref`, `ref`, `range` | `ALL` (full table scan) |\n| `key` | Named index | `NULL` (no index used) |\n| `rows` | Small number | Large number |\n| `Extra` | `Using index` | `Using filesort`, `Using temporary` |\n\n### Common Optimization Actions\n\n```sql\n-- Add index for frequently queried meta key\nALTER TABLE wp_postmeta ADD INDEX meta_key_value (meta_key, meta_value(50));\n\n-- Add composite index\nALTER TABLE wp_posts ADD INDEX type_status_date (post_type, post_status, post_date);\n```\n\n## Query Monitor Integration\n\nUse Query Monitor plugin to identify:\n\n1. **Slow queries** - Queries over threshold\n2. **Duplicate queries** - Same query run multiple times\n3. **Queries by component** - Which plugin/theme caused each query\n4. **Query count** - Total queries per page load\n\n### Target Metrics\n\n| Metric | Target | Concern |\n|--------|--------|---------|\n| Total queries | < 50 | > 100 |\n| Duplicate queries | 0 | > 5 |\n| Slowest query | < 50ms | > 100ms |\n| Total query time | < 100ms | > 500ms |\n\n## Common Query Patterns\n\n### Get Latest Posts (Optimized)\n\n```php\n$query = new WP_Query([\n    'post_type' => 'post',\n    'post_status' => 'publish',\n    'posts_per_page' => 10,\n    'no_found_rows' => true,\n    'update_post_term_cache' => false,  // If not displaying categories\n]);\n```\n\n### Get Posts by IDs (Optimized)\n\n```php\n$query = new WP_Query([\n    'post__in' => $post_ids,\n    'posts_per_page' => count($post_ids),\n    'orderby' => 'post__in',  // Preserve ID order\n    'no_found_rows' => true,\n    'ignore_sticky_posts' => true\n]);\n```\n\n### Check if Posts Exist (Optimized)\n\n```php\n// Don't fetch full posts just to check existence\n$query = new WP_Query([\n    'post_type' => 'product',\n    'posts_per_page' => 1,\n    'fields' => 'ids',\n    'no_found_rows' => true,\n    'update_post_meta_cache' => false,\n    'update_post_term_cache' => false\n]);\n$has_products = $query->have_posts();\n```\n\n### Count Posts (Optimized)\n\n```php\n// Use wp_count_posts() for simple counts\n$counts = wp_count_posts('post');\n$published = $counts->publish;\n\n// For filtered counts, use found_posts\n$query = new WP_Query([\n    'post_type' => 'post',\n    'posts_per_page' => 1,  // Minimize actual retrieval\n    'category_name' => 'news',\n    // no_found_rows must be FALSE to get found_posts\n]);\n$total = $query->found_posts;\n```\n"
      },
      "plugins": [
        {
          "name": "claude-wordpress-skills",
          "source": "./",
          "description": "Professional WordPress engineering skills for Claude Code ‚Äî performance optimization, security auditing, Gutenberg block development, and theme/plugin best practices",
          "categories": [],
          "install_commands": [
            "/plugin marketplace add elvismdev/claude-wordpress-skills",
            "/plugin install claude-wordpress-skills@claude-wordpress-skills"
          ]
        }
      ]
    }
  ]
}