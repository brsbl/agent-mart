{
  "author": {
    "id": "pumped-fn",
    "display_name": "pumped-fn",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/199755659?v=4",
    "url": "https://github.com/pumped-fn",
    "bio": null,
    "stats": {
      "total_marketplaces": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 0,
      "total_stars": 5,
      "total_forks": 3
    }
  },
  "marketplaces": [
    {
      "name": "pumped-fn-marketplace",
      "version": null,
      "description": "Official marketplace for pumped-fn Claude Code plugins",
      "owner_info": {
        "name": "lagz0ne",
        "email": "duke@silentium.io"
      },
      "keywords": [],
      "repo_full_name": "pumped-fn/pumped-fn",
      "repo_url": "https://github.com/pumped-fn/pumped-fn",
      "repo_description": "Monorepository of @pumped-fn",
      "homepage": "https://pumped-fn.github.io/pumped-fn/",
      "signals": {
        "stars": 5,
        "forks": 3,
        "pushed_at": "2026-01-12T12:05:04Z",
        "created_at": "2025-02-18T10:57:41Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".c3",
          "type": "tree",
          "size": null
        },
        {
          "path": ".c3/README.md",
          "type": "blob",
          "size": 6310
        },
        {
          "path": ".c3/c3-2-lite",
          "type": "tree",
          "size": null
        },
        {
          "path": ".c3/c3-2-lite/README.md",
          "type": "blob",
          "size": 10276
        },
        {
          "path": ".c3/c3-3-lite-react",
          "type": "tree",
          "size": null
        },
        {
          "path": ".c3/c3-3-lite-react/README.md",
          "type": "blob",
          "size": 7221
        },
        {
          "path": ".c3/c3-4-lite-devtools",
          "type": "tree",
          "size": null
        },
        {
          "path": ".c3/c3-4-lite-devtools/README.md",
          "type": "blob",
          "size": 1816
        },
        {
          "path": ".c3/c3-5-lite-hmr",
          "type": "tree",
          "size": null
        },
        {
          "path": ".c3/c3-5-lite-hmr/README.md",
          "type": "blob",
          "size": 4212
        },
        {
          "path": ".c3/c3-6-lite-devtools-server",
          "type": "tree",
          "size": null
        },
        {
          "path": ".c3/c3-6-lite-devtools-server/README.md",
          "type": "blob",
          "size": 2680
        },
        {
          "path": ".c3/c3-7-lite-extension-otel",
          "type": "tree",
          "size": null
        },
        {
          "path": ".c3/c3-7-lite-extension-otel/README.md",
          "type": "blob",
          "size": 8025
        },
        {
          "path": ".changeset",
          "type": "tree",
          "size": null
        },
        {
          "path": ".changeset/README.md",
          "type": "blob",
          "size": 510
        },
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1391
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 563
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/commands/pf:feature.md",
          "type": "blob",
          "size": 2928
        },
        {
          "path": ".claude/commands/pf:implement.md",
          "type": "blob",
          "size": 2294
        },
        {
          "path": ".claude/commands/pf:release.md",
          "type": "blob",
          "size": 2763
        },
        {
          "path": ".claude/commands/pf:review.md",
          "type": "blob",
          "size": 3779
        },
        {
          "path": ".claude/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/hooks/git.md",
          "type": "blob",
          "size": 1120
        },
        {
          "path": ".claude/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/README.md",
          "type": "blob",
          "size": 2440
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows/README.md",
          "type": "blob",
          "size": 3329
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 6591
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/README.md",
          "type": "blob",
          "size": 234
        },
        {
          "path": "packages",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/codemod",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/codemod/README.md",
          "type": "blob",
          "size": 3525
        },
        {
          "path": "packages/lite-devtools-server",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/lite-devtools-server/README.md",
          "type": "blob",
          "size": 1694
        },
        {
          "path": "packages/lite-devtools",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/lite-devtools/README.md",
          "type": "blob",
          "size": 2375
        },
        {
          "path": "packages/lite-extension-otel",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/lite-extension-otel/README.md",
          "type": "blob",
          "size": 2119
        },
        {
          "path": "packages/lite-hmr",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/lite-hmr/README.md",
          "type": "blob",
          "size": 2265
        },
        {
          "path": "packages/lite-react",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/lite-react/README.md",
          "type": "blob",
          "size": 5392
        },
        {
          "path": "packages/lite",
          "type": "tree",
          "size": null
        },
        {
          "path": "packages/lite/README.md",
          "type": "blob",
          "size": 12808
        }
      ],
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"pumped-fn-marketplace\",\n  \"owner\": {\n    \"name\": \"lagz0ne\",\n    \"email\": \"duke@silentium.io\"\n  },\n  \"metadata\": {\n    \"description\": \"Official marketplace for pumped-fn Claude Code plugins\",\n    \"version\": \"1.4.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"pumped-design\",\n      \"source\": \"./\",\n      \"description\": \"Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies\",\n      \"version\": \"1.4.0\",\n      \"author\": {\n        \"name\": \"lagz0ne\",\n        \"email\": \"duke@silentium.io\"\n      },\n      \"homepage\": \"https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design\",\n      \"repository\": \"https://github.com/pumped-fn/pumped-fn\",\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"typescript\",\n        \"backend-architecture\",\n        \"application-design\",\n        \"testing-strategy\",\n        \"code-quality\",\n        \"pumped-fn\",\n        \"design-patterns\",\n        \"resource-management\",\n        \"flow-orchestration\",\n        \"best-practices\"\n      ],\n      \"category\": \"code-quality\",\n      \"tags\": [\n        \"typescript\",\n        \"backend-architecture\",\n        \"application-design\",\n        \"testing-strategy\",\n        \"code-quality\",\n        \"pumped-fn\",\n        \"design-patterns\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"pumped-design\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies\",\n  \"author\": {\n    \"name\": \"lagz0ne\",\n    \"email\": \"duke@silentium.io\"\n  },\n  \"repository\": \"https://github.com/pumped-fn/pumped-fn\",\n  \"homepage\": \"https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design\",\n  \"skills\": [\n    \"./.claude/skills/pumped-design\"\n  ]\n}\n",
        ".c3/README.md": "---\nid: c3-0\nc3-version: 3\ntitle: pumped-fn System Overview\nsummary: >\n  Lightweight effect system for TypeScript providing scope-based dependency injection,\n  flow execution patterns, and metadata tagging.\n---\n\n# pumped-fn System Overview\n\n## Overview {#c3-0-overview}\n<!-- TypeScript effect system for dependency injection and execution orchestration -->\n\npumped-fn is a lightweight TypeScript effect system that provides:\n- Scope-based dependency injection with automatic lifecycle management\n- Flow execution patterns for request/response handling\n- Tag-based metadata system for cross-cutting concerns\n- Extension hooks for observability and behavior modification\n- Controller-based reactivity for state observation\n\nThe library is designed to be framework-agnostic with zero runtime dependencies.\n\n## Architecture {#c3-0-architecture}\n<!-- High-level view of system components -->\n\n```mermaid\ngraph TB\n    subgraph \"External\"\n        AppDev[Application Developer]\n        LibAuthor[Library Author]\n    end\n\n    subgraph \"pumped-fn\"\n        Lite[\"@pumped-fn/lite<br/>(Core Library)\"]\n        ReactLite[\"@pumped-fn/lite-react<br/>(React Bindings)\"]\n        Devtools[\"@pumped-fn/lite-devtools<br/>(Observability)\"]\n        DevtoolsServer[\"@pumped-fn/lite-devtools-server<br/>(TUI Server)\"]\n        LiteHMR[\"@pumped-fn/lite-hmr<br/>(HMR Plugin)\"]\n        OTel[\"@pumped-fn/lite-extension-otel<br/>(OpenTelemetry)\"]\n    end\n\n    subgraph \"Framework Integrations\"\n        Hono[Hono]\n        NextJS[Next.js]\n        TanStack[TanStack Start]\n    end\n\n    AppDev -->|uses| Lite\n    AppDev -->|uses| ReactLite\n    AppDev -->|uses| Devtools\n    LibAuthor -->|extends| Lite\n\n    ReactLite -->|depends on| Lite\n    Devtools -->|depends on| Lite\n    DevtoolsServer -->|depends on| Lite\n    DevtoolsServer -->|depends on| ReactLite\n    Devtools -.->|HTTP events| DevtoolsServer\n    LiteHMR -->|transforms| Lite\n\n    AppDev -->|uses| LiteHMR\n    OTel -->|depends on| Lite\n    Hono -.->|integrates| Lite\n    NextJS -.->|integrates| Lite\n    TanStack -.->|integrates| Lite\n```\n\n## Actors {#c3-0-actors}\n<!-- Who/what interacts with this system -->\n\n| Actor | Description |\n|-------|-------------|\n| Application Developer | Builds applications using pumped-fn for dependency management and flow execution |\n| Library Author | Creates extensions, framework integrations, or custom tooling on top of lite |\n\n## Containers {#c3-0-containers}\n<!-- Separately deployable/publishable units -->\n\n| Container | Type | Description | Documentation |\n|-----------|------|-------------|---------------|\n| @pumped-fn/lite | Library | Lightweight DI with minimal reactivity - atoms, flows, tags, controllers | [c3-2-lite](./c3-2-lite/) |\n| @pumped-fn/lite-react | Library | Minimal React bindings with Suspense and useSyncExternalStore | [c3-3-lite-react](./c3-3-lite-react/) |\n| @pumped-fn/lite-devtools | Library | Observability extension with transport-based event streaming | [c3-4-lite-devtools](./c3-4-lite-devtools/) |\n| @pumped-fn/lite-hmr | Vite Plugin | Build-time transform preserving atom state across HMR reloads | [c3-5-lite-hmr](./c3-5-lite-hmr/) |\n| @pumped-fn/lite-devtools-server | CLI Tool | Standalone TUI server receiving devtools events via HTTP | [c3-6-lite-devtools-server](./c3-6-lite-devtools-server/) |\n| @pumped-fn/lite-extension-otel | Library | OpenTelemetry integration with tracing, metrics, and context propagation | [c3-7-lite-extension-otel](./c3-7-lite-extension-otel/) |\n| docs | Static Site | VitePress documentation site | (out of scope) |\n\n## Protocols {#c3-0-protocols}\n<!-- How containers communicate -->\n\n| From | To | Protocol | Description |\n|------|-----|----------|-------------|\n| Framework integrations | @pumped-fn/lite | npm dependency | Frameworks use lite for DI and flow handling |\n| @pumped-fn/lite-react | @pumped-fn/lite | npm dependency | React hooks wrap lite Scope and Controller APIs |\n| @pumped-fn/lite-devtools | @pumped-fn/lite | Extension interface | Devtools uses Extension hooks for instrumentation |\n| @pumped-fn/lite-devtools | External UI | Transport (fire-and-forget) | Events streamed via BroadcastChannel, WebSocket, or Memory |\n| @pumped-fn/lite-hmr | User code | AST transform | Plugin transforms atom() calls at build time |\n\nContainers are npm packages with no runtime protocol - communication is through TypeScript types and function imports. Devtools uses fire-and-forget transports for zero-overhead event streaming.\n\n## Cross-Cutting Concerns {#c3-0-cross-cutting}\n<!-- Decisions that affect multiple containers -->\n\n### Extension System\nCross-cutting behavior (logging, tracing, caching, error handling) is implemented via the Extension interface. Extensions hook into atom resolution and flow execution lifecycle via `wrapResolve` and `wrapExec` hooks.\n\nImplemented in: [c3-2-lite](./c3-2-lite/)\n\n### Tag-Based Metadata\nMetadata propagation across execution boundaries uses the Tag system. Tags can be attached to atoms, flows, and scopes, then extracted at various points with `required`, `optional`, or `all` modes.\n\nImplemented in: [c3-204-tag](./c3-2-lite/c3-204-tag.md)\n\n### Controller Reactivity\nReactive state observation through the Controller pattern. Atoms can self-invalidate and listeners can subscribe to state changes with event filtering (`resolved`, `resolving`, `*`).\n\nImplemented in: [c3-201-scope](./c3-2-lite/c3-201-scope.md)\n\n### Observability (Devtools)\nDeveloper observability via Extension-based instrumentation. Events (atom resolution, flow execution, errors) are streamed through fire-and-forget transports to external UIs without blocking application code.\n\nImplemented in: [c3-4-lite-devtools](./c3-4-lite-devtools/)\n\n## Deployment {#c3-0-deployment}\n<!-- How this system is distributed -->\n\npumped-fn is distributed as npm packages:\n- Published to npm registry via changesets\n- Semantic versioning with automated changelog generation\n- Zero runtime dependencies\n\nNo container/infrastructure deployment - this is a library ecosystem.\n\n## System Testing {#c3-0-testing}\n<!-- Cross-container testing strategy -->\n\nTesting is per-package using Vitest:\n- Unit tests for individual modules\n- Behavior tests for integration scenarios\n- Type tests for TypeScript inference\n\nPackages are independently testable via their public APIs.\n",
        ".c3/c3-2-lite/README.md": "---\nid: c3-2\nc3-version: 3\ntitle: Lite Library (@pumped-fn/lite)\nsummary: >\n  Lightweight dependency injection with minimal reactivity - atoms, flows, tags,\n  and controllers for TypeScript applications with zero external dependencies.\n---\n\n# Lite Library (@pumped-fn/lite)\n\n## Overview {#c3-2-overview}\n<!-- Lightweight DI with minimal reactivity -->\n\n`@pumped-fn/lite` is a minimal dependency injection library for TypeScript that provides:\n- **Atoms** - Long-lived dependencies with lifecycle management\n- **Flows** - Short-lived request/response execution patterns\n- **Tags** - Metadata attachment and extraction\n- **Controllers** - Deferred resolution with reactivity support\n\n**Design principles:**\n1. Very light, very compact - say no to unnecessary features\n2. Very little API exposed - every API is gold, expensive to learn\n3. Minimal overhead - optimized code required\n\n**Bundle size:** <17KB (ESM), <17KB (CJS)\n\n**Dependencies:** Zero external dependencies\n\n## Technology Stack {#c3-2-stack}\n<!-- Runtime and build tooling -->\n\n| Category | Technology |\n|----------|------------|\n| Language | TypeScript 5.9+ |\n| Runtime | Node.js 18+ |\n| Build | tsdown (rolldown-based) |\n| Test | Vitest |\n| Package | ESM + CJS dual format |\n\n## Component Relationships {#c3-2-relationships}\n<!-- How internal modules connect -->\n\n```mermaid\ngraph TB\n    subgraph \"Public API\"\n        createScope[\"createScope()\"]\n        atom[\"atom()\"]\n        service[\"service()\"]\n        flow[\"flow()\"]\n        tag[\"tag()\"]\n        preset[\"preset()\"]\n        controller[\"controller()\"]\n    end\n\n    subgraph \"Runtime\"\n        Scope[\"Scope\"]\n        Controller[\"Controller\"]\n        ExecutionContext[\"ExecutionContext\"]\n    end\n\n    subgraph \"Data\"\n        AtomEntry[\"AtomEntry<br/>(state, value, cleanups)\"]\n        Tags[\"Tagged[]\"]\n    end\n\n    createScope --> Scope\n    atom --> Scope\n    service --> Scope\n    flow --> ExecutionContext\n    tag --> Tags\n    preset --> Scope\n    controller --> Controller\n\n    Scope --> AtomEntry\n    Scope --> Controller\n    Scope --> ExecutionContext\n    Controller --> AtomEntry\n    ExecutionContext --> Scope\n    ExecutionContext --> Tags\n```\n\n## Data Flow {#c3-2-data-flow}\n<!-- Execution sequence -->\n\n### Atom Resolution Flow\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant Scope\n    participant Entry as AtomEntry\n    participant Factory\n\n    App->>Scope: resolve(atom)\n    Scope->>Entry: check state\n    alt state = resolved\n        Entry-->>App: cached value\n    else state = idle/failed\n        Scope->>Entry: state = resolving\n        Scope->>Factory: call factory(ctx, deps)\n        Factory-->>Scope: value\n        Scope->>Entry: state = resolved, cache value\n        Entry-->>App: value\n    end\n```\n\n### Controller Invalidation Flow\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant Ctrl as Controller\n    participant Scope\n    participant Entry as AtomEntry\n    participant Factory\n\n    App->>Ctrl: invalidate()\n    Ctrl->>Scope: invalidate(atom)\n    Scope->>Entry: run cleanups (LIFO)\n    Scope->>Entry: state = resolving\n    Scope->>Entry: notify listeners\n    Scope->>Factory: call factory(ctx, deps)\n    Factory-->>Scope: new value\n    Scope->>Entry: state = resolved\n    Scope->>Entry: notify listeners\n```\n\n## Public API {#c3-2-api}\n<!-- Exported functions and types -->\n\n### Factory Functions\n\n| Function | Description | Returns |\n|----------|-------------|---------|\n| `createScope(options?)` | Create DI container (sync, with `ready` promise) | `Scope` |\n| `atom(config)` | Define long-lived dependency | `Atom<T>` |\n| `flow(config)` | Define request handler | `Flow<T, I>` |\n| `tag(config)` | Define metadata tag | `Tag<T>` |\n| `preset(atom, value)` | Create preset injection | `Preset<T>` |\n| `controller(atom)` | Create controller dependency | `ControllerDep<T>` |\n| `service(config)` | Define context-aware method container | `Atom<T extends ServiceMethods>` |\n| `scope.select(atom, selector, options?)` | Create fine-grained subscription | `SelectHandle<S>` |\n\n### Type Guards\n\n| Function | Description |\n|----------|-------------|\n| `isAtom(value)` | Check if value is Atom |\n| `isFlow(value)` | Check if value is Flow |\n| `isTag(value)` | Check if value is Tag |\n| `isTagged(value)` | Check if value is Tagged |\n| `isPreset(value)` | Check if value is Preset |\n| `isControllerDep(value)` | Check if value is ControllerDep |\n| `isTagExecutor(value)` | Check if value is TagExecutor |\n\n### Interfaces\n\n| Interface | Description |\n|-----------|-------------|\n| `Scope` | DI container with resolution, controller, and event APIs |\n| `Controller<T>` | Deferred accessor with state, get, invalidate, and subscription |\n| `ExecutionContext` | Flow execution context with input, exec, and lifecycle |\n| `Extension` | Cross-cutting hooks for resolve and exec |\n\n### Namespace Export\n\nAll types are grouped under the `Lite` namespace:\n\n```typescript\nimport type { Lite } from '@pumped-fn/lite'\n\nconst myAtom: Lite.Atom<Config> = atom({ factory: () => loadConfig() })\n```\n\n## Source Organization {#c3-2-source}\n<!-- File structure -->\n\n```\npackages/lite/\n├── src/\n│   ├── index.ts      # Public exports\n│   ├── types.ts      # Lite namespace with all interfaces\n│   ├── symbols.ts    # Unique symbols for type guards\n│   ├── atom.ts       # atom(), controller(), type guards\n│   ├── flow.ts       # flow(), isFlow()\n│   ├── tag.ts        # tag(), tags, tag type guards\n│   ├── preset.ts     # preset(), isPreset()\n│   ├── service.ts    # service()\n│   ├── scope.ts      # createScope(), Scope, Controller, ExecutionContext\n│   └── errors.ts     # ParseError class\n├── tests/\n│   ├── atom.test.ts\n│   ├── flow.test.ts\n│   ├── tag.test.ts\n│   ├── preset.test.ts\n│   ├── scope.test.ts\n│   ├── extension.test.ts\n│   └── types.test.ts\n├── package.json\n├── tsconfig.json\n└── tsdown.config.ts\n```\n\n## Components {#c3-2-components}\n<!-- Component inventory -->\n\n| ID | Component | Description |\n|----|-----------|-------------|\n| [c3-201](./c3-201-scope.md) | Scope & Controller | DI container, resolution, lifecycle states, reactivity |\n| [c3-202](./c3-202-atom.md) | Atom | Long-lived dependency definition (includes `service()` helper) |\n| [c3-203](./c3-203-flow.md) | Flow & ExecutionContext | Request/response execution pattern |\n| [c3-204](./c3-204-tag.md) | Tag System | Metadata attachment and extraction |\n| [c3-205](./c3-205-preset.md) | Preset | Value injection and atom redirection |\n\n## Extension System {#c3-2-extension}\n<!-- Cross-cutting concern hooks -->\n\nExtensions provide AOP-style hooks for cross-cutting concerns:\n\n```typescript\ninterface Extension {\n  readonly name: string\n  init?(scope: Scope): MaybePromise<void>\n  wrapResolve?<T>(next: () => Promise<T>, atom: Atom<T>, scope: Scope): Promise<T>\n  wrapExec?<T>(next: () => Promise<T>, target: Flow | Function, ctx: ExecutionContext): Promise<T>\n  dispose?(scope: Scope): MaybePromise<void>\n}\n```\n\n**Lifecycle:**\n1. `init()` - Called when scope is created (after `createScope()`)\n2. `wrapResolve()` - Wraps atom resolution (innermost extension runs first)\n3. `wrapExec()` - Wraps flow/function execution\n4. `dispose()` - Called when scope is disposed\n\n**Example logging extension:**\n\n```typescript\nconst loggingExtension: Lite.Extension = {\n  name: 'logging',\n  wrapResolve: async (next, atom, scope) => {\n    console.log('Resolving atom...')\n    const result = await next()\n    console.log('Resolved:', result)\n    return result\n  }\n}\n\nconst scope = createScope({ extensions: [loggingExtension] })\n```\n\n**Example tracing extension with hierarchical context:**\n\n```typescript\nconst SPAN_KEY = Symbol('tracing.span')\n\ninterface Span {\n  name: string\n  parent?: Span\n  end(): void\n}\n\nconst tracingExtension: Lite.Extension = {\n  name: 'tracing',\n  wrapExec: async (next, target, ctx) => {\n    // Extensions receive CHILD context (created by exec)\n    // Access parent span from parent context's data\n    const parentSpan = ctx.parent?.data.get(SPAN_KEY) as Span | undefined\n\n    const span: Span = {\n      name: isFlow(target) ? (target.name ?? 'anonymous') : 'fn',\n      parent: parentSpan,  // Automatic parent-child relationship!\n      end: () => console.log(`Span ended: ${span.name}`)\n    }\n\n    // Store span in THIS context's data (isolated per execution)\n    ctx.data.set(SPAN_KEY, span)\n\n    try {\n      const result = await next()\n      return result\n    } finally {\n      span.end()\n    }\n  }\n}\n\nconst scope = createScope({ extensions: [tracingExtension] })\nconst ctx = scope.createContext()\n\nawait ctx.exec({\n  flow: flow({\n    name: 'parent',\n    factory: async (ctx) => {\n      // parentSpan stored in ctx.data\n\n      await ctx.exec({\n        flow: flow({\n          name: 'child',\n          factory: async (ctx) => {\n            // childSpan.parent = parentSpan (automatic!)\n          }\n        })\n      })\n    }\n  })\n})\n// Hierarchical span tree created without AsyncLocalStorage!\n```\n\n**Key pattern:**\n- Each `ctx.exec()` creates child context with isolated `data` Map\n- Extensions read `ctx.parent?.data` for parent info\n- Extensions write to `ctx.data` for current execution\n- Enables nested tracing without global state or AsyncLocalStorage\n\n## Testing {#c3-2-testing}\n<!-- Testing strategy -->\n\n**Test organization:**\n- Unit tests per source file\n- Type tests using `expectTypeOf` from Vitest\n- 145 tests covering all components (including 15 hierarchical context tests)\n\n**Running tests:**\n```bash\npnpm -F @pumped-fn/lite test        # Run all tests\npnpm -F @pumped-fn/lite test:watch  # Watch mode\npnpm -F @pumped-fn/lite typecheck   # Type check src\npnpm -F @pumped-fn/lite typecheck:full  # Type check src + tests\n```\n\n## Related {#c3-2-related}\n\n- [ADR-002](../adr/adr-002-lightweight-lite-package.md) - Initial package design decisions\n- [ADR-003](../adr/adr-003-controller-reactivity.md) - Controller-based reactivity design\n- [ADR-008](../adr/adr-008-sync-create-scope.md) - Synchronous createScope with ready promise\n- [ADR-009](../adr/adr-009-fix-duplicate-listener-notifications.md) - Controller.on() state filtering\n",
        ".c3/c3-3-lite-react/README.md": "---\nid: c3-3\nc3-version: 3\ntitle: Lite React Library (@pumped-fn/lite-react)\nsummary: >\n  Minimal React bindings for @pumped-fn/lite with Suspense and ErrorBoundary\n  integration via useSyncExternalStore for React 18+ applications.\n---\n\n# Lite React Library (@pumped-fn/lite-react)\n\n## Overview {#c3-3-overview}\n\n`@pumped-fn/lite-react` provides thin React wrappers around `@pumped-fn/lite` primitives:\n- **ScopeProvider** - React Context provider for scope injection\n- **useAtom** - Subscribe to atom values with Suspense/ErrorBoundary integration\n- **useSelect** - Fine-grained selection with custom equality\n- **useController** - Access Controller for imperative operations\n\n**Design principles:**\n1. Thin wrappers - no hidden magic, explicit lifecycle\n2. Hooks observe, don't trigger - atoms must be pre-resolved\n3. SSR-compatible - no side effects on import, no global state\n\n**Bundle size:** <2KB (estimated)\n\n**Dependencies:** Peer dependencies only (react >=18.0.0, @pumped-fn/lite >=1.4.0)\n\n## Technology Stack {#c3-3-stack}\n\n| Category | Technology |\n|----------|------------|\n| Language | TypeScript 5.9+ |\n| Runtime | Browser/Node.js |\n| React | React 18+ (useSyncExternalStore) |\n| Build | tsdown (rolldown-based) |\n| Test | Vitest + @testing-library/react |\n| Package | ESM + CJS dual format |\n\n## Component Relationships {#c3-3-relationships}\n\n```mermaid\ngraph TB\n    subgraph \"React App\"\n        App[\"App Component\"]\n        ScopeProvider[\"ScopeProvider\"]\n        Components[\"User Components\"]\n    end\n\n    subgraph \"@pumped-fn/lite-react\"\n        useScope[\"useScope()\"]\n        useAtom[\"useAtom()\"]\n        useSelect[\"useSelect()\"]\n        useController[\"useController()\"]\n    end\n\n    subgraph \"@pumped-fn/lite\"\n        Scope[\"Scope\"]\n        Controller[\"Controller\"]\n        SelectHandle[\"SelectHandle\"]\n    end\n\n    App --> ScopeProvider\n    ScopeProvider --> Components\n    Components --> useAtom\n    Components --> useSelect\n    Components --> useController\n\n    useAtom --> useScope\n    useSelect --> useScope\n    useController --> useScope\n\n    useScope --> Scope\n    useController --> Controller\n    useSelect --> SelectHandle\n    useAtom --> Controller\n```\n\n## State Handling {#c3-3-states}\n\nHooks handle the four atom states via React patterns:\n\n```mermaid\nflowchart TD\n    Hook[useAtom/useSelect called]\n    Hook --> CheckState{ctrl.state?}\n\n    CheckState -->|idle| ThrowError[Throw Error]\n    CheckState -->|resolving| ThrowPromise[Throw Promise]\n    CheckState -->|resolved| ReturnValue[Return value + subscribe]\n    CheckState -->|failed| ThrowStored[Throw stored error]\n\n    ThrowPromise --> Suspense[Suspense catches]\n    ThrowStored --> ErrorBoundary[ErrorBoundary catches]\n    ThrowError --> DevError[Dev must fix lifecycle]\n```\n\n| State | Hook Behavior |\n|-------|---------------|\n| `idle` | Throw `Error(\"Atom not resolved...\")` |\n| `resolving` | Throw Promise from `ctrl.resolve()` - Suspense catches |\n| `resolved` | Return value, subscribe to changes |\n| `failed` | Throw stored error - ErrorBoundary catches |\n\n## Public API {#c3-3-api}\n\n### Context\n\n| Export | Description |\n|--------|-------------|\n| `ScopeContext` | React Context for advanced use cases |\n| `ScopeProvider` | Provider component for scope injection |\n\n### Hooks\n\n| Hook | Description | Returns |\n|------|-------------|---------|\n| `useScope()` | Get scope from context | `Lite.Scope` |\n| `useController(atom, options?)` | Get memoized controller | `Lite.Controller<T>` |\n| `useAtom(atom)` | Subscribe to atom value (Suspense) | `T` |\n| `useAtom(atom, { suspense: false })` | Manual state handling | `UseAtomState<T>` |\n| `useSelect(atom, selector, eq?)` | Fine-grained selection | `S` |\n\n### Type Exports\n\n| Type | Description |\n|------|-------------|\n| `UseAtomOptions` | Options for useAtom hook |\n| `UseAtomState<T>` | Return type for non-Suspense mode |\n| `UseControllerOptions` | Options for useController hook |\n| `Lite` | Re-exported namespace from `@pumped-fn/lite` |\n\n## Source Organization {#c3-3-source}\n\n```\npackages/lite-react/\n├── src/\n│   ├── index.ts          # Public exports\n│   ├── context.tsx       # ScopeContext, ScopeProvider\n│   └── hooks.ts          # useScope, useAtom, useSelect, useController\n├── tests/\n│   ├── hooks.test.tsx    # Comprehensive test suite\n│   └── setup.ts          # Test setup (jest-dom)\n├── package.json\n├── tsconfig.json\n├── tsconfig.test.json\n├── vitest.config.ts\n└── tsdown.config.ts\n```\n\n## Components {#c3-3-components}\n\n| ID | Component | Description |\n|----|-----------|-------------|\n| [c3-301](./c3-301-hooks.md) | React Hooks | useScope, useAtom, useSelect, useController |\n\n## Usage Patterns {#c3-3-patterns}\n\n### Basic Usage\n\n```tsx\nimport { createScope, atom } from '@pumped-fn/lite'\nimport { ScopeProvider, useAtom } from '@pumped-fn/lite-react'\n\nconst userAtom = atom({\n  factory: async () => fetch('/api/user').then(r => r.json())\n})\n\nconst scope = createScope()\nawait scope.resolve(userAtom)\n\nfunction App() {\n  return (\n    <ScopeProvider scope={scope}>\n      <Suspense fallback={<Loading />}>\n        <UserProfile />\n      </Suspense>\n    </ScopeProvider>\n  )\n}\n\nfunction UserProfile() {\n  const user = useAtom(userAtom)\n  return <div>{user.name}</div>\n}\n```\n\n### Invalidation with Suspense\n\n```tsx\nfunction UserProfile() {\n  const user = useAtom(userAtom)\n  const ctrl = useController(userAtom)\n\n  const refresh = () => ctrl.invalidate()\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <button onClick={refresh}>Refresh</button>\n    </div>\n  )\n}\n```\n\n### Fine-Grained Selection\n\n```tsx\nfunction TodoCount() {\n  const count = useSelect(\n    todosAtom,\n    todos => todos.filter(t => !t.done).length\n  )\n  return <span>{count} remaining</span>\n}\n```\n\n## Testing {#c3-3-testing}\n\n**Test organization:**\n- Hook tests with @testing-library/react\n- State handling tests for all 4 atom states\n- Suspense and ErrorBoundary integration tests\n- 17 tests passing, 4 skipped (jsdom timing issues)\n\n**Running tests:**\n```bash\npnpm -F @pumped-fn/lite-react test        # Run all tests\npnpm -F @pumped-fn/lite-react typecheck   # Type check src\npnpm -F @pumped-fn/lite-react typecheck:full  # Type check src + tests\n```\n\n**Testing with presets:**\n```tsx\nimport { createScope, preset } from '@pumped-fn/lite'\nimport { ScopeProvider } from '@pumped-fn/lite-react'\n\ntest('renders user name', async () => {\n  const scope = createScope({\n    presets: [preset(userAtom, { name: 'Test User' })]\n  })\n  await scope.resolve(userAtom)\n\n  render(\n    <ScopeProvider scope={scope}>\n      <UserProfile />\n    </ScopeProvider>\n  )\n\n  expect(screen.getByText('Test User')).toBeInTheDocument()\n})\n```\n\n## SSR Compatibility {#c3-3-ssr}\n\nThe package is SSR-compatible because:\n1. No side effects on import\n2. Uses `useSyncExternalStore` with `getServerSnapshot`\n3. No window/document access\n4. Scope passed as prop (no global state)\n\n## Related {#c3-3-related}\n\n- [c3-2](../c3-2-lite/) - @pumped-fn/lite base library\n- [ADR-006](../adr/adr-006-select-fine-grained-reactivity.md) - select() API design\n- [ADR-003](../adr/adr-003-controller-reactivity.md) - Controller reactivity pattern\n",
        ".c3/c3-4-lite-devtools/README.md": "---\nid: c3-4\nc3-version: 3\ntitle: Lite Devtools Library (@pumped-fn/lite-devtools)\nsummary: >\n  Observability extension with fire-and-forget transports.\n---\n\n# Lite Devtools Library (@pumped-fn/lite-devtools)\n\n## Overview {#c3-4-overview}\n\nExtension-based observability for pumped-fn. Fire-and-forget, never blocks app.\n\n## API {#c3-4-api}\n\n```typescript\nimport { createDevtools, memory, broadcastChannel, consoleTransport } from '@pumped-fn/lite-devtools'\n\nconst mem = memory()\nconst scope = createScope({\n  extensions: [createDevtools({ transports: [mem] })]\n})\n\nmem.subscribe((events) => console.log(events))\n```\n\n**Transports:**\n| Transport | Use Case |\n|-----------|----------|\n| `memory()` | Same-process (panels, testing) |\n| `broadcastChannel()` | Browser tabs |\n| `consoleTransport()` | Debug logging |\n| `httpTransport()` | Cross-process (standalone server) |\n\n**Event types:** `atom:resolve`, `atom:resolved`, `flow:exec`, `flow:complete`, `error`\n\n## Source Organization {#c3-4-source}\n\n```\npackages/lite-devtools/\n├── src/\n│   ├── index.ts        # Public exports\n│   ├── extension.ts    # createDevtools() implementation\n│   ├── types.ts        # Devtools namespace, event types\n│   ├── symbols.ts      # Internal symbols\n│   └── transports/\n│       ├── index.ts    # Transport exports\n│       ├── memory.ts   # In-memory transport with subscribe()\n│       ├── broadcast.ts # BroadcastChannel transport\n│       ├── console.ts  # Console/debug transport\n│       └── http.ts     # HTTP POST transport\n├── tests/\n├── package.json\n└── tsdown.config.ts\n```\n\n## Related {#c3-4-related}\n\n- [ADR-015](../adr/adr-015-devtools-integration.md)\n- [c3-2 Extension System](../c3-2-lite/README.md#c3-2-extension)\n",
        ".c3/c3-5-lite-hmr/README.md": "---\nid: c3-5\nc3-version: 3\ntitle: Lite HMR Plugin (@pumped-fn/lite-hmr)\nsummary: >\n  Build-time Vite plugin preserving atom state across hot module reloads.\n---\n\n# Lite HMR Plugin (@pumped-fn/lite-hmr)\n\n## Overview {#c3-5-overview}\n\nVite plugin that transforms atom declarations at build time to preserve state across HMR reloads. No changes required to @pumped-fn/lite.\n\n**Problem:** Scope caches atoms by object reference. HMR reloads create new references, causing cache misses.\n\n**Solution:** Transform `atom({...})` → `__hmr_register(key, atom({...}))` to return cached references.\n\n## Architecture {#c3-5-architecture}\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                      Build Time                              │\n│  ┌─────────────────┐    ┌────────────────────────────────┐  │\n│  │   Vite Plugin   │───▶│  AST Transform (dev only)      │  │\n│  └─────────────────┘    │  - Detect atom() declarations  │  │\n│                         │  - Inject __hmr_register()      │  │\n│                         └────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘\n                              │\n                              ▼\n┌─────────────────────────────────────────────────────────────┐\n│                       Runtime                                │\n│  ┌─────────────────┐    ┌────────────────────────────────┐  │\n│  │ __hmr_register  │───▶│  import.meta.hot.data registry │  │\n│  └─────────────────┘    │  - Returns cached atom ref     │  │\n│                         │  - Scope cache naturally works │  │\n│                         └────────────────────────────────┘  │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## API {#c3-5-api}\n\n```typescript\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport { pumpedHmr } from '@pumped-fn/lite-hmr'\n\nexport default defineConfig({\n  plugins: [pumpedHmr()]\n})\n```\n\n**Options:**\n| Option | Default | Description |\n|--------|---------|-------------|\n| `include` | `/\\.[jt]sx?$/` | Files to transform |\n| `exclude` | `/node_modules/` | Files to skip |\n\n## Transform Rules {#c3-5-transforms}\n\n| Pattern | Transforms |\n|---------|------------|\n| `const foo = atom({...})` | ✅ Yes |\n| `let foo = atom({...})` | ✅ Yes |\n| `export const foo = atom({...})` | ✅ Yes |\n| `atoms.push(atom({...}))` | ❌ No (dynamic) |\n| `factory(() => atom({...}))` | ❌ No (nested) |\n\n## Production Safety {#c3-5-production}\n\n- Transform skipped when `NODE_ENV=production`\n- Runtime returns atom as-is when `import.meta.hot` undefined\n- Zero overhead in production builds\n\n## Source Organization {#c3-5-source}\n\n```\npackages/lite-hmr/\n├── src/\n│   ├── index.ts      # Plugin export\n│   ├── plugin.ts     # Vite plugin implementation\n│   ├── runtime.ts    # __hmr_register() helper\n│   ├── transform.ts  # AST transform logic\n│   └── types.ts      # PumpedHmrOptions\n├── tests/\n├── package.json\n└── tsdown.config.ts\n```\n\n## Related {#c3-5-related}\n\n- [c3-2 Scope](../c3-2-lite/c3-201-scope.md) - Cache behavior\n- [Design Doc](../../plans/2025-12-08-hmr-compatibility-design.md)\n",
        ".c3/c3-6-lite-devtools-server/README.md": "---\nid: c3-6\nc3-version: 3\ntitle: Lite Devtools Server (@pumped-fn/lite-devtools-server)\nsummary: >\n  Standalone TUI server receiving devtools events via HTTP from application processes.\n---\n\n# Lite Devtools Server (@pumped-fn/lite-devtools-server)\n\n## Overview {#c3-6-overview}\n\nCLI tool that receives devtools events via HTTP and displays them in a terminal dashboard. Designed for cross-process observability where the application and devtools UI run in separate processes.\n\n## Architecture {#c3-6-architecture}\n\n```mermaid\ngraph LR\n    subgraph \"Application Process\"\n        App[App]\n        DT[\"createDevtools()\"]\n        HT[\"httpTransport()\"]\n    end\n\n    subgraph \"Server Process\"\n        Server[\"Hono Server\"]\n        Atom[\"eventsAtom\"]\n        TUI[\"OpenTUI Dashboard\"]\n    end\n\n    App -->|events| DT\n    DT -->|fire-and-forget| HT\n    HT -->|POST /events| Server\n    Server -->|update| Atom\n    Atom -->|reactive| TUI\n```\n\n## Technology Stack {#c3-6-stack}\n\n| Layer | Choice | Rationale |\n|-------|--------|-----------|\n| HTTP Server | Hono | Lightweight, modern, works with Node.js |\n| State | @pumped-fn/lite | Dog-fooding the library, reactive atoms |\n| React Bindings | @pumped-fn/lite-react | Reactive UI updates via useAtom |\n| Terminal UI | OpenTUI | React-based TUI rendering |\n\n## API {#c3-6-api}\n\n### CLI\n\n```bash\n# Start server on default port 3001\nnpx @pumped-fn/lite-devtools-server\n\n# Custom port\nPORT=4000 npx @pumped-fn/lite-devtools-server\n```\n\n### HTTP Endpoints\n\n| Endpoint | Method | Description |\n|----------|--------|-------------|\n| `/events` | POST | Receive events (JSON array) |\n| `/events` | GET | Retrieve buffered events |\n| `/health` | GET | Health check |\n\n### Programmatic\n\n```typescript\nimport { createApp, scope, eventsAtom } from '@pumped-fn/lite-devtools-server'\nimport { serve } from '@hono/node-server'\n\nawait scope.ready\nawait scope.resolve(eventsAtom)\nconst ctrl = scope.controller(eventsAtom)\nconst app = createApp(ctrl)\nserve({ fetch: app.fetch, port: 3001 })\n```\n\n## Source Organization {#c3-6-source}\n\n```\npackages/lite-devtools-server/\n├── src/\n│   ├── bin.tsx     # CLI entry point\n│   ├── server.ts   # Hono HTTP server\n│   ├── state.ts    # Reactive state (eventsAtom)\n│   ├── ui.tsx      # OpenTUI React dashboard\n│   └── index.ts    # Public exports\n├── package.json\n└── tsconfig.json\n```\n\n## Related {#c3-6-related}\n\n- [c3-4 Lite Devtools](../c3-4-lite-devtools/) - Event source library with httpTransport\n- [ADR-015](../adr/adr-015-devtools-integration.md) - Devtools architecture decision\n- [c3-2 Lite](../c3-2-lite/) - Core library used for state management\n",
        ".c3/c3-7-lite-extension-otel/README.md": "---\nid: c3-7\nc3-version: 3\ntitle: Lite Extension OTel (@pumped-fn/lite-extension-otel)\nsummary: >\n  Self-contained OpenTelemetry tracing extension with tag-based configuration,\n  AsyncLocalStorage context propagation, and automatic provider lifecycle management.\n---\n\n# Lite Extension OTel (@pumped-fn/lite-extension-otel)\n\n## Overview {#c3-7-overview}\n\nSelf-contained OpenTelemetry integration for `@pumped-fn/lite` with tag-based configuration and automatic parent-child span relationships via AsyncLocalStorage.\n\n**Features:**\n- **Tracing** - Spans for flows with automatic hierarchy\n- **Tag-based Config** - Service name, exporter type, result capture via tags\n- **Self-contained** - Extension manages provider lifecycle (init/dispose)\n- **Per-execution Redaction** - Control sensitive data capture via context tags\n\n**Design principles:**\n1. Zero external setup - extension manages provider, exporter, tracer\n2. Tag-based configuration - no code coupling to OTel APIs\n3. AsyncLocalStorage for context propagation - reliable parent-child spans\n4. Focused on tracing - metrics removed as separate concern\n\n## Technology Stack {#c3-7-stack}\n\n| Category | Technology |\n|----------|------------|\n| Language | TypeScript 5.9+ |\n| Runtime | Node.js 18+ |\n| OTel | @opentelemetry/api, sdk-trace-base, exporter-trace-otlp-http |\n| Context | AsyncLocalStorage (node:async_hooks) |\n| Build | tsdown (rolldown-based) |\n| Test | Vitest |\n\n## Architecture {#c3-7-architecture}\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Scope\n    participant Ext as otel Extension\n    participant ALS as AsyncLocalStorage\n    participant Provider as TracerProvider\n\n    User->>Scope: setTag(otelConfig.*)\n    User->>Scope: createScope({ extensions: [otel()] })\n\n    Scope->>Ext: init(scope)\n    Ext->>Ext: Resolve otelConfig tags\n    Ext->>Provider: Create provider + exporter\n    Ext->>Ext: Create tracer\n\n    User->>Scope: ctx.exec({ flow })\n    Scope->>Ext: wrapExec(next, target, ctx)\n    Ext->>ALS: getStore() → parent OTel context\n    Ext->>Provider: startSpan(ctx.name, parent)\n    Ext->>ALS: run(newContext, next)\n    ALS-->>Ext: result\n    Ext->>Ext: Capture result (if enabled)\n    Ext->>Provider: span.end()\n\n    User->>Scope: dispose()\n    Scope->>Ext: dispose()\n    Ext->>Provider: shutdown()\n```\n\n## Span Hierarchy Flow {#c3-7-hierarchy}\n\n```mermaid\nsequenceDiagram\n    participant Root as Root Execution\n    participant Child as Child Execution\n    participant GC as Grandchild Execution\n    participant ALS as AsyncLocalStorage\n    participant Tracer\n\n    Root->>Child: ctx.exec({ flow: parent })\n    Child->>ALS: getStore() → ROOT_CONTEXT\n    Child->>Tracer: startSpan('parent', ROOT_CONTEXT)\n    Note over Child,Tracer: parentSpan created\n    Child->>ALS: run(parentOtelCtx, factory)\n\n    Child->>GC: ctx.exec({ flow: nested })\n    GC->>ALS: getStore() → parentOtelCtx\n    GC->>Tracer: startSpan('nested', parentOtelCtx)\n    Note over GC,Tracer: nestedSpan is child of parentSpan\n    GC->>ALS: run(nestedOtelCtx, factory)\n\n    GC-->>GC: factory returns\n    GC->>Tracer: nestedSpan.end()\n    GC-->>Child: return\n\n    Child-->>Child: factory returns\n    Child->>Tracer: parentSpan.end()\n    Child-->>Root: return\n```\n\n## API {#c3-7-api}\n\n### Basic Setup\n\n```typescript\nimport { createScope, flow } from '@pumped-fn/lite'\nimport { otel, otelConfig } from '@pumped-fn/lite-extension-otel'\n\nconst scope = createScope({\n  extensions: [otel()]\n})\n\nscope.setTag(otelConfig.name, 'my-app')\nscope.setTag(otelConfig.type, 'console')\n\nawait scope.ready\n\nconst myFlow = flow({\n  name: 'processOrder',\n  factory: async (ctx) => {\n    return { orderId: '123' }\n  }\n})\n\nconst ctx = scope.createContext()\nawait ctx.exec({ flow: myFlow })\nawait ctx.close()\n```\n\n### Production with OTLP HTTP Exporter\n\n```typescript\nimport { createScope } from '@pumped-fn/lite'\nimport { otel, otelConfig } from '@pumped-fn/lite-extension-otel'\n\nconst scope = createScope({\n  extensions: [otel()]\n})\n\nscope.setTag(otelConfig.name, 'production-app')\nscope.setTag(otelConfig.url, 'http://collector:4318/v1/traces')\nscope.setTag(otelConfig.type, 'http')\nscope.setTag(otelConfig.captureResults, true)\n\nawait scope.ready\n```\n\n### Configuration Tags\n\n```typescript\nexport const otelConfig = {\n  name: tag<string>({ label: \"otel.name\", default: \"default-app\" }),\n  url: tag<string>({ label: \"otel.url\", default: \"http://localhost:4318/v1/traces\" }),\n  type: tag<\"http\" | \"grpc\" | \"console\">({ label: \"otel.type\", default: \"console\" }),\n  captureResults: tag<boolean>({ label: \"otel.captureResults\", default: true }),\n  redact: tag<boolean>({ label: \"otel.redact\", default: false }),\n  exporter: tag<SpanExporter | undefined>({ label: \"otel.exporter\" }),\n}\n```\n\n### Redacting Sensitive Data\n\nControl per-execution redaction via context tag:\n\n```typescript\nconst sensitiveFlow = flow({\n  name: 'processPayment',\n  factory: async (ctx) => {\n    return { cardNumber: '4111-1111-1111-1111' }\n  }\n})\n\nconst ctx = scope.createContext()\nctx.data.setTag(otelConfig.redact, true)\nawait ctx.exec({ flow: sensitiveFlow })\n```\n\n### Span Naming\n\nSpans use execution name with fallback to flow name:\n\n```typescript\n// Span name: \"customName\"\nawait ctx.exec({ flow: myFlow, name: 'customName' })\n\n// Span name: \"myFlow\"\nconst myFlow = flow({ name: 'myFlow', factory: () => {} })\nawait ctx.exec({ flow: myFlow })\n\n// Span name: \"unknown-flow\"\nconst anonFlow = flow({ factory: () => {} })\nawait ctx.exec({ flow: anonFlow })\n```\n\n## Lifecycle Management {#c3-7-lifecycle}\n\n### Extension Lifecycle\n\nThe extension manages the complete OpenTelemetry provider lifecycle:\n\n1. **init(scope)** - Creates provider, exporter, tracer from tags\n2. **wrapExec(next, target, ctx)** - Wraps executions with spans\n3. **dispose()** - Shuts down provider and flushes spans\n\n## Source Organization {#c3-7-source}\n\n```\npackages/lite-extension-otel/\n├── src/\n│   └── index.ts           # Complete implementation (~80 LOC)\n│                          # - otelConfig tags\n│                          # - otel() extension factory\n│                          # - Provider management\n│                          # - AsyncLocalStorage context\n│                          # - Span creation/completion\n├── tests/\n│   └── otel.test.ts       # Comprehensive test suite\n├── package.json\n├── tsconfig.json\n└── tsdown.config.ts\n```\n\n**Key implementation details:**\n\n- **Tag Config** - `otelConfig` exports for name, url, type, captureResults, redact\n- **Provider Management** - BasicTracerProvider with ConsoleSpanExporter or OTLPTraceExporter\n- **Context Propagation** - AsyncLocalStorage stores OpenTelemetry context across async boundaries\n- **Span Lifecycle** - Created in wrapExec, ended in finally block\n- **Result Capture** - Configurable via captureResults tag, respects redact flag\n- **Shutdown** - Provider cleanup in dispose()\n\n## Testing {#c3-7-testing}\n\n**Test coverage:**\n- Tag-based configuration initialization\n- Span creation with correct naming (ctx.name, flow.name, fallback)\n- Parent-child span hierarchy via AsyncLocalStorage\n- Error recording and span status codes\n- Result capture configuration (captureResults, redact tags)\n- Provider lifecycle (init, dispose)\n\n**Test infrastructure:**\n- InMemorySpanExporter for span inspection\n- BasicTracerProvider for test isolation\n- Vitest test runner\n\n**Running tests:**\n```bash\npnpm -F @pumped-fn/lite-extension-otel test\npnpm -F @pumped-fn/lite-extension-otel typecheck\n```\n\n## Related {#c3-7-related}\n\n- [ADR-025](../adr/adr-025-otel-simplification.md) - Simplification to self-contained extension\n- [ADR-018](../adr/adr-018-otel-extension.md) - Original design decision\n- [ADR-023](../adr/adr-023-tag-deps-seek-hierarchy.md) - Tag hierarchical lookup enabling per-execution redaction\n- [c3-2 Extension System](../c3-2-lite/README.md#c3-2-extension) - Extension interface (init/wrapExec/dispose)\n- [c3-4 lite-devtools](../c3-4-lite-devtools/README.md) - Similar extension pattern\n",
        ".changeset/README.md": "# Changesets\n\nHello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works\nwith multi-package repos, or single-package repos to help you version and publish your code. You can\nfind the full documentation for it [in our repository](https://github.com/changesets/changesets)\n\nWe have a quick list of common questions to get you started engaging with this project in\n[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)\n",
        ".claude/commands/pf:feature.md": "# Feature Development Workflow\n\nStructured workflow for developing new features with proper scoping, documentation, and task breakdown.\n\n## Arguments\n\n- `$ARGUMENTS` - Brief description of the feature to develop\n\n## Process\n\nExecute following steps sequentially:\n\n1. **Scope the feature**\n   - Use `/c3-skill:c3-use` to understand current architecture\n   - Identify which C3 layers (Context/Container/Component) are affected\n   - Map dependencies and integration points\n\n2. **Determine documentation impact**\n   - Assess if changes require C3 documentation updates\n   - If architectural changes needed → proceed to step 3\n   - If implementation-only changes → skip to step 4\n\n3. **Create ADR (if needed)**\n   - Use `/c3-skill:c3` to draft Architecture Decision Record\n   - Document the decision context, options considered, and chosen approach\n   - Include trade-offs and consequences\n\n4. **Create review diagram**\n   - Build mermaid diagram summarizing the proposed changes\n   - Generate mermaid.live link for stakeholder review\n   - Format: `https://mermaid.live/edit#pako:<base64-encoded-diagram>`\n   - Present diagram link and wait for approval\n\n5. **Wait for ADR approval**\n   - Present the ADR summary and diagram for review\n   - Explicitly ask: \"Is this approach approved? (yes/no)\"\n   - Do NOT proceed until explicit approval received\n\n6. **Create implementation plan**\n   - Use `/superpowers:write-plan` to break down into tasks\n   - Eliminate superficial details (comments, trivial type annotations)\n   - Focus on concrete, testable implementation steps\n   - Plan file created at: `.plans/<feature-slug>.md`\n\n7. **Convert plan to beads tickets**\n   - Read the generated plan file\n   - For each task, create bead with `bd create`:\n     - `--title`: Clear, action-oriented title\n     - `--type`: task, bug, or feature as appropriate\n   - Append to each ticket:\n     - Related C3 document references (if applicable)\n     - Exact file paths to modify\n     - Acceptance criteria\n     - Dependencies on other tickets\n   - Use `bd dep add` to establish dependencies between related tickets\n\n## Success criteria\n\n- Architecture understood via C3 scoping\n- ADR created (if architectural changes needed)\n- Mermaid diagram generated for review\n- Explicit approval received before planning\n- Implementation plan created without superficial details\n- All tasks converted to beads tickets with:\n  - C3 document references\n  - Clear acceptance criteria\n  - Proper dependency chains\n  - Sufficient detail for independent implementation\n\n## Error handling\n\nIf any step fails:\n- Report error clearly with context\n- Suggest corrective actions\n- Wait for user input before proceeding\n\n## Notes\n\n- Each beads ticket should be implementable by an average developer without additional context\n- Use `bd ready` to verify tickets are properly configured\n- Tickets should be independent where possible, with explicit dependencies where not\n",
        ".claude/commands/pf:implement.md": "# Implementation Workflow\n\nPick up beads tickets and implement them using subagent-driven-development with code review between tasks.\n\n## Arguments\n\n- `$ARGUMENTS` - Optional: specific bead ID(s) to implement, or epic ID to work on\n\n## Process\n\nExecute following steps sequentially:\n\n1. **Find available work**\n   - If specific bead ID provided → use that\n   - If epic ID provided → list tickets in that epic with `bd list`\n   - Otherwise → run `bd ready` to find unblocked tickets\n   - Show available tickets and let user confirm which to work on\n\n2. **Review ticket context**\n   - Run `bd show <id>` for selected ticket\n   - Read referenced C3 documents (if any)\n   - Understand acceptance criteria and dependencies\n   - Identify exact files to modify\n\n3. **Claim the work**\n   - Run `bd update <id> --status=in_progress`\n\n4. **Implement using subagent-driven-development**\n   - Use `subagent-driven-development` skill for implementation\n   - Follow TDD workflow: write test first, watch it fail, implement\n   - Each task gets a fresh subagent\n   - Code review between tasks\n\n5. **Verify implementation**\n   - Run typecheck: `pnpm -F <package> typecheck`\n   - Run tests: `pnpm -r test`\n   - Ensure all acceptance criteria met\n\n6. **Close completed ticket**\n   - Run `bd close <id>`\n   - If multiple tickets completed → `bd close <id1> <id2> ...`\n\n7. **Sync and continue**\n   - Run `bd sync` to push changes\n   - Check `bd ready` for next available ticket\n   - Ask user: \"Continue with next ticket? (yes/no)\"\n\n## Success criteria\n\n- Ticket claimed before work starts\n- TDD workflow followed (test-first)\n- Code review performed between tasks\n- Typecheck and tests passing\n- All acceptance criteria met\n- Ticket closed upon completion\n- Changes synced to remote\n\n## Error handling\n\nIf implementation fails:\n- Do NOT close the ticket\n- Report what went wrong\n- Keep ticket in `in_progress` status\n- Ask for guidance before proceeding\n\nIf tests fail:\n- Use `systematic-debugging` skill to investigate\n- Fix root cause, not symptoms\n- Re-run verification before closing\n\n## Notes\n\n- Use `bd blocked` to check if current work is blocking others\n- Prioritize unblocking work when possible\n- Each ticket should be completable in one session\n- If ticket is too large, discuss breaking it down\n",
        ".claude/commands/pf:release.md": "# Release Preparation Workflow\n\nAutomate release preparation for pumped-fn with changesets and CI validation.\n\n## Process\n\nExecute following steps sequentially:\n\n1. **Run typecheck**\n   - Run `pnpm -F @pumped-fn/lite typecheck` for src code types\n   - Run `pnpm -F @pumped-fn/lite typecheck:full` for test code types\n   - If typecheck fails, fix errors and re-run until passing\n   - Both src and test typecheck must pass before proceeding\n\n2. **Run tests**\n   - Run `pnpm -r test` for all packages\n   - If tests fail, fix errors and re-run until passing\n   - All tests must pass before proceeding\n\n3. **Commit staged changes**\n   - Run `git status` to check current state\n   - If uncommitted changes exist, draft commit message following repo conventions\n   - Create commit with proper formatting\n   - If commit fails due to pre-commit hooks, handle modifications and retry\n\n4. **Handle conflicts**\n   - Check for merge conflicts with `git status`\n   - If conflicts exist, identify files and guide resolution\n   - After resolution, verify with `git status`\n   - Re-run typecheck and tests after conflict resolution\n\n5. **Verify documentation builds**\n   - Run `pnpm docs:build` to build documentation\n   - Ensure build passes as docs depend on latest version content\n   - Fix any documentation build failures before proceeding\n\n6. **Create changeset**\n   - Run `pnpm changeset add` interactively\n   - **Always select patch version bump**\n   - Provide clear, concise changeset description\n   - Verify changeset file created in `.changeset/` directory\n\n7. **Push to GitHub**\n   - Get current branch name with `git branch --show-current`\n   - Push commits with `git push`\n   - Confirm push succeeded\n\n8. **Monitor CI/CD**\n   - Use `gh run list --branch <branch>` to check GitHub Actions status\n   - Use `gh run watch` to monitor latest workflow run\n   - If failures occur:\n     - Use `gh run view --log-failed` to analyze failures\n     - Identify root cause from logs\n     - Apply fixes locally\n     - Re-run typecheck and tests to verify fixes\n     - Commit and push fixes\n     - Monitor again until all workflows pass\n\n## Success criteria\n\n- Typecheck passes for all packages (src and tests)\n- All tests pass\n- All commits pushed to GitHub\n- Changeset created with patch version\n- All GitHub Actions workflows passing\n- No merge conflicts\n- Documentation builds successfully\n\n## Error handling\n\nIf any step fails:\n- Report error clearly with context\n- Suggest corrective actions\n- Wait for user input before proceeding\n- Do not skip steps even if blocked\n\n## Notes\n\n- Use `gh` binary for GitHub interactions (already authenticated)\n- Follow CLAUDE.md coding standards for any code fixes\n- Ensure typecheck passes for TypeScript fixes\n- Use pnpm as package manager\n",
        ".claude/commands/pf:review.md": "# Review and PR Workflow\n\nReview implementation against ADR, clean up slop, and create pull request.\n\n## Arguments\n\n- `$ARGUMENTS` - Optional: epic ID or feature name to review\n\n## Process\n\nExecute following steps sequentially:\n\n1. **Verify all work complete**\n   - Run `bd list --status=in_progress` to check for incomplete work\n   - If tickets remain open → warn user and ask to continue or abort\n   - Run `bd list --status=open` for the epic to confirm all done\n\n2. **Review against ADR**\n   - Locate relevant ADR in `.c3/` directory\n   - Compare implementation against documented decisions\n   - Verify all acceptance criteria met\n   - Flag any deviations from ADR\n\n3. **Run verification suite**\n   - Typecheck: `pnpm -F @pumped-fn/lite typecheck`\n   - Typecheck tests: `pnpm -F @pumped-fn/lite typecheck:full`\n   - All tests: `pnpm -r test`\n   - Documentation build: `pnpm docs:build`\n   - All must pass before proceeding\n\n4. **Execute noslop cleanup**\n   - Remove excessive comments (keep only non-obvious explanations)\n   - Remove unnecessary type annotations (where inference works)\n   - Remove verbose error handling (simplify where appropriate)\n   - Remove redundant documentation\n   - Remove dead code and unused imports\n   - Criteria: if a junior dev can understand without it, remove it\n\n5. **Update package README**\n   - Check if README.md needs updates for new features\n   - Ensure diagrams reflect current architecture\n   - Keep focused on how the library works\n\n6. **Run C3 audit**\n   - Use `/c3-skill:c3-audit` to verify docs match implementation\n   - Fix any drift between docs and code\n   - Update C3 documents if needed\n\n7. **Re-run verification**\n   - Repeat typecheck and tests after cleanup\n   - Ensure noslop changes didn't break anything\n\n8. **Commit all changes**\n   - Run `git status` to review changes\n   - Stage relevant files: `git add <files>`\n   - Commit with descriptive message\n   - Run `bd sync` to sync beads state\n\n9. **Finish development branch**\n   - Use `finishing-a-development-branch` skill\n   - Choose appropriate integration path (merge, PR, cleanup)\n\n10. **Create pull request**\n    - Use `gh pr create` with:\n      - Clear title summarizing the feature\n      - Body containing:\n        - Summary of changes (bullet points)\n        - Link to ADR (if applicable)\n        - Mermaid diagram of architecture changes\n        - Test plan checklist\n    - Format body using HEREDOC for proper formatting\n\n## Slop Checklist\n\nRemove these patterns during noslop cleanup:\n\n- [ ] Comments that restate the code (`// increment counter` above `counter++`)\n- [ ] JSDoc for self-explanatory functions\n- [ ] Type annotations where TypeScript infers correctly\n- [ ] Empty catch blocks or generic error handlers\n- [ ] Console.log statements left from debugging\n- [ ] Commented-out code\n- [ ] TODO comments that won't be addressed\n- [ ] Redundant null checks where types guarantee presence\n- [ ] Over-defensive programming for internal APIs\n\n## Success criteria\n\n- All beads tickets for feature closed\n- Implementation matches ADR decisions\n- Typecheck and tests passing\n- Noslop cleanup complete\n- C3 audit passing\n- README updated (if needed)\n- PR created with proper documentation\n- Mermaid diagram included in PR\n\n## Error handling\n\nIf verification fails after cleanup:\n- Revert problematic cleanup changes\n- Keep functional code even if slightly verbose\n- Document why cleanup was reverted\n\nIf C3 audit finds drift:\n- Prioritize updating docs to match code\n- Only change code if docs represent intended design\n\n## Notes\n\n- Noslop is about clarity, not minimalism\n- Keep comments that explain \"why\", remove those that explain \"what\"\n- PR should be reviewable by someone unfamiliar with the feature\n- Use `gh pr view` to verify PR created correctly\n",
        ".claude/hooks/git.md": "---\nallowed-tools: [Bash, Read, Glob, TodoWrite, Edit]\ndescription: \"Git operations with intelligent commit messages and branch management\"\n---\n\n# /git - Git Operations\n\n## Purpose\nExecute Git operations with intelligent commit messages, branch management, and workflow optimization.\n\n## Usage\n```\n/git [operation] [args] [--smart-commit] [--branch-strategy]\n```\n\n## Arguments\n- `operation` - Git operation (add, commit, push, pull, merge, branch, status)\n- `args` - Operation-specific arguments\n- `--smart-commit` - Generate intelligent commit messages\n- `--branch-strategy` - Apply branch naming conventions\n- `--interactive` - Interactive mode for complex operations\n\n## Execution\n1. Analyze current Git state and repository context\n2. Execute requested Git operations with validation\n3. Apply intelligent commit message generation\n4. Handle merge conflicts and branch management\n5. Provide clear feedback and next steps\n\n## Claude Code Integration\n- Uses Bash for Git command execution\n- Leverages Read for repository analysis\n- Applies TodoWrite for operation tracking\n- Maintains Git best practices and conventions",
        ".claude/skills/README.md": "# Project-Scoped Skills\n\nProject skills are located in the `skills/` directory at project root.\n\n## Pumped-design Skill\n\n**pumped-design** - Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns.\n\n### Features\n\n- Strict organizational patterns (entrypoints, resources, flows, utilities)\n- Sub-skill architecture with 14 specialized reference guides\n- Layer-specific testing strategies\n- Framework integration guides (Hono, Next.js, TanStack Start)\n- AI-assisted catalog system with mermaid diagrams\n- Type-safe error handling patterns\n\n### Structure\n\n```\npumped-design/\n├── SKILL.md                           # Main routing skill\n└── references/                        # Sub-skills loaded on-demand\n    ├── coding-standards.md            # Type safety, naming, style\n    ├── resource-basic.md              # Standalone resources\n    ├── resource-derived.md            # Resources with dependencies\n    ├── resource-lazy.md               # Lazy/conditional resources\n    ├── flow-subflows.md               # Flow orchestration\n    ├── flow-context.md                # Context operations\n    ├── integration-hono.md            # Hono server integration\n    ├── integration-nextjs.md          # Next.js integration\n    ├── integration-tanstack.md        # TanStack Start integration\n    ├── testing-utilities.md           # Unit testing patterns\n    ├── testing-flows.md               # Flow integration testing\n    ├── testing-integration.md         # E2E testing\n    ├── extension-basics.md            # Cross-cutting concerns\n    └── entrypoint-patterns.md         # Entrypoint structure\n```\n\n### Usage\n\nThe skill uses YAML frontmatter tags for AI-driven sub-skill routing. When working with pumped-fn applications, the main SKILL.md determines which references/ sub-skills to load based on task context.\n\n### External Skills\n\nGeneral development workflows use superpowers plugin from marketplace:\n- test-driven-development, systematic-debugging, verification-before-completion\n- requesting-code-review, brainstorming, writing-plans, executing-plans\n- using-git-worktrees, defense-in-depth, condition-based-waiting\n\n### Marketplace\n\nThis skill is published to marketplace as the pumped-design plugin. See `.claude-plugin/marketplace.json` and `claude-skill/plugin.json` for configuration.\n",
        ".github/workflows/README.md": "# GitHub Actions Workflows\n\n## package-skills.yml\n\nAutomatically packages pumped-fn skill as zip file when skill files are modified.\n\n### Triggers\n\n- **Push to main**: When `.claude/skills/pumped-fn/**` or `claude-skill/skills/pumped-fn/**` changes\n- **Pull requests**: When pumped-fn skill files are modified in PRs\n\n### Behavior\n\n1. **Detects pumped-fn skill changes**: Monitors only pumped-fn skill directory (excludes superpowers copies)\n2. **Validates structure**: Ensures `SKILL.md` exists in skill directory\n3. **Creates zip file**: Packages pumped-fn skill directory in standard format\n   - Format: `skill-name.zip` containing `skill-name/SKILL.md` and all skill files\n   - Structure matches Claude Code skill directory layout\n4. **Uploads artifacts**: Stores zips as GitHub Actions artifacts (90-day retention)\n5. **Creates GitHub Release** (main branch only): Auto-generates release with skill zips attached and installation instructions\n\n### Zip File Format\n\nStandard Claude Code skill structure:\n\n```\npumped-fn.zip\n└── pumped-fn/\n    ├── SKILL.md          # Required: skill frontmatter + content\n    ├── examples/         # Optional: supporting files\n    ├── templates/        # Optional: code templates\n    └── scripts/          # Optional: helper scripts\n```\n\n### Usage\n\n#### Install Skills from GitHub Releases\n\nDownload latest skill zip from releases:\n\n```bash\n# Find latest release\ngh release list --limit 5\n\n# Download specific release\ngh release download skills-20251027-120000 --pattern \"pumped-fn.zip\"\n\n# Extract to personal skills directory\nunzip pumped-fn.zip -d ~/.claude/skills/\n\n# Or extract to project skills directory\nunzip pumped-fn.zip -d .claude/skills/\n```\n\nOr download manually from [Releases page](https://github.com/pumped-fn/pumped-fn/releases).\n\n#### Install Skills from Artifacts (PR builds)\n\nFor pull request builds, download from GitHub Actions artifacts:\n\n```bash\n# Navigate to Actions tab, select workflow run, download artifact\nunzip pumped-fn.zip -d ~/.claude/skills/\n```\n\n### Development\n\nTest workflow locally with [act](https://github.com/nektos/act):\n\n```bash\n# List workflow jobs\nact -l -W .github/workflows/package-skills.yml\n\n# Run workflow (dry run)\nact push -W .github/workflows/package-skills.yml --dry-run\n\n# Run workflow with skill changes\nact push -W .github/workflows/package-skills.yml\n```\n\n### Configuration\n\n**Paths monitored**:\n- `.claude/skills/pumped-fn/**` - Project-scoped pumped-fn skill\n- `claude-skill/skills/pumped-fn/**` - Marketplace pumped-fn skill (plugin distribution)\n\n**Note**: Only pumped-fn skills are packaged. Superpowers skills (copied from upstream) are excluded.\n\n**Artifacts retention**: 90 days (configurable in workflow)\n\n**Release tags**: Auto-generated as `skills-YYYYMMDD-HHMMSS` (timestamp-based)\n\n### Troubleshooting\n\n**Workflow not triggering**:\n- Verify skill files are in monitored paths\n- Check workflow file syntax: `act -l -W .github/workflows/package-skills.yml`\n\n**Zip validation failed**:\n- Ensure `SKILL.md` exists in skill directory\n- Verify frontmatter is valid YAML (name, description, when_to_use)\n\n**Missing artifacts or releases**:\n- Check Actions tab for workflow run logs\n- Artifacts retained for 90 days, check retention period\n- Releases are only created on main branch pushes (not PRs)\n",
        "README.md": "# pumped-fn\n\n[![npm version](https://img.shields.io/npm/v/@pumped-fn/lite)](https://www.npmjs.com/package/@pumped-fn/lite)\n\nA lightweight effect system for TypeScript with managed lifecycles and minimal reactivity.\n\n## What is an Effect System?\n\nAn effect system manages **how** and **when** computations run:\n- **Resource lifecycle** - acquire, use, release\n- **Computation ordering** - dependency resolution\n- **Side effect isolation** - controlled execution boundaries\n\n## Install\n\n```bash\nnpm install @pumped-fn/lite\n```\n\n## Core Concepts\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                         Scope                               │\n│  (long-lived execution boundary)                            │\n│                                                             │\n│   ┌─────────┐      ┌─────────┐      ┌─────────┐            │\n│   │  Atom   │ ──── │  Atom   │ ──── │  Atom   │            │\n│   │ (effect)│      │ (effect)│      │ (effect)│            │\n│   └─────────┘      └─────────┘      └─────────┘            │\n│        │                                  │                 │\n│        └──────────────┬───────────────────┘                 │\n│                       ▼                                     │\n│   ┌─────────────────────────────────────────────────────┐   │\n│   │              ExecutionContext                       │   │\n│   │  (short-lived operation with input, tags, cleanup)  │   │\n│   └─────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────┘\n```\n\n| Concept | Purpose |\n|---------|---------|\n| **Scope** | Long-lived boundary that manages atom lifecycles |\n| **Atom** | A managed effect with lifecycle (create, cache, cleanup, recreate) |\n| **ExecutionContext** | Short-lived context for running operations |\n| **Controller** | Handle for observing and controlling an atom's state |\n| **Tag** | Contextual value passed through execution |\n\n## Effect Lifecycle\n\n```mermaid\nstateDiagram-v2\n    [*] --> idle\n    idle --> resolving: resolve()\n    resolving --> resolved: success\n    resolving --> failed: error\n    resolved --> resolving: invalidate()\n    failed --> resolving: invalidate()\n    resolved --> idle: release()\n    failed --> idle: release()\n```\n\n## API Reference\n\n| Function | Description |\n|----------|-------------|\n| `createScope(options?)` | Create execution boundary |\n| `atom(config)` | Define managed effect (long-lived) |\n| `flow(config)` | Define operation template |\n| `tag(config)` | Define contextual value |\n| `controller(atom)` | Wrap atom for deferred resolution |\n| `preset(atom, value)` | Override atom value in scope |\n\n## Example: Snake Game\n\n```typescript\nimport { atom, tag, tags, controller, createScope } from '@pumped-fn/lite'\n\ntype Point = { x: number; y: number }\ntype Dir = 'up' | 'down' | 'left' | 'right'\ntype GameState = { snake: Point[]; food: Point; dir: Dir; score: number; hi: number; dead: boolean; size: number }\n\nconst gridSize = tag<number>({ label: 'gridSize', default: 20 })\nconst tickMs = tag<number>({ label: 'tickMs', default: 100 })\nconst stateTag = tag<GameState>({ label: 'state' })\n\nconst gameAtom = atom({\n  deps: { size: tags.required(gridSize) },\n  factory: (ctx, { size }): GameState => {\n    let state = ctx.data.get(stateTag)  // GameState | undefined - type safe!\n    if (!state) {\n      state = {\n        snake: [{ x: Math.floor(size/2), y: Math.floor(size/2) }],\n        food: { x: Math.floor(size/4), y: Math.floor(size/4) },\n        dir: 'right', score: 0, hi: 0, dead: false, size\n      }\n      ctx.data.set(stateTag, state)  // Type checked\n    }\n    return state\n  }\n})\n\nconst tickerAtom = atom({\n  deps: { ms: tags.required(tickMs), game: controller(gameAtom) },\n  factory: (ctx, { ms, game }) => {\n    const id = setInterval(() => {\n      const state = game.get()\n      if (!state.dead) {\n        tick(state)\n        game.invalidate()\n      }\n    }, ms)\n    ctx.cleanup(() => clearInterval(id))\n  }\n})\n\nfunction tick(s: GameState) { /* move snake, check collisions, update score */ }\n\nasync function createSnakeGame(size = 20, tickInterval = 100) {\n  const scope = createScope({ tags: [gridSize(size), tickMs(tickInterval)] })\n  const gameCtrl = scope.controller(gameAtom)\n  const tickerCtrl = scope.controller(tickerAtom)\n  await gameCtrl.resolve()\n\n  const turn = (dir: Dir) => {\n    const state = gameCtrl.get()\n    const opposite: Record<Dir, Dir> = { up: 'down', down: 'up', left: 'right', right: 'left' }\n    if (opposite[dir] !== state.dir && !state.dead) state.dir = dir\n  }\n\n  return {\n    state: gameCtrl,\n    up: () => turn('up'),\n    down: () => turn('down'),\n    left: () => turn('left'),\n    right: () => turn('right'),\n    step: () => { tick(gameCtrl.get()); gameCtrl.invalidate() },\n    start: () => tickerCtrl.resolve(),\n    pause: () => tickerCtrl.release(),\n    dispose: () => scope.dispose()\n  }\n}\n\nconst game = await createSnakeGame(15, 100)\ngame.state.on('resolved', () => render(game.state.get()))\nawait game.start()\ngame.down()\n```\n\n**What's demonstrated:**\n- **`tag`** - `gridSize`, `tickMs` configure game per-instance; `stateTag` provides typed storage key\n- **`ctx.data`** - State persists across `invalidate()` calls with type-safe tag-based API\n- **`controller()`** - Ticker gets `Controller<GameState>`, calls `.get()` and `.invalidate()`\n- **`invalidate()`** - Re-runs factory, notifies subscribers\n- **`cleanup()`** - Ticker interval cleared on `pause()`\n- **`ctrl.on('resolved')`** - UI subscribes to state changes\n\n## Design Principles\n\n1. **Minimal API** - Every export is expensive to learn\n2. **Zero dependencies** - No runtime dependencies\n3. **Explicit lifecycle** - No magic, clear state transitions\n4. **Composable** - Effects compose through deps\n\n## License\n\nMIT\n",
        "docs/README.md": "# pumped-fn docs entry\n\nCanonical reference lives in [docs/index.md](./index.md). Load that file for diagrams, API grid, and twoslash sample.\n\nThe main package is `@pumped-fn/lite`. Build with `pnpm docs:build` if you touch anything.\n",
        "packages/codemod/README.md": "# @pumped-fn/codemod\n\nOne-time migration tool from `@pumped-fn/core-next` to `@pumped-fn/lite`.\n\n## Transform Flow\n\n```mermaid\ngraph TD\n    A[Source Files] --> B[jscodeshift]\n    B --> C{Transform Type}\n    C --> D[provide → atom]\n    C --> E[derive → atom with deps]\n    C --> F[executor.lazy/reactive → controller]\n    C --> G[Type Transforms]\n    D --> H[Transformed Files]\n    E --> H\n    F --> H\n    G --> H\n    H --> I[migration-report.md]\n    I --> J[Manual Review]\n```\n\n## Usage\n\n```bash\n# Run on current directory\nnpx @pumped-fn/codemod\n\n# Run on specific path\nnpx @pumped-fn/codemod ./src\n\n# Dry run (preview changes)\nnpx @pumped-fn/codemod --dry\n\n# Verbose output\nnpx @pumped-fn/codemod --verbose\n```\n\n## What Gets Transformed\n\n| Before | After |\n|--------|-------|\n| `provide((ctl) => value)` | `atom({ factory: (ctx) => value })` |\n| `derive([a, b], fn)` | `atom({ deps: { a, b }, factory: fn })` |\n| `executor.lazy` | `controller(executor)` |\n| `executor.reactive` | `controller(executor)` |\n| `Core.Executor<T>` | `Lite.Atom<T>` |\n| `ctl.release()` | `ctx.invalidate()` |\n| `import { ... } from '@pumped-fn/core-next'` | `import { ... } from '@pumped-fn/lite'` |\n\n## Migration Report\n\nAfter running, check `migration-report.md` for:\n- Summary statistics (files processed, transforms applied)\n- Edge cases requiring manual review\n- AI-friendly JSON for assisted migration\n- Detailed breakdown of each transform type\n\n## After Running\n\n```bash\n# Review changes\ngit diff\n\n# Update dependencies\nnpm uninstall @pumped-fn/core-next\nnpm install @pumped-fn/lite\n\n# Fix remaining TypeScript errors\nnpm run typecheck\n```\n\n## Edge Cases\n\nSome patterns cannot be auto-transformed:\n\n- `Core.Static<T>` - no equivalent in lite\n- `resolves([...])` - use `Promise.all` with `scope.resolve()`\n- Dynamic accessor references - requires manual refactoring\n- Spread in dependencies - convert to explicit object keys\n- Complex executor patterns - may need manual review\n\nThese cases are flagged in `migration-report.md` with file locations for manual review.\n\n## CLI Options\n\n```\nOptions:\n  --dry          Preview changes without writing files\n  --verbose      Show detailed transform information\n  --help         Show help message\n```\n\n## Examples\n\n### Basic Migration\n\n```bash\n# Before\nimport { provide, derive } from '@pumped-fn/core-next';\n\nconst userAtom = provide((ctl) => ({ name: 'Alice' }));\nconst nameAtom = derive([userAtom], (user) => user.name);\n\n// After\nimport { atom } from '@pumped-fn/lite';\n\nconst userAtom = atom({ factory: (ctx) => ({ name: 'Alice' }) });\nconst nameAtom = atom({ deps: { userAtom }, factory: ({ userAtom }) => userAtom.name });\n```\n\n### Controller Migration\n\n```bash\n# Before\nimport { executor } from '@pumped-fn/core-next';\n\nconst fetchUser = executor.lazy(async (ctl, id: string) => {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n});\n\n// After\nimport { controller } from '@pumped-fn/lite';\n\nconst fetchUser = controller(async (ctx, id: string) => {\n  const response = await fetch(`/api/users/${id}`);\n  return response.json();\n});\n```\n\n## Troubleshooting\n\n**TypeScript errors after migration:**\n- Check `migration-report.md` for edge cases\n- Review type transforms for `Core.Executor` → `Lite.Atom`\n- Ensure `@pumped-fn/lite` is installed\n\n**Transforms not applied:**\n- Verify file patterns match (`.ts`, `.tsx` files)\n- Check for syntax errors in source files\n- Use `--verbose` to see transform details\n\n**Need to revert:**\n```bash\ngit checkout .\n```\n",
        "packages/lite-devtools-server/README.md": "# @pumped-fn/lite-devtools-server\n\nStandalone TUI server for receiving devtools events from `@pumped-fn/lite-devtools` via HTTP.\n\n**CLI tool** · **Terminal dashboard** · **HTTP receiver**\n\n## Architecture\n\n```mermaid\ngraph LR\n    subgraph \"Application Process\"\n        App[Your App]\n        DT[\"@pumped-fn/lite-devtools\"]\n        HTTP[\"httpTransport()\"]\n    end\n\n    subgraph \"Server Process\"\n        Server[\"@pumped-fn/lite-devtools-server\"]\n        TUI[Terminal Dashboard]\n    end\n\n    App -->|events| DT\n    DT -->|fire-and-forget| HTTP\n    HTTP -->|POST /events| Server\n    Server -->|renders| TUI\n```\n\n## Usage\n\n### Start the server\n\n```bash\nnpx @pumped-fn/lite-devtools-server\n# Or with custom port\nPORT=4000 npx @pumped-fn/lite-devtools-server\n```\n\n### Configure your app\n\n```typescript\nimport { createScope } from '@pumped-fn/lite'\nimport { createDevtools, httpTransport } from '@pumped-fn/lite-devtools'\n\nconst scope = createScope({\n  extensions: [\n    createDevtools({\n      transports: [httpTransport({ url: 'http://localhost:3001/events' })]\n    })\n  ]\n})\n```\n\n## API\n\n### HTTP Endpoints\n\n| Endpoint | Method | Description |\n|----------|--------|-------------|\n| `/events` | POST | Receive events from httpTransport |\n| `/events` | GET | Retrieve buffered events (last 100) |\n| `/health` | GET | Health check |\n\n## How It Works\n\n1. Server starts Hono HTTP server on specified port (default: 3001)\n2. Events POSTed to `/events` are buffered (max 100 events)\n3. TUI dashboard displays last 20 events in real-time\n4. Uses `@pumped-fn/lite` atoms for reactive state management\n\n## Full API\n\nSee [`dist/index.d.mts`](./dist/index.d.mts) for complete type definitions.\n\n## License\n\nMIT\n",
        "packages/lite-devtools/README.md": "# @pumped-fn/lite-devtools\n\nObservability extension for `@pumped-fn/lite` with fire-and-forget transport-based event streaming.\n\n**Zero dependencies** · **Fire-and-forget** · **Multiple transports**\n\n## How It Works\n\n```mermaid\nsequenceDiagram\n    participant App\n    participant Scope\n    participant Extension as createDevtools()\n    participant Queue as Event Queue\n    participant Transport\n\n    App->>Scope: createScope({ extensions: [createDevtools(...)] })\n\n    App->>Scope: scope.resolve(atom)\n    Scope->>Extension: wrapResolve()\n    Extension->>Queue: atom:resolve event\n    Note over Queue: Batched, non-blocking\n    Queue-->>Transport: send(events[])\n    Extension-->>Scope: value\n    Extension->>Queue: atom:resolved event\n\n    App->>Scope: ctx.exec({ flow })\n    Scope->>Extension: wrapExec()\n    Extension->>Queue: flow:exec event\n    Extension-->>Scope: result\n    Extension->>Queue: flow:complete event\n```\n\n## Transport Architecture\n\n```mermaid\ngraph LR\n    subgraph \"Application\"\n        Ext[createDevtools]\n        Queue[Event Queue]\n    end\n\n    subgraph \"Transports\"\n        Mem[memory]\n        BC[broadcastChannel]\n        Con[consoleTransport]\n        HTTP[httpTransport]\n    end\n\n    subgraph \"Consumers\"\n        Panel[Devtools Panel]\n        Server[Devtools Server]\n        Debug[Console]\n    end\n\n    Ext --> Queue\n    Queue --> Mem\n    Queue --> BC\n    Queue --> Con\n    Queue --> HTTP\n\n    Mem --> Panel\n    BC --> Panel\n    Con --> Debug\n    HTTP --> Server\n```\n\n## Transports\n\n| Transport | Use Case | Target |\n|-----------|----------|--------|\n| `memory()` | Same-process consumers (panels, testing) | In-memory subscribers |\n| `broadcastChannel(name?)` | Cross-tab communication | Browser tabs |\n| `consoleTransport()` | Debug logging | Console output |\n| `httpTransport({ url })` | Cross-process streaming | HTTP endpoint |\n\n## Event Types\n\n| Event | Trigger |\n|-------|---------|\n| `atom:resolve` | Before atom factory runs |\n| `atom:resolved` | After atom factory completes |\n| `flow:exec` | Before flow factory runs |\n| `flow:complete` | After flow factory completes |\n| `error` | On factory error |\n\n## Full API\n\nSee [`dist/index.d.mts`](./dist/index.d.mts) for complete type definitions.\n\nAll types available under the `Devtools` namespace:\n\n```typescript\nimport type { Devtools } from '@pumped-fn/lite-devtools'\n```\n\n## License\n\nMIT\n",
        "packages/lite-extension-otel/README.md": "# @pumped-fn/lite-extension-otel\n\nOpenTelemetry tracing extension for `@pumped-fn/lite` with self-contained provider management.\n\n## Installation\n\n```bash\npnpm add @pumped-fn/lite-extension-otel\n```\n\n## Usage\n\n```typescript\nimport { createScope, flow } from \"@pumped-fn/lite\"\nimport { otel, otelConfig } from \"@pumped-fn/lite-extension-otel\"\n\nconst scope = createScope({\n  extensions: [otel()]\n})\n\nscope.setTag(otelConfig.name, \"my-app\")\nscope.setTag(otelConfig.url, \"http://localhost:4318/v1/traces\")\nscope.setTag(otelConfig.type, \"http\")\n\nawait scope.ready\n\nconst myFlow = flow({\n  name: \"processOrder\",\n  factory: async (ctx) => {\n    return { orderId: \"123\" }\n  }\n})\n\nconst ctx = scope.createContext()\nawait ctx.exec({ flow: myFlow })\nawait ctx.close()\n```\n\n## Configuration Tags\n\n| Tag | Type | Default | Description |\n|-----|------|---------|-------------|\n| `otelConfig.name` | `string` | `\"default-app\"` | Service name for spans |\n| `otelConfig.url` | `string` | `\"http://localhost:4318/v1/traces\"` | OTLP collector URL |\n| `otelConfig.type` | `\"http\" \\| \"grpc\" \\| \"console\"` | `\"console\"` | Exporter type |\n| `otelConfig.captureResults` | `boolean` | `true` | Capture operation results in spans |\n| `otelConfig.redact` | `boolean` | `false` | Redact sensitive data (per-execution) |\n\n## Redacting Sensitive Data\n\nSet the redact tag on the execution context to prevent result capture:\n\n```typescript\nconst ctx = scope.createContext()\nctx.data.setTag(otelConfig.redact, true)\nawait ctx.exec({ flow: sensitiveFlow })\n```\n\n## Architecture\n\n```mermaid\nsequenceDiagram\n    participant Scope\n    participant Ext as otel Extension\n    participant ALS as AsyncLocalStorage\n    participant Provider as TracerProvider\n\n    Scope->>Ext: init(scope)\n    Ext->>Ext: Read config from tags\n    Ext->>Provider: Create provider + exporter\n\n    Scope->>Ext: wrapExec(next, target, ctx)\n    Ext->>ALS: getStore() → parent context\n    Ext->>Provider: startSpan(name, parent)\n    Ext->>ALS: run(newContext, next)\n    ALS-->>Ext: result\n    Ext->>Provider: span.end()\n\n    Scope->>Ext: dispose()\n    Ext->>Provider: shutdown()\n```\n",
        "packages/lite-hmr/README.md": "# @pumped-fn/lite-hmr\n\nVite HMR plugin for `@pumped-fn/lite` that preserves atom state across hot module reloads.\n\n**Dev only** · **Zero overhead in production** · **Vite plugin**\n\n## How It Works\n\n```mermaid\nsequenceDiagram\n    participant Dev as Developer\n    participant Vite\n    participant Plugin as pumpedHmr()\n    participant HMR as import.meta.hot.data\n    participant Scope\n\n    Note over Vite,Plugin: Build Time Transform\n\n    Dev->>Vite: Save file with atom()\n    Vite->>Plugin: transform(code)\n    Plugin->>Plugin: AST detect: const foo = atom({...})\n    Plugin-->>Vite: const foo = __hmr_register('key', atom({...}))\n\n    Note over HMR,Scope: Runtime (HMR Reload)\n\n    Vite->>HMR: Module reload\n    HMR->>HMR: Check registry for 'key'\n    alt First load\n        HMR->>HMR: Store new atom reference\n        HMR-->>Scope: New atom\n    else Reload\n        HMR-->>Scope: Cached atom (same reference)\n    end\n\n    Note over Scope: Cache hit - state preserved!\n```\n\n## Usage\n\n```typescript\n// vite.config.ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport { pumpedHmr } from '@pumped-fn/lite-hmr'\n\nexport default defineConfig({\n  plugins: [\n    pumpedHmr(),  // Add before other plugins\n    react()\n  ]\n})\n```\n\n## Transform Example\n\nThe plugin transforms named atom declarations at build time:\n\n```typescript\n// Your code\nconst configAtom = atom({ factory: () => loadConfig() })\n\n// Transformed (dev only)\nconst configAtom = __hmr_register('src/atoms.ts:1:18', atom({ factory: () => loadConfig() }))\n```\n\nThe `__hmr_register` helper stores atom references in `import.meta.hot.data`. On HMR reload, it returns the cached reference, preserving Scope cache hits.\n\n## What Gets Transformed\n\n| Pattern | Transformed |\n|---------|-------------|\n| `const foo = atom({...})` | Yes |\n| `let foo = atom({...})` | Yes |\n| `export const foo = atom({...})` | Yes |\n| `atoms.push(atom({...}))` | No (dynamic) |\n| `createAtom(() => atom({...}))` | No (nested) |\n\n## Options\n\n```typescript\npumpedHmr({\n  include: /\\.[jt]sx?$/,  // Files to transform (default)\n  exclude: /node_modules/ // Files to skip (default)\n})\n```\n\n## Production\n\nThe plugin is automatically disabled in production builds (`NODE_ENV=production`).\n\n## License\n\nMIT\n",
        "packages/lite-react/README.md": "# @pumped-fn/lite-react\n\nReact bindings for `@pumped-fn/lite` with Suspense and ErrorBoundary integration.\n\n**Zero dependencies** · **<2KB bundle** · **React 18+**\n\n## How It Works\n\n```mermaid\nsequenceDiagram\n    participant App\n    participant ScopeProvider\n    participant useAtom\n    participant Controller\n\n    App->>App: scope.resolve(atom)\n    App->>ScopeProvider: <ScopeProvider scope={scope}>\n\n    useAtom->>Controller: check ctrl.state\n    alt resolved\n        Controller-->>useAtom: value\n        useAtom->>Controller: subscribe to changes\n    else resolving\n        useAtom-->>App: throw Promise (Suspense)\n    else failed\n        useAtom-->>App: throw Error (ErrorBoundary)\n    else idle\n        useAtom-->>App: throw Error (not resolved)\n    end\n```\n\n## State Handling\n\n```mermaid\nflowchart TD\n    Hook[useAtom/useSelect]\n    Hook --> State{ctrl.state?}\n\n    State -->|idle| AutoResolve[Auto-resolve + Throw Promise]\n    State -->|resolving| Promise[Throw cached Promise]\n    State -->|resolved| Value[Return value]\n    State -->|failed| Stored[Throw stored error]\n\n    AutoResolve --> Suspense[Suspense catches]\n    Promise --> Suspense\n    Stored --> ErrorBoundary[ErrorBoundary catches]\n```\n\n| State | Hook Behavior |\n|-------|---------------|\n| `idle` | Auto-resolves and suspends — Suspense shows fallback |\n| `resolving` | Throws cached promise — Suspense shows fallback |\n| `resolved` | Returns value, subscribes to changes |\n| `failed` | Throws stored error — ErrorBoundary catches |\n\n## API\n\n### ScopeProvider\n\nProvides scope to component tree.\n\n```tsx\nimport { createScope } from '@pumped-fn/lite'\nimport { ScopeProvider } from '@pumped-fn/lite-react'\n\nconst scope = createScope()\nawait scope.resolve(userAtom)\n\n<ScopeProvider scope={scope}>\n  <App />\n</ScopeProvider>\n```\n\n### useScope\n\nAccess scope from context.\n\n```tsx\nconst scope = useScope()\nawait scope.resolve(someAtom)\n```\n\n### useController\n\nGet memoized controller for imperative operations.\n\n```tsx\nconst ctrl = useController(counterAtom)\nctrl.set(10)\nctrl.update(n => n + 1)\nctrl.invalidate()\n```\n\nWith `{ resolve: true }` option, triggers Suspense if atom not resolved:\n\n```tsx\n// Suspense ensures controller is resolved before render\nconst ctrl = useController(configAtom, { resolve: true })\nctrl.get() // safe - Suspense guarantees resolved state\n```\n\n### useAtom\n\nSubscribe to atom value with Suspense integration.\n\n```tsx\nfunction UserProfile() {\n  const user = useAtom(userAtom)\n  return <div>{user.name}</div>\n}\n\n// Wrap with Suspense + ErrorBoundary\n<ErrorBoundary fallback={<Error />}>\n  <Suspense fallback={<Loading />}>\n    <UserProfile />\n  </Suspense>\n</ErrorBoundary>\n```\n\n#### Non-Suspense Mode\n\nFor manual loading/error state handling without Suspense:\n\n```tsx\nfunction UserProfile() {\n  const { data, loading, error, controller } = useAtom(userAtom, { suspense: false })\n\n  if (loading) return <div>Loading...</div>\n  if (error) return <div>Error: {error.message}</div>\n  if (!data) return <div>Not loaded</div>\n\n  return (\n    <div>\n      <h1>{data.name}</h1>\n      <button onClick={() => controller.invalidate()}>Refresh</button>\n    </div>\n  )\n}\n```\n\nWith `{ resolve: true }`, auto-resolves on mount:\n\n```tsx\n// Starts resolution automatically when component mounts\nconst { data, loading, error } = useAtom(userAtom, { suspense: false, resolve: true })\n```\n\n| Option | Effect |\n|--------|--------|\n| `{ suspense: false }` | Returns state object, no auto-resolve |\n| `{ suspense: false, resolve: true }` | Returns state object, auto-resolves on mount |\n\n### useSelect\n\nFine-grained selection — only re-renders when selected value changes.\n\n```tsx\nconst name = useSelect(userAtom, user => user.name)\nconst count = useSelect(todosAtom, todos => todos.length, (a, b) => a === b)\n```\n\n## Invalidation\n\nWhen an atom is invalidated, hooks automatically suspend during re-resolution:\n\n```mermaid\nsequenceDiagram\n    participant Component\n    participant useAtom\n    participant Controller\n\n    Note over Controller: state = resolved\n    Component->>useAtom: render (value)\n\n    Note over Controller: ctrl.invalidate()\n    Controller->>Controller: state = resolving\n    useAtom-->>Component: throw Promise\n    Note over Component: Suspense fallback\n\n    Controller->>Controller: factory runs\n    Controller->>Controller: state = resolved\n    useAtom->>Component: re-render (new value)\n```\n\n## Testing\n\nUse presets for test isolation:\n\n```tsx\nimport { createScope, preset } from '@pumped-fn/lite'\nimport { ScopeProvider } from '@pumped-fn/lite-react'\n\nconst scope = createScope({\n  presets: [preset(userAtom, { name: 'Test User' })]\n})\nawait scope.resolve(userAtom)\n\nrender(\n  <ScopeProvider scope={scope}>\n    <UserProfile />\n  </ScopeProvider>\n)\n```\n\n## SSR\n\nSSR-compatible by design:\n\n- No side effects on import\n- Uses `useSyncExternalStore` with server snapshot\n- Scope passed as prop (no global state)\n\n```tsx\n// Server\nconst scope = createScope()\nawait scope.resolve(dataAtom)\nconst html = renderToString(<ScopeProvider scope={scope}><App /></ScopeProvider>)\n\n// Client\nconst clientScope = createScope({\n  presets: [preset(dataAtom, window.__DATA__)]\n})\nawait clientScope.resolve(dataAtom)\nhydrateRoot(root, <ScopeProvider scope={clientScope}><App /></ScopeProvider>)\n```\n\n## Full API\n\nSee [`dist/index.d.mts`](./dist/index.d.mts) for complete type definitions.\n\n## License\n\nMIT\n",
        "packages/lite/README.md": "# @pumped-fn/lite\n\nA lightweight effect system for TypeScript with managed lifecycles and minimal reactivity.\n\n**Zero dependencies** · **<17KB bundle** · **Full TypeScript support**\n\n## Documentation\n\n| Resource | Purpose |\n|----------|---------|\n| [PATTERNS.md](./PATTERNS.md) | Architecture patterns, flow design, deps resolution, cleanup strategies |\n| [dist/index.d.mts](./dist/index.d.mts) | API reference with TSDoc |\n\n## How It Works\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Scope\n    participant Atom\n\n    User->>Scope: createScope(options?)\n    Scope-->>User: scope\n    User->>Scope: await scope.ready\n\n    User->>Scope: scope.resolve(atom)\n    alt preset exists\n        Scope-->>User: preset value (factory skipped)\n    else no preset\n        Scope->>Atom: factory(ctx, deps)\n        Atom-->>Scope: value (cached)\n        Scope-->>User: value\n    end\n\n    User->>Scope: scope.dispose()\n    Scope->>Atom: run cleanups, release all\n```\n\n## Invalidation & Data Retention\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Controller\n    participant Atom\n    participant DataStore as ctx.data\n\n    Note over DataStore: persists across invalidations\n\n    User->>Controller: ctrl.invalidate()\n    Controller->>Atom: run cleanups (LIFO)\n    Note over DataStore: retained\n    Controller->>Atom: state = resolving\n    Controller->>Atom: factory(ctx, deps)\n    Note right of Atom: ctx.data still has previous values\n    Atom-->>Controller: new value\n    Controller->>Atom: state = resolved\n    Controller-->>User: listeners notified\n```\n\n## Flow Execution\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Scope\n    participant Context as ExecutionContext\n    participant Flow\n\n    User->>Scope: scope.createContext(options?)\n    Scope-->>User: context\n\n    User->>Context: ctx.exec({ flow, input, tags? })\n    Context->>Flow: parse(input)\n    Context->>Context: resolve flow deps\n    Context->>Flow: factory(ctx, deps)\n    Flow-->>Context: output\n    Context-->>User: output\n\n    User->>Context: ctx.close()\n    Context->>Context: run onClose cleanups (LIFO)\n```\n\n## Tag Inheritance (ADR-023)\n\nTags are auto-populated into `ctx.data` and resolved via `seekTag()`:\n\n```mermaid\nflowchart TD\n    subgraph Root[\"Root Context (ctx.data)\"]\n        S[\"scope.tags → auto-populated\"]\n        C[\"context.tags → auto-populated\"]\n        subgraph Child[\"Child Context (exec)\"]\n            E[\"exec.tags → auto-populated\"]\n            F[\"flow.tags → auto-populated\"]\n            D[\"ctx.data.setTag() → runtime\"]\n            subgraph Deps[\"tags.required(tag)\"]\n                R[\"seekTag() traverses: Child → Root\"]\n            end\n        end\n    end\n\n    Note[\"Nearest value wins. Propagates to all descendants.\"]\n```\n\n## Controller Reactivity\n\n```mermaid\nsequenceDiagram\n    participant User\n    participant Controller\n    participant Atom\n\n    User->>Controller: scope.controller(atom)\n    User->>Controller: ctrl.on('resolved', listener)\n    Controller-->>User: unsubscribe fn\n\n    Note over Controller: atom invalidated elsewhere\n\n    Controller->>Atom: state = resolving\n    Controller-->>User: 'resolving' listeners fire\n    Atom-->>Controller: new value\n    Controller->>Atom: state = resolved\n    Controller-->>User: 'resolved' listeners fire\n\n    User->>Controller: ctrl.get()\n    Controller-->>User: current value\n```\n\n## Primitives\n\n### Scope\n\nEntry point. Manages atom lifecycles, caching, and cleanup orchestration.\n\n- `createScope(options?)` — create with optional extensions, presets, tags\n- `scope.ready` — wait for extension initialization\n- `scope.resolve(atom)` — resolve and cache\n- `scope.controller(atom)` — get reactive handle\n- `scope.release(atom)` — run cleanups, remove from cache\n- `scope.dispose()` — release all, cleanup extensions\n- `scope.createContext(options?)` — create execution context for flows\n- `scope.select(atom, selector)` — fine-grained reactivity\n- `scope.flush()` — wait for pending invalidations\n\n### Atom\n\nLong-lived cached dependency with lifecycle.\n\n- Dependencies on other atoms via `deps`\n- `ctx.cleanup(fn)` — runs on invalidate and release (LIFO order)\n- `ctx.invalidate()` — schedule re-resolution\n- `ctx.data` — storage that survives invalidation (cleared on release)\n- `ctx.data.getOrSetTag(tag, defaultValue)` — initialize and retrieve in one call\n\n### Flow\n\nShort-lived operation with input/output.\n\n- `parse` — validate/transform input before factory (throws `ParseError` on failure)\n- `typed<T>()` — type marker without runtime parsing\n- Dependencies on atoms via `deps`\n- `ctx.input` — typed input access\n- `ctx.onClose(fn)` — cleanup when context closes\n- `ctx.exec({ flow, rawInput })` — pass unknown input when flow has `parse`\n\n### Tag\n\nContextual value passed through execution without explicit wiring.\n\n- Hierarchical lookup via `seekTag()` (ADR-023)\n- Auto-populates into `ctx.data`: scope → context → exec → flow\n- Registry tracks atom↔tag relationships (ADR-026)\n\n```mermaid\nflowchart TD\n    subgraph \"Tag Registry (ADR-026)\"\n        direction LR\n        A[\"atom({ tags: [...] })\"] -->|auto-register| R[\"WeakMap⟨Tag, WeakRef⟨Atom⟩[]⟩\"]\n        R -->|\"tag.atoms()\"| Q[\"query atoms by tag\"]\n        R -->|\"getAllTags()\"| T[\"query all tags\"]\n    end\n\n    subgraph \"Tag Inheritance (ADR-023)\"\n        S[scope.tags] --> D[ctx.data]\n        C[context.tags] --> D\n        E[exec.tags] --> D\n        F[flow.tags] --> D\n        D -->|\"seekTag()\"| V[\"nearest value wins\"]\n    end\n```\n\nMemory: `WeakRef` allows GC of unused atoms/tags. Cleanup on query.\n\n### Controller\n\nReactive handle for observing and controlling atom state.\n\n- `ctrl.state` — sync access: `'idle' | 'resolving' | 'resolved' | 'failed'`\n- `ctrl.get()` — sync value access (throws if not resolved, returns stale during resolving)\n- `ctrl.resolve()` — async resolution\n- `ctrl.invalidate()` — trigger re-resolution (runs factory)\n- `ctrl.set(value)` — replace value directly (skips factory)\n- `ctrl.update(fn)` — transform value: `fn(currentValue) → newValue` (skips factory)\n- `ctrl.on(event, listener)` — subscribe to `'resolved' | 'resolving' | '*'`\n- Use `controller(atom)` in deps for reactive dependency (unresolved, you control timing)\n- Use `controller(atom, { resolve: true })` to auto-resolve before passing to factory\n- Use `scope.controller(atom, { resolve: true })` for same behavior outside deps\n\n### Preset\n\nValue injection for testing. Bypasses factory entirely.\n\n- `preset(atom, value)` — inject direct value\n- `preset(atom, otherAtom)` — redirect to another atom's factory\n- Pass via `createScope({ presets: [...] })`\n\n### Extension\n\nAOP-style middleware for cross-cutting concerns.\n\n- `init(scope)` — setup when scope created\n- `wrapResolve(next, atom, scope)` — intercept atom resolution\n- `wrapExec(next, target, ctx)` — intercept flow execution\n- `dispose(scope)` — cleanup when scope disposed\n- Pass via `createScope({ extensions: [...] })`\n\n## Patterns\n\n### Eager Resolution via Tag Registry\n\nUse tags to mark atoms for eager resolution without hardcoding atom references:\n\n```mermaid\nflowchart LR\n    subgraph \"Define\"\n        T[eagerTag] --> A1[atomA]\n        T --> A2[atomB]\n        T --> A3[atomC]\n    end\n\n    subgraph \"Extension init()\"\n        E[\"eagerTag.atoms()\"] --> R[\"resolve all marked atoms\"]\n    end\n\n    A1 & A2 & A3 -.->|\"auto-tracked\"| E\n```\n\n### Extension Discovery via getAllTags()\n\nExtensions can discover and process all tags at runtime:\n\n```mermaid\nflowchart LR\n    subgraph \"Runtime\"\n        G[\"getAllTags()\"] --> F{\"filter by criteria\"}\n        F --> P[\"process matching tags\"]\n        P --> A[\"tag.atoms() for each\"]\n    end\n```\n\nUse cases: metrics collection, debugging, documentation generation.\n\n## Types\n\nAll types available under the `Lite` namespace:\n\n```typescript\nimport type { Lite } from '@pumped-fn/lite'\n```\n\n## Edge Cases\n\n### Controller.set() / update()\n\n| State | Behavior |\n|-------|----------|\n| `idle` | Throws \"Atom not resolved\" |\n| `resolving` | Queues, applies after resolution completes |\n| `resolved` | Queues normally |\n| `failed` | Throws the stored error |\n\nBoth run cleanups before applying the new value.\n\n### ContextData.getTag()\n\n`ctx.data.getTag(tag)` always returns `T | undefined` (Map-like semantics). Use `getOrSetTag(tag)` when you need the tag's default value.\n\n```typescript\nconst countTag = tag<number>({ label: 'count', default: 0 })\n\nctx.data.getTag(countTag)       // undefined (not stored)\nctx.data.getOrSetTag(countTag)  // 0 (uses default, now stored)\nctx.data.getTag(countTag)       // 0 (now stored)\n```\n\n### Hierarchical Data Lookup with seekTag() (ADR-023)\n\nTag dependencies (`tags.required()`, `tags.optional()`, `tags.all()`) use `seekTag()` internally to traverse the ExecutionContext parent chain. Tags from all sources are auto-populated into `ctx.data`:\n\n```typescript\nconst requestIdTag = tag<string>({ label: 'requestId' })\n\nconst middleware = flow({\n  factory: async (ctx) => {\n    ctx.data.setTag(requestIdTag, 'req-123')\n    return ctx.exec({ flow: handler })\n  }\n})\n\nconst handler = flow({\n  deps: { reqId: tags.required(requestIdTag) },\n  factory: (ctx, { reqId }) => {\n    // reqId === 'req-123' (found via seekTag from parent)\n  }\n})\n```\n\n| Method | Scope | Use Case |\n|--------|-------|----------|\n| `getTag(tag)` | Local only | Per-exec isolated data |\n| `seekTag(tag)` | Local → parent → root | Cross-cutting concerns |\n| `setTag(tag, v)` | Local only | Always writes to current context |\n| `tags.required(tag)` | Uses `seekTag()` | Dependency injection |\n\n### Resolution Timing\n\nTag dependencies resolve **once** at factory start. Direct `seekTag()` calls reflect runtime changes:\n\n```typescript\nconst handler = flow({\n  deps: { userId: tags.required(userIdTag) },\n  factory: (ctx, { userId }) => {\n    ctx.data.setTag(userIdTag, 'changed')\n\n    console.log(userId)                      // Original (stable)\n    console.log(ctx.data.seekTag(userIdTag)) // 'changed' (dynamic)\n  }\n})\n```\n\n| Access | Resolution | Runtime Changes |\n|--------|------------|-----------------|\n| `deps: { x: tags.required(tag) }` | Once at start | Stable snapshot |\n| `ctx.data.seekTag(tag)` | Each call | Sees changes |\n\n## Automatic Garbage Collection\n\nAtoms are automatically released when they have no subscribers, preventing memory leaks in long-running applications.\n\n### How It Works\n\n```mermaid\nsequenceDiagram\n    participant Component\n    participant Controller\n    participant Scope\n    participant Timer\n\n    Component->>Controller: ctrl.on('resolved', callback)\n    Note over Controller: subscriberCount = 1\n    \n    Component->>Controller: unsubscribe()\n    Note over Controller: subscriberCount = 0\n    Controller->>Timer: schedule GC (3000ms)\n    \n    alt Resubscribe before timeout\n        Component->>Controller: ctrl.on('resolved', callback)\n        Controller->>Timer: cancel GC\n        Note over Controller: Atom stays alive\n    else Timeout fires\n        Timer->>Scope: release(atom)\n        Note over Scope: Cleanups run, cache cleared\n        Scope->>Scope: Check dependencies for cascading GC\n    end\n```\n\n### Configuration\n\n```typescript\n// Default: GC enabled with 3000ms grace period\nconst scope = createScope()\n\n// Custom grace period (useful for tests)\nconst scope = createScope({\n  gc: { graceMs: 100 }\n})\n\n// Disable GC entirely (preserves pre-1.11 behavior)\nconst scope = createScope({\n  gc: { enabled: false }\n})\n```\n\n### Opt-Out with keepAlive\n\nMark atoms that should never be automatically released:\n\n```typescript\nconst configAtom = atom({\n  factory: () => loadConfig(),\n  keepAlive: true  // Never auto-released\n})\n```\n\n### Cascading Dependency Protection\n\nDependencies are protected while dependents are mounted:\n\n```\nconfigAtom (keepAlive: true)\n    ↑\ndbAtom ←── userServiceAtom ←── [Component subscribes]\n```\n\n- `dbAtom` won't be GC'd while `userServiceAtom` is mounted\n- When component unmounts, `userServiceAtom` is GC'd after grace period\n- Then `dbAtom` becomes eligible for GC (no dependents)\n- `configAtom` stays alive due to `keepAlive: true`\n\n### React Strict Mode Compatibility\n\nThe 3000ms default grace period handles React's double-mount behavior:\n\n```\nMount (render 1):     subscribe    → count=1\nUnmount (cleanup 1):  unsubscribe  → count=0 → schedule GC\nMount (render 2):     subscribe    → count=1 → CANCEL GC\n```\n\nThe second mount always happens before the GC timer fires.\n\n### API Summary\n\n| Option | Default | Description |\n|--------|---------|-------------|\n| `gc.enabled` | `true` | Enable/disable automatic GC |\n| `gc.graceMs` | `3000` | Delay before releasing (ms) |\n| `atom.keepAlive` | `false` | Prevent auto-release for specific atoms |\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "pumped-design",
          "source": "./",
          "description": "Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies",
          "version": "1.4.0",
          "author": {
            "name": "lagz0ne",
            "email": "duke@silentium.io"
          },
          "homepage": "https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design",
          "repository": "https://github.com/pumped-fn/pumped-fn",
          "license": "MIT",
          "keywords": [
            "typescript",
            "backend-architecture",
            "application-design",
            "testing-strategy",
            "code-quality",
            "pumped-fn",
            "design-patterns",
            "resource-management",
            "flow-orchestration",
            "best-practices"
          ],
          "category": "code-quality",
          "tags": [
            "typescript",
            "backend-architecture",
            "application-design",
            "testing-strategy",
            "code-quality",
            "pumped-fn",
            "design-patterns"
          ],
          "categories": [
            "application-design",
            "backend-architecture",
            "best-practices",
            "code-quality",
            "design-patterns",
            "flow-orchestration",
            "pumped-fn",
            "resource-management",
            "testing-strategy",
            "typescript"
          ],
          "install_commands": [
            "/plugin marketplace add pumped-fn/pumped-fn",
            "/plugin install pumped-design@pumped-fn-marketplace"
          ]
        }
      ]
    }
  ]
}