{
  "author": {
    "id": "pumped-fn",
    "display_name": "pumped-fn",
    "avatar_url": "https://avatars.githubusercontent.com/u/199755659?v=4"
  },
  "marketplaces": [
    {
      "name": "pumped-fn-marketplace",
      "version": null,
      "description": "Official marketplace for pumped-fn Claude Code plugins",
      "repo_full_name": "pumped-fn/pumped-fn",
      "repo_url": "https://github.com/pumped-fn/pumped-fn",
      "repo_description": "Monorepository of @pumped-fn",
      "signals": {
        "stars": 5,
        "forks": 3,
        "pushed_at": "2026-02-16T11:04:55Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"pumped-fn-marketplace\",\n  \"owner\": {\n    \"name\": \"lagz0ne\",\n    \"email\": \"duke@silentium.io\"\n  },\n  \"metadata\": {\n    \"description\": \"Official marketplace for pumped-fn Claude Code plugins\",\n    \"version\": \"1.4.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"pumped-design\",\n      \"source\": \"./\",\n      \"description\": \"Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies\",\n      \"version\": \"1.4.0\",\n      \"author\": {\n        \"name\": \"lagz0ne\",\n        \"email\": \"duke@silentium.io\"\n      },\n      \"homepage\": \"https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design\",\n      \"repository\": \"https://github.com/pumped-fn/pumped-fn\",\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"typescript\",\n        \"backend-architecture\",\n        \"application-design\",\n        \"testing-strategy\",\n        \"code-quality\",\n        \"pumped-fn\",\n        \"design-patterns\",\n        \"resource-management\",\n        \"flow-orchestration\",\n        \"best-practices\"\n      ],\n      \"category\": \"code-quality\",\n      \"tags\": [\n        \"typescript\",\n        \"backend-architecture\",\n        \"application-design\",\n        \"testing-strategy\",\n        \"code-quality\",\n        \"pumped-fn\",\n        \"design-patterns\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"pumped-design\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies\",\n  \"author\": {\n    \"name\": \"lagz0ne\",\n    \"email\": \"duke@silentium.io\"\n  },\n  \"repository\": \"https://github.com/pumped-fn/pumped-fn\",\n  \"homepage\": \"https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design\",\n  \"skills\": [\n    \"./.claude/skills/pumped-design\"\n  ]\n}\n",
        "README.md": "# pumped-fn\n\n[![npm version](https://img.shields.io/npm/v/@pumped-fn/lite)](https://www.npmjs.com/package/@pumped-fn/lite)\n\nA lightweight effect system for TypeScript with managed lifecycles and minimal reactivity.\n\n## What is an Effect System?\n\nAn effect system manages **how** and **when** computations run:\n- **Resource lifecycle** - acquire, use, release\n- **Computation ordering** - dependency resolution\n- **Side effect isolation** - controlled execution boundaries\n\n## Install\n\n```bash\nnpm install @pumped-fn/lite\n```\n\n## Core Concepts\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                         Scope                               │\n│  (long-lived execution boundary)                            │\n│                                                             │\n│   ┌─────────┐      ┌─────────┐      ┌─────────┐            │\n│   │  Atom   │ ──── │  Atom   │ ──── │  Atom   │            │\n│   │ (effect)│      │ (effect)│      │ (effect)│            │\n│   └─────────┘      └─────────┘      └─────────┘            │\n│        │                                  │                 │\n│        └──────────────┬───────────────────┘                 │\n│                       ▼                                     │\n│   ┌─────────────────────────────────────────────────────┐   │\n│   │              ExecutionContext                       │   │\n│   │  (short-lived operation with input, tags, cleanup)  │   │\n│   └─────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────┘\n```\n\n| Concept | Purpose |\n|---------|---------|\n| **Scope** | Long-lived boundary that manages atom lifecycles |\n| **Atom** | A managed effect with lifecycle (create, cache, cleanup, recreate) |\n| **ExecutionContext** | Short-lived context for running operations |\n| **Controller** | Handle for observing and controlling an atom's state |\n| **Tag** | Contextual value passed through execution |\n\n## Effect Lifecycle\n\n```mermaid\nstateDiagram-v2\n    [*] --> idle\n    idle --> resolving: resolve()\n    resolving --> resolved: success\n    resolving --> failed: error\n    resolved --> resolving: invalidate()\n    failed --> resolving: invalidate()\n    resolved --> idle: release()\n    failed --> idle: release()\n```\n\n## API Reference\n\n| Function | Description |\n|----------|-------------|\n| `createScope(options?)` | Create execution boundary |\n| `atom(config)` | Define managed effect (long-lived) |\n| `flow(config)` | Define operation template |\n| `tag(config)` | Define contextual value |\n| `controller(atom)` | Wrap atom for deferred resolution |\n| `preset(atom, value)` | Override atom value in scope |\n\n## Example: Snake Game\n\n```typescript\nimport { atom, tag, tags, controller, createScope } from '@pumped-fn/lite'\n\ntype Point = { x: number; y: number }\ntype Dir = 'up' | 'down' | 'left' | 'right'\ntype GameState = { snake: Point[]; food: Point; dir: Dir; score: number; hi: number; dead: boolean; size: number }\n\nconst gridSize = tag<number>({ label: 'gridSize', default: 20 })\nconst tickMs = tag<number>({ label: 'tickMs', default: 100 })\nconst stateTag = tag<GameState>({ label: 'state' })\n\nconst gameAtom = atom({\n  deps: { size: tags.required(gridSize) },\n  factory: (ctx, { size }): GameState => {\n    let state = ctx.data.get(stateTag)  // GameState | undefined - type safe!\n    if (!state) {\n      state = {\n        snake: [{ x: Math.floor(size/2), y: Math.floor(size/2) }],\n        food: { x: Math.floor(size/4), y: Math.floor(size/4) },\n        dir: 'right', score: 0, hi: 0, dead: false, size\n      }\n      ctx.data.set(stateTag, state)  // Type checked\n    }\n    return state\n  }\n})\n\nconst tickerAtom = atom({\n  deps: { ms: tags.required(tickMs), game: controller(gameAtom) },\n  factory: (ctx, { ms, game }) => {\n    const id = setInterval(() => {\n      const state = game.get()\n      if (!state.dead) {\n        tick(state)\n        game.invalidate()\n      }\n    }, ms)\n    ctx.cleanup(() => clearInterval(id))\n  }\n})\n\nfunction tick(s: GameState) { /* move snake, check collisions, update score */ }\n\nasync function createSnakeGame(size = 20, tickInterval = 100) {\n  const scope = createScope({ tags: [gridSize(size), tickMs(tickInterval)] })\n  const gameCtrl = scope.controller(gameAtom)\n  const tickerCtrl = scope.controller(tickerAtom)\n  await gameCtrl.resolve()\n\n  const turn = (dir: Dir) => {\n    const state = gameCtrl.get()\n    const opposite: Record<Dir, Dir> = { up: 'down', down: 'up', left: 'right', right: 'left' }\n    if (opposite[dir] !== state.dir && !state.dead) state.dir = dir\n  }\n\n  return {\n    state: gameCtrl,\n    up: () => turn('up'),\n    down: () => turn('down'),\n    left: () => turn('left'),\n    right: () => turn('right'),\n    step: () => { tick(gameCtrl.get()); gameCtrl.invalidate() },\n    start: () => tickerCtrl.resolve(),\n    pause: () => tickerCtrl.release(),\n    dispose: () => scope.dispose()\n  }\n}\n\nconst game = await createSnakeGame(15, 100)\ngame.state.on('resolved', () => render(game.state.get()))\nawait game.start()\ngame.down()\n```\n\n**What's demonstrated:**\n- **`tag`** - `gridSize`, `tickMs` configure game per-instance; `stateTag` provides typed storage key\n- **`ctx.data`** - State persists across `invalidate()` calls with type-safe tag-based API\n- **`controller()`** - Ticker gets `Controller<GameState>`, calls `.get()` and `.invalidate()`\n- **`invalidate()`** - Re-runs factory, notifies subscribers\n- **`cleanup()`** - Ticker interval cleared on `pause()`\n- **`ctrl.on('resolved')`** - UI subscribes to state changes\n\n## Design Principles\n\n1. **Minimal API** - Every export is expensive to learn\n2. **Zero dependencies** - No runtime dependencies\n3. **Explicit lifecycle** - No magic, clear state transitions\n4. **Composable** - Effects compose through deps\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "pumped-design",
          "source": "./",
          "description": "Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies",
          "version": "1.4.0",
          "author": {
            "name": "lagz0ne",
            "email": "duke@silentium.io"
          },
          "homepage": "https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design",
          "repository": "https://github.com/pumped-fn/pumped-fn",
          "license": "MIT",
          "keywords": [
            "typescript",
            "backend-architecture",
            "application-design",
            "testing-strategy",
            "code-quality",
            "pumped-fn",
            "design-patterns",
            "resource-management",
            "flow-orchestration",
            "best-practices"
          ],
          "category": "code-quality",
          "tags": [
            "typescript",
            "backend-architecture",
            "application-design",
            "testing-strategy",
            "code-quality",
            "pumped-fn",
            "design-patterns"
          ],
          "categories": [
            "application-design",
            "backend-architecture",
            "best-practices",
            "code-quality",
            "design-patterns",
            "flow-orchestration",
            "pumped-fn",
            "resource-management",
            "testing-strategy",
            "typescript"
          ],
          "install_commands": [
            "/plugin marketplace add pumped-fn/pumped-fn",
            "/plugin install pumped-design@pumped-fn-marketplace"
          ]
        }
      ]
    },
    {
      "name": "pumped-go",
      "version": null,
      "description": "Claude Code plugins for the pumped-go dependency injection library",
      "repo_full_name": "pumped-fn/pumped-go",
      "repo_url": "https://github.com/pumped-fn/pumped-go",
      "repo_description": "Carry pumped-fn concept to golang",
      "signals": {
        "stars": 0,
        "forks": 1,
        "pushed_at": "2026-02-06T07:52:01Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"pumped-go\",\n  \"owner\": {\n    \"name\": \"pumped-fn\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugins for the pumped-go dependency injection library\",\n    \"version\": \"1.0.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"pumped-go\",\n      \"source\": \"./claude-skill\",\n      \"description\": \"Comprehensive Go guidance for pumped-go DI library - pattern enforcement, lifecycle management, testing support\",\n      \"version\": \"1.0.0\",\n      \"author\": {\n        \"name\": \"pumped-fn\"\n      },\n      \"homepage\": \"https://github.com/pumped-fn/pumped-go\",\n      \"repository\": \"https://github.com/pumped-fn/pumped-go\",\n      \"license\": \"MIT\",\n      \"keywords\": [\"go\", \"golang\", \"dependency-injection\", \"reactive-programming\", \"lifecycle-management\"],\n      \"category\": \"frameworks\"\n    }\n  ]\n}\n",
        "README.md": "# Pumped Go\n\n[![CI](https://github.com/pumped-fn/pumped-go/actions/workflows/ci.yml/badge.svg?branch=main)](https://github.com/pumped-fn/pumped-go/actions/workflows/ci.yml)\n[![GoDoc](https://pkg.go.dev/badge/github.com/pumped-fn/pumped-go.svg)](https://pkg.go.dev/github.com/pumped-fn/pumped-go)\n[![codecov](https://codecov.io/gh/pumped-fn/pumped-go/graph/badge.svg?token=CODECOV_TOKEN)](https://codecov.io/gh/pumped-fn/pumped-go)\n\nA powerful dependency injection and reactive execution library for Go, inspired by pumped-fn.\n\n## Features\n\n- **Graph-based DI**: Declare dependencies explicitly, resolve lazily\n- **Reactive Updates**: Automatic propagation of changes through dependency graph\n- **Flow Execution**: Short-span operations with execution context trees and tracing\n- **Type-safe**: Full generic support with minimal casting\n- **Controller Pattern**: Fine-grained lifecycle control (get, update, reload, release)\n- **Tags**: Type-safe metadata system for executors, scopes, and flows\n- **Extensions**: Powerful middleware system for cross-cutting concerns\n- **No IDs Required**: Executors are their own keys\n\n## Installation\n\n```bash\ngo get github.com/pumped-fn/pumped-go\n```\n\n## Quick Example\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    pumped \"github.com/pumped-fn/pumped-go\"\n)\n\nfunc main() {\n    scope := pumped.NewScope()\n\n    // Define executors\n    counter := pumped.Provide(func(ctx *pumped.ResolveCtx) (int, error) {\n        return 0, nil\n    })\n\n    doubled := pumped.Derive1(\n        pumped.Reactive(counter),\n        func(ctx *pumped.ResolveCtx, counterCtrl *pumped.Controller[int]) (int, error) {\n            count, _ := counterCtrl.Get()\n            return count * 2, nil\n        },\n    )\n\n    // Use accessors\n    doubledAcc := scope.Accessor(doubled)\n    val, _ := doubledAcc.Get()\n    fmt.Printf(\"Result: %d\\n\", val) // 0\n\n    // Update triggers reactivity\n    counterAcc := scope.Accessor(counter)\n    counterAcc.Update(5)\n\n    val, _ = doubledAcc.Get()\n    fmt.Printf(\"Result: %d\\n\", val) // 10\n}\n```\n\n## Concepts\n\n### Executors\n\nExecutors are units of computation with explicit dependencies:\n\n```go\n// No dependencies\nconfig := pumped.Provide(func(ctx *pumped.ResolveCtx) (string, error) {\n    return \"config-value\", nil\n})\n\n// With dependencies - receive controllers\nservice := pumped.Derive1(\n    pumped.Static(config),\n    func(ctx *pumped.ResolveCtx, configCtrl *pumped.Controller[string]) (*Service, error) {\n        cfg, _ := configCtrl.Get()\n        return &Service{config: cfg}, nil\n    },\n)\n```\n\n### Dependency Modes\n\n- **Static**: Resolve once, cache forever (default)\n- **Reactive**: Invalidate when dependency changes\n\n```go\n// This executor re-resolves when counter changes\nreactive := pumped.Derive1(\n    pumped.Reactive(counter),\n    func(ctx *pumped.ResolveCtx, ctrl *pumped.Controller[int]) (int, error) {\n        // ...\n    },\n)\n\n// This executor doesn't re-resolve\nstatic := pumped.Derive1(\n    pumped.Static(counter),\n    func(ctx *pumped.ResolveCtx, ctrl *pumped.Controller[int]) (int, error) {\n        // ...\n    },\n)\n```\n\n### Controllers\n\nAll dependencies are passed as controllers for maximum flexibility:\n\n```go\nbutton := pumped.Derive1(\n    pumped.Static(counter),\n    func(ctx *pumped.ResolveCtx, counterCtrl *pumped.Controller[int]) (*Button, error) {\n        return &Button{\n            onClick: func() error {\n                current, _ := counterCtrl.Get()      // Get value\n                return counterCtrl.Update(current + 1) // Update\n            },\n        }, nil\n    },\n)\n```\n\n### Tags\n\nType-safe metadata for executors and scopes:\n\n```go\nversionTag := pumped.NewTag[string](\"version\")\n\nexecutor := pumped.Provide(\n    func(ctx *pumped.ResolveCtx) (int, error) { return 42, nil },\n    pumped.WithTag(versionTag, \"1.0.0\"),\n)\n\nversion, _ := versionTag.Get(executor)\n```\n\n### Extensions\n\nPowerful middleware for cross-cutting concerns:\n\n```go\nlogging := pumped.NewLoggingExtension()\nmetrics := pumped.NewMetricsExtension()\n\nscope := pumped.NewScope(\n    pumped.WithExtension(logging),\n    pumped.WithExtension(metrics),\n)\n```\n\n### Flows\n\nFlows are short-span executable units with context trees and tracing:\n\n```go\n// Define long-running resources as executors\ndb := pumped.Derive1(config, func(ctx *pumped.ResolveCtx, cfg *pumped.Controller[*Config]) (*DB, error) {\n    return NewDB(cfg.Get().DBHost)\n})\n\n// Define short-span operations as flows\nfetchUser := pumped.Flow1(db,\n    func(execCtx *pumped.ExecutionCtx, db *pumped.Controller[*DB]) (*User, error) {\n        database, _ := db.Get()\n        return database.QueryUser(\"123\")\n    },\n    pumped.WithFlowTag(pumped.FlowName(), \"fetchUser\"),\n)\n\n// Execute flow with context\nresult, execNode, err := pumped.Exec(scope, context.Background(), fetchUser)\n\n// Query execution tree\ntree := scope.GetExecutionTree()\nroots := tree.GetRoots()\nfor _, root := range roots {\n    children := tree.GetChildren(root.ID)\n    // Visualize execution tree\n}\n```\n\n**Sub-flow execution:**\n\n```go\nparentFlow := pumped.Flow1(db, func(execCtx *pumped.ExecutionCtx, db *pumped.Controller[*DB]) (string, error) {\n    // Execute sub-flows\n    user, userCtx, _ := pumped.Exec1(execCtx, fetchUserFlow)\n    orders, _, _ := pumped.Exec1(userCtx, fetchOrdersFlow)\n\n    // Child contexts can read parent data via tags\n    userID, _ := execCtx.Lookup(customTag)\n\n    return fmt.Sprintf(\"User %s has %d orders\", user, len(orders)), nil\n})\n```\n\n**Tag-based data flow:**\n\n```go\n// Set data in parent flow\nexecCtx.Set(pumped.Input(), \"user-123\")\n\n// Child flows can read upward (but not write)\nuserID, _ := childCtx.GetFromParent(pumped.Input())\nuserID, _ := childCtx.Lookup(pumped.Input()) // checks self, then parents, then scope\n```\n\n**Execution lifecycle:**\n\n- Flows execute with `ExecutionCtx` (execution-specific context tree)\n- Executors resolve with `ResolveCtx` (scope-level resolution)\n- Extensions hook into flow lifecycle: `OnFlowStart`, `OnFlowEnd`, `OnFlowPanic`\n- Execution tree automatically tracks all executions with tags\n\n## Development\n\nThis project uses [Devbox](https://www.jetify.com/devbox/) for reproducible development environments.\n\n### Quick Start\n\n1. **Install Devbox:**\n   ```bash\n   curl -fsSL https://get.jetify.com/devbox | bash\n   ```\n\n2. **Clone and setup:**\n   ```bash\n   git clone https://github.com/pumped-fn/pumped-go.git\n   cd pumped-go\n   devbox shell\n   devbox run setup\n   ```\n\n### Available Commands\n\n```bash\n# Setup & Dependencies\ndevbox run setup           # Initial setup\ndevbox run deps            # Download dependencies\ndevbox run tidy            # Tidy go.mod\n\n# Testing\ndevbox run test            # Run tests\ndevbox run test-coverage   # Run with coverage\ndevbox run coverage        # View coverage report\ndevbox run integration-test # Integration tests\ndevbox run benchmark       # Run benchmarks\n\n# Code Quality\ndevbox run lint            # Run linters\ndevbox run lint-fix        # Auto-fix issues\ndevbox run fmt             # Format code\ndevbox run vet             # Run go vet\n\n# Building\ndevbox run build           # Build library\ndevbox run build-examples  # Build examples\n\n# Security\ndevbox run security        # Run gosec\ndevbox run vulnerability-check # Check vulnerabilities\n\n# CI/CD\ndevbox run ci              # Full CI pipeline\ndevbox run pre-commit      # Pre-commit checks\ndevbox run release-snapshot # Test release locally\ndevbox run release-test    # Validate release config\n\n# Maintenance\ndevbox run clean           # Clean artifacts\ndevbox run all             # Run everything\n```\n\n### Development Workflow\n\n1. Make your changes\n2. Run tests: `devbox run test`\n3. Run linters: `devbox run lint`\n4. Fix any issues: `devbox run lint-fix`\n5. Run full CI: `devbox run ci`\n6. Commit with conventional commits\n\n### Pre-commit Checks\n\nBefore every commit:\n```bash\ndevbox run pre-commit\n```\n\n## CI/CD Pipeline\n\n### Overview\n\nOur CI/CD pipeline uses:\n- **GitHub Actions** for automation\n- **Devbox** for reproducible development environments\n- **GoReleaser** for release automation\n- **Codecov** for coverage reporting\n- **cosign** for artifact signing\n\n### Workflows\n\n#### CI Workflow\n\n**Trigger:** Push to `main`/`develop` branches or pull requests\n\n**Jobs:**\n- **Lint**: Runs golangci-lint with comprehensive linter configuration\n- **Test**: Matrix strategy (Ubuntu and macOS) with race detection and coverage\n- **Build**: Validates library and example builds\n- **Integration**: Runs integration tests with `-tags=integration`\n- **Security**: Runs gosec security scanner\n\n#### Release Workflow\n\n**Trigger:** Push of version tag (`v*.*.*`)\n\n**Features:**\n- Runs full test suite\n- Builds multi-platform binaries for examples\n- Generates changelog from conventional commits\n- Creates checksums\n- Signs artifacts with cosign\n- Creates GitHub release\n- Updates Go proxy\n\n### Linting Configuration\n\nEnabled linters include:\n- errcheck, gosimple, govet, ineffassign, staticcheck, unused\n- gofmt, goimports, misspell, revive, gosec, gocritic\n- And more...\n\nTimeout: 5 minutes with error severity by default.\n\n### Release Process\n\n#### Semantic Versioning\n\nWe follow [Semantic Versioning](https://semver.org/):\n- **MAJOR**: Breaking changes\n- **MINOR**: New features (backward compatible)\n- **PATCH**: Bug fixes\n\n#### Conventional Commits\n\nWe use conventional commits for automatic changelog generation:\n\n```\nfeat: Add new feature (MINOR bump)\nfix: Fix bug (PATCH bump)\nperf: Performance improvement\ndocs: Documentation changes\ntest: Test changes\nci: CI/CD changes\nchore: Maintenance\nrefactor: Code refactoring\n\nBREAKING CHANGE: (MAJOR bump)\n```\n\n#### Creating a Release\n\n1. **Ensure CI passes:** `devbox run ci`\n2. **Test release locally:** `devbox run release-snapshot`\n3. **Update version references if needed**\n4. **Commit and push:**\n   ```bash\n   git add .\n   git commit -m \"chore: prepare for v0.x.0 release\"\n   git push\n   ```\n5. **Create and push tag:**\n   ```bash\n   git tag -a v0.x.0 -m \"Release v0.x.0\"\n   git push origin v0.x.0\n   ```\n\nGitHub Actions will automatically handle the rest.\n\n## Examples\n\nSee [examples/](./examples/) for complete working examples:\n\n- `basic/` - Executor fundamentals with reactivity\n- `health-monitor/` - Production-ready health monitoring service\n- `order-processing/` - Flow execution with context trees\n- `http-api/` - REST API with dependency injection\n- `cli-tasks/` - CLI application with services\n\n## Claude Code Skill\n\nThis project includes a [Claude Code](https://docs.anthropic.com/en/docs/claude-code) skill that provides automated guidance for writing pumped-go code — pattern enforcement, lifecycle management, testing support, and more.\n\n### Installing the Skill\n\nIn Claude Code, run:\n\n```bash\n/plugin marketplace add pumped-fn/pumped-go\n/plugin install pumped-go@pumped-fn-pumped-go\n```\n\nOr from the CLI:\n\n```bash\nclaude plugin marketplace add pumped-fn/pumped-go\nclaude plugin install pumped-go@pumped-fn-pumped-go\n```\n\nOnce installed, the skill **auto-activates** when your `go.mod` imports `github.com/pumped-fn/pumped-go`. No manual activation needed.\n\n### What It Provides\n\n- **Decision tree** for choosing Executors vs Flows vs plain functions\n- **Pattern enforcement** (package-level vars, controller usage, error handling)\n- **Production lifecycle** guidance (cleanup, graceful shutdown, signal handling)\n- **Testing strategies** with `WithPreset()` mocks\n- **Troubleshooting** for common issues\n\nSee [`claude-skill/README.md`](./claude-skill/README.md) for full details.\n\n## Contributing\n\n1. Fork the repository\n2. Create a feature branch: `git checkout -b feature/amazing-feature`\n3. Follow the development workflow above\n4. Commit with conventional commits\n5. Push to your fork: `git push origin feature/amazing-feature`\n6. Open a Pull Request\n\n## License\n\nMIT\n",
        "claude-skill/README.md": "# Pumped-Go Claude Code Skill\n\nAuto-activating Claude Code skill for building production-ready Go applications with [pumped-go](https://github.com/pumped-fn/pumped-go).\n\n## Overview\n\nThis skill provides comprehensive guidance for using pumped-go, covering:\n\n- **Architecture Patterns** - When to use Executors vs Flows vs plain functions\n- **Package-Level Executor Pattern** - Go-idiomatic dependency declaration\n- **Lifecycle Management** - Proper cleanup, graceful shutdown, resource management\n- **Testing Strategies** - Unit and integration testing with mocks\n- **Production Readiness** - Error handling, goroutine safety, signal handling\n- **Common Patterns** - Repository, service layer, handler injection, background workers\n\n## Auto-Activation\n\nThe skill automatically activates when your `go.mod` contains:\n\n```go\nrequire github.com/pumped-fn/pumped-go v0.x.x\n```\n\nNo manual activation needed! Claude will automatically apply pumped-go best practices when working with your code.\n\n## What This Skill Covers\n\n### 1. Decision Tree\nQuick guidance on choosing the right pattern:\n- Long-lived resources → **Executors** (package-level vars)\n- Short-span operations → **Flows** (business logic with tracing)\n- Pure transformations → **Plain functions**\n\n### 2. Executors (Long-Lived Resources)\n- Package-level `var` pattern\n- `Provide` (no deps) vs `Derive1-N` (with deps)\n- Controller-based dependency access\n- Error handling at every step\n- Lifecycle management with `OnCleanup()`\n- Static vs Reactive dependencies\n\n### 3. Flows (Short-Span Operations)\n- When to use flows vs methods\n- Execution contexts and tag propagation\n- Sub-flow composition\n- Error handling patterns\n\n### 4. Production Lifecycle\n- Scope creation and disposal\n- Graceful shutdown patterns\n- Signal handling\n- Resource cleanup ordering\n- Background goroutine management\n\n### 5. Testing\n- `WithPreset()` for mocking executors\n- Table-driven tests (Go idiom)\n- Testing reactivity\n- Integration vs unit tests\n\n### 6. Enforcement Rules\n- **Tier 1 (Critical):** Must follow for production\n- **Tier 2 (Important):** Strong recommendations\n- **Tier 3 (Best Practices):** Go idioms and conventions\n\n## Quick Examples\n\n### Package-Level Executor Declaration\n\n```go\npackage graph\n\nimport pumped \"github.com/pumped-fn/pumped-go\"\n\nvar (\n    Config = pumped.Provide(func(ctx *pumped.ResolveCtx) (*Config, error) {\n        return &Config{DBHost: \"localhost\"}, nil\n    })\n\n    DB = pumped.Derive1(\n        Config,\n        func(ctx *pumped.ResolveCtx, cfgCtrl *pumped.Controller[*Config]) (*sql.DB, error) {\n            cfg, err := cfgCtrl.Get()\n            if err != nil {\n                return nil, err\n            }\n\n            db, err := sql.Open(\"postgres\", cfg.ConnectionString())\n            if err != nil {\n                return nil, err\n            }\n\n            ctx.OnCleanup(func() error {\n                return db.Close()\n            })\n\n            return db, nil\n        },\n    )\n)\n```\n\n### Testing with Mocks\n\n```go\nfunc TestUserService(t *testing.T) {\n    mockRepo := &MockUserRepository{}\n\n    testScope := pumped.NewScope(\n        pumped.WithPreset(UserRepo, mockRepo),\n    )\n    defer testScope.Dispose()\n\n    service, err := pumped.Resolve(testScope, UserService)\n    if err != nil {\n        t.Fatalf(\"failed to resolve: %v\", err)\n    }\n\n    // Test service...\n}\n```\n\n### Graceful Shutdown\n\n```go\nfunc main() {\n    scope := pumped.NewScope()\n    defer scope.Dispose()\n\n    // Resolve components...\n\n    sigCh := make(chan os.Signal, 1)\n    signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)\n    <-sigCh\n\n    log.Println(\"Shutting down...\")\n    // scope.Dispose() runs via defer\n}\n```\n\n## Installation\n\nAdd the marketplace and install the plugin in Claude Code:\n\n```bash\n/plugin marketplace add pumped-fn/pumped-go\n/plugin install pumped-go@pumped-fn-pumped-go\n```\n\nOr from the CLI:\n\n```bash\nclaude plugin marketplace add pumped-fn/pumped-go\nclaude plugin install pumped-go@pumped-fn-pumped-go\n```\n\nTo install for a specific scope:\n\n```bash\n# Project-wide (shared via version control)\nclaude plugin install pumped-go@pumped-fn-pumped-go --scope project\n\n# Local only (not shared)\nclaude plugin install pumped-go@pumped-fn-pumped-go --scope local\n```\n\n## Examples\n\nThe skill references real production examples from the `examples/` directory:\n\n- `examples/basic/` - Executor fundamentals\n- `examples/health-monitor/` - Production health monitoring service\n- `examples/http-api/` - REST API with dependency injection\n- `examples/cli-tasks/` - CLI application\n- `examples/order-processing/` - Flow execution patterns\n\n## Key Principles\n\n1. **Package-level executors** - All executors are `var` declarations\n2. **Controller pattern** - All dependencies passed as `*Controller[T]`\n3. **Error handling** - Never ignore errors from `.Get()`\n4. **Lifecycle management** - Always `OnCleanup()` for resources\n5. **Graceful shutdown** - Always `scope.Dispose()` (defer pattern)\n6. **Testing** - Use `WithPreset()` for mocks\n\n## Contributing\n\nFound an issue or want to improve the skill? Contributions welcome!\n\n1. Fork the repository\n2. Create your feature branch\n3. Update the skill in `claude-skill/skills/pumped-go/SKILL.md`\n4. Submit a pull request\n\n## License\n\nMIT - Same as pumped-go\n\n## Links\n\n- [pumped-go Repository](https://github.com/pumped-fn/pumped-go)\n- [Documentation](https://pkg.go.dev/github.com/pumped-fn/pumped-go)\n- [Examples](../examples/)\n"
      },
      "plugins": [
        {
          "name": "pumped-go",
          "source": "./claude-skill",
          "description": "Comprehensive Go guidance for pumped-go DI library - pattern enforcement, lifecycle management, testing support",
          "version": "1.0.0",
          "author": {
            "name": "pumped-fn"
          },
          "homepage": "https://github.com/pumped-fn/pumped-go",
          "repository": "https://github.com/pumped-fn/pumped-go",
          "license": "MIT",
          "keywords": [
            "go",
            "golang",
            "dependency-injection",
            "reactive-programming",
            "lifecycle-management"
          ],
          "category": "frameworks",
          "categories": [
            "dependency-injection",
            "frameworks",
            "go",
            "golang",
            "lifecycle-management",
            "reactive-programming"
          ],
          "install_commands": [
            "/plugin marketplace add pumped-fn/pumped-go",
            "/plugin install pumped-go@pumped-go"
          ]
        }
      ]
    }
  ]
}