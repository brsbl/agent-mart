{
  "author": {
    "id": "pumped-fn",
    "display_name": "pumped-fn",
    "avatar_url": "https://avatars.githubusercontent.com/u/199755659?v=4"
  },
  "marketplaces": [
    {
      "name": "pumped-fn-marketplace",
      "version": null,
      "description": "Official marketplace for pumped-fn Claude Code plugins",
      "repo_full_name": "pumped-fn/pumped-fn",
      "repo_url": "https://github.com/pumped-fn/pumped-fn",
      "repo_description": "Monorepository of @pumped-fn",
      "signals": {
        "stars": 5,
        "forks": 3,
        "pushed_at": "2026-02-02T11:25:02Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"pumped-fn-marketplace\",\n  \"owner\": {\n    \"name\": \"lagz0ne\",\n    \"email\": \"duke@silentium.io\"\n  },\n  \"metadata\": {\n    \"description\": \"Official marketplace for pumped-fn Claude Code plugins\",\n    \"version\": \"1.4.0\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"pumped-design\",\n      \"source\": \"./\",\n      \"description\": \"Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies\",\n      \"version\": \"1.4.0\",\n      \"author\": {\n        \"name\": \"lagz0ne\",\n        \"email\": \"duke@silentium.io\"\n      },\n      \"homepage\": \"https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design\",\n      \"repository\": \"https://github.com/pumped-fn/pumped-fn\",\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"typescript\",\n        \"backend-architecture\",\n        \"application-design\",\n        \"testing-strategy\",\n        \"code-quality\",\n        \"pumped-fn\",\n        \"design-patterns\",\n        \"resource-management\",\n        \"flow-orchestration\",\n        \"best-practices\"\n      ],\n      \"category\": \"code-quality\",\n      \"tags\": [\n        \"typescript\",\n        \"backend-architecture\",\n        \"application-design\",\n        \"testing-strategy\",\n        \"code-quality\",\n        \"pumped-fn\",\n        \"design-patterns\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"pumped-design\",\n  \"version\": \"1.4.0\",\n  \"description\": \"Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies\",\n  \"author\": {\n    \"name\": \"lagz0ne\",\n    \"email\": \"duke@silentium.io\"\n  },\n  \"repository\": \"https://github.com/pumped-fn/pumped-fn\",\n  \"homepage\": \"https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design\",\n  \"skills\": [\n    \"./.claude/skills/pumped-design\"\n  ]\n}\n",
        "README.md": "# pumped-fn\n\n[![npm version](https://img.shields.io/npm/v/@pumped-fn/lite)](https://www.npmjs.com/package/@pumped-fn/lite)\n\nA lightweight effect system for TypeScript with managed lifecycles and minimal reactivity.\n\n## What is an Effect System?\n\nAn effect system manages **how** and **when** computations run:\n- **Resource lifecycle** - acquire, use, release\n- **Computation ordering** - dependency resolution\n- **Side effect isolation** - controlled execution boundaries\n\n## Install\n\n```bash\nnpm install @pumped-fn/lite\n```\n\n## Core Concepts\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                         Scope                               │\n│  (long-lived execution boundary)                            │\n│                                                             │\n│   ┌─────────┐      ┌─────────┐      ┌─────────┐            │\n│   │  Atom   │ ──── │  Atom   │ ──── │  Atom   │            │\n│   │ (effect)│      │ (effect)│      │ (effect)│            │\n│   └─────────┘      └─────────┘      └─────────┘            │\n│        │                                  │                 │\n│        └──────────────┬───────────────────┘                 │\n│                       ▼                                     │\n│   ┌─────────────────────────────────────────────────────┐   │\n│   │              ExecutionContext                       │   │\n│   │  (short-lived operation with input, tags, cleanup)  │   │\n│   └─────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────┘\n```\n\n| Concept | Purpose |\n|---------|---------|\n| **Scope** | Long-lived boundary that manages atom lifecycles |\n| **Atom** | A managed effect with lifecycle (create, cache, cleanup, recreate) |\n| **ExecutionContext** | Short-lived context for running operations |\n| **Controller** | Handle for observing and controlling an atom's state |\n| **Tag** | Contextual value passed through execution |\n\n## Effect Lifecycle\n\n```mermaid\nstateDiagram-v2\n    [*] --> idle\n    idle --> resolving: resolve()\n    resolving --> resolved: success\n    resolving --> failed: error\n    resolved --> resolving: invalidate()\n    failed --> resolving: invalidate()\n    resolved --> idle: release()\n    failed --> idle: release()\n```\n\n## API Reference\n\n| Function | Description |\n|----------|-------------|\n| `createScope(options?)` | Create execution boundary |\n| `atom(config)` | Define managed effect (long-lived) |\n| `flow(config)` | Define operation template |\n| `tag(config)` | Define contextual value |\n| `controller(atom)` | Wrap atom for deferred resolution |\n| `preset(atom, value)` | Override atom value in scope |\n\n## Example: Snake Game\n\n```typescript\nimport { atom, tag, tags, controller, createScope } from '@pumped-fn/lite'\n\ntype Point = { x: number; y: number }\ntype Dir = 'up' | 'down' | 'left' | 'right'\ntype GameState = { snake: Point[]; food: Point; dir: Dir; score: number; hi: number; dead: boolean; size: number }\n\nconst gridSize = tag<number>({ label: 'gridSize', default: 20 })\nconst tickMs = tag<number>({ label: 'tickMs', default: 100 })\nconst stateTag = tag<GameState>({ label: 'state' })\n\nconst gameAtom = atom({\n  deps: { size: tags.required(gridSize) },\n  factory: (ctx, { size }): GameState => {\n    let state = ctx.data.get(stateTag)  // GameState | undefined - type safe!\n    if (!state) {\n      state = {\n        snake: [{ x: Math.floor(size/2), y: Math.floor(size/2) }],\n        food: { x: Math.floor(size/4), y: Math.floor(size/4) },\n        dir: 'right', score: 0, hi: 0, dead: false, size\n      }\n      ctx.data.set(stateTag, state)  // Type checked\n    }\n    return state\n  }\n})\n\nconst tickerAtom = atom({\n  deps: { ms: tags.required(tickMs), game: controller(gameAtom) },\n  factory: (ctx, { ms, game }) => {\n    const id = setInterval(() => {\n      const state = game.get()\n      if (!state.dead) {\n        tick(state)\n        game.invalidate()\n      }\n    }, ms)\n    ctx.cleanup(() => clearInterval(id))\n  }\n})\n\nfunction tick(s: GameState) { /* move snake, check collisions, update score */ }\n\nasync function createSnakeGame(size = 20, tickInterval = 100) {\n  const scope = createScope({ tags: [gridSize(size), tickMs(tickInterval)] })\n  const gameCtrl = scope.controller(gameAtom)\n  const tickerCtrl = scope.controller(tickerAtom)\n  await gameCtrl.resolve()\n\n  const turn = (dir: Dir) => {\n    const state = gameCtrl.get()\n    const opposite: Record<Dir, Dir> = { up: 'down', down: 'up', left: 'right', right: 'left' }\n    if (opposite[dir] !== state.dir && !state.dead) state.dir = dir\n  }\n\n  return {\n    state: gameCtrl,\n    up: () => turn('up'),\n    down: () => turn('down'),\n    left: () => turn('left'),\n    right: () => turn('right'),\n    step: () => { tick(gameCtrl.get()); gameCtrl.invalidate() },\n    start: () => tickerCtrl.resolve(),\n    pause: () => tickerCtrl.release(),\n    dispose: () => scope.dispose()\n  }\n}\n\nconst game = await createSnakeGame(15, 100)\ngame.state.on('resolved', () => render(game.state.get()))\nawait game.start()\ngame.down()\n```\n\n**What's demonstrated:**\n- **`tag`** - `gridSize`, `tickMs` configure game per-instance; `stateTag` provides typed storage key\n- **`ctx.data`** - State persists across `invalidate()` calls with type-safe tag-based API\n- **`controller()`** - Ticker gets `Controller<GameState>`, calls `.get()` and `.invalidate()`\n- **`invalidate()`** - Re-runs factory, notifies subscribers\n- **`cleanup()`** - Ticker interval cleared on `pause()`\n- **`ctrl.on('resolved')`** - UI subscribes to state changes\n\n## Design Principles\n\n1. **Minimal API** - Every export is expensive to learn\n2. **Zero dependencies** - No runtime dependencies\n3. **Explicit lifecycle** - No magic, clear state transitions\n4. **Composable** - Effects compose through deps\n\n## License\n\nMIT\n"
      },
      "plugins": [
        {
          "name": "pumped-design",
          "source": "./",
          "description": "Design, navigate, troubleshoot, and test pumped-fn backend applications using strict organizational patterns - provides phased design process, catalog-based navigation, and layer-specific testing strategies",
          "version": "1.4.0",
          "author": {
            "name": "lagz0ne",
            "email": "duke@silentium.io"
          },
          "homepage": "https://github.com/pumped-fn/pumped-fn/tree/main/.claude/skills/pumped-design",
          "repository": "https://github.com/pumped-fn/pumped-fn",
          "license": "MIT",
          "keywords": [
            "typescript",
            "backend-architecture",
            "application-design",
            "testing-strategy",
            "code-quality",
            "pumped-fn",
            "design-patterns",
            "resource-management",
            "flow-orchestration",
            "best-practices"
          ],
          "category": "code-quality",
          "tags": [
            "typescript",
            "backend-architecture",
            "application-design",
            "testing-strategy",
            "code-quality",
            "pumped-fn",
            "design-patterns"
          ],
          "categories": [
            "application-design",
            "backend-architecture",
            "best-practices",
            "code-quality",
            "design-patterns",
            "flow-orchestration",
            "pumped-fn",
            "resource-management",
            "testing-strategy",
            "typescript"
          ],
          "install_commands": [
            "/plugin marketplace add pumped-fn/pumped-fn",
            "/plugin install pumped-design@pumped-fn-marketplace"
          ]
        }
      ]
    }
  ]
}