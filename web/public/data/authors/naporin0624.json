{
  "author": {
    "id": "naporin0624",
    "display_name": "naporitan",
    "avatar_url": "https://avatars.githubusercontent.com/u/32933709?u=0fdafcaf020ccd1c7e1c7b8b90cf185e80b9d93e&v=4"
  },
  "marketplaces": [
    {
      "name": "hono-electron-marketplace",
      "version": null,
      "description": "Claude Code plugin for type-safe IPC communication in Electron applications using Hono RPC",
      "repo_full_name": "naporin0624/claude-plugin-hono-electron",
      "repo_url": "https://github.com/naporin0624/claude-plugin-hono-electron",
      "repo_description": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2026-01-27T08:47:55Z"
      },
      "files": {
        ".claude-plugin/marketplace.json": "{\n  \"name\": \"hono-electron-marketplace\",\n  \"owner\": {\n    \"name\": \"napochaan\"\n  },\n  \"metadata\": {\n    \"description\": \"Claude Code plugin for type-safe IPC communication in Electron applications using Hono RPC\",\n    \"version\": \"1.1.1\"\n  },\n  \"plugins\": [\n    {\n      \"name\": \"hono-electron-ipc\",\n      \"source\": \"./\",\n      \"description\": \"Type-safe IPC communication for Electron applications using Hono RPC, CQRS architecture, and reactive state management. Provides factory pattern with DI, Observable queries, ResultAsync commands, Jotai hybrid atoms, and migration support from traditional IPC.\",\n      \"version\": \"1.1.1\",\n      \"author\": {\n        \"name\": \"napochaan\"\n      },\n      \"license\": \"MIT\",\n      \"keywords\": [\n        \"electron\",\n        \"ipc\",\n        \"hono\",\n        \"typescript\",\n        \"rpc\",\n        \"type-safety\",\n        \"dependency-injection\",\n        \"zod-validation\",\n        \"factory-pattern\",\n        \"cqrs\",\n        \"rxjs\",\n        \"observable\",\n        \"jotai\",\n        \"reactive\",\n        \"neverthrow\"\n      ]\n    }\n  ]\n}\n",
        ".claude-plugin/plugin.json": "{\n  \"name\": \"hono-electron-ipc\",\n  \"version\": \"1.1.1\",\n  \"description\": \"Type-safe IPC communication for Electron applications using Hono RPC, CQRS architecture, and reactive state management. Provides factory pattern with DI, Observable queries, ResultAsync commands, and Jotai hybrid atoms.\",\n  \"author\": {\n    \"name\": \"napochaan\"\n  },\n  \"homepage\": \"https://github.com/naporin0624/claude-plugin-hono-electron\",\n  \"repository\": \"https://github.com/naporin0624/claude-plugin-hono-electron\",\n  \"license\": \"MIT\",\n  \"keywords\": [\n    \"electron\",\n    \"ipc\",\n    \"hono\",\n    \"typescript\",\n    \"rpc\",\n    \"type-safety\",\n    \"dependency-injection\",\n    \"zod-validation\",\n    \"factory-pattern\",\n    \"cqrs\",\n    \"rxjs\",\n    \"observable\",\n    \"jotai\",\n    \"reactive\",\n    \"neverthrow\"\n  ]\n}\n",
        "README.md": "# hono-electron-ipc\n\nA Claude Code plugin for implementing type-safe IPC communication in Electron applications using Hono RPC, CQRS architecture, and reactive state management.\n\n## Features\n\n- **Type-Safe IPC**: Full TypeScript inference across main and renderer processes\n- **Factory Pattern with DI**: Dependency injection for testable services\n- **Zod Validation**: Request validation with Zod schemas\n- **CQRS Architecture**: Observable queries and ResultAsync commands\n- **Reactive State**: Jotai hybrid atoms with IPC subscriptions\n- **Migration Support**: Migrate existing ipcRenderer/ipcMain to Hono\n\n## Installation\n\n### From Marketplace\n\n```bash\n/plugin marketplace add napochaan/hono-electron-ipc\n/plugin install hono-electron-ipc\n```\n\n### Local Development\n\n```bash\nclaude --plugin-dir ./hono-electron-ipc\n```\n\n## Quick Start\n\n### 1. Initialize Hono IPC\n\n```bash\n/hono-electron-ipc:init\n```\n\nThis scaffolds the complete directory structure:\n\n```\nsrc/\n├── shared/\n│   └── callable/\n│       ├── index.ts          # Factory and app creation\n│       └── types.d.ts        # Type export for client\n├── main/\n│   └── callable/\n│       └── index.ts          # Service injection\n└── renderer/\n    └── src/\n        └── adapters/\n            └── client.ts     # Type-safe hc client\n```\n\n### 2. Add Routes (Basic)\n\n```bash\n/hono-electron-ipc:add-route users\n```\n\nCreates a new route with Zod validation:\n\n```typescript\n// src/shared/callable/users/index.ts\nimport { zValidator } from '@hono/zod-validator';\nimport { Hono } from 'hono';\nimport { z } from 'zod';\n\nconst app = new Hono<HonoEnv>();\n\nexport const routes = app\n  .get('/', (c) => c.json({ users: [] }))\n  .get('/:id', (c) => c.json({ id: c.req.param('id') }));\n```\n\n### 3. Use in Renderer\n\n```typescript\nimport { client } from '@adapters/client';\n\n// Full autocomplete and type checking!\nconst res = await client.users[':id'].$get({ param: { id: 'usr_123' } });\nconst user = await res.json();\n```\n\n## Advanced Patterns\n\n### CQRS Service with Observable Queries\n\n```bash\n/hono-electron-ipc:new-service users\n```\n\nCreates a CQRS service:\n\n```typescript\nexport class UserServiceImpl implements UserService {\n  #notify = new BehaviorSubject(Date.now());\n\n  // Query: Observable for reactive data streams\n  list(): Observable<User[]> {\n    return concat(\n      from(this.#getUsers()),\n      this.#notify.pipe(mergeMap(() => this.#getUsers()))\n    );\n  }\n\n  // Command: ResultAsync for type-safe operations\n  create(data: CreateUserData): ResultAsync<void, Error> {\n    return this.#insertUser(data)\n      .andThen(() => {\n        this.#notify.next(Date.now());\n        return okAsync(void 0);\n      });\n  }\n}\n```\n\n### Reactive Jotai Atoms with IPC Subscriptions\n\n```bash\n/hono-electron-ipc:new-hybrid-atom users\n```\n\nCreates a hybrid atom (stream + HTTP fallback):\n\n```typescript\n// Stream atom (IPC subscription)\nconst streamUsersAtom = atom<{ value: User[] }>();\nstreamUsersAtom.onMount = (set) => {\n  const handler = debounce(async () => {\n    const data = await client.users.$get().then(r => r.json());\n    set({ value: data });\n  }, 300);\n  handler();\n  return usersSource.subscribe(handler);\n};\n\n// Hybrid selector\nexport const usersAtom = atom(async (get) => {\n  const stream = get(streamUsersAtom);\n  if (stream === undefined) return get(singleFetchAtom);\n  return stream.value;\n});\n```\n\n### Type-Safe Route with CQRS Integration\n\n```bash\n/hono-electron-ipc:new-route users\n```\n\nCreates a route with CQRS service integration:\n\n```typescript\nconst route = new Hono()\n  .get('/', async (c) => {\n    const users = await firstValueFromResult(\n      c.var.services.users.list()\n    );\n    return users.match(\n      (data) => c.json(data, 200),\n      (error) => c.json({ error: error.message }, 500)\n    );\n  });\n\n// Client: Full type inference\nconst users = await client.users.$get().then(r => r.json());\n```\n\n## Migrating Existing IPC\n\n```bash\n/hono-electron-ipc:migrate\n```\n\nThis orchestrates a full migration from traditional IPC to Hono:\n\n1. **Analyze** - Finds all `ipcMain.handle` and `ipcRenderer.invoke` calls\n2. **Plan** - Designs RESTful route structure\n3. **Execute** - Creates route files and updates registrations\n\n## Commands\n\n### Basic Commands\n\n| Command | Description |\n|---------|-------------|\n| `/hono-electron-ipc:init` | Initialize Hono IPC architecture |\n| `/hono-electron-ipc:add-route [name]` | Add a basic route with validation |\n| `/hono-electron-ipc:migrate` | Migrate existing IPC to Hono |\n\n### Advanced Commands (CQRS + Reactive)\n\n| Command | Description |\n|---------|-------------|\n| `/hono-electron-ipc:new-service [name]` | Create CQRS service with Observable/ResultAsync |\n| `/hono-electron-ipc:new-route [name]` | Create route with CQRS integration |\n| `/hono-electron-ipc:new-hybrid-atom [name]` | Create Jotai hybrid atom with IPC subscription |\n\n## Skills\n\n### Core Skills\n\n#### hono-ipc-setup\n\nAuto-triggers when discussing IPC setup, Hono for Electron, or type-safe IPC.\n\nProvides:\n- Complete setup instructions\n- Factory pattern with DI\n- Custom client implementation\n- Example routes\n\n#### hono-ipc-patterns\n\nAuto-triggers when discussing CQRS patterns, IPC error handling, or Zod validation.\n\nProvides:\n- CQRS (Query/Command separation)\n- Zod validation patterns\n- Error handling with Result types\n- Reactive data with RxJS\n\n### Advanced Skills\n\n#### cqrs-pattern\n\nImplement CQRS (Command Query Responsibility Segregation) pattern:\n\n- **Queries**: Return `Observable<T>` for reactive data streams\n- **Commands**: Return `ResultAsync<void, Error>` for type-safe operations\n- **BehaviorSubject**: Bridge between queries and commands\n\nSee: `skills/cqrs-pattern/SKILL.md`\n\n#### jotai-reactive-atoms\n\nImplement reactive Jotai atoms for Electron:\n\n- **Hybrid Atom Pattern**: Stream + HTTP fallback\n- **Event Subscription**: Optimized IPC listener sharing\n- **Debouncing**: Prevent UI thrashing from rapid updates\n\nSee: `skills/jotai-reactive-atoms/SKILL.md`\n\n#### hono-ipc-routes\n\nImplement type-safe IPC routes with CQRS:\n\n- **Route Handlers**: HTTP-like semantics over IPC with CQRS services\n- **Type Safety**: Full TypeScript inference from routes to client\n- **Zod Validation**: Schema-based request validation\n\nSee: `skills/hono-ipc-routes/SKILL.md`\n\n#### suspense-boundary-design\n\nDesign React Suspense boundaries for optimal loading states:\n\n- **ErrorBoundary + Suspense**: Combined error and loading handling\n- **Skeleton Loading**: Match skeleton to content size\n- **Boundary Granularity**: Group components sharing data under same boundary\n\nSee: `skills/suspense-boundary-design/SKILL.md`\n\n## Agents\n\n### ipc-analyzer\n\nAnalyzes existing IPC usage in codebase:\n- Finds all `ipcMain.handle()` calls\n- Maps request/response structures\n- Identifies service dependencies\n\n### route-planner\n\nDesigns Hono route structure:\n- Groups handlers into routes\n- Creates RESTful URL patterns\n- Plans service interfaces\n\n### migration-executor\n\nExecutes route migrations:\n- Creates route files\n- Migrates handler logic\n- Updates registrations\n\n## Architecture\n\n```\n┌─────────────────────────────────────────────────────────────────────┐\n│                      MAIN PROCESS                                    │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                       │\n│   Services (CQRS)                    IPC Layer (Hono)                │\n│   ┌─────────────────┐                ┌─────────────────┐             │\n│   │ Query:          │                │ HTTP-style RPC  │             │\n│   │ Observable<T>   │ ◄──────────────│ /users, /events │             │\n│   │                 │                │                 │             │\n│   │ Command:        │                │ Push Events     │             │\n│   │ ResultAsync     │ ──────────────►│ webContents.send│             │\n│   └─────────────────┘                └─────────────────┘             │\n│                                                                       │\n└─────────────────────────────────────────────────────────────────────┘\n                                    │\n                                    │ IPC\n                                    │\n┌─────────────────────────────────────────────────────────────────────┐\n│                      RENDERER PROCESS                                │\n├─────────────────────────────────────────────────────────────────────┤\n│                                                                       │\n│   Hono Client            Event Subscription         Jotai Atoms     │\n│   ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐ │\n│   │ client.users    │    │ Optimized IPC   │    │ Hybrid Pattern  │ │\n│   │ .$get()         │    │ Subscriptions   │───►│ Stream + HTTP   │ │\n│   └─────────────────┘    └─────────────────┘    └─────────────────┘ │\n│                                                                       │\n│   React Components with Suspense                                     │\n│                                                                       │\n└─────────────────────────────────────────────────────────────────────┘\n```\n\n### Data Flow\n\n1. **Renderer → Main**: `client.users.$get()` → Hono Router → CQRS Service\n2. **Main → Renderer (Push)**: Service emits Observable → `webContents.send()` → Jotai atom updates\n3. **Reactive Updates**: Database changes trigger BehaviorSubject → all subscribers notified\n\n## Type Safety\n\nThe key to type safety is the `CallableType`:\n\n```typescript\n// src/shared/callable/types.d.ts\nexport type CallableType = ReturnType<typeof createApp>;\n\n// src/renderer/src/adapters/client.ts\nexport const client = hc<CallableType>('http://internal.localhost', { ... });\n\n// Now client has full autocomplete:\n// client.users.$get()\n// client.users[':id'].$get({ param: { id: 'xxx' } })\n// client.auth.sign_in.$post({ json: { token: 'xxx' } })\n```\n\n## TDD Workflow\n\n1. **Red**: Write failing test first\n2. **Green**: Implement minimal code\n3. **Refactor**: Improve while keeping tests green\n\n```typescript\ndescribe('UserService', () => {\n  let db: ReturnType<typeof init>;\n\n  beforeEach(() => {\n    db = init();           // In-memory SQLite\n    runMigrate(db);        // Apply migrations\n  });\n\n  it('should list users reactively', async () => {\n    const service = new UserServiceImpl(db);\n    const values: User[][] = [];\n\n    service.list().subscribe(users => values.push(users));\n\n    await service.create({ name: 'Alice' });\n\n    expect(values).toHaveLength(2); // Initial + after create\n  });\n});\n```\n\n## Requirements\n\n- Node.js >= 18\n- Electron\n- TypeScript\n- Dependencies:\n  - Core: `hono`, `@hono/zod-validator`, `zod`\n  - CQRS: `rxjs`, `neverthrow`\n  - State: `jotai`\n  - Database: `drizzle-orm`\n  - Testing: `vitest`\n\n## License\n\nMIT\n\n## Author\n\nnapochaan\n\n## Contributing\n\nContributions are welcome! Please open an issue or submit a pull request.\n"
      },
      "plugins": [
        {
          "name": "hono-electron-ipc",
          "source": "./",
          "description": "Type-safe IPC communication for Electron applications using Hono RPC, CQRS architecture, and reactive state management. Provides factory pattern with DI, Observable queries, ResultAsync commands, Jotai hybrid atoms, and migration support from traditional IPC.",
          "version": "1.1.1",
          "author": {
            "name": "napochaan"
          },
          "license": "MIT",
          "keywords": [
            "electron",
            "ipc",
            "hono",
            "typescript",
            "rpc",
            "type-safety",
            "dependency-injection",
            "zod-validation",
            "factory-pattern",
            "cqrs",
            "rxjs",
            "observable",
            "jotai",
            "reactive",
            "neverthrow"
          ],
          "categories": [
            "cqrs",
            "dependency-injection",
            "electron",
            "factory-pattern",
            "hono",
            "ipc",
            "jotai",
            "neverthrow",
            "observable",
            "reactive",
            "rpc",
            "rxjs",
            "type-safety",
            "typescript",
            "zod-validation"
          ],
          "install_commands": [
            "/plugin marketplace add naporin0624/claude-plugin-hono-electron",
            "/plugin install hono-electron-ipc@hono-electron-marketplace"
          ]
        }
      ]
    }
  ]
}