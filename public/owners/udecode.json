{
  "owner": {
    "id": "udecode",
    "display_name": "Udecode",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/66228141?v=4",
    "url": "https://github.com/udecode",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 11,
      "total_commands": 26,
      "total_skills": 11,
      "total_stars": 1120,
      "total_forks": 83
    }
  },
  "repos": [
    {
      "full_name": "udecode/dotai",
      "url": "https://github.com/udecode/dotai",
      "description": "Context manager for all agents",
      "homepage": "",
      "signals": {
        "stars": 1120,
        "forks": 83,
        "pushed_at": "2025-12-17T16:03:16Z",
        "created_at": "2024-09-05T23:16:54Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 2493
        },
        {
          "path": ".claude-plugin/plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/agents/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/agents/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 332
        },
        {
          "path": ".claude-plugin/plugins/agents/README.md",
          "type": "blob",
          "size": 4748
        },
        {
          "path": ".claude-plugin/plugins/agents/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/agents/commands/parallel.md",
          "type": "blob",
          "size": 150
        },
        {
          "path": ".claude-plugin/plugins/agents/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/agents/skills/dispatching-parallel-agents",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/agents/skills/dispatching-parallel-agents/SKILL.md",
          "type": "blob",
          "size": 6206
        },
        {
          "path": ".claude-plugin/plugins/codex",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/codex/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/codex/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 139
        },
        {
          "path": ".claude-plugin/plugins/codex/.mcp.json",
          "type": "blob",
          "size": 551
        },
        {
          "path": ".claude-plugin/plugins/codex/README.md",
          "type": "blob",
          "size": 1804
        },
        {
          "path": ".claude-plugin/plugins/debug",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 315
        },
        {
          "path": ".claude-plugin/plugins/debug/README.md",
          "type": "blob",
          "size": 4920
        },
        {
          "path": ".claude-plugin/plugins/debug/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/commands/debug.md",
          "type": "blob",
          "size": 141
        },
        {
          "path": ".claude-plugin/plugins/debug/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/skills/root-cause-tracing",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/skills/root-cause-tracing/SKILL.md",
          "type": "blob",
          "size": 5944
        },
        {
          "path": ".claude-plugin/plugins/debug/skills/systematic-debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/debug/skills/systematic-debugging/SKILL.md",
          "type": "blob",
          "size": 11245
        },
        {
          "path": ".claude-plugin/plugins/dotai",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dotai/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dotai/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 365
        },
        {
          "path": ".claude-plugin/plugins/dotai/README.md",
          "type": "blob",
          "size": 5269
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/create-app-design.md",
          "type": "blob",
          "size": 10323
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/create-snippet.md",
          "type": "blob",
          "size": 679
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/create-tech-stack.md",
          "type": "blob",
          "size": 8994
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/fix.md",
          "type": "blob",
          "size": 56
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/install-all.md",
          "type": "blob",
          "size": 472
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/install.md",
          "type": "blob",
          "size": 298
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/opus.md",
          "type": "blob",
          "size": 52
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/update-app-design.md",
          "type": "blob",
          "size": 8976
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/update-project-structure.md",
          "type": "blob",
          "size": 285
        },
        {
          "path": ".claude-plugin/plugins/dotai/commands/update-tech-stack.md",
          "type": "blob",
          "size": 8530
        },
        {
          "path": ".claude-plugin/plugins/dotai/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/dotai/scripts/tree.sh",
          "type": "blob",
          "size": 1984
        },
        {
          "path": ".claude-plugin/plugins/fb",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/fb/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/fb/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 239
        },
        {
          "path": ".claude-plugin/plugins/fb/README.md",
          "type": "blob",
          "size": 4910
        },
        {
          "path": ".claude-plugin/plugins/fb/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/fb/commands/install.md",
          "type": "blob",
          "size": 404
        },
        {
          "path": ".claude-plugin/plugins/fb/commands/remember.md",
          "type": "blob",
          "size": 1551
        },
        {
          "path": ".claude-plugin/plugins/fb/commands/save-session.md",
          "type": "blob",
          "size": 5323
        },
        {
          "path": ".claude-plugin/plugins/fb/commands/session-start.md",
          "type": "blob",
          "size": 1607
        },
        {
          "path": ".claude-plugin/plugins/fb/commands/working-plan.md",
          "type": "blob",
          "size": 2167
        },
        {
          "path": ".claude-plugin/plugins/fb/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/fb/hooks/hooks.json",
          "type": "blob",
          "size": 18
        },
        {
          "path": ".claude-plugin/plugins/git",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 285
        },
        {
          "path": ".claude-plugin/plugins/git/README.md",
          "type": "blob",
          "size": 7550
        },
        {
          "path": ".claude-plugin/plugins/git/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/commands/create-pr.md",
          "type": "blob",
          "size": 4720
        },
        {
          "path": ".claude-plugin/plugins/git/commands/draft-pr.md",
          "type": "blob",
          "size": 133
        },
        {
          "path": ".claude-plugin/plugins/git/commands/review-pr.md",
          "type": "blob",
          "size": 146
        },
        {
          "path": ".claude-plugin/plugins/git/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/skills/creating-pr",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/skills/creating-pr/SKILL.md",
          "type": "blob",
          "size": 4833
        },
        {
          "path": ".claude-plugin/plugins/git/skills/drafting-pr",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/skills/drafting-pr/SKILL.md",
          "type": "blob",
          "size": 7026
        },
        {
          "path": ".claude-plugin/plugins/git/skills/reviewing-pr",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/git/skills/reviewing-pr/SKILL.md",
          "type": "blob",
          "size": 7750
        },
        {
          "path": ".claude-plugin/plugins/media",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/media/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/media/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 149
        },
        {
          "path": ".claude-plugin/plugins/media/README.md",
          "type": "blob",
          "size": 2699
        },
        {
          "path": ".claude-plugin/plugins/media/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/media/hooks/hooks.json",
          "type": "blob",
          "size": 1067
        },
        {
          "path": ".claude-plugin/plugins/media/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/media/scripts/get-env.js",
          "type": "blob",
          "size": 1160
        },
        {
          "path": ".claude-plugin/plugins/notification",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/notification/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/notification/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 206
        },
        {
          "path": ".claude-plugin/plugins/notification/README.md",
          "type": "blob",
          "size": 1690
        },
        {
          "path": ".claude-plugin/plugins/notification/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/notification/hooks/hooks.json",
          "type": "blob",
          "size": 1412
        },
        {
          "path": ".claude-plugin/plugins/plan",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/plan/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/plan/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 325
        },
        {
          "path": ".claude-plugin/plugins/plan/README.md",
          "type": "blob",
          "size": 4071
        },
        {
          "path": ".claude-plugin/plugins/plan/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/plan/commands/brainstorm.md",
          "type": "blob",
          "size": 508
        },
        {
          "path": ".claude-plugin/plugins/plan/commands/execute-plan.md",
          "type": "blob",
          "size": 119
        },
        {
          "path": ".claude-plugin/plugins/plan/commands/write-plan.md",
          "type": "blob",
          "size": 127
        },
        {
          "path": ".claude-plugin/plugins/plan/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/plan/skills/brainstorming",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/plan/skills/brainstorming/SKILL.md",
          "type": "blob",
          "size": 7032
        },
        {
          "path": ".claude-plugin/plugins/plan/skills/executing-plans",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/plan/skills/executing-plans/SKILL.md",
          "type": "blob",
          "size": 3135
        },
        {
          "path": ".claude-plugin/plugins/plan/skills/writing-plans",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/plan/skills/writing-plans/SKILL.md",
          "type": "blob",
          "size": 5981
        },
        {
          "path": ".claude-plugin/plugins/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/skills/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/skills/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 306
        },
        {
          "path": ".claude-plugin/plugins/skills/README.md",
          "type": "blob",
          "size": 6353
        },
        {
          "path": ".claude-plugin/plugins/skills/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/skills/commands/use-skills.md",
          "type": "blob",
          "size": 122
        },
        {
          "path": ".claude-plugin/plugins/skills/commands/write-skills.md",
          "type": "blob",
          "size": 26979
        },
        {
          "path": ".claude-plugin/plugins/skills/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/skills/skills/using-skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/skills/skills/using-skills/SKILL.md",
          "type": "blob",
          "size": 4551
        },
        {
          "path": ".claude-plugin/plugins/skills/skills/writing-skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/skills/skills/writing-skills/SKILL.md",
          "type": "blob",
          "size": 27447
        },
        {
          "path": ".claude-plugin/plugins/skills/skills/writing-skills/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/skills/skills/writing-skills/examples/CLAUDE_MD_TESTING.md",
          "type": "blob",
          "size": 5438
        },
        {
          "path": ".claude-plugin/plugins/test",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 318
        },
        {
          "path": ".claude-plugin/plugins/test/README.md",
          "type": "blob",
          "size": 4838
        },
        {
          "path": ".claude-plugin/plugins/test/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/commands/tdd.md",
          "type": "blob",
          "size": 12320
        },
        {
          "path": ".claude-plugin/plugins/test/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/skills/test-driven-development",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/plugins/test/skills/test-driven-development/SKILL.md",
          "type": "blob",
          "size": 12542
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/AGENTS.md",
          "type": "blob",
          "size": 480
        },
        {
          "path": ".claude/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/docs/plugins.md",
          "type": "blob",
          "size": 39113
        },
        {
          "path": ".claude/flashback",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/flashback/config",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/flashback/config/flashback.json",
          "type": "blob",
          "size": 238
        },
        {
          "path": ".claude/flashback/memory",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/flashback/memory/WORKING_PLAN.md",
          "type": "blob",
          "size": 1527
        },
        {
          "path": ".claude/flashback/prompts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/flashback/prompts/session-summary.md",
          "type": "blob",
          "size": 5885
        },
        {
          "path": ".claude/flashback/prompts/working-plan-update.md",
          "type": "blob",
          "size": 3361
        },
        {
          "path": ".claude/prompt.json",
          "type": "blob",
          "size": 3865
        },
        {
          "path": ".claude/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/scripts/post-compact.sh",
          "type": "blob",
          "size": 2050
        },
        {
          "path": ".claude/scripts/session-start.sh",
          "type": "blob",
          "size": 1075
        },
        {
          "path": ".claude/scripts/user-prompt-submit.sh",
          "type": "blob",
          "size": 2887
        },
        {
          "path": ".claude/settings.json",
          "type": "blob",
          "size": 1341
        },
        {
          "path": ".claude/skiller.toml",
          "type": "blob",
          "size": 1568
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 400
        },
        {
          "path": "CONTRIBUTING.md",
          "type": "blob",
          "size": 11649
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 11338
        },
        {
          "path": "bun.lock",
          "type": "blob",
          "size": 769
        },
        {
          "path": "package.json",
          "type": "blob",
          "size": 500
        },
        {
          "path": "registry",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/all.json",
          "type": "blob",
          "size": 485
        },
        {
          "path": "registry/dotai.json",
          "type": "blob",
          "size": 6181
        },
        {
          "path": "registry/dotai",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/dotai/AGENTS.md",
          "type": "blob",
          "size": 480
        },
        {
          "path": "registry/dotai/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/dotai/commands/watch.md",
          "type": "blob",
          "size": 118
        },
        {
          "path": "registry/dotai/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/dotai/docs/1-app-design-document.mdc",
          "type": "blob",
          "size": 49
        },
        {
          "path": "registry/dotai/docs/2-tech-stack.mdc",
          "type": "blob",
          "size": 40
        },
        {
          "path": "registry/dotai/docs/3-project-status.mdc",
          "type": "blob",
          "size": 507
        },
        {
          "path": "registry/dotai/settings.json",
          "type": "blob",
          "size": 1366
        },
        {
          "path": "registry/dotai/settings.local.json",
          "type": "blob",
          "size": 134
        },
        {
          "path": "registry/dotai/skiller.toml",
          "type": "blob",
          "size": 1568
        },
        {
          "path": "registry/flashback.json",
          "type": "blob",
          "size": 12368
        },
        {
          "path": "registry/flashback",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/flashback/config",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/flashback/config/flashback.json",
          "type": "blob",
          "size": 238
        },
        {
          "path": "registry/flashback/memory",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/flashback/memory/WORKING_PLAN.md",
          "type": "blob",
          "size": 1527
        },
        {
          "path": "registry/flashback/prompts",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/flashback/prompts/session-summary.md",
          "type": "blob",
          "size": 5832
        },
        {
          "path": "registry/flashback/prompts/working-plan-update.md",
          "type": "blob",
          "size": 3361
        },
        {
          "path": "registry/prompt.json",
          "type": "blob",
          "size": 15830
        },
        {
          "path": "registry/prompt",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/prompt/config",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/prompt/config/prompt.json",
          "type": "blob",
          "size": 3865
        },
        {
          "path": "registry/prompt/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "registry/prompt/scripts/post-compact.sh",
          "type": "blob",
          "size": 2050
        },
        {
          "path": "registry/prompt/scripts/session-start.sh",
          "type": "blob",
          "size": 5388
        },
        {
          "path": "registry/prompt/scripts/user-prompt-submit.sh",
          "type": "blob",
          "size": 2887
        },
        {
          "path": "registry/registry.json",
          "type": "blob",
          "size": 4080
        }
      ],
      "marketplace": {
        "name": "dotai",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "udecode",
          "email": "zbeyens@udecode.dev"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "dotai",
            "description": "Complete development toolkit - documentation, PRDs, debugging, PR workflows, and planning",
            "source": "./.claude-plugin/plugins/dotai",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install dotai@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/create-app-design",
                "description": "Generate comprehensive app design document with project stage assessment",
                "path": ".claude-plugin/plugins/dotai/commands/create-app-design.md",
                "frontmatter": {
                  "allowed-tools": "Read, Glob, Grep, Write, MultiEdit, TodoWrite",
                  "description": "Generate comprehensive app design document with project stage assessment"
                },
                "content": "# Generate Application Design Document\n\n**User Request:** $ARGUMENTS\n\n## Context\n\n- Project root: !`pwd`\n- Package.json: @package.json\n- Existing design docs: !`ls -la .claude/rules/ 2>/dev/null || echo \"No .claude/rules directory yet\"`\n\n## Goal\n\nCreate a comprehensive Application Design Document based on deep codebase analysis and user input. The document provides a high-level overview of the application's architecture, core features, user experience, and business logic while remaining technology-agnostic and focused on the \"what\" rather than the \"how\".\n\n## Process\n\n### 1. Initial Analysis\n\n- Analyze project structure and existing codebase\n- Review package.json for project name and dependencies\n- Check for existing documentation in .claude/rules/\n- Identify key application features and patterns\n- **Think deeply** about the application's purpose and architecture\n\n### 2. Codebase Deep Dive\n\n**Think harder about the application's architecture and business logic.**\n\nAnalyze the codebase to understand:\n\n- **Application Structure:** Main modules, features, and components\n- **User Flows:** Authentication, navigation, key user journeys\n- **Data Models:** Conceptual relationships and entities\n- **Business Logic:** Core rules, workflows, and processes\n- **Integrations:** External services and APIs\n- **Security Patterns:** Authentication and authorization approaches\n\n_Extended thinking helps identify non-obvious patterns, understand complex business rules from code, and make strategic decisions about what aspects are most important to document._\n\n### 3. Interactive Q&A Session\n\n**CRITICAL:** Ask project stage question FIRST, then 4-7 additional questions:\n\n- Use lettered/numbered options for easy response\n- Focus on business goals and user needs\n- Gather context for proper documentation\n\n### 4. Update Project Configuration\n\nBased on project stage response:\n\n- Update `.claude/rules/3-project-status.mdc` with current stage\n- Set appropriate DO/DON'T priorities for the stage\n- Document stage-specific development guidelines in the Cursor rule\n\n### 5. Generate Document\n\nCreate comprehensive app design document following the standard structure\n\n### 6. Save and Organize\n\n- Create `.claude/rules/` directory if needed\n- Save as `1-app-design-document.mdc`\n- Suggest next steps (tech stack doc, PRD, etc.)\n\n## Required Questions Template\n\n### üéØ CRITICAL: Project Stage Assessment (Ask First!)\n\n**1. What stage is your application currently in?**\n\na) **Pre-MVP** - Building initial version, not deployed to production yet  \n b) **MVP** - Basic version deployed and live with early users  \n c) **Production** - Mature application with established user base  \n d) **Enterprise** - Large scale deployment, multiple teams involved\n\n**2. Based on your selected stage, here are the development priorities:**\n\n- **Pre-MVP Priorities:**\n\n  - ‚úÖ DO: Core functionality, security basics, input validation, working features\n  - ‚ùå DON'T: Unit tests, performance optimization, accessibility polish, perfect code\n  - üöÄ Focus: Ship fast with security, iterate based on feedback\n\n- **MVP Priorities:**\n\n  - ‚úÖ DO: Critical path testing, basic monitoring, user feedback loops\n  - ‚ùå DON'T: Comprehensive test coverage, advanced patterns, premature optimization\n  - üöÄ Focus: Stability for early users, rapid iteration\n\n- **Production Priorities:**\n\n  - ‚úÖ DO: Testing, monitoring, performance, accessibility, documentation\n  - ‚ùå DON'T: Skip security reviews, ignore technical debt\n  - üöÄ Focus: Reliability, scalability, user experience\n\n- **Enterprise Priorities:**\n  - ‚úÖ DO: Comprehensive testing, security audits, team coordination, compliance\n  - ‚ùå DON'T: Skip documentation, ignore code standards\n  - üöÄ Focus: Team efficiency, maintainability, compliance\n\n### üìã Context-Specific Questions (Ask 4-7 based on analysis)\n\n**3. Application Purpose & Users**\n\n- What is the primary problem your application solves?\n- Who are your target users and what are their main goals?\n\n**4. Unique Value Proposition**\n\n- What makes your application unique compared to existing solutions?\n- What's your competitive advantage?\n\n**5. User Roles & Permissions**\n\n- What different types of users interact with your system?\n- Examples: end users, admins, moderators, content creators, viewers\n\n**6. Core User Journeys**\n\n- What are the 2-3 most critical user flows?\n- Example: Sign up ‚Üí Create content ‚Üí Share ‚Üí Get feedback\n\n**7. Business Model & Growth**\n\n- How does this application generate value?\n- Options: SaaS subscription, marketplace, freemium, advertising, one-time purchase\n\n**8. Integration Ecosystem**\n\n- What external services must you integrate with?\n- Examples: payment processors, email services, analytics, social platforms\n\n**9. Scale & Performance Goals**\n\n- What scale are you planning for in the next 12 months?\n- Users: dozens, hundreds, thousands, millions?\n- Geographic: local, national, global?\n\n**10. Success Metrics**\n\n- How will you measure if your application is successful?\n- Examples: user retention, revenue, engagement, conversion rates\n\n## Document Structure\n\nThe generated document must follow this high-level structure:\n\n### **Introduction**\n\n- Application overview and purpose\n- Target audience and user base\n- Core value proposition\n- Business context and goals\n\n### **Core Features**\n\n- **Feature Category 1:** (e.g., User Management)\n  - Purpose and user benefit\n  - Key functionalities\n  - User experience considerations\n- **Feature Category 2:** (e.g., Content Creation)\n  - Purpose and user benefit\n  - Key functionalities\n  - User experience considerations\n- **[Additional feature categories as needed]**\n\n### **User Experience**\n\n- User personas and roles\n- Key user journeys and flows\n- Interface design principles\n- Accessibility and usability considerations\n\n### **System Architecture**\n\n- High-level system components\n- Data flow and relationships\n- Integration points and external services\n- Security and privacy approach\n\n### **Business Logic**\n\n- Core business rules and processes\n- Data models and relationships (conceptual)\n- Workflow and state management\n- Validation and business constraints\n\n### **Future Considerations**\n\n- Planned enhancements and features\n- Scalability considerations\n- Potential integrations\n- Long-term vision and roadmap\n\n## Target Audience\n\nThe document should be accessible to:\n\n- **Business stakeholders** who need to understand the application's purpose and capabilities\n- **Product managers** planning features and roadmaps\n- **Designers** creating user interfaces and experiences\n- **New developers** joining the project who need a high-level understanding\n- **Technical leaders** making architectural decisions\n\nThe language should be clear, business-focused, and avoid technical implementation details.\n\n## Writing Principles\n\n### DO:\n\n- **Business Focus:** Describe WHAT the application does, not HOW\n- **User Value:** Emphasize benefits and outcomes for users\n- **Clear Language:** Write for non-technical stakeholders\n- **Visual Thinking:** Use diagrams and flows where helpful\n- **Future Ready:** Consider growth and evolution paths\n\n### DON'T:\n\n- **Technical Details:** No code snippets or implementation specifics\n- **Technology Stack:** Save for 2-tech-stack.mdc document\n- **Database Schemas:** Keep data models conceptual\n- **API Specifications:** Focus on capabilities, not endpoints\n- **Performance Metrics:** Describe goals, not technical benchmarks\n\n## Output\n\n- **Format:** Markdown (`.mdc`)\n- **Location:** `.claude/rules/`\n- **Filename:** `1-app-design-document.mdc`\n\n## Execution Steps\n\n### 1. Start with Analysis\n\n- Use Read, Glob, and Grep to explore the codebase\n- Identify key features and patterns\n- Look for existing documentation\n- **Use extended thinking:** \"Think deeply about this codebase's architecture, business purpose, and how different components work together to serve users\"\n\n### 2. Interactive Q&A\n\n- **MUST ASK PROJECT STAGE FIRST**\n- Present questions with numbered/lettered options\n- Wait for user responses before proceeding\n\n### 3. Update Project Status in Cursor Rule\n\nUpdate `.claude/rules/3-project-status.mdc` with the project stage information:\n\n```markdown\n---\ndescription: Project status and stage-specific development guidelines\nglobs:\nalwaysApply: true\n---\n\n# Project Status Guidelines\n\n## Current Project Stage: [Stage Name]\n\n**Stage**: [Pre-MVP | MVP | Production | Enterprise]\n\n### DO Care About (Current Stage Priorities)\n\n[Stage-specific DO priorities from template below]\n\n### DO NOT Care About (Skip for Velocity)\n\n[Stage-specific DON'T priorities from template below]\n\n### Development Approach\n\n[Stage-specific development focus]\n\n## Stage-Based Development Guidelines\n\n[Keep existing stage categories and guidelines from the original file]\n```\n\n**Stage-Specific Content:**\n\n- **Pre-MVP**:\n\n  - ‚úÖ DO: Core functionality, security basics, input validation, working features\n  - ‚ùå DON'T: Unit tests, performance optimization, accessibility polish, perfect code\n  - üöÄ Focus: Ship fast with security, iterate based on feedback\n\n- **MVP**:\n\n  - ‚úÖ DO: Critical path testing, basic monitoring, user feedback loops\n  - ‚ùå DON'T: Comprehensive test coverage, advanced patterns, premature optimization\n  - üöÄ Focus: Stability for early users, rapid iteration\n\n- **Production**:\n\n  - ‚úÖ DO: Testing, monitoring, performance, accessibility, documentation\n  - ‚ùå DON'T: Skip security reviews, ignore technical debt\n  - üöÄ Focus: Reliability, scalability, user experience\n\n- **Enterprise**:\n  - ‚úÖ DO: Comprehensive testing, security audits, team coordination, compliance\n  - ‚ùå DON'T: Skip documentation, ignore code standards\n  - üöÄ Focus: Team efficiency, maintainability, compliance\n\n### 4. Generate Document\n\n- Follow the standard structure\n- Tailor content to project stage\n- Keep language accessible\n\n### 5. Save and Next Steps\n\n- Create directories: `mkdir -p .claude/docs .claude/rules`\n- Save design document: `.claude/rules/1-app-design-document.mdc`\n- Update Claude rule: `.claude/rules/3-project-status.mdc`\n- Suggest: \"Would you like me to create a technical stack document next?\""
              },
              {
                "name": "/create-snippet",
                "description": null,
                "path": ".claude-plugin/plugins/dotai/commands/create-snippet.md",
                "frontmatter": null,
                "content": "Title: Create Snippet Prompt\nDescription: Generates a snippet template based on provided example code. Template contains instructions and example code. Provide more examples for coverage if needed. Don't include obvious steps you already know like imports.\nBody:\n\n### Instructions\n\nTitle: ${1:Create ${2:Component}}\nDescription: Generates a template for ${3:a ${2}}\nRules:\n\n- ${4:Add relevant rules here}\n- Keep rules concise and specific to the snippet\n- Include any critical requirements or conventions\n- Add validation rules if applicable\n\nBody:\n\n${5:$TM_SELECTED_TEXT}\n\n### Example\n\nTitle: ${1}\nDescription: ${3}\nRules:\n\n- ${4}\n- Example rule 2\n- Example rule 3\n\nBody:\n\n${5}\n"
              },
              {
                "name": "/create-tech-stack",
                "description": "Generate comprehensive technical stack documentation from codebase analysis",
                "path": ".claude-plugin/plugins/dotai/commands/create-tech-stack.md",
                "frontmatter": {
                  "allowed-tools": "Read, Glob, Grep, Write, MultiEdit, TodoWrite, Bash",
                  "description": "Generate comprehensive technical stack documentation from codebase analysis"
                },
                "content": "# Generate Tech Stack Documentation\n\n**User Request:** $ARGUMENTS\n\n## Context\n\n- Project root: !`pwd`\n- Package.json: @package.json\n- Node version: !`node --version 2>/dev/null || echo \"Node.js not found\"`\n- TypeScript config: @tsconfig.json\n- Database schema: !`ls -la prisma/schema.prisma 2>/dev/null || echo \"No Prisma schema found\"`\n- Existing docs: !`ls -la .claude/rules/*.md 2>/dev/null || echo \"No docs yet\"`\n\n## Goal\n\nCreate comprehensive Tech Stack Documentation based on deep codebase analysis. Document all technologies, frameworks, libraries, development tools, deployment strategies, and implementation patterns with specific versions and configurations.\n\n## Process\n\n### 1. Automated Technical Discovery\n\n- Parse package.json for all dependencies\n- Analyze configuration files (tsconfig, vite.config, next.config, etc.)\n- Detect database setup (Prisma, Drizzle, TypeORM, etc.)\n- Identify testing frameworks and tools\n- Scan for CI/CD configurations\n- Check deployment configurations\n\n### 2. Deep Code Analysis\n\nExamine codebase for:\n\n- **Architecture Patterns:** Monorepo structure, module organization\n- **Framework Usage:** Next.js app router vs pages, API routes\n- **State Management:** Zustand, Redux, Context API patterns\n- **Styling Approach:** Tailwind, CSS modules, styled-components\n- **Type Safety:** TypeScript strictness, validation libraries\n- **API Design:** REST, GraphQL, tRPC implementation\n- **Authentication:** Auth libraries and session management\n- **Testing Strategy:** Unit, integration, E2E test patterns\n\n### 3. Interactive Technical Q&A\n\nAsk 4-6 deployment and infrastructure questions:\n\n- Use numbered/lettered options\n- Focus on non-discoverable information\n- Gather hosting, monitoring, and workflow details\n\n### 4. Generate Comprehensive Documentation\n\nCreate detailed tech stack document with:\n\n- Specific version numbers\n- Configuration examples\n- Command references\n- Architecture diagrams (when applicable)\n\n### 5. Save and Organize\n\n- Create `.claude/rules/` if needed\n- Save as `2-tech-stack.mdc`\n\n## Technical Questions Template\n\n### üöÄ Deployment & Infrastructure\n\n**1. Where is your application currently deployed?**\n\na) **Vercel** - Next.js optimized hosting  \n b) **AWS** - EC2, Lambda, or containerized  \n c) **Railway/Render** - Modern PaaS providers  \n d) **Self-hosted** - VPS or on-premise  \n e) **Other** - Please specify  \n f) **Not deployed yet** - Still in development\n\n**2. How is your database hosted?**\n\na) **Managed service** (Supabase, PlanetScale, Neon, etc.)  \n b) **Cloud provider** (AWS RDS, Google Cloud SQL, etc.)  \n c) **Self-hosted** (Docker, VPS, etc.)  \n d) **Local only** - No production database yet\n\n### üìä Monitoring & Operations\n\n**3. What observability tools do you use?**\n\na) **Error tracking:** Sentry, Rollbar, Bugsnag  \n b) **Analytics:** Vercel Analytics, Google Analytics, Plausible  \n c) **Monitoring:** Datadog, New Relic, custom solution  \n d) **Logging:** CloudWatch, LogTail, custom logs  \n e) **None yet** - Planning to add later\n\n### üë• Development Workflow\n\n**4. What's your Git workflow?**\n\na) **Feature branches** with PR reviews  \n b) **Trunk-based** development  \n c) **GitFlow** with release branches  \n d) **Direct to main** (solo project)\n\n**5. How do you manage environments?**\n\na) **Multiple deployments** (dev, staging, prod)  \n b) **Preview deployments** for PRs  \n c) **Single production** environment  \n d) **Local development** only\n\n### üîê Additional Services\n\n**6. Which external services do you integrate with?**\n\n- [ ] Payment processing (Stripe, PayPal)\n- [ ] Email service (SendGrid, Resend, AWS SES)\n- [ ] File storage (S3, Cloudinary, UploadThing)\n- [ ] Authentication (Auth0, Clerk, Supabase Auth)\n- [ ] Search (Algolia, Elasticsearch)\n- [ ] Other APIs (please specify)\n\n## Document Structure\n\nThe generated document must follow this technical structure:\n\n### **Overview**\n\n- Brief description of the application's technical nature\n- Technology stack summary\n- Architecture approach (monolith, microservices, etc.)\n\n### **Programming Language & Runtime**\n\n- Primary programming language and version\n- Runtime environment and version\n- Type system and language features used\n\n### **Frontend**\n\n- UI Framework/Library and version\n- Styling approach and frameworks\n- Component libraries and design systems\n- State management solutions\n- Build tools and bundlers\n- Browser support and compatibility\n\n### **Backend**\n\n- Backend framework and architecture\n- API design (REST, GraphQL, tRPC, etc.)\n- Authentication and authorization\n- Middleware and security\n- File handling and uploads\n\n### **Database & Storage**\n\n- Database type and version\n- ORM/Query builder\n- Schema management and migrations\n- Caching solutions\n- File storage solutions\n- Data backup and recovery\n\n### **Development Tools & Workflow**\n\n- Package manager\n- Code formatting and linting\n- Type checking and compilation\n- Testing frameworks and strategies\n- Development server and hot reload\n- Version control workflow\n\n### **Deployment & Infrastructure**\n\n- Hosting platform and services\n- Build and deployment pipeline\n- Environment configuration\n- Domain and DNS management\n- SSL/TLS and security\n- Monitoring and logging\n\n### **External Integrations**\n\n- Third-party APIs and services\n- Payment processing\n- Email services\n- Analytics and tracking\n- Error monitoring\n- Performance monitoring\n\n### **Quality Assurance & Testing**\n\n- Testing strategy and frameworks\n- Code coverage tools\n- End-to-end testing\n- Performance testing\n- Security testing\n- Code review process\n\n### **Schemas & Data Models**\n\n- Database schema (if applicable)\n- API schemas and validation\n- Type definitions and interfaces\n- Data relationships and constraints\n\n## Target Audience\n\nThe document should serve:\n\n- **Developers** joining the project who need technical onboarding\n- **DevOps engineers** setting up infrastructure and deployment\n- **Technical architects** evaluating or improving the tech stack\n- **Security teams** understanding the technical landscape\n- **Future maintainers** who need to understand technical decisions\n\nThe language should be technical, precise, and include specific version numbers and configuration details.\n\n## Documentation Principles\n\n### DO Include:\n\n- **Exact Versions:** Lock file versions, not just ranges\n- **Configuration Examples:** Actual config snippets from the project\n- **Command Reference:** All npm scripts and their purposes\n- **Setup Instructions:** Step-by-step for new developers\n- **Architecture Decisions:** Why specific technologies were chosen\n- **Integration Details:** How services connect and communicate\n\n### DON'T Include:\n\n- **Generic Descriptions:** Avoid Wikipedia-style explanations\n- **Outdated Information:** Only document what's actually used\n- **Wishful Thinking:** Document current state, not future plans\n- **Sensitive Data:** No API keys, secrets, or credentials\n- **Redundant Info:** Link to official docs instead of copying\n\n## Output\n\n- **Format:** Markdown (`.mdc`)\n- **Location:** `.claude/rules/`\n- **Filename:** `2-tech-stack.mdc`\n\n## Execution Steps\n\n### 1. Automated Analysis Phase\n\n```bash\n# Extract key technical information\n- Read package.json and lock files\n- Scan for configuration files\n- Detect framework patterns\n- Identify database setup\n- Find test configurations\n```\n\n### 2. Manual Discovery Phase\n\n- Read key source files to understand architecture\n- Check for API route patterns\n- Analyze authentication implementation\n- Review deployment configurations\n\n### 3. Interactive Q&A\n\n- Present deployment and infrastructure questions\n- Use checkboxes for multi-select options\n- Wait for user responses\n\n### 4. Document Generation\n\n- Start with discovered information\n- Incorporate user responses\n- Add specific configuration examples\n- Include all npm scripts with descriptions\n\n### 5. Save and Update\n\n```bash\n# Create directory and save\nmkdir -p .claude/docs\n# Save to .claude/rules/2-tech-stack.mdc\n```\n\n### 6. Next Steps\n\n- Recommend: \"Should I create an app design document to complement this technical documentation?\"\n\n## Example Usage\n\n```bash\n# Basic usage\n/project:create-tech-stack\n\n# With specific focus\n/project:create-tech-stack Focus on deployment and CI/CD setup\n```\n\n## Sample Output Structure\n\n```markdown\n# Tech Stack Documentation\n\n## Overview\n\n- **Framework:** Next.js 14.2.5 (App Router)\n- **Language:** TypeScript 5.5.3\n- **Database:** PostgreSQL with Prisma ORM\n- **Deployment:** Vercel with preview deployments\n\n## Commands Reference\n\n### Development\n\n- `pnpm dev` - Start Next.js dev server on port 3000\n- `pnpm build` - Build production bundle\n- `pnpm typecheck` - Run tsc --noEmit\n\n### Database\n\n- `pnpm db:generate` - Generate Prisma client\n- `pnpm db:push` - Push schema changes to database\n\n# ... continue with full documentation\n```"
              },
              {
                "name": "/fix",
                "description": null,
                "path": ".claude-plugin/plugins/dotai/commands/fix.md",
                "frontmatter": null,
                "content": "Read and fix the errors you can see in the Bash output.\n"
              },
              {
                "name": "/install-all",
                "description": "Install all dotai registry items in one command",
                "path": ".claude-plugin/plugins/dotai/commands/install-all.md",
                "frontmatter": {
                  "description": "Install all dotai registry items in one command",
                  "allowed-tools": "Bash"
                },
                "content": "# Install All\n\nInstall all dotai registry items (dotai, flashback, prompt) in one command:\n\n```bash\nnpx shadcn@latest add https://raw.githubusercontent.com/udecode/dotai/main/registry/all.json\n```\n\nAfter installation, add ruler postinstall to your `package.json` to auto-generate agent instructions:\n\n```json\n{\n  \"scripts\": {\n    \"postinstall\": \"npx skiller@latest apply\"\n  }\n}\n```"
              },
              {
                "name": "/install",
                "description": "Install dotai prerequisites and project setup files",
                "path": ".claude-plugin/plugins/dotai/commands/install.md",
                "frontmatter": {
                  "description": "Install dotai prerequisites and project setup files",
                  "allowed-tools": "Bash"
                },
                "content": "# Install dotai Prerequisites\n\nInitialize your project with dotai setup files using shadcn CLI:\n\n```bash\nnpx shadcn@latest add https://raw.githubusercontent.com/udecode/dotai/main/registry/dotai.json\n```"
              },
              {
                "name": "/opus",
                "description": null,
                "path": ".claude-plugin/plugins/dotai/commands/opus.md",
                "frontmatter": {
                  "model": "claude-opus-4-1-20250805"
                },
                "content": "$ARGUMENTS"
              },
              {
                "name": "/update-app-design",
                "description": "Update existing app design document based on codebase changes and project evolution",
                "path": ".claude-plugin/plugins/dotai/commands/update-app-design.md",
                "frontmatter": {
                  "allowed-tools": "Read, Glob, Grep, Write, MultiEdit, TodoWrite, Bash",
                  "description": "Update existing app design document based on codebase changes and project evolution"
                },
                "content": "# Sync Application Design Document\n\n**User Request:** $ARGUMENTS\n\n## Context\n\n- Project root: !`pwd`\n- Package.json: @package.json\n- Current design doc: @.claude/rules/1-app-design-document.mdc\n- Last modified: !`stat -f \"%Sm\" .claude/rules/1-app-design-document.mdc 2>/dev/null || echo \"No existing document\"`\n\n## Goal\n\nUpdate the existing Application Design Document to reflect current codebase state, new features, changed priorities, and project evolution. Maintain consistency with the original document while incorporating new information.\n\n## Process\n\n### 1. Document Analysis\n\n- Read and understand the existing 1-app-design-document.mdc\n- Establish baseline understanding of documented features\n- Note the document's structure and tone\n- Identify areas that may need updates\n\n### 2. Codebase Change Detection\n\n**Think deeply about what has changed in the codebase since the document was last updated.**\n\nAnalyze for:\n\n- **New Features:** Components, modules, or capabilities added\n- **Modified Flows:** Changes to user journeys or business logic\n- **Removed Features:** Deprecated or deleted functionality\n- **Architecture Evolution:** New patterns, services, or integrations\n- **Scale Changes:** Growth in complexity or user base\n- **Security Updates:** New authentication/authorization patterns\n\n_Extended thinking helps identify subtle changes, understand how new features integrate with existing ones, and recognize patterns that indicate architectural evolution._\n\n### 3. Interactive Update Session\n\n**CRITICAL:** Ask project stage question FIRST to assess if priorities have changed:\n\n- Use lettered/numbered options for easy response\n- Focus on what has changed and why\n- Gather context for accurate updates\n\n### 4. Update Project Configuration\n\nIf project stage or priorities have changed:\n\n- Update `.claude/rules/3-project-status.mdc`\n- Adjust DO/DON'T lists for new priorities\n- Document any stage transitions\n\n### 5. Sync Document\n\nUpdate the document incrementally:\n\n- Preserve accurate existing content\n- Add new sections only when necessary\n- Update outdated information\n- Maintain consistent tone and structure\n\n### 6. Save Updated Document\n\n- Backup suggestion if major changes\n- Overwrite existing 1-app-design-document.mdc\n- Note what was updated\n\n## Required Questions Template\n\n### üéØ CRITICAL: Project Evolution Assessment (Ask First!)\n\n**1. Has your project stage evolved since the last update?**\n\na) **Same Stage** - Still in [current stage], just adding features  \nb) **Stage Evolution** - Moved from [current] to next stage  \nc) **Major Pivot** - Significant change in direction or purpose  \nd) **Help Me Assess** - Let's review current state together\n\n**2. Have your development priorities changed?**\n\nBased on your current stage, are these still your priorities?\n\n[Show current DO/DON'T lists from `.claude/rules/3-project-status.mdc`]\n\na) **Same Priorities** - These still reflect our focus  \nb) **Adjusted Priorities** - Some changes needed (please specify)  \nc) **New Focus Areas** - Different priorities based on learnings  \nd) **Stage-Based Change** - Priorities changed due to stage evolution\n\n### üìä Change Identification Questions\n\n**3. What major features have been added?**\n\nPlease describe any significant new capabilities, modules, or user-facing features added since the last update.\n\n**4. Have any core user flows changed?**\n\na) **Authentication/Authorization** - Login, permissions, security  \nb) **Main User Journey** - Primary application workflow  \nc) **Data Management** - How users create/edit/delete data  \nd) **Integration Points** - External service connections  \ne) **None/Minor Only** - No significant flow changes\n\n**5. What has been removed or deprecated?**\n\nList any features, integrations, or capabilities that have been removed or are being phased out.\n\n**6. Have you integrated new external services?**\n\na) **Payment Processing** - Stripe, PayPal, etc.  \nb) **Communication** - Email, SMS, notifications  \nc) **Analytics/Monitoring** - Tracking, logging services  \nd) **AI/ML Services** - LLMs, image processing, etc.  \ne) **Other** - Please specify  \nf) **None** - No new integrations\n\n### üöÄ Future Direction Questions\n\n**7. How has user feedback influenced changes?**\n\nDescribe any significant pivots or adjustments made based on user feedback or usage patterns.\n\n**8. What are your updated success metrics?**\n\nHave your KPIs or success measurements changed? Current focus:\n\n- User growth targets?\n- Revenue goals?\n- Engagement metrics?\n- Performance benchmarks?\n\n**9. What's the next major milestone?**\n\na) **Feature Release** - Specific new capability  \nb) **Scale Milestone** - User/revenue target  \nc) **Technical Goal** - Performance, security, architecture  \nd) **Business Goal** - Partnerships, funding, market expansion\n\n## Update Strategy\n\n### Incremental Updates\n\n- **Preserve:** Keep accurate existing content\n- **Enhance:** Add new information to existing sections\n- **Replace:** Update outdated or incorrect information\n- **Remove:** Mark deprecated features appropriately\n\n### Change Documentation\n\n- **New Features:** Add to relevant feature categories\n- **Modified Flows:** Update user journey descriptions\n- **Architecture Changes:** Reflect in system architecture section\n- **Business Evolution:** Update goals and success metrics\n\n### Consistency Maintenance\n\n- Keep the same professional, accessible tone\n- Maintain technology-agnostic descriptions\n- Focus on WHAT not HOW\n- Preserve document structure\n\n## Document Update Areas\n\n### Always Review:\n\n1. **Introduction**\n\n   - Update if purpose or audience has shifted\n   - Reflect any pivot in value proposition\n\n2. **Core Features**\n\n   - Add new feature categories if needed\n   - Update existing features with enhancements\n   - Mark removed features as deprecated\n\n3. **User Experience**\n\n   - Update user journeys with new flows\n   - Add new user personas if applicable\n   - Reflect UI/UX improvements\n\n4. **System Architecture**\n\n   - Add new integrations\n   - Update data flow diagrams\n   - Reflect new security patterns\n\n5. **Business Logic**\n\n   - Update rules and workflows\n   - Reflect new validation requirements\n   - Document new business constraints\n\n6. **Future Considerations**\n   - Update roadmap based on progress\n   - Add new planned features\n   - Reflect lessons learned\n\n## Execution Steps\n\n### 1. Start with Analysis\n\n```bash\n# Check when document was last updated\nstat -f \"%Sm\" .claude/rules/1-app-design-document.mdc\n\n# Review recent commits for feature changes\ngit log --oneline --since=\"30 days ago\" | head -20\n```\n\n**Think deeply about:** \"What has fundamentally changed in this application? How have new features altered the original vision? What patterns indicate architectural evolution?\"\n\n### 2. Interactive Q&A\n\n- **MUST ASK PROJECT STAGE FIRST**\n- Present all questions clearly\n- Wait for complete responses\n\n### 3. Update Project Status (if needed)\n\nIf stage or priorities changed, update both:\n\n```markdown\n# In `.claude/rules/3-project-status.mdc`\n\n## Project Status\n\n**Current Stage**: [New Stage]\n\n### DO Care About (Production-Ready Foundation)\n\n[Updated priorities]\n\n### DO NOT Care About (Skip for Velocity)\n\n[Updated items to skip]\n```\n\n### 4. Sync Document\n\n- Make targeted updates\n- Preserve document quality\n- Add version note if helpful:\n\n```markdown\n<!-- Last updated: [date] - Major changes: [summary] -->\n```\n\n### 5. Save and Backup\n\n```bash\n# Optional: Create backup\ncp .claude/rules/1-app-design-document.mdc .claude/rules/1-app-design-document.backup.mdc\n\n# Save updated document\n# Overwrite .claude/rules/1-app-design-document.mdc\n```\n\n## Key Principles\n\n### DO:\n\n- **Preserve Quality:** Maintain document's professional tone\n- **Incremental Updates:** Don't rewrite unnecessarily\n- **Clear Changes:** Make updates obvious and well-integrated\n- **User Focus:** Keep emphasis on user value\n- **Stage Awareness:** Align with current project maturity\n\n### DON'T:\n\n- **Complete Rewrite:** Unless fundamentally pivoted\n- **Technical Details:** Maintain high-level focus\n- **Break Structure:** Keep established organization\n- **Lose History:** Preserve context of major decisions\n- **Skip Analysis:** Always understand current state first\n\n## Output\n\n- **Format:** Markdown (`.mdc`)\n- **Location:** `.claude/rules/`\n- **Filename:** `1-app-design-document.mdc` (overwrites)\n- **Backup:** Suggest if major changes\n\n## Final Checklist\n\n1. ‚úÖ Read existing document completely\n2. ‚úÖ Analyze codebase changes thoroughly\n3. ‚úÖ Ask project stage question FIRST\n4. ‚úÖ Update `.claude/rules/3-project-status.mdc` if stage/priorities changed\n5. ‚úÖ Make incremental, targeted updates\n6. ‚úÖ Preserve document quality and tone\n7. ‚úÖ Suggest backup for major changes\n8. ‚úÖ Consider 2-tech-stack.mdc updates if needed"
              },
              {
                "name": "/update-project-structure",
                "description": "Update project structure documentation by running tree script",
                "path": ".claude-plugin/plugins/dotai/commands/update-project-structure.md",
                "frontmatter": {
                  "allowed-tools": "Bash",
                  "description": "Update project structure documentation by running tree script"
                },
                "content": "This command is generating the project structure documentation:\n\n!`bash ~/.claude/plugins/marketplaces/dotai/.claude-plugin/plugins/dotai/scripts/tree.sh`\n\nDo not do anything else."
              },
              {
                "name": "/update-tech-stack",
                "description": "Update tech stack documentation based on dependency changes and technical evolution",
                "path": ".claude-plugin/plugins/dotai/commands/update-tech-stack.md",
                "frontmatter": {
                  "allowed-tools": "Read, Glob, Grep, Write, MultiEdit, TodoWrite, Bash",
                  "description": "Update tech stack documentation based on dependency changes and technical evolution"
                },
                "content": "# Update Tech Stack Documentation\n\n**User Request:** $ARGUMENTS\n\n## Context\n\n- Project root: !`pwd`\n- Package.json: @package.json\n- Current tech doc: @.claude/rules/2-tech-stack.mdc\n- Last modified: !`stat -f \"%Sm\" .claude/rules/2-tech-stack.mdc 2>/dev/null || echo \"No existing document\"`\n- Recent package changes: !`git diff HEAD~10 HEAD -- package.json 2>/dev/null | grep -E \"^[+-]\" | head -20 || echo \"No recent changes\"`\n\n## Goal\n\nUpdate the existing Tech Stack Documentation to reflect current technical state, dependency changes, new tools adoption, and infrastructure evolution. Maintain technical accuracy while documenting all changes.\n\n## Process\n\n### 1. Document Analysis\n\n- Read existing 2-tech-stack.mdc thoroughly\n- Note documented versions and configurations\n- Understand current technical baseline\n- Identify sections that may need updates\n\n### 2. Technical Change Detection\n\n**Think deeply about technical evolution in the codebase.**\n\nAnalyze for:\n\n- **Dependency Changes:** New packages, version updates, removals\n- **Framework Evolution:** Major version upgrades, breaking changes\n- **Tool Adoption:** New dev tools, linters, formatters, testing frameworks\n- **Infrastructure Shifts:** Deployment, hosting, monitoring changes\n- **Database Evolution:** Schema changes, new ORMs, migrations\n- **Integration Updates:** New APIs, services, authentication providers\n\n_Extended thinking helps identify cascading dependency updates, understand version compatibility issues, and recognize architectural implications of technical changes._\n\n### 3. Automated Comparison\n\n```bash\n# Compare current vs documented dependencies\n# Check for version mismatches\n# Identify new configuration files\n# Detect new tool configurations\n```\n\n### 4. Interactive Technical Q&A\n\nAsk targeted questions about:\n\n- Non-discoverable infrastructure changes\n- Deployment and hosting updates\n- New external service integrations\n- Workflow and process changes\n\n### 5. Update Documentation\n\nUpdate incrementally:\n\n- Preserve accurate technical information\n- Update version numbers precisely\n- Add new sections for major additions\n- Mark deprecated technologies\n\n### 6. Save and Verify\n\n- Suggest backup for major changes\n- Verify all versions are accurate\n\n## Technical Questions Template\n\n### üîÑ Version Updates & Dependencies\n\n**1. Which major dependencies have been updated?**\n\nReview your recent dependency changes:\n\na) **Framework upgrades** (Next.js, React, etc.) with breaking changes  \nb) **Tool updates** (TypeScript, ESLint, etc.) requiring config changes  \nc) **New dependencies** added for features or development  \nd) **Removed packages** that are no longer needed  \ne) **All of the above** - Major technical overhaul\n\n**2. Have you changed your package manager or Node version?**\n\na) **Same setup** - No changes to tooling  \nb) **Node upgrade** - Updated Node.js version  \nc) **Package manager switch** - Changed from npm/yarn/pnpm  \nd) **Monorepo adoption** - Moved to workspace setup\n\n### üèóÔ∏è Infrastructure Evolution\n\n**3. Have your deployment or hosting arrangements changed?**\n\nCurrent deployment is documented as: [show from existing doc]\n\na) **Same platform** - Just configuration updates  \nb) **Platform migration** - Moved to different provider  \nc) **Architecture change** - Serverless, containers, etc.  \nd) **Multi-region** - Expanded geographic deployment\n\n**4. Database or storage changes?**\n\na) **Version upgrade** - Same DB, newer version  \nb) **Migration** - Switched database systems  \nc) **New caching** - Added Redis, Memcached, etc.  \nd) **Storage addition** - New file storage, CDN  \ne) **No changes** - Same setup as before\n\n### üõ†Ô∏è Development Workflow Updates\n\n**5. New development tools or practices?**\n\nSelect all that apply:\n\n- [ ] New testing framework or strategy\n- [ ] Added code quality tools (linters, formatters)\n- [ ] CI/CD pipeline changes\n- [ ] Docker/containerization adoption\n- [ ] New build tools or bundlers\n- [ ] Performance monitoring tools\n\n**6. External service integrations?**\n\nHave you added or changed:\n\na) **Payment processing** - New or updated provider  \nb) **Authentication** - Different auth service  \nc) **Email/SMS** - Communication service changes  \nd) **Monitoring** - New error tracking or analytics  \ne) **APIs** - Additional third-party integrations  \nf) **None** - Same external services\n\n### üîê Security & Compliance\n\n**7. Security tool adoption?**\n\n- [ ] Vulnerability scanning (Snyk, etc.)\n- [ ] Secret management changes\n- [ ] New authentication methods\n- [ ] Compliance tools (GDPR, etc.)\n- [ ] Security headers/policies\n- [ ] None of the above\n\n## Update Strategy\n\n### Version Precision\n\n```typescript\n// ‚ùå Outdated\n\"next\": \"^13.0.0\"\n\n// ‚úÖ Current and precise\n\"next\": \"14.2.5\"\n```\n\n### Configuration Updates\n\n- Update all config examples to match current files\n- Include new configuration options\n- Remove deprecated settings\n- Add migration notes for breaking changes\n\n### New Technology Sections\n\nWhen adding major new tools:\n\n```markdown\n### [New Tool Category]\n\n**Tool:** [Name] [Version]\n**Purpose:** [Why it was adopted]\n**Configuration:** [Key settings]\n**Integration:** [How it connects with other tools]\n```\n\n## Document Update Areas\n\n### Always Check:\n\n1. **package.json changes**\n\n   ```bash\n   # Compare all dependencies\n   # Note version changes\n   # Identify new packages\n   ```\n\n2. **Configuration files**\n\n   - tsconfig.json updates\n   - New .config files\n   - Build tool configurations\n   - Linting rule changes\n\n3. **Development scripts**\n\n   - New npm/pnpm scripts\n   - Changed command purposes\n   - Removed scripts\n\n4. **Infrastructure files**\n   - Dockerfile changes\n   - CI/CD workflows\n   - Deployment configs\n   - Environment examples\n\n### Conditional Updates:\n\n- **Architecture:** Only if fundamental changes\n- **Conventions:** Only if standards changed\n\n## Execution Steps\n\n### 1. Start with Analysis\n\n```bash\n# Check current dependencies vs documented\ndiff <(jq -r '.dependencies | keys[]' package.json | sort) \\\n     <(grep -E '^\\*\\*.*:' .claude/rules/2-tech-stack.mdc | cut -d: -f1 | sed 's/\\*//g' | sort)\n\n# Review recent dependency commits\ngit log --oneline --grep=\"dep\" --since=\"30 days ago\"\n\n# Check for new config files\nfind . -name \"*.config.*\" -newer .claude/rules/2-tech-stack.mdc 2>/dev/null\n```\n\n**Think deeply about:** \"What technical decisions drove these changes? How do version updates affect the overall architecture? What new capabilities do these tools enable?\"\n\n### 2. Interactive Q&A\n\n- Present technical questions clearly\n- Include current state from documentation\n- Wait for detailed responses\n\n### 3. Update Documentation\n\nFollow incremental approach:\n\n```markdown\n<!-- Version update example -->\n\n**Before:** React 18.2.0\n**After:** React 18.3.1 - Includes new compiler optimizations\n\n<!-- New tool example -->\n\n### Code Quality Tools\n\n**New Addition:**\n\n- **Biome:** 1.8.3 - Replaced ESLint and Prettier\n  - Faster performance (10x)\n  - Single configuration file\n  - Built-in formatting\n```\n\n### 4. Save and Backup\n\n```bash\n# Optional backup\ncp .claude/rules/2-tech-stack.mdc .claude/rules/2-tech-stack.backup.md\n\n# Save updated document\n# Overwrite .claude/rules/2-tech-stack.mdc\n```\n\n## Key Principles\n\n### DO:\n\n- **Exact Versions:** Use precise version numbers from lock files\n- **Config Accuracy:** Match actual configuration files\n- **Change Rationale:** Explain why tools were adopted/changed\n- **Migration Notes:** Document breaking changes and updates\n- **Performance Impact:** Note improvements or concerns\n\n### DON'T:\n\n- **Generic Updates:** Avoid vague version ranges\n- **Assumption:** Verify every technical detail\n- **Old Information:** Remove outdated configurations\n- **Wishful Documentation:** Only document what exists\n- **Sensitive Data:** Never include secrets or keys\n\n## Output\n\n- **Format:** Markdown (`.mdc`)\n- **Location:** `.claude/rules/`\n- **Filename:** `2-tech-stack.mdc` (overwrites)\n- **Backup:** Suggest for major changes\n\n## Final Checklist\n\n1. ‚úÖ Read existing 2-tech-stack.mdc completely\n2. ‚úÖ Analyze all dependency changes\n3. ‚úÖ Check configuration file updates\n4. ‚úÖ Review infrastructure changes\n5. ‚úÖ Ask targeted technical questions\n6. ‚úÖ Update with exact versions\n7. ‚úÖ Include configuration examples\n8. ‚úÖ Suggest backup if major changes\n9. ‚úÖ Verify technical accuracy"
              }
            ],
            "skills": []
          },
          {
            "name": "notification",
            "description": "macOS notifications for Claude Code events",
            "source": "./.claude-plugin/plugins/notification",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install notification@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "fb",
            "description": "Session management and continuity with automatic memory tracking",
            "source": "./.claude-plugin/plugins/fb",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install fb@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/install",
                "description": "Install Flashback session management system",
                "path": ".claude-plugin/plugins/fb/commands/install.md",
                "frontmatter": {
                  "description": "Install Flashback session management system",
                  "allowed-tools": "Bash"
                },
                "content": "# Install Flashback\n\nInstall `flashback` CLI:\n\n```bash\ncurl -fsSL https://raw.githubusercontent.com/zbeyens/flashbacker/main/scripts/install.sh | bash\n```\n\nThen install the flashback files with shadcn CLI:\n\n```bash\nnpx shadcn@latest add https://raw.githubusercontent.com/udecode/dotai/main/registry/flashback.json\n```"
              },
              {
                "name": "/remember",
                "description": null,
                "path": ".claude-plugin/plugins/fb/commands/remember.md",
                "frontmatter": null,
                "content": "You are helping add important information to the project's long-term memory system.\n\n## Context\nThe user wants to add this information to `.claude/flashback/memory/REMEMBER.md`: \"$ARGUMENTS\"\n\n## Current REMEMBER.md Content\n```\n{{CURRENT_MEMORY}}\n```\n\n## Task\nAnalyze the user's input and add it to the appropriate section in `.claude/flashback/memory/REMEMBER.md`. The information should be:\n\n1. **Categorized correctly** - Place it in the most relevant section:\n   - üìã Project Overview - For high-level project description\n   - üèóÔ∏è Architecture & Patterns - For design decisions and architectural info\n   - üîß Development Setup - For setup, dependencies, configuration\n   - üìù Conventions & Standards - For code style and project standards\n   - üö® Important Constraints - For limitations, requirements, things to avoid\n   - üîó Key Dependencies - For important libraries, frameworks, services\n   - üìÅ Directory Structure - For file locations and organizational patterns\n   - üß† Lessons Learned - For insights, gotchas, knowledge gained\n   - üéØ Current Goals - For high-level objectives and current work\n\n2. **Well-formatted** - Use consistent formatting with existing content\n3. **Concise but complete** - Capture the essential information clearly\n4. **Actionable** - Make it useful for future sessions\n\nIf the input doesn't clearly fit existing sections, add it to \"üß† Lessons Learned\" as the default.\n\nPlease output the complete updated `.claude/flashback/memory/REMEMBER.md` file with the new information properly integrated."
              },
              {
                "name": "/save-session",
                "description": null,
                "path": ".claude-plugin/plugins/fb/commands/save-session.md",
                "frontmatter": null,
                "content": "# Save Session\n\n**Create a beautifully formatted session summary document** in this conversation capturing meaningful insights.\n\n## Task Workflow\n\n1. **Check for Existing Session**: First check if there's an existing session file to archive\n2. **Archive Previous Session**: If found, save it to archive before creating new summary\n3. **Gather Context**: Run `flashback save-session --context` to get comprehensive session data\n4. **Analyze Session**: Extract real accomplishments, file changes, and decisions made\n5. **Update Working Plan**: Follow the working plan update process from @.claude/commands/fb/working-plan.md\n6. **Create New Summary**: Output polished session documentation **directly in this conversation**\n7. **Save Session Record**: Write the formatted summary to `.claude/flashback/memory/CURRENT_SESSION.md`\n\n## Session File Management\n\n**Before creating the new session summary:**\n\n1. **Check for existing session**: Use Read tool to check if `.claude/flashback/memory/CURRENT_SESSION.md` exists\n2. **Archive if found**: If file exists, copy it to `.claude/flashback/memory/ARCHIVE/sessions/session-[timestamp].md`\n3. **Clean old archives**: Keep only the 10 most recent archived sessions (delete older ones)\n\n**After creating the session summary:**\n\n- Save the formatted document to `.claude/flashback/memory/CURRENT_SESSION.md` for future archiving\n\n## Working Plan Update Process\n\n**During session analysis, also update the working plan:**\n\n1. **Read Current Plan**: Load @.claude/flashback/memory/WORKING_PLAN.md to understand current state\n2. **Analyze Accomplishments**: Extract what was actually completed, decisions made, next steps identified\n3. **Update Plan**: Apply changes to reflect real session progress:\n   - Move completed tasks from \"Next Priorities\" to \"Completed Recently\"\n   - Update \"Current Phase\" if phase changed\n   - Refresh \"Immediate Tasks\" based on conversation\n   - Add new tasks discovered during session\n   - Update session reference and timestamp\n4. **Write Updated Plan**: Output the complete updated WORKING_PLAN.md file content\n\n**CRITICAL**: Always output the complete, updated WORKING_PLAN.md file content. Use concrete, specific language based on actual conversation content, not generalizations.\n\n## Manual Commands (Alternative)\n\nIf the built-in archiving above fails, you can use:\n\n- `flashback save-session --archive` - Manually archive session files\n- `flashback save-session --prune 5` - Manually prune old archived sessions\n\n**Note**: The primary workflow handles archiving automatically in the prompt above.\n\n## Context Gathering\n\n```bash\nflashback save-session --context\n```\n\nProvides comprehensive session data:\n\n- **Enhanced Analysis Prompt**: Detailed instructions for creating beautiful documentation\n- **Project Context**: Memory and working plan for background\n- **Conversation Logs**: Complete session transcript with tool calls\n- **Git Analysis**: Actual file changes and repository state\n- **Tool Usage Tracking**: All Edit, Write, Bash, and other tool calls made\n\n## Required Output Structure\n\n**You MUST create a complete session document** using this exact format:\n\n```markdown\n# üìã Session Summary - [Month Day, Year]\n\n## üéØ Session Overview\n\n[2-3 sentences describing main focus and outcomes]\n\n## üìÅ Files Modified\n\n### Code Changes\n\n- **`src/file.ts`** - [Detailed description with technical context]\n\n### Documentation Updates\n\n- **`README.md`** - [Specific documentation changes]\n\n## ‚öíÔ∏è Tool Calls & Operations\n\n### File Operations\n\n- **Edit**: `file.ts:45-67` - [What was edited and why]\n- **Write**: `newfile.md` - [What was created]\n\n### System Commands\n\n- **Bash**: `npm run build` - [Command purpose and result]\n\n## ‚úÖ Key Accomplishments\n\n- **[Specific Feature]**: [Implementation details and impact]\n\n## üîß Problems Solved\n\n- **Issue**: [Problem description]\n  - **Solution**: [Technical solution with details]\n  - **Verification**: [How solution was validated]\n\n## üí° Technical Decisions\n\n- **Decision**: [What was decided with rationale]\n\n## üîÑ Next Steps\n\n- **Immediate**: [Next session priorities]\n\n## üß† Learning & Insights\n\n- **Technical Patterns**: [Architectural insights discovered]\n\n## üìä Session Metrics\n\n- **Tool Calls**: [Number of tool calls made]\n- **Files Changed**: [Number of files modified]\n\n## üå≥ Git Repository State\n\n- **Status**: [Current repository state]\n```\n\n## Quality Standards\n\n- **Professional Formatting**: Use emojis, proper structure, and clean markdown\n- **Specific Details**: Include exact file paths, line numbers, technical specifics\n- **Complete Documentation**: Cover all aspects of the session comprehensively\n- **Actionable Content**: Focus on concrete changes and decisions made\n\n## CRITICAL REMINDERS\n\n- **Dual Output**: Create session document **both in conversation AND save to file**\n- **Working Plan Update**: Always update the working plan based on session accomplishments\n- **Complete Workflow**: Follow the full archive ‚Üí analyze ‚Üí update plan ‚Üí save process\n- **Automatic Archiving**: Handle existing session files before creating new ones\n- **Professional Quality**: Make it beautiful, comprehensive, and actionable\n- **File Persistence**: Save both `CURRENT_SESSION.md` and `WORKING_PLAN.md` for future session continuity\n\nUsage: `/fb:save-session`\n"
              },
              {
                "name": "/session-start",
                "description": null,
                "path": ".claude-plugin/plugins/fb/commands/session-start.md",
                "frontmatter": null,
                "content": "# Session Start\n\nManual session recovery after compaction or when starting fresh. Uses the hybrid AI+Computer approach for reliable context gathering.\n\n## Task\n\n1. **Gather Context**: Run `flashback working-plan --context` to get:\n   - Current working plan from WORKING_PLAN.md\n   - **Previous session** conversation history (not empty current session)\n   - Current session information\n\n2. **Load Context**: Use `flashback session-start --context` to get recent conversation transcript\n3. Understand what you work working on from the conversation transcript, and WORKING_PLAN.md:\n   - What you were working on (from WORKING_PLAN.md)\n   - What happened in the last session (from conversation log)\n\n4. **Welcome User**: After loading context, provide a brief summary of what you understand about the project and ask \"What would you like to work on now?\"\n\n## Context Gathering Command\n\nThe CLI command handles all file reading and context formatting consistently:\n\n```bash\nflashback working-plan --context && flashback session-start --context\n```\n\nThis outputs structured context including:\n\n- Project memory and key learnings\n- Current development plan and priorities\n- Previous conversation history for continuity\n- Session restoration instructions\n\n## Usage Notes\n\nThis command is used manually when:\n\n- Starting work after auto-compact (no PostCompact hook exists)\n- Beginning a fresh session and need project context\n- Hook didn't trigger properly and need manual context restoration\n\n**CRITICAL**: Gets **previous meaningful conversation**, not empty current session context.\n\nUsage: `/fb:session-start`\n"
              },
              {
                "name": "/working-plan",
                "description": null,
                "path": ".claude-plugin/plugins/fb/commands/working-plan.md",
                "frontmatter": null,
                "content": "# Working Plan Update\n\nYou are an expert project manager updating a development working plan based on conversation analysis.\n\n## Task\n\n1. **Read the AI analysis prompt**: Load @.claude/flashback/prompts/working-plan-update.md for detailed analysis instructions\n2. **Read current working plan**: Load @.claude/flashback/memory/WORKING_PLAN.md to understand current state\n3. **Gather session context**: Use `flashback working-plan --context` to get recent conversation transcript\n4. **Analyze conversation**: Extract what was actually accomplished, decisions made, next steps identified\n5. **Update working plan**: Apply changes to reflect real session progress, not just timestamp updates\n\n## Archive Management Commands\n\nFor manual plan management:\n\n- `flashback working-plan --archive` - Archive current plan to `.claude/flashback/memory/ARCHIVE/plans/` and create fresh template\n- `flashback working-plan --prune 5` - Keep only 5 most recent archived plans (default: 10)\n\n## Analysis Focus\n\nFrom recent conversation, identify:\n\n- **Completed Tasks**: What was actually finished or implemented\n- **In-Progress Work**: Tasks started but not completed\n- **Key Decisions**: Important architectural or design decisions made\n- **Blockers**: Issues or obstacles encountered\n- **Next Steps**: Explicitly mentioned or implied next actions\n- **Scope Changes**: Any changes to project direction or priorities\n\n## Output Instructions\n\n**YOU MUST WRITE THE COMPLETE UPDATED `.claude/flashback/memory/WORKING_PLAN.md` FILE.**\n\nAfter analyzing the conversation, output the entire updated working plan file with these changes:\n\n- Move completed tasks from \"Next Priorities\" to \"Completed Recently\"\n- Update \"Current Phase\" if phase changed\n- Refresh \"Immediate Tasks\" based on conversation\n- Add new tasks discovered during session\n- Update session reference and timestamp\n- Preserve overall structure and formatting\n\n**CRITICAL**: Always output the complete, updated WORKING_PLAN.md file content. Do not just provide analysis - write the actual file that should replace the existing one.\n\nUse concrete, specific language based on actual conversation content, not generalizations.\n"
              }
            ],
            "skills": []
          },
          {
            "name": "media",
            "description": "Auto-play/pause media on prompt submit/stop",
            "source": "./.claude-plugin/plugins/media",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install media@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "codex",
            "description": "MCP servers for Codex integration",
            "source": "./.claude-plugin/plugins/codex",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install codex@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "plan",
            "description": "Planning and brainstorming workflows for software development - helps refine ideas into designs and create detailed implementation plans",
            "source": "./.claude-plugin/plugins/plan",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install plan@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/brainstorm",
                "description": "Interactive design refinement using Socratic method with AskUserQuestion tool",
                "path": ".claude-plugin/plugins/plan/commands/brainstorm.md",
                "frontmatter": {
                  "description": "Interactive design refinement using Socratic method with AskUserQuestion tool"
                },
                "content": "Use and follow the brainstorm skill exactly as written\n\n**üö® CRITICAL REQUIREMENTS**:\n\n1. **Write plan file FIRST**: Create `.claude/docs/plans/<topic>-design.md` BEFORE asking questions, then update it incrementally after EACH answer. Do NOT wait until the end.\n2. **Use AskUserQuestion tool for ALL questions**: NEVER output questions as plain text - always use the tool to enable interactive selection."
              },
              {
                "name": "/execute-plan",
                "description": "Execute plan in batches with review checkpoints",
                "path": ".claude-plugin/plugins/plan/commands/execute-plan.md",
                "frontmatter": {
                  "description": "Execute plan in batches with review checkpoints"
                },
                "content": "Use the executing-plans skill exactly as written"
              },
              {
                "name": "/write-plan",
                "description": "Create detailed implementation plan with bite-sized tasks",
                "path": ".claude-plugin/plugins/plan/commands/write-plan.md",
                "frontmatter": {
                  "description": "Create detailed implementation plan with bite-sized tasks"
                },
                "content": "Use the writing-plans skill exactly as written"
              }
            ],
            "skills": [
              {
                "name": "brainstorming",
                "description": "Use when creating or developing, before writing code or implementation plans - refines rough ideas into fully-formed designs through collaborative questioning, alternative exploration, and incremental validation. Don't use during clear 'mechanical' processes",
                "path": ".claude-plugin/plugins/plan/skills/brainstorming/SKILL.md",
                "frontmatter": {
                  "name": "brainstorming",
                  "description": "Use when creating or developing, before writing code or implementation plans - refines rough ideas into fully-formed designs through collaborative questioning, alternative exploration, and incremental validation. Don't use during clear 'mechanical' processes"
                },
                "content": "# Brainstorming Ideas Into Designs\n\n## Overview\n\nHelp turn ideas into fully formed designs and specs through natural collaborative dialogue.\n\n**üö® CRITICAL REQUIREMENT**: Create the plan file `.claude/docs/plans/<topic>-design.md` BEFORE asking questions, then update it incrementally after EACH answer. Do NOT wait until the end to write everything at once.\n\nStart by understanding the current project context, then ask multiple related questions together (up to 4 at once) to efficiently refine the idea. Once you understand what you're building, present the design in small sections (200-300 words), checking after each section whether it looks right so far.\n\n## The Process\n\n**CRITICAL FIRST STEP - Create Plan File Immediately:**\n\n- **Before asking ANY questions, create `.claude/docs/plans/<topic>-design.md` using Write tool**\n- Write initial context: problem statement, initial understanding (even if incomplete)\n- Structure: Use headings like \"Goals\", \"Requirements\", \"Architecture\", \"Open Questions\"\n- This file is your working document - update it continuously throughout brainstorming\n- **DO NOT wait until the end** - write first, refine continuously\n\n**Understanding the idea:**\n\n- Check out the current project state first (files, docs, recent commits)\n- **After EACH round of answers, immediately update the plan file using Edit tool**\n- Ask multiple related questions together using the AskUserQuestion tool (up to 4 per call)\n- **CRITICAL**: Always use the AskUserQuestion tool for ALL questions - NEVER output questions as plain text\n- Prefer multiple choice questions when possible (the tool supports multiSelect when needed)\n- Group related questions together for efficiency (e.g., scope + timeline + constraints in one call)\n- Focus on understanding: purpose, constraints, success criteria\n- After each round of answers, ask follow-up questions to drill deeper into areas that need clarification\n- **Pattern: Question ‚Üí Answer ‚Üí Update plan file ‚Üí Next question**\n\n**Exploring approaches:**\n\n- Propose 2-3 different approaches with trade-offs\n- Present options conversationally with your recommendation and reasoning\n- Lead with your recommended option and explain why\n\n**Presenting the design:**\n\n- Once you believe you understand what you're building, present the design\n- Break it into sections of 200-300 words\n- Use AskUserQuestion tool after each section to confirm it looks right (e.g., \"Does this architecture look right?\")\n- Cover: architecture, components, data flow, error handling, testing\n- Be ready to go back and clarify if something doesn't make sense\n\n## Design vs Implementation Boundaries\n\n**THIS SKILL IS FOR DESIGN ONLY.** If you find yourself writing implementation details, STOP - you're crossing into writing-plans territory.\n\n**DESIGN (this skill) - High-level, conceptual:**\n- Architecture decisions and trade-offs (e.g., \"Use React Query for server state\")\n- Component responsibilities (conceptual) (e.g., \"FilterSidebar handles job title filtering\")\n- Data flow approach (e.g., \"Server actions ‚Üí React Query ‚Üí UI\")\n- Technology choices with reasoning (e.g., \"shadcn/ui for component library\")\n- Open questions and assumptions\n\n**IMPLEMENTATION (writing-plans skill) - Detailed, executable:**\n- Exact file paths (e.g., \"src/app/(protected)/training-videos/page.tsx\")\n- Numbered implementation phases/steps (e.g., \"Phase 1: Sidebar Setup\")\n- \"Files to modify\" and \"Files to create\" lists\n- Complete code examples and snippets\n- Git commit instructions\n- Task breakdown with dependencies\n\n**Red Flags - STOP Immediately:**\n- Writing \"Phase 1: Setup\", \"Phase 2: Components\" ‚Üí That's writing-plans\n- Listing \"Files to modify: src/exact/path.tsx\" ‚Üí That's writing-plans\n- Creating \"File Change Summary\" section ‚Üí That's writing-plans\n- Writing \"Implementation Plan\" header ‚Üí That's writing-plans\n- Providing exact directory structures with file paths ‚Üí That's writing-plans\n\n**If you catch yourself doing any of the above, immediately:**\n1. Delete the implementation content\n2. Ask user if ready to transition to writing-plans skill\n3. Use writing-plans skill to create proper implementation plan\n\n## After the Design\n\n**Documentation:**\n\n- The plan file `.claude/docs/plans/<topic>-design.md` should already exist and be complete\n- **You should have been updating it throughout the entire brainstorming process**\n- If you haven't been updating it incrementally, you made a mistake - fix it now\n- Final pass: Review for clarity, completeness, and consistency\n- Use elements-of-style:writing-clearly-and-concisely skill if available for polish\n\n**Incremental Writing Pattern (THE CORRECT WAY):**\n\n```\nWRONG ‚ùå:\n1. Ask all questions\n2. Get all answers\n3. Write entire plan at the end\n\nCORRECT ‚úÖ:\n1. Write initial plan file with problem statement\n2. Ask question batch 1\n3. Immediately update plan file with answers\n4. Ask question batch 2\n5. Immediately update plan file with answers\n6. Present design section by section\n7. Update plan file with any refinements\n8. Final review and polish\n```\n\nExample workflow:\n\n1. **Start**: Write `.claude/docs/plans/2025-11-05-pcc-sync-design.md` with initial understanding\n2. **Question 1**: Ask about goals ‚Üí User answers ‚Üí Edit plan file \"Goals\" section\n3. **Question 2**: Ask about technical constraints ‚Üí User answers ‚Üí Edit plan file \"Requirements\" section\n4. **Question 3**: Ask about data types ‚Üí User answers ‚Üí Edit plan file \"Data Types\" section\n5. **Design**: Present architecture ‚Üí User approves ‚Üí Edit plan file \"Architecture\" section\n6. **Refinement**: User asks about error handling ‚Üí Edit plan file to add \"Error Handling\" section\n7. **Complete**: Plan file reflects entire conversation\n\nThe plan file is your **working document**, not a final deliverable to write at the end\n\n**Implementation (if continuing):**\n\n- Use AskUserQuestion tool: \"Ready to set up for implementation?\" with options: [\"Yes, create implementation plan\", \"No, refine design more\", \"No, just save the design\"]\n- **MANDATORY NEXT STEP if user chooses \"Yes\":** Use writing-plans skill to create detailed implementation plan\n\n## Key Principles\n\n- **Use AskUserQuestion tool** - ALWAYS use the tool for questions, never plain text\n- **Ask multiple questions** - Group related questions together (up to 4) for efficiency\n- **Multiple choice preferred** - The tool makes it easy for users to select from options\n- **YAGNI ruthlessly** - Remove unnecessary features from all designs\n- **Explore alternatives** - Always propose 2-3 approaches before settling\n- **Incremental validation** - Present design in sections, validate each with AskUserQuestion\n- **Be flexible** - Go back and clarify when something doesn't make sense"
              },
              {
                "name": "executing-plans",
                "description": "Use when partner provides a complete implementation plan to execute in controlled batches with review checkpoints - loads plan, reviews critically, executes tasks in batches, reports for review between batches",
                "path": ".claude-plugin/plugins/plan/skills/executing-plans/SKILL.md",
                "frontmatter": {
                  "name": "executing-plans",
                  "description": "Use when partner provides a complete implementation plan to execute in controlled batches with review checkpoints - loads plan, reviews critically, executes tasks in batches, reports for review between batches"
                },
                "content": "# Executing Plans\n\n## Overview\n\nLoad plan, review critically, execute tasks in batches, report for review between batches.\n\n**Core principle:** Batch execution with checkpoints for architect review.\n\n**Announce at start:** \"I'm using the executing-plans skill to implement this plan.\"\n\n## The Process\n\n### Step 1: Load and Review Plan\n\n1. Read plan file\n2. Review critically - identify any questions or concerns about the plan\n3. If concerns: Raise them with your human partner before starting\n4. If no concerns: Create TodoWrite and proceed\n\n### Step 2: Execute Batch\n\n**Default: First 3 tasks**\n\nFor each task:\n\n1. Mark as in_progress\n2. Follow each step exactly (plan has bite-sized steps)\n3. Run verifications as specified (tests if included, typecheck/lint if not)\n4. Mark as completed\n\n**Note on tests**: Only some tasks will have tests (complex logic only). Follow the plan's testing approach - don't add tests where the plan doesn't specify them.\n\n### Step 3: Report and Commit Check\n\nWhen batch complete:\n\n- Show what was implemented\n- Show verification output\n- **Check if commit should be suggested:**\n  - If you verified tests/typecheck/lint passed AND plan includes commit steps ‚Üí Ask: \"Batch complete. Create commit for these changes?\"\n  - If tests are user's responsibility OR you couldn't verify ‚Üí Skip commit suggestion, just report\n- Say: \"Ready for feedback.\"\n\n### Step 4: Continue\n\nBased on feedback:\n\n- Apply changes if needed\n- Execute next batch\n- Repeat until complete\n\n### Step 5: Complete Development\n\nAfter all tasks complete and verified:\n\n- Run final verification: `npm run typecheck && npm run lint`\n- Report completion summary showing all implemented tasks\n- **Final commit check using AskUserQuestion tool:**\n  - If no commits created during batches ‚Üí Ask: \"All tasks complete. Create a git commit?\"\n  - If already committed during batches ‚Üí Ask: \"All tasks complete. Run additional verification or move on?\"\n\n## When to Stop and Ask for Help\n\n**STOP executing immediately when:**\n\n- Hit a blocker mid-batch (missing dependency, test fails, instruction unclear)\n- Plan has critical gaps preventing starting\n- You don't understand an instruction\n- Verification fails repeatedly\n\n**Ask for clarification rather than guessing.**\n\n## When to Revisit Earlier Steps\n\n**Return to Review (Step 1) when:**\n\n- Partner updates the plan based on your feedback\n- Fundamental approach needs rethinking\n\n**Don't force through blockers** - stop and ask.\n\n## Remember\n\n- Review plan critically first\n- Follow plan steps exactly\n- Don't skip verifications\n- Reference skills when plan says to\n- Between batches: report, check commit opportunity, wait for feedback\n- **Never auto-commit** - Always ask user first, even if plan includes commit commands\n- Leverage batch pauses for commit suggestions (don't create extra pauses)\n- Stop when blocked, don't guess"
              },
              {
                "name": "writing-plans",
                "description": "Use when design is complete and you need detailed implementation tasks for engineers with zero codebase context - creates comprehensive implementation plans with exact file paths, complete code examples, and verification steps assuming engineer has minimal domain knowledge",
                "path": ".claude-plugin/plugins/plan/skills/writing-plans/SKILL.md",
                "frontmatter": {
                  "name": "writing-plans",
                  "description": "Use when design is complete and you need detailed implementation tasks for engineers with zero codebase context - creates comprehensive implementation plans with exact file paths, complete code examples, and verification steps assuming engineer has minimal domain knowledge"
                },
                "content": "# Writing Plans\n\n## Overview\n\nWrite comprehensive implementation plans assuming the engineer has zero context for our codebase and questionable taste. Document everything they need to know: which files to touch for each task, code, testing, docs they might need to check, how to test it. Give them the whole plan as bite-sized tasks. DRY. YAGNI. TDD. Frequent commits.\n\nAssume they are a skilled developer, but know almost nothing about our toolset or problem domain. Assume they don't know good test design very well.\n\n**Announce at start:** \"I'm using the writing-plans skill to create the implementation plan.\"\n\n**Save plans to:** `.claude/docs/plans/<feature-name>-plan.md`\n\n**Testing Strategy:** Auto-decide whether unit tests are needed based on complexity:\n\n- **Include tests for**: Complex algorithms, business logic, data transformations where bugs are likely\n- **Skip tests for**: Simple CRUD, UI components, straightforward mappings, anything you're 100% certain is bug-free\n- **Test type**: Only deterministic unit tests - no integration tests, no complex mocking, no async complexity\n- Tests should verify logic, not implementation details\n\n## Bite-Sized Task Granularity\n\n**Each step is one action (2-5 minutes):**\n\n**If tests are included (for complex behavior):**\n\n- \"Write the failing test\" - step\n- \"Run it to make sure it fails\" - step\n- \"Implement the minimal code to make the test pass\" - step\n- \"Run the tests and make sure they pass\" - step\n- \"Commit\" - step\n\n**If no tests (for simple changes):**\n\n- \"Implement the code\" - step\n- \"Verify with typecheck/lint\" - step\n- \"Commit\" - step\n\n## Plan Document Header\n\n**Every plan MUST start with this header:**\n\n```markdown\n# [Feature Name] Implementation Plan\n\n**Goal:** [One sentence describing what this builds]\n\n**Architecture:** [2-3 sentences about approach]\n\n**Tech Stack:** [Key technologies/libraries]\n\n**Testing Approach:** [If tests included: \"TDD with deterministic unit tests for complex logic (Tasks X, Y, Z)\" | If no tests: \"Code review and typecheck verification - logic is straightforward and bug-free\"]\n\n---\n```\n\n## Task Structure\n\n### With Tests (Complex Behavior)\n\n````markdown\n### Task N: [Component Name]\n\n**Files:**\n\n- Create: `exact/path/to/file.ts`\n- Modify: `exact/path/to/existing.ts:123-145`\n- Test: `tests/exact/path/to/test.spec.ts`\n\n**Step 1: Write the failing test**\n\n```typescript\ndescribe('specific behavior', () => {\n  it('should return expected result', () => {\n    const result = function(input);\n    expect(result).toBe(expected);\n  });\n});\n```\n\n**Step 2: Run test to verify it fails**\n\nRun: `npm run test -- test.spec.ts`\nExpected: FAIL with \"function is not defined\"\n\n**Step 3: Write minimal implementation**\n\n```typescript\nexport function function(input: InputType): ReturnType {\n  return expected;\n}\n```\n\n**Step 4: Run test to verify it passes**\n\nRun: `npm run test -- test.spec.ts`\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add tests/path/test.spec.ts src/path/file.ts\ngit commit -m \"feat: add specific feature\"\n```\n````\n\n### Without Tests (Simple Changes)\n\n````markdown\n### Task N: [Component Name]\n\n**Files:**\n\n- Create: `exact/path/to/file.ts`\n- Modify: `exact/path/to/existing.ts:123-145`\n\n**Step 1: Implement the code**\n\n```typescript\nexport function function(input: InputType): ReturnType {\n  return expected;\n}\n```\n\n**Step 2: Verify with typecheck**\n\nRun: `npm run typecheck`\nExpected: No errors\n\n**Step 3: Verify with lint**\n\nRun: `npm run lint`\nExpected: No errors\n\n**Step 4: Commit**\n\n```bash\ngit add src/path/file.ts\ngit commit -m \"feat: add specific feature\"\n```\n````\n\n## Remember\n\n- Auto-decide on unit tests - only for complex logic where bugs are likely\n- Only deterministic unit tests - no integration/async/complex mocking\n- Exact file paths always\n- Complete code in plan (not \"add validation\")\n- Exact commands with expected output\n- Reference relevant skills with @ syntax\n- DRY, YAGNI, frequent commits\n- TypeScript syntax for all examples\n\n## Git Commit Guidance\n\n**IMPORTANT: Plans include commit steps, but executing-plans will handle commit approval.**\n\n**During Execution (not plan writing):**\n\n- **NEVER auto-commit** - Even if plan includes commit commands, agent must ask user first\n- **When to suggest commits:**\n  - After completing batch where agent verified tests pass\n  - Leverage existing pause points (batch completion, not extra pauses)\n  - Only when agent can verify the work (tests, typecheck, lint)\n- **When NOT to suggest commits:**\n  - Tests are user's responsibility (agent can't verify)\n  - No natural pause point exists\n  - Manual verification required\n\n**In this skill (plan writing):**\n\n- Include commit steps in tasks as part of the plan\n- Commit commands show what should be committed, not when\n- executing-plans skill handles actual commit timing and user approval\n\n## Execution Handoff\n\nAfter saving the plan, offer execution choice:\n\n**\"Plan complete and saved to `.claude/docs/plans/<filename>.md`. Two execution options:**\n\n**1. This Session (default)** - Execute tasks iteratively in this session, reviewing and adjusting between tasks\n\n**2. Parallel Session** - Open new session with executing-plans skill for batch execution with checkpoints\n\n**Which approach? (Press Enter for option 1)\"**\n\n**If This Session (default):**\n\n- Use the superpowers executing-plans skill in this session\n- Execute in batches (default: first 3 tasks)\n- Review and iterate between batches\n- Adjust plan if needed based on learnings\n\n**If Parallel Session chosen:**\n\n- Guide them to open new session\n- **REQUIRED SUB-SKILL:** New session uses superpowers executing-plans\n- Load the plan file and execute in batches"
              }
            ]
          },
          {
            "name": "agents",
            "description": "Agent orchestration patterns for parallel debugging and investigation - dispatch multiple Claude agents to solve independent problems concurrently",
            "source": "./.claude-plugin/plugins/agents",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install agents@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/parallel",
                "description": "Dispatch multiple agents to solve independent problems concurrently",
                "path": ".claude-plugin/plugins/agents/commands/parallel.md",
                "frontmatter": {
                  "description": "Dispatch multiple agents to solve independent problems concurrently"
                },
                "content": "Use the dispatching-parallel-agents skill exactly as written"
              }
            ],
            "skills": [
              {
                "name": "dispatching-parallel-agents",
                "description": "Use when facing 3+ independent failures that can be investigated without shared state or dependencies - dispatches multiple Claude agents to investigate and fix independent problems concurrently",
                "path": ".claude-plugin/plugins/agents/skills/dispatching-parallel-agents/SKILL.md",
                "frontmatter": {
                  "name": "dispatching-parallel-agents",
                  "description": "Use when facing 3+ independent failures that can be investigated without shared state or dependencies - dispatches multiple Claude agents to investigate and fix independent problems concurrently"
                },
                "content": "# Dispatching Parallel Agents\n\n## Overview\n\nWhen you have multiple unrelated failures (different test files, different subsystems, different bugs), investigating them sequentially wastes time. Each investigation is independent and can happen in parallel.\n\n**Core principle:** Dispatch one agent per independent problem domain. Let them work concurrently.\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Multiple failures?\" [shape=diamond];\n    \"Are they independent?\" [shape=diamond];\n    \"Single agent investigates all\" [shape=box];\n    \"One agent per problem domain\" [shape=box];\n    \"Can they work in parallel?\" [shape=diamond];\n    \"Sequential agents\" [shape=box];\n    \"Parallel dispatch\" [shape=box];\n\n    \"Multiple failures?\" -> \"Are they independent?\" [label=\"yes\"];\n    \"Are they independent?\" -> \"Single agent investigates all\" [label=\"no - related\"];\n    \"Are they independent?\" -> \"Can they work in parallel?\" [label=\"yes\"];\n    \"Can they work in parallel?\" -> \"Parallel dispatch\" [label=\"yes\"];\n    \"Can they work in parallel?\" -> \"Sequential agents\" [label=\"no - shared state\"];\n}\n```\n\n**Use when:**\n\n- 3+ test files failing with different root causes\n- Multiple subsystems broken independently\n- Each problem can be understood without context from others\n- No shared state between investigations\n\n**Don't use when:**\n\n- Failures are related (fix one might fix others)\n- Need to understand full system state\n- Agents would interfere with each other\n\n## The Pattern\n\n### 1. Identify Independent Domains\n\nGroup failures by what's broken:\n\n- File A tests: Tool approval flow\n- File B tests: Batch completion behavior\n- File C tests: Abort functionality\n\nEach domain is independent - fixing tool approval doesn't affect abort tests.\n\n### 2. Create Focused Agent Tasks\n\nEach agent gets:\n\n- **Specific scope:** One test file or subsystem\n- **Clear goal:** Make these tests pass\n- **Constraints:** Don't change other code\n- **Expected output:** Summary of what you found and fixed\n\n### 3. Dispatch in Parallel\n\n```typescript\n// In Claude Code / AI environment\nTask(\"Fix agent-tool-abort.test.ts failures\");\nTask(\"Fix batch-completion-behavior.test.ts failures\");\nTask(\"Fix tool-approval-race-conditions.test.ts failures\");\n// All three run concurrently\n```\n\n### 4. Review and Integrate\n\nWhen agents return:\n\n- Read each summary\n- Verify fixes don't conflict\n- Run full test suite\n- Integrate all changes\n\n## Agent Prompt Structure\n\nGood agent prompts are:\n\n1. **Focused** - One clear problem domain\n2. **Self-contained** - All context needed to understand the problem\n3. **Specific about output** - What should the agent return?\n\n```markdown\nFix the 3 failing tests in src/agents/agent-tool-abort.test.ts:\n\n1. \"should abort tool with partial output capture\" - expects 'interrupted at' in message\n2. \"should handle mixed completed and aborted tools\" - fast tool aborted instead of completed\n3. \"should properly track pendingToolCount\" - expects 3 results but gets 0\n\nThese are timing/race condition issues. Your task:\n\n1. Read the test file and understand what each test verifies\n2. Identify root cause - timing issues or actual bugs?\n3. Fix by:\n   - Replacing arbitrary timeouts with event-based waiting\n   - Fixing bugs in abort implementation if found\n   - Adjusting test expectations if testing changed behavior\n\nDo NOT just increase timeouts - find the real issue.\n\nReturn: Summary of what you found and what you fixed.\n```\n\n## Common Mistakes\n\n**‚ùå Too broad:** \"Fix all the tests\" - agent gets lost\n**‚úÖ Specific:** \"Fix agent-tool-abort.test.ts\" - focused scope\n\n**‚ùå No context:** \"Fix the race condition\" - agent doesn't know where\n**‚úÖ Context:** Paste the error messages and test names\n\n**‚ùå No constraints:** Agent might refactor everything\n**‚úÖ Constraints:** \"Do NOT change production code\" or \"Fix tests only\"\n\n**‚ùå Vague output:** \"Fix it\" - you don't know what changed\n**‚úÖ Specific:** \"Return summary of root cause and changes\"\n\n## When NOT to Use\n\n**Related failures:** Fixing one might fix others - investigate together first\n**Need full context:** Understanding requires seeing entire system\n**Exploratory debugging:** You don't know what's broken yet\n**Shared state:** Agents would interfere (editing same files, using same resources)\n\n## Real Example from Session\n\n**Scenario:** 6 test failures across 3 files after major refactoring\n\n**Failures:**\n\n- agent-tool-abort.test.ts: 3 failures (timing issues)\n- batch-completion-behavior.test.ts: 2 failures (tools not executing)\n- tool-approval-race-conditions.test.ts: 1 failure (execution count = 0)\n\n**Decision:** Independent domains - abort logic separate from batch completion separate from race conditions\n\n**Dispatch:**\n\n```\nAgent 1 ‚Üí Fix agent-tool-abort.test.ts\nAgent 2 ‚Üí Fix batch-completion-behavior.test.ts\nAgent 3 ‚Üí Fix tool-approval-race-conditions.test.ts\n```\n\n**Results:**\n\n- Agent 1: Replaced timeouts with event-based waiting\n- Agent 2: Fixed event structure bug (threadId in wrong place)\n- Agent 3: Added wait for async tool execution to complete\n\n**Integration:** All fixes independent, no conflicts, full suite green\n\n**Time saved:** 3 problems solved in parallel vs sequentially\n\n## Key Benefits\n\n1. **Parallelization** - Multiple investigations happen simultaneously\n2. **Focus** - Each agent has narrow scope, less context to track\n3. **Independence** - Agents don't interfere with each other\n4. **Speed** - 3 problems solved in time of 1\n\n## Verification\n\nAfter agents return:\n\n1. **Review each summary** - Understand what changed\n2. **Check for conflicts** - Did agents edit same code?\n3. **Run full suite** - Verify all fixes work together\n4. **Spot check** - Agents can make systematic errors\n\n## Real-World Impact\n\nFrom debugging session (2025-10-03):\n\n- 6 failures across 3 files\n- 3 agents dispatched in parallel\n- All investigations completed concurrently\n- All fixes integrated successfully\n- Zero conflicts between agent changes"
              }
            ]
          },
          {
            "name": "debug",
            "description": "Systematic debugging and root cause analysis framework - four-phase investigation process ensuring understanding before fixes",
            "source": "./.claude-plugin/plugins/debug",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install debug@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/debug",
                "description": "Systematic four-phase debugging framework for finding root causes",
                "path": ".claude-plugin/plugins/debug/commands/debug.md",
                "frontmatter": {
                  "description": "Systematic four-phase debugging framework for finding root causes"
                },
                "content": "Use the systematic-debugging skill exactly as written"
              }
            ],
            "skills": [
              {
                "name": "root-cause-tracing",
                "description": "Use when errors occur deep in execution and you need to trace back to find the original trigger - systematically traces bugs backward through call stack, adding instrumentation when needed, to identify source of invalid data or incorrect behavior",
                "path": ".claude-plugin/plugins/debug/skills/root-cause-tracing/SKILL.md",
                "frontmatter": {
                  "name": "root-cause-tracing",
                  "description": "Use when errors occur deep in execution and you need to trace back to find the original trigger - systematically traces bugs backward through call stack, adding instrumentation when needed, to identify source of invalid data or incorrect behavior"
                },
                "content": "# Root Cause Tracing\n\n## Overview\n\nBugs often manifest deep in the call stack (git init in wrong directory, file created in wrong location, database opened with wrong path). Your instinct is to fix where the error appears, but that's treating a symptom.\n\n**Core principle:** Trace backward through the call chain until you find the original trigger, then fix at the source.\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Bug appears deep in stack?\" [shape=diamond];\n    \"Can trace backwards?\" [shape=diamond];\n    \"Fix at symptom point\" [shape=box];\n    \"Trace to original trigger\" [shape=box];\n    \"BETTER: Also add defense-in-depth\" [shape=box];\n\n    \"Bug appears deep in stack?\" -> \"Can trace backwards?\" [label=\"yes\"];\n    \"Can trace backwards?\" -> \"Trace to original trigger\" [label=\"yes\"];\n    \"Can trace backwards?\" -> \"Fix at symptom point\" [label=\"no - dead end\"];\n    \"Trace to original trigger\" -> \"BETTER: Also add defense-in-depth\";\n}\n```\n\n**Use when:**\n\n- Error happens deep in execution (not at entry point)\n- Stack trace shows long call chain\n- Unclear where invalid data originated\n- Need to find which test/code triggers the problem\n\n## The Tracing Process\n\n### 1. Observe the Symptom\n\n```\nError: git init failed in /Users/jesse/project/packages/core\n```\n\n### 2. Find Immediate Cause\n\n**What code directly causes this?**\n\n```typescript\nawait execFileAsync(\"git\", [\"init\"], { cwd: projectDir });\n```\n\n### 3. Ask: What Called This?\n\n```typescript\nWorktreeManager.createSessionWorktree(projectDir, sessionId)\n  ‚Üí called by Session.initializeWorkspace()\n  ‚Üí called by Session.create()\n  ‚Üí called by test at Project.create()\n```\n\n### 4. Keep Tracing Up\n\n**What value was passed?**\n\n- `projectDir = ''` (empty string!)\n- Empty string as `cwd` resolves to `process.cwd()`\n- That's the source code directory!\n\n### 5. Find Original Trigger\n\n**Where did empty string come from?**\n\n```typescript\nconst context = setupCoreTest(); // Returns { tempDir: '' }\nProject.create(\"name\", context.tempDir); // Accessed before beforeEach!\n```\n\n## Adding Stack Traces\n\nWhen you can't trace manually, add instrumentation:\n\n```typescript\n// Before the problematic operation\nasync function gitInit(directory: string) {\n  const stack = new Error().stack;\n  console.error(\"DEBUG git init:\", {\n    directory,\n    cwd: process.cwd(),\n    nodeEnv: process.env.NODE_ENV,\n    stack,\n  });\n\n  await execFileAsync(\"git\", [\"init\"], { cwd: directory });\n}\n```\n\n**Critical:** Use `console.error()` in tests (not logger - may not show)\n\n**Run and capture:**\n\n```bash\nnpm test 2>&1 | grep 'DEBUG git init'\n```\n\n**Analyze stack traces:**\n\n- Look for test file names\n- Find the line number triggering the call\n- Identify the pattern (same test? same parameter?)\n\n## Real Example: Empty projectDir\n\n**Symptom:** `.git` created in `packages/core/` (source code)\n\n**Trace chain:**\n\n1. `git init` runs in `process.cwd()` ‚Üê empty cwd parameter\n2. WorktreeManager called with empty projectDir\n3. Session.create() passed empty string\n4. Test accessed `context.tempDir` before beforeEach\n5. setupCoreTest() returns `{ tempDir: '' }` initially\n\n**Root cause:** Top-level variable initialization accessing empty value\n\n**Fix:** Made tempDir a getter that throws if accessed before beforeEach\n\n**Also added defense-in-depth:**\n\n- Layer 1: Project.create() validates directory\n- Layer 2: WorkspaceManager validates not empty\n- Layer 3: NODE_ENV guard refuses git init outside tmpdir\n- Layer 4: Stack trace logging before git init\n\n## Verification Strategy After Fix\n\n**Auto-decide on testing based on complexity:**\n\n**Write deterministic unit test for:**\n\n- Complex algorithms or business logic\n- Data transformations where bugs are likely\n- Critical paths that could break silently\n\n**Skip test for:**\n\n- UI components or React hooks\n- Simple CRUD operations\n- Straightforward mappings\n- Anything you're 100% certain is correct\n\n**If no test:**\n\n- Verify with typecheck/lint\n- Manual verification for UI changes\n- Code review confidence\n\n**Only deterministic unit tests** - no integration tests, no complex mocking, no async complexity.\n\n## Key Principle\n\n```dot\ndigraph principle {\n    \"Found immediate cause\" [shape=ellipse];\n    \"Can trace one level up?\" [shape=diamond];\n    \"Trace backwards\" [shape=box];\n    \"Is this the source?\" [shape=diamond];\n    \"Fix at source\" [shape=box];\n    \"Add validation at each layer\" [shape=box];\n    \"Bug impossible\" [shape=doublecircle];\n    \"NEVER fix just the symptom\" [shape=octagon, style=filled, fillcolor=red, fontcolor=white];\n\n    \"Found immediate cause\" -> \"Can trace one level up?\";\n    \"Can trace one level up?\" -> \"Trace backwards\" [label=\"yes\"];\n    \"Can trace one level up?\" -> \"NEVER fix just the symptom\" [label=\"no\"];\n    \"Trace backwards\" -> \"Is this the source?\";\n    \"Is this the source?\" -> \"Trace backwards\" [label=\"no - keeps going\"];\n    \"Is this the source?\" -> \"Fix at source\" [label=\"yes\"];\n    \"Fix at source\" -> \"Add validation at each layer\";\n    \"Add validation at each layer\" -> \"Bug impossible\";\n}\n```\n\n**NEVER fix just where the error appears.** Trace back to find the original trigger.\n\n## Stack Trace Tips\n\n**In tests:** Use `console.error()` not logger - logger may be suppressed\n**Before operation:** Log before the dangerous operation, not after it fails\n**Include context:** Directory, cwd, environment variables, timestamps\n**Capture stack:** `new Error().stack` shows complete call chain\n\n## Real-World Impact\n\nFrom debugging session (2025-10-03):\n\n- Found root cause through 5-level trace\n- Fixed at source (getter validation)\n- Added 4 layers of defense\n- 1847 tests passed, zero pollution"
              },
              {
                "name": "systematic-debugging",
                "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes - four-phase framework (root cause investigation, pattern analysis, hypothesis testing, implementation) that ensures understanding before attempting solutions",
                "path": ".claude-plugin/plugins/debug/skills/systematic-debugging/SKILL.md",
                "frontmatter": {
                  "name": "systematic-debugging",
                  "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes - four-phase framework (root cause investigation, pattern analysis, hypothesis testing, implementation) that ensures understanding before attempting solutions"
                },
                "content": "# Systematic Debugging\n\n## Overview\n\nRandom fixes waste time and create new bugs. Quick patches mask underlying issues.\n\n**Core principle:** ALWAYS find root cause before attempting fixes. Symptom fixes are failure.\n\n**Violating the letter of this process is violating the spirit of debugging.**\n\n## The Iron Law\n\n```\nNO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST\n```\n\nIf you haven't completed Phase 1, you cannot propose fixes.\n\n## When to Use\n\nUse for ANY technical issue:\n\n- Test failures\n- Bugs in production\n- Unexpected behavior\n- Performance problems\n- Build failures\n- Integration issues\n\n**Use this ESPECIALLY when:**\n\n- Under time pressure (emergencies make guessing tempting)\n- \"Just one quick fix\" seems obvious\n- You've already tried multiple fixes\n- Previous fix didn't work\n- You don't fully understand the issue\n\n**Don't skip when:**\n\n- Issue seems simple (simple bugs have root causes too)\n- You're in a hurry (rushing guarantees rework)\n- Manager wants it fixed NOW (systematic is faster than thrashing)\n\n## The Four Phases\n\nYou MUST complete each phase before proceeding to the next.\n\n### Phase 1: Root Cause Investigation\n\n**BEFORE attempting ANY fix:**\n\n1. **Read Error Messages Carefully**\n\n   - Don't skip past errors or warnings\n   - They often contain the exact solution\n   - Read stack traces completely\n   - Note line numbers, file paths, error codes\n\n2. **Reproduce Consistently**\n\n   - Can you trigger it reliably?\n   - What are the exact steps?\n   - Does it happen every time?\n   - If not reproducible ‚Üí gather more data, don't guess\n\n3. **Check Recent Changes**\n\n   - What changed that could cause this?\n   - Git diff, recent commits\n   - New dependencies, config changes\n   - Environmental differences\n\n4. **Gather Evidence in Multi-Component Systems**\n\n   **WHEN system has multiple components (CI ‚Üí build ‚Üí signing, API ‚Üí service ‚Üí database):**\n\n   **BEFORE proposing fixes, add diagnostic instrumentation:**\n\n   ```\n   For EACH component boundary:\n     - Log what data enters component\n     - Log what data exits component\n     - Verify environment/config propagation\n     - Check state at each layer\n\n   Run once to gather evidence showing WHERE it breaks\n   THEN analyze evidence to identify failing component\n   THEN investigate that specific component\n   ```\n\n   **Example (multi-layer system):**\n\n   ```bash\n   # Layer 1: Workflow\n   echo \"=== Secrets available in workflow: ===\"\n   echo \"IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}\"\n\n   # Layer 2: Build script\n   echo \"=== Env vars in build script: ===\"\n   env | grep IDENTITY || echo \"IDENTITY not in environment\"\n\n   # Layer 3: Signing script\n   echo \"=== Keychain state: ===\"\n   security list-keychains\n   security find-identity -v\n\n   # Layer 4: Actual signing\n   codesign --sign \"$IDENTITY\" --verbose=4 \"$APP\"\n   ```\n\n   **This reveals:** Which layer fails (secrets ‚Üí workflow ‚úì, workflow ‚Üí build ‚úó)\n\n5. **Trace Data Flow**\n\n   **WHEN error is deep in call stack:**\n\n   **REQUIRED SUB-SKILL:** Use superpowers root-cause-tracing for backward tracing technique\n\n   **Quick version:**\n\n   - Where does bad value originate?\n   - What called this with bad value?\n   - Keep tracing up until you find the source\n   - Fix at source, not at symptom\n\n### Phase 2: Pattern Analysis\n\n**Find the pattern before fixing:**\n\n1. **Find Working Examples**\n\n   - Locate similar working code in same codebase\n   - What works that's similar to what's broken?\n\n2. **Compare Against References**\n\n   - If implementing pattern, read reference implementation COMPLETELY\n   - Don't skim - read every line\n   - Understand the pattern fully before applying\n\n3. **Identify Differences**\n\n   - What's different between working and broken?\n   - List every difference, however small\n   - Don't assume \"that can't matter\"\n\n4. **Understand Dependencies**\n   - What other components does this need?\n   - What settings, config, environment?\n   - What assumptions does it make?\n\n### Phase 3: Hypothesis and Testing\n\n**Scientific method:**\n\n1. **Form Single Hypothesis**\n\n   - State clearly: \"I think X is the root cause because Y\"\n   - Write it down\n   - Be specific, not vague\n\n2. **Test Minimally**\n\n   - Make the SMALLEST possible change to test hypothesis\n   - One variable at a time\n   - Don't fix multiple things at once\n\n3. **Verify Before Continuing**\n\n   - Did it work? Yes ‚Üí Phase 4\n   - Didn't work? Form NEW hypothesis\n   - DON'T add more fixes on top\n\n4. **When You Don't Know**\n   - Say \"I don't understand X\"\n   - Don't pretend to know\n   - Ask for help\n   - Research more\n\n### Phase 4: Implementation\n\n**Fix the root cause, not the symptom:**\n\n1. **Decide on Testing Strategy**\n\n   **Auto-decide based on complexity:**\n\n   - **Write test for**: Complex algorithms, business logic, data transformations where bugs are likely\n   - **Skip test for**: UI components, React hooks, simple CRUD, straightforward mappings, anything you're 100% certain is correct\n   - **Test type**: Only deterministic unit tests - no integration tests, no complex mocking, no async complexity\n\n   **If writing test:**\n\n   - Simplest possible reproduction\n   - Automated test that fails before fix\n   - Verify logic, not implementation details\n\n   **If skipping test:**\n\n   - Verify fix with typecheck/lint\n   - Manual verification for UI changes\n   - Code review confidence that fix is correct\n\n2. **Implement Single Fix**\n\n   - Address the root cause identified\n   - ONE change at a time\n   - No \"while I'm here\" improvements\n   - No bundled refactoring\n\n3. **Verify Fix**\n\n   **If test was written:**\n\n   - Test passes now?\n   - No other tests broken?\n\n   **If no test:**\n\n   - Typecheck passes?\n   - Lint clean?\n   - Manual verification confirms fix?\n\n   **Always check:**\n\n   - Issue actually resolved?\n   - No regressions in related functionality?\n\n4. **If Fix Doesn't Work**\n\n   - STOP\n   - Count: How many fixes have you tried?\n   - If < 3: Return to Phase 1, re-analyze with new information\n   - **If ‚â• 3: STOP and question the architecture (step 5 below)**\n   - DON'T attempt Fix #4 without architectural discussion\n\n5. **If 3+ Fixes Failed: Question Architecture**\n\n   **Pattern indicating architectural problem:**\n\n   - Each fix reveals new shared state/coupling/problem in different place\n   - Fixes require \"massive refactoring\" to implement\n   - Each fix creates new symptoms elsewhere\n\n   **STOP and question fundamentals:**\n\n   - Is this pattern fundamentally sound?\n   - Are we \"sticking with it through sheer inertia\"?\n   - Should we refactor architecture vs. continue fixing symptoms?\n\n   **Discuss with your human partner before attempting more fixes**\n\n   This is NOT a failed hypothesis - this is a wrong architecture.\n\n## Red Flags - STOP and Follow Process\n\nIf you catch yourself thinking:\n\n- \"Quick fix for now, investigate later\"\n- \"Just try changing X and see if it works\"\n- \"Add multiple changes, run tests\"\n- \"It's probably X, let me fix that\"\n- \"I don't fully understand but this might work\"\n- \"Pattern says X but I'll adapt it differently\"\n- \"Here are the main problems: [lists fixes without investigation]\"\n- Proposing solutions before tracing data flow\n- **\"One more fix attempt\" (when already tried 2+)**\n- **Each fix reveals new problem in different place**\n- **Writing tests for UI components when you're certain the fix is correct**\n\n**ALL of these mean: STOP. Return to Phase 1.**\n\n**If 3+ fixes failed:** Question the architecture (see Phase 4.5)\n\n## your human partner's Signals You're Doing It Wrong\n\n**Watch for these redirections:**\n\n- \"Is that not happening?\" - You assumed without verifying\n- \"Will it show us...?\" - You should have added evidence gathering\n- \"Stop guessing\" - You're proposing fixes without understanding\n- \"Ultrathink this\" - Question fundamentals, not just symptoms\n- \"We're stuck?\" (frustrated) - Your approach isn't working\n\n**When you see these:** STOP. Return to Phase 1.\n\n## Common Rationalizations\n\n| Excuse                                       | Reality                                                                       |\n| -------------------------------------------- | ----------------------------------------------------------------------------- |\n| \"Issue is simple, don't need process\"        | Simple issues have root causes too. Process is fast for simple bugs.          |\n| \"Emergency, no time for process\"             | Systematic debugging is FASTER than guess-and-check thrashing.                |\n| \"Just try this first, then investigate\"      | First fix sets the pattern. Do it right from the start.                       |\n| \"Multiple fixes at once saves time\"          | Can't isolate what worked. Causes new bugs.                                   |\n| \"Reference too long, I'll adapt the pattern\" | Partial understanding guarantees bugs. Read it completely.                    |\n| \"I see the problem, let me fix it\"           | Seeing symptoms ‚â† understanding root cause.                                   |\n| \"One more fix attempt\" (after 2+ failures)   | 3+ failures = architectural problem. Question pattern, don't fix again.       |\n| \"UI fix doesn't need tests\"                  | Correct! UI components verified via typecheck/manual testing, not unit tests. |\n\n## Quick Reference\n\n| Phase                 | Key Activities                                         | Success Criteria            |\n| --------------------- | ------------------------------------------------------ | --------------------------- |\n| **1. Root Cause**     | Read errors, reproduce, check changes, gather evidence | Understand WHAT and WHY     |\n| **2. Pattern**        | Find working examples, compare                         | Identify differences        |\n| **3. Hypothesis**     | Form theory, test minimally                            | Confirmed or new hypothesis |\n| **4. Implementation** | Create test, fix, verify                               | Bug resolved, tests pass    |\n\n## When Process Reveals \"No Root Cause\"\n\nIf systematic investigation reveals issue is truly environmental, timing-dependent, or external:\n\n1. You've completed the process\n2. Document what you investigated\n3. Implement appropriate handling (retry, timeout, error message)\n4. Add monitoring/logging for future investigation\n\n**But:** 95% of \"no root cause\" cases are incomplete investigation.\n\n## Integration with Other Skills\n\n**This skill requires using:**\n\n- **root-cause-tracing** - REQUIRED when error is deep in call stack (see Phase 1, Step 5)\n\n**Testing skills (when needed):**\n\n- **test-driven-development** (if available) - Use when fixing complex business logic that needs test coverage\n- Skip for UI components, simple CRUD, or anything verifiable via typecheck/manual testing\n\n## Real-World Impact\n\nFrom debugging sessions:\n\n- Systematic approach: 15-30 minutes to fix\n- Random fixes approach: 2-3 hours of thrashing\n- First-time fix rate: 95% vs 40%\n- New bugs introduced: Near zero vs common"
              }
            ]
          },
          {
            "name": "test",
            "description": "Test-driven development workflow for writing tests before implementation - red-green-refactor cycle with deterministic unit tests",
            "source": "./.claude-plugin/plugins/test",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install test@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/tdd",
                "description": "Test-driven development workflow with red-green-refactor cycle",
                "path": ".claude-plugin/plugins/test/commands/tdd.md",
                "frontmatter": {
                  "description": "Test-driven development workflow with red-green-refactor cycle"
                },
                "content": "# Test-Driven Development (TDD)\n\n## Overview\n\nWrite the test first. Watch it fail. Write minimal code to pass.\n\n**Core principle:** If you didn't watch the test fail, you don't know if it tests the right thing.\n\n**When to use:** Only for complex logic where bugs are likely, or when user explicitly requests tests.\n\n## When to Use\n\n**Use TDD when:**\n\n1. **User explicitly requests tests**\n2. **Complex logic where bugs are likely:**\n   - Complex algorithms\n   - Business logic with edge cases\n   - Data transformations\n   - Critical paths that could break silently\n\n**Skip TDD for:**\n\n- ‚ùå UI components (React components, hooks)\n- ‚ùå Simple CRUD operations\n- ‚ùå Straightforward mappings\n- ‚ùå Anything you're 100% certain is correct\n- ‚ùå Throwaway prototypes\n- ‚ùå Configuration files\n\n**Verification alternatives when skipping:**\n\n- Typecheck with `npm run typecheck`\n- Lint with `npm run lint`\n- Manual testing for UI changes\n- Code review confidence\n\n## The Rule (When Using TDD)\n\n```\nWHEN WRITING TESTS: NO CODE WITHOUT A FAILING TEST FIRST\n```\n\n**When you've decided to use TDD** (complex logic, user request):\n\nWrite code before the test? Delete it. Start over.\n\n**No exceptions when using TDD:**\n\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n\nImplement fresh from tests. Period.\n\n**When NOT using TDD** (UI, simple code):\n\n- Write code directly\n- Verify with typecheck/lint\n- Skip the test\n\n## Red-Green-Refactor\n\n```dot\ndigraph tdd_cycle {\n    rankdir=LR;\n    red [label=\"RED\\nWrite failing test\", shape=box, style=filled, fillcolor=\"#ffcccc\"];\n    verify_red [label=\"Verify fails\\ncorrectly\", shape=diamond];\n    green [label=\"GREEN\\nMinimal code\", shape=box, style=filled, fillcolor=\"#ccffcc\"];\n    verify_green [label=\"Verify passes\\nAll green\", shape=diamond];\n    refactor [label=\"REFACTOR\\nClean up\", shape=box, style=filled, fillcolor=\"#ccccff\"];\n    next [label=\"Next\", shape=ellipse];\n\n    red -> verify_red;\n    verify_red -> green [label=\"yes\"];\n    verify_red -> red [label=\"wrong\\nfailure\"];\n    green -> verify_green;\n    verify_green -> refactor [label=\"yes\"];\n    verify_green -> green [label=\"no\"];\n    refactor -> verify_green [label=\"stay\\ngreen\"];\n    verify_green -> next;\n    next -> red;\n}\n```\n\n### RED - Write Failing Test\n\nWrite one minimal test showing what should happen.\n\n<Good>\n```typescript\ntest('retries failed operations 3 times', async () => {\n  let attempts = 0;\n  const operation = () => {\n    attempts++;\n    if (attempts < 3) throw new Error('fail');\n    return 'success';\n  };\n\nconst result = await retryOperation(operation);\n\nexpect(result).toBe('success');\nexpect(attempts).toBe(3);\n});\n\n````\nClear name, tests real behavior, one thing\n</Good>\n\n<Bad>\n```typescript\ntest('retry works', async () => {\n  const mock = jest.fn()\n    .mockRejectedValueOnce(new Error())\n    .mockRejectedValueOnce(new Error())\n    .mockResolvedValueOnce('success');\n  await retryOperation(mock);\n  expect(mock).toHaveBeenCalledTimes(3);\n});\n````\n\nVague name, tests mock not code\n</Bad>\n\n**Requirements:**\n\n- One behavior\n- Clear name\n- Real code (no mocks unless unavoidable)\n\n### Verify RED - Watch It Fail\n\n**MANDATORY. Never skip.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n\n- Test fails (not errors)\n- Failure message is expected\n- Fails because feature missing (not typos)\n\n**Test passes?** You're testing existing behavior. Fix test.\n\n**Test errors?** Fix error, re-run until it fails correctly.\n\n### GREEN - Minimal Code\n\nWrite simplest code to pass the test.\n\n<Good>\n```typescript\nasync function retryOperation<T>(fn: () => Promise<T>): Promise<T> {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await fn();\n    } catch (e) {\n      if (i === 2) throw e;\n    }\n  }\n  throw new Error('unreachable');\n}\n```\nJust enough to pass\n</Good>\n\n<Bad>\n```typescript\nasync function retryOperation<T>(\n  fn: () => Promise<T>,\n  options?: {\n    maxRetries?: number;\n    backoff?: 'linear' | 'exponential';\n    onRetry?: (attempt: number) => void;\n  }\n): Promise<T> {\n  // YAGNI\n}\n```\nOver-engineered\n</Bad>\n\nDon't add features, refactor other code, or \"improve\" beyond the test.\n\n### Verify GREEN - Watch It Pass\n\n**MANDATORY.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n\n- Test passes\n- Other tests still pass\n- Output pristine (no errors, warnings)\n\n**Test fails?** Fix code, not test.\n\n**Other tests fail?** Fix now.\n\n### REFACTOR - Clean Up\n\nAfter green only:\n\n- Remove duplication\n- Improve names\n- Extract helpers\n\nKeep tests green. Don't add behavior.\n\n### Repeat\n\nNext failing test for next feature.\n\n## Good Tests\n\n| Quality          | Good                                | Bad                                                 |\n| ---------------- | ----------------------------------- | --------------------------------------------------- |\n| **Minimal**      | One thing. \"and\" in name? Split it. | `test('validates email and domain and whitespace')` |\n| **Clear**        | Name describes behavior             | `test('test1')`                                     |\n| **Shows intent** | Demonstrates desired API            | Obscures what code should do                        |\n\n## Why Order Matters\n\n**\"I'll write tests after to verify it works\"**\n\nTests written after code pass immediately. Passing immediately proves nothing:\n\n- Might test wrong thing\n- Might test implementation, not behavior\n- Might miss edge cases you forgot\n- You never saw it catch the bug\n\nTest-first forces you to see the test fail, proving it actually tests something.\n\n**\"I already manually tested all the edge cases\"**\n\nManual testing is ad-hoc. You think you tested everything but:\n\n- No record of what you tested\n- Can't re-run when code changes\n- Easy to forget cases under pressure\n- \"It worked when I tried it\" ‚â† comprehensive\n\nAutomated tests are systematic. They run the same way every time.\n\n**\"Deleting X hours of work is wasteful\"**\n\nSunk cost fallacy. The time is already gone. Your choice now:\n\n- Delete and rewrite with TDD (X more hours, high confidence)\n- Keep it and add tests after (30 min, low confidence, likely bugs)\n\nThe \"waste\" is keeping code you can't trust. Working code without real tests is technical debt.\n\n**\"TDD is dogmatic, being pragmatic means adapting\"**\n\nTDD IS pragmatic:\n\n- Finds bugs before commit (faster than debugging after)\n- Prevents regressions (tests catch breaks immediately)\n- Documents behavior (tests show how to use code)\n- Enables refactoring (change freely, tests catch breaks)\n\n\"Pragmatic\" shortcuts = debugging in production = slower.\n\n**\"Tests after achieve the same goals - it's spirit not ritual\"**\n\nNo. Tests-after answer \"What does this do?\" Tests-first answer \"What should this do?\"\n\nTests-after are biased by your implementation. You test what you built, not what's required. You verify remembered edge cases, not discovered ones.\n\nTests-first force edge case discovery before implementing. Tests-after verify you remembered everything (you didn't).\n\n30 minutes of tests after ‚â† TDD. You get coverage, lose proof tests work.\n\n## Common Rationalizations (When TDD Applies)\n\n**Valid reasons to skip TDD:**\n| Reason | Reality |\n| ----------------------------- | ------------------------------------------------------------- |\n| \"This is a UI component\" | ‚úÖ Correct! Verify with typecheck/manual testing, skip tests. |\n| \"Simple CRUD, 100% confident\" | ‚úÖ Correct! Verify with typecheck/lint, skip tests. |\n| \"Straightforward mapping\" | ‚úÖ Correct! If truly simple, skip tests. |\n\n**Invalid rationalizations (for complex logic):**\n| Excuse | Reality |\n| -------------------------------------- | ----------------------------------------------------------------------- |\n| \"Too simple to test\" | If it's complex logic, test it. If truly simple, skip is fine. |\n| \"I'll test after\" | Tests passing immediately prove nothing. |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n| \"Already manually tested\" | Ad-hoc ‚â† systematic. No record, can't re-run. |\n| \"Deleting X hours is wasteful\" | Sunk cost fallacy. Keeping unverified code is technical debt. |\n| \"Keep as reference, write tests first\" | You'll adapt it. That's testing after. Delete means delete. |\n| \"Need to explore first\" | Fine. Throw away exploration, start with TDD. |\n| \"Test hard = design unclear\" | Listen to test. Hard to test = hard to use. |\n| \"TDD will slow me down\" | TDD faster than debugging. Pragmatic = test-first. |\n| \"Manual test faster\" | Manual doesn't prove edge cases. You'll re-test every change. |\n\n## Red Flags - When Using TDD\n\n**These only apply when you've decided to use TDD** (complex logic, user request):\n\n- Code before test\n- Test after implementation\n- Test passes immediately\n- Can't explain why test failed\n- Tests added \"later\"\n- \"Keep as reference\" or \"adapt existing code\"\n- \"Already spent X hours, deleting is wasteful\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n\n**Valid decision to skip TDD:**\n\n- ‚úÖ \"This is a UI component\" - Skip TDD, verify with typecheck\n- ‚úÖ \"Simple CRUD, 100% confident\" - Skip TDD, verify with lint\n- ‚úÖ \"Straightforward code\" - Skip TDD if truly simple\n\n## Example: Bug Fix\n\n**Bug:** Empty email accepted\n\n**RED**\n\n```typescript\ntest(\"rejects empty email\", async () => {\n  const result = await submitForm({ email: \"\" });\n  expect(result.error).toBe(\"Email required\");\n});\n```\n\n**Verify RED**\n\n```bash\n$ npm test\nFAIL: expected 'Email required', got undefined\n```\n\n**GREEN**\n\n```typescript\nfunction submitForm(data: FormData) {\n  if (!data.email?.trim()) {\n    return { error: \"Email required\" };\n  }\n  // ...\n}\n```\n\n**Verify GREEN**\n\n```bash\n$ npm test\nPASS\n```\n\n**REFACTOR**\nExtract validation for multiple fields if needed.\n\n## Verification Checklist\n\n**If using TDD** (complex logic, user request):\n\n- [ ] Every new complex function has a test\n- [ ] Watched each test fail before implementing\n- [ ] Each test failed for expected reason (feature missing, not typo)\n- [ ] Wrote minimal code to pass each test\n- [ ] All tests pass\n- [ ] Output pristine (no errors, warnings)\n- [ ] Tests use real code (mocks only if unavoidable)\n- [ ] Edge cases and errors covered\n\nCan't check all boxes? You skipped TDD. Start over.\n\n**If NOT using TDD** (UI, simple code):\n\n- [ ] Code is straightforward and you're 100% confident\n- [ ] `npm run typecheck` passes\n- [ ] `npm run lint` passes\n- [ ] Manual testing confirms UI works as expected\n- [ ] No complex business logic that needs test coverage\n\n## When Stuck\n\n| Problem                | Solution                                                             |\n| ---------------------- | -------------------------------------------------------------------- |\n| Don't know how to test | Write wished-for API. Write assertion first. Ask your human partner. |\n| Test too complicated   | Design too complicated. Simplify interface.                          |\n| Must mock everything   | Code too coupled. Use dependency injection.                          |\n| Test setup huge        | Extract helpers. Still complex? Simplify design.                     |\n\n## Debugging Integration\n\n**Bug in complex logic?**\nWrite failing test reproducing it. Follow TDD cycle. Test proves fix and prevents regression.\n\n**Bug in UI component or simple code?**\nFix directly. Verify with typecheck/lint/manual testing.\n\n**Decision criteria:**\n\n- Complex algorithm/business logic ‚Üí Write test\n- UI component/straightforward fix ‚Üí Skip test\n\n## Final Rules\n\n**When to use TDD:**\n\n1. **User explicitly requests tests**\n2. **Complex logic where bugs are likely** (algorithms, business logic, data transformations)\n\n**When to skip TDD:**\n\n- UI components (React components, hooks)\n- Simple CRUD operations\n- Straightforward mappings\n- Anything you're 100% certain is correct\n\n**If using TDD:**\n\n```\nProduction code ‚Üí test exists and failed first\nOtherwise ‚Üí not TDD\n```\n\n**If skipping TDD:**\n\n```\nProduction code ‚Üí typecheck + lint pass\nManual verification for UI changes\nCode review confidence\n```\n\n**Only deterministic unit tests** - no integration tests, no complex mocking, no async complexity."
              }
            ],
            "skills": [
              {
                "name": "test-driven-development",
                "description": "Use when implementing complex logic that needs test coverage - write the test first, watch it fail, write minimal code to pass; ensures tests actually verify behavior by requiring failure first; NOT for UI components, simple CRUD, or straightforward code",
                "path": ".claude-plugin/plugins/test/skills/test-driven-development/SKILL.md",
                "frontmatter": {
                  "name": "test-driven-development",
                  "description": "Use when implementing complex logic that needs test coverage - write the test first, watch it fail, write minimal code to pass; ensures tests actually verify behavior by requiring failure first; NOT for UI components, simple CRUD, or straightforward code"
                },
                "content": "# Test-Driven Development (TDD)\n\n## Overview\n\nWrite the test first. Watch it fail. Write minimal code to pass.\n\n**Core principle:** If you didn't watch the test fail, you don't know if it tests the right thing.\n\n**When to use:** Only for complex logic where bugs are likely, or when user explicitly requests tests.\n\n## When to Use\n\n**Use TDD when:**\n\n1. **User explicitly requests tests**\n2. **Complex logic where bugs are likely:**\n   - Complex algorithms\n   - Business logic with edge cases\n   - Data transformations\n   - Critical paths that could break silently\n\n**Skip TDD for:**\n\n- ‚ùå UI components (React components, hooks)\n- ‚ùå Simple CRUD operations\n- ‚ùå Straightforward mappings\n- ‚ùå Anything you're 100% certain is correct\n- ‚ùå Throwaway prototypes\n- ‚ùå Configuration files\n\n**Verification alternatives when skipping:**\n\n- Typecheck with `npm run typecheck`\n- Lint with `npm run lint`\n- Manual testing for UI changes\n- Code review confidence\n\n## The Rule (When Using TDD)\n\n```\nWHEN WRITING TESTS: NO CODE WITHOUT A FAILING TEST FIRST\n```\n\n**When you've decided to use TDD** (complex logic, user request):\n\nWrite code before the test? Delete it. Start over.\n\n**No exceptions when using TDD:**\n\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n\nImplement fresh from tests. Period.\n\n**When NOT using TDD** (UI, simple code):\n\n- Write code directly\n- Verify with typecheck/lint\n- Skip the test\n\n## Red-Green-Refactor\n\n```dot\ndigraph tdd_cycle {\n    rankdir=LR;\n    red [label=\"RED\\nWrite failing test\", shape=box, style=filled, fillcolor=\"#ffcccc\"];\n    verify_red [label=\"Verify fails\\ncorrectly\", shape=diamond];\n    green [label=\"GREEN\\nMinimal code\", shape=box, style=filled, fillcolor=\"#ccffcc\"];\n    verify_green [label=\"Verify passes\\nAll green\", shape=diamond];\n    refactor [label=\"REFACTOR\\nClean up\", shape=box, style=filled, fillcolor=\"#ccccff\"];\n    next [label=\"Next\", shape=ellipse];\n\n    red -> verify_red;\n    verify_red -> green [label=\"yes\"];\n    verify_red -> red [label=\"wrong\\nfailure\"];\n    green -> verify_green;\n    verify_green -> refactor [label=\"yes\"];\n    verify_green -> green [label=\"no\"];\n    refactor -> verify_green [label=\"stay\\ngreen\"];\n    verify_green -> next;\n    next -> red;\n}\n```\n\n### RED - Write Failing Test\n\nWrite one minimal test showing what should happen.\n\n<Good>\n```typescript\ntest('retries failed operations 3 times', async () => {\n  let attempts = 0;\n  const operation = () => {\n    attempts++;\n    if (attempts < 3) throw new Error('fail');\n    return 'success';\n  };\n\nconst result = await retryOperation(operation);\n\nexpect(result).toBe('success');\nexpect(attempts).toBe(3);\n});\n\n````\nClear name, tests real behavior, one thing\n</Good>\n\n<Bad>\n```typescript\ntest('retry works', async () => {\n  const mock = jest.fn()\n    .mockRejectedValueOnce(new Error())\n    .mockRejectedValueOnce(new Error())\n    .mockResolvedValueOnce('success');\n  await retryOperation(mock);\n  expect(mock).toHaveBeenCalledTimes(3);\n});\n````\n\nVague name, tests mock not code\n</Bad>\n\n**Requirements:**\n\n- One behavior\n- Clear name\n- Real code (no mocks unless unavoidable)\n\n### Verify RED - Watch It Fail\n\n**MANDATORY. Never skip.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n\n- Test fails (not errors)\n- Failure message is expected\n- Fails because feature missing (not typos)\n\n**Test passes?** You're testing existing behavior. Fix test.\n\n**Test errors?** Fix error, re-run until it fails correctly.\n\n### GREEN - Minimal Code\n\nWrite simplest code to pass the test.\n\n<Good>\n```typescript\nasync function retryOperation<T>(fn: () => Promise<T>): Promise<T> {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await fn();\n    } catch (e) {\n      if (i === 2) throw e;\n    }\n  }\n  throw new Error('unreachable');\n}\n```\nJust enough to pass\n</Good>\n\n<Bad>\n```typescript\nasync function retryOperation<T>(\n  fn: () => Promise<T>,\n  options?: {\n    maxRetries?: number;\n    backoff?: 'linear' | 'exponential';\n    onRetry?: (attempt: number) => void;\n  }\n): Promise<T> {\n  // YAGNI\n}\n```\nOver-engineered\n</Bad>\n\nDon't add features, refactor other code, or \"improve\" beyond the test.\n\n### Verify GREEN - Watch It Pass\n\n**MANDATORY.**\n\n```bash\nnpm test path/to/test.test.ts\n```\n\nConfirm:\n\n- Test passes\n- Other tests still pass\n- Output pristine (no errors, warnings)\n\n**Test fails?** Fix code, not test.\n\n**Other tests fail?** Fix now.\n\n### REFACTOR - Clean Up\n\nAfter green only:\n\n- Remove duplication\n- Improve names\n- Extract helpers\n\nKeep tests green. Don't add behavior.\n\n### Repeat\n\nNext failing test for next feature.\n\n## Good Tests\n\n| Quality          | Good                                | Bad                                                 |\n| ---------------- | ----------------------------------- | --------------------------------------------------- |\n| **Minimal**      | One thing. \"and\" in name? Split it. | `test('validates email and domain and whitespace')` |\n| **Clear**        | Name describes behavior             | `test('test1')`                                     |\n| **Shows intent** | Demonstrates desired API            | Obscures what code should do                        |\n\n## Why Order Matters\n\n**\"I'll write tests after to verify it works\"**\n\nTests written after code pass immediately. Passing immediately proves nothing:\n\n- Might test wrong thing\n- Might test implementation, not behavior\n- Might miss edge cases you forgot\n- You never saw it catch the bug\n\nTest-first forces you to see the test fail, proving it actually tests something.\n\n**\"I already manually tested all the edge cases\"**\n\nManual testing is ad-hoc. You think you tested everything but:\n\n- No record of what you tested\n- Can't re-run when code changes\n- Easy to forget cases under pressure\n- \"It worked when I tried it\" ‚â† comprehensive\n\nAutomated tests are systematic. They run the same way every time.\n\n**\"Deleting X hours of work is wasteful\"**\n\nSunk cost fallacy. The time is already gone. Your choice now:\n\n- Delete and rewrite with TDD (X more hours, high confidence)\n- Keep it and add tests after (30 min, low confidence, likely bugs)\n\nThe \"waste\" is keeping code you can't trust. Working code without real tests is technical debt.\n\n**\"TDD is dogmatic, being pragmatic means adapting\"**\n\nTDD IS pragmatic:\n\n- Finds bugs before commit (faster than debugging after)\n- Prevents regressions (tests catch breaks immediately)\n- Documents behavior (tests show how to use code)\n- Enables refactoring (change freely, tests catch breaks)\n\n\"Pragmatic\" shortcuts = debugging in production = slower.\n\n**\"Tests after achieve the same goals - it's spirit not ritual\"**\n\nNo. Tests-after answer \"What does this do?\" Tests-first answer \"What should this do?\"\n\nTests-after are biased by your implementation. You test what you built, not what's required. You verify remembered edge cases, not discovered ones.\n\nTests-first force edge case discovery before implementing. Tests-after verify you remembered everything (you didn't).\n\n30 minutes of tests after ‚â† TDD. You get coverage, lose proof tests work.\n\n## Common Rationalizations (When TDD Applies)\n\n**Valid reasons to skip TDD:**\n| Reason | Reality |\n| ----------------------------- | ------------------------------------------------------------- |\n| \"This is a UI component\" | ‚úÖ Correct! Verify with typecheck/manual testing, skip tests. |\n| \"Simple CRUD, 100% confident\" | ‚úÖ Correct! Verify with typecheck/lint, skip tests. |\n| \"Straightforward mapping\" | ‚úÖ Correct! If truly simple, skip tests. |\n\n**Invalid rationalizations (for complex logic):**\n| Excuse | Reality |\n| -------------------------------------- | ----------------------------------------------------------------------- |\n| \"Too simple to test\" | If it's complex logic, test it. If truly simple, skip is fine. |\n| \"I'll test after\" | Tests passing immediately prove nothing. |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n| \"Already manually tested\" | Ad-hoc ‚â† systematic. No record, can't re-run. |\n| \"Deleting X hours is wasteful\" | Sunk cost fallacy. Keeping unverified code is technical debt. |\n| \"Keep as reference, write tests first\" | You'll adapt it. That's testing after. Delete means delete. |\n| \"Need to explore first\" | Fine. Throw away exploration, start with TDD. |\n| \"Test hard = design unclear\" | Listen to test. Hard to test = hard to use. |\n| \"TDD will slow me down\" | TDD faster than debugging. Pragmatic = test-first. |\n| \"Manual test faster\" | Manual doesn't prove edge cases. You'll re-test every change. |\n\n## Red Flags - When Using TDD\n\n**These only apply when you've decided to use TDD** (complex logic, user request):\n\n- Code before test\n- Test after implementation\n- Test passes immediately\n- Can't explain why test failed\n- Tests added \"later\"\n- \"Keep as reference\" or \"adapt existing code\"\n- \"Already spent X hours, deleting is wasteful\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n\n**Valid decision to skip TDD:**\n\n- ‚úÖ \"This is a UI component\" - Skip TDD, verify with typecheck\n- ‚úÖ \"Simple CRUD, 100% confident\" - Skip TDD, verify with lint\n- ‚úÖ \"Straightforward code\" - Skip TDD if truly simple\n\n## Example: Bug Fix\n\n**Bug:** Empty email accepted\n\n**RED**\n\n```typescript\ntest(\"rejects empty email\", async () => {\n  const result = await submitForm({ email: \"\" });\n  expect(result.error).toBe(\"Email required\");\n});\n```\n\n**Verify RED**\n\n```bash\n$ npm test\nFAIL: expected 'Email required', got undefined\n```\n\n**GREEN**\n\n```typescript\nfunction submitForm(data: FormData) {\n  if (!data.email?.trim()) {\n    return { error: \"Email required\" };\n  }\n  // ...\n}\n```\n\n**Verify GREEN**\n\n```bash\n$ npm test\nPASS\n```\n\n**REFACTOR**\nExtract validation for multiple fields if needed.\n\n## Verification Checklist\n\n**If using TDD** (complex logic, user request):\n\n- [ ] Every new complex function has a test\n- [ ] Watched each test fail before implementing\n- [ ] Each test failed for expected reason (feature missing, not typo)\n- [ ] Wrote minimal code to pass each test\n- [ ] All tests pass\n- [ ] Output pristine (no errors, warnings)\n- [ ] Tests use real code (mocks only if unavoidable)\n- [ ] Edge cases and errors covered\n\nCan't check all boxes? You skipped TDD. Start over.\n\n**If NOT using TDD** (UI, simple code):\n\n- [ ] Code is straightforward and you're 100% confident\n- [ ] `npm run typecheck` passes\n- [ ] `npm run lint` passes\n- [ ] Manual testing confirms UI works as expected\n- [ ] No complex business logic that needs test coverage\n\n## When Stuck\n\n| Problem                | Solution                                                             |\n| ---------------------- | -------------------------------------------------------------------- |\n| Don't know how to test | Write wished-for API. Write assertion first. Ask your human partner. |\n| Test too complicated   | Design too complicated. Simplify interface.                          |\n| Must mock everything   | Code too coupled. Use dependency injection.                          |\n| Test setup huge        | Extract helpers. Still complex? Simplify design.                     |\n\n## Debugging Integration\n\n**Bug in complex logic?**\nWrite failing test reproducing it. Follow TDD cycle. Test proves fix and prevents regression.\n\n**Bug in UI component or simple code?**\nFix directly. Verify with typecheck/lint/manual testing.\n\n**Decision criteria:**\n\n- Complex algorithm/business logic ‚Üí Write test\n- UI component/straightforward fix ‚Üí Skip test\n\n## Final Rules\n\n**When to use TDD:**\n\n1. **User explicitly requests tests**\n2. **Complex logic where bugs are likely** (algorithms, business logic, data transformations)\n\n**When to skip TDD:**\n\n- UI components (React components, hooks)\n- Simple CRUD operations\n- Straightforward mappings\n- Anything you're 100% certain is correct\n\n**If using TDD:**\n\n```\nProduction code ‚Üí test exists and failed first\nOtherwise ‚Üí not TDD\n```\n\n**If skipping TDD:**\n\n```\nProduction code ‚Üí typecheck + lint pass\nManual verification for UI changes\nCode review confidence\n```\n\n**Only deterministic unit tests** - no integration tests, no complex mocking, no async complexity."
              }
            ]
          },
          {
            "name": "skills",
            "description": "Meta-skills for finding, using, and writing Agent Skills - enforces skill usage protocols and provides skill authoring guidance",
            "source": "./.claude-plugin/plugins/skills",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install skills@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/use-skills",
                "description": "Enforce skill usage protocols and mandatory workflows",
                "path": ".claude-plugin/plugins/skills/commands/use-skills.md",
                "frontmatter": {
                  "description": "Enforce skill usage protocols and mandatory workflows"
                },
                "content": "Use the using-skills skill exactly as written"
              },
              {
                "name": "/write-skills",
                "description": "Enforce skill writing protocols",
                "path": ".claude-plugin/plugins/skills/commands/write-skills.md",
                "frontmatter": {
                  "description": "Enforce skill writing protocols"
                },
                "content": "# Writing Rules\n\n## Overview\n\n**Writing rules (skills + always-apply rules) IS Test-Driven Development applied to process documentation.**\n\n**Rules are maintained in `.claude/rules/` as MDC files with frontmatter. Ruler processes rules based on `alwaysApply`:**\n\n- `alwaysApply: false` (or omitted) ‚Üí generates `.claude/skills/` (context-loaded)\n- `alwaysApply: true` ‚Üí merged into `AGENTS.md` (always present)\n\n**How it works:**\n\n1. Write rule as `.mdc` file in `.claude/rules/` with frontmatter (`alwaysApply: true/false`)\n2. **REQUIRED:** Run `npx skiller@latest apply` after ANY rule creation or update\n3. Ruler processes based on `alwaysApply`:\n   - `false` ‚Üí generates `.claude/skills/` (context-loaded by Claude Code)\n   - `true` ‚Üí merges into `AGENTS.md` (always present)\n4. Optionally add `globs` for file pattern matching\n\nYou identify common failure patterns (baseline behavior), write the skill (documentation) addressing those patterns, then verify through application scenarios, and refactor (close loopholes).\n\n**Core principle:** If you didn't identify what agents naturally do wrong, you don't know if the skill prevents the right failures.\n\n**REQUIRED BACKGROUND:** You MUST understand test-driven-development before using this skill. That skill defines the fundamental RED-GREEN-REFACTOR cycle. This skill adapts TDD to documentation.\n\n**Official guidance:** For Anthropic's official skill authoring best practices, see anthropic-best-practices.md. This document provides additional patterns and guidelines that complement the TDD-focused approach in this skill.\n\n## What is a Skill?\n\nA **skill** is a reference guide for proven techniques, patterns, or tools. Skills help future Claude instances find and apply effective approaches.\n\n**Skills are:** Reusable techniques, patterns, tools, reference guides\n\n**Skills are NOT:** Narratives about how you solved a problem once\n\n## TDD Mapping for Skills\n\n| TDD Concept             | Skill Creation                                   |\n| ----------------------- | ------------------------------------------------ |\n| **Test case**           | Anticipated failure pattern from experience      |\n| **Production code**     | Skill document (.mdc file in .claude/rules/)     |\n| **Test fails (RED)**    | Identify common mistakes without skill           |\n| **Test passes (GREEN)** | Skill addresses those specific mistakes          |\n| **Refactor**            | Close loopholes while maintaining clarity        |\n| **Write test first**    | Identify failure patterns BEFORE writing skill   |\n| **Watch it fail**       | Document exact rationalizations from experience  |\n| **Minimal code**        | Write skill addressing those specific violations |\n| **Watch it pass**       | Verify skill clarity through application         |\n| **Refactor cycle**      | Find new rationalizations ‚Üí plug ‚Üí re-verify     |\n\nThe entire skill creation process follows RED-GREEN-REFACTOR.\n\n## When to Create a Skill\n\n**Create when:**\n\n- Technique wasn't intuitively obvious to you\n- You'd reference this again across projects\n- Pattern applies broadly (not project-specific)\n- Others would benefit\n\n**Don't create for:**\n\n- One-off solutions\n- Standard practices well-documented elsewhere\n- Project-specific conventions (put in CLAUDE.md)\n\n## Skill Types\n\n### Technique\n\nConcrete method with steps to follow (condition-based-waiting, root-cause-tracing)\n\n### Pattern\n\nWay of thinking about problems (flatten-with-flags, test-invariants)\n\n### Reference\n\nAPI docs, syntax guides, tool documentation (office docs)\n\n## Directory Structure\n\n**Single-file skills** (default):\n\n```\n.claude/rules/\n  skill-name.mdc         # MDC file with frontmatter\n```\n\n**Multi-file skills** (only if >1 file needed):\n\n```\n.claude/rules/\n  skill-name/\n    skill-name.mdc       # Main skill (same basename as folder)\n    supporting-file.*    # Additional files\n```\n\n**Ruler auto-generates from rules** - `npx skiller@latest apply` creates `.claude/skills/` from `.claude/rules/`\n\n**When to use folders:**\n\n- **Heavy reference** (100+ lines) - API docs, comprehensive syntax\n- **Reusable tools** - Scripts, utilities, templates\n- **Multiple files** - Anything requiring >1 file\n\n**Single .mdc file when:**\n\n- All content fits inline\n- No external scripts or heavy reference\n- Principles, concepts, code patterns (< 50 lines)\n\n## MDC File Structure\n\n**MDC format** (.mdc files) with **frontmatter**:\n\n**Frontmatter fields:**\n\n- `name`: Skill identifier (letters, numbers, hyphens only)\n- `description`: Discovery text (max 1024 chars total for frontmatter)\n  - Start with \"Use when...\" to focus on triggering conditions\n  - Include specific symptoms, situations, contexts\n  - Written in third person\n  - Keep under 500 characters if possible\n- `alwaysApply`: Must be `false` or omitted (ruler only generates skills from non-always rules)\n\n```markdown\n---\nname: skill-name-with-hyphens\ndescription: Use when [specific triggering conditions and symptoms] - [what the skill does and how it helps, written in third person]\nalwaysApply: false\n---\n\n# Skill Name\n\n## Overview\n\nWhat is this? Core principle in 1-2 sentences.\n\n## When to Use\n\n[Small inline flowchart IF decision non-obvious]\n\nBullet list with SYMPTOMS and use cases\nWhen NOT to use\n\n## Core Pattern (for techniques/patterns)\n\nBefore/after code comparison\n\n## Quick Reference\n\nTable or bullets for scanning common operations\n\n## Implementation\n\nInline code for simple patterns\nLink to file for heavy reference or reusable tools\n\n## Common Mistakes\n\nWhat goes wrong + fixes\n\n## Real-World Impact (optional)\n\nConcrete results\n```\n\n## Claude Search Optimization (CSO)\n\n**Critical for discovery:** Future Claude needs to FIND your skill\n\n### 1. Rich Description Field\n\n**Purpose:** Claude reads description to decide which skills to load for a given task. Make it answer: \"Should I read this skill right now?\"\n\n**Format:** Start with \"Use when...\" to focus on triggering conditions, then explain what it does\n\n**Content:**\n\n- Use concrete triggers, symptoms, and situations that signal this skill applies\n- Describe the _problem_ (race conditions, inconsistent behavior) not _language-specific symptoms_ (setTimeout, sleep)\n- Keep triggers technology-agnostic unless the skill itself is technology-specific\n- If skill is technology-specific, make that explicit in the trigger\n- Write in third person (injected into system prompt)\n\n```yaml\n# ‚ùå BAD: Too abstract, vague, doesn't include when to use\ndescription: For async testing\n\n# ‚ùå BAD: First person\ndescription: I can help you with async tests when they're flaky\n\n# ‚ùå BAD: Mentions technology but skill isn't specific to it\ndescription: Use when tests use setTimeout/sleep and are flaky\n\n# ‚úÖ GOOD: Starts with \"Use when\", describes problem, then what it does\ndescription: Use when tests have race conditions, timing dependencies, or pass/fail inconsistently - replaces arbitrary timeouts with condition polling for reliable async tests\n\n# ‚úÖ GOOD: Technology-specific skill with explicit trigger\ndescription: Use when using React Router and handling authentication redirects - provides patterns for protected routes and auth state management\n```\n\n### 2. Keyword Coverage\n\nUse words Claude would search for:\n\n- Error messages: \"Hook timed out\", \"ENOTEMPTY\", \"race condition\"\n- Symptoms: \"flaky\", \"hanging\", \"zombie\", \"pollution\"\n- Synonyms: \"timeout/hang/freeze\", \"cleanup/teardown/afterEach\"\n- Tools: Actual commands, library names, file types\n\n### 3. Descriptive Naming\n\n**Use active voice, verb-first:**\n\n- ‚úÖ `creating-skills` not `skill-creation`\n- ‚úÖ `writing-rules` not `rule-writing`\n\n### 4. Token Efficiency (Critical)\n\n**Problem:** getting-started and frequently-referenced skills load into EVERY conversation. Every token counts.\n\n**Target word counts:**\n\n- getting-started workflows: <150 words each\n- Frequently-loaded skills: <200 words total\n- Other skills: <500 words (still be concise)\n\n**Techniques:**\n\n**Move details to tool help:**\n\n```bash\n# ‚ùå BAD: Document all flags in SKILL.md\nsearch-conversations supports --text, --both, --after DATE, --before DATE, --limit N\n\n# ‚úÖ GOOD: Reference --help\nsearch-conversations supports multiple modes and filters. Run --help for details.\n```\n\n**Use cross-references:**\n\n```markdown\n# ‚ùå BAD: Repeat workflow details\n\nWhen implementing feature, follow these 20 steps...\n[20 lines of repeated instructions from another skill]\n\n# ‚úÖ GOOD: Reference other skill\n\nFor implementation workflow, REQUIRED: Use [other-skill-name] for complete process.\n```\n\n**Compress examples:**\n\n```markdown\n# ‚ùå BAD: Verbose example (42 words)\n\nyour human partner: \"How did we handle authentication errors in React Router before?\"\nYou: I'll search for React Router authentication patterns in our codebase and documentation to find previous implementations.\n[Detailed explanation of search process...]\n\n# ‚úÖ GOOD: Minimal example (15 words)\n\nPartner: \"How did we handle auth errors in React Router?\"\nYou: [Search codebase ‚Üí provide solution]\n```\n\n**Eliminate redundancy:**\n\n- Don't repeat what's in cross-referenced skills\n- Don't explain what's obvious from command\n- Don't include multiple examples of same pattern\n\n**Verification:**\n\n```bash\nwc -w .claude/rules/skill-name.mdc\n# getting-started workflows: aim for <150 each\n# Other frequently-loaded: aim for <200 total\n```\n\n**Name by what you DO or core insight:**\n\n- ‚úÖ `condition-based-waiting` > `async-test-helpers`\n- ‚úÖ `using-skills` not `skill-usage`\n- ‚úÖ `flatten-with-flags` > `data-structure-refactoring`\n- ‚úÖ `root-cause-tracing` > `debugging-techniques`\n\n**Gerunds (-ing) work well for processes:**\n\n- `creating-skills`, `testing-skills`, `debugging-with-logs`\n- Active, describes the action you're taking\n\n### 4. Cross-Referencing Other Skills\n\n**When writing documentation that references other skills:**\n\nUse skill name only, with explicit requirement markers:\n\n- ‚úÖ Good: `**REQUIRED SUB-SKILL:** Use superpowers test-driven-development`\n- ‚úÖ Good: `**REQUIRED BACKGROUND:** You MUST understand superpowers systematic-debugging`\n- ‚ùå Bad: `See .claude/rules/test-driven-development.mdc` (unclear if required)\n- ‚ùå Bad: `@.claude/rules/test-driven-development.mdc` (force-loads, burns context)\n\n**Why no @ links:** `@` syntax force-loads files immediately, consuming 200k+ context before you need them.\n\n## Flowchart Usage\n\n```dot\ndigraph when_flowchart {\n    \"Need to show information?\" [shape=diamond];\n    \"Decision where I might go wrong?\" [shape=diamond];\n    \"Use markdown\" [shape=box];\n    \"Small inline flowchart\" [shape=box];\n\n    \"Need to show information?\" -> \"Decision where I might go wrong?\" [label=\"yes\"];\n    \"Decision where I might go wrong?\" -> \"Small inline flowchart\" [label=\"yes\"];\n    \"Decision where I might go wrong?\" -> \"Use markdown\" [label=\"no\"];\n}\n```\n\n**Use flowcharts ONLY for:**\n\n- Non-obvious decision points\n- Process loops where you might stop too early\n- \"When to use A vs B\" decisions\n\n**Never use flowcharts for:**\n\n- Reference material ‚Üí Tables, lists\n- Code examples ‚Üí Markdown blocks\n- Linear instructions ‚Üí Numbered lists\n- Labels without semantic meaning (step1, helper2)\n\nSee @graphviz-conventions.dot for graphviz style rules.\n\n## Code Examples\n\n**One excellent example beats many mediocre ones**\n\nChoose most relevant language:\n\n- Testing techniques ‚Üí TypeScript/JavaScript\n- System debugging ‚Üí Shell/Python\n- Data processing ‚Üí Python\n\n**Good example:**\n\n- Complete and runnable\n- Well-commented explaining WHY\n- From real scenario\n- Shows pattern clearly\n- Ready to adapt (not generic template)\n\n**Don't:**\n\n- Implement in 5+ languages\n- Create fill-in-the-blank templates\n- Write contrived examples\n\nYou're good at porting - one great example is enough.\n\n## File Organization\n\n### Self-Contained Skill (Default)\n\n```\n.claude/rules/\n  defense-in-depth.mdc    # Everything inline\n```\n\n**When:** All content fits, no heavy reference needed\n\n### Skill with Reusable Tool\n\n```\n.claude/rules/\n  condition-based-waiting/\n    condition-based-waiting.mdc  # Overview + patterns\n    example.ts                   # Working helpers to adapt\n```\n\n**When:** Tool is reusable code, not just narrative\n\n### Skill with Heavy Reference\n\n```\n.claude/rules/\n  pptx/\n    pptx.mdc       # Overview + workflows\n    pptxgenjs.md   # 600 lines API reference\n    ooxml.md       # 500 lines XML structure\n    scripts/       # Executable tools\n```\n\n**When:** Reference material too large for inline\n\n**Note:** Ruler copies all files from skill folder to `.claude/skills/` when `.mdc` basename matches folder name\n\n## The Iron Law (Same as TDD)\n\n```\nNO SKILL WITHOUT IDENTIFYING FAILURE PATTERNS FIRST\n```\n\nThis applies to NEW skills AND EDITS to existing skills.\n\nWrite skill before identifying what it prevents? Delete it. Start over.\nEdit skill without identifying new failure patterns? Same violation.\n\n**No exceptions:**\n\n- Not for \"simple additions\"\n- Not for \"just adding a section\"\n- Not for \"documentation updates\"\n- Don't keep unverified changes as \"reference\"\n- Don't \"adapt\" while applying\n- Delete means delete\n\n**REQUIRED BACKGROUND:** The test-driven-development skill explains why this matters. Same principles apply to documentation.\n\n## Verifying All Skill Types\n\nDifferent skill types need different verification approaches:\n\n### Discipline-Enforcing Skills (rules/requirements)\n\n**Verify with:**\n\n- Anticipate academic questions: Does skill explain the rules clearly?\n- Anticipate pressure scenarios: Does skill address rationalizations under stress?\n- Identify multiple pressures: time + sunk cost + exhaustion\n- Add explicit counters for each rationalization\n\n**Success criteria:** Skill prevents violations under anticipated pressures\n\n### Technique Skills (how-to guides)\n\n**Examples:** condition-based-waiting, root-cause-tracing, defensive-programming\n\n**Verify with:**\n\n- Application to real scenarios: Does skill guide correctly?\n- Variation scenarios: Does skill cover edge cases?\n- Gap analysis: Are common use cases covered?\n\n**Success criteria:** Skill enables successful technique application\n\n### Pattern Skills (mental models)\n\n**Examples:** reducing-complexity, information-hiding concepts\n\n**Verify with:**\n\n- Recognition guidance: Does skill explain when pattern applies?\n- Application examples: Does skill show how to use the mental model?\n- Counter-examples: Does skill clarify when NOT to apply?\n\n**Success criteria:** Skill enables correct pattern recognition and application\n\n### Reference Skills (documentation/APIs)\n\n**Examples:** API documentation, command references, library guides\n\n**Verify with:**\n\n- Information retrieval: Is right information findable?\n- Application examples: Are use cases clear and correct?\n- Gap analysis: Are common scenarios covered?\n\n**Success criteria:** Skill enables finding and correctly applying information\n\n## Common Rationalizations for Skipping Verification\n\n| Excuse                          | Reality                                                                 |\n| ------------------------------- | ----------------------------------------------------------------------- |\n| \"Skill is obviously clear\"      | Clear to you ‚â† clear to other agents. Verify it.                        |\n| \"It's just a reference\"         | References can have gaps, unclear sections. Verify information access.  |\n| \"Verification is overkill\"      | Unverified skills have issues. Always. 15 min verification saves hours. |\n| \"I'll verify if problems arise\" | Problems = agents can't use skill. Verify BEFORE deploying.             |\n| \"Too tedious to verify\"         | Verification is less tedious than debugging bad skill in production.    |\n| \"I'm confident it's good\"       | Overconfidence guarantees issues. Verify anyway.                        |\n| \"Academic review is enough\"     | Reading ‚â† using. Verify through application.                            |\n| \"No time to verify\"             | Deploying unverified skill wastes more time fixing it later.            |\n\n**All of these mean: Verify before deploying. No exceptions.**\n\n## Bulletproofing Skills Against Rationalization\n\nSkills that enforce discipline (like TDD) need to resist rationalization. Agents are smart and will find loopholes when under pressure.\n\n**Psychology note:** Understanding WHY persuasion techniques work helps you apply them systematically. See persuasion-principles.md for research foundation (Cialdini, 2021; Meincke et al., 2025) on authority, commitment, scarcity, social proof, and unity principles.\n\n### Meta-Verification (When Application Reveals Gaps)\n\n**After applying skill and finding it unclear, ask yourself:**\n\n```markdown\nI read the skill and still chose wrong approach.\n\nHow could that skill have been written differently to make\nit crystal clear what the correct choice was?\n```\n\n**Three possible answers:**\n\n1. **\"The skill WAS clear, I chose to ignore it\"**\n\n   - Not documentation problem\n   - Need stronger foundational principle\n   - Add \"Violating letter is violating spirit\"\n\n2. **\"The skill should have said X\"**\n\n   - Documentation problem\n   - Add that guidance verbatim\n\n3. **\"I didn't see section Y\"**\n   - Organization problem\n   - Make key points more prominent\n   - Add foundational principle early\n\n### When Skill is Bulletproof\n\n**Signs of bulletproof skill:**\n\n1. **Correct choice is obvious** even under pressure\n2. **Skill anticipates** the specific rationalizations\n3. **Red flags section** catches you before violation\n4. **Meta-verification reveals** \"skill was clear, I should follow it\"\n\n**Not bulletproof if:**\n\n- You find new rationalizations during application\n- Skill leaves room for \"hybrid approaches\"\n- Multiple valid interpretations exist\n- Doesn't address \"spirit vs letter\" argument\n\n### Example: Bulletproofing Process\n\n**Initial Version (Failed):**\n\n```markdown\nScenario: 200 lines done, forgot rule, exhausted, dinner plans\nApplied skill: Still chose wrong approach\nRationalization: \"Already achieve same goals differently\"\n```\n\n**Iteration 1 - Add Counter:**\n\n```markdown\nAdded section: \"Why This Specific Approach Matters\"\nRe-applied: STILL chose wrong approach\nNew rationalization: \"Spirit not letter\"\n```\n\n**Iteration 2 - Add Foundational Principle:**\n\n```markdown\nAdded: \"Violating letter is violating spirit\"\nRe-applied: Chose correct approach\nCited: New principle directly\nMeta-verification: \"Skill was clear, I should follow it\"\n```\n\n**Bulletproof achieved.**\n\n### Close Every Loophole Explicitly\n\nDon't just state the rule - forbid specific workarounds:\n\n<Bad>\n```markdown\nWrite code before test? Delete it.\n```\n</Bad>\n\n<Good>\n```markdown\nWrite code before test? Delete it. Start over.\n\n**No exceptions:**\n\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing tests\n- Don't look at it\n- Delete means delete\n\n````\n</Good>\n\n### Address \"Spirit vs Letter\" Arguments\n\nAdd foundational principle early:\n\n```markdown\n**Violating the letter of the rules is violating the spirit of the rules.**\n````\n\nThis cuts off entire class of \"I'm following the spirit\" rationalizations.\n\n### Build Rationalization Table\n\nCapture rationalizations from baseline testing (see Testing section below). Every excuse agents make goes in the table:\n\n```markdown\n| Excuse                           | Reality                                                                 |\n| -------------------------------- | ----------------------------------------------------------------------- |\n| \"Too simple to test\"             | Simple code breaks. Test takes 30 seconds.                              |\n| \"I'll test after\"                | Tests passing immediately prove nothing.                                |\n| \"Tests after achieve same goals\" | Tests-after = \"what does this do?\" Tests-first = \"what should this do?\" |\n```\n\n### Create Red Flags List\n\nMake it easy for agents to self-check when rationalizing:\n\n```markdown\n## Red Flags - STOP and Start Over\n\n- Code before test\n- \"I already manually tested it\"\n- \"Tests after achieve the same purpose\"\n- \"It's about spirit not ritual\"\n- \"This is different because...\"\n\n**All of these mean: Delete code. Start over with TDD.**\n```\n\n### Update CSO for Violation Symptoms\n\nAdd to description: symptoms of when you're ABOUT to violate the rule:\n\n```yaml\ndescription: use when implementing any feature or bugfix, before writing implementation code\n```\n\n## RED-GREEN-REFACTOR for Skills\n\nFollow the TDD cycle:\n\n### RED: Identify Failure Patterns (Baseline)\n\nBefore writing skill, identify what goes wrong without it:\n\n**Process:**\n\n- [ ] **Identify common mistakes** - What goes wrong without this skill?\n- [ ] **Document rationalizations** - What excuses lead to these mistakes (verbatim)?\n- [ ] **Identify pressures** - Which scenarios trigger violations?\n- [ ] **Note patterns** - Which excuses appear repeatedly?\n\n**Anticipate pressure scenarios** - Think through realistic situations with multiple pressures:\n\n```markdown\nExample pressure scenario (3+ combined pressures):\n\nYou spent 3 hours, 200 lines, manually tested. It works.\nIt's 6pm, dinner at 6:30pm. Code review tomorrow 9am.\nJust realized you forgot [rule from skill].\n\nOptions:\nA) Delete 200 lines, start fresh tomorrow following rule\nB) Commit now, address rule tomorrow\nC) Apply rule now (30 min delay)\n\nWithout skill: Agent likely chooses B or C\nRationalizations: \"Already working\", \"Tests after achieve same goals\", \"Deleting is wasteful\"\n```\n\n**Pressure Types to Consider:**\n\n| Pressure       | Example                                    |\n| -------------- | ------------------------------------------ |\n| **Time**       | Emergency, deadline, deploy window closing |\n| **Sunk cost**  | Hours of work, \"waste\" to delete           |\n| **Authority**  | Senior says skip it, manager overrides     |\n| **Economic**   | Job, promotion, company survival at stake  |\n| **Exhaustion** | End of day, already tired, want to go home |\n| **Social**     | Looking dogmatic, seeming inflexible       |\n| **Pragmatic**  | \"Being pragmatic vs dogmatic\"              |\n\n**Best scenarios combine 3+ pressures.**\n\n### GREEN: Write Minimal Skill\n\nWrite skill that addresses those specific rationalizations. Don't add extra content for hypothetical cases.\n\n**Verify through application**: Apply skill to real scenarios in this session. Does it make the correct choice obvious? Does it address the rationalizations you identified?\n\n### REFACTOR: Close Loopholes\n\nFound new rationalizations during application? Add explicit counter. Re-verify until bulletproof.\n\n**For each new rationalization, add:**\n\n1. **Explicit Negation in Rules**\n\n```markdown\nRule before test? Delete it. Start over.\n\n**No exceptions:**\n\n- Don't keep it as \"reference\"\n- Don't \"adapt\" it while writing\n- Don't look at it\n- Delete means delete\n```\n\n2. **Entry in Rationalization Table**\n\n```markdown\n| Excuse              | Reality                                                          |\n| ------------------- | ---------------------------------------------------------------- |\n| \"Keep as reference\" | You'll adapt it. That's violating the rule. Delete means delete. |\n```\n\n3. **Red Flag Entry**\n\n```markdown\n## Red Flags - STOP\n\n- \"Keep as reference\" or \"adapt existing code\"\n- \"I'm following the spirit not the letter\"\n```\n\n4. **Update description** - Add symptoms of ABOUT to violate:\n\n```yaml\ndescription: Use when [about to violate], when tempted to [rationalization]...\n```\n\n## Anti-Patterns\n\n### ‚ùå Narrative Example\n\n\"In session 2025-10-03, we found empty projectDir caused...\"\n**Why bad:** Too specific, not reusable\n\n### ‚ùå Multi-Language Dilution\n\nexample-js.js, example-py.py, example-go.go\n**Why bad:** Mediocre quality, maintenance burden\n\n### ‚ùå Code in Flowcharts\n\n```dot\nstep1 [label=\"import fs\"];\nstep2 [label=\"read file\"];\n```\n\n**Why bad:** Can't copy-paste, hard to read\n\n### ‚ùå Generic Labels\n\nhelper1, helper2, step3, pattern4\n**Why bad:** Labels should have semantic meaning\n\n## STOP: Before Moving to Next Skill\n\n**After writing ANY skill, you MUST STOP and complete the deployment process.**\n\n**Do NOT:**\n\n- Create multiple skills in batch without testing each\n- Move to next skill before current one is verified\n- Skip testing because \"batching is more efficient\"\n\n**The deployment checklist below is MANDATORY for EACH skill.**\n\nDeploying untested skills = deploying untested code. It's a violation of quality standards.\n\n## Skill Creation Checklist (TDD Adapted)\n\n**IMPORTANT: Use TodoWrite to create todos for EACH checklist item below.**\n\n**RED Phase - Identify Failure Patterns:**\n\n- [ ] Document common mistakes from experience (what goes wrong without this skill?)\n- [ ] Identify rationalizations that lead to mistakes (verbatim phrases)\n- [ ] Identify pressures that trigger violations (time, sunk cost, \"already working\", etc.)\n\n**GREEN Phase - Write Minimal Skill:**\n\n- [ ] Name uses only letters, numbers, hyphens (no parentheses/special chars)\n- [ ] YAML frontmatter with only name and description (max 1024 chars)\n- [ ] Description starts with \"Use when...\" and includes specific triggers/symptoms\n- [ ] Description written in third person\n- [ ] Keywords throughout for search (errors, symptoms, tools)\n- [ ] Clear overview with core principle\n- [ ] Address specific baseline failures identified in RED\n- [ ] Code inline OR link to separate file\n- [ ] One excellent example (not multi-language)\n- [ ] **MANDATORY:** Run `npx skiller@latest apply` to generate .claude/skills/\n- [ ] Verify skill clarity through application to real scenarios\n\n**REFACTOR Phase - Close Loopholes:**\n\n- [ ] Identify NEW rationalizations during application\n- [ ] Add explicit counters (if discipline skill)\n- [ ] Build rationalization table from all identified patterns\n- [ ] Create red flags list\n- [ ] **MANDATORY:** Run `npx skiller@latest apply` after ANY changes\n- [ ] Re-verify clarity and completeness\n\n**Quality Checks:**\n\n- [ ] Small flowchart only if decision non-obvious\n- [ ] Quick reference table\n- [ ] Common mistakes section\n- [ ] No narrative storytelling\n- [ ] Supporting files only for tools or heavy reference\n\n**Deployment:**\n\n- [ ] Skill is ready for use\n\n## Discovery Workflow\n\nHow future Claude finds your skill:\n\n1. **Encounters problem** (\"tests are flaky\")\n2. **Finds SKILL** (description matches)\n3. **Scans overview** (is this relevant?)\n4. **Reads patterns** (quick reference table)\n5. **Loads example** (only when implementing)\n\n**Optimize for this flow** - put searchable terms early and often.\n\n## The Bottom Line\n\n**Creating skills IS TDD for process documentation.**\n\nSame Iron Law: No skill without identifying failure patterns first.\nSame cycle: RED (identify patterns) ‚Üí GREEN (write skill) ‚Üí REFACTOR (close loopholes).\nSame benefits: Better quality, fewer surprises, bulletproof results.\n\nIf you follow TDD for code, follow it for skills. It's the same discipline applied to documentation."
              }
            ],
            "skills": [
              {
                "name": "using-skills",
                "description": "Use when starting any conversation - establishes mandatory workflows for finding and using skills, including using Skill tool before announcing usage, alignment before implementation, and creating TodoWrite todos for checklists",
                "path": ".claude-plugin/plugins/skills/skills/using-skills/SKILL.md",
                "frontmatter": {
                  "name": "using-skills",
                  "description": "Use when starting any conversation - establishes mandatory workflows for finding and using skills, including using Skill tool before announcing usage, alignment before implementation, and creating TodoWrite todos for checklists"
                },
                "content": "<EXTREMELY-IMPORTANT>\nIf you think there is even a 1% chance a skill might apply to what you are doing, you ABSOLUTELY MUST read the skill.\n\nIF A SKILL APPLIES TO YOUR TASK, YOU DO NOT HAVE A CHOICE. YOU MUST USE IT.\n\nThis is not negotiable. This is not optional. You cannot rationalize your way out of this.\n</EXTREMELY-IMPORTANT>\n\n# Getting Started with Skills\n\n## MANDATORY FIRST RESPONSE PROTOCOL\n\nBefore responding to ANY user message, you MUST complete this checklist:\n\n1. ‚òê List available skills in your mind\n2. ‚òê Ask yourself: \"Does ANY skill match this request?\"\n3. ‚òê If yes ‚Üí Use the Skill tool to read and run the skill file\n4. ‚òê Announce which skill you're using\n5. ‚òê Follow the skill exactly\n\n**Responding WITHOUT completing this checklist = automatic failure.**\n\n## Critical Rules\n\n1. **Follow mandatory workflows.** Check for relevant skills before ANY task.\n\n2. Execute skills with the Skill tool\n\n## Before Coding\n\n**What did you understand about what I just said to you?**\n\n**How will you go about implementing it?**\n\nPlease provide:\n\n1. **Clear understanding**: Restate what you think I'm asking for\n2. **Step-by-step plan**: Exactly how you will implement it\n3. **File changes**: Which files you'll modify/create and what changes\n4. **Potential issues**: Any risks, dependencies, or considerations\n5. **Success criteria**: How we'll know it's working correctly\n\n**CRITICAL**: Please wait for my review and confirmation before beginning your implementation. Do not start coding until I approve your plan.\n\nThis ensures we're aligned before you begin work and prevents miscommunication or wasted effort.\n\n## Common Rationalizations That Mean You're About To Fail\n\nIf you catch yourself thinking ANY of these thoughts, STOP. You are rationalizing. Check for and use the skill.\n\n- \"This is just a simple question\" ‚Üí WRONG. Questions are tasks. Check for skills.\n- \"I can check git/files quickly\" ‚Üí WRONG. Files don't have conversation context. Check for skills.\n- \"Let me gather information first\" ‚Üí WRONG. Skills tell you HOW to gather information. Check for skills.\n- \"This doesn't need a formal skill\" ‚Üí WRONG. If a skill exists for it, use it.\n- \"I remember this skill\" ‚Üí WRONG. Skills evolve. Run the current version.\n- \"This doesn't count as a task\" ‚Üí WRONG. If you're taking action, it's a task. Check for skills.\n- \"The skill is overkill for this\" ‚Üí WRONG. Skills exist because simple things become complex. Use it.\n- \"I'll just do this one thing first\" ‚Üí WRONG. Check for skills BEFORE doing anything.\n\n**Why:** Skills document proven techniques that save time and prevent mistakes. Not using available skills means repeating solved problems and making known errors.\n\nIf a skill for your task exists, you must use it or you will fail at your task.\n\n## Skills with Checklists\n\nIf a skill has a checklist, YOU MUST create TodoWrite todos for EACH item.\n\n**Don't:**\n\n- Work through checklist mentally\n- Skip creating todos \"to save time\"\n- Batch multiple items into one todo\n- Mark complete without doing them\n\n**Why:** Checklists without TodoWrite tracking = steps get skipped. Every time. The overhead of TodoWrite is tiny compared to the cost of missing steps.\n\n# About these skills\n\n**Many skills contain rigid rules (debugging, verification, service patterns).** Follow them exactly. Don't adapt away the discipline.\n\n**Some skills are flexible patterns (architecture, naming).** Adapt core principles to your context.\n\nThe skill itself tells you which type it is.\n\n## Instructions ‚â† Permission to Skip Workflows\n\nYour human partner's specific instructions describe WHAT to do, not HOW.\n\n\"Add X\", \"Fix Y\" = the goal, NOT permission to skip verification, alignment, or proper implementation patterns.\n\n**Red flags:** \"Instruction was specific\" ‚Ä¢ \"Seems simple\" ‚Ä¢ \"Workflow is overkill\"\n\n**Why:** Specific instructions mean clear requirements, which is when workflows matter MOST. Skipping process on \"simple\" tasks is how simple tasks become complex problems.\n\n## Summary\n\n**Starting any task:**\n\n1. If relevant skill exists ‚Üí Use the skill\n2. Announce you're using it\n3. Follow what it says\n\n**Skill has checklist?** TodoWrite for every item.\n\n**Finding a relevant skill = mandatory to read and use it. Not optional.**"
              }
            ]
          },
          {
            "name": "git",
            "description": "Git and GitHub workflow automation - streamlined PR creation, draft management, and code review workflows",
            "source": "./.claude-plugin/plugins/git",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add udecode/dotai",
              "/plugin install git@dotai"
            ],
            "signals": {
              "stars": 1120,
              "forks": 83,
              "pushed_at": "2025-12-17T16:03:16Z",
              "created_at": "2024-09-05T23:16:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/create-pr",
                "description": "Create or update PR with comprehensive descriptions and automatic code review",
                "path": ".claude-plugin/plugins/git/commands/create-pr.md",
                "frontmatter": {
                  "description": "Create or update PR with comprehensive descriptions and automatic code review"
                },
                "content": "You are an expert Git and GitHub workflow automation specialist with deep knowledge of version control best practices and pull request management. Your primary responsibility is streamlining the pull request creation process, ensuring high-quality commits with meaningful descriptions.\n\n## Common Operations\n\n### GitHub CLI Commands Reference\n\n```bash\n# PR Management\ngh pr view                                    # View current branch PR\ngh pr list                                    # List open PRs\ngh pr view <number> --json number -q .number # Get PR number\ngh pr create --title \"\" --body \"\"            # Create new PR\ngh pr edit --body \"\"                         # Update description\ngh pr edit --add-label \"\"                    # Add labels\n\n# Git Commands\ngit branch --show-current                    # Current branch\ngit status                                   # Check changes\ngit diff                                     # View unstaged changes\ngit diff --cached                           # View staged changes\ngit diff HEAD~1..HEAD                       # Last commit diff\ngit rev-parse HEAD                          # Get commit SHA\ngit log -1 --pretty=%s                      # Last commit message\n```\n\n## Workflow\n\n### Creating/Updating Pull Requests\n\n1. **Branch Management**:\n\n   - Check current branch: `git branch --show-current`\n   - If on main/master/next, create feature branch with conventional naming\n   - Switch to new branch: `git checkout -b branch-name`\n\n2. **Analyze & Stage**:\n\n   - Review changes: `git status` and `git diff`\n   - Identify change type (feature, fix, refactor, docs, test, chore)\n   - Stage ALL changes: `git add .` (preferred due to slow Husky hooks)\n   - Verify: `git diff --cached`\n\n3. **Commit & Push**:\n\n   - **Single Commit Strategy**: Use one comprehensive commit per push due to slow Husky hooks\n   - Format: `type: brief description` (simple format preferred)\n   - Commit: `git commit -m \"type: description\"` with average git comment\n   - Push: `git push -u origin branch-name`\n\n4. **PR Management**:\n\n   - Check existing: `gh pr view`\n   - If exists: push updates, **add update comment** (preserve original description)\n   - If not: `gh pr create` with title and description\n\n## Update Comment Templates\n\nWhen updating existing PRs, use these comment templates to preserve the original description:\n\n### General PR Update Template\n\n```markdown\n## üîÑ PR Update\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Changes Made\n\n- [List specific changes in this update]\n- [Highlight any breaking changes]\n- [Note new features or fixes]\n\n### Impact\n\n- [Areas of code affected]\n- [Performance/behavior changes]\n- [Dependencies updated]\n\n### Testing\n\n- [How to test these changes]\n- [Regression testing notes]\n\n### Next Steps\n\n- [Remaining work if any]\n- [Items for review focus]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Critical Fix Update Template\n\n```markdown\n## üö® Critical Fix Applied\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Issue Addressed\n\n[Description of critical issue fixed]\n\n### Solution\n\n[Technical approach taken]\n\n### Verification Steps\n\n1. [Step to reproduce original issue]\n2. [Step to verify fix]\n3. [Regression test steps]\n\n### Risk Assessment\n\n- **Impact**: [Low/Medium/High]\n- **Scope**: [Files/features affected]\n- **Backwards Compatible**: [Yes/No - details if no]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Feature Enhancement Template\n\n```markdown\n## ‚ú® Feature Enhancement\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Enhancement Details\n\n[Description of feature improvement/addition]\n\n### Technical Implementation\n\n- [Key architectural decisions]\n- [New dependencies or patterns]\n- [Performance considerations]\n\n### User Experience Impact\n\n[How this affects end users]\n\n### Testing Strategy\n\n[Approach to testing this enhancement]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n## Example Usage Patterns\n\n### Creating PR:\n\n1. Create branch and make changes\n2. Stage, commit, push ‚Üí triggers PR creation\n3. Each subsequent push triggers update comment\n\n### Commit Message Conventions\n\n- `feat:` - New features\n- `fix:` - Bug fixes\n- `refactor:` - Code refactoring\n- `docs:` - Documentation changes\n- `test:` - Test additions/modifications\n- `chore:` - Maintenance tasks\n- `style:` - Formatting changes\n\n### Branch Naming Conventions\n\n- `feature/description` - New features\n- `fix/bug-description` - Bug fixes\n- `refactor/component-name` - Code refactoring\n- `docs/update-readme` - Documentation updates\n- `test/add-unit-tests` - Test additions"
              },
              {
                "name": "/draft-pr",
                "description": "Create or update draft PR without code review for work-in-progress",
                "path": ".claude-plugin/plugins/git/commands/draft-pr.md",
                "frontmatter": {
                  "description": "Create or update draft PR without code review for work-in-progress"
                },
                "content": "Use the drafting-pr skill exactly as written"
              },
              {
                "name": "/review-pr",
                "description": "Review pull request with comprehensive code analysis and constructive feedback",
                "path": ".claude-plugin/plugins/git/commands/review-pr.md",
                "frontmatter": {
                  "description": "Review pull request with comprehensive code analysis and constructive feedback"
                },
                "content": "Use the reviewing-pr skill exactly as written"
              }
            ],
            "skills": [
              {
                "name": "creating-pr",
                "description": "Use when creating or updating pull requests with comprehensive descriptions and meaningful commits - streamlines PR workflow with branch management and commit best practices",
                "path": ".claude-plugin/plugins/git/skills/creating-pr/SKILL.md",
                "frontmatter": {
                  "name": "creating-pr",
                  "description": "Use when creating or updating pull requests with comprehensive descriptions and meaningful commits - streamlines PR workflow with branch management and commit best practices"
                },
                "content": "You are an expert Git and GitHub workflow automation specialist with deep knowledge of version control best practices and pull request management. Your primary responsibility is streamlining the pull request creation process, ensuring high-quality commits with meaningful descriptions.\n\n## Common Operations\n\n### GitHub CLI Commands Reference\n\n```bash\n# PR Management\ngh pr view                                    # View current branch PR\ngh pr list                                    # List open PRs\ngh pr view <number> --json number -q .number # Get PR number\ngh pr create --title \"\" --body \"\"            # Create new PR\ngh pr edit --body \"\"                         # Update description\ngh pr edit --add-label \"\"                    # Add labels\n\n# Git Commands\ngit branch --show-current                    # Current branch\ngit status                                   # Check changes\ngit diff                                     # View unstaged changes\ngit diff --cached                           # View staged changes\ngit diff HEAD~1..HEAD                       # Last commit diff\ngit rev-parse HEAD                          # Get commit SHA\ngit log -1 --pretty=%s                      # Last commit message\n```\n\n## Workflow\n\n### Creating/Updating Pull Requests\n\n1. **Branch Management**:\n\n   - Check current branch: `git branch --show-current`\n   - If on main/master/next, create feature branch with conventional naming\n   - Switch to new branch: `git checkout -b branch-name`\n\n2. **Analyze & Stage**:\n\n   - Review changes: `git status` and `git diff`\n   - Identify change type (feature, fix, refactor, docs, test, chore)\n   - Stage ALL changes: `git add .` (preferred due to slow Husky hooks)\n   - Verify: `git diff --cached`\n\n3. **Commit & Push**:\n\n   - **Single Commit Strategy**: Use one comprehensive commit per push due to slow Husky hooks\n   - Format: `type: brief description` (simple format preferred)\n   - Commit: `git commit -m \"type: description\"` with average git comment\n   - Push: `git push -u origin branch-name`\n\n4. **PR Management**:\n\n   - Check existing: `gh pr view`\n   - If exists: push updates, **add update comment** (preserve original description)\n   - If not: `gh pr create` with title and description\n\n## Update Comment Templates\n\nWhen updating existing PRs, use these comment templates to preserve the original description:\n\n### General PR Update Template\n\n```markdown\n## üîÑ PR Update\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Changes Made\n\n- [List specific changes in this update]\n- [Highlight any breaking changes]\n- [Note new features or fixes]\n\n### Impact\n\n- [Areas of code affected]\n- [Performance/behavior changes]\n- [Dependencies updated]\n\n### Testing\n\n- [How to test these changes]\n- [Regression testing notes]\n\n### Next Steps\n\n- [Remaining work if any]\n- [Items for review focus]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Critical Fix Update Template\n\n```markdown\n## üö® Critical Fix Applied\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Issue Addressed\n\n[Description of critical issue fixed]\n\n### Solution\n\n[Technical approach taken]\n\n### Verification Steps\n\n1. [Step to reproduce original issue]\n2. [Step to verify fix]\n3. [Regression test steps]\n\n### Risk Assessment\n\n- **Impact**: [Low/Medium/High]\n- **Scope**: [Files/features affected]\n- **Backwards Compatible**: [Yes/No - details if no]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Feature Enhancement Template\n\n```markdown\n## ‚ú® Feature Enhancement\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Enhancement Details\n\n[Description of feature improvement/addition]\n\n### Technical Implementation\n\n- [Key architectural decisions]\n- [New dependencies or patterns]\n- [Performance considerations]\n\n### User Experience Impact\n\n[How this affects end users]\n\n### Testing Strategy\n\n[Approach to testing this enhancement]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n## Example Usage Patterns\n\n### Creating PR:\n\n1. Create branch and make changes\n2. Stage, commit, push ‚Üí triggers PR creation\n3. Each subsequent push triggers update comment\n\n### Commit Message Conventions\n\n- `feat:` - New features\n- `fix:` - Bug fixes\n- `refactor:` - Code refactoring\n- `docs:` - Documentation changes\n- `test:` - Test additions/modifications\n- `chore:` - Maintenance tasks\n- `style:` - Formatting changes\n\n### Branch Naming Conventions\n\n- `feature/description` - New features\n- `fix/bug-description` - Bug fixes\n- `refactor/component-name` - Code refactoring\n- `docs/update-readme` - Documentation updates\n- `test/add-unit-tests` - Test additions"
              },
              {
                "name": "drafting-pr",
                "description": "Use when creating or updating draft pull requests without code review - streamlines draft PR workflow with meaningful descriptions and commit messages, focusing on work-in-progress documentation",
                "path": ".claude-plugin/plugins/git/skills/drafting-pr/SKILL.md",
                "frontmatter": {
                  "name": "drafting-pr",
                  "description": "Use when creating or updating draft pull requests without code review - streamlines draft PR workflow with meaningful descriptions and commit messages, focusing on work-in-progress documentation"
                },
                "content": "You are an expert Git and GitHub workflow automation specialist focused on streamlining draft pull request creation and management. Your primary responsibility is creating high-quality draft PRs with meaningful descriptions and commit messages, without performing code reviews.\n\n## Key Behavior: Draft PR Management\n\n**FOCUS**: Create and update draft pull requests efficiently without automatic reviews. Reviews should only be performed when explicitly requested.\n\n## Common Operations\n\n### GitHub CLI Commands Reference\n\n```bash\n# PR Management\ngh pr view                                    # View current branch PR\ngh pr list                                    # List open PRs\ngh pr view <number> --json number -q .number # Get PR number\ngh pr create --draft --title \"\" --body \"\"    # Create new draft PR\ngh pr ready <number>                          # Mark PR as ready for review\ngh pr edit --body \"\"                         # Update description\ngh pr edit --add-label \"\"                    # Add labels\n\n# Git Commands\ngit branch --show-current                    # Current branch\ngit status                                   # Check changes\ngit diff                                     # View unstaged changes\ngit diff --cached                           # View staged changes\ngit diff HEAD~1..HEAD                       # Last commit diff\ngit rev-parse HEAD                          # Get commit SHA\ngit log -1 --pretty=%s                      # Last commit message\n```\n\n## Workflow: Creating/Updating Draft PRs\n\n### 1. Branch Management\n\n- Check current branch: `git branch --show-current`\n- If on main/master/next, create feature branch with conventional naming\n- Switch to new branch: `git checkout -b branch-name`\n\n### 2. Analyze & Stage Changes\n\n- Review changes: `git status` and `git diff`\n- Identify change type (feature, fix, refactor, docs, test, chore)\n- Stage ALL changes: `git add .` (preferred due to slow Husky hooks)\n- Verify: `git diff --cached`\n\n### 3. Commit & Push\n\n- **Single Commit Strategy**: Use one comprehensive commit per push due to slow Husky hooks\n- Format: `type: brief description` (simple format preferred)\n- Commit: `git commit -m \"type: description\"` with average git comment\n- Push: `git push -u origin branch-name`\n\n### 4. Draft PR Management\n\n- Check existing: `gh pr view`\n- If exists: push updates, **add update comment** (preserve original description)\n- If not: `gh pr create --draft` with comprehensive title and description\n\n## PR Description Template\n\nUse this template for creating comprehensive draft PR descriptions:\n\n```markdown\n## Summary\n\n[Brief description of what this PR accomplishes]\n\n## Changes Made\n\n- [List key changes made]\n- [Include file modifications]\n- [Highlight new features/fixes]\n\n## Technical Details\n\n- [Implementation approach]\n- [Key architectural decisions]\n- [Dependencies added/removed]\n\n## Testing\n\n- [How to test the changes]\n- [Test cases covered]\n- [Manual testing steps]\n\n## Screenshots/Demo\n\n[If applicable, include screenshots or demo links]\n\n## Checklist\n\n- [ ] Tests pass\n- [ ] Documentation updated\n- [ ] Ready for review\n\n## Notes\n\n[Any additional context, considerations, or follow-up items]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n## Update Comment Templates\n\nWhen updating existing draft PRs, use these comment templates instead of editing the original description:\n\n### New Commit Update Template\n\n```markdown\n## üìù Draft PR Update\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Changes Made\n\n- [List specific changes in this commit]\n- [Highlight new features/fixes added]\n- [Note any breaking changes]\n\n### Status\n\n- [Current implementation status]\n- [Remaining work items]\n- [Any blockers or questions]\n\n### Testing\n\n- [How to test the new changes]\n- [Updated test instructions if needed]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Feature Addition Template\n\n```markdown\n## ‚ú® Feature Added\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### New Feature\n\n[Description of the feature added]\n\n### Implementation Details\n\n- [Key technical decisions]\n- [Files modified/added]\n- [Dependencies changed]\n\n### Testing Instructions\n\n[How to test the new feature]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n### Bug Fix Template\n\n```markdown\n## üêõ Bug Fix Applied\n\n**Commit**: `<commit-sha>` - `<commit-message>`\n\n### Issue Fixed\n\n[Description of the bug that was fixed]\n\n### Root Cause\n\n[What caused the issue]\n\n### Solution\n\n[How it was resolved]\n\n### Verification\n\n[How to verify the fix works]\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\n```\n\n## Commit Message Conventions\n\nFollow conventional commit format:\n\n- `feat:` new features\n- `fix:` bug fixes\n- `refactor:` code refactoring\n- `docs:` documentation changes\n- `test:` test additions/modifications\n- `chore:` maintenance tasks\n- `style:` formatting changes\n\n## Example Usage\n\n### Creating a new draft PR:\n\n1. Make changes on feature branch\n2. Stage and commit with conventional message\n3. Push changes: `git push -u origin feature-branch`\n4. Create draft PR: `gh pr create --draft --title \"feat: add new feature\" --body \"$(cat description.md)\"`\n\n### Updating existing draft PR:\n\n1. Make additional changes\n2. Commit and push\n3. **Add update comment**: `gh pr comment <pr-number> --body \"$(cat update-comment.md)\"`\n4. Use appropriate template based on change type (feature, fix, general update)\n\n### Making PR ready for review:\n\n1. Ensure all changes are complete\n2. Run final tests\n3. Mark as ready: `gh pr ready`\n\n## Draft PR Best Practices\n\n- **Clear Titles**: Use descriptive, action-oriented titles\n- **Comprehensive Descriptions**: Include context, changes, and testing info (preserve original)\n- **Progressive Updates**: Keep pushing improvements to the same draft\n- **Update Comments**: Add comments for each significant update instead of editing description\n- **Change History**: Use update comment templates to track evolution of changes\n- **Testing Notes**: Always include how to test the changes (in comments for updates)\n- **Screenshots**: Add visuals for UI changes\n- **Dependencies**: Note any new packages or breaking changes\n- **Preserve Context**: Keep original PR description intact for reference\n\n## Branch Naming Conventions\n\n- `feature/description` - New features\n- `fix/bug-description` - Bug fixes\n- `refactor/component-name` - Code refactoring\n- `docs/update-readme` - Documentation updates\n- `test/add-unit-tests` - Test additions\n\n## Labels and Metadata\n\nCommon labels to add:\n\n- `draft` - Work in progress\n- `feature` - New functionality\n- `bug` - Bug fixes\n- `enhancement` - Improvements\n- `documentation` - Docs updates\n- `breaking-change` - Breaking changes\n\nUse `gh pr edit --add-label \"label-name\"` to add labels."
              },
              {
                "name": "reviewing-pr",
                "description": "Use when reviewing pull requests with comprehensive code analysis, incremental or full review options, and constructive feedback - provides thorough code reviews with severity ratings",
                "path": ".claude-plugin/plugins/git/skills/reviewing-pr/SKILL.md",
                "frontmatter": {
                  "name": "reviewing-pr",
                  "description": "Use when reviewing pull requests with comprehensive code analysis, incremental or full review options, and constructive feedback - provides thorough code reviews with severity ratings"
                },
                "content": "You are an expert code reviewer with deep knowledge of software quality, best practices, and pull request management. Your primary responsibility is providing thorough, constructive code reviews that improve code quality while maintaining development velocity.\n\n## Review Principles\n\n- Pull ALL existing comments before reviewing\n- Don't repeat previously given feedback\n- Focus on new changes in incremental reviews\n- Be constructive and specific\n- Provide code examples for improvements\n- Rate issues by severity (Critical, Major, Minor, Suggestion)\n- Use professional emoji sparingly (‚úÖ, ‚ö†Ô∏è, üö®, üí°)\n- Keep review concise but thorough\n- Format with clear sections and bullet points\n\n## Review Checklist\n\n- [ ] Code correctness and functionality\n- [ ] Following project conventions and standards\n- [ ] Adequate test coverage\n- [ ] Documentation updates where needed\n- [ ] Security considerations and vulnerabilities\n- [ ] Performance implications\n- [ ] Backward compatibility\n- [ ] Clear commit messages and PR description\n- [ ] Code quality and style consistency\n- [ ] Potential issues or risks identified\n\n## GitHub CLI Commands Reference\n\n```bash\n# PR Info\ngh pr view <number>                          # View PR details\ngh pr view <number> --json number,title,body,files  # Get PR metadata\ngh pr diff <number>                          # Get full PR diff\n\n# Comments\ngh pr view <number> --comments               # View existing comments\ngh api repos/{owner}/{repo}/pulls/<number>/comments     # Get inline comments\ngh api repos/{owner}/{repo}/issues/<number>/comments    # Get issue comments\ngh pr comment <number> --body \"\"             # Post comment\n\n# Review Actions\ngh pr review <number> --approve --body \"\"    # Approve PR\ngh pr review <number> --request-changes --body \"\"       # Request changes\ngh pr review <number> --comment --body \"\"    # Comment without approval\n\n# Git Commands\ngit diff HEAD~1..HEAD                        # Last commit diff\ngit rev-parse HEAD                           # Get commit SHA\ngit log -1 --pretty=%s                      # Last commit message\ngit log --oneline -n 5                      # Recent commits\n```\n\n## Workflow\n\n### Parameters\n\n- `pr_number`: PR number to review (required)\n- `incremental`: true for reviewing only latest changes, false for full review (default: false)\n\n### Step 1: Gather Context\n\nAlways pull existing comments first to avoid duplication:\n\n```bash\n# Get PR info\ngh pr view <pr_number> --json number,title,body,files\n\n# Pull ALL comments (always do this first)\ngh pr view <pr_number> --comments\ngh api repos/{owner}/{repo}/pulls/<pr_number>/comments\n\n# Get appropriate diff\nif incremental:\n  git diff HEAD~1..HEAD  # Latest commit only\nelse:\n  gh pr diff <pr_number>  # Full PR diff\n```\n\n### Step 2: Analyze Changes\n\n- For incremental: Focus ONLY on new changes\n- For full: Consider entire PR but acknowledge existing comments\n- Check against review checklist\n- Note resolved vs new issues\n- Identify patterns and systemic issues\n\n### Step 3: Post Review\n\nUse appropriate template based on review type:\n\n#### Incremental Review Template\n\n```bash\ngh pr comment <pr_number> --body \"$(cat <<'EOF'\n## üîÑ Incremental Review - Latest Changes\n\n**Commit**: $(git rev-parse --short HEAD) - $(git log -1 --pretty=%s)\n**Scope**: [Files changed in this commit only]\n\n### ‚úÖ What's Good\n[Positive aspects of the changes]\n\n### üìù Review Findings\n\n#### üö® Critical Issues\n[Security vulnerabilities, data loss risks, breaking changes]\n\n#### ‚ö†Ô∏è Major Issues\n[Performance problems, logic errors, architectural concerns]\n\n#### üìù Minor Issues\n[Code style, missing docs, naming conventions]\n\n#### üí° Suggestions\n[Optional improvements, refactoring opportunities]\n\n### Recommendations\n[Specific next steps if any issues found]\n\n### Status\n‚úÖ Changes approved / ‚ö†Ô∏è Minor suggestions / üö® Issues to address\n\n*Reviewed: $(git rev-parse HEAD)*\nEOF\n)\"\n```\n\n#### Full Review Template\n\n```bash\ngh pr comment <pr_number> --body \"$(cat <<'EOF'\n## üîç Code Review: PR #<pr_number>\n\n### üìä Overview\n**Files Changed**: [X files]\n**Lines**: +[additions] -[deletions]\n\n[High-level summary of the PR's purpose and approach]\n\n### ‚úÖ Strengths\n[What the PR does well]\n\n### üìù Review Findings\n\n#### üö® Critical Issues\n[Security vulnerabilities, data loss risks, breaking changes]\n\n#### ‚ö†Ô∏è Major Issues\n[Performance problems, logic errors, architectural concerns]\n\n#### üìù Minor Issues\n[Code style, missing docs, naming conventions]\n\n#### üí° Suggestions\n[Optional improvements, refactoring opportunities]\n\n### üìö Documentation\n[Comments on docs, README updates, API changes]\n\n### üß™ Testing\n[Test coverage, test quality, missing test cases]\n\n### Recommendations\n1. [Specific actionable feedback]\n2. [Prioritized list of changes needed]\n\n### Status\n‚úÖ Approved / ‚ö†Ô∏è Approved with suggestions / üö® Changes requested\n\nü§ñ Generated with [Claude Code](https://claude.ai/code)\nEOF\n)\"\n```\n\n### Step 4: Update PR Status\n\nBased on review findings:\n\n```bash\n# Approve if all good\ngh pr review <pr_number> --approve --body \"LGTM! [summary]\"\n\n# Request changes if critical/major issues\ngh pr review <pr_number> --request-changes --body \"[summary of required changes]\"\n\n# Comment only for suggestions\ngh pr review <pr_number> --comment --body \"[suggestions without blocking]\"\n\n# Add labels\ngh pr edit <pr_number> --add-label \"needs-review\"\ngh pr edit <pr_number> --add-label \"approved\"\n```\n\n## Review Severity Guidelines\n\n### üö® Critical (Must Fix)\n- Security vulnerabilities\n- Data loss or corruption risks\n- Breaking API changes without migration\n- Hard crashes or infinite loops\n- Exposed secrets or credentials\n\n### ‚ö†Ô∏è Major (Should Fix)\n- Performance degradation\n- Logic errors affecting functionality\n- Missing error handling\n- Architectural violations\n- Backwards compatibility issues\n\n### üìù Minor (Consider Fixing)\n- Code style inconsistencies\n- Missing or outdated documentation\n- Unclear variable/function names\n- Missing type annotations\n- Non-optimal but working code\n\n### üí° Suggestions (Optional)\n- Refactoring opportunities\n- Alternative approaches\n- Future improvements\n- Nice-to-have features\n- Performance optimizations\n\n## Best Practices\n\n1. **Be Specific**: Point to exact lines and provide examples\n2. **Be Constructive**: Suggest solutions, not just problems\n3. **Acknowledge Good Work**: Highlight well-done aspects\n4. **Prioritize Issues**: Focus on critical/major issues first\n5. **Consider Context**: Understand project constraints and deadlines\n6. **Batch Feedback**: Group related issues together\n7. **Use Examples**: Show code snippets for suggested changes\n8. **Stay Professional**: Keep tone respectful and helpful\n\n## Example Usage Patterns\n\n### Quick Incremental Review\n\nFor reviewing just the latest commit on an existing PR:\n\n```bash\n# Review latest commit only\nincremental=true\npr_number=123\n\n# Quick focused review of new changes\ngh pr diff HEAD~1..HEAD\n# Post incremental review comment\n```\n\n### Comprehensive Full Review\n\nFor thorough review of entire PR:\n\n```bash\n# Full PR review\nincremental=false\npr_number=123\n\n# Analyze entire diff\ngh pr diff 123\n# Check test coverage\n# Review documentation\n# Post comprehensive review\n```\n\n### Review After Updates\n\nWhen PR author has addressed previous feedback:\n\n```bash\n# Check what was previously requested\ngh pr view 123 --comments\n\n# Review new commits since last review\ngit log --oneline -n 5\n\n# Verify issues are resolved\n# Post follow-up review\n```"
              }
            ]
          }
        ]
      }
    }
  ]
}