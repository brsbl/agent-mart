{
  "owner": {
    "id": "yzlin",
    "display_name": "Ethan Lin",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/82482?u=8a6c57b23a194a8802f2d51ef925b54b207c13c6&v=4",
    "url": "https://github.com/yzlin",
    "bio": "Code farmer",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 2,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "yzlin/supaviber",
      "url": "https://github.com/yzlin/supaviber",
      "description": "SupaViber - Personal vibe coding toolkit with custom skills, agents, and commands for an optimized development environment",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-03T06:18:38Z",
        "created_at": "2025-12-27T15:49:20Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 883
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 398
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows/validate-skills.yml",
          "type": "blob",
          "size": 569
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 346
        },
        {
          "path": ".python-version",
          "type": "blob",
          "size": 5
        },
        {
          "path": ".templates",
          "type": "tree",
          "size": null
        },
        {
          "path": ".templates/skill-template",
          "type": "tree",
          "size": null
        },
        {
          "path": ".templates/skill-template/SKILL.md",
          "type": "blob",
          "size": 1372
        },
        {
          "path": "CHANGELOG.md",
          "type": "blob",
          "size": 2182
        },
        {
          "path": "CONTRIBUTING.md",
          "type": "blob",
          "size": 5924
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1062
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 8883
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/.gitkeep",
          "type": "blob",
          "size": null
        },
        {
          "path": "agents/README.md",
          "type": "blob",
          "size": 4465
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/.gitkeep",
          "type": "blob",
          "size": null
        },
        {
          "path": "commands/README.md",
          "type": "blob",
          "size": 4914
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/METADATA-CONVENTIONS.md",
          "type": "blob",
          "size": 3196
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/.gitkeep",
          "type": "blob",
          "size": null
        },
        {
          "path": "hooks/README.md",
          "type": "blob",
          "size": 6201
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 324
        },
        {
          "path": "pyproject.toml",
          "type": "blob",
          "size": 417
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/.gitkeep",
          "type": "blob",
          "size": null
        },
        {
          "path": "scripts/create-skill.sh",
          "type": "blob",
          "size": 4314
        },
        {
          "path": "scripts/validate-skills.sh",
          "type": "blob",
          "size": 2379
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/README.md",
          "type": "blob",
          "size": 4073
        },
        {
          "path": "skills/coding-standards",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-standards/SKILL.md",
          "type": "blob",
          "size": 15469
        },
        {
          "path": "skills/coding-standards/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/coding-standards/references/EXAMPLES.md",
          "type": "blob",
          "size": 5160
        },
        {
          "path": "skills/coding-standards/references/LANGUAGE-SPECIFICS.md",
          "type": "blob",
          "size": 6387
        },
        {
          "path": "skills/git-safety",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/git-safety/SKILL.md",
          "type": "blob",
          "size": 7271
        }
      ],
      "marketplace": {
        "name": "supaviber-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Ethan Lin",
          "email": "yzlin1985@gmail.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "supaviber",
            "description": "Personal vibe coding toolkit - custom skills, agents, and commands for an optimized development environment",
            "source": "./",
            "category": "productivity",
            "version": "0.3.0",
            "author": {
              "name": "Ethan Lin",
              "url": "https://github.com/yzlin"
            },
            "install_commands": [
              "/plugin marketplace add yzlin/supaviber",
              "/plugin install supaviber@supaviber-marketplace"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-03T06:18:38Z",
              "created_at": "2025-12-27T15:49:20Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "coding-standards",
                "description": "Guide for writing clean, maintainable code following industry best practices and design principles like DRY, SOLID, and composition patterns. Use when writing any code to ensure consistency, readability, and long-term maintainability across all programming languages.",
                "path": "skills/coding-standards/SKILL.md",
                "frontmatter": {
                  "name": "coding-standards",
                  "description": "Guide for writing clean, maintainable code following industry best practices and design principles like DRY, SOLID, and composition patterns. Use when writing any code to ensure consistency, readability, and long-term maintainability across all programming languages.",
                  "license": "MIT",
                  "compatibility": "Works with Claude Code and OpenAI Codex. Language-agnostic with specific guidance for Python, TypeScript, Java, Go, Rust.",
                  "metadata": {
                    "category": "code-quality",
                    "tags": "clean-code, SOLID, DRY, best-practices, design-patterns",
                    "version": "1.0.0"
                  }
                },
                "content": "# Coding Standards & Design Principles Guide\n\n## Overview\n\nThis skill ensures you write high-quality, maintainable code that follows industry best practices. Use this whenever you're writing code, reviewing code, or refactoring existing implementations. The principles here apply across all programming languages, with specific considerations for different contexts.\n\n**Core Philosophy:**\n\n- **Clarity over cleverness** - Code is read more often than written\n- **Practical pragmatism** - Apply patterns when they add value, not dogmatically\n- **Evolution-friendly** - Design for change and future extension\n- **Team-oriented** - Write code others (including future you) can understand\n\n---\n\n# Process\n\n## üöÄ High-Level Workflow\n\nWriting quality code involves three main phases:\n\n### Phase 1: Planning and Design\n\n#### 1.1 Understand Core Design Principles\n\nBefore writing code, internalize these fundamental principles:\n\n**DRY (Don't Repeat Yourself):**\n\n- Extract duplicated logic when the same code appears **3+ times**\n- Create reusable functions/methods/classes for shared behavior\n- **BUT**: Don't abstract prematurely - two instances might just be coincidence\n- **Balance**: Readability > DRY for simple, self-explanatory code\n- **Example**: If you see identical validation logic in 3 endpoints, extract it\n\n**SOLID Principles:**\n\n**S - Single Responsibility Principle (SRP):**\n\n- Each class/function should do one thing and do it well\n- If you can't describe what it does in one sentence without \"and\", it's doing too much\n- **Red flag**: Functions with names like `processAndValidateAndSaveUser()`\n- **Good**: Separate `validateUser()`, `processUser()`, `saveUser()`\n\n**O - Open/Closed Principle:**\n\n- Open for extension, closed for modification\n- Use interfaces, abstract classes, or composition to allow new behavior without changing existing code\n- **Example**: Plugin architecture instead of giant switch statements\n\n**L - Liskov Substitution Principle:**\n\n- Subclasses should be substitutable for their base classes\n- Don't break contracts - if parent returns non-null, child shouldn't return null\n- **Red flag**: Subclass that throws NotImplementedException for parent methods\n\n**I - Interface Segregation Principle:**\n\n- Many specific interfaces are better than one general-purpose interface\n- Clients shouldn't depend on methods they don't use\n- **Example**: `IReadable` and `IWritable` instead of `IFileOperations` with unused methods\n\n**D - Dependency Inversion Principle:**\n\n- Depend on abstractions, not concrete implementations\n- High-level modules shouldn't depend on low-level modules\n- **Use**: Dependency injection, interface-based design\n\n**Composition Over Inheritance:**\n\n- Favor \"has-a\" relationships over \"is-a\"\n- Inheritance creates tight coupling; composition provides flexibility\n- **Example**: Use strategy pattern instead of inheritance hierarchies\n- **Guideline**: More than 2-3 inheritance levels is usually a smell\n\n**YAGNI (You Aren't Gonna Need It):**\n\n- Don't build features \"just in case\" or \"for the future\"\n- Add complexity only when actually needed\n- **Balance**: Don't over-engineer, but leave sensible extension points\n\n**KISS (Keep It Simple, Stupid):**\n\n- Simple solutions are easier to understand, test, and maintain\n- If a junior developer can't understand it, it's probably too complex\n- **Question**: \"Is there a simpler way to achieve the same goal?\"\n\n#### 1.2 Plan Your Approach\n\nBefore writing code, ask yourself:\n\n**Functionality:**\n\n- What is the single responsibility of this code?\n- What are the inputs, outputs, and side effects?\n- What are the error cases and how should they be handled?\n\n**Reusability:**\n\n- Is there existing code that does something similar?\n- Will this logic be needed elsewhere?\n- What's the right level of abstraction?\n\n**Dependencies:**\n\n- What external dependencies does this need?\n- Can dependencies be injected rather than hard-coded?\n- Are we depending on abstractions or concrete implementations?\n\n**Testing:**\n\n- How will this be tested?\n- Are we writing testable code (pure functions, dependency injection)?\n- What are the edge cases?\n\n#### 1.3 Design the Interface First\n\n**Before implementation, design the public interface:**\n\n- What will consumers of this code need?\n- What parameters are required vs optional?\n- What does success look like? What about failure?\n- How will this be documented?\n\n**Consider:**\n\n- Function/method signatures\n- Class constructors and public methods\n- Return types and error handling strategy\n- Naming conventions\n\n---\n\n### Phase 2: Implementation\n\n#### 2.1 Code Organization\n\n**File Structure:**\n\n- One class per file (for OOP languages)\n- Group related functionality in modules/packages\n- Keep files under 300-500 lines (guideline, not rule)\n- Organize imports: stdlib ‚Üí third-party ‚Üí local\n\n**Function/Method Length:**\n\n- Aim for 20-30 lines max per function\n- If longer, can you extract helper functions?\n- **Exception**: Sometimes a long, linear function is clearer than over-decomposition\n\n**Class Length:**\n\n- Aim for under 200-300 lines per class\n- If larger, consider if it has multiple responsibilities\n- Extract inner classes or create new classes\n\n#### 2.2 Naming Conventions\n\n**Critical Rules:**\n\n- Names should reveal intent: `getUserById()` not `get()`\n- Avoid abbreviations unless universally known: `HTTP` is fine, `usrLst` is not\n- Be consistent within the codebase\n- Use domain language that business stakeholders understand\n\n**Specific Guidelines:**\n\n**Variables:**\n\n- Use nouns: `userCount`, `activeConnections`, `databasePool`\n- Boolean: Prefix with `is`, `has`, `can`: `isValid`, `hasAccess`, `canDelete`\n- Avoid single letters except for: `i, j, k` (loop indices), `x, y` (coordinates), `e` (exceptions)\n\n**Functions/Methods:**\n\n- Use verbs: `calculateTotal()`, `fetchUser()`, `validateEmail()`\n- Predicates return boolean: `isEmpty()`, `hasPermission()`\n- Commands vs Queries: Separate functions that change state from those that return data\n\n**Classes:**\n\n- Use nouns: `UserRepository`, `EmailValidator`, `PaymentProcessor`\n- Avoid \"Manager\", \"Helper\", \"Utility\" names - they hide responsibility\n- If you need them, be specific: `DatabaseConnectionManager` not `Manager`\n\n**Constants:**\n\n- All caps with underscores: `MAX_RETRY_ATTEMPTS`, `DEFAULT_TIMEOUT`\n- Group related constants in enums or dedicated modules\n\n#### 2.3 Function Design\n\n**Parameters:**\n\n- Ideal: 0-2 parameters\n- Acceptable: 3 parameters\n- Avoid: 4+ parameters (use parameter objects/configs)\n- **Example**: Instead of `createUser(name, email, age, country, preferences, settings)`, use `createUser(UserCreateRequest request)`\n\n**Return Values:**\n\n- Be consistent: Don't mix null, undefined, empty arrays, and exceptions for \"no data\"\n- Prefer explicit error handling over null: Result types, Option types, or exceptions\n- Return early to avoid deep nesting\n\n**Side Effects:**\n\n- Document all side effects in function documentation\n- Separate query operations (read) from command operations (write)\n- Minimize hidden side effects (global state, file I/O, etc.)\n\n**Pure Functions When Possible:**\n\n- Same inputs always produce same outputs\n- No side effects\n- Easier to test, reason about, and parallelize\n- **Example**: `calculateTax(amount, rate)` is pure; `updateUserInDatabase(user)` is not\n\n#### 2.4 Error Handling\n\n**General Principles:**\n\n- Fail fast: Validate inputs early\n- Provide actionable error messages\n- Don't swallow exceptions silently\n- Use specific exception types\n\n**Error Handling Strategies:**\n\n**Exceptions (for exceptional situations):**\n\n- Use for truly exceptional conditions, not control flow\n- Provide context: What failed, why, and what to do about it\n- Clean up resources (use try-finally or context managers)\n\n**Return Values (for expected failures):**\n\n- Use Result/Option types for operations that commonly fail\n- Example: `findUser()` returns `Option<User>` or `Result<User, NotFoundError>`\n- Avoid null/undefined when possible\n\n**Validation:**\n\n- Validate at system boundaries (API endpoints, database queries)\n- Use type systems and schema validation\n- Return structured validation errors\n\n**Logging:**\n\n- Log actionable information\n- Include context: user ID, request ID, timestamp\n- Use appropriate levels: ERROR for failures, WARN for degraded state, INFO for significant events\n\n#### 2.5 Comments and Documentation\n\n**When to Comment:**\n\n- **WHY, not WHAT**: Explain the reasoning, not the obvious\n  - ‚ùå `// Increment counter by 1`\n  - ‚úÖ `// Skip first item as it contains headers`\n- Complex algorithms: Explain the approach\n- Non-obvious business rules\n- TODO/FIXME with context and owner\n\n**When NOT to Comment:**\n\n- Self-explanatory code (use better names instead)\n- Commented-out code (use version control)\n- Obvious statements\n\n**Documentation (Doc Comments):**\n\n- Public APIs: Always document\n- Complex internal functions: Document\n- Simple, self-explanatory functions: Optional\n\n**Include:**\n\n- Purpose and behavior\n- Parameter descriptions with types and constraints\n- Return value description\n- Exceptions/errors that can be thrown\n- Usage examples for complex APIs\n\n#### 2.6 Code Quality Practices\n\n**Avoid Deep Nesting:**\n\n- Maximum 3 levels of indentation\n- Use early returns/guards\n- Extract complex conditions into well-named functions\n\n**Example:**\n\n```typescript\n// ‚ùå BAD:\nif (user !== null) {\n  if (user.isActive) {\n    if (user.hasPermission(\"write\")) {\n      // do something\n    }\n  }\n}\n\n// ‚úÖ GOOD:\nif (user === null) return;\nif (!user.isActive) return;\nif (!user.hasPermission(\"write\")) return;\n// do something\n```\n\n**Avoid Long Parameter Lists:**\n\n- Use parameter objects/configs for 4+ parameters\n- Consider builder pattern for objects with many optional parameters\n\n**Avoid Magic Numbers:**\n\n- Define constants with descriptive names\n- ‚ùå `if (status === 404)`\n- ‚úÖ `if (status === HTTP_NOT_FOUND)`\n\n**Consistent Formatting:**\n\n- Use automated formatters (Prettier, Black, gofmt)\n- Follow language-specific style guides\n- Be consistent within the project\n\n**Minimize Global State:**\n\n- Prefer dependency injection over global singletons\n- Use function parameters instead of accessing global variables\n- Make mutability explicit and minimal\n\n---\n\n### Phase 3: Review and Refine\n\n#### 3.1 Self-Review Checklist\n\nBefore considering code complete, verify:\n\n**Design Principles:**\n\n- [ ] Each function/class has a single, clear responsibility\n- [ ] No code duplication (DRY applied where it adds value)\n- [ ] Dependencies are injected, not hard-coded\n- [ ] Code is open for extension, closed for modification\n- [ ] Abstractions don't leak implementation details\n\n**Code Quality:**\n\n- [ ] Names clearly express intent\n- [ ] Functions are short and focused (< 30 lines typically)\n- [ ] No deep nesting (< 3 levels)\n- [ ] No magic numbers or strings\n- [ ] Consistent formatting and style\n\n**Error Handling:**\n\n- [ ] Input validation at boundaries\n- [ ] Meaningful error messages\n- [ ] Resources properly cleaned up\n- [ ] No swallowed exceptions\n\n**Testing:**\n\n- [ ] Code is testable (minimal dependencies, pure functions where possible)\n- [ ] Edge cases identified\n- [ ] Test coverage for critical paths\n\n**Documentation:**\n\n- [ ] Public APIs documented\n- [ ] Complex logic has explanatory comments\n- [ ] Non-obvious decisions explained\n\n**Performance:**\n\n- [ ] No obvious inefficiencies (N+1 queries, unnecessary loops)\n- [ ] Appropriate data structures chosen\n- [ ] No premature optimization\n\n**Security:**\n\n- [ ] Input sanitized/validated\n- [ ] Sensitive data not logged\n- [ ] Authentication/authorization checked\n\n#### 3.2 Refactoring Opportunities\n\n**Code Smells to Watch For:**\n\n**Long Functions/Methods:**\n\n- Extract smaller, well-named functions\n- Each function should do one thing\n\n**Large Classes:**\n\n- Consider if class has multiple responsibilities\n- Extract collaborating classes\n\n**Long Parameter Lists:**\n\n- Use parameter objects or builder pattern\n- Consider if function is doing too much\n\n**Primitive Obsession:**\n\n- Create domain objects instead of passing primitives\n- Example: `Email` class instead of raw strings\n\n**Feature Envy:**\n\n- Method uses another class's data more than its own\n- Move method to the class whose data it uses\n\n**Data Clumps:**\n\n- Same group of parameters appears together repeatedly\n- Extract into a dedicated object\n\n**Switch Statements:**\n\n- Consider polymorphism or strategy pattern\n- Especially if same switch appears in multiple places\n\n**Comments:**\n\n- If you need a comment to explain what code does, consider better naming\n- If explaining why, the comment is valuable\n\n---\n\n**For language-specific best practices and examples, see [references/LANGUAGE-SPECIFICS.md](references/LANGUAGE-SPECIFICS.md).**\n\n**For detailed code examples demonstrating these principles, see [references/EXAMPLES.md](references/EXAMPLES.md).**\n\n---\n\n# Quick Reference\n\n## When to Apply Each Principle\n\n**Use DRY when:**\n\n- Same logic appears 3+ times\n- The abstraction is clear and natural\n- Changes to the logic should affect all uses\n\n**Don't use DRY when:**\n\n- Two similar pieces of code serve different purposes\n- The abstraction would be more complex than duplication\n- Code is unlikely to change together\n\n**Use SRP when:**\n\n- Class/function is hard to name without \"and\"\n- Changes for one reason affect unrelated functionality\n- Testing requires mocking many dependencies\n\n**Use Dependency Injection when:**\n\n- Testing with mock dependencies\n- Supporting multiple implementations\n- Configuration needs to vary by environment\n\n**Use Composition when:**\n\n- Multiple inheritance creates diamond problem\n- Behavior needs to be mixed and matched\n- Inheritance depth exceeds 2-3 levels\n\n**Keep It Simple when:**\n\n- Always - start simple, add complexity only when needed\n- You're tempted to use advanced patterns\n- Junior developers will maintain the code\n\n## Common Anti-Patterns to Avoid\n\n- **God Objects**: Classes that do everything\n- **Shotgun Surgery**: One change requires editing many files\n- **Spaghetti Code**: No clear structure, everything connected\n- **Copy-Paste Programming**: Duplicating code instead of abstracting\n- **Golden Hammer**: Using favorite pattern everywhere\n- **Premature Optimization**: Optimizing before measuring\n- **Not Invented Here**: Reimplementing existing solutions\n- **Analysis Paralysis**: Over-planning without implementing\n\n---\n\n# Final Notes\n\n**Remember:**\n\n- These are guidelines, not laws - apply them with judgment\n- Consistency within a codebase matters more than perfect adherence\n- Write code for humans first, machines second\n- When in doubt, favor simplicity and clarity\n- Refactor continuously - don't let technical debt accumulate\n\n**The Goal:**\nWrite code that is:\n\n- Easy to understand\n- Easy to change\n- Easy to test\n- Easy to debug\n- Easy to extend\n\nIf your code achieves these goals, you're on the right track."
              },
              {
                "name": "git-safety",
                "description": "Apply critical git safety protocols before any git operations, especially in collaborative environments. Use when performing git commands, managing files, or making destructive changes.",
                "path": "skills/git-safety/SKILL.md",
                "frontmatter": {
                  "name": "git-safety",
                  "description": "Apply critical git safety protocols before any git operations, especially in collaborative environments. Use when performing git commands, managing files, or making destructive changes.",
                  "license": "MIT",
                  "compatibility": "Works with Claude Code and OpenAI Codex. Requires git CLI access.",
                  "metadata": {
                    "category": "version-control",
                    "tags": "git, safety, collaboration, destructive-operations",
                    "version": "1.0.0"
                  }
                },
                "content": "# Git Safety Skill\n\nApply rigorous git safety protocols to prevent data loss and conflicts in collaborative development environments, particularly when multiple agents or developers work concurrently.\n\n## Core Safety Principles\n\n### File Management Rules\n\n**Deleting Files:**\n- ‚ö†Ô∏è **STOP before deleting any file to resolve type/lint failures** - Ask the user first\n- Only remove obsolete files when changes make them genuinely irrelevant\n- Only revert your own work or changes explicitly requested by the user\n- **Coordinate with teammates before removing in-progress edits**\n- Never assume a file is safe to delete without confirmation\n\n**File Modifications:**\n- Always verify file ownership and recent changes before modifying\n- Check `git log <file>` to see who last edited\n- Communicate before making sweeping changes to shared files\n\n### Environment & Configuration Safety\n\n**Critical: Environment Files**\n- üö´ **NEVER edit `.env` or any environment variable files**\n- Only the user may change environment configurations\n- This includes `.env`, `.env.local`, `.env.production`, etc.\n- If environment changes are needed, inform the user - never make them yourself\n\n**Git Configuration:**\n- Never modify `.gitconfig` or repository git settings\n- Never amend commits without explicit written approval\n- Preserve existing git hooks and configurations\n\n## Destructive Operations - Extreme Caution Required\n\n### Absolutely Forbidden Without Explicit Permission\n\nüö® **ABSOLUTELY NEVER run these operations unless the user gives explicit, written instruction:**\n\n- `git reset --hard` - Destroys uncommitted work permanently\n- `git checkout <old-commit>` - Can lose current work\n- `git restore --source=<old-commit>` - Reverts to old state, losing changes\n- `rm -rf` - Irreversible file deletion\n- `git push --force` - Overwrites remote history\n- `git rebase` without safeguards - Can lose commits\n- `git clean -fd` - Deletes untracked files permanently\n\n### What Requires User Approval\n\nBefore running these commands, **STOP and ask the user explicitly:**\n\n1. Any command that can lose uncommitted changes\n2. Force pushing to remote repositories\n3. Rebasing published branches\n4. Amending pushed commits\n5. Deleting branches (local or remote)\n6. Hard resets of any kind\n7. File deletions to fix build errors\n\n## Safe Workflow Standards\n\n### Before Any Commit\n\n**Pre-commit Checklist:**\n1. Run `git status` to verify exactly what's being committed\n2. Use explicit file paths - never `git add .` or `git add -A` blindly\n3. Ensure only modified/intended files are staged\n4. Review diffs with `git diff --staged`\n5. Keep commits atomic (focused on one logical change)\n\n**Example - Safe Commit:**\n```bash\n# Good: Explicit, verified, atomic\ngit status\ngit add src/components/Button.tsx src/components/Button.test.tsx\ngit diff --staged\ngit commit -m \"feat: add disabled state to Button component\"\n```\n\n**Example - Unsafe Commit:**\n```bash\n# Bad: No verification, adds everything\ngit add .\ngit commit -m \"fixes\"\n```\n\n### Path Handling\n\n**Quote Special Characters:**\n- Always quote paths with brackets, parentheses, or spaces\n- Use double quotes to prevent shell interpretation\n\n```bash\n# Good\ngit add \"src/utils/parse(data).ts\"\ngit add \"src/components/[id].tsx\"\n\n# Bad - shell may misinterpret\ngit add src/utils/parse(data).ts\ngit add src/components/[id].tsx\n```\n\n### Rebase Safety\n\nWhen rebasing is necessary:\n\n```bash\n# Suppress editor prompts\nGIT_SEQUENCE_EDITOR=true git rebase <branch>\n\n# Or set environment variable\nexport GIT_SEQUENCE_EDITOR=true\ngit rebase main\n```\n\n## Coordination in Collaborative Environments\n\n### Before Major Changes\n\n**Communication First:**\n1. Check who else is working on related files: `git log --since=\"1 day ago\" --oneline`\n2. Announce intention to make sweeping changes\n3. Wait for confirmation before proceeding\n4. Coordinate timing of force pushes or rebases\n\n### Conflict Prevention\n\n**Proactive Coordination:**\n- Pull frequently: `git pull --rebase`\n- Communicate when working on shared files\n- Use feature branches to isolate work\n- Merge main frequently to stay current\n\n## Decision Tree for Destructive Operations\n\n```\nAre you about to run a destructive git command?\n‚îú‚îÄ YES ‚Üí Is there explicit written user approval?\n‚îÇ   ‚îú‚îÄ YES ‚Üí Proceed carefully, verify twice\n‚îÇ   ‚îî‚îÄ NO ‚Üí STOP. Ask user for permission first.\n‚îî‚îÄ NO ‚Üí Proceed with normal safety checks\n```\n\n## Common Scenarios\n\n### Scenario 1: Type Error in File\n\n**Wrong Approach:**\n```bash\n# ‚ùå Delete file to fix error\nrm src/components/BrokenComponent.tsx\n```\n\n**Right Approach:**\n```bash\n# ‚úÖ Stop and ask user\n# \"I see a type error in BrokenComponent.tsx.\n# Should I fix the error or is this file obsolete?\"\n```\n\n### Scenario 2: Need to Reset Changes\n\n**Wrong Approach:**\n```bash\n# ‚ùå Hard reset without asking\ngit reset --hard HEAD\n```\n\n**Right Approach:**\n```bash\n# ‚úÖ Ask first, then use safer methods\ngit stash  # Preserves work\n# OR\ngit checkout -b backup-branch  # Creates backup\n```\n\n### Scenario 3: Multiple Agents Working\n\n**Wrong Approach:**\n```bash\n# ‚ùå Force push over teammate's work\ngit push --force\n```\n\n**Right Approach:**\n```bash\n# ‚úÖ Coordinate first\n# \"I need to force push to fix history.\n# Is anyone else working on this branch?\"\n```\n\n## Safety Verification Commands\n\n**Before Destructive Operations:**\n\n```bash\n# Check what will be affected\ngit status\ngit log --oneline -n 10\ngit diff HEAD\n\n# See who's been working recently\ngit log --since=\"1 day ago\" --all --oneline\n\n# Check remote status\ngit fetch\ngit status\n```\n\n## Environment File Protection\n\n**Files to NEVER modify:**\n- `.env`\n- `.env.local`\n- `.env.development`\n- `.env.production`\n- `.env.test`\n- Any file matching `.env.*`\n\n**If environment changes are needed:**\n1. Stop immediately\n2. Inform the user exactly what needs to change\n3. Let the user make the modification\n4. Never assume or guess environment values\n\n## Summary - The Golden Rules\n\n1. üõë **STOP before deleting files** to fix build errors\n2. üö´ **NEVER touch environment files** - user only\n3. ‚ö†Ô∏è **Get explicit permission** for destructive git operations\n4. ‚úÖ **Verify with git status** before every commit\n5. üìù **Use explicit paths** - never blindly add all files\n6. üîí **Quote special characters** in file paths\n7. ü§ù **Coordinate with teammates** before major changes\n8. üíæ **When in doubt, ask** - communication over assumption\n\n## When This Skill Applies\n\nInvoke this skill when:\n- About to run any git command\n- Considering deleting a file\n- Planning to modify shared files\n- Encountering build/type errors that might be \"fixed\" by deletion\n- Working in an environment where others might be active\n- Unsure if an operation is safe\n\n**Default stance: Cautious and communicative. Preserve work, ask questions, coordinate changes.**"
              }
            ]
          }
        ]
      }
    }
  ]
}