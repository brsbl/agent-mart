{
  "owner": {
    "id": "adeonir",
    "display_name": "Adeonir Kohl",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/3428733?u=b69b29699f0d5c48c641f553c2f9ec0c5de9c901&v=4",
    "url": "https://github.com/adeonir",
    "bio": "Senior Software Engineer | React developer, Node explorer, UI and CSS lover | Coffee to code and beer to celebrate",
    "stats": {
      "total_repos": 1,
      "total_plugins": 4,
      "total_commands": 18,
      "total_skills": 2,
      "total_stars": 6,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "adeonir/claude-code-extras",
      "url": "https://github.com/adeonir/claude-code-extras",
      "description": "A personal collection of plugins for Claude Code, organized as a plugin marketplace",
      "homepage": "",
      "signals": {
        "stars": 6,
        "forks": 0,
        "pushed_at": "2026-01-12T14:17:51Z",
        "created_at": "2025-12-03T01:09:41Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1468
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 120
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 5403
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 1347
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/debug-tools",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/debug-tools/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/debug-tools/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 589
        },
        {
          "path": "plugins/debug-tools/.mcp.json",
          "type": "blob",
          "size": 246
        },
        {
          "path": "plugins/debug-tools/CHANGELOG.md",
          "type": "blob",
          "size": 1717
        },
        {
          "path": "plugins/debug-tools/CLAUDE.md",
          "type": "blob",
          "size": 2987
        },
        {
          "path": "plugins/debug-tools/README.md",
          "type": "blob",
          "size": 4355
        },
        {
          "path": "plugins/debug-tools/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/debug-tools/agents/bug-investigator.md",
          "type": "blob",
          "size": 2804
        },
        {
          "path": "plugins/debug-tools/agents/log-injector.md",
          "type": "blob",
          "size": 2194
        },
        {
          "path": "plugins/debug-tools/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/debug-tools/commands/debug.md",
          "type": "blob",
          "size": 2050
        },
        {
          "path": "plugins/debug-tools/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/debug-tools/skills/debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/debug-tools/skills/debugging/SKILL.md",
          "type": "blob",
          "size": 2610
        },
        {
          "path": "plugins/design-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/design-builder/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/design-builder/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 817
        },
        {
          "path": "plugins/design-builder/CHANGELOG.md",
          "type": "blob",
          "size": 2646
        },
        {
          "path": "plugins/design-builder/CLAUDE.md",
          "type": "blob",
          "size": 5677
        },
        {
          "path": "plugins/design-builder/README.md",
          "type": "blob",
          "size": 5723
        },
        {
          "path": "plugins/design-builder/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/design-builder/agents/copy-extractor.md",
          "type": "blob",
          "size": 7306
        },
        {
          "path": "plugins/design-builder/agents/design-extractor.md",
          "type": "blob",
          "size": 10603
        },
        {
          "path": "plugins/design-builder/agents/figma-builder.md",
          "type": "blob",
          "size": 4366
        },
        {
          "path": "plugins/design-builder/agents/frontend-builder.md",
          "type": "blob",
          "size": 6058
        },
        {
          "path": "plugins/design-builder/agents/product-planner.md",
          "type": "blob",
          "size": 4772
        },
        {
          "path": "plugins/design-builder/agents/variants-builder.md",
          "type": "blob",
          "size": 8972
        },
        {
          "path": "plugins/design-builder/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/design-builder/commands/copy.md",
          "type": "blob",
          "size": 790
        },
        {
          "path": "plugins/design-builder/commands/design.md",
          "type": "blob",
          "size": 835
        },
        {
          "path": "plugins/design-builder/commands/figma.md",
          "type": "blob",
          "size": 1024
        },
        {
          "path": "plugins/design-builder/commands/frontend.md",
          "type": "blob",
          "size": 1647
        },
        {
          "path": "plugins/design-builder/commands/plan.md",
          "type": "blob",
          "size": 959
        },
        {
          "path": "plugins/design-builder/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/design-builder/skills/frontend-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/design-builder/skills/frontend-design/SKILL.md",
          "type": "blob",
          "size": 5259
        },
        {
          "path": "plugins/git-helpers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/git-helpers/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/git-helpers/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 566
        },
        {
          "path": "plugins/git-helpers/CHANGELOG.md",
          "type": "blob",
          "size": 1834
        },
        {
          "path": "plugins/git-helpers/CLAUDE.md",
          "type": "blob",
          "size": 2535
        },
        {
          "path": "plugins/git-helpers/README.md",
          "type": "blob",
          "size": 3476
        },
        {
          "path": "plugins/git-helpers/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/git-helpers/agents/code-reviewer.md",
          "type": "blob",
          "size": 3473
        },
        {
          "path": "plugins/git-helpers/agents/guidelines-auditor.md",
          "type": "blob",
          "size": 2429
        },
        {
          "path": "plugins/git-helpers/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/git-helpers/commands/code-review.md",
          "type": "blob",
          "size": 2317
        },
        {
          "path": "plugins/git-helpers/commands/commit.md",
          "type": "blob",
          "size": 2622
        },
        {
          "path": "plugins/git-helpers/commands/details.md",
          "type": "blob",
          "size": 4680
        },
        {
          "path": "plugins/git-helpers/commands/push-pr.md",
          "type": "blob",
          "size": 2311
        },
        {
          "path": "plugins/spec-driven",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/spec-driven/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/spec-driven/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 924
        },
        {
          "path": "plugins/spec-driven/.mcp.json",
          "type": "blob",
          "size": 202
        },
        {
          "path": "plugins/spec-driven/CHANGELOG.md",
          "type": "blob",
          "size": 7173
        },
        {
          "path": "plugins/spec-driven/CLAUDE.md",
          "type": "blob",
          "size": 7895
        },
        {
          "path": "plugins/spec-driven/README.md",
          "type": "blob",
          "size": 6834
        },
        {
          "path": "plugins/spec-driven/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/spec-driven/agents/architect.md",
          "type": "blob",
          "size": 4875
        },
        {
          "path": "plugins/spec-driven/agents/archiver.md",
          "type": "blob",
          "size": 3215
        },
        {
          "path": "plugins/spec-driven/agents/explorer.md",
          "type": "blob",
          "size": 3594
        },
        {
          "path": "plugins/spec-driven/agents/implementer.md",
          "type": "blob",
          "size": 4312
        },
        {
          "path": "plugins/spec-driven/agents/researcher.md",
          "type": "blob",
          "size": 4507
        },
        {
          "path": "plugins/spec-driven/agents/tasker.md",
          "type": "blob",
          "size": 4318
        },
        {
          "path": "plugins/spec-driven/agents/validator.md",
          "type": "blob",
          "size": 6504
        },
        {
          "path": "plugins/spec-driven/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/spec-driven/commands/archive.md",
          "type": "blob",
          "size": 2633
        },
        {
          "path": "plugins/spec-driven/commands/clarify.md",
          "type": "blob",
          "size": 1837
        },
        {
          "path": "plugins/spec-driven/commands/implement.md",
          "type": "blob",
          "size": 3101
        },
        {
          "path": "plugins/spec-driven/commands/init.md",
          "type": "blob",
          "size": 6826
        },
        {
          "path": "plugins/spec-driven/commands/plan.md",
          "type": "blob",
          "size": 4854
        },
        {
          "path": "plugins/spec-driven/commands/specs.md",
          "type": "blob",
          "size": 1430
        },
        {
          "path": "plugins/spec-driven/commands/tasks.md",
          "type": "blob",
          "size": 2028
        },
        {
          "path": "plugins/spec-driven/commands/validate.md",
          "type": "blob",
          "size": 4054
        }
      ],
      "marketplace": {
        "name": "claude-code-extras",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Adeonir Kohl",
          "url": "https://github.com/adeonir"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "spec-driven",
            "description": "Specification-driven development workflow with brownfield support, requirements traceability, task management, and implementation",
            "source": "./plugins/spec-driven",
            "category": null,
            "version": "2.5.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add adeonir/claude-code-extras",
              "/plugin install spec-driven@claude-code-extras"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2026-01-12T14:17:51Z",
              "created_at": "2025-12-03T01:09:41Z",
              "license": null
            },
            "commands": [
              {
                "name": "/archive",
                "description": "Generate docs and mark feature as archived",
                "path": "plugins/spec-driven/commands/archive.md",
                "frontmatter": {
                  "description": "Generate docs and mark feature as archived",
                  "argument-hint": [
                    "ID"
                  ]
                },
                "content": "# Archive Command\n\nGenerate documentation from the completed feature and mark it as archived.\n\n## Arguments\n\n- `[ID]` - Feature ID (optional if branch is associated)\n\nArguments received: $ARGUMENTS\n\n## Process\n\n### Step 1: Resolve Feature\n\nIf ID provided:\n- Use that feature directly\n\nIf no ID:\n- Get current git branch\n- Search `.specs/*/spec.md` for matching `branch:` in frontmatter\n- If found, use that feature\n- If not found, list available features and ask user to specify\n\n### Step 2: Validate Status\n\nRead `.specs/{ID}-{feature}/spec.md` frontmatter.\n\nCheck status:\n- If `done`: proceed\n- If `to-review`: suggest running `/spec-driven:validate` first\n- If other: inform user feature is not ready for archive\n\n### Step 3: Load Artifacts\n\nRead from `.specs/{ID}-{feature}/`:\n- `spec.md` - Overview and feature description\n- `plan.md` - Architecture decisions\n- `tasks.md` - Count completed tasks\n\n### Step 4: Check for Existing Docs\n\nDetermine target path from feature name (e.g., `add-2fa` -> `docs/features/auth.md` or new file).\n\nIf `docs/features/{relevant}.md` exists:\n- Will update that file with new content\n\nIf not:\n- Will create new file\n\n### Step 5: Generate Feature Documentation\n\nCreate/update `docs/features/{feature}.md` (NO changelog section - just permanent docs):\n\n```markdown\n# {Feature Title}\n\n## Overview\n\n{from spec.md Overview section}\n\n## Architecture Decisions\n\n{from plan.md Architecture Decision section}\n```\n\n### Step 6: Update Centralized Changelog\n\nUpdate `docs/CHANGELOG.md` (create if not exists):\n\n```markdown\n# Changelog\n\n## {YYYY-MM-DD}\n\n### Added\n- {New capabilities from this feature}\n\n### Changed\n- {Modified behaviors}\n\n### Removed\n- {Deprecated/removed items}\n\n## {previous date}\n...\n```\n\nRules for changelog:\n- Add new date section at TOP of file (after # Changelog header)\n- Use Keep a Changelog format (Added/Changed/Removed/Fixed/Deprecated/Security)\n- Only include sections that have entries\n- Each entry describes user-visible change, not implementation detail\n\n### Step 7: Update Status\n\nUpdate `.specs/{ID}-{feature}/spec.md` frontmatter:\n- Set `status: archived`\n\n### Step 8: Report\n\nInform user:\n- Documentation generated/updated at `docs/features/{file}.md`\n- Changelog entry added to `docs/CHANGELOG.md`\n- Feature marked as archived\n- User can delete `.specs/{ID}-{feature}/` manually if desired\n\n## Error Handling\n\n- **Feature not found**: List available features\n- **Not in done status**: Suggest running `/spec-driven:validate` first\n- **Missing artifacts**: Note which files are missing"
              },
              {
                "name": "/clarify",
                "description": "Resolve ambiguities in the specification",
                "path": "plugins/spec-driven/commands/clarify.md",
                "frontmatter": {
                  "description": "Resolve ambiguities in the specification",
                  "argument-hint": [
                    "ID"
                  ]
                },
                "content": "# Clarify Command\n\nIdentify and resolve items marked [NEEDS CLARIFICATION] in the specification.\n\n## Arguments\n\n- `[ID]` - Feature ID (optional if branch is associated)\n\nArguments received: $ARGUMENTS\n\n## Process\n\n### Step 1: Resolve Feature\n\nIf ID provided:\n- Use that feature directly\n\nIf no ID:\n- Get current git branch\n- Search `.specs/*/spec.md` for matching `branch:` in frontmatter\n- If found, use that feature\n- If not found:\n  - If only one feature exists, use it\n  - If multiple, list them and ask user to specify\n\n### Step 2: Load Specification\n\nRead `.specs/{ID}-{feature}/spec.md`\n\nIf file doesn't exist, inform user to run `/init` first.\n\n### Step 3: Find Clarifications Needed\n\nSearch for all `[NEEDS CLARIFICATION: ...]` markers in the spec.\n\nIf none found:\n- Inform user the spec is complete\n- Suggest running `/spec-driven:plan` next\n- Exit\n\n### Step 4: Present Questions\n\nFor each clarification needed:\n- Present the question clearly\n- Provide context from the surrounding spec content\n- Suggest options if applicable\n\nUse AskUserQuestion for structured choices when appropriate.\n\n### Step 5: Update Specification\n\nFor each answered question:\n- Replace the `[NEEDS CLARIFICATION: ...]` marker with the clarified content\n- Keep the spec well-formatted\n\n### Step 6: Report\n\nAfter all clarifications:\n- Show summary of what was clarified\n- Check if any new clarifications emerged\n- Suggest `/spec-driven:plan` as next step if spec is complete\n\n## Error Handling\n\n- **Feature not found**: List available features or suggest `/spec-driven:init`\n- **Spec not found**: Inform user to run `/spec-driven:init` first\n- **User unsure**: Mark as still needing clarification, move on\n- **Conflicting answers**: Ask for resolution before proceeding"
              },
              {
                "name": "/implement",
                "description": null,
                "path": "plugins/spec-driven/commands/implement.md",
                "frontmatter": null,
                "content": "---\ndescription: Execute implementation tasks\nargument-hint: [ID] [T001 | T001-T005 | --all]\n---\n\n# Implement Command\n\nExecute tasks from the task list, respecting dependencies and updating progress.\n\n## Arguments\n\n| Input | Action |\n|-------|--------|\n| `[ID]` | Feature ID (optional if branch is associated) |\n| (empty) | Next pending task |\n| `T001` | Single task |\n| `T001-T005` | Range of tasks |\n| `--all` | All pending tasks |\n\nArguments received: $ARGUMENTS\n\n## Process\n\n### Step 1: Resolve Feature\n\nParse arguments to extract:\n- Feature ID (if provided as first numeric arg or `XXX-name` format)\n- Task scope (T001, T001-T005, --all, or empty)\n\nIf no ID:\n- Get current git branch\n- Search `.specs/*/spec.md` for matching `branch:` in frontmatter\n- If found, use that feature\n- If not found:\n  - If only one feature exists, use it\n  - If multiple, list them and ask user to specify\n\n### Step 2: Load Context\n\nRead from `.specs/{ID}-{feature}/`:\n- `spec.md` - Requirements (extract Acceptance Criteria section)\n- `plan.md` - Technical decisions and Critical Files\n- `tasks.md` - Task list and progress\n\nCheck `docs/research/` for any referenced research files.\n\nIf plan.md or tasks.md don't exist, inform user to run `/spec-driven:plan` and `/spec-driven:tasks` first.\n\n### Step 3: Update Status\n\nIf status is `ready` or `draft`:\n- Update spec.md frontmatter to `status: in-progress`\n\n### Step 4: Load Critical Files\n\nFrom plan.md, identify the `## Critical Files` section.\n\nFor the tasks about to execute:\n- Read the **Reference Files** relevant to current tasks (max 5 files)\n- These provide patterns and conventions to follow\n\n### Step 5: Parse Scope\n\nDetermine which tasks to execute based on arguments.\n\n### Step 6: Validate Dependencies\n\nFor each task to execute:\n- If marked `[P]`, can proceed\n- If marked `[B:Txxx]`, check if Txxx is completed\n- Skip blocked tasks, inform user\n\n### Step 7: Execute Tasks\n\nInvoke the `implementer` agent with:\n- Task scope\n- Specification (Acceptance Criteria section)\n- Technical plan\n- Research summary (if exists)\n- Current task list\n- Reference file contents\n- Feature ID and name\n\nThe agent will:\n- Implement each task following the plan\n- Validate against acceptance criteria\n- Follow patterns from reference files\n- Update tasks.md with checkboxes\n- Suggest atomic commits\n\n### Step 8: Check Completion\n\nAfter execution, check if ALL tasks are completed.\n\nIf all tasks done:\n- Update spec.md frontmatter to `status: to-review`\n- Inform user that implementation is complete\n\n### Step 9: Report\n\nAfter execution:\n- Show tasks completed\n- Show files created/modified\n- Show remaining tasks (if any)\n- Suggest commit message\n- If all done: suggest `/spec-driven:validate` for final review\n- If tasks remain: suggest continuing with `/spec-driven:implement`\n\n## Error Handling\n\n- **Feature not found**: List available features or suggest `/spec-driven:init`\n- **Plan/tasks not found**: Inform user to run previous commands\n- **Dependency blocked**: List which tasks need to complete first\n- **Implementation error**: Report issue, keep task unchecked\n"
              },
              {
                "name": "/init",
                "description": "Create feature specification from description or PRD",
                "path": "plugins/spec-driven/commands/init.md",
                "frontmatter": {
                  "description": "Create feature specification from description or PRD",
                  "argument-hint": "<description> | @<file.md>"
                },
                "content": "# Init Command\n\nInitialize a new feature with a structured specification file.\n\n## Arguments\n\n- `<description>` - Text describing the feature\n- `@<file.md>` - Path to PRD file to use as context\n- `--link <ID>` - Associate current branch with existing feature\n\nArguments received: $ARGUMENTS\n\n## Process\n\n### Step 1: Handle --link Flag\n\nIf `--link <ID>` provided:\n- Find feature with that ID in `.specs/`\n- Get current git branch\n- Update the feature's `spec.md` frontmatter with `branch: {current_branch}`\n- Inform user and exit\n\n### Step 2: Generate Feature ID\n\nScan `.specs/` directory for existing features.\nFind the highest ID number and increment by 1.\n\nExample: If `.specs/003-payment-flow/` exists, next ID is `004`.\n\nIf `.specs/` doesn't exist, start with `001`.\n\n### Step 2b: Detect Greenfield vs Brownfield\n\nAnalyze the user's description to determine if this is greenfield (new) or brownfield (change to existing).\n\n**1. Extract keywords from description:**\n\nBrownfield keywords:\n- \"melhorar\", \"refatorar\", \"corrigir\", \"otimizar\"\n- \"estender\", \"adicionar a\", \"modificar\", \"atualizar\"\n- \"improve\", \"refactor\", \"fix\", \"optimize\"\n- \"extend\", \"add to\", \"modify\", \"update\"\n\nGreenfield keywords:\n- \"criar\", \"novo\", \"implementar do zero\"\n- \"create\", \"new\", \"implement from scratch\"\n\n**2. Search codebase for related code:**\n\nExtract technical terms from the description (e.g., \"cache\", \"auth\", \"payment\").\n\nUse Glob/Grep to find related files:\n```bash\n# Example for \"improve cache performance\"\nfind . -name \"*cache*\" -type f\ngrep -r \"cache\" --include=\"*.ts\" --include=\"*.js\" -l\n```\n\n**3. Determine type:**\n\n| Keywords | Code Found | Type |\n|----------|------------|------|\n| Greenfield | No | `greenfield` |\n| Greenfield | Yes | Ask user |\n| Brownfield | No | Ask user |\n| Brownfield | Yes | `brownfield` |\n| Unclear | No | `greenfield` |\n| Unclear | Yes | Ask user |\n\n**4. If ambiguous, ask user:**\n\n```\n> Found related code in: src/cache/redis.ts, src/cache/memory.ts\n> Is this:\n> 1. Feature nova (greenfield) - nao relacionada ao codigo existente\n> 2. Mudanca em codigo existente (brownfield)\n```\n\nStore detected type for use in Step 7.\n\n### Step 3: Process Input\n\nIf input is a file reference (@file.md):\n- Read the file content as PRD context\n\nIf input is text:\n- Use as feature description\n\nIf input is empty:\n- Ask the user for a feature description\n\n### Step 4: Process Referenced Documentation\n\nWhen documentation is referenced with @path:\n\n1. **List all files** in the referenced path\n2. **Read each file completely**\n3. **Extract** from each file:\n   - Rules (words: \"must\", \"cannot\", \"always\", \"never\", \"required\")\n   - Constraints (words: \"only if\", \"when\", \"unless\")\n   - Examples (code blocks, diagrams, sample data)\n4. **For each item found**, ask: \"Is this relevant to the feature?\"\n5. **If relevant**, it MUST become an FR or AC in the spec\n6. **If skipped**, note WHY in the Notes section\n\nOutput before generating spec:\n\n```markdown\n## Extracted from Documentation\n\n| Source | Item | Relevant | Mapped To |\n|--------|------|----------|-----------|\n| {file} | {rule/constraint} | Yes/No | FR-xxx / AC-xxx / Skipped: {reason} |\n```\n\n### Step 4b: Baseline Discovery (if brownfield)\n\nIf type is `brownfield`, gather information about the current implementation.\n\n**1. Find related files:**\n\nUse the technical terms and file paths found in Step 2b.\n\n**2. Read main files:**\n\nFor each related file (up to 5 most relevant):\n- Read the file content\n- Identify key behaviors, functions, classes\n- Note current implementation approach\n\n**3. Document baseline:**\n\nPrepare baseline information for spec.md:\n- List of related files with brief descriptions\n- Current behavior summary\n- Points that will be modified\n\nExample baseline data:\n```\nFiles: src/cache/redis.ts, src/cache/memory.ts\nCurrent: Fixed TTL of 3600s, manual invalidation only\nModification points: TTL configuration, tag-based invalidation\n```\n\n### Step 5: Generate Feature Name\n\nFrom the description, derive a short kebab-case name:\n- \"Add two-factor authentication\" -> `add-2fa`\n- \"User registration flow\" -> `user-registration`\n\n### Step 6: Check Branch Association\n\nGet current git branch:\n```bash\ngit branch --show-current\n```\n\nAsk user:\n- \"Associate this feature with branch `{branch}`?\" (Yes/No)\n\nIf on main/master, suggest creating a new branch.\n\n### Step 7: Generate Specification\n\nCreate `.specs/{ID}-{feature}/spec.md` with frontmatter and content:\n\n**Frontmatter:**\n```yaml\n---\nid: {ID}\nfeature: {feature-name}\ntype: {greenfield | brownfield}  # from Step 2b\nstatus: draft\nbranch: {branch or empty}\ncreated: {YYYY-MM-DD}\n---\n```\n\n**Content for greenfield:**\n```markdown\n# Feature: {Feature Title}\n\n## Overview\n\n{brief_description}\n\n## User Stories\n\n- As a {user_type}, I want {goal} so that {benefit}\n\n## Functional Requirements\n\n- [ ] FR-001: {requirement}\n- [ ] FR-002: {requirement}\n\n## Acceptance Criteria\n\n- [ ] AC-001: {criterion}\n- [ ] AC-002: {criterion}\n\n## Notes\n\n{additional_context}\n\n<!-- Items marked [NEEDS CLARIFICATION] require resolution before plan -->\n```\n\n**Content for brownfield (includes Baseline section):**\n```markdown\n# Feature: {Feature Title}\n\n## Overview\n\n{brief_description}\n\n## Baseline\n\nEstado atual baseado em analise de: {list of files analyzed}\n\n### Arquivos Relacionados\n\n- `{file_path}`: {brief description of current behavior}\n- `{file_path}`: {brief description of current behavior}\n\n### Comportamento Atual\n\n- {description of current implementation}\n- {description of current implementation}\n\n### Pontos de Modificacao\n\n- {component/file} sera modificado para {action}\n- {component/file} sera modificado para {action}\n\n## User Stories\n\n- As a {user_type}, I want {goal} so that {benefit}\n\n## Functional Requirements\n\n- [ ] FR-001: {requirement}\n- [ ] FR-002: {requirement}\n\n## Acceptance Criteria\n\n- [ ] AC-001: {criterion}\n- [ ] AC-002: {criterion}\n\n## Notes\n\n{additional_context}\n\n<!-- Items marked [NEEDS CLARIFICATION] require resolution before plan -->\n```\n\n### Step 8: Mark Ambiguities\n\nFor any unclear or underspecified items, add:\n```\n[NEEDS CLARIFICATION: specific question]\n```\n\n### Step 9: Report\n\nInform the user:\n- Feature created: `{ID}-{feature}`\n- Type: `{greenfield | brownfield}`\n- Spec file at `.specs/{ID}-{feature}/spec.md`\n- Branch associated: `{branch}` (or \"none\")\n- If brownfield: Number of related files analyzed\n- Number of items needing clarification (if any)\n- Next step: `/spec-driven:clarify` to resolve ambiguities, or `/spec-driven:plan` if none\n\n## Error Handling\n\n- **No input provided**: Ask user for feature description\n- **File not found**: Inform user and ask for correct path\n- **ID conflict**: Should not happen, but regenerate if it does"
              },
              {
                "name": "/plan",
                "description": null,
                "path": "plugins/spec-driven/commands/plan.md",
                "frontmatter": null,
                "content": "---\ndescription: Explore codebase and generate technical plan\nargument-hint: [ID] [additional instructions]\n---\n\n# Plan Command\n\nAnalyze the codebase and create a comprehensive technical plan for implementing the feature.\n\n## Arguments\n\n- `[ID]` - Feature ID (optional if branch is associated)\n- `[additional instructions]` - Extra context for research or planning\n\nArguments received: $ARGUMENTS\n\n## Process\n\n### Step 1: Resolve Feature\n\nIf ID provided (numeric or full like `002-add-2fa`):\n- Use that feature directly\n\nIf no ID:\n- Get current git branch\n- Search `.specs/*/spec.md` for matching `branch:` in frontmatter\n- If found, use that feature\n- If not found:\n  - If only one feature exists, use it\n  - If multiple, list them and ask user to specify\n\n### Step 2: Load Specification\n\nRead `.specs/{ID}-{feature}/spec.md`\n\nIf file doesn't exist, inform user to run `/init` first.\n\n### Step 3: Check for Clarifications\n\nSearch for `[NEEDS CLARIFICATION]` in the spec.\n\nIf found:\n- List the items needing clarification\n- Suggest running `/spec-driven:clarify` first\n- Exit\n\n### Step 4: Research External Information\n\nDetermine if web research is needed by checking:\n1. **User provided additional instructions** with the `/plan` command\n2. **Spec mentions external technologies**: libraries, frameworks, APIs, services\n3. **Spec references standards or protocols** that need verification\n\nIf research is needed:\n- Check if `docs/research/{topic}.md` already exists for the technology\n- If exists, use existing research\n- If not, invoke the `researcher` agent\n\nThe researcher will create `docs/research/{topic}.md` with findings (shared across features).\n\nSkip research if:\n- The spec is purely about internal code changes\n- No external dependencies mentioned\n- Research already exists for all mentioned technologies\n\n### Step 5: Explore Codebase\n\nInvoke the `explorer` agent to analyze the codebase:\n\nAsk it to explore:\n- Similar existing features\n- Architecture patterns and conventions\n- Relevant entry points and integration areas\n- Testing patterns\n\nYou may launch 2-3 explorer agents in parallel with different focuses.\n\n### Step 6: Review Exploration\n\nRead the files identified as essential by the explorers.\n\n**Consolidate Critical Files:**\n- **Reference Files**: Patterns to follow\n- **Files to Modify**: Existing files that need changes\n- **Files to Create**: New files to be added\n\n### Step 7: Generate Plan\n\nInvoke the `architect` agent with:\n- The specification (spec.md)\n- Research summary (from docs/research/ if applicable)\n- Exploration insights\n- Consolidated critical files list\n- Feature ID and name\n\nThe architect will create `.specs/{ID}-{feature}/plan.md`\n\nInclude a Research Summary section if external research was used:\n```markdown\n## Research Summary\n\n> From [docs/research/totp-authentication.md]\n\nKey points:\n- {relevant findings}\n```\n\n### Step 8: Validate Plan Against Documentation\n\nAfter plan.md is generated, validate it against project documentation.\n\n**Discover Project Documentation:**\n- Find docs/*.md, README.md, *.md in project root\n- Include files referenced in spec.md\n- Check for architecture diagrams, ADRs, or specs\n\n**Invoke validator Agent (Mode Plan):**\n\nPass to the agent:\n- Validation mode: `plan`\n- spec.md (requirements context)\n- plan.md (just generated)\n- List of discovered documentation files\n\n**Handle Validation Results:**\n\nIf `Ready`:\n- Continue to Step 9\n\nIf `Needs fixes`:\n1. Present validation results to user (informational)\n2. Re-invoke `architect` with:\n   - Original inputs\n   - List of specific corrections from validator\n   - Explicit instruction: \"Documentation is the source of truth. Address these inconsistencies.\"\n3. After new plan.md generated, re-validate\n4. Repeat until `Ready` or max 3 iterations reached\n\nIf max iterations reached with issues remaining:\n- Report the remaining inconsistencies\n- Ask user how to proceed:\n  - **Continue anyway**: Proceed to Step 9 (plan may need manual adjustment later)\n  - **Review documentation**: User will check if documentation is accurate/outdated\n  - **Manually adjust plan**: User will edit plan.md directly to resolve issues\n\n### Step 9: Update Status\n\nUpdate spec.md frontmatter:\n- Set `status: ready`\n\n### Step 10: Report\n\nInform the user:\n- Research conducted (if applicable) at `docs/research/{topic}.md`\n- Plan created at `.specs/{ID}-{feature}/plan.md`\n- Plan validated against documentation (X iterations if corrections were needed)\n- Key architectural decisions made\n- Next step: `/spec-driven:tasks` to generate task list\n\n## Error Handling\n\n- **Feature not found**: List available features or suggest `/spec-driven:init`\n- **Spec not found**: Inform user to run `/spec-driven:init` first\n- **Clarifications pending**: Suggest `/spec-driven:clarify` first\n- **Codebase unclear**: Ask user for guidance on patterns to follow\n"
              },
              {
                "name": "/specs",
                "description": "List all features by status",
                "path": "plugins/spec-driven/commands/specs.md",
                "frontmatter": {
                  "description": "List all features by status"
                },
                "content": "# /specs Command\n\nList all features in `.specs/` organized by status.\n\n## Process\n\n1. **Scan .specs/ directory**\n   - Find all feature directories matching pattern `{ID}-{name}/`\n   - Read `spec.md` frontmatter from each\n\n2. **Parse metadata**\n   - Extract: id, feature, status, branch, created\n   - Sort by ID (ascending)\n\n3. **Group by status**\n   - Group features by their status field\n   - Order: in-progress, to-review, ready, draft, done, archived\n\n4. **Display summary**\n\n## Output Format\n\n```markdown\n## Features\n\n### In Progress\n| ID | Feature | Branch | Created |\n|----|---------|--------|---------|\n| 003 | payment-flow | feat/payments | 2025-01-02 |\n\n### Review\n| ID | Feature | Branch | Created |\n|----|---------|--------|---------|\n| 002 | add-2fa | feat/add-2fa | 2025-01-01 |\n\n### Done\n| ID | Feature | Branch | Created |\n|----|---------|--------|---------|\n| 001 | user-auth | - | 2024-12-15 |\n\n---\nTotal: 3 features\n```\n\n## Edge Cases\n\n- **No .specs/ directory**: \"No features found. Use /spec-driven:init to create one.\"\n- **Empty .specs/**: \"No features found. Use /spec-driven:init to create one.\"\n- **Missing frontmatter**: Show with status \"unknown\"\n- **Invalid directory name**: Skip (not a feature)\n\n## Filtering (optional)\n\n```bash\n/specs                    # All features\n/specs --status ready     # Only ready\n/specs --status done      # Only done\n```"
              },
              {
                "name": "/tasks",
                "description": "Generate task list from technical plan",
                "path": "plugins/spec-driven/commands/tasks.md",
                "frontmatter": {
                  "description": "Generate task list from technical plan",
                  "argument-hint": [
                    "ID"
                  ]
                },
                "content": "# Tasks Command\n\nTransform the technical plan into an organized, trackable task list.\n\n## Arguments\n\n- `[ID]` - Feature ID (optional if branch is associated)\n\nArguments received: $ARGUMENTS\n\n## Process\n\n### Step 1: Resolve Feature\n\nIf ID provided:\n- Use that feature directly\n\nIf no ID:\n- Get current git branch\n- Search `.specs/*/spec.md` for matching `branch:` in frontmatter\n- If found, use that feature\n- If not found:\n  - If only one feature exists, use it\n  - If multiple, list them and ask user to specify\n\n### Step 2: Load Specification\n\nRead `.specs/{ID}-{feature}/spec.md` to have access to:\n- Functional requirements (FR-xxx)\n- Acceptance criteria (AC-xxx)\n\n### Step 3: Load Plan\n\nRead `.specs/{ID}-{feature}/plan.md`\n\nIf file doesn't exist, inform user to run `/plan` first.\n\n### Step 4: Generate Tasks\n\nInvoke the `tasker` agent with:\n- The specification (spec.md) with requirements\n- The technical plan (plan.md)\n- Feature ID and name\n\nThe agent will create `.specs/{ID}-{feature}/tasks.md` with:\n- Sequential IDs (T001, T002...)\n- Dependency markers [P] and [B:Txxx]\n- Categories (Foundation, Implementation, Validation, Documentation)\n- Checkboxes for tracking\n- Requirements coverage table\n\n### Step 5: Report\n\nInform the user:\n- Tasks created at `.specs/{ID}-{feature}/tasks.md`\n- Next step: `/spec-driven:implement` to start implementation\n\nShow a summary table:\n```\n## Task Summary\n\n| Category | Tasks | Complexity |\n|----------|-------|------------|\n| Foundation | T001-T002 | Low |\n| Implementation | T003-T006 | High |\n| Validation | T007-T008 | Medium |\n| Documentation | T009 | Low |\n\nRun `/spec-driven:implement` to start, or `/spec-driven:implement T001` for a specific task.\n```\n\n## Error Handling\n\n- **Feature not found**: List available features or suggest `/spec-driven:init`\n- **Plan not found**: Inform user to run `/spec-driven:plan` first\n- **Plan incomplete**: Point out missing sections, suggest updating plan"
              },
              {
                "name": "/validate",
                "description": "Validate artifacts, code, and acceptance criteria",
                "path": "plugins/spec-driven/commands/validate.md",
                "frontmatter": {
                  "description": "Validate artifacts, code, and acceptance criteria",
                  "argument-hint": [
                    "ID"
                  ]
                },
                "content": "# Validate Command\n\nValidate feature artifacts at any workflow phase. Automatically detects which artifacts exist and runs appropriate validation mode.\n\n## Arguments\n\n- `[ID]` - Feature ID (optional if branch is associated)\n\nArguments received: $ARGUMENTS\n\n## Process\n\n### Step 1: Resolve Feature\n\nIf ID provided:\n- Use that feature directly\n\nIf no ID:\n- Get current git branch\n- Search `.specs/*/spec.md` for matching `branch:` in frontmatter\n- If found, use that feature\n- If not found:\n  - If only one feature exists, use it\n  - If multiple, list them and ask user to specify\n\n### Step 2: Detect Validation Mode\n\nCheck which artifacts exist in `.specs/{ID}-{feature}/`:\n\n| Artifacts Present | Mode | Description |\n|-------------------|------|-------------|\n| spec.md only | **Spec** | Validate spec structure |\n| spec.md + plan.md | **Plan** | + documentation compliance |\n| spec.md + plan.md + tasks.md | **Tasks** | + requirements coverage |\n| All + status is in-progress/to-review | **Full** | + code validation |\n\nInform user which mode will be used:\n```\nDetected mode: {mode} (found: spec.md, plan.md, tasks.md)\n```\n\n### Step 3: Load Context\n\nBased on detected mode, read:\n- **Mode Spec**: `spec.md`\n- **Mode Plan**: `spec.md`, `plan.md`, docs files from plan.md references\n- **Mode Tasks**: `spec.md`, `plan.md`, `tasks.md`\n- **Mode Full**: All artifacts + `git diff`\n\n### Step 4: Discover Documentation (Mode Plan+)\n\nIf mode is Plan or higher:\n- Find docs/*.md, README.md in project root\n- Find files referenced in spec.md\n- Look for architecture docs, ADRs\n\n### Step 5: Invoke Validator\n\nInvoke the `validator` agent with:\n- Validation mode\n- Available artifacts\n- Documentation files list (for Plan+)\n- git diff (for Full mode)\n\n### Step 6: Present Results\n\nShow validation results based on mode:\n\n**Mode Spec:**\n```markdown\n## Validation: {ID}-{feature}\n\n### Mode: Spec\n\n### Artifact Structure\n\n| File | Status | Issues |\n|------|--------|--------|\n| spec.md | Valid | - |\n\n### Summary\n\n- Status: **Ready for /plan** or **Needs clarification**\n\n### Next Steps\n\n- Run `/spec-driven:clarify` if ambiguities found\n- Run `/spec-driven:plan` to generate technical plan\n```\n\n**Mode Plan:**\n```markdown\n## Validation: {ID}-{feature}\n\n### Mode: Plan\n\n### Artifact Structure\n\n| File | Status | Issues |\n|------|--------|--------|\n| spec.md | Valid | - |\n| plan.md | Valid | - |\n\n### Documentation Compliance\n\n| Severity | Issue | Source |\n|----------|-------|--------|\n| ... | ... | ... |\n\n### Summary\n\n- Status: **Ready for /tasks** or **Needs corrections**\n```\n\n**Mode Tasks:**\n```markdown\n## Validation: {ID}-{feature}\n\n### Mode: Tasks\n\n### Consistency\n\n| Check | Status |\n|-------|--------|\n| Requirements coverage | Passed (5/5 FR have tasks) |\n| AC coverage | Passed (4/4 AC addressed) |\n| Task dependencies | Passed |\n\n### Summary\n\n- Status: **Ready for /implement** or **Needs fixes**\n```\n\n**Mode Full:**\n(Full output as in validator agent)\n\n### Step 7: Determine Outcome\n\n**Mode Spec/Plan/Tasks:**\n- If valid: Suggest next command in workflow\n- If issues: List what needs fixing\n\n**Mode Full:**\n- **If all checks pass:**\n  - Update spec.md frontmatter to `status: done`\n  - Inform user feature is complete\n  - Suggest `/spec-driven:archive` to generate documentation\n\n- **If any checks fail:**\n  - Keep status as `to-review`\n  - List issues that need fixing\n  - Suggest running `/spec-driven:implement` to fix issues\n\n### Step 8: Report\n\nSummary with next steps based on mode:\n\n| Mode | If Valid | If Issues |\n|------|----------|-----------|\n| Spec | Run /plan | Run /clarify |\n| Plan | Run /tasks | Fix plan inconsistencies |\n| Tasks | Run /implement | Fix coverage gaps |\n| Full | Run /archive | Run /implement |\n\n## Error Handling\n\n- **Feature not found**: List available features or suggest `/spec-driven:init`\n- **No artifacts**: Suggest `/spec-driven:init` to start\n- **No code changes (Full mode)**: Warn and suggest running /implement first"
              }
            ],
            "skills": []
          },
          {
            "name": "debug-tools",
            "description": "Iterative debugging workflow with confidence scoring and runtime analysis via Console Ninja and Chrome DevTools MCP",
            "source": "./plugins/debug-tools",
            "category": null,
            "version": "1.3.1",
            "author": null,
            "install_commands": [
              "/plugin marketplace add adeonir/claude-code-extras",
              "/plugin install debug-tools@claude-code-extras"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2026-01-12T14:17:51Z",
              "created_at": "2025-12-03T01:09:41Z",
              "license": null
            },
            "commands": [
              {
                "name": "/debug",
                "description": "Start debugging session with investigation and targeted logging",
                "path": "plugins/debug-tools/commands/debug.md",
                "frontmatter": {
                  "description": "Start debugging session with investigation and targeted logging",
                  "argument-hint": "bug description"
                },
                "content": "# Debug Command\n\nStart an iterative debugging session to find and fix bugs.\n\n## Arguments\n\n- `\"bug description\"` - Description of the bug or unexpected behavior\n\nArguments received: $ARGUMENTS\n\n## Workflow\n\n```mermaid\nflowchart TD\n    start[\"/debug\"] --> investigate[1: Investigate]\n    investigate --> found{Root cause?}\n    found -->|Yes| fix[3: Propose Fix]\n    found -->|No| inject[2: Inject Logs]\n    inject --> reproduce[Reproduce + Analyze]\n    reproduce --> investigate\n    fix --> verify[4: Verify]\n    verify -->|Fixed| cleanup[5: Cleanup]\n    verify -->|Not fixed| investigate\n```\n\n## Phases\n\n### Phase 1: Investigate\n\nInvoke the `bug-investigator` agent to:\n- Analyze code related to the bug\n- Find root cause with confidence scoring\n- Report findings >= 70 confidence as probable cause\n- Suggest logs for findings 50-69 confidence\n\n### Phase 2: Inject Logs (if needed)\n\nIf runtime data is needed, invoke the `log-injector` agent to:\n- Add targeted `[DEBUG]` logs at strategic points\n- Report locations and what each log captures\n- Ask user to reproduce the bug\n\n### Phase 3: Propose Fix\n\nWhen root cause is confirmed:\n- Present minimal fix in diff format\n- Include confidence score\n- Ask user to approve\n\n### Phase 4: Verify\n\nAfter fix is applied:\n- Ask user to verify the bug is fixed\n- If not fixed, return to Phase 1\n- If fixed, proceed to cleanup\n\n### Phase 5: Cleanup\n\nAutomatically remove all debug logs:\n- Find all `[DEBUG]` statements\n- Remove them from code\n- Report cleanup summary\n\n## When to Use\n\n- Bug with unexpected behavior\n- Silent errors or intermittent failures\n- Issues requiring runtime data\n\n## When NOT to Use\n\n- Syntax errors (linter resolves)\n- Type errors (TypeScript resolves)\n- Obvious bugs in diff (use `/git-helpers:code-review`)\n\n## Notes\n\n- Cleanup is automatic after fix is verified\n- Debug logs use `[DEBUG]` prefix for easy identification\n- All findings include file:line references"
              }
            ],
            "skills": [
              {
                "name": "debugging",
                "description": "Guide for debugging with targeted log injection and runtime analysis",
                "path": "plugins/debug-tools/skills/debugging/SKILL.md",
                "frontmatter": {
                  "name": "debugging",
                  "description": "Guide for debugging with targeted log injection and runtime analysis",
                  "context": "fork"
                },
                "content": "# Debugging Skill\n\nGuide for debugging with targeted log injection and runtime analysis.\n\n## When to Activate\n\nSuggest `/debug-tools:debug` when users describe:\n- \"X is not working\"\n- \"Getting error Y when doing Z\"\n- \"Something broke after [change]\"\n- Silent failures or unexpected behavior\n\n## Log Format\n\n```javascript\nconsole.log('[DEBUG] [file:line] description', { values });\n```\n\n- `[DEBUG]` - Prefix for grep and cleanup\n- `[file:line]` - Location for navigation\n- `description` - What this log checks\n- `{ values }` - Relevant data (no sensitive info)\n\n## Log Patterns\n\n### React/Next.js\n\n```javascript\n// Lifecycle\nconsole.log('[DEBUG] [Component.tsx:10] mount', { props });\n\n// Effect\nuseEffect(() => {\n  console.log('[DEBUG] [Component.tsx:15] effect run', { deps });\n  return () => console.log('[DEBUG] [Component.tsx:17] cleanup');\n}, [deps]);\n\n// State\nconsole.log('[DEBUG] [Component.tsx:25] before setState', { current: state });\n```\n\n### Node.js/Express\n\n```javascript\n// Request\nconsole.log('[DEBUG] [route.ts:10] request', { method: req.method, path: req.path });\n\n// Error\nconsole.log('[DEBUG] [service.ts:30] caught error', { name: err.name, message: err.message });\n```\n\n### API Calls\n\n```javascript\nconsole.log('[DEBUG] [api.ts:10] fetch start', { url, method });\nconsole.log('[DEBUG] [api.ts:15] fetch done', { status: res.status, ok: res.ok });\n```\n\n## Common Bug Patterns\n\n| Pattern | Symptom | Check |\n|---------|---------|-------|\n| Null access | \"Cannot read property X of undefined\" | Optional chaining, defaults |\n| Race condition | Works sometimes, fails randomly | Async ordering, state timing |\n| Stale closure | Using old values in callbacks | useCallback deps, event bindings |\n| API mismatch | Data not displaying | Response shape, null handling |\n| Silent error | Nothing happens | Empty catch blocks, missing error state |\n\n## Confidence Scoring\n\n| Score | Meaning | Action |\n|-------|---------|--------|\n| >= 70 | High - clear evidence | Report as probable cause |\n| 50-69 | Medium - possible | Suggest logs to confirm |\n| < 50 | Low - speculation | Do not report |\n\n## Cleanup\n\nAfter debugging, all `[DEBUG]` logs are removed automatically.\n\nManual check:\n\n```bash\ngrep -rn '\\[DEBUG\\]' . --include='*.ts' --include='*.tsx' --include='*.js' --include='*.jsx'\n```\n\n## MCP Integration\n\n| MCP | Provides |\n|-----|----------|\n| Console Ninja | Runtime values, test status, coverage |\n| Chrome DevTools | Network inspection, browser console, DOM state |"
              }
            ]
          },
          {
            "name": "design-builder",
            "description": "Extract copy and design from references to build React frontend or Figma designs",
            "source": "./plugins/design-builder",
            "category": null,
            "version": "4.0.1",
            "author": null,
            "install_commands": [
              "/plugin marketplace add adeonir/claude-code-extras",
              "/plugin install design-builder@claude-code-extras"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2026-01-12T14:17:51Z",
              "created_at": "2025-12-03T01:09:41Z",
              "license": null
            },
            "commands": [
              {
                "name": "/copy",
                "description": "Extract structured content from URLs",
                "path": "plugins/design-builder/commands/copy.md",
                "frontmatter": {
                  "description": "Extract structured content from URLs",
                  "argument-hint": "<url> [--type=landing|website|webapp|app]"
                },
                "content": "# Extract Copy Command\n\nExtract structured content from a URL and generate a copy.yaml file.\n\n## Arguments\n\n- `<url>` - URL to extract content from\n- `--type` - Project type (landing, website, webapp, app)\n\nArguments received: $ARGUMENTS\n\n## Process\n\nInvoke the `copy-extractor` subagent to extract content from the provided URL.\n\nThe copy-extractor will:\n1. Fetch and analyze the URL\n2. Detect project type or use --type if provided\n3. Generate copy.yaml in ./docs/\n\nWait for the agent to complete and inform the user of the result.\n\n## Error Handling\n\n- **URL not accessible**: Ask user to paste a screenshot instead\n- **Project type unclear**: Ask user to specify --type"
              },
              {
                "name": "/design",
                "description": "Extract design tokens from reference images",
                "path": "plugins/design-builder/commands/design.md",
                "frontmatter": {
                  "description": "Extract design tokens from reference images",
                  "argument-hint": [
                    "image-url..."
                  ]
                },
                "content": "# Extract Design Command\n\nExtract design tokens from reference images and generate a design.json file.\n\n## Arguments\n\n- `[image-url...]` - Optional image URLs (will prompt if not provided)\n\nArguments received: $ARGUMENTS\n\n## Process\n\nInvoke the `design-extractor` subagent to extract design tokens from images.\n\nThe design-extractor will:\n1. Request images from user if not provided\n2. Check for existing copy.yaml for project context (optional)\n3. If no copy.yaml, ask user for brief project description\n4. Extract colors, typography, spacing, components\n5. Generate design.json in ./docs/\n\nWait for the agent to complete and inform the user of the result.\n\n## Error Handling\n\n- **No images provided**: Ask user to paste reference images"
              },
              {
                "name": "/figma",
                "description": "Generate HTML and export to Figma via YashiTech plugin",
                "path": "plugins/design-builder/commands/figma.md",
                "frontmatter": {
                  "description": "Generate HTML and export to Figma via YashiTech plugin",
                  "argument-hint": ""
                },
                "content": "# Export to Figma Command\n\nGenerate HTML from design tokens and export to Figma.\n\n## Arguments\n\nNone\n\nArguments received: $ARGUMENTS\n\n## Prerequisites\n\n- [YashiTech Chrome Extension](https://chromewebstore.google.com/detail/html-to-figma-by-yashi-te/apgdhlibcimkkffajannbmpnbjaealmo)\n- [YashiTech Figma Plugin](https://www.figma.com/community/plugin/1459487250118622106)\n\nFree tier: 40 imports/week\n\n## Process\n\nInvoke the `figma-builder` subagent to generate HTML for Figma import.\n\nThe figma-builder will:\n1. Locate design.json (required) and copy.yaml (optional)\n2. Generate clean HTML with inline CSS\n3. Save to ./outputs/figma-export/index.html\n4. Start local server at http://localhost:8081\n5. Provide step-by-step import instructions\n\nWait for the agent to complete and follow the instructions to import into Figma.\n\n## Error Handling\n\n- **No design.json found**: Run /design-builder:design first to extract design tokens"
              },
              {
                "name": "/frontend",
                "description": "Build frontend components from design tokens",
                "path": "plugins/design-builder/commands/frontend.md",
                "frontmatter": {
                  "description": "Build frontend components from design tokens",
                  "argument-hint": [
                    "--variants"
                  ]
                },
                "content": "# Build Frontend Command\n\nBuild production-grade frontend components using Claude Code.\n\n## Arguments\n\n- `--variants` - Generate 4 HTML+CSS preview variants for comparison before building React\n\nArguments received: $ARGUMENTS\n\n## Process\n\n### If --variants is present\n\nInvoke the `variants-builder` subagent to generate 4 HTML+CSS preview variants.\n\nThe variants-builder will:\n1. Load the frontend-design skill first\n2. Locate design.json (required) and copy.yaml (optional)\n3. Generate all 4 presets (minimal, editorial, startup, bold) in ./outputs/\n4. Create index.html for side-by-side comparison\n5. Run `npx http-server ./outputs -o -p 8080`\n6. Inform user to open http://localhost:8080\n\nAfter comparison, user tells Claude which variant to use (e.g., \"use editorial\") and the frontend-builder will create the React application based on that layout.\n\n### If --variants is NOT present\n\nInvoke the `frontend-builder` subagent to build React directly.\n\nThe frontend-builder will:\n1. Detect existing project stack (React, Vue, Svelte, etc.)\n2. If no project, ask user for preferred stack\n3. Scaffold new project if needed\n4. Locate design.json (required) and copy.yaml (optional)\n5. If no copy.yaml, ask user for brief project description\n6. Generate components in ./src/ applying the frontend-design skill\n\nWait for the agent to complete and inform the user of the result.\n\n## Error Handling\n\n- **No design.json found**: Run /design-builder:design first to extract design tokens\n- **Scaffold failed**: Check package manager is installed and available"
              },
              {
                "name": "/plan",
                "description": "Define product vision, data models, and features from scratch",
                "path": "plugins/design-builder/commands/plan.md",
                "frontmatter": {
                  "description": "Define product vision, data models, and features from scratch",
                  "argument-hint": [
                    "--type=landing|website|webapp|app"
                  ]
                },
                "content": "# Plan Product Command\n\nDefine product structure when starting without reference URL or images.\n\n## Arguments\n\n- `--type` - Project type (landing, website, webapp, app)\n\nArguments received: $ARGUMENTS\n\n## Process\n\nInvoke the `product-planner` subagent to gather requirements and generate a product plan.\n\nThe product-planner will:\n1. Ask about the product (name, type, description)\n2. Define target audience and pain points\n3. Establish value proposition and features\n4. Structure sections/screens\n5. Set style direction\n6. Generate product-plan.yaml in ./docs/\n\nWait for the agent to complete and inform the user of the result.\n\n## Next Steps\n\nAfter the plan is created, user should:\n1. Provide reference images and run `/design-builder:design`\n2. Or run `/design-builder:design` without images (will use plan for context)"
              }
            ],
            "skills": [
              {
                "name": "frontend-design",
                "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                "path": "plugins/design-builder/skills/frontend-design/SKILL.md",
                "frontmatter": {
                  "name": "frontend-design",
                  "description": "Create distinctive, production-grade frontend interfaces with high design quality. Use this skill when the user asks to build web components, pages, or applications. Generates creative, polished code that avoids generic AI aesthetics.",
                  "context": "fork"
                },
                "content": "<!-- Based on official Anthropic skill: https://github.com/anthropics/claude-code/blob/main/plugins/frontend-design/skills/frontend-design/SKILL.md -->\n\nThis skill guides creation of distinctive, production-grade frontend interfaces that avoid generic \"AI slop\" aesthetics. Implement real working code with exceptional attention to aesthetic details and creative choices.\n\nThe user provides frontend requirements: a component, page, application, or interface to build. They may include context about the purpose, audience, or technical constraints. If a `design.json` file exists, use it as the source of truth for design tokens.\n\n## Design Thinking\n\nBefore coding, understand the context and commit to a BOLD aesthetic direction:\n\n- **Purpose**: What problem does this interface solve? Who uses it?\n- **Tone**: Pick an extreme: brutally minimal, maximalist chaos, retro-futuristic, organic/natural, luxury/refined, playful/toy-like, editorial/magazine, brutalist/raw, art deco/geometric, soft/pastel, industrial/utilitarian, etc. There are so many flavors to choose from. Use these for inspiration but design one that is true to the aesthetic direction.\n- **Constraints**: Technical requirements (framework, performance, accessibility).\n- **Differentiation**: What makes this UNFORGETTABLE? What's the one thing someone will remember?\n\n**CRITICAL**: Choose a clear conceptual direction and execute it with precision. Bold maximalism and refined minimalism both work - the key is intentionality, not intensity.\n\nThen implement working code (HTML/CSS/JS, React, Vue, Svelte, etc.) that is:\n- Production-grade and functional\n- Visually striking and memorable\n- Cohesive with a clear aesthetic point-of-view\n- Meticulously refined in every detail\n\n## Frontend Aesthetics Guidelines\n\n### Typography\n\nChoose fonts that are beautiful, unique, and interesting. Avoid generic fonts like Arial; opt instead for distinctive choices that elevate the frontend's aesthetics. Pair a distinctive display font with a refined body font.\n\n**Avoid overusing:** Roboto, Arial, default system fonts\n\n**Impact choices by context:**\n- Editorial: Playfair Display, Crimson Pro, Fraunces, Newsreader\n- Code/Technical: JetBrains Mono, Fira Code, IBM Plex Mono\n- Startup/Modern: Clash Display, Satoshi, Cabinet Grotesk\n- Distinctive: Bricolage Grotesque, Obviously, General Sans\n\n**Pairing principle:** High contrast = interesting. Display + monospace, serif + geometric sans, variable font across weights.\n\n**Consider contrast:** Vary weights noticeably (e.g., 300 vs 700) and use meaningful size differences between headings and body text.\n\n### Color & Theme\n\nCommit to a cohesive aesthetic. Use CSS variables for consistency. Dominant colors with sharp accents outperform timid, evenly-distributed palettes. Draw from IDE themes and cultural aesthetics for inspiration.\n\nIf `design.json` exists, map its color tokens to CSS variables and use them consistently throughout.\n\n### Motion\n\nUse animations for effects and micro-interactions. Prioritize CSS-only solutions for HTML. Use Motion library for React when available.\n\nFocus on high-impact moments: one well-orchestrated page load with staggered reveals (animation-delay) creates more delight than scattered micro-interactions. Use scroll-triggering and hover states that surprise.\n\n### Spatial Composition\n\nUnexpected layouts. Asymmetry. Overlap. Diagonal flow. Grid-breaking elements. Generous negative space OR controlled density.\n\n### Backgrounds & Visual Details\n\nCreate atmosphere and depth rather than defaulting to solid colors. Add contextual effects and textures that match the overall aesthetic: gradient meshes, noise textures, geometric patterns, layered transparencies, dramatic shadows, decorative borders, and grain overlays.\n\n## Anti-Patterns (NEVER use)\n\n- Overused font families (Roboto, Arial, system fonts)\n- Cliched color schemes (particularly purple gradients on white backgrounds)\n- Predictable layouts and component patterns\n- Cookie-cutter design that lacks context-specific character\n- Generic AI-generated aesthetics\n- Converging on common choices (Space Grotesk, for example) across generations\n\nInterpret creatively and make unexpected choices that feel genuinely designed for the context. No design should be the same. Vary between light and dark themes, different fonts, different aesthetics.\n\n## Implementation\n\nMatch implementation complexity to the aesthetic vision:\n- Maximalist designs need elaborate code with extensive animations and effects\n- Minimalist or refined designs need restraint, precision, and careful attention to spacing, typography, and subtle details\n- Elegance comes from executing the vision well\n\nIf `design.json` exists, apply its tokens for colors, typography, spacing, and component styles.\n\nRemember: Claude is capable of extraordinary creative work. Don't hold back - show what can truly be created when thinking outside the box and committing fully to a distinctive vision."
              }
            ]
          },
          {
            "name": "git-helpers",
            "description": "Git workflow commands with confidence-scored code review",
            "source": "./plugins/git-helpers",
            "category": null,
            "version": "1.2.1",
            "author": null,
            "install_commands": [
              "/plugin marketplace add adeonir/claude-code-extras",
              "/plugin install git-helpers@claude-code-extras"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2026-01-12T14:17:51Z",
              "created_at": "2025-12-03T01:09:41Z",
              "license": null
            },
            "commands": [
              {
                "name": "/code-review",
                "description": "Review code changes using specialized agents",
                "path": "plugins/git-helpers/commands/code-review.md",
                "frontmatter": {
                  "description": "Review code changes using specialized agents",
                  "argument-hint": "[base-branch] [--comment]"
                },
                "content": "# Code Review Command\n\nReview code changes using `code-reviewer` and `guidelines-auditor` agents.\n\n## Arguments\n\n- **No argument**: Review uncommitted changes, or branch diff if clean\n- **`base-branch`**: Compare against specified base branch\n- **`--comment`**: Post review as PR comment via gh cli\n\n## Usage\n\n```bash\n/git-helpers:code-review              # Terminal output, ask to save\n/git-helpers:code-review main         # Compare against main\n/git-helpers:code-review --comment    # Post to PR via gh\n```\n\n## Process\n\n1. **Parse arguments**:\n   - Check if `--comment` flag is present\n   - Extract base branch if provided\n\n2. **Determine base branch**:\n   - If provided: use specified branch\n   - If not: auto-detect (`development` -> `develop` -> `main` -> `master`)\n\n3. **Detect review mode**:\n   - Run `git status --porcelain` to check for uncommitted changes\n   - If uncommitted changes: review working directory\n   - If clean: compare current branch against base\n\n4. **Get modified files and diff**:\n   - For uncommitted changes:\n     - Files: `git diff --name-only` + `git diff --cached --name-only`\n     - Diff: `git diff` + `git diff --cached`\n   - For branch comparison:\n     - Files: `git diff $BASE...HEAD --name-only`\n     - Diff: `git diff $BASE...HEAD`\n\n5. **Launch agents in parallel**:\n   - `code-reviewer`: Bug detection, security, performance\n   - `guidelines-auditor`: CLAUDE.md compliance checking\n\n6. **Combine results and output**:\n   - If `--comment`: Post combined review to PR via `gh pr comment`\n   - Otherwise: Output to terminal, then ask if user wants to save to `CODE_REVIEW.md`\n\n## Output Format\n\n```markdown\n# Code Review: {branch-name}\n\nReviewed against `{base-branch}` | {date}\n\n## Issues\n\nOnly issues with confidence >= 80 are reported.\n\n- **[{score}] [{file}:{line}]** Issue description\n  - Why it's a problem and how to fix\n\n## CLAUDE.md Compliance\n\n- **[{score}] [{file}:{line}]** Guideline violation\n  - Which guideline and how to fix\n\n## Summary\n\nX files | Y issues | Z compliance findings\n```\n\n## Notes\n\n- Only reports issues with >= 80 confidence score\n- Analyzes actual diff, not conversation context\n- Guidelines auditor reads CLAUDE.md files from repository"
              },
              {
                "name": "/commit",
                "description": "Create commits with well-formatted messages",
                "path": "plugins/git-helpers/commands/commit.md",
                "frontmatter": {
                  "description": "Create commits with well-formatted messages",
                  "argument-hint": "[-s|--staged]"
                },
                "content": "# Commit Command\n\nCreate a commit with a well-formatted message based on the actual file changes.\n\n## Arguments\n\n- **No flag**: Stage all modified/new files before committing\n- **`-s` or `--staged`**: Use only files already staged\n\n## Process\n\n1. **Gather context** (run in parallel):\n   ```bash\n   git status\n   git diff HEAD\n   git log --oneline -5\n   ```\n\n2. **Analyze changes**:\n   - Review the diff output to understand what changed\n   - Base your analysis solely on the file contents, not conversation context\n   - Determine the appropriate commit type\n\n3. **Stage files** (if not using `-s/--staged`):\n   ```bash\n   git add .\n   ```\n\n4. **Create commit** using HEREDOC format:\n   ```bash\n   git commit -m \"$(cat <<'EOF'\n   type: concise description\n\n   - Optional body item 1\n   - Optional body item 2\n   EOF\n   )\"\n   ```\n\n5. **Verify commit**:\n   ```bash\n   git log -1 --format=\"%B\"\n   git status\n   ```\n\n6. **Handle pre-commit hooks** (if files were modified):\n   - Check authorship: `git log -1 --format='%an %ae'`\n   - If safe, amend the commit with modified files (one retry only)\n\n## Commit Types\n\n| Type | Use when |\n|------|----------|\n| `feat` | Adding new functionality |\n| `fix` | Fixing a bug |\n| `refactor` | Restructuring code without changing behavior |\n| `chore` | Maintenance tasks, dependencies, configs |\n| `docs` | Documentation changes |\n| `test` | Adding or updating tests |\n\n## Message Format\n\n```\ntype: concise description in imperative mood\n\n- Optional: area or component affected\n- Optional: another key change\n```\n\n## Guidelines\n\n- Analyze the actual diff, not the conversation context\n- Message should reflect the current state of the implementation\n- Be specific about functionality, not generic\n- Focus on WHAT is being done, not HOW\n- Use imperative mood: \"add\", \"fix\", \"implement\"\n- Do not mention specific files or technical decisions\n- Do not reference future tasks or architectural reasoning\n- Do not mention specific package versions (e.g., \"update lodash to 4.17.21\" -> \"update lodash\")\n- Do not mention version bumps in commit messages (version changes are implicit from the changelog)\n- Include a body only when the change spans 3+ functional areas (keep to 3-4 concise list items)\n- **NEVER use scope in commit type** - use `feat:` not `feat(scope):`\n- **NEVER add Co-Authored-By, Authored-By, or similar attribution lines**\n\n## Task\n\nCreate a commit for changes with $ARGUMENTS.\n\nUse only git commands. Do not use other tools or send additional messages beyond the tool calls."
              },
              {
                "name": "/details",
                "description": "Generate PR title and description to file",
                "path": "plugins/git-helpers/commands/details.md",
                "frontmatter": {
                  "description": "Generate PR title and description to file",
                  "argument-hint": "[base-branch]"
                },
                "content": "# PR Details Command\n\nGenerate a comprehensive PR description comparing current branch with base branch, save to `PR_DETAILS.md`.\n\n## Arguments\n\n- **No argument**: Auto-detect base branch (main > master > develop > development)\n- **`base-branch`**: Use specified branch as base for comparison\n\n## Pre-execution Validation\n\n**CRITICAL**: Always validate before running analysis:\n\n```bash\n# 1. Verify base branch exists\ngit branch -a | grep -E \"(main|master|develop|development)$\"\n\n# 2. Confirm current branch is NOT the base branch\ngit branch --show-current\n```\n\n**Requirements:**\n- Base branch must exist in repository\n- Current branch must NOT be the base branch (avoid empty diffs)\n\n## Process\n\n1. **Detect base branch** (if not specified):\n   ```bash\n   git branch -a | grep -E \"(main|master|develop|development)$\" | head -1\n   ```\n\n2. **Gather context** (run in parallel):\n   ```bash\n   # Extract tickets from branch name\n   git branch --show-current\n\n   # Get diff statistics\n   git diff {base}...HEAD --stat\n\n   # Get file change status\n   git diff {base}...HEAD --name-status\n\n   # Get commit history\n   git log {base}..HEAD --oneline\n\n   # Get detailed diff for content analysis\n   git diff {base}...HEAD\n   ```\n\n3. **Analyze changes** and categorize files:\n   - **Core Changes**: Main application source files\n   - **API Changes**: Endpoint modifications, services\n   - **State Management**: Store/state files\n   - **UI Components**: Component files\n   - **Configuration**: Config, package.json, build files\n   - **Documentation**: README, CLAUDE.md, docs\n\n5. **Assess risk and impact**:\n   - **Risk Level**: HIGH (breaking changes, DB mods) | MEDIUM (new features, UI changes) | LOW (bug fixes, minor)\n   - **Performance Impact**: POSITIVE | NEUTRAL | NEGATIVE\n   - **Compatibility Impact**: NONE | MINOR | MAJOR\n\n6. **Generate PR_DETAILS.md** using Write tool with template below.\n\n## PR_DETAILS.md Template\n\n```markdown\n# Brief Descriptive Title\n\n## Summary\n[2-3 sentences describing the main functional change or feature - focus on business value, not implementation details]\n\n## Key Changes\n\n### Core Changes (X files)\n- **[filename]**: [Brief functional description of changes]\n\n### API Changes (X files)\n- **[filename]**: [Brief description]\n\n### State Management (X files)\n- **[filename]**: [Brief description]\n\n### UI Components (X files)\n- **[filename]**: [Brief description]\n\n### Configuration/Build (X files)\n- **[filename]**: [Brief description]\n\n### Documentation (X files)\n- **[filename]**: [Brief description]\n\n## Technical Flow\n\n**Change Flow Description:**\n1. [User action or trigger that initiates the change]\n2. [How modified components handle the interaction]\n3. [API calls or state updates that occur]\n4. [Final outcome or UI response]\n5. [Fallback mechanisms or error handling]\n\n**Key Components Involved:**\n- **[Component Name]**: [Role in the change]\n- **[API/Service Name]**: [API modifications or interactions]\n- **[State Management]**: [State changes if applicable]\n\n**Data Flow:**\n- Input: [What triggers the change]\n- Processing: [How the change is handled]\n- Output: [What the user experiences]\n\n## Impact Assessment\n\n### Risk Level: [LOW/MEDIUM/HIGH]\n- [Justification for risk level]\n- [Potential issues to watch for]\n\n### Performance Impact: [POSITIVE/NEUTRAL/NEGATIVE]\n- [Description of performance changes]\n\n### Compatibility Impact: [NONE/MINOR/MAJOR]\n- [Backward compatibility considerations]\n- [API changes if any]\n\n## Priority Review Areas\n- **HIGH**: [Critical areas - breaking changes, core business logic, state management]\n- **MEDIUM**: [Important areas - UI changes, new features, refactoring]\n- **LOW**: [Minor areas - documentation, styling, configuration]\n\n## Testing Instructions\n1. [Step-by-step instructions to test the changes]\n2. [Expected outcomes for each step]\n3. [Edge cases to verify]\n\n## Additional Notes\n[Any additional context, future considerations, or related work]\n```\n\n## Template Guidelines\n\n- **Only include sections with actual file changes** - omit empty categories\n- **File descriptions**: Focus on functional impact, not line-by-line changes\n- **Technical Flow**: Describe the user-facing flow, not internal implementation\n- **Priority Review**: Focus on component names and areas, NOT line numbers\n- **Risk assessment**: Be honest about potential issues\n\n## Task\n\nGenerate PR description for current branch with $ARGUMENTS and save to `PR_DETAILS.md`.\n\nAfter analyzing all changes:\n1. Generate complete PR_DETAILS.md file using Write tool\n2. Provide brief summary of key changes and priority review areas"
              },
              {
                "name": "/push-pr",
                "description": "Push branch and create PR with generated details",
                "path": "plugins/git-helpers/commands/push-pr.md",
                "frontmatter": {
                  "description": "Push branch and create PR with generated details",
                  "argument-hint": "[base-branch]"
                },
                "content": "# Push PR Command\n\nPush current branch and create Pull Request via `gh` cli.\n\n## Arguments\n\n- **No argument**: Auto-detect base branch (main > master > develop)\n- **`base-branch`**: Use specified branch as base for comparison\n\n## Process\n\n1. **Check gh cli availability**:\n   ```bash\n   which gh\n   ```\n   If not available, stop and inform user to install `gh` cli or use `/git-helpers:details` instead.\n\n2. **Detect base branch** (if not specified):\n   ```bash\n   git branch -a | grep -E \"(main|master|develop)$\" | head -1\n   ```\n\n3. **Gather context** (run in parallel):\n   ```bash\n   git branch --show-current\n   git log {base}..HEAD --oneline\n   git diff {base}...HEAD --stat\n   git diff {base}...HEAD\n   ```\n\n4. **Analyze changes**:\n   - Review commits and diff to understand what changed\n   - Base analysis solely on file contents, not conversation context\n   - Determine the appropriate PR type\n\n5. **Create PR**:\n   ```bash\n   gh pr create --title \"type: description\" --body \"...\"\n   ```\n\n## PR Types\n\n| Type | Use when |\n|------|----------|\n| `feat` | Adding new functionality |\n| `fix` | Fixing a bug |\n| `refactor` | Restructuring code without changing behavior |\n| `chore` | Maintenance tasks, dependencies, configs |\n| `docs` | Documentation changes |\n| `test` | Adding or updating tests |\n\n## Format\n\n**Title:** `type: concise description` or `type(scope): concise description`\n\n**Body:**\n```markdown\nBrief summary of what this PR does (2-3 sentences max).\n\n## Changes\n- Key change 1\n- Key change 2\n- Key change 3\n```\n\n## Guidelines\n\n- Analyze commits and diff, not conversation context\n- Title and description should reflect the current implementation state\n- Be specific about functionality, not generic\n- Focus on WHAT is being done, not HOW\n- Use imperative mood: \"add\", \"fix\", \"implement\"\n- Keep changes list to 3-5 key items\n- Do not include risk assessment, testing instructions, or technical flow sections\n- **Scope in title is allowed** - both `feat:` and `feat(scope):` are valid\n- **NEVER add Co-Authored-By, Authored-By, or similar attribution lines**\n\n## Task\n\nGenerate PR details for current branch with $ARGUMENTS and create PR using `gh pr create`.\n\nOutput the PR URL when done."
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}