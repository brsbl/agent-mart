{
  "owner": {
    "id": "barnabasJ",
    "display_name": "Barnabas Jovanovics",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/11669837?u=d99938af427a7a483508bf850c08d722b1186f29&v=4",
    "url": "https://github.com/barnabasJ",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 8,
      "total_skills": 0,
      "total_stars": 1,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "barnabasJ/claude",
      "url": "https://github.com/barnabasJ/claude",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 1,
        "forks": 0,
        "pushed_at": "2025-12-10T16:29:15Z",
        "created_at": "2025-12-10T14:22:21Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 388
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 36
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 1949
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2904
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/essentials",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/essentials/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/essentials/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 750
        },
        {
          "path": "plugins/essentials/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/essentials/agents/architecture-agent.md",
          "type": "blob",
          "size": 7899
        },
        {
          "path": "plugins/essentials/agents/code-quality-reviewer.md",
          "type": "blob",
          "size": 2864
        },
        {
          "path": "plugins/essentials/agents/consistency-reviewer.md",
          "type": "blob",
          "size": 2649
        },
        {
          "path": "plugins/essentials/agents/documentation-expert.md",
          "type": "blob",
          "size": 2983
        },
        {
          "path": "plugins/essentials/agents/documentation-reviewer.md",
          "type": "blob",
          "size": 3062
        },
        {
          "path": "plugins/essentials/agents/factual-reviewer.md",
          "type": "blob",
          "size": 2284
        },
        {
          "path": "plugins/essentials/agents/feature-planner.md",
          "type": "blob",
          "size": 3325
        },
        {
          "path": "plugins/essentials/agents/qa-reviewer.md",
          "type": "blob",
          "size": 5533
        },
        {
          "path": "plugins/essentials/agents/redundancy-reviewer.md",
          "type": "blob",
          "size": 2633
        },
        {
          "path": "plugins/essentials/agents/research-agent.md",
          "type": "blob",
          "size": 5235
        },
        {
          "path": "plugins/essentials/agents/security-reviewer.md",
          "type": "blob",
          "size": 7467
        },
        {
          "path": "plugins/essentials/agents/senior-engineer-reviewer.md",
          "type": "blob",
          "size": 7099
        },
        {
          "path": "plugins/essentials/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/essentials/commands/breakdown.md",
          "type": "blob",
          "size": 6183
        },
        {
          "path": "plugins/essentials/commands/commit.md",
          "type": "blob",
          "size": 3805
        },
        {
          "path": "plugins/essentials/commands/execute.md",
          "type": "blob",
          "size": 6138
        },
        {
          "path": "plugins/essentials/commands/fix.md",
          "type": "blob",
          "size": 5783
        },
        {
          "path": "plugins/essentials/commands/plan.md",
          "type": "blob",
          "size": 5689
        },
        {
          "path": "plugins/essentials/commands/research.md",
          "type": "blob",
          "size": 5532
        },
        {
          "path": "plugins/essentials/commands/rewrite-history.md",
          "type": "blob",
          "size": 4466
        },
        {
          "path": "plugins/essentials/commands/rpbe.md",
          "type": "blob",
          "size": 5301
        },
        {
          "path": "plugins/essentials/docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/essentials/docs/agent-patterns.md",
          "type": "blob",
          "size": 7360
        },
        {
          "path": "plugins/essentials/docs/getting-started.md",
          "type": "blob",
          "size": 6617
        },
        {
          "path": "plugins/essentials/docs/workflow-overview.md",
          "type": "blob",
          "size": 7575
        }
      ],
      "marketplace": {
        "name": "essentials-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "joba"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "essentials",
            "description": "Essential commands and agents for software development",
            "source": "./plugins/essentials",
            "category": null,
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add barnabasJ/claude",
              "/plugin install essentials@essentials-marketplace"
            ],
            "signals": {
              "stars": 1,
              "forks": 0,
              "pushed_at": "2025-12-10T16:29:15Z",
              "created_at": "2025-12-10T14:22:21Z",
              "license": null
            },
            "commands": [
              {
                "name": "/breakdown",
                "description": "Task decomposition with TDD - creates numbered checklists from plans",
                "path": "plugins/essentials/commands/breakdown.md",
                "frontmatter": {
                  "description": "Task decomposition with TDD - creates numbered checklists from plans",
                  "argument-hint": [
                    "feature-name"
                  ]
                },
                "content": "# Breakdown Command\n\n## Overview\n\nTransforms strategic plans into granular, numbered task checklists with\ntest-first requirements. Each task includes specific file references,\ndocumentation links, and commit guidance. Creates the executable checklist for\nthe execute phase.\n\nPart of the four-phase workflow: research â†’ plan â†’ breakdown â†’ execute\n\n---\n\n## Prerequisites\n\n- Plan phase completed with document at `./notes/plans/[feature-name].md`\n- Plan includes phases, technical design, and success criteria\n\n---\n\n## Workflow\n\n### Step 1: Check Knowledge Base\n\nSearch `./notes/knowledge/` for:\n\n- Similar task breakdowns\n- Task decomposition patterns\n- Testing methodology guidance\n\n### Step 2: Create Task List\n\nUse TodoWrite with tasks:\n\n- Check knowledge base\n- Read and analyze plan\n- Design task structure\n- Create numbered checklist\n- Add TDD requirements\n- Create breakdown document\n- Update knowledge base\n\n### Step 3: Read Strategic Plan\n\nRead `./notes/plans/[feature-name].md` and extract:\n\n- Implementation phases\n- Technical design details\n- File references and patterns\n- Success criteria\n\n### Step 4: Design Task Structure\n\n**Task sizing guidelines:**\n\n| Size | Duration  | Example                        |\n| ---- | --------- | ------------------------------ |\n| XS   | 15-30 min | Config change, add attribute   |\n| S    | 30-60 min | Simple feature with tests      |\n| M    | 1-2 hours | Resource with multiple actions |\n| L    | 2-4 hours | Multi-file integration         |\n| XL   | 4+ hours  | Split into smaller tasks       |\n\n**Each task should be:**\n\n- Independently executable\n- Self-contained with all needed info\n- Testable with clear criteria\n- Completable with a single commit\n\n### Step 5: Create Numbered Checklist\n\n**Task format:**\n\n```markdown\nX. [ ] **Task Name**\n\nPrerequisites: [if any]\n\nX.1. [ ] Substep with file reference - File: `path/to/file.ex:line-numbers` -\nðŸ“– [Documentation](url)\nX.2. [ ] Write failing test - File: `test/path/to/test.exs`\nX.3. [ ] Implement feature\nX.4. [ ] Run tests: `mix test path/to/test`\nX.5. [ ] Verify all tests pass\n\nðŸ“ Commit: `type(scope): description`\n```\n\n**Include for each task:**\n\n- Specific file paths with line numbers\n- Documentation links where helpful\n- Test file locations\n- Test command to run\n- Suggested commit message\n\n### Step 6: Integrate TDD Requirements\n\nEvery task follows Red-Green-Refactor:\n\n1. **RED**: Write failing test (substep)\n2. **GREEN**: Implement to pass test (substeps)\n3. **REFACTOR**: Clean up if needed (substep)\n4. **VERIFY**: Run full test suite (substep)\n5. **COMMIT**: Only after tests pass\n\n### Step 7: Define Quality Gates\n\n**Task-level gates:**\n\n- All task tests pass\n- Code follows project patterns\n- Ready for commit\n\n**Phase-level gates:**\n\n- Integration between tasks works\n- Phase success criteria met\n\n**System-level gates:**\n\n- Full test suite passes\n- All acceptance criteria met\n\n### Step 8: Create Breakdown Document\n\nWrite to `./notes/breakdowns/[feature-name].md`\n\n### Step 9: Update Knowledge Base\n\nDocument in `./notes/knowledge/`:\n\n- Task decomposition patterns used\n- Testing strategies that worked\n- Useful breakdown techniques\n\n---\n\n## Agent Consultations\n\n| Agent              | When to Use                         |\n| ------------------ | ----------------------------------- |\n| architecture-agent | Task placement, module organization |\n| qa-reviewer        | Test coverage, validation strategy  |\n| research-agent     | Technical details from research     |\n\n---\n\n## Output\n\n**Location**: `./notes/breakdowns/[feature-name].md`\n\n**Document structure:**\n\n```markdown\n# [Feature] Implementation Breakdown\n\n**Date**: YYYY-MM-DD **Status**: Ready for Execution **Plan**:\n./notes/plans/[feature-name].md\n\n## Overview\n\n[Brief description]\n\n## Tasks\n\n### Phase 1: [Phase Name]\n\n1. [ ] **Task Name** ...\n\n### Phase 2: [Phase Name]\n\n2. [ ] **Task Name** ...\n\n## Testing Strategy\n\n- TDD workflow for each task\n- Quality gates between phases\n\n## Success Criteria\n\n- [ ] All tests pass\n- [ ] Acceptance criteria met\n```\n\n---\n\n## Critical Rules\n\nðŸš¨ **Do:**\n\n- Include test substeps in EVERY task\n- Provide specific file paths with line numbers\n- Include commit message for each task\n- Size tasks appropriately (15 min - 4 hours)\n- Reference documentation links\n\nðŸš¨ **Don't:**\n\n- Create tasks without testing substeps\n- Use vague file references (\"update the config\")\n- Skip commit guidance\n- Create XL tasks (split them)\n\n---\n\n## Example\n\n**Input:** `/breakdown user-authentication`\n\n**Output excerpt:**\n\n```markdown\n### Phase 1: User Resource\n\n1. [ ] **Add User Resource with Auth Attributes**\n\n   1.1. [ ] Create user resource - File: `lib/app/accounts/user.ex` \n    - Follow pattern: `lib/app/accounts/organization.ex:15-40` - ðŸ“– [Ash Resource Guide](https://hexdocs.pm/ash/resources.html) \n   1.2. [ ] Write user creation test - File: `test/app/accounts/user_test.exs` \n   1.3. [ ] Add email and password attributes \n   1.4. [ ] Add email validation \n   1.5. [ ] Run tests: `mix test test/app/accounts/user_test.exs` \n   1.6. [ ] Verify all tests pass\n\n   ðŸ“ Commit: `feat(accounts): add user resource with auth attributes`\n\n### Phase 2: OAuth Integration\n\n2. [ ] **Configure OAuth Providers**\n\n   Prerequisites: Task 1 complete\n\n   2.1. [ ] Add ueberauth dependencies to mix.exs - ðŸ“–\n   [Ueberauth Docs](https://hexdocs.pm/ueberauth) \n   2.2. [ ] Write OAuth callback test \n   2.3. [ ] Create OAuth controller - File: `lib/app_web/controllers/auth_controller.ex` \n   2.4. [ ] Configure providers in config/ \n   2.5. [ ] Run tests: `mix test test/app_web/controllers/auth_controller_test.exs` \n   2.6. [ ] Verify all tests pass\n\n   ðŸ“ Commit: `feat(auth): configure OAuth providers`\n```\n\n---\n\n## Common Pitfalls\n\n- **Missing tests**: Every task MUST have test substeps\n- **Vague references**: \"Update config\" â†’ specify exact file and line\n- **Giant tasks**: If >4 hours, split into smaller tasks\n- **No dependencies noted**: Mark prerequisites between tasks\n- **Skipping commit messages**: Include for every task"
              },
              {
                "name": "/commit",
                "description": "Create conventional git commits with proper formatting",
                "path": "plugins/essentials/commands/commit.md",
                "frontmatter": {
                  "description": "Create conventional git commits with proper formatting"
                },
                "content": "# Commit Command\n\n## Overview\n\nCreates well-formed git commits using conventional commit format. Analyzes\nchanges, determines commit type, and creates properly formatted messages.\n\n---\n\n## Prerequisites\n\n- Changes exist in working directory (staged or unstaged)\n- No merge conflicts pending\n- Appropriate branch (feature/_, fix/_, etc.)\n\n---\n\n## Workflow\n\n### Step 1: Analyze Current State\n\nRun in parallel:\n\n```bash\ngit status          # All changed files\ngit diff            # Unstaged changes\ngit diff --staged   # Staged changes\ngit log --oneline -10  # Recent commit style\n```\n\n### Step 2: Determine Commit Type\n\n| Type     | When to Use                            |\n| -------- | -------------------------------------- |\n| feat     | New feature or capability              |\n| fix      | Bug fix                                |\n| refactor | Code restructuring, no behavior change |\n| docs     | Documentation only                     |\n| test     | Adding or updating tests               |\n| chore    | Maintenance, dependencies, tooling     |\n| style    | Formatting, whitespace                 |\n| perf     | Performance improvements               |\n\n### Step 3: Stage Files\n\n```bash\ngit add <files>   # Specific files\ngit add -A        # All changes\n```\n\nðŸš¨ **Never stage files with secrets** (.env, credentials.json, API keys)\n\n### Step 4: Create Commit\n\nUse HEREDOC format:\n\n```bash\ngit commit -m \"$(cat <<'EOF'\ntype(scope): brief description\n\nOptional body explaining why this change was made.\nEOF\n)\"\n```\n\n**Format:**\n\n- Subject: `type(scope): description` (â‰¤50 chars)\n- Blank line\n- Body: Explain \"why\" not \"what\" (optional)\n\n### Step 5: Verify\n\n```bash\ngit status   # Confirm clean state\ngit log -1   # Verify commit\n```\n\n---\n\n## Critical Rules\n\nðŸš¨ **Never:**\n\n- `git push` without explicit user request\n- `--force`, `--hard`, or destructive flags\n- `--no-verify` (skip hooks)\n- Commit secrets or credentials\n- `--amend` on commits you didn't author\n- Reference Claude/AI in commit messages\n\nðŸš¨ **Always:**\n\n- Use conventional commit format\n- Check authorship before amend: `git log -1 --format='%an %ae'`\n- Warn if staging sensitive files\n- Use HEREDOC for message formatting\n- Verify with `git status` after commit\n\n---\n\n## Error Handling\n\n**Pre-commit hook modifies files:**\n\n1. Review changes\n2. `git add <modified-files>`\n3. Retry commit (amend if your commit)\n\n**Nothing to commit:**\n\n- Check `git status` for changes\n- Verify correct files staged\n\n**Merge conflicts:**\n\n- Cannot proceed until resolved\n- Inform user\n\n---\n\n## Example\n\n**Input:** `/commit`\n\n**Process:**\n\n```\n1. git status â†’ 2 files changed\n2. git diff â†’ auth.ex, auth_test.exs modified\n3. git log â†’ repo uses conventional commits\n4. Type: feat (new validation feature)\n5. Scope: auth\n6. Stage: git add lib/auth.ex test/auth_test.exs\n7. Commit:\n   git commit -m \"$(cat <<'EOF'\n   feat(auth): add email validation to login\n\n   Add regex-based email format validation to prevent\n   invalid submissions. Includes edge case handling.\n   EOF\n   )\"\n8. Verify: git status, git log -1\n```\n\n---\n\n## Commit Message Examples\n\n```\nfeat(api): add user profile endpoint\n\nImplement GET /api/users/:id/profile with auth\nand caching for performance.\n```\n\n```\nfix(payment): resolve timeout in processing\n\nAdd retry logic for high-load scenarios.\n\nFixes #456\n```\n\n```\nrefactor(auth): extract validation to utility\n\nMove validation logic to shared module.\nNo behavior changes.\n```\n\n---\n\n## Common Pitfalls\n\n- **Mixing changes**: Keep commits focused on one thing\n- **Vague messages**: \"Fix bug\" â†’ \"Fix null pointer in user validation\"\n- **Past tense**: Use \"Add feature\" not \"Added feature\"\n- **Giant commits**: Small, focused commits are better"
              },
              {
                "name": "/execute",
                "description": "Implementation execution following breakdown checklist with TDD",
                "path": "plugins/essentials/commands/execute.md",
                "frontmatter": {
                  "description": "Implementation execution following breakdown checklist with TDD",
                  "argument-hint": [
                    "feature-name"
                  ]
                },
                "content": "# Execute Command\n\n## Overview\n\nImplements the detailed breakdown checklist task by task, following TDD\nworkflow. You are the implementation lead: write code, create tests, make\ncommits, and track progress. Consult agents for guidance when needed.\n\nFinal phase of: research â†’ plan â†’ breakdown â†’ execute\n\n---\n\n## Prerequisites\n\n- Breakdown completed at `./notes/breakdowns/[feature-name].md`\n- Development environment ready (tests can run)\n- Understanding of project patterns from research phase\n\n---\n\n## Workflow\n\n### Step 1: Check Knowledge Base\n\nSearch `./notes/knowledge/` BEFORE starting:\n\n- `./notes/knowledge/hard-won-knowledge/` - Previous solutions\n- `./notes/knowledge/technical-patterns/` - Implementation patterns\n- `./notes/knowledge/project/` - Project-specific approaches\n\nðŸš¨ **Check knowledge base before debugging ANY problem.**\n\n### Step 2: Create Task List from Breakdown\n\nRead `./notes/breakdowns/[feature-name].md` and use TodoWrite to create tasks:\n\n- One task per numbered item in breakdown\n- Mark tasks in_progress before starting\n- Mark completed immediately after finishing\n- Keep exactly ONE task in_progress at a time\n\n### Step 3: Execute Tasks Sequentially\n\nFor each task in the breakdown:\n\n**3a. Start task**\n\n- Mark task as in_progress in TodoWrite\n- Read task requirements from breakdown\n\n**3b. Follow TDD cycle**\n\n1. Write failing test (RED)\n2. Implement minimal code to pass (GREEN)\n3. Refactor if needed (REFACTOR)\n4. Run test suite\n5. Verify all tests pass\n\n**3c. Commit**\n\n- Use suggested commit message from breakdown\n- Only commit when tests pass\n\n**3d. Track progress**\n\n- Mark substasks as `[x]` in breakdown document\n- Mark task as completed in TodoWrite\n- Move to next task\n\n### Step 4: Quality Gates\n\n**After each task:**\n\n- All task tests pass\n- Code follows project patterns\n\n**After 3-4 related tasks:**\n\n- Run review agents (qa-reviewer, code-quality-reviewer)\n- Address issues before continuing\n\n**After all tasks:**\n\n- Run full test suite\n- Run all review agents\n- Verify success criteria from breakdown\n\n### Step 5: Update Knowledge Base\n\nDocument learnings in `./notes/knowledge/`:\n\n- Implementation patterns that worked\n- Problems solved and solutions\n- Testing techniques used\n\n---\n\n## Zero-Tolerance Test Policy\n\nðŸš¨ **Tasks are NOT complete with failing tests.**\n\n**When tests fail:**\n\n1. STOP all other work\n2. Check knowledge base for similar issues\n3. Debug and fix root cause\n4. Verify fix with full test suite\n5. Only then continue\n\n**Never:**\n\n- Mark task complete with failing tests\n- Delete or skip tests without user approval\n- Comment out failing tests\n- Commit with failing tests\n\n---\n\n## Knowledge-First Debugging\n\nðŸš¨ **Check knowledge base BEFORE debugging any problem.**\n\nWhen you encounter an error:\n\n1. Search `./notes/knowledge/hard-won-knowledge/` for similar errors\n2. Search `./notes/knowledge/technical-patterns/` for tech-specific solutions\n3. Check `./notes/knowledge/project/` for project approaches\n\n**After solving a problem:**\n\n- Store solution immediately in `./notes/knowledge/hard-won-knowledge/`\n- Include: problem, symptoms, solution, why it works\n\n---\n\n## Agent Consultations\n\n| Agent                 | When to Use                 |\n| --------------------- | --------------------------- |\n| qa-reviewer           | Test coverage validation    |\n| code-quality-reviewer | Pattern consistency, naming |\n| architecture-agent    | Integration validation      |\n| research-agent        | Retrieve technical details  |\n\n**Consult agents when:**\n\n- Unclear about implementation approach\n- Multiple valid options exist\n- Need pattern guidance\n- Validating integration approach\n\n**Ask specific questions:**\n\n```\n\"I'm implementing OAuth callback. The breakdown says to use\nlib/app_web/controllers/auth_controller.ex. Looking at existing\ncontrollers, should I use Phoenix actions or Ash actions?\"\n```\n\n---\n\n## Progress Tracking\n\n**In breakdown document:**\n\n```markdown\n### 1. [x] Add User Resource âœ… 2025-12-10\n\n- [x] 1.1 Create user resource\n- [x] 1.2 Write tests\n- [x] 1.3 Add attributes Commit: abc123f\n```\n\n**In TodoWrite:**\n\n- Update status as you work\n- Mark completed immediately\n- Keep one in_progress at a time\n\n---\n\n## Critical Rules\n\nðŸš¨ **Do:**\n\n- Check knowledge base before debugging ANY problem\n- Follow TDD: test first, then implement\n- Run tests after every substep\n- Commit only when tests pass\n- Store solutions immediately after solving problems\n- Mark progress in breakdown document and TodoWrite\n\nðŸš¨ **Don't:**\n\n- Skip test substeps\n- Commit with failing tests\n- Continue past failed tests\n- Delete tests without user approval\n- Debug without checking knowledge base first\n\n---\n\n## Example\n\n**Input:** `/execute user-authentication`\n\n**Process:**\n\n```\n1. Read breakdown: ./notes/breakdowns/user-authentication.md\n   - Task 1: Add User Resource\n   - Task 2: Configure OAuth\n   - Task 3: Add Tests\n\n2. Create TodoWrite tasks from breakdown\n\n3. Execute Task 1:\n   - Mark in_progress\n   - 1.1 Create user.ex (follow pattern from organization.ex)\n   - 1.2 Write user_test.exs\n   - 1.3 Add email, password attributes\n   - 1.4 Run tests â†’ pass\n   - Commit: \"feat(accounts): add user resource\"\n   - Mark completed\n\n4. Execute Task 2:\n   - Mark in_progress\n   - 2.1 Add ueberauth to mix.exs\n   - 2.2 Write auth_controller_test.exs\n   - 2.3 Create auth_controller.ex\n   - 2.4 Run tests â†’ FAIL\n   - Check knowledge base â†’ found OAuth callback solution\n   - Apply fix\n   - Run tests â†’ pass\n   - Commit: \"feat(auth): configure OAuth\"\n   - Store solution in knowledge base\n   - Mark completed\n\n5. Run review agents\n6. Update knowledge base with learnings\n```\n\n---\n\n## Common Pitfalls\n\n- **Skipping knowledge base check**: Always check before debugging\n- **Batch completing tasks**: Mark each task complete immediately\n- **Ignoring test failures**: Stop and fix, never continue\n- **Vague agent questions**: Ask specific, contextual questions\n- **Forgetting to store solutions**: Save to knowledge base immediately"
              },
              {
                "name": "/fix",
                "description": "Bug fixing with root cause analysis and regression testing",
                "path": "plugins/essentials/commands/fix.md",
                "frontmatter": {
                  "description": "Bug fixing with root cause analysis and regression testing",
                  "argument-hint": [
                    "issue-description"
                  ]
                },
                "content": "# Fix Command\n\n## Overview\n\nSystematically diagnoses root causes, implements fixes, and creates regression\ntests. Emphasizes finding the actual problem (not symptoms), knowledge-first\ndebugging, and ensuring the bug never returns.\n\n---\n\n## Prerequisites\n\n- Clear description of the issue or bug\n- Ability to reproduce the issue\n- Access to run tests\n\n---\n\n## Workflow\n\n### Step 1: Check Knowledge Base FIRST\n\nðŸš¨ **Before any debugging**, search `./notes/knowledge/`:\n\n- `./notes/knowledge/hard-won-knowledge/` - Similar problems solved\n- `./notes/knowledge/technical-patterns/` - Tech-specific solutions\n- `./notes/knowledge/project/` - Project-specific approaches\n\nLook for: similar errors, symptoms, previous solutions.\n\n### Step 2: Create Fix Branch\n\n```bash\ngit checkout -b fix/[issue-description]\n```\n\n### Step 3: Reproduce the Issue\n\nEstablish reliable reproduction:\n\n- Document exact steps to trigger\n- Identify minimum conditions required\n- Verify reproduction is consistent\n\n**Document:**\n\n- Steps to reproduce\n- Expected vs actual behavior\n- Frequency (always/intermittent)\n\n### Step 4: Investigate Root Cause\n\n**Check logs and errors:**\n\n- Stack traces\n- Error messages\n- Warning patterns\n\n**Isolate the problem:**\n\n- Which component fails?\n- When did it start? (git bisect)\n- What's different in failing vs passing cases?\n\n**Five Whys technique:**\n\n1. Why did error occur? â†’ Function received null\n2. Why null? â†’ Database returned no results\n3. Why no results? â†’ WHERE clause too restrictive\n4. Why too restrictive? â†’ Wrong date format\n5. Why wrong format? â†’ No timezone handling\n\n**Root cause**: Date parsing doesn't handle timezones\n\nðŸš¨ **Fix the root cause, not symptoms.**\n\n### Step 5: Create Fix Plan Document\n\nWrite to `./notes/fixes/[issue-name].md`:\n\n```markdown\n# Fix: [Issue Name]\n\n## Issue Description\n\n- Problem: [what's broken]\n- Steps to reproduce: [numbered steps]\n- Expected: [what should happen]\n- Actual: [what happens]\n\n## Root Cause Analysis\n\n- Where: [file:line]\n- Why: [technical explanation]\n- Affected: [related components]\n\n## Solution\n\n- Approach: [how to fix]\n- Changes: [files to modify]\n\n## Testing\n\n- Regression test: [test that fails before, passes after]\n- Edge cases: [additional tests]\n\n## Rollback Plan\n\n- Revert: [how to undo]\n- Monitor: [what to watch]\n```\n\n### Step 6: Write Regression Test FIRST\n\nðŸš¨ **Before implementing fix:**\n\n1. Write test that reproduces the bug\n2. Verify test FAILS\n3. This proves test catches the bug\n\n### Step 7: Implement Fix\n\n- Make minimal, targeted changes\n- Address root cause (not symptoms)\n- Follow project patterns\n\n### Step 8: Verify Fix\n\n1. Run regression test â†’ should PASS now\n2. Run full test suite â†’ all should pass\n3. Manually verify fix works\n\n### Step 9: Run Reviews\n\nUse review agents in parallel:\n\n- qa-reviewer\n- security-reviewer (if relevant)\n- code-quality-reviewer\n\nAddress any issues found.\n\n### Step 10: Commit and Document\n\n```bash\ngit commit -m \"fix(scope): description\n\nRoot cause: [brief explanation]\nSolution: [what was changed]\n\nCloses #[issue-number]\"\n```\n\n### Step 11: Store Solution in Knowledge Base\n\nðŸš¨ **Immediately** after solving, document in\n`./notes/knowledge/hard-won-knowledge/`:\n\n```markdown\n# [Problem Title]\n\n## Symptoms\n\n- Error message: [exact message]\n- When it occurs: [conditions]\n\n## Root Cause\n\n[Technical explanation]\n\n## Solution\n\n[What fixed it]\n\n## Prevention\n\n[How to avoid in future]\n```\n\n---\n\n## Agent Consultations\n\n| Agent                    | When to Use                     |\n| ------------------------ | ------------------------------- |\n| qa-reviewer              | Test strategy, regression tests |\n| security-reviewer        | Security implications           |\n| senior-engineer-reviewer | Fix approach validation         |\n| research-agent           | Technical documentation         |\n\n---\n\n## Output\n\n**Location**: `./notes/fixes/[issue-name].md`\n\n**Required sections:**\n\n1. Issue Description\n2. Root Cause Analysis\n3. Solution\n4. Testing Strategy\n5. Rollback Plan\n\n---\n\n## Critical Rules\n\nðŸš¨ **Do:**\n\n- Check knowledge base BEFORE debugging\n- Find root cause, not symptoms\n- Write regression test BEFORE implementing fix\n- Store solution in knowledge base immediately\n- Run review agents before completing\n\nðŸš¨ **Don't:**\n\n- Fix symptoms while root cause remains\n- Implement without regression test\n- Skip knowledge base check\n- Wait until later to document solution\n- Delete tests to make fix \"work\"\n\n---\n\n## Example\n\n**Input:** `/fix login-timeout-too-short`\n\n**Process:**\n\n```\n1. Check knowledge base â†’ No similar issue found\n\n2. Reproduce:\n   - Login, wait 35 seconds, submit\n   - Get timeout error\n   - Expected: 5 min timeout\n\n3. Investigate:\n   - Check session config\n   - Found: timeout = 30000 (30 sec)\n   - Should be: 300000 (5 min)\n   - Root cause: Typo in config\n\n4. Write regression test:\n   - Test session timeout is 5 minutes\n   - Verify test FAILS with current config\n\n5. Fix:\n   - Update config/session.conf: 30000 â†’ 300000\n\n6. Verify:\n   - Regression test PASSES\n   - Full suite passes\n\n7. Commit:\n   \"fix(session): correct timeout from 30s to 5min\"\n\n8. Store in knowledge base:\n   - Problem: Session timeout too short\n   - Cause: Config typo (missing zero)\n   - Solution: Verify timeout values have correct zeros\n```\n\n---\n\n## Common Pitfalls\n\n- **Fixing symptoms**: Null check instead of fixing why null occurs\n- **Skipping regression test**: Bug can return undetected\n- **Not checking knowledge base**: May repeat previous debugging work\n- **Workarounds**: Always fix root cause, never work around it\n- **Late documentation**: Document solution immediately while fresh"
              },
              {
                "name": "/plan",
                "description": "Strategic implementation planning from research findings",
                "path": "plugins/essentials/commands/plan.md",
                "frontmatter": {
                  "description": "Strategic implementation planning from research findings",
                  "argument-hint": [
                    "feature-name"
                  ]
                },
                "content": "# Plan Command\n\n## Overview\n\nTransforms research findings into a strategic implementation plan. Defines\narchitecture, phases, integration patterns, and success criteria. Creates the\nblueprint that the breakdown phase will decompose into tasks.\n\nPart of the four-phase workflow: research â†’ plan â†’ breakdown â†’ execute\n\n---\n\n## Prerequisites\n\n- Research phase completed with document at `./notes/research/[feature-name].md`\n- Research includes file impact mapping, patterns, and dependencies\n\n---\n\n## Workflow\n\n### Step 1: Check Knowledge Base\n\nSearch `./notes/knowledge/` for similar plans:\n\n- Similar implementation plans\n- Architectural decisions for related features\n- Implementation patterns that worked well\n\n### Step 2: Create Task List\n\nUse TodoWrite with tasks:\n\n- Check knowledge base\n- Review research findings\n- Consult architecture-agent\n- Design implementation strategy\n- Define phases and success criteria\n- Create plan document\n- Update knowledge base\n\n### Step 3: Review Research Findings\n\nRead `./notes/research/[feature-name].md` and extract:\n\n- Files and modules affected\n- Existing patterns to follow\n- Dependencies and integration points\n- Third-party services involved\n- Questions that need user clarification\n\n### Step 4: Consult Architecture Agent\n\nUse architecture-agent to validate:\n\n- Proposed structural approach\n- Integration patterns\n- Module organization\n- Code placement decisions\n\n### Step 5: Design Implementation Strategy\n\nBased on research and architecture consultation:\n\n**Define feature specification:**\n\n- User stories with acceptance criteria\n- API contracts and data flow\n- State management approach\n- Error handling strategy\n\n**Design using existing patterns:**\n\n- Reference specific files as templates (e.g., `lib/app/accounts/user.ex:45-67`)\n- Extend existing modules following project conventions\n- Plan data model changes using current schema patterns\n\n### Step 6: Define Implementation Phases\n\nBreak implementation into phases:\n\n**Each phase includes:**\n\n- Clear objectives\n- Success criteria\n- Dependencies on other phases\n- Deliverables\n\n**Phase structure example:**\n\n1. Infrastructure/Foundation\n2. Core functionality\n3. Integration\n4. Testing and validation\n\n### Step 7: Create Plan Document\n\nWrite to `./notes/plans/[feature-name].md`\n\n### Step 8: Update Knowledge Base\n\nDocument in `./notes/knowledge/`:\n\n- Architectural decisions made\n- Patterns selected and why\n- Planning techniques that worked\n\n---\n\n## Agent Consultations\n\n| Agent                    | When to Use                                 |\n| ------------------------ | ------------------------------------------- |\n| architecture-agent       | Structural validation, integration approach |\n| senior-engineer-reviewer | Strategic validation, scalability review    |\n| research-agent           | Retrieve research details when needed       |\n\n**Consultation patterns:**\n\n- **Algorithm changes**: Run architecture-agent + senior-engineer-reviewer in\n  PARALLEL\n- **Cross-codebase changes**: Run SEQUENTIALLY (architecture first, then domain\n  experts)\n\n---\n\n## Output\n\n**Location**: `./notes/plans/[feature-name].md`\n\n**Required sections:**\n\n1. **Impact Analysis Summary** - Files affected, patterns to follow\n2. **Feature Specification** - User stories, API contracts, data flow\n3. **Technical Design** - Implementation approach with code references\n4. **Implementation Strategy** - Phases with objectives and success criteria\n5. **Agent Consultations** - Guidance received from agents\n6. **Testing Strategy** - Test coverage requirements\n7. **Success Criteria** - Measurable completion criteria\n\n**Document metadata:**\n\n```\ntype: plan\nstatus: completed\ncreated: YYYY-MM-DD\nproject: [project-name]\ntopic: [feature-name]\n```\n\n---\n\n## Critical Rules\n\nðŸš¨ **Do:**\n\n- Build on research findings (don't re-research)\n- Reference specific files as pattern templates\n- Include complete code examples in technical design\n- Define clear phase boundaries and success criteria\n- Validate architecture before finalizing\n\nðŸš¨ **Don't:**\n\n- Create overly detailed low-level implementation plans (that's breakdown's job)\n- Skip architecture consultation for complex changes\n- Leave success criteria vague or unmeasurable\n- Ignore existing patterns discovered in research\n\n---\n\n## Example\n\n**Input:** `/plan user-authentication`\n\n**Process:**\n\n```\n1. Check knowledge base â†’ Found auth patterns in ./notes/knowledge/\n\n2. Review research:\n   - Research shows project uses Guardian for auth\n   - Existing user.ex at lib/app/accounts/user.ex\n   - OAuth patterns in lib/app_web/controllers/auth_controller.ex\n\n3. Consult architecture-agent:\n   - Recommended: Extend existing accounts context\n   - Place OAuth logic in auth_controller.ex\n   - Use existing Guardian pipeline\n\n4. Design strategy:\n   - Phase 1: User resource with auth attributes\n   - Phase 2: OAuth integration\n   - Phase 3: Session management\n   - Phase 4: Testing\n\n5. Define success criteria:\n   - User can register/login with email\n   - OAuth providers work (Google, GitHub)\n   - Session persists across requests\n   - All auth tests pass\n```\n\n**Output:** `./notes/plans/user-authentication.md`\n\n---\n\n## Common Pitfalls\n\n- **Over-planning**: Keep phases high-level; details go in breakdown\n- **Ignoring research**: Plan must build on research, not duplicate it\n- **Vague criteria**: \"Works correctly\" is not a success criterion\n- **Missing architecture review**: Always validate structure for complex changes\n- **New patterns without justification**: Stick to existing patterns unless\n  research identified issues"
              },
              {
                "name": "/research",
                "description": "Codebase impact analysis and pattern discovery for new features",
                "path": "plugins/essentials/commands/research.md",
                "frontmatter": {
                  "description": "Codebase impact analysis and pattern discovery for new features",
                  "argument-hint": [
                    "feature-name"
                  ]
                },
                "content": "# Research Command\n\n## Overview\n\nPerforms comprehensive codebase impact analysis for a proposed feature or\nchange. Maps all affected files, discovers existing patterns and conventions,\nidentifies dependencies, and gathers version-specific documentation. Creates\nfoundation for the plan phase.\n\nPart of the four-phase workflow: research â†’ plan â†’ breakdown â†’ execute\n\n---\n\n## Prerequisites\n\n- Clear description of the feature or change to research\n- Access to the codebase for pattern discovery\n- Ability to read package files for dependency versions\n\n---\n\n## Workflow\n\n### Step 1: Check Knowledge Base\n\nSearch `./notes/knowledge/` for similar work:\n\n- `./notes/knowledge/hard-won-knowledge/` - Previous debugging insights\n- `./notes/knowledge/technical-patterns/` - Implementation approaches\n- `./notes/knowledge/project/` - Project-specific patterns\n\n### Step 2: Create Task List\n\nUse TodoWrite with tasks:\n\n- Check knowledge base\n- Analyze codebase impact\n- Discover existing patterns\n- Gather documentation\n- Create research document\n- Update knowledge base\n\n### Step 3: Analyze Codebase Impact\n\nMap all files requiring changes:\n\n- Use Glob to find relevant files (`**/*pattern*.ext`)\n- Use Grep to search for related code\n- Read files to understand current implementation\n- Note specific line numbers for reference\n\n**Document:**\n\n- Files affected with line numbers\n- Dependencies between components\n- Integration points\n- Shared utilities that amplify impact\n\n### Step 4: Discover Project Patterns\n\nAnalyze existing code to find:\n\n- Package dependencies (mix.exs, package.json, etc.)\n- Architectural patterns in use\n- Testing approaches and frameworks\n- Authentication/authorization patterns\n- Naming conventions\n\nðŸš¨ **Discover what the project uses, not what it could use.**\n\n### Step 5: Gather Documentation\n\nFind version-specific docs for actual dependencies:\n\n- Check package files for exact versions\n- Link to specific version docs (e.g., hexdocs.pm/package/X.Y.Z)\n- Include both official docs and community guides\n- Note relevant GitHub repos for source reference\n\n### Step 6: Create Research Document\n\nWrite findings to `./notes/research/[feature-name].md`\n\n### Step 7: Update Knowledge Base\n\nDocument new learnings in `./notes/knowledge/`:\n\n- Patterns discovered\n- Useful documentation links\n- Techniques that worked well\n\n---\n\n## Agent Consultations\n\n| Agent              | When to Use                                      |\n| ------------------ | ------------------------------------------------ |\n| research-agent     | Deep technical research, documentation gathering |\n| architecture-agent | Structural understanding, integration patterns   |\n| qa-reviewer        | Test coverage analysis                           |\n\n**Parallel pattern for algorithm research:**\n\n```\nRun in PARALLEL:\nâ”œâ”€â”€ research-agent: \"Research [Language] [Algorithm] patterns\"\nâ””â”€â”€ architecture-agent: \"Map impact of changing [Module].[function]\"\n```\n\n---\n\n## Output\n\n**Location**: `./notes/research/[feature-name].md`\n\n**Required sections:**\n\n1. **Overview** - What was researched and why\n2. **Current Implementation** - What exists in the codebase\n3. **File Impact Mapping** - Files and line numbers affected\n4. **Dependencies** - Exact versions with doc links\n5. **Existing Patterns** - Conventions discovered\n6. **Third-Party Integrations** - External services detected\n7. **Unclear Areas** - Questions for user clarification\n\n**File references must include:**\n\n- Full path: `lib/module/parser.ex`\n- Line numbers: `parser.ex:70` or `lines 589-615`\n- Function names: `Transformer.list_item_to_blocks/3`\n\n---\n\n## Critical Rules\n\nðŸš¨ **Do:**\n\n- Discover project patterns FIRST before suggesting solutions\n- Use version-specific documentation links (actual versions, not \"latest\")\n- Include specific file paths and line numbers\n- Check test files for usage examples and edge cases\n\nðŸš¨ **Don't:**\n\n- Assume new dependencies without user approval\n- Suggest patterns not established in the project\n- Link to \"latest\" docs when project uses older version\n- Stop at first file found - follow dependencies\n\n---\n\n## Example\n\n**Input:** `/research markdown-todo-conversion`\n\n**Process:**\n\n```\n1. Check knowledge base â†’ No similar work found\n\n2. Analyze codebase:\n   - Glob **/*markdown*.ex â†’ found parser.ex, renderer.ex, transformer.ex\n   - Read parser.ex â†’ Found TaskItem handling at line 70\n   - Grep \"checkbox\" â†’ Found in transformer.ex:589-615\n\n3. Discover patterns:\n   - mix.exs shows mdex 0.9.4\n   - Uses GFM tasklist extension\n   - Bidirectional conversion already exists\n\n4. Gather docs:\n   - https://hexdocs.pm/mdex/0.9.4\n   - GFM spec for task lists\n\n5. Document findings:\n   - Parser: lib/app/markdown/parser.ex (TaskItem at :70)\n   - Transformer: lib/app/markdown/transformer.ex (checkbox :589-615)\n   - Renderer: lib/app/markdown/renderer.ex (round-trip)\n   - Finding: Full conversion already implemented\n```\n\n**Output:** `./notes/research/markdown-todo-conversion.md`\n\n---\n\n## Common Pitfalls\n\n- **Assuming missing functionality**: Always check tests - feature may already\n  exist\n- **Searching too narrowly**: Use multiple terms (todo, TaskItem, checkbox,\n  tasklist)\n- **Ignoring test files**: Tests show what already works and expected behavior\n- **One-direction analysis**: For conversions, check BOTH directions\n- **Outdated doc links**: Always verify docs match actual package version"
              },
              {
                "name": "/rewrite-history",
                "description": "Reimplement current branch with clean, narrative-quality commit history",
                "path": "plugins/essentials/commands/rewrite-history.md",
                "frontmatter": {
                  "description": "Reimplement current branch with clean, narrative-quality commit history"
                },
                "content": "# Rewrite History Command\n\n## Overview\n\nReimplements the current branch with a clean, reviewer-friendly commit history.\nCreates a backup of the original branch, then rewrites commits as a logical\nnarrative suitable for code review.\n\n---\n\n## Prerequisites\n\n- Current branch has changes relative to `main`\n- No uncommitted changes or merge conflicts\n- Branch is up to date with `main`\n\n---\n\n## Workflow\n\n### Step 1: Validate Source Branch\n\nRun validation checks:\n\n```bash\ngit status                    # No uncommitted changes\ngit diff main --stat          # Confirm changes exist\ngit merge-base --is-ancestor main HEAD  # Up to date with main\n```\n\nðŸš¨ **Stop if:**\n\n- Uncommitted changes exist\n- Merge conflicts pending\n- No changes relative to main\n\n### Step 2: Create Backup Branch\n\n```bash\n# Save current branch name\nBRANCH=$(git branch --show-current)\n\n# Create backup\ngit branch ${BRANCH}-backup\n```\n\n### Step 3: Analyze the Diff\n\nStudy all changes between current branch and `main`:\n\n```bash\ngit diff main --stat          # Files changed\ngit diff main                 # Full diff\ngit log main..HEAD --oneline  # Existing commits\n```\n\n**Goal:** Form a complete understanding of the final intended state.\n\n### Step 4: Plan the Commit Storyline\n\nBreak the implementation into logical stages:\n\n1. **Foundation** - Setup, configuration, dependencies\n2. **Core** - Main functionality implementation\n3. **Integration** - Connecting components\n4. **Polish** - Documentation, cleanup, refinements\n\nEach commit should:\n\n- Introduce a single coherent idea\n- Be self-contained and buildable (when possible)\n- Read like a tutorial step\n\n**Write the plan before executing.**\n\n### Step 5: Reset and Reimplement\n\n```bash\n# Reset to main, keeping changes in working directory\ngit reset main\n```\n\nThen recreate commits according to your plan:\n\n```bash\ngit add <relevant-files>\ngit commit -m \"$(cat <<'EOF'\ntype(scope): brief description\n\nExplanation of what this step accomplishes and why.\nEOF\n)\"\n```\n\nRepeat for each planned commit.\n\n### Step 6: Verify Correctness\n\nConfirm final state matches the backup:\n\n```bash\ngit diff ${BRANCH}-backup\n```\n\nðŸš¨ **This must show no differences.** If it does, investigate and fix.\n\n### Step 7: Report Results\n\nShow the new commit history:\n\n```bash\ngit log main..HEAD --oneline\n```\n\nInform user of:\n\n- Backup branch name\n- Number of new commits\n- Summary of narrative structure\n\n---\n\n## Critical Rules\n\nðŸš¨ **Never:**\n\n- Delete the backup branch\n- Add yourself as author or contributor\n- Include AI/Claude references in commits\n- Use `--force` on shared branches\n- Change the final state (must match original exactly)\n\nðŸš¨ **Always:**\n\n- Create backup before any destructive operations\n- Verify final state matches backup\n- Use conventional commit format\n- Write clear commit messages explaining \"why\"\n- Use `--no-verify` sparingly (only for known issues)\n\n---\n\n## Commit Message Format\n\n```\ntype(scope): brief description (â‰¤50 chars)\n\nLonger explanation of what this commit does and why.\nFocus on the narrative - what problem does this solve?\nWhat decision was made and why?\n```\n\n**Good narrative commits:**\n\n```\nfeat(plugin): add plugin manifest structure\n\nCreate .claude-plugin/plugin.json with required metadata.\nThis establishes the plugin identity for Claude Code's\nplugin system.\n```\n\n```\nrefactor(commands): standardize frontmatter format\n\nEnsure all command files have description field in\nfrontmatter as required by plugin specification.\n```\n\n---\n\n## Example\n\n**Input:** `/rewrite-history`\n\n**Process:**\n\n```\n1. Validate: git status clean, changes exist vs main\n2. Backup: git branch feature/auth-backup\n3. Analyze: 5 files changed, 3 original commits\n4. Plan storyline:\n   - feat: add user model\n   - feat: implement auth service\n   - feat: add login endpoint\n   - test: add auth test suite\n   - docs: update API documentation\n5. Reset: git reset main\n6. Reimplement: Create 5 clean commits\n7. Verify: git diff feature/auth-backup (empty)\n8. Report: \"Created 5 commits, backup at feature/auth-backup\"\n```\n\n---\n\n## Common Pitfalls\n\n- **Forgetting backup**: Always create backup first\n- **Changing final state**: Diff must be empty vs backup\n- **Too granular**: Commits should be meaningful, not trivial\n- **Too large**: Each commit should be reviewable in isolation\n- **Missing context**: Commit messages should explain decisions"
              },
              {
                "name": "/rpbe",
                "description": "Full workflow - Research, Plan, Breakdown, Execute in sequence",
                "path": "plugins/essentials/commands/rpbe.md",
                "frontmatter": {
                  "description": "Full workflow - Research, Plan, Breakdown, Execute in sequence",
                  "argument-hint": [
                    "feature-name"
                  ]
                },
                "content": "# RPBE Command\n\n## Overview\n\nOrchestrates the complete four-phase workflow: Research â†’ Plan â†’ Breakdown â†’\nExecute. Runs each phase sequentially with user checkpoints between phases. Use\nfor comprehensive feature implementation from analysis through delivery.\n\n---\n\n## Prerequisites\n\n- Clear feature or task description\n- Time for full workflow (30-60+ minutes for complex features)\n- Ability to answer clarifying questions between phases\n\n---\n\n## Workflow\n\n### Step 1: Create Master Task List\n\nUse TodoWrite:\n\n```json\n[\n  { \"content\": \"Research phase\", \"status\": \"pending\" },\n  {\n    \"content\": \"Review research and gather clarifications\",\n    \"status\": \"pending\"\n  },\n  { \"content\": \"Plan phase\", \"status\": \"pending\" },\n  { \"content\": \"Review plan and gather clarifications\", \"status\": \"pending\" },\n  { \"content\": \"Breakdown phase\", \"status\": \"pending\" },\n  { \"content\": \"Review breakdown and get approval\", \"status\": \"pending\" },\n  { \"content\": \"Execute phase\", \"status\": \"pending\" },\n  { \"content\": \"Update knowledge base\", \"status\": \"pending\" }\n]\n```\n\n### Step 2: Research Phase\n\nRun `/research [feature-name]`\n\n**Output**: `./notes/research/[feature-name].md`\n\n### Step 3: Research Checkpoint\n\nAfter research completes:\n\n1. Read research document\n2. Identify ambiguities or questions\n3. Use AskUserQuestion for clarifications\n4. Update research document with answers\n5. Confirm ready for planning\n\n**Questions to consider:**\n\n- Technology choices if multiple options\n- Integration point preferences\n- Existing pattern confirmations\n\n### Step 4: Plan Phase\n\nRun `/plan [feature-name]`\n\n**Output**: `./notes/plans/[feature-name].md`\n\n### Step 5: Plan Checkpoint\n\nAfter plan completes:\n\n1. Read plan document\n2. Validate architectural decisions\n3. Use AskUserQuestion for design alternatives\n4. Update plan with user decisions\n5. Confirm ready for breakdown\n\n**Questions to consider:**\n\n- Architectural approach approval\n- Phase ordering preferences\n- Priority tradeoffs\n\n### Step 6: Breakdown Phase\n\nRun `/breakdown [feature-name]`\n\n**Output**: `./notes/breakdowns/[feature-name].md`\n\n### Step 7: Breakdown Checkpoint (APPROVAL REQUIRED)\n\nðŸš¨ **Must get explicit user approval before execution**\n\nPresent summary:\n\n- Number of tasks\n- Estimated complexity\n- Key phases\n- Testing approach\n\nAsk:\n\n- \"Does this breakdown look correct?\"\n- \"Any tasks to add, remove, or split?\"\n- \"Ready to proceed with execution?\"\n\n**Do NOT proceed to execute without approval.**\n\n### Step 8: Execute Phase\n\nRun `/execute [feature-name]`\n\nFollows breakdown checklist with TDD workflow.\n\n### Step 9: Update Knowledge Base\n\nDocument learnings in `./notes/knowledge/`:\n\n- Workflow effectiveness\n- Phase handoff quality\n- Patterns discovered\n- Techniques that worked\n\n---\n\n## Phase Handoffs\n\n| From      | To        | Handoff Document               |\n| --------- | --------- | ------------------------------ |\n| Research  | Plan      | `./notes/research/[name].md`   |\n| Plan      | Breakdown | `./notes/plans/[name].md`      |\n| Breakdown | Execute   | `./notes/breakdowns/[name].md` |\n\nEach phase reads the previous phase's output document.\n\n---\n\n## Critical Rules\n\nðŸš¨ **Do:**\n\n- Run phases SEQUENTIALLY (never parallel)\n- Checkpoint with user between each phase\n- Get explicit approval before execute phase\n- Update knowledge base at end\n\nðŸš¨ **Don't:**\n\n- Skip checkpoints\n- Start execute without breakdown approval\n- Run phases in parallel\n- Proceed if user has unanswered questions\n\n---\n\n## When to Use RPBE vs Individual Commands\n\n**Use RPBE:**\n\n- New feature requiring full analysis\n- Complex implementation\n- Time available for complete workflow\n- Want structured checkpoints\n\n**Use individual commands:**\n\n- Only need one phase (e.g., just research)\n- Resuming work after pause\n- Simple task not needing full workflow\n- Want to pause between phases for extended time\n\n---\n\n## Example\n\n**Input:** `/rpbe user-authentication`\n\n**Process:**\n\n```\n1. Create TodoWrite with 8 tasks\n\n2. Research Phase:\n   - Analyze codebase for auth patterns\n   - Find existing user handling\n   - Document dependencies\n   Output: ./notes/research/user-authentication.md\n\n3. Research Checkpoint:\n   - \"Research shows Guardian and Pow available. Which do you prefer?\"\n   - User: \"Guardian\"\n   - Update research with decision\n\n4. Plan Phase:\n   - Design using Guardian\n   - Define phases: User resource â†’ OAuth â†’ Sessions\n   Output: ./notes/plans/user-authentication.md\n\n5. Plan Checkpoint:\n   - \"Plan has 3 phases. OAuth before sessions ok?\"\n   - User: \"Yes\"\n\n6. Breakdown Phase:\n   - Create numbered task checklist\n   - Add TDD requirements\n   Output: ./notes/breakdowns/user-authentication.md\n\n7. Breakdown Checkpoint:\n   - \"8 tasks total. Ready to execute?\"\n   - User: \"Yes, proceed\"\n\n8. Execute Phase:\n   - Implement tasks 1-8\n   - Follow TDD workflow\n   - Commit after each task\n\n9. Update knowledge base with learnings\n```\n\n---\n\n## Common Pitfalls\n\n- **Skipping checkpoints**: Always pause for user input between phases\n- **Parallel execution**: Phases must run sequentially\n- **No breakdown approval**: Never execute without explicit approval\n- **Rushing through**: Take time for quality at each phase"
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}