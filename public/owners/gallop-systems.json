{
  "owner": {
    "id": "gallop-systems",
    "display_name": "gallop-systems",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/238145497?v=4",
    "url": "https://github.com/gallop-systems",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 4,
      "total_commands": 0,
      "total_skills": 6,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "gallop-systems/claude-skills",
      "url": "https://github.com/gallop-systems/claude-skills",
      "description": "Claude Code skills for the Gallop Systems team",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-04T00:23:42Z",
        "created_at": "2026-01-02T19:34:22Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 913
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 146
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 97
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2161
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/kysely-postgres",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/kysely-postgres/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/kysely-postgres/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 161
        },
        {
          "path": "skills/kysely-postgres/SKILL.md",
          "type": "blob",
          "size": 27003
        },
        {
          "path": "skills/kysely-postgres/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/kysely-postgres/references/aggregations.ts",
          "type": "blob",
          "size": 3565
        },
        {
          "path": "skills/kysely-postgres/references/ctes.ts",
          "type": "blob",
          "size": 4416
        },
        {
          "path": "skills/kysely-postgres/references/expressions.ts",
          "type": "blob",
          "size": 7342
        },
        {
          "path": "skills/kysely-postgres/references/joins.ts",
          "type": "blob",
          "size": 5543
        },
        {
          "path": "skills/kysely-postgres/references/json-arrays.ts",
          "type": "blob",
          "size": 11676
        },
        {
          "path": "skills/kysely-postgres/references/mutations.ts",
          "type": "blob",
          "size": 5166
        },
        {
          "path": "skills/kysely-postgres/references/orderby-pagination.ts",
          "type": "blob",
          "size": 3132
        },
        {
          "path": "skills/kysely-postgres/references/relations.ts",
          "type": "blob",
          "size": 5215
        },
        {
          "path": "skills/kysely-postgres/references/select-where.ts",
          "type": "blob",
          "size": 3666
        },
        {
          "path": "skills/nitro-testing",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nitro-testing/SKILL.md",
          "type": "blob",
          "size": 7086
        },
        {
          "path": "skills/nitro-testing/async-testing.md",
          "type": "blob",
          "size": 7566
        },
        {
          "path": "skills/nitro-testing/ci-setup.md",
          "type": "blob",
          "size": 4873
        },
        {
          "path": "skills/nitro-testing/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nitro-testing/examples/global-setup.ts",
          "type": "blob",
          "size": 2839
        },
        {
          "path": "skills/nitro-testing/examples/handler.test.ts",
          "type": "blob",
          "size": 4466
        },
        {
          "path": "skills/nitro-testing/examples/setup.ts",
          "type": "blob",
          "size": 766
        },
        {
          "path": "skills/nitro-testing/examples/test-utils-index.ts",
          "type": "blob",
          "size": 8834
        },
        {
          "path": "skills/nitro-testing/examples/vitest.config.ts",
          "type": "blob",
          "size": 1037
        },
        {
          "path": "skills/nitro-testing/factories.md",
          "type": "blob",
          "size": 6647
        },
        {
          "path": "skills/nitro-testing/test-utils.md",
          "type": "blob",
          "size": 6558
        },
        {
          "path": "skills/nitro-testing/transaction-rollback.md",
          "type": "blob",
          "size": 5090
        },
        {
          "path": "skills/nitro-testing/vitest-config.md",
          "type": "blob",
          "size": 5613
        },
        {
          "path": "skills/nuxt-nitro-api",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nuxt-nitro-api/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nuxt-nitro-api/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 176
        },
        {
          "path": "skills/nuxt-nitro-api/SKILL.md",
          "type": "blob",
          "size": 7179
        },
        {
          "path": "skills/nuxt-nitro-api/auth-patterns.md",
          "type": "blob",
          "size": 6010
        },
        {
          "path": "skills/nuxt-nitro-api/composables-utils.md",
          "type": "blob",
          "size": 4832
        },
        {
          "path": "skills/nuxt-nitro-api/deep-linking.md",
          "type": "blob",
          "size": 5395
        },
        {
          "path": "skills/nuxt-nitro-api/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/nuxt-nitro-api/examples/auth-middleware.ts",
          "type": "blob",
          "size": 845
        },
        {
          "path": "skills/nuxt-nitro-api/examples/auth-utils.ts",
          "type": "blob",
          "size": 1336
        },
        {
          "path": "skills/nuxt-nitro-api/examples/deep-link-page.vue",
          "type": "blob",
          "size": 1745
        },
        {
          "path": "skills/nuxt-nitro-api/examples/service-util.ts",
          "type": "blob",
          "size": 1629
        },
        {
          "path": "skills/nuxt-nitro-api/examples/sse-endpoint.ts",
          "type": "blob",
          "size": 1493
        },
        {
          "path": "skills/nuxt-nitro-api/examples/validation-endpoint.ts",
          "type": "blob",
          "size": 1298
        },
        {
          "path": "skills/nuxt-nitro-api/fetch-patterns.md",
          "type": "blob",
          "size": 3854
        },
        {
          "path": "skills/nuxt-nitro-api/nitro-tasks.md",
          "type": "blob",
          "size": 6023
        },
        {
          "path": "skills/nuxt-nitro-api/page-structure.md",
          "type": "blob",
          "size": 4140
        },
        {
          "path": "skills/nuxt-nitro-api/server-services.md",
          "type": "blob",
          "size": 5582
        },
        {
          "path": "skills/nuxt-nitro-api/sse.md",
          "type": "blob",
          "size": 4699
        },
        {
          "path": "skills/nuxt-nitro-api/ssr-client.md",
          "type": "blob",
          "size": 4082
        },
        {
          "path": "skills/nuxt-nitro-api/validation.md",
          "type": "blob",
          "size": 3281
        }
      ],
      "marketplace": {
        "name": "gallop-systems-claude-skills",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Gallop Systems",
          "email": "yeedle@gallopsystems.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "all",
            "description": "All skills: Kysely PostgreSQL, Nuxt/Nitro API, Nitro testing",
            "source": "./",
            "category": null,
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gallop-systems/claude-skills",
              "/plugin install all@gallop-systems-claude-skills"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-04T00:23:42Z",
              "created_at": "2026-01-02T19:34:22Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "kysely-postgres",
                "description": "Write effective, type-safe Kysely queries for PostgreSQL. This skill should be used when working in Node.js/TypeScript backends with Kysely installed, covering query patterns, migrations, type generation, and common pitfalls to avoid.",
                "path": "skills/kysely-postgres/SKILL.md",
                "frontmatter": {
                  "name": "kysely-postgres",
                  "description": "Write effective, type-safe Kysely queries for PostgreSQL. This skill should be used when working in Node.js/TypeScript backends with Kysely installed, covering query patterns, migrations, type generation, and common pitfalls to avoid."
                },
                "content": "# Kysely for PostgreSQL\n\nKysely is a type-safe TypeScript SQL query builder. This skill provides patterns for writing effective queries, managing migrations, and avoiding common pitfalls.\n\n## When to Use This Skill\n\nUse this skill when:\n- Working in a Node.js/TypeScript project with Kysely installed\n- Writing database queries for PostgreSQL\n- Creating or modifying database migrations\n- Debugging type inference issues in Kysely queries\n\n## Reference Files\n\nFor detailed examples, see these topic-focused reference files:\n\n- [select-where.ts](references/select-where.ts) - Basic SELECT patterns, WHERE clauses, AND/OR conditions\n- [joins.ts](references/joins.ts) - Simple joins, callback joins, subquery joins, cross joins\n- [aggregations.ts](references/aggregations.ts) - COUNT, SUM, AVG, GROUP BY, HAVING\n- [orderby-pagination.ts](references/orderby-pagination.ts) - ORDER BY, NULLS handling, DISTINCT, pagination\n- [ctes.ts](references/ctes.ts) - Common Table Expressions, multiple CTEs, recursive CTEs\n- [json-arrays.ts](references/json-arrays.ts) - JSONB handling, array columns, jsonBuildObject, jsonAgg\n- [relations.ts](references/relations.ts) - jsonArrayFrom, jsonObjectFrom for nested data\n- [mutations.ts](references/mutations.ts) - INSERT, UPDATE, DELETE, UPSERT, INSERT FROM SELECT\n- [expressions.ts](references/expressions.ts) - CASE, $if, subqueries, eb.val/lit/not, standalone expressionBuilder\n\n## Core Principles\n\n1. **Prefer Kysely methods over raw SQL**: Almost everything you can do in SQL, you can do in Kysely without `sql``\n2. **Use the ExpressionBuilder (eb)**: The `eb` parameter in callbacks is the foundation of type-safe query building\n3. **Let TypeScript guide you**: If it compiles, it's likely correct SQL\n\n## ExpressionBuilder (eb) - The Foundation\n\nThe `eb` parameter in select/where callbacks provides all expression methods:\n\n```typescript\n.select((eb) => [\n  eb.ref(\"column\").as(\"alias\"),                    // Column reference\n  eb.fn<string>(\"upper\", [eb.ref(\"email\")]),       // Function call (typed!)\n  eb.fn.count(\"id\").as(\"count\"),                   // Aggregate function\n  eb.fn.sum(\"amount\").as(\"total\"),                 // SUM\n  eb.fn.avg(\"rating\").as(\"avgRating\"),             // AVG\n  eb.fn.coalesce(\"nullable_col\", eb.val(0)),       // COALESCE\n  eb.case().when(\"status\", \"=\", \"active\")          // CASE expression\n    .then(\"Active\").else(\"Inactive\").end(),\n  eb(\"quantity\", \"*\", eb.ref(\"unit_price\")),       // Binary expression\n  eb.exists(subquery),                             // EXISTS\n  eb.not(expression),                              // NOT / negation\n  eb.cast(eb.val(\" \"), \"text\"),                    // Cast value to type\n  eb.and([...]),                                   // AND conditions\n  eb.or([...]),                                    // OR conditions\n])\n```\n\n### eb.val() vs eb.lit()\n\n```typescript\n// eb.val() - Creates a parameterized value ($1, $2, etc.) - PREFERRED for user input\n// Note: eb.val() alone may fail with \"could not determine data type of parameter\"\n// Use eb.cast(eb.val(...), \"text\") for string values in function arguments\neb.val(\"user input\")                    // Becomes: $1 with parameter \"user input\"\neb.cast(eb.val(\"safe\"), \"text\")         // Becomes: $1::text - always works\n\n// eb.lit() - Creates a literal value in SQL\n// ONLY accepts: numbers, booleans, null - NOT strings (throws \"unsafe immediate value\")\neb.lit(1)             // Becomes: 1 (directly in SQL)\neb.lit(true)          // Becomes: true\neb.lit(null)          // Becomes: NULL\n\n// For string literals, use sql`` template instead\nsql`'active'`         // Becomes: 'active' (directly in SQL)\nsql<string>`'label'`  // Typed string literal\n```\n\n### Standalone ExpressionBuilder\n\nFor reusable helpers outside query callbacks:\n\n```typescript\nimport { expressionBuilder } from \"kysely\";\nimport type { DB } from \"./db.d.ts\";\n\n// Create standalone expression builder\nconst eb = expressionBuilder<DB, \"user\">();\n\n// Use in helper functions\nfunction isActiveUser() {\n  return eb.and([\n    eb(\"is_active\", \"=\", true),\n    eb(\"role\", \"!=\", \"banned\"),\n  ]);\n}\n```\n\n### Conditional Expressions with Arrays\n\nBuild dynamic filters by collecting expressions:\n\n```typescript\n.where((eb) => {\n  const filters: Expression<SqlBool>[] = [];\n\n  if (firstName) filters.push(eb(\"first_name\", \"=\", firstName));\n  if (lastName) filters.push(eb(\"last_name\", \"=\", lastName));\n  if (minAge) filters.push(eb(\"age\", \">=\", minAge));\n\n  // Combine all filters with AND (empty array = no filter)\n  return eb.and(filters);\n})\n```\n\n## String Concatenation\n\nUse the `||` operator with `sql` template for clean string concatenation:\n\n```typescript\n// RECOMMENDED - Clean and type-safe with eb.ref()\n.select((eb) => [\n  sql<string>`${eb.ref(\"first_name\")} || ' ' || ${eb.ref(\"last_name\")}`.as(\"full_name\"),\n])\n// Output: \"first_name\" || ' ' || \"last_name\"\n\n// ALTERNATIVE - Pure eb() chaining (parameterized literals)\n.select((eb) => [\n  eb(eb(\"first_name\", \"||\", \" \"), \"||\", eb.ref(\"last_name\")).as(\"full_name\"),\n])\n// Output: \"first_name\" || $1 || \"last_name\"\n\n// VERBOSE - concat() function (avoid unless you need NULL handling)\n.select((eb) => [\n  eb.fn<string>(\"concat\", [\n    eb.ref(\"first_name\"),\n    eb.cast(eb.val(\" \"), \"text\"),\n    eb.ref(\"last_name\"),\n  ]).as(\"full_name\"),\n])\n```\n\n**Note**: `concat()` treats NULL as empty string, while `||` propagates NULL. Use `concat()` only when you need that NULL behavior.\n\n## Query Patterns\n\n### Basic SELECT\n\n```typescript\n// Select all columns\nconst users = await db.selectFrom(\"user\").selectAll().execute();\n\n// Select specific columns with aliases\nconst users = await db\n  .selectFrom(\"user\")\n  .select([\"id\", \"email\", \"first_name as firstName\"])\n  .execute();\n\n// Single row (returns T | undefined)\nconst user = await db.selectFrom(\"user\").selectAll()\n  .where(\"id\", \"=\", userId).executeTakeFirst();\n\n// Single row that must exist (throws if not found)\nconst user = await db.selectFrom(\"user\").selectAll()\n  .where(\"id\", \"=\", userId).executeTakeFirstOrThrow();\n```\n\n### WHERE Clauses\n\n```typescript\n// Equality, comparison, IN, LIKE\n.where(\"status\", \"=\", \"active\")\n.where(\"price\", \">\", 100)\n.where(\"role\", \"in\", [\"admin\", \"manager\"])\n.where(\"name\", \"like\", \"%search%\")\n.where(\"deleted_at\", \"is\", null)\n\n// Multiple conditions (chained = AND)\n.where(\"is_active\", \"=\", true)\n.where(\"role\", \"=\", \"admin\")\n\n// OR conditions\n.where((eb) => eb.or([\n  eb(\"role\", \"=\", \"admin\"),\n  eb(\"role\", \"=\", \"manager\"),\n]))\n\n// Complex AND/OR\n.where((eb) => eb.and([\n  eb(\"is_active\", \"=\", true),\n  eb.or([\n    eb(\"price\", \"<\", 50),\n    eb(\"stock\", \">\", 100),\n  ]),\n]))\n```\n\n### JOINs\n\n```typescript\n// Inner join\n.innerJoin(\"order\", \"order.user_id\", \"user.id\")\n\n// Left join\n.leftJoin(\"category\", \"category.id\", \"product.category_id\")\n\n// Self-join with alias\n.selectFrom(\"category as c\")\n.leftJoin(\"category as parent\", \"parent.id\", \"c.parent_id\")\n\n// Multiple joins\n.innerJoin(\"order\", \"order.id\", \"order_item.order_id\")\n.innerJoin(\"product\", \"product.id\", \"order_item.product_id\")\n.innerJoin(\"user\", \"user.id\", \"order.user_id\")\n```\n\n### Complex JOINs (Callback Format)\n\nUse the callback format when you need:\n- Multiple join conditions (composite keys)\n- Mixed column-to-column and column-to-literal comparisons\n- OR conditions within joins\n- Subquery joins (derived tables)\n\n**Join Builder Methods:**\n- `onRef(col1, op, col2)` - Column-to-column comparison\n- `on(col, op, value)` - Column-to-literal comparison\n- `on((eb) => ...)` - Complex expressions with OR logic\n\n```typescript\n// Multi-condition join (composite key + filter)\n.leftJoin(\"invoice as i\", (join) =>\n  join\n    .onRef(\"sp.service_provider_id\", \"=\", \"i.service_provider_id\")\n    .onRef(\"sp.year\", \"=\", \"i.year\")\n    .onRef(\"sp.month\", \"=\", \"i.month\")\n    .on(\"i.status\", \"!=\", \"invalidated\")\n)\n\n// Join with OR conditions\n.leftJoin(\"order as o\", (join) =>\n  join\n    .onRef(\"o.user_id\", \"=\", \"u.id\")\n    .on((eb) =>\n      eb.or([\n        eb(\"o.status\", \"=\", \"completed\"),\n        eb(\"o.status\", \"=\", \"shipped\"),\n      ])\n    )\n)\n\n// Subquery join (derived table) - two callbacks\n.leftJoin(\n  (eb) =>\n    eb\n      .selectFrom(\"order\")\n      .select((eb) => [\n        \"user_id\",\n        eb.fn.count(\"id\").as(\"order_count\"),\n        eb.fn.max(\"created_at\").as(\"last_order_at\"),\n      ])\n      .groupBy(\"user_id\")\n      .as(\"order_stats\"),  // MUST have alias!\n  (join) => join.onRef(\"order_stats.user_id\", \"=\", \"u.id\")\n)\n\n// Cross join (always-true condition) - for joining aggregated CTEs\n.leftJoin(\"summary_cte\", (join) =>\n  join.on(sql`true`, \"=\", sql`true`)\n)\n```\n\n### Aggregations\n\n```typescript\n.select((eb) => [\n  \"status\",\n  eb.fn.count(\"id\").as(\"count\"),\n  eb.fn.sum(\"total_amount\").as(\"totalAmount\"),\n  eb.fn.avg(\"total_amount\").as(\"avgAmount\"),\n])\n.groupBy(\"status\")\n.having((eb) => eb.fn.count(\"id\"), \">\", 5)\n```\n\n### ORDER BY\n\n```typescript\n// Simple ordering\n.orderBy(\"created_at\", \"desc\")\n.orderBy(\"name\", \"asc\")\n\n// NULLS FIRST / NULLS LAST - use order builder callback\n.orderBy(\"category_id\", (ob) => ob.asc().nullsLast())\n.orderBy(\"priority\", (ob) => ob.desc().nullsFirst())\n\n// Multiple columns - chain orderBy calls (array syntax is deprecated)\n.orderBy(\"category_id\", \"asc\")\n.orderBy(\"price\", \"desc\")\n.orderBy(\"name\", \"asc\")\n```\n\n### CTEs (Common Table Expressions)\n\nUse CTEs for complex queries with multiple aggregation levels:\n\n```typescript\nconst result = await db\n  .with(\"order_totals\", (db) =>\n    db.selectFrom(\"order\")\n      .innerJoin(\"user\", \"user.id\", \"order.user_id\")\n      .select((eb) => [\n        \"user.id as userId\",\n        \"user.email\",\n        eb.fn.sum(\"order.total_amount\").as(\"totalSpent\"),\n        eb.fn.count(\"order.id\").as(\"orderCount\"),\n      ])\n      .groupBy([\"user.id\", \"user.email\"])\n  )\n  .selectFrom(\"order_totals\")\n  .selectAll()\n  .orderBy(\"totalSpent\", \"desc\")\n  .execute();\n```\n\n### JSON Aggregation (PostgreSQL)\n\n```typescript\nimport { jsonBuildObject } from \"kysely/helpers/postgres\";\n// Note: jsonAgg is accessed via eb.fn.jsonAgg(), not imported\n\n.with(\"tasks\", (db) =>\n  db.selectFrom(\"task\")\n    .leftJoin(\"user\", \"user.id\", \"task.assignee_id\")\n    .select((eb) => [\n      \"task.job_id\",\n      eb.fn.jsonAgg(\n        jsonBuildObject({\n          id: eb.ref(\"task.id\"),\n          status: eb.ref(\"task.status\"),\n          assignee: jsonBuildObject({\n            id: eb.ref(\"user.id\"),\n            name: eb.fn<string>(\"concat\", [\n              eb.ref(\"user.first_name\"),\n              eb.cast(eb.val(\" \"), \"text\"),\n              eb.ref(\"user.last_name\"),\n            ]),\n          }),\n        })\n      )\n      .filterWhere(\"task.id\", \"is not\", null) // Filter nulls from left join\n      .as(\"tasks\"),\n    ])\n    .groupBy(\"task.job_id\")\n)\n```\n\n## JSON, JSONB, and Array Handling\n\n### JSONB Columns\n\n**NO `JSON.stringify` or `JSON.parse` needed!** The `pg` driver handles JSONB automatically:\n\n```typescript\n// INSERT - pass objects directly\nawait db\n  .insertInto(\"user\")\n  .values({\n    email: \"test@example.com\",\n    metadata: { preferences: { theme: \"dark\" }, count: 42 },\n  })\n  .execute();\n\n// UPDATE - pass objects directly\nawait db\n  .updateTable(\"user\")\n  .set({\n    metadata: { preferences: { theme: \"light\" } },\n  })\n  .where(\"id\", \"=\", userId)\n  .execute();\n\n// READ - returns parsed object, not string\nconst user = await db\n  .selectFrom(\"user\")\n  .select([\"id\", \"metadata\"])\n  .executeTakeFirst();\nconsole.log(user.metadata.preferences.theme); // \"dark\" - already an object!\n```\n\n### Array Columns (text[], int[], etc.)\n\n**NO `JSON.stringify` needed for array columns!** The `pg` driver handles arrays natively:\n\n```typescript\n// INSERT with array - pass array directly\nawait db\n  .insertInto(\"product\")\n  .values({\n    name: \"Product\",\n    tags: [\"phone\", \"electronics\", \"premium\"], // Direct array!\n  })\n  .execute();\n\n// READ - returns as native JavaScript array\nconst product = await db\n  .selectFrom(\"product\")\n  .select([\"name\", \"tags\"])\n  .executeTakeFirst();\nconsole.log(product.tags); // [\"phone\", \"electronics\", \"premium\"]\n\n// UPDATE array\nawait db\n  .updateTable(\"product\")\n  .set({ tags: [\"updated\", \"tags\"] })\n  .where(\"id\", \"=\", productId)\n  .execute();\n```\n\n### Querying Arrays\n\n```typescript\n// Array contains all values (@>) - operator works natively!\n.where(\"tags\", \"@>\", sql`ARRAY['phone', 'premium']::text[]`)\n\n// Arrays overlap (&&) - operator works natively!\n.where(\"tags\", \"&&\", sql`ARRAY['premium', 'basic']::text[]`)\n\n// Array contains value (ANY) - type-safe with eb.fn\n.where((eb) => eb(sql`${searchTerm}`, \"=\", eb.fn(\"any\", [eb.ref(\"tags\")])))\n// eb.ref(\"tags\") validates column exists - eb.ref(\"invalid\") would be a TS error\n```\n\n### Querying JSONB\n\n```typescript\n// Key exists (?) - operator works natively!\n.where(\"metadata\", \"?\", \"theme\")\n\n// Any key exists (?|) - operator works natively!\n.where(\"metadata\", \"?|\", sql`array['theme', 'language']`)\n\n// All keys exist (?&) - operator works natively!\n.where(\"metadata\", \"?&\", sql`array['theme', 'notifications']`)\n\n// JSONB contains (@>) - operator works natively!\n.where(\"metadata\", \"@>\", sql`'{\"notifications\": true}'::jsonb`)\n\n// Extract field as text (->> as operator) - type-safe!\n.where((eb) => eb(eb(\"metadata\", \"->>\", \"theme\"), \"=\", \"dark\"))\n// eb(\"metadata\", ...) validates column - eb(\"invalid\", ...) would be TS error\n\n// Extract nested path (#>> still needs sql``)\n.where(sql`metadata#>>'{preferences,theme}'`, \"=\", \"dark\")\n\n// In SELECT - type-safe with eb()\n.select((eb) => [\n  eb(\"metadata\", \"->\", \"preferences\").as(\"prefs\"),   // Returns JSONB\n  eb(\"metadata\", \"->>\", \"theme\").as(\"theme\"),        // Returns text\n])\n// Nested paths still need sql``\n.select(sql`metadata#>'{preferences,theme}'`.as(\"t\"))   // Nested as JSONB\n.select(sql<string>`metadata#>>'{a,b}'`.as(\"t\"))        // Nested as text\n```\n\n### JSONPath (PostgreSQL 12+)\n\n```typescript\n// JSONPath match (@@) - works as native operator!\n.where(\"metadata\", \"@@\", sql`'$.preferences.theme == \"dark\"'`)\n\n// JSONPath exists (@?) - NOT in Kysely's allowlist, use function instead\n// Use jsonb_path_exists() for type-safe column validation\n.where((eb) =>\n  eb.fn(\"jsonb_path_exists\", [eb.ref(\"metadata\"), sql`'$.preferences.theme'`])\n)\n// eb.ref(\"metadata\") validates column - eb.ref(\"invalid\") would be TS error\n\n// Extract with JSONPath - type-safe with eb.fn\n.select((eb) => [\n  \"id\",\n  eb.fn(\"jsonb_path_query_first\", [eb.ref(\"metadata\"), sql`'$.preferences.theme'`]).as(\"theme\"),\n])\n\n// JSONPath with variables\nconst searchValue = \"dark\";\n.where((eb) =>\n  eb.fn(\"jsonb_path_exists\", [\n    eb.ref(\"metadata\"),\n    sql`'$.preferences.theme ? (@ == $val)'`,\n    sql`jsonb_build_object('val', ${searchValue}::text)`,\n  ])\n)\n```\n\n### Conditional Queries ($if)\n\nUse `$if()` for runtime-conditional query modifications:\n\n```typescript\nconst result = await db\n  .selectFrom(\"user\")\n  .selectAll()\n  .$if(!includeInactive, (qb) => qb.where(\"is_active\", \"=\", true))\n  .$if(includeMetadata, (qb) => qb.select(\"metadata\"))\n  .$if(!!searchTerm, (qb) => qb.where(\"name\", \"like\", `%${searchTerm}%`))\n  .$if(!!roleFilter, (qb) => qb.where(\"role\", \"in\", roleFilter!))\n  .execute();\n```\n\n**Type behavior**: Columns added via `$if` become optional in the result type since inclusion isn't guaranteed at compile time.\n\n### Relations (jsonArrayFrom / jsonObjectFrom)\n\nKysely is NOT an ORM - it uses PostgreSQL's JSON functions for nested data:\n\n```typescript\nimport { jsonArrayFrom, jsonObjectFrom } from \"kysely/helpers/postgres\";\n\n// One-to-many: User with their orders\nconst users = await db\n  .selectFrom(\"user\")\n  .select((eb) => [\n    \"user.id\",\n    \"user.email\",\n    jsonArrayFrom(\n      eb\n        .selectFrom(\"order\")\n        .select([\"order.id\", \"order.status\", \"order.total_amount\"])\n        .whereRef(\"order.user_id\", \"=\", \"user.id\")\n        .orderBy(\"order.created_at\", \"desc\")\n    ).as(\"orders\"),\n  ])\n  .execute();\n\n// Many-to-one: Product with its category\nconst products = await db\n  .selectFrom(\"product\")\n  .select((eb) => [\n    \"product.id\",\n    \"product.name\",\n    jsonObjectFrom(\n      eb\n        .selectFrom(\"category\")\n        .select([\"category.id\", \"category.name\"])\n        .whereRef(\"category.id\", \"=\", \"product.category_id\")\n    ).as(\"category\"),\n  ])\n  .execute();\n```\n\n### Reusable Helpers\n\nCreate composable, type-safe helper functions using `Expression<T>`:\n\n```typescript\nimport { Expression, sql } from \"kysely\";\n\n// Helper that takes and returns Expression<string>\nfunction lower(expr: Expression<string>) {\n  return sql<string>`lower(${expr})`;\n}\n\n// Use in queries\n.where(({ eb, ref }) => eb(lower(ref(\"email\")), \"=\", email.toLowerCase()))\n```\n\n### Splitting Query Building and Execution\n\nBuild queries without executing, useful for dynamic query construction:\n\n```typescript\n// Build query (doesn't execute)\nlet query = db\n  .selectFrom(\"user\")\n  .select([\"id\", \"email\"]);\n\n// Add conditions dynamically\nif (role) {\n  query = query.where(\"role\", \"=\", role);\n}\nif (isActive !== undefined) {\n  query = query.where(\"is_active\", \"=\", isActive);\n}\n\n// Execute when ready\nconst results = await query.execute();\n\n// Or compile to SQL without executing\nconst compiled = query.compile();\nconsole.log(compiled.sql);        // The SQL string\nconsole.log(compiled.parameters); // Bound parameters\n```\n\n### Subqueries\n\n```typescript\n// Subquery in WHERE\n.where(\"id\", \"in\",\n  db.selectFrom(\"order\").select(\"user_id\").where(\"status\", \"=\", \"completed\")\n)\n\n// EXISTS subquery\n.where((eb) =>\n  eb.exists(\n    db.selectFrom(\"review\")\n      .select(sql`1`.as(\"one\"))\n      .whereRef(\"review.product_id\", \"=\", eb.ref(\"product.id\"))\n  )\n)\n```\n\n### INSERT Operations\n\n```typescript\n// Single insert with returning\nconst user = await db\n  .insertInto(\"user\")\n  .values({ email: \"test@example.com\", first_name: \"Test\", last_name: \"User\" })\n  .returning([\"id\", \"email\"])\n  .executeTakeFirst();\n\n// Multiple rows\nawait db\n  .insertInto(\"user\")\n  .values([\n    { email: \"a@example.com\", first_name: \"A\", last_name: \"User\" },\n    { email: \"b@example.com\", first_name: \"B\", last_name: \"User\" },\n  ])\n  .execute();\n\n// Upsert (ON CONFLICT) - type-safe with expression builder\nawait db\n  .insertInto(\"product\")\n  .values({ sku: \"ABC123\", name: \"Product\", stock_quantity: 10 })\n  .onConflict((oc) =>\n    oc.column(\"sku\").doUpdateSet((eb) => ({\n      stock_quantity: eb(\"product.stock_quantity\", \"+\", eb.ref(\"excluded.stock_quantity\")),\n    }))\n  )\n  .execute();\n// eb(\"product.invalid_column\", ...) would be a TypeScript error!\n\n// Insert from SELECT\nawait db\n  .insertInto(\"archive\")\n  .columns([\"user_id\", \"data\", \"archived_at\"])\n  .expression(\n    db.selectFrom(\"user\")\n      .select([\"id\", \"metadata\", sql`now()`.as(\"archived_at\")])\n      .where(\"is_active\", \"=\", false)\n  )\n  .execute();\n```\n\n### UPDATE Operations\n\n```typescript\n// Simple update\nawait db\n  .updateTable(\"user\")\n  .set({ is_active: false })\n  .where(\"id\", \"=\", userId)\n  .execute();\n\n// Update with expression\nawait db\n  .updateTable(\"product\")\n  .set((eb) => ({\n    stock_quantity: eb(\"stock_quantity\", \"+\", 10),\n  }))\n  .where(\"sku\", \"=\", \"ABC123\")\n  .returning([\"id\", \"stock_quantity\"])\n  .executeTakeFirst();\n```\n\n## Migrations\n\n### Configuration (kysely.config.ts)\n\n```typescript\nimport { PostgresDialect } from \"kysely\";\nimport { defineConfig } from \"kysely-ctl\";\nimport pg from \"pg\";\n\nexport default defineConfig({\n  dialect: new PostgresDialect({\n    pool: new pg.Pool({\n      connectionString: process.env.DATABASE_URL,\n    }),\n  }),\n  migrations: {\n    migrationFolder: \"src/db/migrations\",\n  },\n  seeds: {\n    seedFolder: \"src/db/seeds\",\n  },\n});\n```\n\n### Migration Commands\n\n```bash\nnpx kysely migrate:make migration-name  # Create migration\nnpx kysely migrate:latest               # Run all pending migrations\nnpx kysely migrate:down                 # Rollback last migration\nnpx kysely seed make seed-name          # Create seed\nnpx kysely seed run                     # Run all seeds\n```\n\n### Migration File Structure\n\n```typescript\nimport type { Kysely } from \"kysely\";\nimport { sql } from \"kysely\";\n\n// Always use Kysely<any> - migrations should be frozen in time\nexport async function up(db: Kysely<any>): Promise<void> {\n  await db.schema\n    .createTable(\"user\")\n    .addColumn(\"id\", \"bigint\", (col) => col.primaryKey().generatedAlwaysAsIdentity())\n    .addColumn(\"email\", \"text\", (col) => col.notNull().unique())\n    .addColumn(\"created_at\", \"timestamptz\", (col) => col.notNull().defaultTo(sql`now()`))\n    .execute();\n\n  // IMPORTANT: Always index foreign key columns!\n  await db.schema.createIndex(\"idx_order_user_id\").on(\"order\").column(\"user_id\").execute();\n}\n\nexport async function down(db: Kysely<any>): Promise<void> {\n  await db.schema.dropTable(\"user\").execute();\n}\n```\n\n### Recommended Column Types\n\n```typescript\n// Primary keys: Use identity columns (SQL standard, prevents accidental ID conflicts)\n.addColumn(\"id\", \"bigint\", (col) => col.primaryKey().generatedAlwaysAsIdentity())\n// NOT serial/bigserial - those allow manual ID inserts that can cause conflicts\n\n// Timestamps: Always use timestamptz (stores UTC, converts to client timezone)\n.addColumn(\"created_at\", \"timestamptz\", (col) => col.notNull().defaultTo(sql`now()`))\n// NOT timestamp - loses timezone information\n\n// Money: Use numeric with precision (exact decimal, no floating point errors)\n.addColumn(\"price\", \"numeric(10, 2)\", (col) => col.notNull())\n// NOT float/real/double precision - those have rounding errors\n\n// Strings: Use text (no length limit, same performance as varchar)\n.addColumn(\"name\", \"text\", (col) => col.notNull())\n// varchar(n) only if you need a hard length constraint\n\n// JSON: Use jsonb (binary, indexable, faster queries)\n.addColumn(\"metadata\", \"jsonb\")\n// NOT json - stored as text, no indexing, slower\n\n// Foreign keys: Create indexes manually (PostgreSQL doesn't auto-index FKs)\nawait db.schema.createIndex(\"idx_order_user_id\").on(\"order\").column(\"user_id\").execute();\n```\n\n### Data Type Gotchas\n\n```typescript\n// CORRECT - Space after comma in numeric types\n.addColumn(\"price\", \"numeric(10, 2)\")\n\n// WRONG - Will fail with \"invalid column data type\"\n.addColumn(\"price\", \"numeric(10,2)\")\n\n// For complex types, use sql template\n.addColumn(\"price\", sql`numeric(10, 2)`)\n```\n\n## Type Generation\n\nUse `kysely-codegen` to generate types from your database:\n\n```bash\nnpx kysely-codegen --url \"postgresql://...\" --out-file src/db/db.d.ts\n```\n\nGenerated types use:\n- `Generated<T>` for auto-increment columns (optional on insert)\n- `ColumnType<Select, Insert, Update>` for different operation types\n- `Timestamp` for timestamptz columns\n\n## Common Pitfalls to Avoid\n\n### 1. Don't Resort to `sql`` When Kysely Has a Method\n\n```typescript\n// WRONG\n.select(sql`count(*)`.as(\"count\"))\n\n// RIGHT\n.select((eb) => eb.fn.countAll().as(\"count\"))\n```\n\n### 2. Don't Forget .execute()\n\nQueries are lazy - they won't run without calling an execute method:\n\n```typescript\n// This does nothing!\ndb.selectFrom(\"user\").selectAll();\n\n// This runs the query\nawait db.selectFrom(\"user\").selectAll().execute();\n```\n\n### 3. Use whereRef for Column-to-Column Comparisons\n\n```typescript\n// WRONG - Compares to string literal \"other.column\"\n.where(\"table.column\", \"=\", \"other.column\")\n\n// RIGHT - Compares to actual column value\n.whereRef(\"table.column\", \"=\", \"other.column\")\n```\n\n### 4. Type Your Function Returns\n\n```typescript\n// Better type inference\neb.fn<string>(\"concat\", [...])\neb.fn<number>(\"length\", [...])\n```\n\n### 5. PostgreSQL Does NOT Auto-Index Foreign Keys\n\nAlways create indexes on foreign key columns:\n\n```typescript\nawait db.schema.createIndex(\"idx_order_user_id\").on(\"order\").column(\"user_id\").execute();\n```\n\n## PostgreSQL Helpers Summary\n\nAll helpers from `kysely/helpers/postgres`:\n\n```typescript\nimport {\n  jsonArrayFrom,    // One-to-many relations (subquery → array)\n  jsonObjectFrom,   // Many-to-one relations (subquery → object | null)\n  jsonBuildObject,  // Build JSON object from expressions\n  mergeAction,      // Get action performed in MERGE query (PostgreSQL 15+)\n} from \"kysely/helpers/postgres\";\n```\n\n**Note**: `jsonAgg` is NOT imported - use `eb.fn.jsonAgg()` instead.\n\n### mergeAction (PostgreSQL 15+)\n\nFor MERGE queries, get which action was performed:\n\n```typescript\nimport { mergeAction } from \"kysely/helpers/postgres\";\n\nconst result = await db\n  .mergeInto(\"person\")\n  .using(\"person_updates\", \"person.id\", \"person_updates.id\")\n  .whenMatched()\n  .thenUpdateSet({ name: eb.ref(\"person_updates.name\") })\n  .whenNotMatched()\n  .thenInsertValues({ id: eb.ref(\"person_updates.id\"), name: eb.ref(\"person_updates.name\") })\n  .returning([mergeAction().as(\"action\"), \"id\"])\n  .execute();\n\n// result[0].action is 'INSERT' | 'UPDATE' | 'DELETE'\n```\n\n## Extending Kysely\n\n### Custom Helper Functions\n\nMost extensions use the `sql` template tag with `RawBuilder<T>`:\n\n```typescript\nimport { sql, RawBuilder } from \"kysely\";\n\n// Create a typed helper function\nfunction json<T>(value: T): RawBuilder<T> {\n  return sql`CAST(${JSON.stringify(value)} AS JSONB)`;\n}\n\n// Use in queries\n.select((eb) => [\n  json({ name: \"value\" }).as(\"data\"),\n])\n```\n\n### Custom Expression Classes\n\nFor reusable expressions, implement the `Expression<T>` interface:\n\n```typescript\nimport { Expression, OperationNode, sql } from \"kysely\";\n\nclass JsonValue<T> implements Expression<T> {\n  readonly #value: T;\n\n  constructor(value: T) {\n    this.#value = value;\n  }\n\n  get expressionType(): T | undefined {\n    return undefined;\n  }\n\n  toOperationNode(): OperationNode {\n    return sql`CAST(${JSON.stringify(this.#value)} AS JSONB)`.toOperationNode();\n  }\n}\n```\n\n**Note**: Module augmentation and inheritance-based extension are not recommended.\n\n## Handling \"Excessively Deep Types\" Error\n\n### The Problem\n\nComplex queries with many CTEs can overwhelm TypeScript's type instantiation limits:\n\n```\nType instantiation is excessively deep and possibly infinite\n```\n\nThis commonly occurs with 12+ `with` clauses, as Kysely's nested helper types accumulate.\n\n### The Solution: `$assertType`\n\nUse `$assertType` to simplify the type chain at intermediate points:\n\n```typescript\nconst result = await db\n  .with(\"cte1\", (qb) =>\n    qb.selectFrom(\"user\")\n      .select([\"id\", \"email\"])\n      .$assertType<{ id: number; email: string }>()  // Simplify type here\n  )\n  .with(\"cte2\", (qb) =>\n    qb.selectFrom(\"cte1\")\n      .select(\"email\")\n      .$assertType<{ email: string }>()\n  )\n  // ... more CTEs\n  .selectFrom(\"cteN\")\n  .selectAll()\n  .execute();\n```\n\n**Key points**:\n- The asserted type must structurally match the actual type (full type safety preserved)\n- Apply to several intermediate `with` clauses in large queries\n- TypeScript cannot automatically simplify these types - explicit assertion is required"
              },
              {
                "name": "nitro-testing",
                "description": "Test Nuxt 3 / Nitro API handlers with real PostgreSQL, transaction rollback isolation, and typed factories. No mocks, real SQL.",
                "path": "skills/nitro-testing/SKILL.md",
                "frontmatter": {
                  "name": "nitro-testing",
                  "description": "Test Nuxt 3 / Nitro API handlers with real PostgreSQL, transaction rollback isolation, and typed factories. No mocks, real SQL."
                },
                "content": "# Nitro API Testing Patterns\n\nTest Nitro API handlers with a real PostgreSQL database using transaction rollback isolation. Each test runs in a transaction that auto-rolls back, providing complete isolation without cleanup overhead.\n\n## When to Use This Skill\n\nUse this skill when:\n- Testing Nuxt 3 / Nitro API handlers\n- Using Kysely or another query builder with PostgreSQL\n- Need real database testing (not mocks)\n- Want fast, isolated tests without truncation\n\n## Reference Files\n\n- [transaction-rollback.md](./transaction-rollback.md) - Core isolation pattern with Vitest fixtures\n- [test-utils.md](./test-utils.md) - Mock events, stubs, and assertion helpers\n- [factories.md](./factories.md) - Transaction-bound factory pattern\n- [vitest-config.md](./vitest-config.md) - Vitest configuration for Nitro\n- [ci-setup.md](./ci-setup.md) - GitHub Actions with PostgreSQL service\n- [async-testing.md](./async-testing.md) - Testing background tasks and automations\n\n## Example Files\n\n- [test-utils-index.ts](./examples/test-utils-index.ts) - Complete test utilities module\n- [global-setup.ts](./examples/global-setup.ts) - Database reset and migration\n- [setup.ts](./examples/setup.ts) - Per-file setup with stubs\n- [handler.test.ts](./examples/handler.test.ts) - Example API handler test\n- [vitest.config.ts](./examples/vitest.config.ts) - Vitest configuration\n\n## Core Concept: Transaction Rollback\n\nInstead of truncating tables between tests, each test runs inside a database transaction that rolls back at the end:\n\n```typescript\n// Each test gets isolated factories and db access\ntest(\"creates user\", async ({ factories, db }) => {\n  const user = await factories.user({ email: \"test@example.com\" });\n\n  // Test your handler\n  const event = mockPost({}, { name: \"New Item\" });\n  const result = await handler(event);\n\n  // Verify in database\n  const saved = await db.selectFrom(\"item\").selectAll().execute();\n  expect(saved).toHaveLength(1);\n});\n// Transaction auto-rolls back - no cleanup needed\n```\n\nBenefits:\n- **Fast**: No DELETE/TRUNCATE between tests\n- **Isolated**: Tests can't affect each other\n- **Real SQL**: Catches actual database issues\n- **Simple**: No manual cleanup\n\n## Quick Setup\n\n### 1. Install Dependencies\n\n```bash\nyarn add -D vitest @vitest/coverage-v8\n```\n\n### 2. Create Test Utils Structure\n\n```\nserver/\n  test-utils/\n    index.ts        # Factories, fixtures, mock helpers\n    global-setup.ts # Runs once: reset DB, run migrations\n    setup.ts        # Runs per-file: stub auto-imports\n```\n\n### 3. Configure Vitest\n\n```typescript\n// vitest.config.ts\nimport { defineConfig } from \"vitest/config\";\nimport path from \"path\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: \"node\",\n    globalSetup: [\"./server/test-utils/global-setup.ts\"],\n    setupFiles: [\"./server/test-utils/setup.ts\"],\n  },\n  resolve: {\n    alias: {\n      \"~\": path.resolve(__dirname),\n    },\n  },\n});\n```\n\n### 4. Write Tests\n\n```typescript\n// server/api/users/index.post.test.ts\nimport { describe, test, expect, mockPost, expectHttpError } from \"~/server/test-utils\";\nimport handler from \"./index.post\";\n\ndescribe(\"POST /api/users\", () => {\n  test(\"creates user with valid data\", async ({ factories: _, db }) => {\n    const event = mockPost({}, {\n      email: \"new@example.com\",\n      name: \"New User\"\n    });\n    const result = await handler(event);\n\n    expect(result.id).toBeDefined();\n    expect(result.email).toBe(\"new@example.com\");\n\n    // Verify persisted\n    const saved = await db\n      .selectFrom(\"user\")\n      .where(\"id\", \"=\", result.id)\n      .selectAll()\n      .executeTakeFirst();\n    expect(saved?.name).toBe(\"New User\");\n  });\n\n  test(\"throws 400 for missing email\", async ({ factories: _ }) => {\n    const event = mockPost({}, { name: \"No Email\" });\n    await expectHttpError(handler(event), { statusCode: 400 });\n  });\n});\n```\n\n## Key Patterns\n\n### Mock Event Helpers\n\n```typescript\n// GET with route params and query\nconst event = mockGet({ id: 123 }, { include: \"details\" });\n\n// POST with body\nconst event = mockPost({}, { name: \"Test\", status: \"active\" });\n\n// PATCH with route params and body\nconst event = mockPatch({ id: 123 }, { status: \"completed\" });\n\n// DELETE with route params\nconst event = mockDelete({ id: 123 });\n```\n\n### Factory Pattern\n\n```typescript\ntest(\"lists user's projects\", async ({ factories }) => {\n  // Factories are transaction-bound - auto-rolled back\n  const user = await factories.user();\n  const project1 = await factories.project({ ownerId: user.id });\n  const project2 = await factories.project({ ownerId: user.id });\n\n  const event = mockGet({ userId: user.id });\n  const result = await handler(event);\n\n  expect(result).toHaveLength(2);\n});\n```\n\n### Testing with Related Data\n\n```typescript\ntest(\"returns task with job details\", async ({ factories }) => {\n  // Factories auto-create dependencies\n  const job = await factories.job(); // Creates project automatically\n  const task = await factories.task({ jobId: job.id });\n\n  const event = mockGet({ id: task.id });\n  const result = await handler(event);\n\n  expect(result.job.id).toBe(job.id);\n  expect(result.job.project).toBeDefined();\n});\n```\n\n### Testing Error Cases\n\n```typescript\ntest(\"returns 404 for non-existent resource\", async ({ factories: _ }) => {\n  const event = mockGet({ id: 999999 });\n  await expectHttpError(handler(event), {\n    statusCode: 404,\n    message: \"Not found\",\n  });\n});\n\ntest(\"returns 400 for invalid input\", async ({ factories: _ }) => {\n  const event = mockPost({}, { invalidField: true });\n  await expectHttpError(handler(event), { statusCode: 400 });\n});\n```\n\n## Auto-Import Stubs\n\nThe setup file stubs Nuxt/Nitro auto-imports:\n\n| Stub | Purpose |\n|------|---------|\n| `defineEventHandler` | Unwraps to return handler directly |\n| `getUserSession` | Returns test user (configurable) |\n| `useDatabase` | Returns test transaction |\n| `createError` | Creates H3-style errors |\n| `getValidatedQuery` | Validates mock query params |\n| `readValidatedBody` | Validates mock body |\n| `getRouterParam` | Returns mock route params |\n\n## Key Gotchas\n\n1. **Always destructure `factories`** - Even if unused, it sets up the transaction:\n   ```typescript\n   test(\"...\", async ({ factories: _ }) => { ... });\n   ```\n\n2. **Don't use top-level db imports** - Use the `db` fixture instead:\n   ```typescript\n   // ❌ Wrong - uses real db, not transaction\n   import { db } from \"../utils/db\";\n\n   // ✅ Right - uses test transaction\n   test(\"...\", async ({ db }) => { ... });\n   ```\n\n3. **Nested transactions work** - Code that calls `db.transaction()` works because we patch the prototype\n\n4. **Test file location** - Co-locate with handlers: `handler.ts` → `handler.test.ts`\n\n5. **Separate test database** - Always use a dedicated test DB (`myapp-test`, not `myapp`)\n\n6. **CI needs PostgreSQL service** - See [ci-setup.md](./ci-setup.md) for GitHub Actions config"
              },
              {
                "name": "nuxt-nitro-api",
                "description": "Build type-safe Nuxt 3 applications with Nitro API patterns. Covers validation, fetch patterns, auth, SSR, composables, background tasks, and real-time features.",
                "path": "skills/nuxt-nitro-api/SKILL.md",
                "frontmatter": {
                  "name": "nuxt-nitro-api",
                  "description": "Build type-safe Nuxt 3 applications with Nitro API patterns. Covers validation, fetch patterns, auth, SSR, composables, background tasks, and real-time features."
                },
                "content": "# Nuxt 3 / Nitro API Patterns\n\nThis skill provides patterns for building type-safe Nuxt 3 applications with Nitro backends.\n\n## When to Use This Skill\n\nUse this skill when:\n- Working in a Nuxt 3 project with TypeScript\n- Building API endpoints with Nitro\n- Implementing authentication with nuxt-auth-utils\n- Handling SSR + client-side state\n- Creating background tasks or real-time features\n\n## Reference Files\n\nFor detailed patterns, see these topic-focused reference files:\n\n- [validation.md](./validation.md) - Zod validation with h3, Standard Schema, error handling\n- [fetch-patterns.md](./fetch-patterns.md) - useFetch vs $fetch vs useAsyncData\n- [auth-patterns.md](./auth-patterns.md) - nuxt-auth-utils, OAuth, WebAuthn, middleware\n- [page-structure.md](./page-structure.md) - Keep pages thin, components do the work\n- [composables-utils.md](./composables-utils.md) - When to use composables vs utils\n- [ssr-client.md](./ssr-client.md) - SSR + localStorage, hydration, VueUse\n- [deep-linking.md](./deep-linking.md) - URL params sync with filters and useFetch\n- [nitro-tasks.md](./nitro-tasks.md) - Background jobs, scheduled tasks, job queues\n- [sse.md](./sse.md) - Server-Sent Events for real-time streaming\n- [server-services.md](./server-services.md) - Third-party service integration patterns\n\n## Example Files\n\nWorking examples from a Nuxt project:\n\n- [validation-endpoint.ts](./examples/validation-endpoint.ts) - API endpoint with Zod validation\n- [auth-middleware.ts](./examples/auth-middleware.ts) - Server auth middleware\n- [auth-utils.ts](./examples/auth-utils.ts) - Reusable auth helpers\n- [deep-link-page.vue](./examples/deep-link-page.vue) - URL params sync with filters\n- [sse-endpoint.ts](./examples/sse-endpoint.ts) - SSE streaming endpoint\n- [service-util.ts](./examples/service-util.ts) - Server-side service pattern\n\n## Core Principles\n\n1. **Let Nitro infer types** - Never add manual type params to `$fetch<Type>()` or `useFetch<Type>()`\n2. **Use h3 validation** - `getValidatedQuery()`, `readValidatedBody()` with Zod schemas\n3. **Composables for context, utils for pure functions** - Composables access Nuxt context, utils are pure\n4. **SSR-safe code** - Guard browser APIs with `import.meta.client` or `onMounted`\n5. **Keep pages thin** - Pages = layout + route params + components. Components own data fetching and logic.\n\n## Auto-Imports Quick Reference\n\n### Server-side (`/server` directory)\n\nAll h3 utilities auto-imported:\n- `defineEventHandler`, `createError`, `getQuery`, `getValidatedQuery`\n- `readBody`, `readValidatedBody`, `getRouterParams`, `getValidatedRouterParams`\n- `getCookie`, `setCookie`, `deleteCookie`, `getHeader`, `setHeader`\n\nFrom nuxt-auth-utils:\n- `getUserSession`, `setUserSession`, `clearUserSession`, `requireUserSession`\n- `hashPassword`, `verifyPassword`\n- `defineOAuth*EventHandler` (Google, GitHub, etc.)\n\n**Need to import:** `z` from \"zod\", `fromZodError` from \"zod-validation-error\"\n\n### Client-side\n\nAll auto-imported:\n- Vue: `ref`, `computed`, `watch`, `onMounted`, etc.\n- VueUse: `refDebounced`, `useLocalStorage`, `useUrlSearchParams`, etc.\n- Nuxt: `useFetch`, `useAsyncData`, `useRoute`, `useRouter`, `useState`, `navigateTo`\n\n### Shared (`/shared` directory - Nuxt 3.14+)\n\nCode auto-imported on both client AND server. Use for:\n- Types and interfaces\n- Pure utility functions\n- Constants\n\n## Quick Patterns\n\n### Validation (h3 v2+ with Standard Schema)\n\n```typescript\n// Pass Zod schema directly (h3 v2+)\nconst query = await getValidatedQuery(event, z.object({\n  search: z.string().optional(),\n  page: z.coerce.number().default(1),\n}));\n\nconst body = await readValidatedBody(event, z.object({\n  email: z.string().email(),\n  name: z.string().min(1),\n}));\n```\n\n### $fetch Type Inference\n\n```typescript\n// Template literals preserve type inference (fixed late 2024)\nconst userId = \"123\";  // Literal type \"123\"\nconst result = await $fetch(`/api/users/${userId}`);\n// result is typed from the handler's return type\n\n// NEVER do this - defeats type inference\nconst result = await $fetch<User>(\"/api/users/123\");  // WRONG\n```\n\n### useFetch for Page Data\n\n```typescript\n// Basic - types inferred from Nitro\nconst { data, status, refresh } = await useFetch(\"/api/users\");\n\n// Reactive query params - auto-refetch on change\nconst search = ref(\"\");\nconst debouncedSearch = refDebounced(search, 300);  // Auto-imported\nconst { data } = await useFetch(\"/api/users\", {\n  query: computed(() => ({\n    ...(debouncedSearch.value ? { search: debouncedSearch.value } : {}),\n  })),\n});\n\n// Dynamic URL with getter\nconst userId = ref(\"123\");\nconst { data } = await useFetch(() => `/api/users/${userId.value}`);\n\n// New options (Nuxt 3.14+)\nconst { data } = await useFetch(\"/api/data\", {\n  retry: 3,          // Retry on failure\n  retryDelay: 1000,  // Wait between retries\n  dedupe: \"cancel\",  // Cancel previous request\n  delay: 300,        // Debounce the request\n});\n```\n\n### $fetch for Event Handlers\n\n```typescript\n// ONLY use $fetch in event handlers (onClick, onSubmit)\nconst handleSubmit = async () => {\n  const result = await $fetch(\"/api/users\", {\n    method: \"POST\",\n    body: { name: \"Test\" },\n  });\n};\n```\n\n### Auth Check in API\n\n```typescript\n// In server/utils/auth.ts\nexport async function getAuthenticatedUser(event: H3Event) {\n  const session = await getUserSession(event);\n  if (!session?.user) {\n    throw createError({ statusCode: 401, statusMessage: \"Unauthorized\" });\n  }\n  return session.user;\n}\n\n// In API handler\nexport default defineEventHandler(async (event) => {\n  const user = await getAuthenticatedUser(event);\n  // user is typed and guaranteed to exist\n});\n```\n\n### SSR-Safe localStorage\n\n```typescript\n// Option 1: import.meta.client guard\nwatch(preference, (value) => {\n  if (import.meta.client) {\n    localStorage.setItem(\"pref\", value);\n  }\n});\n\n// Option 2: onMounted\nonMounted(() => {\n  const saved = localStorage.getItem(\"pref\");\n  if (saved) preference.value = saved;\n});\n\n// Option 3: VueUse (SSR-safe)\nconst theme = useLocalStorage(\"theme\", \"light\");\n```\n\n### Composable vs Util Decision\n\n```\nNeeds Nuxt/Vue context (useRuntimeConfig, useRoute, refs)?\n├─ YES → COMPOSABLE in /composables/use*.ts\n└─ NO → UTIL in /utils/*.ts (client) or /server/utils/*.ts (server)\n```\n\n## Key Gotchas\n\n1. **Don't use `$fetch` at top level** - Causes double-fetch (SSR + client). Use `useFetch`.\n2. **Debounce search inputs** - Use `refDebounced` to avoid excessive API calls.\n3. **Reset pagination on filter change** - Or users see empty page 5 with new filters.\n4. **Guard browser APIs** - Use `import.meta.client`, `onMounted`, or `<ClientOnly>`.\n5. **Nitro tasks are single-instance** - Can't run same task twice concurrently. Use DB job queue.\n6. **useRouteQuery needs Nuxt composables** - Pass `route` and `router` explicitly.\n7. **Input types aren't auto-generated** - Export Zod schemas for client use.\n8. **Cookie size limit is 4096 bytes** - Store only essential session data."
              }
            ]
          },
          {
            "name": "kysely-postgres",
            "description": "Type-safe Kysely query patterns for PostgreSQL",
            "source": "./skills/kysely-postgres",
            "category": null,
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gallop-systems/claude-skills",
              "/plugin install kysely-postgres@gallop-systems-claude-skills"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-04T00:23:42Z",
              "created_at": "2026-01-02T19:34:22Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "kysely-postgres",
                "description": "Write effective, type-safe Kysely queries for PostgreSQL. This skill should be used when working in Node.js/TypeScript backends with Kysely installed, covering query patterns, migrations, type generation, and common pitfalls to avoid.",
                "path": "skills/kysely-postgres/SKILL.md",
                "frontmatter": {
                  "name": "kysely-postgres",
                  "description": "Write effective, type-safe Kysely queries for PostgreSQL. This skill should be used when working in Node.js/TypeScript backends with Kysely installed, covering query patterns, migrations, type generation, and common pitfalls to avoid."
                },
                "content": "# Kysely for PostgreSQL\n\nKysely is a type-safe TypeScript SQL query builder. This skill provides patterns for writing effective queries, managing migrations, and avoiding common pitfalls.\n\n## When to Use This Skill\n\nUse this skill when:\n- Working in a Node.js/TypeScript project with Kysely installed\n- Writing database queries for PostgreSQL\n- Creating or modifying database migrations\n- Debugging type inference issues in Kysely queries\n\n## Reference Files\n\nFor detailed examples, see these topic-focused reference files:\n\n- [select-where.ts](references/select-where.ts) - Basic SELECT patterns, WHERE clauses, AND/OR conditions\n- [joins.ts](references/joins.ts) - Simple joins, callback joins, subquery joins, cross joins\n- [aggregations.ts](references/aggregations.ts) - COUNT, SUM, AVG, GROUP BY, HAVING\n- [orderby-pagination.ts](references/orderby-pagination.ts) - ORDER BY, NULLS handling, DISTINCT, pagination\n- [ctes.ts](references/ctes.ts) - Common Table Expressions, multiple CTEs, recursive CTEs\n- [json-arrays.ts](references/json-arrays.ts) - JSONB handling, array columns, jsonBuildObject, jsonAgg\n- [relations.ts](references/relations.ts) - jsonArrayFrom, jsonObjectFrom for nested data\n- [mutations.ts](references/mutations.ts) - INSERT, UPDATE, DELETE, UPSERT, INSERT FROM SELECT\n- [expressions.ts](references/expressions.ts) - CASE, $if, subqueries, eb.val/lit/not, standalone expressionBuilder\n\n## Core Principles\n\n1. **Prefer Kysely methods over raw SQL**: Almost everything you can do in SQL, you can do in Kysely without `sql``\n2. **Use the ExpressionBuilder (eb)**: The `eb` parameter in callbacks is the foundation of type-safe query building\n3. **Let TypeScript guide you**: If it compiles, it's likely correct SQL\n\n## ExpressionBuilder (eb) - The Foundation\n\nThe `eb` parameter in select/where callbacks provides all expression methods:\n\n```typescript\n.select((eb) => [\n  eb.ref(\"column\").as(\"alias\"),                    // Column reference\n  eb.fn<string>(\"upper\", [eb.ref(\"email\")]),       // Function call (typed!)\n  eb.fn.count(\"id\").as(\"count\"),                   // Aggregate function\n  eb.fn.sum(\"amount\").as(\"total\"),                 // SUM\n  eb.fn.avg(\"rating\").as(\"avgRating\"),             // AVG\n  eb.fn.coalesce(\"nullable_col\", eb.val(0)),       // COALESCE\n  eb.case().when(\"status\", \"=\", \"active\")          // CASE expression\n    .then(\"Active\").else(\"Inactive\").end(),\n  eb(\"quantity\", \"*\", eb.ref(\"unit_price\")),       // Binary expression\n  eb.exists(subquery),                             // EXISTS\n  eb.not(expression),                              // NOT / negation\n  eb.cast(eb.val(\" \"), \"text\"),                    // Cast value to type\n  eb.and([...]),                                   // AND conditions\n  eb.or([...]),                                    // OR conditions\n])\n```\n\n### eb.val() vs eb.lit()\n\n```typescript\n// eb.val() - Creates a parameterized value ($1, $2, etc.) - PREFERRED for user input\n// Note: eb.val() alone may fail with \"could not determine data type of parameter\"\n// Use eb.cast(eb.val(...), \"text\") for string values in function arguments\neb.val(\"user input\")                    // Becomes: $1 with parameter \"user input\"\neb.cast(eb.val(\"safe\"), \"text\")         // Becomes: $1::text - always works\n\n// eb.lit() - Creates a literal value in SQL\n// ONLY accepts: numbers, booleans, null - NOT strings (throws \"unsafe immediate value\")\neb.lit(1)             // Becomes: 1 (directly in SQL)\neb.lit(true)          // Becomes: true\neb.lit(null)          // Becomes: NULL\n\n// For string literals, use sql`` template instead\nsql`'active'`         // Becomes: 'active' (directly in SQL)\nsql<string>`'label'`  // Typed string literal\n```\n\n### Standalone ExpressionBuilder\n\nFor reusable helpers outside query callbacks:\n\n```typescript\nimport { expressionBuilder } from \"kysely\";\nimport type { DB } from \"./db.d.ts\";\n\n// Create standalone expression builder\nconst eb = expressionBuilder<DB, \"user\">();\n\n// Use in helper functions\nfunction isActiveUser() {\n  return eb.and([\n    eb(\"is_active\", \"=\", true),\n    eb(\"role\", \"!=\", \"banned\"),\n  ]);\n}\n```\n\n### Conditional Expressions with Arrays\n\nBuild dynamic filters by collecting expressions:\n\n```typescript\n.where((eb) => {\n  const filters: Expression<SqlBool>[] = [];\n\n  if (firstName) filters.push(eb(\"first_name\", \"=\", firstName));\n  if (lastName) filters.push(eb(\"last_name\", \"=\", lastName));\n  if (minAge) filters.push(eb(\"age\", \">=\", minAge));\n\n  // Combine all filters with AND (empty array = no filter)\n  return eb.and(filters);\n})\n```\n\n## String Concatenation\n\nUse the `||` operator with `sql` template for clean string concatenation:\n\n```typescript\n// RECOMMENDED - Clean and type-safe with eb.ref()\n.select((eb) => [\n  sql<string>`${eb.ref(\"first_name\")} || ' ' || ${eb.ref(\"last_name\")}`.as(\"full_name\"),\n])\n// Output: \"first_name\" || ' ' || \"last_name\"\n\n// ALTERNATIVE - Pure eb() chaining (parameterized literals)\n.select((eb) => [\n  eb(eb(\"first_name\", \"||\", \" \"), \"||\", eb.ref(\"last_name\")).as(\"full_name\"),\n])\n// Output: \"first_name\" || $1 || \"last_name\"\n\n// VERBOSE - concat() function (avoid unless you need NULL handling)\n.select((eb) => [\n  eb.fn<string>(\"concat\", [\n    eb.ref(\"first_name\"),\n    eb.cast(eb.val(\" \"), \"text\"),\n    eb.ref(\"last_name\"),\n  ]).as(\"full_name\"),\n])\n```\n\n**Note**: `concat()` treats NULL as empty string, while `||` propagates NULL. Use `concat()` only when you need that NULL behavior.\n\n## Query Patterns\n\n### Basic SELECT\n\n```typescript\n// Select all columns\nconst users = await db.selectFrom(\"user\").selectAll().execute();\n\n// Select specific columns with aliases\nconst users = await db\n  .selectFrom(\"user\")\n  .select([\"id\", \"email\", \"first_name as firstName\"])\n  .execute();\n\n// Single row (returns T | undefined)\nconst user = await db.selectFrom(\"user\").selectAll()\n  .where(\"id\", \"=\", userId).executeTakeFirst();\n\n// Single row that must exist (throws if not found)\nconst user = await db.selectFrom(\"user\").selectAll()\n  .where(\"id\", \"=\", userId).executeTakeFirstOrThrow();\n```\n\n### WHERE Clauses\n\n```typescript\n// Equality, comparison, IN, LIKE\n.where(\"status\", \"=\", \"active\")\n.where(\"price\", \">\", 100)\n.where(\"role\", \"in\", [\"admin\", \"manager\"])\n.where(\"name\", \"like\", \"%search%\")\n.where(\"deleted_at\", \"is\", null)\n\n// Multiple conditions (chained = AND)\n.where(\"is_active\", \"=\", true)\n.where(\"role\", \"=\", \"admin\")\n\n// OR conditions\n.where((eb) => eb.or([\n  eb(\"role\", \"=\", \"admin\"),\n  eb(\"role\", \"=\", \"manager\"),\n]))\n\n// Complex AND/OR\n.where((eb) => eb.and([\n  eb(\"is_active\", \"=\", true),\n  eb.or([\n    eb(\"price\", \"<\", 50),\n    eb(\"stock\", \">\", 100),\n  ]),\n]))\n```\n\n### JOINs\n\n```typescript\n// Inner join\n.innerJoin(\"order\", \"order.user_id\", \"user.id\")\n\n// Left join\n.leftJoin(\"category\", \"category.id\", \"product.category_id\")\n\n// Self-join with alias\n.selectFrom(\"category as c\")\n.leftJoin(\"category as parent\", \"parent.id\", \"c.parent_id\")\n\n// Multiple joins\n.innerJoin(\"order\", \"order.id\", \"order_item.order_id\")\n.innerJoin(\"product\", \"product.id\", \"order_item.product_id\")\n.innerJoin(\"user\", \"user.id\", \"order.user_id\")\n```\n\n### Complex JOINs (Callback Format)\n\nUse the callback format when you need:\n- Multiple join conditions (composite keys)\n- Mixed column-to-column and column-to-literal comparisons\n- OR conditions within joins\n- Subquery joins (derived tables)\n\n**Join Builder Methods:**\n- `onRef(col1, op, col2)` - Column-to-column comparison\n- `on(col, op, value)` - Column-to-literal comparison\n- `on((eb) => ...)` - Complex expressions with OR logic\n\n```typescript\n// Multi-condition join (composite key + filter)\n.leftJoin(\"invoice as i\", (join) =>\n  join\n    .onRef(\"sp.service_provider_id\", \"=\", \"i.service_provider_id\")\n    .onRef(\"sp.year\", \"=\", \"i.year\")\n    .onRef(\"sp.month\", \"=\", \"i.month\")\n    .on(\"i.status\", \"!=\", \"invalidated\")\n)\n\n// Join with OR conditions\n.leftJoin(\"order as o\", (join) =>\n  join\n    .onRef(\"o.user_id\", \"=\", \"u.id\")\n    .on((eb) =>\n      eb.or([\n        eb(\"o.status\", \"=\", \"completed\"),\n        eb(\"o.status\", \"=\", \"shipped\"),\n      ])\n    )\n)\n\n// Subquery join (derived table) - two callbacks\n.leftJoin(\n  (eb) =>\n    eb\n      .selectFrom(\"order\")\n      .select((eb) => [\n        \"user_id\",\n        eb.fn.count(\"id\").as(\"order_count\"),\n        eb.fn.max(\"created_at\").as(\"last_order_at\"),\n      ])\n      .groupBy(\"user_id\")\n      .as(\"order_stats\"),  // MUST have alias!\n  (join) => join.onRef(\"order_stats.user_id\", \"=\", \"u.id\")\n)\n\n// Cross join (always-true condition) - for joining aggregated CTEs\n.leftJoin(\"summary_cte\", (join) =>\n  join.on(sql`true`, \"=\", sql`true`)\n)\n```\n\n### Aggregations\n\n```typescript\n.select((eb) => [\n  \"status\",\n  eb.fn.count(\"id\").as(\"count\"),\n  eb.fn.sum(\"total_amount\").as(\"totalAmount\"),\n  eb.fn.avg(\"total_amount\").as(\"avgAmount\"),\n])\n.groupBy(\"status\")\n.having((eb) => eb.fn.count(\"id\"), \">\", 5)\n```\n\n### ORDER BY\n\n```typescript\n// Simple ordering\n.orderBy(\"created_at\", \"desc\")\n.orderBy(\"name\", \"asc\")\n\n// NULLS FIRST / NULLS LAST - use order builder callback\n.orderBy(\"category_id\", (ob) => ob.asc().nullsLast())\n.orderBy(\"priority\", (ob) => ob.desc().nullsFirst())\n\n// Multiple columns - chain orderBy calls (array syntax is deprecated)\n.orderBy(\"category_id\", \"asc\")\n.orderBy(\"price\", \"desc\")\n.orderBy(\"name\", \"asc\")\n```\n\n### CTEs (Common Table Expressions)\n\nUse CTEs for complex queries with multiple aggregation levels:\n\n```typescript\nconst result = await db\n  .with(\"order_totals\", (db) =>\n    db.selectFrom(\"order\")\n      .innerJoin(\"user\", \"user.id\", \"order.user_id\")\n      .select((eb) => [\n        \"user.id as userId\",\n        \"user.email\",\n        eb.fn.sum(\"order.total_amount\").as(\"totalSpent\"),\n        eb.fn.count(\"order.id\").as(\"orderCount\"),\n      ])\n      .groupBy([\"user.id\", \"user.email\"])\n  )\n  .selectFrom(\"order_totals\")\n  .selectAll()\n  .orderBy(\"totalSpent\", \"desc\")\n  .execute();\n```\n\n### JSON Aggregation (PostgreSQL)\n\n```typescript\nimport { jsonBuildObject } from \"kysely/helpers/postgres\";\n// Note: jsonAgg is accessed via eb.fn.jsonAgg(), not imported\n\n.with(\"tasks\", (db) =>\n  db.selectFrom(\"task\")\n    .leftJoin(\"user\", \"user.id\", \"task.assignee_id\")\n    .select((eb) => [\n      \"task.job_id\",\n      eb.fn.jsonAgg(\n        jsonBuildObject({\n          id: eb.ref(\"task.id\"),\n          status: eb.ref(\"task.status\"),\n          assignee: jsonBuildObject({\n            id: eb.ref(\"user.id\"),\n            name: eb.fn<string>(\"concat\", [\n              eb.ref(\"user.first_name\"),\n              eb.cast(eb.val(\" \"), \"text\"),\n              eb.ref(\"user.last_name\"),\n            ]),\n          }),\n        })\n      )\n      .filterWhere(\"task.id\", \"is not\", null) // Filter nulls from left join\n      .as(\"tasks\"),\n    ])\n    .groupBy(\"task.job_id\")\n)\n```\n\n## JSON, JSONB, and Array Handling\n\n### JSONB Columns\n\n**NO `JSON.stringify` or `JSON.parse` needed!** The `pg` driver handles JSONB automatically:\n\n```typescript\n// INSERT - pass objects directly\nawait db\n  .insertInto(\"user\")\n  .values({\n    email: \"test@example.com\",\n    metadata: { preferences: { theme: \"dark\" }, count: 42 },\n  })\n  .execute();\n\n// UPDATE - pass objects directly\nawait db\n  .updateTable(\"user\")\n  .set({\n    metadata: { preferences: { theme: \"light\" } },\n  })\n  .where(\"id\", \"=\", userId)\n  .execute();\n\n// READ - returns parsed object, not string\nconst user = await db\n  .selectFrom(\"user\")\n  .select([\"id\", \"metadata\"])\n  .executeTakeFirst();\nconsole.log(user.metadata.preferences.theme); // \"dark\" - already an object!\n```\n\n### Array Columns (text[], int[], etc.)\n\n**NO `JSON.stringify` needed for array columns!** The `pg` driver handles arrays natively:\n\n```typescript\n// INSERT with array - pass array directly\nawait db\n  .insertInto(\"product\")\n  .values({\n    name: \"Product\",\n    tags: [\"phone\", \"electronics\", \"premium\"], // Direct array!\n  })\n  .execute();\n\n// READ - returns as native JavaScript array\nconst product = await db\n  .selectFrom(\"product\")\n  .select([\"name\", \"tags\"])\n  .executeTakeFirst();\nconsole.log(product.tags); // [\"phone\", \"electronics\", \"premium\"]\n\n// UPDATE array\nawait db\n  .updateTable(\"product\")\n  .set({ tags: [\"updated\", \"tags\"] })\n  .where(\"id\", \"=\", productId)\n  .execute();\n```\n\n### Querying Arrays\n\n```typescript\n// Array contains all values (@>) - operator works natively!\n.where(\"tags\", \"@>\", sql`ARRAY['phone', 'premium']::text[]`)\n\n// Arrays overlap (&&) - operator works natively!\n.where(\"tags\", \"&&\", sql`ARRAY['premium', 'basic']::text[]`)\n\n// Array contains value (ANY) - type-safe with eb.fn\n.where((eb) => eb(sql`${searchTerm}`, \"=\", eb.fn(\"any\", [eb.ref(\"tags\")])))\n// eb.ref(\"tags\") validates column exists - eb.ref(\"invalid\") would be a TS error\n```\n\n### Querying JSONB\n\n```typescript\n// Key exists (?) - operator works natively!\n.where(\"metadata\", \"?\", \"theme\")\n\n// Any key exists (?|) - operator works natively!\n.where(\"metadata\", \"?|\", sql`array['theme', 'language']`)\n\n// All keys exist (?&) - operator works natively!\n.where(\"metadata\", \"?&\", sql`array['theme', 'notifications']`)\n\n// JSONB contains (@>) - operator works natively!\n.where(\"metadata\", \"@>\", sql`'{\"notifications\": true}'::jsonb`)\n\n// Extract field as text (->> as operator) - type-safe!\n.where((eb) => eb(eb(\"metadata\", \"->>\", \"theme\"), \"=\", \"dark\"))\n// eb(\"metadata\", ...) validates column - eb(\"invalid\", ...) would be TS error\n\n// Extract nested path (#>> still needs sql``)\n.where(sql`metadata#>>'{preferences,theme}'`, \"=\", \"dark\")\n\n// In SELECT - type-safe with eb()\n.select((eb) => [\n  eb(\"metadata\", \"->\", \"preferences\").as(\"prefs\"),   // Returns JSONB\n  eb(\"metadata\", \"->>\", \"theme\").as(\"theme\"),        // Returns text\n])\n// Nested paths still need sql``\n.select(sql`metadata#>'{preferences,theme}'`.as(\"t\"))   // Nested as JSONB\n.select(sql<string>`metadata#>>'{a,b}'`.as(\"t\"))        // Nested as text\n```\n\n### JSONPath (PostgreSQL 12+)\n\n```typescript\n// JSONPath match (@@) - works as native operator!\n.where(\"metadata\", \"@@\", sql`'$.preferences.theme == \"dark\"'`)\n\n// JSONPath exists (@?) - NOT in Kysely's allowlist, use function instead\n// Use jsonb_path_exists() for type-safe column validation\n.where((eb) =>\n  eb.fn(\"jsonb_path_exists\", [eb.ref(\"metadata\"), sql`'$.preferences.theme'`])\n)\n// eb.ref(\"metadata\") validates column - eb.ref(\"invalid\") would be TS error\n\n// Extract with JSONPath - type-safe with eb.fn\n.select((eb) => [\n  \"id\",\n  eb.fn(\"jsonb_path_query_first\", [eb.ref(\"metadata\"), sql`'$.preferences.theme'`]).as(\"theme\"),\n])\n\n// JSONPath with variables\nconst searchValue = \"dark\";\n.where((eb) =>\n  eb.fn(\"jsonb_path_exists\", [\n    eb.ref(\"metadata\"),\n    sql`'$.preferences.theme ? (@ == $val)'`,\n    sql`jsonb_build_object('val', ${searchValue}::text)`,\n  ])\n)\n```\n\n### Conditional Queries ($if)\n\nUse `$if()` for runtime-conditional query modifications:\n\n```typescript\nconst result = await db\n  .selectFrom(\"user\")\n  .selectAll()\n  .$if(!includeInactive, (qb) => qb.where(\"is_active\", \"=\", true))\n  .$if(includeMetadata, (qb) => qb.select(\"metadata\"))\n  .$if(!!searchTerm, (qb) => qb.where(\"name\", \"like\", `%${searchTerm}%`))\n  .$if(!!roleFilter, (qb) => qb.where(\"role\", \"in\", roleFilter!))\n  .execute();\n```\n\n**Type behavior**: Columns added via `$if` become optional in the result type since inclusion isn't guaranteed at compile time.\n\n### Relations (jsonArrayFrom / jsonObjectFrom)\n\nKysely is NOT an ORM - it uses PostgreSQL's JSON functions for nested data:\n\n```typescript\nimport { jsonArrayFrom, jsonObjectFrom } from \"kysely/helpers/postgres\";\n\n// One-to-many: User with their orders\nconst users = await db\n  .selectFrom(\"user\")\n  .select((eb) => [\n    \"user.id\",\n    \"user.email\",\n    jsonArrayFrom(\n      eb\n        .selectFrom(\"order\")\n        .select([\"order.id\", \"order.status\", \"order.total_amount\"])\n        .whereRef(\"order.user_id\", \"=\", \"user.id\")\n        .orderBy(\"order.created_at\", \"desc\")\n    ).as(\"orders\"),\n  ])\n  .execute();\n\n// Many-to-one: Product with its category\nconst products = await db\n  .selectFrom(\"product\")\n  .select((eb) => [\n    \"product.id\",\n    \"product.name\",\n    jsonObjectFrom(\n      eb\n        .selectFrom(\"category\")\n        .select([\"category.id\", \"category.name\"])\n        .whereRef(\"category.id\", \"=\", \"product.category_id\")\n    ).as(\"category\"),\n  ])\n  .execute();\n```\n\n### Reusable Helpers\n\nCreate composable, type-safe helper functions using `Expression<T>`:\n\n```typescript\nimport { Expression, sql } from \"kysely\";\n\n// Helper that takes and returns Expression<string>\nfunction lower(expr: Expression<string>) {\n  return sql<string>`lower(${expr})`;\n}\n\n// Use in queries\n.where(({ eb, ref }) => eb(lower(ref(\"email\")), \"=\", email.toLowerCase()))\n```\n\n### Splitting Query Building and Execution\n\nBuild queries without executing, useful for dynamic query construction:\n\n```typescript\n// Build query (doesn't execute)\nlet query = db\n  .selectFrom(\"user\")\n  .select([\"id\", \"email\"]);\n\n// Add conditions dynamically\nif (role) {\n  query = query.where(\"role\", \"=\", role);\n}\nif (isActive !== undefined) {\n  query = query.where(\"is_active\", \"=\", isActive);\n}\n\n// Execute when ready\nconst results = await query.execute();\n\n// Or compile to SQL without executing\nconst compiled = query.compile();\nconsole.log(compiled.sql);        // The SQL string\nconsole.log(compiled.parameters); // Bound parameters\n```\n\n### Subqueries\n\n```typescript\n// Subquery in WHERE\n.where(\"id\", \"in\",\n  db.selectFrom(\"order\").select(\"user_id\").where(\"status\", \"=\", \"completed\")\n)\n\n// EXISTS subquery\n.where((eb) =>\n  eb.exists(\n    db.selectFrom(\"review\")\n      .select(sql`1`.as(\"one\"))\n      .whereRef(\"review.product_id\", \"=\", eb.ref(\"product.id\"))\n  )\n)\n```\n\n### INSERT Operations\n\n```typescript\n// Single insert with returning\nconst user = await db\n  .insertInto(\"user\")\n  .values({ email: \"test@example.com\", first_name: \"Test\", last_name: \"User\" })\n  .returning([\"id\", \"email\"])\n  .executeTakeFirst();\n\n// Multiple rows\nawait db\n  .insertInto(\"user\")\n  .values([\n    { email: \"a@example.com\", first_name: \"A\", last_name: \"User\" },\n    { email: \"b@example.com\", first_name: \"B\", last_name: \"User\" },\n  ])\n  .execute();\n\n// Upsert (ON CONFLICT) - type-safe with expression builder\nawait db\n  .insertInto(\"product\")\n  .values({ sku: \"ABC123\", name: \"Product\", stock_quantity: 10 })\n  .onConflict((oc) =>\n    oc.column(\"sku\").doUpdateSet((eb) => ({\n      stock_quantity: eb(\"product.stock_quantity\", \"+\", eb.ref(\"excluded.stock_quantity\")),\n    }))\n  )\n  .execute();\n// eb(\"product.invalid_column\", ...) would be a TypeScript error!\n\n// Insert from SELECT\nawait db\n  .insertInto(\"archive\")\n  .columns([\"user_id\", \"data\", \"archived_at\"])\n  .expression(\n    db.selectFrom(\"user\")\n      .select([\"id\", \"metadata\", sql`now()`.as(\"archived_at\")])\n      .where(\"is_active\", \"=\", false)\n  )\n  .execute();\n```\n\n### UPDATE Operations\n\n```typescript\n// Simple update\nawait db\n  .updateTable(\"user\")\n  .set({ is_active: false })\n  .where(\"id\", \"=\", userId)\n  .execute();\n\n// Update with expression\nawait db\n  .updateTable(\"product\")\n  .set((eb) => ({\n    stock_quantity: eb(\"stock_quantity\", \"+\", 10),\n  }))\n  .where(\"sku\", \"=\", \"ABC123\")\n  .returning([\"id\", \"stock_quantity\"])\n  .executeTakeFirst();\n```\n\n## Migrations\n\n### Configuration (kysely.config.ts)\n\n```typescript\nimport { PostgresDialect } from \"kysely\";\nimport { defineConfig } from \"kysely-ctl\";\nimport pg from \"pg\";\n\nexport default defineConfig({\n  dialect: new PostgresDialect({\n    pool: new pg.Pool({\n      connectionString: process.env.DATABASE_URL,\n    }),\n  }),\n  migrations: {\n    migrationFolder: \"src/db/migrations\",\n  },\n  seeds: {\n    seedFolder: \"src/db/seeds\",\n  },\n});\n```\n\n### Migration Commands\n\n```bash\nnpx kysely migrate:make migration-name  # Create migration\nnpx kysely migrate:latest               # Run all pending migrations\nnpx kysely migrate:down                 # Rollback last migration\nnpx kysely seed make seed-name          # Create seed\nnpx kysely seed run                     # Run all seeds\n```\n\n### Migration File Structure\n\n```typescript\nimport type { Kysely } from \"kysely\";\nimport { sql } from \"kysely\";\n\n// Always use Kysely<any> - migrations should be frozen in time\nexport async function up(db: Kysely<any>): Promise<void> {\n  await db.schema\n    .createTable(\"user\")\n    .addColumn(\"id\", \"bigint\", (col) => col.primaryKey().generatedAlwaysAsIdentity())\n    .addColumn(\"email\", \"text\", (col) => col.notNull().unique())\n    .addColumn(\"created_at\", \"timestamptz\", (col) => col.notNull().defaultTo(sql`now()`))\n    .execute();\n\n  // IMPORTANT: Always index foreign key columns!\n  await db.schema.createIndex(\"idx_order_user_id\").on(\"order\").column(\"user_id\").execute();\n}\n\nexport async function down(db: Kysely<any>): Promise<void> {\n  await db.schema.dropTable(\"user\").execute();\n}\n```\n\n### Recommended Column Types\n\n```typescript\n// Primary keys: Use identity columns (SQL standard, prevents accidental ID conflicts)\n.addColumn(\"id\", \"bigint\", (col) => col.primaryKey().generatedAlwaysAsIdentity())\n// NOT serial/bigserial - those allow manual ID inserts that can cause conflicts\n\n// Timestamps: Always use timestamptz (stores UTC, converts to client timezone)\n.addColumn(\"created_at\", \"timestamptz\", (col) => col.notNull().defaultTo(sql`now()`))\n// NOT timestamp - loses timezone information\n\n// Money: Use numeric with precision (exact decimal, no floating point errors)\n.addColumn(\"price\", \"numeric(10, 2)\", (col) => col.notNull())\n// NOT float/real/double precision - those have rounding errors\n\n// Strings: Use text (no length limit, same performance as varchar)\n.addColumn(\"name\", \"text\", (col) => col.notNull())\n// varchar(n) only if you need a hard length constraint\n\n// JSON: Use jsonb (binary, indexable, faster queries)\n.addColumn(\"metadata\", \"jsonb\")\n// NOT json - stored as text, no indexing, slower\n\n// Foreign keys: Create indexes manually (PostgreSQL doesn't auto-index FKs)\nawait db.schema.createIndex(\"idx_order_user_id\").on(\"order\").column(\"user_id\").execute();\n```\n\n### Data Type Gotchas\n\n```typescript\n// CORRECT - Space after comma in numeric types\n.addColumn(\"price\", \"numeric(10, 2)\")\n\n// WRONG - Will fail with \"invalid column data type\"\n.addColumn(\"price\", \"numeric(10,2)\")\n\n// For complex types, use sql template\n.addColumn(\"price\", sql`numeric(10, 2)`)\n```\n\n## Type Generation\n\nUse `kysely-codegen` to generate types from your database:\n\n```bash\nnpx kysely-codegen --url \"postgresql://...\" --out-file src/db/db.d.ts\n```\n\nGenerated types use:\n- `Generated<T>` for auto-increment columns (optional on insert)\n- `ColumnType<Select, Insert, Update>` for different operation types\n- `Timestamp` for timestamptz columns\n\n## Common Pitfalls to Avoid\n\n### 1. Don't Resort to `sql`` When Kysely Has a Method\n\n```typescript\n// WRONG\n.select(sql`count(*)`.as(\"count\"))\n\n// RIGHT\n.select((eb) => eb.fn.countAll().as(\"count\"))\n```\n\n### 2. Don't Forget .execute()\n\nQueries are lazy - they won't run without calling an execute method:\n\n```typescript\n// This does nothing!\ndb.selectFrom(\"user\").selectAll();\n\n// This runs the query\nawait db.selectFrom(\"user\").selectAll().execute();\n```\n\n### 3. Use whereRef for Column-to-Column Comparisons\n\n```typescript\n// WRONG - Compares to string literal \"other.column\"\n.where(\"table.column\", \"=\", \"other.column\")\n\n// RIGHT - Compares to actual column value\n.whereRef(\"table.column\", \"=\", \"other.column\")\n```\n\n### 4. Type Your Function Returns\n\n```typescript\n// Better type inference\neb.fn<string>(\"concat\", [...])\neb.fn<number>(\"length\", [...])\n```\n\n### 5. PostgreSQL Does NOT Auto-Index Foreign Keys\n\nAlways create indexes on foreign key columns:\n\n```typescript\nawait db.schema.createIndex(\"idx_order_user_id\").on(\"order\").column(\"user_id\").execute();\n```\n\n## PostgreSQL Helpers Summary\n\nAll helpers from `kysely/helpers/postgres`:\n\n```typescript\nimport {\n  jsonArrayFrom,    // One-to-many relations (subquery → array)\n  jsonObjectFrom,   // Many-to-one relations (subquery → object | null)\n  jsonBuildObject,  // Build JSON object from expressions\n  mergeAction,      // Get action performed in MERGE query (PostgreSQL 15+)\n} from \"kysely/helpers/postgres\";\n```\n\n**Note**: `jsonAgg` is NOT imported - use `eb.fn.jsonAgg()` instead.\n\n### mergeAction (PostgreSQL 15+)\n\nFor MERGE queries, get which action was performed:\n\n```typescript\nimport { mergeAction } from \"kysely/helpers/postgres\";\n\nconst result = await db\n  .mergeInto(\"person\")\n  .using(\"person_updates\", \"person.id\", \"person_updates.id\")\n  .whenMatched()\n  .thenUpdateSet({ name: eb.ref(\"person_updates.name\") })\n  .whenNotMatched()\n  .thenInsertValues({ id: eb.ref(\"person_updates.id\"), name: eb.ref(\"person_updates.name\") })\n  .returning([mergeAction().as(\"action\"), \"id\"])\n  .execute();\n\n// result[0].action is 'INSERT' | 'UPDATE' | 'DELETE'\n```\n\n## Extending Kysely\n\n### Custom Helper Functions\n\nMost extensions use the `sql` template tag with `RawBuilder<T>`:\n\n```typescript\nimport { sql, RawBuilder } from \"kysely\";\n\n// Create a typed helper function\nfunction json<T>(value: T): RawBuilder<T> {\n  return sql`CAST(${JSON.stringify(value)} AS JSONB)`;\n}\n\n// Use in queries\n.select((eb) => [\n  json({ name: \"value\" }).as(\"data\"),\n])\n```\n\n### Custom Expression Classes\n\nFor reusable expressions, implement the `Expression<T>` interface:\n\n```typescript\nimport { Expression, OperationNode, sql } from \"kysely\";\n\nclass JsonValue<T> implements Expression<T> {\n  readonly #value: T;\n\n  constructor(value: T) {\n    this.#value = value;\n  }\n\n  get expressionType(): T | undefined {\n    return undefined;\n  }\n\n  toOperationNode(): OperationNode {\n    return sql`CAST(${JSON.stringify(this.#value)} AS JSONB)`.toOperationNode();\n  }\n}\n```\n\n**Note**: Module augmentation and inheritance-based extension are not recommended.\n\n## Handling \"Excessively Deep Types\" Error\n\n### The Problem\n\nComplex queries with many CTEs can overwhelm TypeScript's type instantiation limits:\n\n```\nType instantiation is excessively deep and possibly infinite\n```\n\nThis commonly occurs with 12+ `with` clauses, as Kysely's nested helper types accumulate.\n\n### The Solution: `$assertType`\n\nUse `$assertType` to simplify the type chain at intermediate points:\n\n```typescript\nconst result = await db\n  .with(\"cte1\", (qb) =>\n    qb.selectFrom(\"user\")\n      .select([\"id\", \"email\"])\n      .$assertType<{ id: number; email: string }>()  // Simplify type here\n  )\n  .with(\"cte2\", (qb) =>\n    qb.selectFrom(\"cte1\")\n      .select(\"email\")\n      .$assertType<{ email: string }>()\n  )\n  // ... more CTEs\n  .selectFrom(\"cteN\")\n  .selectAll()\n  .execute();\n```\n\n**Key points**:\n- The asserted type must structurally match the actual type (full type safety preserved)\n- Apply to several intermediate `with` clauses in large queries\n- TypeScript cannot automatically simplify these types - explicit assertion is required"
              }
            ]
          },
          {
            "name": "nuxt-nitro-api",
            "description": "Nuxt 3 / Nitro API patterns: validation, auth, SSR, tasks, SSE",
            "source": "./skills/nuxt-nitro-api",
            "category": null,
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gallop-systems/claude-skills",
              "/plugin install nuxt-nitro-api@gallop-systems-claude-skills"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-04T00:23:42Z",
              "created_at": "2026-01-02T19:34:22Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "nuxt-nitro-api",
                "description": "Build type-safe Nuxt 3 applications with Nitro API patterns. Covers validation, fetch patterns, auth, SSR, composables, background tasks, and real-time features.",
                "path": "skills/nuxt-nitro-api/SKILL.md",
                "frontmatter": {
                  "name": "nuxt-nitro-api",
                  "description": "Build type-safe Nuxt 3 applications with Nitro API patterns. Covers validation, fetch patterns, auth, SSR, composables, background tasks, and real-time features."
                },
                "content": "# Nuxt 3 / Nitro API Patterns\n\nThis skill provides patterns for building type-safe Nuxt 3 applications with Nitro backends.\n\n## When to Use This Skill\n\nUse this skill when:\n- Working in a Nuxt 3 project with TypeScript\n- Building API endpoints with Nitro\n- Implementing authentication with nuxt-auth-utils\n- Handling SSR + client-side state\n- Creating background tasks or real-time features\n\n## Reference Files\n\nFor detailed patterns, see these topic-focused reference files:\n\n- [validation.md](./validation.md) - Zod validation with h3, Standard Schema, error handling\n- [fetch-patterns.md](./fetch-patterns.md) - useFetch vs $fetch vs useAsyncData\n- [auth-patterns.md](./auth-patterns.md) - nuxt-auth-utils, OAuth, WebAuthn, middleware\n- [page-structure.md](./page-structure.md) - Keep pages thin, components do the work\n- [composables-utils.md](./composables-utils.md) - When to use composables vs utils\n- [ssr-client.md](./ssr-client.md) - SSR + localStorage, hydration, VueUse\n- [deep-linking.md](./deep-linking.md) - URL params sync with filters and useFetch\n- [nitro-tasks.md](./nitro-tasks.md) - Background jobs, scheduled tasks, job queues\n- [sse.md](./sse.md) - Server-Sent Events for real-time streaming\n- [server-services.md](./server-services.md) - Third-party service integration patterns\n\n## Example Files\n\nWorking examples from a Nuxt project:\n\n- [validation-endpoint.ts](./examples/validation-endpoint.ts) - API endpoint with Zod validation\n- [auth-middleware.ts](./examples/auth-middleware.ts) - Server auth middleware\n- [auth-utils.ts](./examples/auth-utils.ts) - Reusable auth helpers\n- [deep-link-page.vue](./examples/deep-link-page.vue) - URL params sync with filters\n- [sse-endpoint.ts](./examples/sse-endpoint.ts) - SSE streaming endpoint\n- [service-util.ts](./examples/service-util.ts) - Server-side service pattern\n\n## Core Principles\n\n1. **Let Nitro infer types** - Never add manual type params to `$fetch<Type>()` or `useFetch<Type>()`\n2. **Use h3 validation** - `getValidatedQuery()`, `readValidatedBody()` with Zod schemas\n3. **Composables for context, utils for pure functions** - Composables access Nuxt context, utils are pure\n4. **SSR-safe code** - Guard browser APIs with `import.meta.client` or `onMounted`\n5. **Keep pages thin** - Pages = layout + route params + components. Components own data fetching and logic.\n\n## Auto-Imports Quick Reference\n\n### Server-side (`/server` directory)\n\nAll h3 utilities auto-imported:\n- `defineEventHandler`, `createError`, `getQuery`, `getValidatedQuery`\n- `readBody`, `readValidatedBody`, `getRouterParams`, `getValidatedRouterParams`\n- `getCookie`, `setCookie`, `deleteCookie`, `getHeader`, `setHeader`\n\nFrom nuxt-auth-utils:\n- `getUserSession`, `setUserSession`, `clearUserSession`, `requireUserSession`\n- `hashPassword`, `verifyPassword`\n- `defineOAuth*EventHandler` (Google, GitHub, etc.)\n\n**Need to import:** `z` from \"zod\", `fromZodError` from \"zod-validation-error\"\n\n### Client-side\n\nAll auto-imported:\n- Vue: `ref`, `computed`, `watch`, `onMounted`, etc.\n- VueUse: `refDebounced`, `useLocalStorage`, `useUrlSearchParams`, etc.\n- Nuxt: `useFetch`, `useAsyncData`, `useRoute`, `useRouter`, `useState`, `navigateTo`\n\n### Shared (`/shared` directory - Nuxt 3.14+)\n\nCode auto-imported on both client AND server. Use for:\n- Types and interfaces\n- Pure utility functions\n- Constants\n\n## Quick Patterns\n\n### Validation (h3 v2+ with Standard Schema)\n\n```typescript\n// Pass Zod schema directly (h3 v2+)\nconst query = await getValidatedQuery(event, z.object({\n  search: z.string().optional(),\n  page: z.coerce.number().default(1),\n}));\n\nconst body = await readValidatedBody(event, z.object({\n  email: z.string().email(),\n  name: z.string().min(1),\n}));\n```\n\n### $fetch Type Inference\n\n```typescript\n// Template literals preserve type inference (fixed late 2024)\nconst userId = \"123\";  // Literal type \"123\"\nconst result = await $fetch(`/api/users/${userId}`);\n// result is typed from the handler's return type\n\n// NEVER do this - defeats type inference\nconst result = await $fetch<User>(\"/api/users/123\");  // WRONG\n```\n\n### useFetch for Page Data\n\n```typescript\n// Basic - types inferred from Nitro\nconst { data, status, refresh } = await useFetch(\"/api/users\");\n\n// Reactive query params - auto-refetch on change\nconst search = ref(\"\");\nconst debouncedSearch = refDebounced(search, 300);  // Auto-imported\nconst { data } = await useFetch(\"/api/users\", {\n  query: computed(() => ({\n    ...(debouncedSearch.value ? { search: debouncedSearch.value } : {}),\n  })),\n});\n\n// Dynamic URL with getter\nconst userId = ref(\"123\");\nconst { data } = await useFetch(() => `/api/users/${userId.value}`);\n\n// New options (Nuxt 3.14+)\nconst { data } = await useFetch(\"/api/data\", {\n  retry: 3,          // Retry on failure\n  retryDelay: 1000,  // Wait between retries\n  dedupe: \"cancel\",  // Cancel previous request\n  delay: 300,        // Debounce the request\n});\n```\n\n### $fetch for Event Handlers\n\n```typescript\n// ONLY use $fetch in event handlers (onClick, onSubmit)\nconst handleSubmit = async () => {\n  const result = await $fetch(\"/api/users\", {\n    method: \"POST\",\n    body: { name: \"Test\" },\n  });\n};\n```\n\n### Auth Check in API\n\n```typescript\n// In server/utils/auth.ts\nexport async function getAuthenticatedUser(event: H3Event) {\n  const session = await getUserSession(event);\n  if (!session?.user) {\n    throw createError({ statusCode: 401, statusMessage: \"Unauthorized\" });\n  }\n  return session.user;\n}\n\n// In API handler\nexport default defineEventHandler(async (event) => {\n  const user = await getAuthenticatedUser(event);\n  // user is typed and guaranteed to exist\n});\n```\n\n### SSR-Safe localStorage\n\n```typescript\n// Option 1: import.meta.client guard\nwatch(preference, (value) => {\n  if (import.meta.client) {\n    localStorage.setItem(\"pref\", value);\n  }\n});\n\n// Option 2: onMounted\nonMounted(() => {\n  const saved = localStorage.getItem(\"pref\");\n  if (saved) preference.value = saved;\n});\n\n// Option 3: VueUse (SSR-safe)\nconst theme = useLocalStorage(\"theme\", \"light\");\n```\n\n### Composable vs Util Decision\n\n```\nNeeds Nuxt/Vue context (useRuntimeConfig, useRoute, refs)?\n├─ YES → COMPOSABLE in /composables/use*.ts\n└─ NO → UTIL in /utils/*.ts (client) or /server/utils/*.ts (server)\n```\n\n## Key Gotchas\n\n1. **Don't use `$fetch` at top level** - Causes double-fetch (SSR + client). Use `useFetch`.\n2. **Debounce search inputs** - Use `refDebounced` to avoid excessive API calls.\n3. **Reset pagination on filter change** - Or users see empty page 5 with new filters.\n4. **Guard browser APIs** - Use `import.meta.client`, `onMounted`, or `<ClientOnly>`.\n5. **Nitro tasks are single-instance** - Can't run same task twice concurrently. Use DB job queue.\n6. **useRouteQuery needs Nuxt composables** - Pass `route` and `router` explicitly.\n7. **Input types aren't auto-generated** - Export Zod schemas for client use.\n8. **Cookie size limit is 4096 bytes** - Store only essential session data."
              }
            ]
          },
          {
            "name": "nitro-testing",
            "description": "Test Nitro handlers with real PostgreSQL, transaction rollback, factories",
            "source": "./skills/nitro-testing",
            "category": null,
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add gallop-systems/claude-skills",
              "/plugin install nitro-testing@gallop-systems-claude-skills"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-04T00:23:42Z",
              "created_at": "2026-01-02T19:34:22Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "nitro-testing",
                "description": "Test Nuxt 3 / Nitro API handlers with real PostgreSQL, transaction rollback isolation, and typed factories. No mocks, real SQL.",
                "path": "skills/nitro-testing/SKILL.md",
                "frontmatter": {
                  "name": "nitro-testing",
                  "description": "Test Nuxt 3 / Nitro API handlers with real PostgreSQL, transaction rollback isolation, and typed factories. No mocks, real SQL."
                },
                "content": "# Nitro API Testing Patterns\n\nTest Nitro API handlers with a real PostgreSQL database using transaction rollback isolation. Each test runs in a transaction that auto-rolls back, providing complete isolation without cleanup overhead.\n\n## When to Use This Skill\n\nUse this skill when:\n- Testing Nuxt 3 / Nitro API handlers\n- Using Kysely or another query builder with PostgreSQL\n- Need real database testing (not mocks)\n- Want fast, isolated tests without truncation\n\n## Reference Files\n\n- [transaction-rollback.md](./transaction-rollback.md) - Core isolation pattern with Vitest fixtures\n- [test-utils.md](./test-utils.md) - Mock events, stubs, and assertion helpers\n- [factories.md](./factories.md) - Transaction-bound factory pattern\n- [vitest-config.md](./vitest-config.md) - Vitest configuration for Nitro\n- [ci-setup.md](./ci-setup.md) - GitHub Actions with PostgreSQL service\n- [async-testing.md](./async-testing.md) - Testing background tasks and automations\n\n## Example Files\n\n- [test-utils-index.ts](./examples/test-utils-index.ts) - Complete test utilities module\n- [global-setup.ts](./examples/global-setup.ts) - Database reset and migration\n- [setup.ts](./examples/setup.ts) - Per-file setup with stubs\n- [handler.test.ts](./examples/handler.test.ts) - Example API handler test\n- [vitest.config.ts](./examples/vitest.config.ts) - Vitest configuration\n\n## Core Concept: Transaction Rollback\n\nInstead of truncating tables between tests, each test runs inside a database transaction that rolls back at the end:\n\n```typescript\n// Each test gets isolated factories and db access\ntest(\"creates user\", async ({ factories, db }) => {\n  const user = await factories.user({ email: \"test@example.com\" });\n\n  // Test your handler\n  const event = mockPost({}, { name: \"New Item\" });\n  const result = await handler(event);\n\n  // Verify in database\n  const saved = await db.selectFrom(\"item\").selectAll().execute();\n  expect(saved).toHaveLength(1);\n});\n// Transaction auto-rolls back - no cleanup needed\n```\n\nBenefits:\n- **Fast**: No DELETE/TRUNCATE between tests\n- **Isolated**: Tests can't affect each other\n- **Real SQL**: Catches actual database issues\n- **Simple**: No manual cleanup\n\n## Quick Setup\n\n### 1. Install Dependencies\n\n```bash\nyarn add -D vitest @vitest/coverage-v8\n```\n\n### 2. Create Test Utils Structure\n\n```\nserver/\n  test-utils/\n    index.ts        # Factories, fixtures, mock helpers\n    global-setup.ts # Runs once: reset DB, run migrations\n    setup.ts        # Runs per-file: stub auto-imports\n```\n\n### 3. Configure Vitest\n\n```typescript\n// vitest.config.ts\nimport { defineConfig } from \"vitest/config\";\nimport path from \"path\";\n\nexport default defineConfig({\n  test: {\n    globals: true,\n    environment: \"node\",\n    globalSetup: [\"./server/test-utils/global-setup.ts\"],\n    setupFiles: [\"./server/test-utils/setup.ts\"],\n  },\n  resolve: {\n    alias: {\n      \"~\": path.resolve(__dirname),\n    },\n  },\n});\n```\n\n### 4. Write Tests\n\n```typescript\n// server/api/users/index.post.test.ts\nimport { describe, test, expect, mockPost, expectHttpError } from \"~/server/test-utils\";\nimport handler from \"./index.post\";\n\ndescribe(\"POST /api/users\", () => {\n  test(\"creates user with valid data\", async ({ factories: _, db }) => {\n    const event = mockPost({}, {\n      email: \"new@example.com\",\n      name: \"New User\"\n    });\n    const result = await handler(event);\n\n    expect(result.id).toBeDefined();\n    expect(result.email).toBe(\"new@example.com\");\n\n    // Verify persisted\n    const saved = await db\n      .selectFrom(\"user\")\n      .where(\"id\", \"=\", result.id)\n      .selectAll()\n      .executeTakeFirst();\n    expect(saved?.name).toBe(\"New User\");\n  });\n\n  test(\"throws 400 for missing email\", async ({ factories: _ }) => {\n    const event = mockPost({}, { name: \"No Email\" });\n    await expectHttpError(handler(event), { statusCode: 400 });\n  });\n});\n```\n\n## Key Patterns\n\n### Mock Event Helpers\n\n```typescript\n// GET with route params and query\nconst event = mockGet({ id: 123 }, { include: \"details\" });\n\n// POST with body\nconst event = mockPost({}, { name: \"Test\", status: \"active\" });\n\n// PATCH with route params and body\nconst event = mockPatch({ id: 123 }, { status: \"completed\" });\n\n// DELETE with route params\nconst event = mockDelete({ id: 123 });\n```\n\n### Factory Pattern\n\n```typescript\ntest(\"lists user's projects\", async ({ factories }) => {\n  // Factories are transaction-bound - auto-rolled back\n  const user = await factories.user();\n  const project1 = await factories.project({ ownerId: user.id });\n  const project2 = await factories.project({ ownerId: user.id });\n\n  const event = mockGet({ userId: user.id });\n  const result = await handler(event);\n\n  expect(result).toHaveLength(2);\n});\n```\n\n### Testing with Related Data\n\n```typescript\ntest(\"returns task with job details\", async ({ factories }) => {\n  // Factories auto-create dependencies\n  const job = await factories.job(); // Creates project automatically\n  const task = await factories.task({ jobId: job.id });\n\n  const event = mockGet({ id: task.id });\n  const result = await handler(event);\n\n  expect(result.job.id).toBe(job.id);\n  expect(result.job.project).toBeDefined();\n});\n```\n\n### Testing Error Cases\n\n```typescript\ntest(\"returns 404 for non-existent resource\", async ({ factories: _ }) => {\n  const event = mockGet({ id: 999999 });\n  await expectHttpError(handler(event), {\n    statusCode: 404,\n    message: \"Not found\",\n  });\n});\n\ntest(\"returns 400 for invalid input\", async ({ factories: _ }) => {\n  const event = mockPost({}, { invalidField: true });\n  await expectHttpError(handler(event), { statusCode: 400 });\n});\n```\n\n## Auto-Import Stubs\n\nThe setup file stubs Nuxt/Nitro auto-imports:\n\n| Stub | Purpose |\n|------|---------|\n| `defineEventHandler` | Unwraps to return handler directly |\n| `getUserSession` | Returns test user (configurable) |\n| `useDatabase` | Returns test transaction |\n| `createError` | Creates H3-style errors |\n| `getValidatedQuery` | Validates mock query params |\n| `readValidatedBody` | Validates mock body |\n| `getRouterParam` | Returns mock route params |\n\n## Key Gotchas\n\n1. **Always destructure `factories`** - Even if unused, it sets up the transaction:\n   ```typescript\n   test(\"...\", async ({ factories: _ }) => { ... });\n   ```\n\n2. **Don't use top-level db imports** - Use the `db` fixture instead:\n   ```typescript\n   // ❌ Wrong - uses real db, not transaction\n   import { db } from \"../utils/db\";\n\n   // ✅ Right - uses test transaction\n   test(\"...\", async ({ db }) => { ... });\n   ```\n\n3. **Nested transactions work** - Code that calls `db.transaction()` works because we patch the prototype\n\n4. **Test file location** - Co-locate with handlers: `handler.ts` → `handler.test.ts`\n\n5. **Separate test database** - Always use a dedicated test DB (`myapp-test`, not `myapp`)\n\n6. **CI needs PostgreSQL service** - See [ci-setup.md](./ci-setup.md) for GitHub Actions config"
              }
            ]
          }
        ]
      }
    }
  ]
}