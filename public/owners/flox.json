{
  "owner": {
    "id": "flox",
    "display_name": "Flox",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/72631827?v=4",
    "url": "https://github.com/flox",
    "bio": "Developer environments you can take with you",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 7,
      "total_stars": 3,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "flox/flox-agentic",
      "url": "https://github.com/flox/flox-agentic",
      "description": "Supplying agents with Flox knowledge",
      "homepage": "",
      "signals": {
        "stars": 3,
        "forks": 0,
        "pushed_at": "2025-11-25T20:40:11Z",
        "created_at": "2025-11-06T20:56:27Z",
        "license": "NOASSERTION"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 435
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 8
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 554
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 5994
        },
        {
          "path": "flox-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 360
        },
        {
          "path": "flox-plugin/.mcp.json",
          "type": "blob",
          "size": 139
        },
        {
          "path": "flox-plugin/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/skills/README.md",
          "type": "blob",
          "size": 77
        },
        {
          "path": "flox-plugin/skills/flox-builds",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/skills/flox-builds/SKILL.md",
          "type": "blob",
          "size": 13403
        },
        {
          "path": "flox-plugin/skills/flox-containers",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/skills/flox-containers/SKILL.md",
          "type": "blob",
          "size": 10925
        },
        {
          "path": "flox-plugin/skills/flox-cuda",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/skills/flox-cuda/SKILL.md",
          "type": "blob",
          "size": 12947
        },
        {
          "path": "flox-plugin/skills/flox-environments",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/skills/flox-environments/SKILL.md",
          "type": "blob",
          "size": 11518
        },
        {
          "path": "flox-plugin/skills/flox-publish",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/skills/flox-publish/SKILL.md",
          "type": "blob",
          "size": 10952
        },
        {
          "path": "flox-plugin/skills/flox-services",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/skills/flox-services/SKILL.md",
          "type": "blob",
          "size": 6489
        },
        {
          "path": "flox-plugin/skills/flox-sharing",
          "type": "tree",
          "size": null
        },
        {
          "path": "flox-plugin/skills/flox-sharing/SKILL.md",
          "type": "blob",
          "size": 9868
        },
        {
          "path": "flox.md",
          "type": "blob",
          "size": 39163
        }
      ],
      "marketplace": {
        "name": "flox-agentic",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Flox"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "flox",
            "description": "Flox development environment and deployment plugin. Includes expert guidance for package management, services, builds and package distribution, containerization, environment composition and layering. Works with the Flox MCP server for enhanced functionality.",
            "source": "./flox-plugin",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add flox/flox-agentic",
              "/plugin install flox@flox-agentic"
            ],
            "signals": {
              "stars": 3,
              "forks": 0,
              "pushed_at": "2025-11-25T20:40:11Z",
              "created_at": "2025-11-06T20:56:27Z",
              "license": "NOASSERTION"
            },
            "commands": [],
            "skills": [
              {
                "name": "flox-builds",
                "description": "Building and packaging applications with Flox. Use for manifest builds, Nix expression builds, sandbox modes, multi-stage builds, and packaging assets.",
                "path": "flox-plugin/skills/flox-builds/SKILL.md",
                "frontmatter": {
                  "name": "flox-builds",
                  "description": "Building and packaging applications with Flox. Use for manifest builds, Nix expression builds, sandbox modes, multi-stage builds, and packaging assets."
                },
                "content": "# Flox Build System Guide\n\n## Build System Overview\n\nFlox supports two build modes, each with its own strengths:\n\n**Manifest builds** enable you to define your build steps in your manifest and reuse your existing build scripts and toolchains. Flox manifests are declarative artifacts, expressed in TOML.\n\nManifest builds:\n- Make it easy to get started, requiring few if any changes to your existing workflows\n- Can run inside a sandbox (using `sandbox = \"pure\"`) for reproducible builds\n- Are best for getting going fast with existing projects\n\n**Nix expression builds** guarantee build-time reproducibility because they're both isolated and purely functional. Their learning curve is steeper because they require proficiency with the Nix language.\n\nNix expression builds:\n- Are isolated by default. The Nix sandbox seals the build off from the host system, so no state leak ins\n- Are functional. A Nix build is defined as a pure function of its declared inputs\n\nYou can mix both approaches in the same project, but package names must be unique.\n\n## Core Commands\n\n```bash\nflox build                      # Build all targets\nflox build app docs             # Build specific targets\nflox build -d /path/to/project  # Build in another directory\nflox build -v                   # Verbose output\nflox build .#hello              # Build specific Nix expression\n```\n\n## Development vs Runtime: The Two-Environment Pattern\n\nA common workflow involves **two separate environments**:\n\n### Development Environment (Build-Time)\nContains source code, build tools, and build definitions:\n```toml\n# project-dev/.flox/env/manifest.toml (in git with source code)\n[install]\ngcc.pkg-path = \"gcc13\"\nmake.pkg-path = \"make\"\npython.pkg-path = \"python311Full\"\nuv.pkg-path = \"uv\"\n\n[build.myapp]\ncommand = '''\n  make build\n  mkdir -p $out/bin\n  cp build/myapp $out/bin/\n'''\nversion = \"1.0.0\"\n```\n\n**Workflow:**\n```bash\ncd project-dev\nflox activate\nflox build myapp\nflox publish -o myorg myapp\n```\n\n### Runtime Environment (Consume-Time)\nContains only the published package and runtime dependencies:\n```toml\n# project-runtime/.flox/env/manifest.toml (can push to FloxHub)\n[install]\nmyapp.pkg-path = \"myorg/myapp\"  # The published package\n```\n\n**Workflow:**\n```bash\ncd project-runtime\nflox init\nflox install myorg/myapp\nflox push  # Share runtime environment without source code\n```\n\n**Why separate environments?**\n- Development environment: Heavy (build tools, source code, dev dependencies)\n- Runtime environment: Lightweight (only published package and runtime needs)\n- Security: Runtime environments don't expose source code\n- Clarity: Clear separation between building and consuming\n- Rollback: Can rollback the live generation of a runtime environment without affecting the development environment\n\n**Note**: You can also install published packages into existing environments (other projects, production environments, etc.), not just dedicated runtime environments.\n\n## Manifest Builds\n\nFlox treats a **manifest build** as a short, deterministic Bash script that runs inside an activated environment and copies its deliverables into `$out`. Anything copied there becomes a first-class, versioned package that can later be published and installed like any other catalog artifact.\n\n### Critical insights from real-world packaging:\n- **Build hooks don't run**: `[hook]` scripts DO NOT execute during `flox build` - only during interactive `flox activate`\n- **Guard env vars**: Always use `${FLOX_ENV_CACHE:-}` with default fallback in hooks to avoid build failures\n- **Wrapper scripts pattern**: Create launcher scripts in `$out/bin/` that set up runtime environment:\n  ```bash\n  cat > \"$out/bin/myapp\" << 'EOF'\n  #!/usr/bin/env bash\n  APP_ROOT=\"$(dirname \"$(dirname \"$(readlink -f \"$0\")\")\")\"\n  export PYTHONPATH=\"$APP_ROOT/share/myapp:$PYTHONPATH\"\n  exec python3 \"$APP_ROOT/share/myapp/main.py\" \"$@\"\n  EOF\n  chmod +x \"$out/bin/myapp\"\n  ```\n- **User config pattern**: Default to `~/.myapp/` for user configs, not `$FLOX_ENV_CACHE` (packages are immutable)\n- **Model/data directories**: Create user directories at runtime, not build time:\n  ```bash\n  mkdir -p \"${MYAPP_DIR:-$HOME/.myapp}/models\"\n  ```\n- **Python package strategy**: Don't bundle Python deps - include `requirements.txt` and setup script:\n  ```bash\n  # In build, create setup script:\n  cat > \"$out/bin/myapp-setup\" << 'EOF'\n  venv=\"${VENV:-$HOME/.myapp/venv}\"\n  uv venv \"$venv\" --python python3\n  uv pip install --python \"$venv/bin/python\" -r \"$APP_ROOT/share/myapp/requirements.txt\"\n  EOF\n  ```\n- **Dual-environment workflow**: Use one environment for building (`project-dev/`), another for consuming (`project-runtime/`). See \"Development vs Runtime: The Two-Environment Pattern\" section above for details.\n\n### Build Definition Syntax\n\n```toml\n[build.<name>]\ncommand      = '''  # required – Bash, multiline string\n  <your build steps>                 # e.g. cargo build, npm run build\n  mkdir -p $out/bin\n  cp path/to/artifact $out/bin/<name>\n'''\nversion      = \"1.2.3\"               # optional\ndescription  = \"one-line summary\"    # optional\nsandbox      = \"pure\" | \"off\"        # default: off\nruntime-packages = [ \"id1\", \"id2\" ]  # optional\n```\n\n**One table per package.** Multiple `[build.*]` tables let you publish, for example, a stripped release binary and a debug build from the same sources.\n\n**Bash only.** The script executes under `set -euo pipefail`. If you need zsh or fish features, invoke them explicitly inside the script.\n\n**Environment parity.** Before your script runs, Flox performs the equivalent of `flox activate` — so every tool listed in `[install]` is on PATH.\n\n**Package groups and builds.** Only packages in the `toplevel` group (default) are available during builds. Packages with explicit `pkg-group` settings won't be accessible in build commands unless also installed to `toplevel`.\n\n**Referencing other builds.** `${other}` expands to the `$out` of `[build.other]` and forces that build to run first, enabling multi-stage flows (e.g. vendoring → compilation).\n\n## Purity and Sandbox Control\n\n| sandbox value | Filesystem scope | Network | Typical use-case |\n|---------------|------------------|---------|------------------|\n| `\"off\"` (default) | Project working tree; complete host FS | allowed | Fast, iterative dev builds |\n| `\"pure\"` | Git-tracked files only, copied to tmp | Linux: blocked<br>macOS: allowed | Reproducible, host-agnostic packages |\n\nPure mode highlights undeclared inputs early and is mandatory for builds intended for CI/CD publication. When a pure build needs pre-fetched artifacts (e.g. language modules) use a two-stage pattern:\n\n```toml\n[build.deps]\ncommand  = '''go mod vendor -o $out/etc/vendor'''\nsandbox  = \"off\"\n\n[build.app]\ncommand  = '''\n  cp -r ${deps}/etc/vendor ./vendor\n  go build ./...\n  mkdir -p $out/bin\n  cp app $out/bin/\n'''\nsandbox  = \"pure\"\n```\n\n## $out Layout and Filesystem Hierarchy\n\nOnly files placed under `$out` survive. Follow FHS conventions:\n\n| Path | Purpose |\n|------|---------|\n| `$out/bin` / `$out/sbin` | CLI and daemon binaries (must be `chmod +x`) |\n| `$out/lib`, `$out/libexec` | Shared libraries, helper programs |\n| `$out/share/man` | Man pages (gzip them) |\n| `$out/etc` | Configuration shipped with the package |\n\nScripts or binaries stored elsewhere will not end up on callers' paths.\n\n## Running Manifest Builds\n\n```bash\n# Build every target in the manifest\nflox build\n\n# Build a subset\nflox build app docs\n\n# Build a manifest in another directory\nflox build -d /path/to/project\n```\n\nResults appear as immutable symlinks: `./result-<name>` → `/nix/store/...-<name>-<version>`.\n\nTo execute a freshly built binary: `./result-app/bin/app`.\n\n## Multi-Stage Examples\n\n### Rust release binary plus source tar\n\n```toml\n[build.bin]\ncommand = '''\n  cargo build --release\n  mkdir -p $out/bin\n  cp target/release/myproject $out/bin/\n'''\nversion = \"0.9.0\"\n\n[build.src]\ncommand = '''\n  git archive --format=tar HEAD | gzip > $out/myproject-${bin.version}.tar.gz\n'''\nsandbox = \"pure\"\n```\n\n`${bin.version}` resolves because both builds share the same manifest.\n\n### Go with vendored dependencies\n\n```toml\n[build.vendor]\ncommand = '''\n  go mod vendor\n  mkdir -p $out/vendor\n  cp -r vendor/* $out/vendor/\n'''\nsandbox = \"off\"\n\n[build.app]\ncommand = '''\n  cp -r ${vendor}/vendor ./\n  go build -mod=vendor -o $out/bin/myapp\n'''\nsandbox = \"pure\"\n```\n\n## Trimming Runtime Dependencies\n\nBy default, every package in the `toplevel` install-group becomes a runtime dependency of your build's closure—even if it was only needed at compile time.\n\nDeclare a minimal list instead:\n\n```toml\n[install]\nclang.pkg-path = \"clang\"\npytest.pkg-path = \"pytest\"\n\n[build.cli]\ncommand = '''\n  make\n  mv build/cli $out/bin/\n'''\nruntime-packages = [ \"clang\" ]  # exclude pytest from runtime closure\n```\n\nSmaller closures copy faster and occupy less disk when installed on users' systems.\n\n## Version and Description Metadata\n\nFlox surfaces these fields in `flox search`, `flox show`, and during publication.\n\n```toml\n[build.mytool]\nversion.command = \"git describe --tags\"\ndescription = \"High-performance log shipper\"\n```\n\nAlternative forms:\n\n```toml\nversion = \"1.4.2\"            # static string\nversion.file = \"VERSION.txt\" # read at build time\n```\n\n## Cross-Platform Considerations for Manifest Builds\n\n`flox build` targets the host's systems triple. To ship binaries for additional platforms you must trigger the build on machines (or CI runners) of those architectures:\n\n```\nlinux-x86_64 → build → publish\ndarwin-aarch64 → build → publish\n```\n\nThe manifest can remain identical across hosts.\n\n## Beyond Code — Packaging Assets\n\nAny artifact that can be copied into `$out` can be versioned and installed:\n\n### Nginx baseline config\n\n```toml\n[build.nginx_cfg]\ncommand = '''mkdir -p $out/etc && cp nginx.conf $out/etc/'''\n```\n\n### Organization-wide .proto schema bundle\n\n```toml\n[build.proto]\ncommand = '''\n  mkdir -p $out/share/proto\n  cp proto/**/*.proto $out/share/proto/\n'''\n```\n\nTeams install these packages and reference them via `$FLOX_ENV/etc/nginx.conf` or `$FLOX_ENV/share/proto`.\n\n## Nix Expression Builds\n\nYou can write a Nix expression instead of (or in addition to) defining a manifest build.\n\nPut `*.nix` build files in `.flox/pkgs/` for Nix expression builds. Git add all files before building.\n\n### File Naming\n- `hello.nix` → package named `hello`\n- `hello/default.nix` → package named `hello`\n\n### Common Patterns\n\n**Shell Script**\n```nix\n{writeShellApplication, curl}:\nwriteShellApplication {\n  name = \"my-ip\";\n  runtimeInputs = [ curl ];\n  text = ''curl icanhazip.com'';\n}\n```\n\n**Your Project**\n```nix\n{ rustPlatform, lib }:\nrustPlatform.buildRustPackage {\n  pname = \"my-app\";\n  version = \"0.1.0\";\n  src = ../../.;\n  cargoLock.lockFile = \"${src}/Cargo.lock\";\n}\n```\n\n**Update Version**\n```nix\n{ hello, fetchurl }:\nhello.overrideAttrs (finalAttrs: _: {\n  version = \"2.12.2\";\n  src = fetchurl {\n    url = \"mirror://gnu/hello/hello-${finalAttrs.version}.tar.gz\";\n    hash = \"sha256-WpqZbcKSzCTc9BHO6H6S9qrluNE72caBm0x6nc4IGKs=\";\n  };\n})\n```\n\n**Apply Patches**\n```nix\n{ hello }:\nhello.overrideAttrs (oldAttrs: {\n  patches = (oldAttrs.patches or []) ++ [ ./my.patch ];\n})\n```\n\n### Hash Generation\n1. Use `hash = \"\";`\n2. Run `flox build`\n3. Copy hash from error message\n\n### Commands\n- `flox build` - build all\n- `flox build .#hello` - build specific\n- `git add .flox/pkgs/*` - track files\n\n## Language-Specific Build Examples\n\n### Python Application\n\n```toml\n[build.myapp]\ncommand = '''\n  mkdir -p $out/bin $out/share/myapp\n\n  # Copy application code\n  cp -r src/* $out/share/myapp/\n  cp requirements.txt $out/share/myapp/\n\n  # Create wrapper script\n  cat > $out/bin/myapp << 'EOF'\n#!/usr/bin/env bash\nAPP_ROOT=\"$(dirname \"$(dirname \"$(readlink -f \"$0\")\")\")\"\nexport PYTHONPATH=\"$APP_ROOT/share/myapp:$PYTHONPATH\"\nexec python3 \"$APP_ROOT/share/myapp/main.py\" \"$@\"\nEOF\n  chmod +x $out/bin/myapp\n'''\nversion = \"1.0.0\"\n```\n\n### Node.js Application\n\n```toml\n[build.webapp]\ncommand = '''\n  npm ci\n  npm run build\n\n  mkdir -p $out/share/webapp\n  cp -r dist/* $out/share/webapp/\n  cp package.json package-lock.json $out/share/webapp/\n\n  cd $out/share/webapp && npm ci --production\n'''\nversion = \"1.0.0\"\n```\n\n### Rust Binary\n\n```toml\n[build.cli]\ncommand = '''\n  cargo build --release\n  mkdir -p $out/bin\n  cp target/release/mycli $out/bin/\n'''\nversion.command = \"cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version'\"\n```\n\n## Debugging Build Issues\n\n### Common Problems\n\n**Build hooks don't run**: `[hook]` scripts DO NOT execute during `flox build`\n\n**Package groups**: Only `toplevel` group packages available during builds\n\n**Network access**: Pure builds can't access network on Linux\n\n### Debugging Steps\n\n1. Check build output: `flox build -v`\n2. Inspect result: `ls -la result-<name>/`\n3. Test binary: `./result-<name>/bin/<name>`\n4. Check dependencies: `nix-store -q --references result-<name>`\n\n## Related Skills\n\n- **flox-environments** - Setting up development and runtime environments\n- **flox-publish** - Publishing built packages to catalogs, understanding the dev→publish→runtime workflow\n- **flox-containers** - Building container images"
              },
              {
                "name": "flox-containers",
                "description": "Containerizing Flox environments with Docker/Podman. Use for creating container images, OCI exports, multi-stage builds, and deployment workflows.",
                "path": "flox-plugin/skills/flox-containers/SKILL.md",
                "frontmatter": {
                  "name": "flox-containers",
                  "description": "Containerizing Flox environments with Docker/Podman. Use for creating container images, OCI exports, multi-stage builds, and deployment workflows."
                },
                "content": "# Flox Containerization Guide\n\n## Core Commands\n\n```bash\nflox containerize                          # Export to default tar file\nflox containerize -f ./mycontainer.tar     # Export to specific file\nflox containerize --runtime docker         # Export directly to Docker\nflox containerize --runtime podman         # Export directly to Podman\nflox containerize -f - | docker load       # Pipe to Docker\nflox containerize --tag v1.0               # Tag container image\nflox containerize -r owner/env             # Containerize remote environment\n```\n\n## Basic Usage\n\n### Export to File\n\n```bash\n# Export to file\nflox containerize -f ./mycontainer.tar\ndocker load -i ./mycontainer.tar\n\n# Or use default filename: {name}-container.tar\nflox containerize\ndocker load -i myenv-container.tar\n```\n\n### Export Directly to Runtime\n\n```bash\n# Auto-detects docker or podman\nflox containerize --runtime docker\n\n# Explicit runtime selection\nflox containerize --runtime podman\n```\n\n### Pipe to Stdout\n\n```bash\n# Pipe directly to Docker\nflox containerize -f - | docker load\n\n# With tagging\nflox containerize --tag v1.0 -f - | docker load\n```\n\n## How Containers Behave\n\n**Containers activate the Flox environment on startup** (like `flox activate`):\n\n- **Interactive**: `docker run -it <image>` → Bash shell with environment activated\n- **Non-interactive**: `docker run <image> <cmd>` → Runs command with environment activated (like `flox activate -- <cmd>`)\n- All packages, variables, and hooks are available inside the container\n\n**Note**: Flox sets an entrypoint that activates the environment, then runs `cmd` inside that activation.\n\n## Command Options\n\n```bash\nflox containerize\n  [-f <file>]           # Output file (- for stdout); defaults to {name}-container.tar\n  [--runtime <runtime>] # docker/podman (auto-detects if not specified)\n  [--tag <tag>]         # Container tag (e.g., v1.0, latest)\n  [-d <path>]           # Path to .flox/ directory\n  [-r <owner/name>]     # Remote environment from FloxHub\n```\n\n## Manifest Configuration\n\nConfigure container in `[containerize.config]` (experimental):\n\n```toml\n[containerize.config]\nuser = \"appuser\"                    # Username or uid:gid format\nexposed-ports = [\"8080/tcp\"]        # Ports to expose (tcp/udp/default:tcp)\ncmd = [\"python\", \"app.py\"]          # Command to run (receives activated env)\nvolumes = [\"/data\", \"/config\"]      # Mount points for persistent data\nworking-dir = \"/app\"                # Working directory\nlabels = { version = \"1.0\" }        # Arbitrary metadata\nstop-signal = \"SIGTERM\"             # Signal to stop container\n```\n\n### Configuration Options Explained\n\n**user**: Run container as specific user\n- Username: `user = \"appuser\"`\n- UID:GID: `user = \"1000:1000\"`\n\n**exposed-ports**: Network ports to expose\n- TCP: `[\"8080/tcp\"]`\n- UDP: `[\"8125/udp\"]`\n- Default protocol is tcp: `[\"8080\"]` = `[\"8080/tcp\"]`\n\n**cmd**: Command to run in container\n- Array form: `cmd = [\"python\", \"app.py\"]`\n- Empty for service-based: `cmd = []`\n\n**volumes**: Mount points for persistent data\n- List paths: `volumes = [\"/data\", \"/config\", \"/logs\"]`\n\n**working-dir**: Initial working directory\n- Absolute path: `working-dir = \"/app\"`\n\n**labels**: Arbitrary metadata\n- Key-value pairs: `labels = { version = \"1.0\", env = \"production\" }`\n\n**stop-signal**: Signal to stop container\n- Common: `\"SIGTERM\"`, `\"SIGINT\"`, `\"SIGKILL\"`\n\n## Complete Workflow Examples\n\n### Flask Web Application\n\n```bash\n# Create environment\nflox init\nflox install python311 flask\n\n# Configure for container\ncat >> .flox/env/manifest.toml << 'EOF'\n[containerize.config]\nexposed-ports = [\"5000/tcp\"]\ncmd = [\"python\", \"-m\", \"flask\", \"run\", \"--host=0.0.0.0\"]\nworking-dir = \"/app\"\nuser = \"flask\"\nEOF\n\n# Build and run\nflox containerize -f - | docker load\ndocker run -p 5000:5000 -v $(pwd):/app <container-id>\n```\n\n### Node.js Application\n\n```bash\nflox init\nflox install nodejs\n\ncat >> .flox/env/manifest.toml << 'EOF'\n[containerize.config]\nexposed-ports = [\"3000/tcp\"]\ncmd = [\"npm\", \"start\"]\nworking-dir = \"/app\"\nEOF\n\nflox containerize --tag myapp:latest --runtime docker\ndocker run -p 3000:3000 -v $(pwd):/app myapp:latest\n```\n\n### Database Container\n\n```bash\nflox init\nflox install postgresql\n\n# Set up service in manifest\nflox edit\n\n# Add service and container config\ncat >> .flox/env/manifest.toml << 'EOF'\n[services.postgres]\ncommand = '''\n  mkdir -p /data/postgres\n  if [ ! -d \"/data/postgres/pgdata\" ]; then\n    initdb -D /data/postgres/pgdata\n  fi\n  exec postgres -D /data/postgres/pgdata -h 0.0.0.0\n'''\nis-daemon = true\n\n[containerize.config]\nexposed-ports = [\"5432/tcp\"]\nvolumes = [\"/data\"]\ncmd = []  # Service starts automatically\nEOF\n\nflox containerize -f - | docker load\ndocker run -p 5432:5432 -v pgdata:/data <container-id>\n```\n\n## Common Patterns\n\n### Service Containers\n\nServices start automatically when cmd is empty:\n\n```toml\n[services.web]\ncommand = \"python -m http.server 8000\"\n\n[containerize.config]\nexposed-ports = [\"8000/tcp\"]\ncmd = []  # Service starts automatically\n```\n\n### Multi-Stage Pattern\n\nBuild in one environment, run in another:\n\n```bash\n# Build environment with all dev tools\ncd build-env\nflox activate -- flox build myapp\n\n# Runtime environment with minimal deps\ncd ../runtime-env\nflox install myapp\nflox containerize --tag production -f - | docker load\n\n# Run\ndocker run production\n```\n\n### Remote Environment Containers\n\nContainerize shared team environments:\n\n```bash\n# Containerize remote environment\nflox containerize -r team/python-ml --tag latest --runtime docker\n\n# Run it\ndocker run -it team-python-ml:latest\n```\n\n### Multi-Service Container\n\n```toml\n[services.db]\ncommand = '''exec postgres -D \"$FLOX_ENV_CACHE/postgres\"'''\nis-daemon = true\n\n[services.cache]\ncommand = '''exec redis-server'''\nis-daemon = true\n\n[services.api]\ncommand = '''exec python -m uvicorn main:app --host 0.0.0.0'''\n\n[containerize.config]\nexposed-ports = [\"8000/tcp\", \"5432/tcp\", \"6379/tcp\"]\ncmd = []  # All services start automatically\n```\n\n## Platform-Specific Notes\n\n### macOS\n- Requires docker/podman runtime (uses proxy container for builds)\n- May prompt for file sharing permissions\n- Creates `flox-nix` volume for caching\n- Safe to remove when not building: `docker volume rm flox-nix`\n\n### Linux\n- Direct image creation without proxy\n- No intermediate volumes needed\n- Native container support\n\n## Advanced Use Cases\n\n### Custom Entrypoint with Wrapper Script\n\n```toml\n[build.entrypoint]\ncommand = '''\n  cat > $out/bin/entrypoint.sh << 'EOF'\n#!/usr/bin/env bash\nset -e\n\n# Custom initialization\necho \"Initializing application...\"\nsetup_app\n\n# Run whatever command was passed\nexec \"$@\"\nEOF\n  chmod +x $out/bin/entrypoint.sh\n'''\n\n[containerize.config]\ncmd = [\"entrypoint.sh\", \"python\", \"app.py\"]\n```\n\n### Health Check Support\n\n```toml\n[containerize.config]\ncmd = [\"python\", \"app.py\"]\nlabels = {\n  \"healthcheck\" = \"curl -f http://localhost:8000/health || exit 1\"\n}\n```\n\nThen in Docker:\n```bash\ndocker run --health-cmd=\"curl -f http://localhost:8000/health || exit 1\" \\\n           --health-interval=30s \\\n           myimage\n```\n\n### Multi-Architecture Builds\n\nBuild for different architectures:\n\n```bash\n# On x86_64 Linux\nflox containerize --tag myapp:amd64 --runtime docker\n\n# On ARM64 (aarch64) Linux\nflox containerize --tag myapp:arm64 --runtime docker\n\n# Create manifest\ndocker manifest create myapp:latest \\\n  myapp:amd64 \\\n  myapp:arm64\n```\n\n### Minimal Container Size\n\nCreate minimal runtime environment:\n\n```toml\n[install]\n# Only runtime dependencies\npython.pkg-path = \"python311\"\n# No dev tools, no build tools\n\n[build.app]\ncommand = '''\n  # Build in build environment\n  python -m pip install --target=$out/lib/python -r requirements.txt\n  cp -r src $out/lib/python/\n'''\nruntime-packages = [\"python\"]\n\n[containerize.config]\ncmd = [\"python\", \"-m\", \"myapp\"]\n```\n\n## Container Registry Workflows\n\n### Push to Registry\n\n```bash\n# Build container\nflox containerize --tag myapp:v1.0 --runtime docker\n\n# Tag for registry\ndocker tag myapp:v1.0 registry.company.com/myapp:v1.0\n\n# Push\ndocker push registry.company.com/myapp:v1.0\n```\n\n### GitLab CI/CD\n\n```yaml\ncontainerize:\n  stage: build\n  script:\n    - flox containerize --tag $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG --runtime docker\n    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_TAG\n```\n\n### GitHub Actions\n\n```yaml\n- name: Build container\n  run: |\n    flox containerize --tag ghcr.io/${{ github.repository }}:${{ github.sha }} --runtime docker\n\n- name: Push to GHCR\n  run: |\n    echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin\n    docker push ghcr.io/${{ github.repository }}:${{ github.sha }}\n```\n\n## Kubernetes Deployment\n\n### Basic Deployment\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      containers:\n      - name: myapp\n        image: registry.company.com/myapp:v1.0\n        ports:\n        - containerPort: 8000\n        volumeMounts:\n        - name: data\n          mountPath: /data\n      volumes:\n      - name: data\n        persistentVolumeClaim:\n          claimName: myapp-data\n```\n\n### Service Definition\n\n```yaml\napiVersion: v1\nkind: Service\nmetadata:\n  name: myapp\nspec:\n  selector:\n    app: myapp\n  ports:\n  - port: 80\n    targetPort: 8000\n  type: LoadBalancer\n```\n\n## Debugging Container Issues\n\n### Inspect Container\n\n```bash\n# Run interactively\ndocker run -it --entrypoint /bin/bash <image-id>\n\n# Check environment\ndocker run <image-id> env\n\n# Check what's in the image\ndocker run <image-id> ls -la /\n```\n\n### View Container Logs\n\n```bash\n# Follow logs\ndocker logs -f <container-id>\n\n# Last 100 lines\ndocker logs --tail 100 <container-id>\n```\n\n### Execute Commands in Running Container\n\n```bash\n# Get a shell\ndocker exec -it <container-id> /bin/bash\n\n# Run specific command\ndocker exec <container-id> flox list\n```\n\n## Best Practices\n\n1. **Use specific tags**: Avoid `latest`, use semantic versioning\n2. **Minimize layers**: Combine related operations in manifests\n3. **Use .dockerignore equivalent**: Only include necessary files in build context\n4. **Health checks**: Implement health check endpoints for services\n5. **Security**: Run as non-root user when possible\n6. **Volumes**: Use volumes for persistent data, not container filesystem\n7. **Environment variables**: Make configuration overridable via env vars\n8. **Logging**: Log to stdout/stderr, not files\n\n## Related Skills\n\n- **flox-environments** - Creating environments to containerize\n- **flox-services** - Running services in containers\n- **flox-builds** - Building artifacts before containerizing\n- **flox-sharing** - Containerizing remote environments"
              },
              {
                "name": "flox-cuda",
                "description": "CUDA and GPU development with Flox. Use for NVIDIA CUDA setup, GPU computing, deep learning frameworks, cuDNN, and cross-platform GPU/CPU development.",
                "path": "flox-plugin/skills/flox-cuda/SKILL.md",
                "frontmatter": {
                  "name": "flox-cuda",
                  "description": "CUDA and GPU development with Flox. Use for NVIDIA CUDA setup, GPU computing, deep learning frameworks, cuDNN, and cross-platform GPU/CPU development."
                },
                "content": "# Flox CUDA Development Guide\n\n## Prerequisites & Authentication\n\n- Sign up for early access at https://flox.dev\n- Authenticate with `flox auth login`\n- **Linux-only**: CUDA packages only work on `[\"aarch64-linux\", \"x86_64-linux\"]`\n- All CUDA packages are prefixed with `flox-cuda/` in the catalog\n- **No macOS support**: Use Metal alternatives on Darwin\n\n## Core Commands\n\n```bash\n# Search for CUDA packages\nflox search cudatoolkit --all | grep flox-cuda\nflox search nvcc --all | grep 12_8\n\n# Show available versions\nflox show flox-cuda/cudaPackages.cudatoolkit\n\n# Install CUDA packages\nflox install flox-cuda/cudaPackages_12_8.cuda_nvcc\nflox install flox-cuda/cudaPackages.cuda_cudart\n\n# Verify installation\nnvcc --version\nnvidia-smi\n```\n\n## Package Discovery\n\n```bash\n# Search for CUDA toolkit\nflox search cudatoolkit --all | grep flox-cuda\n\n# Search for specific versions\nflox search nvcc --all | grep 12_8\n\n# Show all available versions\nflox show flox-cuda/cudaPackages.cudatoolkit\n\n# Search for CUDA libraries\nflox search libcublas --all | grep flox-cuda\nflox search cudnn --all | grep flox-cuda\n```\n\n## Essential CUDA Packages\n\n| Package Pattern | Purpose | Example |\n|-----------------|---------|---------|\n| `cudaPackages_X_Y.cudatoolkit` | Main CUDA Toolkit | `cudaPackages_12_8.cudatoolkit` |\n| `cudaPackages_X_Y.cuda_nvcc` | NVIDIA C++ Compiler | `cudaPackages_12_8.cuda_nvcc` |\n| `cudaPackages.cuda_cudart` | CUDA Runtime API | `cuda_cudart` |\n| `cudaPackages_X_Y.libcublas` | Linear algebra | `cudaPackages_12_8.libcublas` |\n| `cudaPackages_X_Y.libcufft` | Fast Fourier Transform | `cudaPackages_12_8.libcufft` |\n| `cudaPackages_X_Y.libcurand` | Random number generation | `cudaPackages_12_8.libcurand` |\n| `cudaPackages_X_Y.cudnn_9_11` | Deep neural networks | `cudaPackages_12_8.cudnn_9_11` |\n| `cudaPackages_X_Y.nccl` | Multi-GPU communication | `cudaPackages_12_8.nccl` |\n\n## Critical: Conflict Resolution\n\n**CUDA packages have LICENSE file conflicts requiring explicit priorities:**\n\n```toml\n[install]\ncuda_nvcc.pkg-path = \"flox-cuda/cudaPackages_12_8.cuda_nvcc\"\ncuda_nvcc.systems = [\"aarch64-linux\", \"x86_64-linux\"]\ncuda_nvcc.priority = 1                    # Highest priority\n\ncuda_cudart.pkg-path = \"flox-cuda/cudaPackages.cuda_cudart\"\ncuda_cudart.systems = [\"aarch64-linux\", \"x86_64-linux\"]\ncuda_cudart.priority = 2\n\ncudatoolkit.pkg-path = \"flox-cuda/cudaPackages_12_8.cudatoolkit\"\ncudatoolkit.systems = [\"aarch64-linux\", \"x86_64-linux\"]\ncudatoolkit.priority = 3                  # Lower for LICENSE conflicts\n\ngcc.pkg-path = \"gcc\"\ngcc-unwrapped.pkg-path = \"gcc-unwrapped\"  # For libstdc++\ngcc-unwrapped.priority = 5\n```\n\n## CUDA Version Selection\n\n### CUDA 12.x (Current)\n\n```toml\n[install]\ncuda_nvcc.pkg-path = \"flox-cuda/cudaPackages_12_8.cuda_nvcc\"\ncuda_nvcc.priority = 1\ncuda_nvcc.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ncudatoolkit.pkg-path = \"flox-cuda/cudaPackages_12_8.cudatoolkit\"\ncudatoolkit.priority = 3\ncudatoolkit.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n```\n\n### CUDA 11.x (Legacy Support)\n\n```toml\n[install]\ncuda_nvcc.pkg-path = \"flox-cuda/cudaPackages_11_8.cuda_nvcc\"\ncuda_nvcc.priority = 1\ncuda_nvcc.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ncudatoolkit.pkg-path = \"flox-cuda/cudaPackages_11_8.cudatoolkit\"\ncudatoolkit.priority = 3\ncudatoolkit.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n```\n\n## Cross-Platform GPU Development\n\nDual CUDA/CPU packages for portability (Linux gets CUDA, macOS gets CPU fallback):\n\n```toml\n[install]\n## CUDA packages (Linux only)\ncuda-pytorch.pkg-path = \"flox-cuda/python3Packages.torch\"\ncuda-pytorch.systems = [\"x86_64-linux\", \"aarch64-linux\"]\ncuda-pytorch.priority = 1\n\n## Non-CUDA packages (macOS + Linux fallback)\npytorch.pkg-path = \"python313Packages.pytorch\"\npytorch.systems = [\"x86_64-darwin\", \"aarch64-darwin\"]\npytorch.priority = 6                     # Lower priority\n```\n\n## GPU Detection Pattern\n\n**Dynamic CPU/GPU package installation in hooks:**\n\n```bash\nsetup_gpu_packages() {\n  venv=\"$FLOX_ENV_CACHE/venv\"\n\n  if [ ! -f \"$FLOX_ENV_CACHE/.deps_installed\" ]; then\n    if lspci 2>/dev/null | grep -E 'NVIDIA|AMD' > /dev/null; then\n      echo \"GPU detected, installing CUDA packages\"\n      uv pip install --python \"$venv/bin/python\" \\\n        torch torchvision --index-url https://download.pytorch.org/whl/cu129\n    else\n      echo \"No GPU detected, installing CPU packages\"\n      uv pip install --python \"$venv/bin/python\" \\\n        torch torchvision --index-url https://download.pytorch.org/whl/cpu\n    fi\n    touch \"$FLOX_ENV_CACHE/.deps_installed\"\n  fi\n}\n```\n\n## Complete CUDA Environment Examples\n\n### Basic CUDA Development\n\n```toml\n[install]\ncuda_nvcc.pkg-path = \"flox-cuda/cudaPackages_12_8.cuda_nvcc\"\ncuda_nvcc.priority = 1\ncuda_nvcc.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ncuda_cudart.pkg-path = \"flox-cuda/cudaPackages.cuda_cudart\"\ncuda_cudart.priority = 2\ncuda_cudart.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ngcc.pkg-path = \"gcc\"\ngcc-unwrapped.pkg-path = \"gcc-unwrapped\"\ngcc-unwrapped.priority = 5\n\n[vars]\nCUDA_VERSION = \"12.8\"\nCUDA_HOME = \"$FLOX_ENV\"\n\n[hook]\necho \"CUDA $CUDA_VERSION environment ready\"\necho \"nvcc: $(nvcc --version | grep release)\"\n```\n\n### Deep Learning with PyTorch\n\n```toml\n[install]\ncuda_nvcc.pkg-path = \"flox-cuda/cudaPackages_12_8.cuda_nvcc\"\ncuda_nvcc.priority = 1\ncuda_nvcc.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ncuda_cudart.pkg-path = \"flox-cuda/cudaPackages.cuda_cudart\"\ncuda_cudart.priority = 2\ncuda_cudart.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\nlibcublas.pkg-path = \"flox-cuda/cudaPackages_12_8.libcublas\"\nlibcublas.priority = 2\nlibcublas.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ncudnn.pkg-path = \"flox-cuda/cudaPackages_12_8.cudnn_9_11\"\ncudnn.priority = 2\ncudnn.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\npython313Full.pkg-path = \"python313Full\"\nuv.pkg-path = \"uv\"\ngcc-unwrapped.pkg-path = \"gcc-unwrapped\"\ngcc-unwrapped.priority = 5\n\n[vars]\nCUDA_VERSION = \"12.8\"\nPYTORCH_CUDA_ALLOC_CONF = \"max_split_size_mb:128\"\n\n[hook]\nsetup_pytorch_cuda() {\n  venv=\"$FLOX_ENV_CACHE/venv\"\n\n  if [ ! -d \"$venv\" ]; then\n    uv venv \"$venv\" --python python3\n  fi\n\n  if [ -f \"$venv/bin/activate\" ]; then\n    source \"$venv/bin/activate\"\n  fi\n\n  if [ ! -f \"$FLOX_ENV_CACHE/.deps_installed\" ]; then\n    uv pip install --python \"$venv/bin/python\" \\\n      torch torchvision torchaudio \\\n      --index-url https://download.pytorch.org/whl/cu129\n    touch \"$FLOX_ENV_CACHE/.deps_installed\"\n  fi\n}\n\nsetup_pytorch_cuda\n```\n\n### TensorFlow with CUDA\n\n```toml\n[install]\ncuda_nvcc.pkg-path = \"flox-cuda/cudaPackages_12_8.cuda_nvcc\"\ncuda_nvcc.priority = 1\ncuda_nvcc.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ncuda_cudart.pkg-path = \"flox-cuda/cudaPackages.cuda_cudart\"\ncuda_cudart.priority = 2\ncuda_cudart.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ncudnn.pkg-path = \"flox-cuda/cudaPackages_12_8.cudnn_9_11\"\ncudnn.priority = 2\ncudnn.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\npython313Full.pkg-path = \"python313Full\"\nuv.pkg-path = \"uv\"\n\n[hook]\nsetup_tensorflow() {\n  venv=\"$FLOX_ENV_CACHE/venv\"\n  [ ! -d \"$venv\" ] && uv venv \"$venv\" --python python3\n  [ -f \"$venv/bin/activate\" ] && source \"$venv/bin/activate\"\n\n  if [ ! -f \"$FLOX_ENV_CACHE/.tf_installed\" ]; then\n    uv pip install --python \"$venv/bin/python\" tensorflow[and-cuda]\n    touch \"$FLOX_ENV_CACHE/.tf_installed\"\n  fi\n}\n\nsetup_tensorflow\n```\n\n### Multi-GPU Development\n\n```toml\n[install]\ncuda_nvcc.pkg-path = \"flox-cuda/cudaPackages_12_8.cuda_nvcc\"\ncuda_nvcc.priority = 1\ncuda_nvcc.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\nnccl.pkg-path = \"flox-cuda/cudaPackages_12_8.nccl\"\nnccl.priority = 2\nnccl.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\nlibcublas.pkg-path = \"flox-cuda/cudaPackages_12_8.libcublas\"\nlibcublas.priority = 2\nlibcublas.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\n[vars]\nCUDA_VISIBLE_DEVICES = \"0,1,2,3\"  # All GPUs\nNCCL_DEBUG = \"INFO\"\n```\n\n## Modular CUDA Environments\n\n### Base CUDA Environment\n\n```toml\n# team/cuda-base\n[install]\ncuda_nvcc.pkg-path = \"flox-cuda/cudaPackages_12_8.cuda_nvcc\"\ncuda_nvcc.priority = 1\ncuda_nvcc.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ncuda_cudart.pkg-path = \"flox-cuda/cudaPackages.cuda_cudart\"\ncuda_cudart.priority = 2\ncuda_cudart.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\ngcc.pkg-path = \"gcc\"\ngcc-unwrapped.pkg-path = \"gcc-unwrapped\"\ngcc-unwrapped.priority = 5\n\n[vars]\nCUDA_VERSION = \"12.8\"\nCUDA_HOME = \"$FLOX_ENV\"\n```\n\n### CUDA Math Libraries\n\n```toml\n# team/cuda-math\n[include]\nenvironments = [{ remote = \"team/cuda-base\" }]\n\n[install]\nlibcublas.pkg-path = \"flox-cuda/cudaPackages_12_8.libcublas\"\nlibcublas.priority = 2\nlibcublas.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\nlibcufft.pkg-path = \"flox-cuda/cudaPackages_12_8.libcufft\"\nlibcufft.priority = 2\nlibcufft.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\nlibcurand.pkg-path = \"flox-cuda/cudaPackages_12_8.libcurand\"\nlibcurand.priority = 2\nlibcurand.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n```\n\n### CUDA Debugging Tools\n\n```toml\n# team/cuda-debug\n[install]\ncuda-gdb.pkg-path = \"flox-cuda/cudaPackages_12_8.cuda-gdb\"\ncuda-gdb.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\nnsight-systems.pkg-path = \"flox-cuda/cudaPackages_12_8.nsight-systems\"\nnsight-systems.systems = [\"aarch64-linux\", \"x86_64-linux\"]\n\n[vars]\nCUDA_LAUNCH_BLOCKING = \"1\"  # Synchronous kernel launches for debugging\n```\n\n### Layer for Development\n\n```bash\n# Base CUDA environment\nflox activate -r team/cuda-base\n\n# Add debugging tools when needed\nflox activate -r team/cuda-base -- flox activate -r team/cuda-debug\n```\n\n## Testing CUDA Installation\n\n### Verify CUDA Compiler\n\n```bash\nnvcc --version\n```\n\n### Check GPU Availability\n\n```bash\nnvidia-smi\n```\n\n### Compile Test Program\n\n```bash\ncat > hello_cuda.cu << 'EOF'\n#include <stdio.h>\n\n__global__ void hello() {\n    printf(\"Hello from GPU!\\n\");\n}\n\nint main() {\n    hello<<<1,1>>>();\n    cudaDeviceSynchronize();\n    return 0;\n}\nEOF\n\nnvcc hello_cuda.cu -o hello_cuda\n./hello_cuda\n```\n\n### Test PyTorch CUDA\n\n```python\nimport torch\nprint(f\"CUDA available: {torch.cuda.is_available()}\")\nprint(f\"CUDA version: {torch.version.cuda}\")\nprint(f\"GPU count: {torch.cuda.device_count()}\")\nif torch.cuda.is_available():\n    print(f\"GPU name: {torch.cuda.get_device_name(0)}\")\n```\n\n## Best Practices\n\n### Always Use Priority Values\nCUDA packages have predictable conflicts - assign explicit priorities\n\n### Version Consistency\nUse specific versions (e.g., `_12_8`) for reproducibility. Don't mix CUDA versions.\n\n### Modular Design\nSplit base CUDA, math libs, and debugging into separate environments for flexibility\n\n### Test Compilation\nVerify `nvcc hello.cu -o hello` works after setup\n\n### Platform Constraints\nAlways include `systems = [\"aarch64-linux\", \"x86_64-linux\"]`\n\n### Memory Management\nSet appropriate CUDA memory allocator configs:\n```toml\n[vars]\nPYTORCH_CUDA_ALLOC_CONF = \"max_split_size_mb:128\"\nCUDA_LAUNCH_BLOCKING = \"0\"  # Async by default\n```\n\n## Common CUDA Gotchas\n\n### CUDA Toolkit ≠ Complete Toolkit\nThe cudatoolkit package doesn't include all libraries. Add what you need:\n- libcublas for linear algebra\n- libcufft for FFT\n- cudnn for deep learning\n\n### License Conflicts\nEvery CUDA package may need explicit priority due to LICENSE file conflicts\n\n### No macOS Support\nCUDA is Linux-only. Use Metal-accelerated packages on Darwin when available\n\n### Version Mixing\nDon't mix CUDA versions. Use consistent `_X_Y` suffixes across all CUDA packages\n\n### Python Virtual Environments\nCUDA Python packages (PyTorch, TensorFlow) should be installed in venv with correct CUDA version\n\n### Driver Requirements\nEnsure NVIDIA driver supports your CUDA version. Check with `nvidia-smi`\n\n## Troubleshooting\n\n### CUDA Not Found\n\n```bash\n# Check CUDA_HOME\necho $CUDA_HOME\n\n# Check nvcc\nwhich nvcc\nnvcc --version\n\n# Check library paths\necho $LD_LIBRARY_PATH\n```\n\n### PyTorch Not Using GPU\n\n```python\nimport torch\nprint(torch.cuda.is_available())  # Should be True\nprint(torch.version.cuda)         # Should match your CUDA version\n\n# If False, reinstall with correct CUDA version\n# uv pip install torch --index-url https://download.pytorch.org/whl/cu129\n```\n\n### Compilation Errors\n\n```bash\n# Check gcc/g++ version\ngcc --version\ng++ --version\n\n# Ensure gcc-unwrapped is installed\nflox list | grep gcc-unwrapped\n\n# Check include paths\necho $CPATH\necho $LIBRARY_PATH\n```\n\n### Runtime Errors\n\n```bash\n# Check GPU visibility\necho $CUDA_VISIBLE_DEVICES\n\n# Check for GPU\nnvidia-smi\n\n# Run with debug output\nCUDA_LAUNCH_BLOCKING=1 python my_script.py\n```\n\n## Related Skills\n\n- **flox-environments** - Setting up development environments\n- **flox-sharing** - Composing CUDA base with project environments\n- **flox-containers** - Containerizing CUDA environments for deployment\n- **flox-services** - Running CUDA workloads as services"
              },
              {
                "name": "flox-environments",
                "description": "Manage reproducible development environments with Flox.  **ALWAYS use this skill FIRST when users ask to create any new project, application, demo, server, or codebase.** Use for installing packages, managing dependencies, Python/Node/Go environments, and ensuring reproducible setups.",
                "path": "flox-plugin/skills/flox-environments/SKILL.md",
                "frontmatter": {
                  "name": "flox-environments",
                  "description": "Manage reproducible development environments with Flox.  **ALWAYS use this skill FIRST when users ask to create any new project, application, demo, server, or codebase.** Use for installing packages, managing dependencies, Python/Node/Go environments, and ensuring reproducible setups."
                },
                "content": "# Flox Environments Guide\n\n## Working Style & Structure\n\n- Use **modular, idempotent bash functions** in hooks\n- Never, ever use absolute paths. Flox environments are designed to be reproducible. Use Flox's environment variables instead\n- I REPEAT: NEVER, EVER USE ABSOLUTE PATHS. Don't do it. Use `$FLOX_ENV` for environment-specific runtime dependencies; use `$FLOX_ENV_PROJECT` for the project directory\n- Name functions descriptively (e.g., `setup_postgres()`)\n- Consider using **gum** for styled output when creating environments for interactive use; this is an anti-pattern in CI\n- Put persistent data/configs in `$FLOX_ENV_CACHE`\n- Return to `$FLOX_ENV_PROJECT` at end of hooks\n- Use `mktemp` for temp files, clean up immediately\n- Do not over-engineer: e.g., do not create unnecessary echo statements or superfluous comments; do not print unnecessary information displays in `[hook]` or `[profile]`; do not create helper functions or aliases without the user requesting these explicitly\n\n## Configuration & Secrets\n\n- Support `VARIABLE=value flox activate` pattern for runtime overrides\n- Never store secrets in manifest; use:\n  - Environment variables\n  - `~/.config/<env_name>/` for persistent secrets\n  - Existing config files (e.g., `~/.aws/credentials`)\n\n## Flox Basics\n\n- Flox is built on Nix; fully Nix-compatible\n- Flox uses nixpkgs as its upstream; packages are _usually_ named the same; unlike nixpkgs, Flox Catalog has millions of historical package-version combinations\n- Key paths:\n  - `.flox/env/manifest.toml`: Environment definition\n  - `.flox/env.json`: Environment metadata\n  - `$FLOX_ENV_CACHE`: Persistent, local-only storage (survives `flox delete`)\n  - `$FLOX_ENV_PROJECT`: Project root directory (where .flox/ lives)\n  - `$FLOX_ENV`: basically the path to `/usr`: contains all the libs, includes, bins, configs, etc. available to a specific flox environment\n- Always use `flox init` to create environments\n- Manifest changes take effect on next `flox activate` (not live reload)\n\n## Core Commands\n\n```bash\nflox init                       # Create new env\nflox search <string> [--all]    # Search for a package\nflox show <pkg>                 # Show available historical versions of a package\nflox install <pkg>              # Add package\nflox list [-e | -c | -n | -a]   # List installed packages\nflox activate                   # Enter env\nflox activate -- <cmd>          # Run without subshell\nflox edit                       # Edit manifest interactively\n```\n\n## Manifest Structure\n\n- `[install]`: Package list with descriptors\n- `[vars]`: Static variables\n- `[hook]`: Non-interactive setup scripts\n- `[profile]`: Shell-specific functions/aliases\n- `[services]`: Service definitions (see flox-services skill)\n- `[build]`: Reproducible build commands (see flox-builds skill)\n- `[include]`: Compose other environments (see flox-sharing skill)\n- `[options]`: Activation mode, supported systems\n\n## The [install] Section\n\n### Package Installation Basics\n\nThe `[install]` table specifies packages to install.\n\n```toml\n[install]\nripgrep.pkg-path = \"ripgrep\"\npip.pkg-path = \"python310Packages.pip\"\n```\n\n### Package Descriptors\n\nEach entry has:\n- **Key**: Install ID (e.g., `ripgrep`, `pip`) - your reference name for the package\n- **Value**: Package descriptor - specifies what to install\n\n### Catalog Descriptors (Most Common)\n\nOptions for packages from the Flox catalog:\n\n```toml\n[install]\nexample.pkg-path = \"package-name\"           # Required: location in catalog\nexample.pkg-group = \"mygroup\"               # Optional: group packages together\nexample.version = \"1.2.3\"                   # Optional: exact or semver range\nexample.systems = [\"x86_64-linux\"]          # Optional: limit to specific platforms\nexample.priority = 3                        # Optional: resolve file conflicts (lower = higher priority)\n```\n\n#### Key Options Explained:\n\n**pkg-path** (required)\n- Location in the package catalog\n- Can be simple (`\"ripgrep\"`) or nested (`\"python310Packages.pip\"`)\n- Can use array format: `[\"python310Packages\", \"pip\"]`\n\n**pkg-group**\n- Groups packages that work well together\n- Packages without explicit group belong to default group\n- Groups upgrade together to maintain compatibility\n- Use different groups to avoid version conflicts\n\n**version**\n- Exact: `\"1.2.3\"`\n- Semver ranges: `\"^1.2\"`, `\">=2.0\"`\n- Partial versions act as wildcards: `\"1.2\"` = latest 1.2.X\n\n**systems**\n- Constrains package to specific platforms\n- Options: `\"x86_64-linux\"`, `\"x86_64-darwin\"`, `\"aarch64-linux\"`, `\"aarch64-darwin\"`\n- Defaults to manifest's `options.systems` if omitted\n\n**priority**\n- Resolves file conflicts between packages\n- Default: 5\n- Lower number = higher priority wins conflicts\n- **Critical for CUDA packages** (see flox-cuda skill)\n\n### Practical Examples\n\n```toml\n# Platform-specific Python\n[install]\npython.pkg-path = \"python311Full\"\nuv.pkg-path = \"uv\"\nsystems = [\"x86_64-linux\", \"aarch64-linux\"]  # Linux only\n\n# Version-pinned with custom priority\n[nodejs]\nnodejs.pkg-path = \"nodejs\"\nversion = \"^20.0\"\npriority = 1  # Takes precedence in conflicts\n\n# Multiple package groups to avoid conflicts\n[install]\ngcc.pkg-path = \"gcc12\"\ngcc.pkg-group = \"stable\"\n```\n\n## Language-Specific Patterns\n\n### Python Virtual Environments\n\n**venv creation pattern**: Always check existence before activation:\n```bash\nif [ ! -d \"$venv\" ]; then\n  uv venv \"$venv\" --python python3\nfi\n# Guard activation - venv creation might not be complete\nif [ -f \"$venv/bin/activate\" ]; then\n  source \"$venv/bin/activate\"\nfi\n```\n\n**Key patterns**:\n- **venv location**: Always use `$FLOX_ENV_CACHE/venv` - survives environment rebuilds\n- **uv with venv**: Use `uv pip install --python \"$venv/bin/python\"` NOT `\"$venv/bin/python\" -m uv`\n- **Cache dirs**: Set `UV_CACHE_DIR` and `PIP_CACHE_DIR` to `$FLOX_ENV_CACHE` subdirs\n- **Dependency installation flag**: Touch `$FLOX_ENV_CACHE/.deps_installed` to prevent reinstalls\n\n### C/C++ Development\n\n- **Package Names**: `gbenchmark` not `benchmark`, `catch2_3` for Catch2, `gcc13`/`clang_18` for specific versions\n- **System Constraints**: Linux-only tools need explicit systems: `valgrind.systems = [\"x86_64-linux\", \"aarch64-linux\"]`\n- **Essential Groups**: Separate `compilers`, `build`, `debug`, `testing`, `libraries` groups prevent conflicts\n- **libstdc++ Access**: ALWAYS include `gcc-unwrapped` for C++ stdlib headers/libs (gcc alone doesn't expose them):\n```toml\ngcc-unwrapped.pkg-path = \"gcc-unwrapped\"\ngcc-unwrapped.priority = 5\ngcc-unwrapped.pkg-group = \"libraries\"\n```\n\n### Node.js Development\n\n- **Package managers**: Install `nodejs` (includes npm); add `yarn` or `pnpm` separately if needed\n- **Version pinning**: Use `version = \"^20.0\"` for LTS, or exact versions for reproducibility\n- **Global tools pattern**: Use `npx` for one-off tools, install commonly-used globals in manifest\n\n### Platform-Specific Patterns\n\n```toml\n# Darwin-specific frameworks\nIOKit.pkg-path = \"darwin.apple_sdk.frameworks.IOKit\"\nIOKit.systems = [\"x86_64-darwin\", \"aarch64-darwin\"]\n\n# Platform-preferred compilers\ngcc.pkg-path = \"gcc\"\ngcc.systems = [\"x86_64-linux\", \"aarch64-linux\"]\nclang.pkg-path = \"clang\"\nclang.systems = [\"x86_64-darwin\", \"aarch64-darwin\"]\n\n# Darwin GNU compatibility layer\ncoreutils.pkg-path = \"coreutils\"\ncoreutils.systems = [\"x86_64-darwin\", \"aarch64-darwin\"]\n```\n\n## Best Practices\n\n- Check manifest before installing new packages\n- Use `return` not `exit` in hooks\n- Define env vars with `${VAR:-default}`\n- Use descriptive, prefixed function names in composed envs\n- Cache downloads in `$FLOX_ENV_CACHE`\n- Test activation with `flox activate -- <command>` before adding to services\n- Use `--quiet` flag with uv/pip in hooks to reduce noise\n\n## Editing Manifests Non-Interactively\n\n```bash\nflox list -c > /tmp/manifest.toml\n# Edit with sed/awk\nflox edit -f /tmp/manifest.toml\n```\n\n## Common Pitfalls\n\n### Hooks Run Every Activation\nHooks run EVERY activation (keep them fast/idempotent)\n\n### Hook vs Profile Functions\nHook functions are not available to users in the interactive shell; use `[profile]` for user-invokable commands/aliases\n\n### Profile Code in Layered Environments\nProfile code runs for each layered/composed environment; keep auto-run display logic in `[hook]` to avoid repetition\n\n### Manifest Syntax Errors\nManifest syntax errors prevent ALL flox commands from working\n\n### Package Search Case Sensitivity\nPackage search is case-sensitive; use `flox search --all` for broader results\n\n## Troubleshooting Tips\n\n### Package Conflicts\nIf packages conflict, use different `pkg-group` values or adjust `priority`\n\n### Tricky Dependencies\n- If we need `libstdc++`, we get this from the `gcc-unwrapped` package, not from `gcc`\n- If user is working with python and requests `uv`, they typically do not mean `uvicorn`; clarify which package user wants\n\n### Hook Issues\n- Use `return` not `exit` in hooks\n- Define env vars with `${VAR:-default}`\n- Guard FLOX_ENV_CACHE usage: `${FLOX_ENV_CACHE:-}` with fallback\n\n## Environment Layering\n\n### What is Layering?\n\n**Layering** is runtime stacking of environments where activate order matters. Each layer runs in its own subshell, preserving isolation while allowing tool composition.\n\n### Core Layering Commands\n\n```bash\n# Layer debugging tools on base environment\nflox activate -r team/base -- flox activate -r team/debug\n\n# Layer multiple environments\nflox activate -r team/db -- flox activate -r team/cache -- flox activate\n\n# Layer local on remote\nflox activate -r prod/app -- flox activate\n```\n\n### When to Use Layering\n\n- **Ad hoc tool addition**: Add debugging/profiling tools temporarily\n- **Development vs production**: Layer dev tools on production environment\n- **Flexible composition**: Mix and match environments at runtime\n- **Temporary utilities**: Add one-time tools without modifying environment\n\n### Layering Use Cases\n\n**Development tools on production environment:**\n```bash\nflox activate -r prod/app -- flox activate -r dev/tools\n```\n\n**Debugging tools on CUDA environment:**\n```bash\nflox activate -r team/cuda-base -- flox activate -r team/cuda-debug\n```\n\n**Temporary utilities:**\n```bash\nflox activate -r project/main -- flox activate -r utils/network\n```\n\n### Creating Layer-Optimized Environments\n\n**Design for runtime stacking with potential conflicts:**\n\n```toml\n[vars]\n# Prefix vars to avoid masking\nMYAPP_PORT = \"8080\"\nMYAPP_HOST = \"localhost\"\n\n[profile.common]\n# Use unique, prefixed function names\nmyapp_setup() { ... }\nmyapp_debug() { ... }\n\n[services.myapp-db]  # Prefix service names\ncommand = \"...\"\n```\n\n**Best practices for layerable environments:**\n- Single responsibility per environment\n- Expect vars/binaries might be overridden by upper layers\n- Document what the environment provides/expects\n- Keep hooks fast and idempotent\n- Use prefixed names to avoid collisions\n\n## Related Skills\n\n- **flox-services** - Running services and background processes\n- **flox-builds** - Building and packaging applications\n- **flox-publish** - Publishing packages to catalogs\n- **flox-sharing** - Environment composition and layering\n- **flox-containers** - Containerizing environments\n- **flox-cuda** - CUDA/GPU development environments"
              },
              {
                "name": "flox-publish",
                "description": "Use for publishing user packages to flox for use in Flox environments.  Use for package distribution and sharing of builds defined in a flox environment.",
                "path": "flox-plugin/skills/flox-publish/SKILL.md",
                "frontmatter": {
                  "name": "flox-publish",
                  "description": "Use for publishing user packages to flox for use in Flox environments.  Use for package distribution and sharing of builds defined in a flox environment."
                },
                "content": "# Flox Package Publishing Guide\n\n## Core Commands\n\n```bash\nflox publish                    # Publish all packages\nflox publish my_package         # Publish single package\nflox publish -o myorg package   # Publish to organization\nflox publish -o myuser package  # Publish to personal namespace\nflox auth login                 # Authenticate before publishing\n```\n\n## Publishing Workflow: Development to Runtime\n\nPublishing packages enables a clear separation between **development** and **runtime/consumption**:\n\n### The Complete Workflow\n\n**Phase 1: Development Environment**\n```toml\n# .flox/env/manifest.toml (in git with source code)\n[install]\ngcc.pkg-path = \"gcc13\"\nmake.pkg-path = \"make\"\npython.pkg-path = \"python311Full\"\n\n[build.myapp]\ncommand = '''\n  python setup.py build\n  mkdir -p $out/bin\n  cp build/myapp $out/bin/\n'''\nversion = \"1.0.0\"\n```\n\nDevelopers work in this environment, commit `.flox/` to git alongside source code.\n\n**Phase 2: Build and Publish**\n```bash\n# Build the package\nflox build myapp\n\n# Publish to catalog\nflox publish -o myorg myapp\n```\n\nThe published package contains BINARIES/ARTIFACTS (what's in `$out/`), NOT source code.\n\n**Phase 3: Runtime Environment**\n```toml\n# Separate environment (can be pushed to FloxHub)\n[install]\nmyapp.pkg-path = \"myorg/myapp\"  # The published package\n```\n\nConsumers create runtime environments and install the published package. No build tools needed, no source code exposed.\n\n**Key insight**: You don't install the published package back into the development environment - that would be circular. Published packages are installed into OTHER environments (different projects, production, etc.).\n\n## Publishing to Flox Catalog\n\n### Prerequisites\nBefore publishing:\n- Package defined in `[build]` section or `.flox/pkgs/`\n- Environment in Git repo with configured remote\n- Clean working tree (no uncommitted changes)\n- Current commit pushed to remote\n- All build files tracked by Git\n- At least one package installed in `[install]`\n\n### Authentication\n\nRun authentication before first publish:\n```bash\nflox auth login\n```\n\n### Publishing Commands\n\n```bash\n# Publish single package\nflox publish my_package\n\n# Publish all packages\nflox publish\n\n# Publish to organization\nflox publish -o myorg my_package\n\n# Publish to personal namespace (for testing)\nflox publish -o mypersonalhandle my_package\n```\n\n### Catalog Types\n\n**Personal catalogs**: Only visible to you (good for testing)\n- Published to your personal namespace\n- Example: User \"alice\" publishes \"hello\" → available as `alice/hello`\n- Useful for testing before publishing to organization\n\n**Organization catalogs**: Shared with team members (paid feature)\n- Published to organization namespace\n- Example: Org \"acme\" publishes \"tool\" → available as `acme/tool`\n- All organization members can install\n\n### Build Validation\n\nFlox clones your repo to a temp location and performs a clean build to ensure reproducibility. Only packages that build successfully in this clean environment can be published.\n\nThis validation ensures:\n- All dependencies are declared\n- Build is reproducible\n- No reliance on local machine state\n- Git repository is clean and up-to-date\n\n### After Publishing\n\n- Package available in `flox search`, `flox show`, `flox install`\n- Metadata sent to Flox servers\n- Package binaries uploaded to Catalog Store\n- Install with: `flox install <catalog>/<package>`\n\nUsers can then:\n```bash\n# Search for your package\nflox search my_package\n\n# See package details\nflox show myorg/my_package\n\n# Install the package\nflox install myorg/my_package\n```\n\n### What Gets Published\n\n**Published packages contain:**\n- Binaries and compiled artifacts (everything in `$out/`)\n- Runtime dependencies specified in `runtime-packages`\n- Package metadata (version, description)\n\n**Published packages do NOT contain:**\n- Source code (unless explicitly copied to `$out/`)\n- Build tools or build-time dependencies\n- Development environment configuration\n- The `.flox/` directory itself\n\nThis separation allows you to share built artifacts without exposing source code.\n\n## Real-world Publishing Workflows\n\n### Application Development Workflow\n\n**Developer workflow:**\n1. Create development environment with build tools:\n   ```bash\n   mkdir myapp && cd myapp\n   flox init\n   flox install gcc make python311Full\n   ```\n\n2. Add source code and build definition to `.flox/env/manifest.toml`:\n   ```toml\n   [build.myapp]\n   command = '''make && cp myapp $out/bin/'''\n   version = \"1.0.0\"\n   ```\n\n3. Commit to git (environment definition + source code):\n   ```bash\n   git add .flox/ src/\n   git commit -m \"Add development environment and source\"\n   git push origin main\n   ```\n\n4. Build and publish package (binaries/artifacts):\n   ```bash\n   flox build myapp\n   flox publish -o myorg myapp\n   ```\n\n**Other developers:**\n- Clone repo: `git clone <repo> && cd myapp && flox activate`\n- Get the same development environment with build tools\n\n**Consumers:**\n- Create new runtime environment: `flox init && flox install myorg/myapp`\n- OR install into existing environment: `flox install myorg/myapp`\n- Get the BUILT package (binaries), not source code\n- Can push runtime environment to FloxHub without exposing source\n\n### Fork-based Development Pattern\n\n1. Fork upstream repo (e.g., `user/project` from `upstream/project`)\n2. Add `.flox/` to fork with build definitions\n3. Commit and push: `git push origin main`\n4. Publish package: `flox publish -o username package-name`\n5. Others can install: `flox install username/package-name`\n\n## Versioning Strategies\n\n### Semantic Versioning\n\n```toml\n[build.mytool]\nversion = \"1.2.3\"  # Major.Minor.Patch\ndescription = \"My awesome tool\"\n```\n\n### Git-based Versioning\n\n```toml\n[build.mytool]\nversion.command = \"git describe --tags\"\ndescription = \"My awesome tool\"\n```\n\n### File-based Versioning\n\n```toml\n[build.mytool]\nversion.file = \"VERSION.txt\"\ndescription = \"My awesome tool\"\n```\n\n### Dynamic Versioning from Source\n\n```toml\n[build.rustapp]\nversion.command = \"cargo metadata --no-deps --format-version 1 | jq -r '.packages[0].version'\"\n```\n\n## Publishing Multiple Variants\n\nYou can publish multiple variants of the same project:\n\n```toml\n[build.myapp]\ncommand = '''\n  cargo build --release\n  mkdir -p $out/bin\n  cp target/release/myapp $out/bin/\n'''\nversion = \"1.0.0\"\ndescription = \"Production build\"\nsandbox = \"pure\"\n\n[build.myapp-debug]\ncommand = '''\n  cargo build\n  mkdir -p $out/bin\n  cp target/debug/myapp $out/bin/myapp-debug\n'''\nversion = \"1.0.0\"\ndescription = \"Debug build with symbols\"\nsandbox = \"off\"\n```\n\nBoth can be published and users can choose which to install.\n\n## Testing Before Publishing\n\n### Local Testing\n\n1. Build the package:\n```bash\nflox build myapp\n```\n\n2. Test the built artifact:\n```bash\n./result-myapp/bin/myapp --version\n```\n\n3. Install locally to test:\n```bash\nflox install ./result-myapp\n```\n\n### Personal Catalog Testing\n\nPublish to your personal namespace first:\n```bash\nflox publish -o myusername myapp\n```\n\nThen test installation:\n```bash\nflox install myusername/myapp\n```\n\nOnce validated, republish to organization:\n```bash\nflox publish -o myorg myapp\n```\n\n## Common Gotchas\n\n### Branch names\nMany repos use `master` not `main` - check with `git branch`\n\n### Auth required\nRun `flox auth login` before first publish\n\n### Clean git state\nCommit and push ALL changes before `flox publish`:\n```bash\ngit status  # Check for uncommitted changes\ngit add .flox/\ngit commit -m \"Add flox build configuration\"\ngit push origin master\n```\n\n### runtime-packages\nList only what package needs at runtime, not build deps:\n```toml\n[install]\ngcc.pkg-path = \"gcc\"\nmake.pkg-path = \"make\"\n\n[build.myapp]\ncommand = '''make && cp myapp $out/bin/'''\nruntime-packages = []  # No runtime deps needed\n```\n\n### Git-tracked files only\nAll files referenced in build must be tracked:\n```bash\ngit add .flox/pkgs/*\ngit add src/\ngit commit -m \"Add build files\"\n```\n\n## Publishing Nix Expression Builds\n\nFor Nix expression builds in `.flox/pkgs/`:\n\n1. Create the Nix expression:\n```bash\nmkdir -p .flox/pkgs\ncat > .flox/pkgs/hello.nix << 'EOF'\n{ hello }:\nhello.overrideAttrs (oldAttrs: {\n  patches = (oldAttrs.patches or []) ++ [ ./my.patch ];\n})\nEOF\n```\n\n2. Track with Git:\n```bash\ngit add .flox/pkgs/*\ngit commit -m \"Add hello package\"\ngit push\n```\n\n3. Publish:\n```bash\nflox publish hello\n```\n\n## Publishing Configuration and Assets\n\nYou can publish non-code artifacts:\n\n### Configuration templates\n\n```toml\n[build.nginx-config]\ncommand = '''\n  mkdir -p $out/etc\n  cp nginx.conf $out/etc/\n  cp -r conf.d $out/etc/\n'''\nversion = \"1.0.0\"\ndescription = \"Organization Nginx configuration\"\n```\n\n### Protocol buffers\n\n```toml\n[build.api-proto]\ncommand = '''\n  mkdir -p $out/share/proto\n  cp proto/**/*.proto $out/share/proto/\n'''\nversion = \"2.1.0\"\ndescription = \"API protocol definitions\"\n```\n\nTeams install and reference via `$FLOX_ENV/etc/` or `$FLOX_ENV/share/`.\n\n## Continuous Integration Publishing\n\n### GitHub Actions Example\n\n```yaml\nname: Publish to Flox\n\non:\n  push:\n    tags:\n      - 'v*'\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install Flox\n        run: |\n          curl -fsSL https://downloads.flox.dev/by-env/stable/install | bash\n\n      - name: Authenticate\n        env:\n          FLOX_AUTH_TOKEN: ${{ secrets.FLOX_AUTH_TOKEN }}\n        run: flox auth login --token \"$FLOX_AUTH_TOKEN\"\n\n      - name: Publish package\n        run: flox publish -o myorg mypackage\n```\n\n### GitLab CI Example\n\n```yaml\npublish:\n  stage: deploy\n  only:\n    - tags\n  script:\n    - curl -fsSL https://downloads.flox.dev/by-env/stable/install | bash\n    - flox auth login --token \"$FLOX_AUTH_TOKEN\"\n    - flox publish -o myorg mypackage\n```\n\n## Package Metadata Best Practices\n\n### Good Descriptions\n\n```toml\n[build.cli]\ndescription = \"High-performance log shipper with filtering\"  # Good: specific, descriptive\n\n# Avoid:\n# description = \"My tool\"  # Too vague\n# description = \"CLI\"      # Not descriptive enough\n```\n\n### Proper Versioning\n\n- Use semantic versioning: MAJOR.MINOR.PATCH\n- Increment MAJOR for breaking changes\n- Increment MINOR for new features\n- Increment PATCH for bug fixes\n\n### Runtime Dependencies\n\nOnly include what's actually needed at runtime:\n\n```toml\n[install]\n# Build-time only\ngcc.pkg-path = \"gcc\"\nmake.pkg-path = \"make\"\n# Runtime dependency\nlibssl.pkg-path = \"openssl\"\n\n[build.myapp]\nruntime-packages = [\"libssl\"]  # Only runtime deps\n```\n\n## Related Skills\n\n- **flox-builds** - Building packages before publishing, dual-environment workflow\n- **flox-environments** - Setting up development and runtime environments\n- **flox-sharing** - Sharing environment definitions (via git or FloxHub) vs publishing packages (binaries/artifacts)"
              },
              {
                "name": "flox-services",
                "description": "Running services and background processes in Flox environments. Use for service configuration, network services, logging, database setup, and service debugging.",
                "path": "flox-plugin/skills/flox-services/SKILL.md",
                "frontmatter": {
                  "name": "flox-services",
                  "description": "Running services and background processes in Flox environments. Use for service configuration, network services, logging, database setup, and service debugging."
                },
                "content": "# Flox Services Guide\n\n## Running Services in Flox Environments\n\n- Start with `flox activate --start-services` or `flox activate -s`\n- Define `is-daemon`, `shutdown.command` for background processes\n- Keep services running using `tail -f /dev/null`\n- Use `flox services status/logs/restart` to manage (must be in activated env)\n- Service commands don't inherit hook activations; explicitly source/activate what you need\n\n## Core Commands\n\n```bash\nflox activate -s                # Start services\nflox services status            # Check service status\nflox services logs <service>    # View service logs\nflox services restart <service> # Restart a service\nflox services stop <service>    # Stop a service\n```\n\n## Network Services Pattern\n\nAlways make host/port configurable via vars:\n\n```toml\n[services.webapp]\ncommand = '''exec app --host \"$APP_HOST\" --port \"$APP_PORT\"'''\n\n[vars]\nAPP_HOST = \"0.0.0.0\"  # Network-accessible\nAPP_PORT = \"8080\"\n```\n\n## Service Logging Pattern\n\nAlways pipe to `$FLOX_ENV_CACHE/logs/` for debugging:\n\n```toml\n[services.myapp]\ncommand = '''\n  mkdir -p \"$FLOX_ENV_CACHE/logs\"\n  exec app 2>&1 | tee -a \"$FLOX_ENV_CACHE/logs/app.log\"\n'''\n```\n\n## Python venv Pattern for Services\n\nServices must activate venv independently:\n\n```toml\n[services.myapp]\ncommand = '''\n  [ -f \"$FLOX_ENV_CACHE/venv/bin/activate\" ] && \\\n    source \"$FLOX_ENV_CACHE/venv/bin/activate\"\n  exec python-app \"$@\"\n'''\n```\n\nOr use venv Python directly:\n\n```toml\n[services.myapp]\ncommand = '''exec \"$FLOX_ENV_CACHE/venv/bin/python\" app.py'''\n```\n\n## Using Packaged Services\n\nOverride package's service by redefining with same name.\n\n## Database Service Examples\n\n### PostgreSQL\n\n```toml\n[services.postgres]\ncommand = '''\n  mkdir -p \"$FLOX_ENV_CACHE/postgres\"\n  if [ ! -d \"$FLOX_ENV_CACHE/postgres/data\" ]; then\n    initdb -D \"$FLOX_ENV_CACHE/postgres/data\"\n  fi\n  exec postgres -D \"$FLOX_ENV_CACHE/postgres/data\" \\\n    -k \"$FLOX_ENV_CACHE/postgres\" \\\n    -h \"$POSTGRES_HOST\" \\\n    -p \"$POSTGRES_PORT\"\n'''\nis-daemon = true\n\n[vars]\nPOSTGRES_HOST = \"localhost\"\nPOSTGRES_PORT = \"5432\"\nPOSTGRES_USER = \"myuser\"\nPOSTGRES_DB = \"mydb\"\n```\n\n### Redis\n\n```toml\n[services.redis]\ncommand = '''\n  mkdir -p \"$FLOX_ENV_CACHE/redis\"\n  exec redis-server \\\n    --bind \"$REDIS_HOST\" \\\n    --port \"$REDIS_PORT\" \\\n    --dir \"$FLOX_ENV_CACHE/redis\"\n'''\nis-daemon = true\n\n[vars]\nREDIS_HOST = \"127.0.0.1\"\nREDIS_PORT = \"6379\"\n```\n\n### MongoDB\n\n```toml\n[services.mongodb]\ncommand = '''\n  mkdir -p \"$FLOX_ENV_CACHE/mongodb\"\n  exec mongod \\\n    --dbpath \"$FLOX_ENV_CACHE/mongodb\" \\\n    --bind_ip \"$MONGODB_HOST\" \\\n    --port \"$MONGODB_PORT\"\n'''\nis-daemon = true\n\n[vars]\nMONGODB_HOST = \"127.0.0.1\"\nMONGODB_PORT = \"27017\"\n```\n\n## Web Server Examples\n\n### Node.js Development Server\n\n```toml\n[services.dev-server]\ncommand = '''\n  exec npm run dev -- --host \"$DEV_HOST\" --port \"$DEV_PORT\"\n'''\n\n[vars]\nDEV_HOST = \"0.0.0.0\"\nDEV_PORT = \"3000\"\n```\n\n### Python Flask/FastAPI\n\n```toml\n[services.api]\ncommand = '''\n  source \"$FLOX_ENV_CACHE/venv/bin/activate\"\n  exec python -m uvicorn main:app \\\n    --host \"$API_HOST\" \\\n    --port \"$API_PORT\" \\\n    --reload\n'''\n\n[vars]\nAPI_HOST = \"0.0.0.0\"\nAPI_PORT = \"8000\"\n```\n\n### Simple HTTP Server\n\n```toml\n[services.web]\ncommand = '''exec python -m http.server \"$WEB_PORT\"'''\n\n[vars]\nWEB_PORT = \"8000\"\n```\n\n## Environment Variable Convention\n\nUse variables like `POSTGRES_HOST`, `POSTGRES_PORT` to define where services run.\n\nThese store connection details *separately*:\n- `*_HOST` is the hostname or IP address (e.g., `localhost`, `db.example.com`)\n- `*_PORT` is the network port number (e.g., `5432`, `6379`)\n\nThis pattern ensures users can override them at runtime:\n```bash\nPOSTGRES_HOST=db.internal POSTGRES_PORT=6543 flox activate -s\n```\n\nUse consistent naming across services so the meaning is clear to any system or person reading the variables.\n\n## Service with Shutdown Command\n\n```toml\n[services.myapp]\ncommand = '''exec myapp start'''\nis-daemon = true\n\n[services.myapp.shutdown]\ncommand = '''myapp stop'''\n```\n\n## Dependent Services\n\nServices can wait for other services to be ready:\n\n```toml\n[services.db]\ncommand = '''exec postgres -D \"$FLOX_ENV_CACHE/postgres\"'''\nis-daemon = true\n\n[services.api]\ncommand = '''\n  # Wait for database\n  until pg_isready -h localhost -p 5432; do\n    sleep 1\n  done\n  exec python -m uvicorn main:app\n'''\n\n[vars]\nPOSTGRES_HOST = \"localhost\"\nPOSTGRES_PORT = \"5432\"\n```\n\n## Service Health Checks\n\n```toml\n[services.api]\ncommand = '''\n  # Health check function\n  health_check() {\n    curl -sf http://localhost:8000/health > /dev/null\n  }\n\n  exec python -m uvicorn main:app --host 0.0.0.0 --port 8000\n'''\n```\n\n## Best Practices\n\n- Log service output to `$FLOX_ENV_CACHE/logs/`\n- Test activation with `flox activate -- <command>` before adding to services\n- When debugging services, run the exact command from manifest manually first\n- Always make host/port configurable via vars for network services\n- Use `exec` to replace the shell process with the service command\n- Services must activate venv inside service command, not rely on hook activation\n- Use `is-daemon = true` for background processes that should detach\n\n## Debugging Service Issues\n\n### Check Service Status\n```bash\nflox services status\n```\n\n### View Service Logs\n```bash\nflox services logs myservice\n```\n\n### Run Service Command Manually\n```bash\nflox activate\n# Copy the exact command from manifest and run it\n```\n\n### Check if Service is Listening\n```bash\n# Check if port is open\nlsof -i :8000\nnetstat -an | grep 8000\n\n# Test connection\ncurl http://localhost:8000\nnc -zv localhost 8000\n```\n\n## Common Pitfalls\n\n### Services Don't Preserve State\nServices see fresh environment (no preserved state between restarts). Store persistent data in `$FLOX_ENV_CACHE`.\n\n### Service Commands Don't Inherit Hook Activations\nExplicitly source/activate what you need inside the service command.\n\n### Forgetting to Create Directories\nAlways `mkdir -p` for data directories in service commands.\n\n### Port Conflicts\nUse configurable ports via variables to avoid conflicts with other services.\n\n## Related Skills\n\n- **flox-environments** - Environment basics and package installation\n- **flox-sharing** - Composing environments with shared services\n- **flox-containers** - Running services in containers"
              },
              {
                "name": "flox-sharing",
                "description": "Sharing and composing Flox environments. Use for environment composition, remote environments, FloxHub, and team collaboration patterns.",
                "path": "flox-plugin/skills/flox-sharing/SKILL.md",
                "frontmatter": {
                  "name": "flox-sharing",
                  "description": "Sharing and composing Flox environments. Use for environment composition, remote environments, FloxHub, and team collaboration patterns."
                },
                "content": "# Flox Environment Sharing & Composition Guide\n\n## Core Concepts\n\n**Composition**: Build-time merging of environments (deterministic)\n**Remote Environments**: Shared environments via FloxHub\n**Team Collaboration**: Reusable, shareable environment stacks\n\n## Understanding Environment Sharing\n\n**The `.flox/` directory contains the environment definition**:\n- Package specifications and versions\n- Environment variables\n- Build definitions\n- Hooks and services configuration\n\n**The environment definition does NOT include**:\n- Built binaries/artifacts (those are created by builds and can be published as packages)\n- Local data or cache\n\n**Two sharing mechanisms**:\n1. **Git**: Commit `.flox/` directory to git. When used with development environments, this is typically alongside your source code in the same repository. Other developers clone the repo and get both the environment definition and source code.\n2. **FloxHub**: Push environment definition only using `flox push`. This shares ONLY the `.flox/` directory, not any source code or other files. Useful for runtime environments or shared base environments used across multiple projects.\n\n**This is different from publishing packages** (see **flox-publish** skill), where you build and distribute the actual binaries/artifacts.\n\n## Core Commands\n\n```bash\n# Activate remote environment\nflox activate -r owner/environment-name\n\n# Pull remote environment locally\nflox pull owner/environment-name\n\n# Push local environment to FloxHub\nflox push\n\n# Compose environments in manifest\n# (see [include] section below)\n```\n\n## Environment Composition\n\n### Basic Composition\n\nMerge environments at build time using `[include]`:\n\n```toml\n[include]\nenvironments = [\n    { remote = \"team/postgres\" },\n    { remote = \"team/redis\" },\n    { remote = \"team/python-base\" }\n]\n```\n\n### Creating Composition-Optimized Environments\n\n**Design for clean merging at build time:**\n\n```toml\n[install]\n# Use pkg-groups to prevent conflicts\ngcc.pkg-path = \"gcc\"\ngcc.pkg-group = \"compiler\"\n\n[vars]\n# Never duplicate var names across composed envs\nPOSTGRES_PORT = \"5432\"  # Not \"PORT\"\n\n[hook]\n# Check if setup already done (idempotent)\nsetup_postgres() {\n  [ -d \"$FLOX_ENV_CACHE/postgres\" ] || init_db\n}\n```\n\n**Best practices:**\n- No overlapping vars, services, or function names\n- Use explicit, namespaced naming (e.g., `postgres_init` not `init`)\n- Minimal hook logic (composed envs run ALL hooks)\n- Avoid auto-run logic in `[profile]` (runs once per layer/composition; help displays will repeat)\n- Test composability: `flox activate` each env standalone first\n\n### Composition Example: Full Stack\n\n```toml\n# .flox/env/manifest.toml\n[include]\nenvironments = [\n    { remote = \"team/postgres\" },\n    { remote = \"team/redis\" },\n    { remote = \"team/nodejs\" },\n    { remote = \"team/monitoring\" }\n]\n\n[vars]\n# Override composed environment variables\nPOSTGRES_HOST = \"localhost\"\nPOSTGRES_PORT = \"5433\"  # Non-standard port\n```\n\n### Use Cases for Composition\n\n**Reproducible stacks:**\n```toml\n[include]\nenvironments = [\n    { remote = \"team/cuda-base\" },\n    { remote = \"team/cuda-math\" },\n    { remote = \"team/python-ml\" }\n]\n```\n\n**Shared base configuration:**\n```toml\n[include]\nenvironments = [\n    { remote = \"org/standards\" },  # Company-wide settings\n    { remote = \"team/backend\" }    # Team-specific tools\n]\n```\n\n## Creating Dual-Purpose Environments\n\n**Design for both layering and composition:**\n\n```toml\n[install]\n# Clear package groups\npython.pkg-path = \"python311\"\npython.pkg-group = \"runtime\"\n\n[vars]\n# Namespace everything\nMYPROJECT_VERSION = \"1.0\"\nMYPROJECT_CONFIG = \"$FLOX_ENV_CACHE/config\"\n\n[profile.common]\n# Defensive function definitions\nif ! type myproject_init >/dev/null 2>&1; then\n  myproject_init() { ... }\nfi\n```\n\n## Remote Environments\n\n### Activating Remote Environments\n\n```bash\n# Activate remote environment directly\nflox activate -r owner/environment-name\n\n# Activate and run a command\nflox activate -r owner/environment-name -- npm test\n```\n\n### Pulling Remote Environments\n\n```bash\n# Pull to work on locally\nflox pull owner/environment-name\n\n# Now it's in your local .flox/\nflox activate\n```\n\n### Pushing Environments to FloxHub\n\n```bash\n# Initialize Git repo if needed\ngit init\ngit add .flox/\ngit commit -m \"Initial environment\"\n\n# Push to FloxHub\nflox push\n\n# Others can now activate with:\n# flox activate -r yourusername/your-repo\n```\n\n### Choosing Between Git and FloxHub\n\n**Commit `.flox/` to Git when:**\n- Environment is for development (includes build tools)\n- Environment lives alongside source code\n- You want version control history for environment changes\n- Team already uses git for collaboration\n\n**Push to FloxHub when:**\n- Environment is for runtime/production (no source code needed)\n- Creating shared base environments used across multiple projects\n- Environment needs to be independently versioned from source code\n- You want to share environment without exposing source code\n\n**Recommended pattern**: Commit development environments to git with source code; push runtime environments to FloxHub.\n\n## Team Collaboration Patterns\n\n### Base + Specialization\n\n**Create base environment:**\n```toml\n# team/base\n[install]\ngit.pkg-path = \"git\"\ngh.pkg-path = \"gh\"\njq.pkg-path = \"jq\"\n\n[vars]\nORG_REGISTRY = \"registry.company.com\"\n```\n\n**Specialize for teams:**\n```toml\n# team/frontend\n[include]\nenvironments = [{ remote = \"team/base\" }]\n\n[install]\nnodejs.pkg-path = \"nodejs\"\npnpm.pkg-path = \"pnpm\"\n```\n\n```toml\n# team/backend\n[include]\nenvironments = [{ remote = \"team/base\" }]\n\n[install]\npython.pkg-path = \"python311Full\"\nuv.pkg-path = \"uv\"\n```\n\n### Service Libraries\n\n**Create reusable service environments:**\n\n```toml\n# team/postgres-service\n[install]\npostgresql.pkg-path = \"postgresql\"\n\n[services.postgres]\ncommand = '''\n  mkdir -p \"$FLOX_ENV_CACHE/postgres\"\n  if [ ! -d \"$FLOX_ENV_CACHE/postgres/data\" ]; then\n    initdb -D \"$FLOX_ENV_CACHE/postgres/data\"\n  fi\n  exec postgres -D \"$FLOX_ENV_CACHE/postgres/data\" \\\n    -h \"$POSTGRES_HOST\" -p \"$POSTGRES_PORT\"\n'''\nis-daemon = true\n\n[vars]\nPOSTGRES_HOST = \"localhost\"\nPOSTGRES_PORT = \"5432\"\n```\n\n**Compose into projects:**\n```toml\n# my-project\n[include]\nenvironments = [\n    { remote = \"team/postgres-service\" },\n    { remote = \"team/redis-service\" }\n]\n```\n\n### Development vs Runtime Environments\n\n**Development environment (for building):**\n```toml\n# project-dev (committed to git with source code)\n[install]\ngcc.pkg-path = \"gcc13\"\nmake.pkg-path = \"make\"\ndebugpy.pkg-path = \"python311Packages.debugpy\"\npytest.pkg-path = \"python311Packages.pytest\"\n\n[build.myapp]\ncommand = '''\n  make release\n  mkdir -p $out/bin\n  cp build/myapp $out/bin/\n'''\nversion = \"1.0.0\"\n\n[vars]\nDEBUG = \"true\"\nLOG_LEVEL = \"debug\"\n```\n\nDevelopers commit this `.flox/` directory to git with the source code. Other developers `git clone` and `flox activate` to get the same development environment.\n\n**Runtime environment (for consuming):**\n```toml\n# project-runtime (pushed to FloxHub, no source code)\n[install]\nmyapp.pkg-path = \"myorg/myapp\"  # Published package, not source\n\n[vars]\nDEBUG = \"false\"\nLOG_LEVEL = \"info\"\nMYAPP_CONFIG = \"$FLOX_ENV_CACHE/config\"\n```\n\nAfter publishing `myapp`, consumers create this runtime environment and install the published package. The runtime environment can be pushed to FloxHub and shared without exposing source code.\n\n**Key distinction**: Development environments contain build tools and source code; runtime environments contain published packages (binaries/artifacts).\n\n(See **flox-environments** skill for layering environments at runtime)\n\n## Composition with Local Packages\n\nCombine composed environments with local packages:\n\n```toml\n# Compose base services\n[include]\nenvironments = [\n    { remote = \"team/database-services\" },\n    { remote = \"team/cache-services\" }\n]\n\n# Add project-specific packages\n[install]\nmyapp.pkg-path = \"company/myapp\"\n```\n\nSee **flox-environments** skill for layering environments at runtime.\n\n## Best Practices\n\n### For Shareable Environments\n\n1. **Use descriptive names**: `team/postgres-service` not `db`\n2. **Document expectations**: What vars/ports/services are provided\n3. **Namespace everything**: Prefix vars, functions, services\n4. **Keep focused**: One responsibility per environment\n5. **Test standalone**: `flox activate` should work without composition\n\n### For Composed Environments\n\n1. **No name collisions**: Check for overlapping vars/services\n2. **Idempotent hooks**: Can run multiple times safely\n3. **Minimal auto-run**: Avoid output in `[profile]`\n4. **Clear dependencies**: Document what environments are needed\n\n(For layering best practices, see **flox-environments** skill)\n\n## Version Management\n\n### Pin Specific Versions\n\n```toml\n[include]\nenvironments = [\n    { remote = \"team/base\", version = \"v1.2.3\" }\n]\n```\n\n### Use Latest\n\n```toml\n[include]\nenvironments = [\n    { remote = \"team/base\" }  # Uses latest\n]\n```\n\n## Troubleshooting\n\n### Conflicts in Composition\n\nIf composed environments conflict:\n1. Use different `pkg-group` values\n2. Adjust `priority` for file conflicts\n3. Namespace variables to avoid collisions\n4. Test each environment standalone first\n\n(For layering troubleshooting, see **flox-environments** skill)\n\n### Remote Environment Not Found\n\n```bash\n# Check available remote environments\nflox search --remote owner/\n\n# Pull and inspect locally\nflox pull owner/environment-name\nflox list -c\n```\n\n## Related Skills\n\n- **flox-environments** - Creating base environments\n- **flox-services** - Sharing service configurations\n- **flox-containers** - Deploying shared environments\n- **flox-publish** - Publishing built packages (binaries/artifacts) vs sharing environments (definitions only)"
              }
            ]
          }
        ]
      }
    }
  ]
}