{
  "owner": {
    "id": "arittr",
    "display_name": "Drew Ritter",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/5742859?u=d41cacd050251c0e406d07c3dbc3a063981f47a5&v=4",
    "url": "https://github.com/arittr",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 1,
      "total_skills": 12,
      "total_stars": 6,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "arittr/spectacular",
      "url": "https://github.com/arittr/spectacular",
      "description": "‚öì‚ú® Spec-anchored, stack-driven development tools for Claude Code",
      "homepage": "",
      "signals": {
        "stars": 6,
        "forks": 0,
        "pushed_at": "2025-12-03T18:52:01Z",
        "created_at": "2025-10-21T09:28:37Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 507
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 507
        },
        {
          "path": ".claude",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude/skills/testing-spectacular.md",
          "type": "blob",
          "size": 11703
        },
        {
          "path": ".codex",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/INSTALL.md",
          "type": "blob",
          "size": 11123
        },
        {
          "path": ".codex/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/commands/codex-execute.md",
          "type": "blob",
          "size": 17619
        },
        {
          "path": ".codex/spectacular-bootstrap.md",
          "type": "blob",
          "size": 6166
        },
        {
          "path": ".codex/spectacular-codex",
          "type": "blob",
          "size": 9410
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows/ci.yml",
          "type": "blob",
          "size": 3050
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 199
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 21583
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1068
        },
        {
          "path": "Makefile",
          "type": "blob",
          "size": 8396
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 12767
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/README.md",
          "type": "blob",
          "size": 12864
        },
        {
          "path": "commands/execute.md",
          "type": "blob",
          "size": 18989
        },
        {
          "path": "commands/init.md",
          "type": "blob",
          "size": 9417
        },
        {
          "path": "commands/plan.md",
          "type": "blob",
          "size": 10886
        },
        {
          "path": "commands/spec.md",
          "type": "blob",
          "size": 12227
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/codex-mcp-planning.md",
          "type": "blob",
          "size": 53284
        },
        {
          "path": "docs/codex-mcp-subagent-wrapper.md",
          "type": "blob",
          "size": 12295
        },
        {
          "path": "docs/constitutions",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/constitutions/current",
          "type": "blob",
          "size": 2
        },
        {
          "path": "docs/constitutions/v1",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/constitutions/v1/architecture.md",
          "type": "blob",
          "size": 7757
        },
        {
          "path": "docs/constitutions/v1/meta.md",
          "type": "blob",
          "size": 1557
        },
        {
          "path": "docs/constitutions/v1/patterns.md",
          "type": "blob",
          "size": 12829
        },
        {
          "path": "docs/constitutions/v1/tech-stack.md",
          "type": "blob",
          "size": 5750
        },
        {
          "path": "docs/constitutions/v1/testing.md",
          "type": "blob",
          "size": 11138
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 270
        },
        {
          "path": "hooks/session-start.sh",
          "type": "blob",
          "size": 934
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/update-version.sh",
          "type": "blob",
          "size": 2612
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/decomposing-tasks",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/decomposing-tasks/SKILL.md",
          "type": "blob",
          "size": 14113
        },
        {
          "path": "skills/decomposing-tasks/test-scenarios.md",
          "type": "blob",
          "size": 12525
        },
        {
          "path": "skills/executing-parallel-phase",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/executing-parallel-phase/SKILL.md",
          "type": "blob",
          "size": 33727
        },
        {
          "path": "skills/executing-parallel-phase/test-scenarios.md",
          "type": "blob",
          "size": 8484
        },
        {
          "path": "skills/executing-sequential-phase",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/executing-sequential-phase/SKILL.md",
          "type": "blob",
          "size": 15603
        },
        {
          "path": "skills/executing-sequential-phase/test-scenarios.md",
          "type": "blob",
          "size": 9287
        },
        {
          "path": "skills/phase-task-verification",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/phase-task-verification/SKILL.md",
          "type": "blob",
          "size": 3550
        },
        {
          "path": "skills/testing-workflows-with-subagents",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/testing-workflows-with-subagents/SKILL.md",
          "type": "blob",
          "size": 15434
        },
        {
          "path": "skills/testing-workflows-with-subagents/example-execute-md-fix.md",
          "type": "blob",
          "size": 9895
        },
        {
          "path": "skills/troubleshooting-execute",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/troubleshooting-execute/SKILL.md",
          "type": "blob",
          "size": 12374
        },
        {
          "path": "skills/understanding-cross-phase-stacking",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/understanding-cross-phase-stacking/SKILL.md",
          "type": "blob",
          "size": 7152
        },
        {
          "path": "skills/using-git-spice",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/using-git-spice/SKILL.md",
          "type": "blob",
          "size": 7176
        },
        {
          "path": "skills/using-git-spice/test-scenarios.md",
          "type": "blob",
          "size": 9172
        },
        {
          "path": "skills/using-spectacular",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/using-spectacular/SKILL.md",
          "type": "blob",
          "size": 4576
        },
        {
          "path": "skills/validating-setup-commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/validating-setup-commands/SKILL.md",
          "type": "blob",
          "size": 7371
        },
        {
          "path": "skills/versioning-constitutions",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/versioning-constitutions/SKILL.md",
          "type": "blob",
          "size": 7944
        },
        {
          "path": "skills/versioning-constitutions/test-scenarios.md",
          "type": "blob",
          "size": 22719
        },
        {
          "path": "skills/writing-specs",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/writing-specs/SKILL.md",
          "type": "blob",
          "size": 8288
        },
        {
          "path": "specs",
          "type": "tree",
          "size": null
        },
        {
          "path": "specs/0de4e1-testing-system",
          "type": "tree",
          "size": null
        },
        {
          "path": "specs/0de4e1-testing-system/plan.md",
          "type": "blob",
          "size": 16186
        },
        {
          "path": "specs/0de4e1-testing-system/spec.md",
          "type": "blob",
          "size": 12093
        },
        {
          "path": "specs/8c8505-cognitive-load-reduction",
          "type": "tree",
          "size": null
        },
        {
          "path": "specs/8c8505-cognitive-load-reduction/plan.md",
          "type": "blob",
          "size": 19695
        },
        {
          "path": "specs/8c8505-cognitive-load-reduction/spec.md",
          "type": "blob",
          "size": 12771
        },
        {
          "path": "specs/93a61e-worktree-isolation",
          "type": "tree",
          "size": null
        },
        {
          "path": "specs/93a61e-worktree-isolation/plan.md",
          "type": "blob",
          "size": 23381
        },
        {
          "path": "specs/93a61e-worktree-isolation/spec.md",
          "type": "blob",
          "size": 33555
        },
        {
          "path": "specs/93a61e-worktree-isolation/test-scenarios.md",
          "type": "blob",
          "size": 25145
        },
        {
          "path": "specs/dedf14-worktree-isolation",
          "type": "tree",
          "size": null
        },
        {
          "path": "specs/dedf14-worktree-isolation/plan.md",
          "type": "blob",
          "size": 14231
        },
        {
          "path": "specs/dedf14-worktree-isolation/spec.md",
          "type": "blob",
          "size": 8274
        },
        {
          "path": "tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/QUICK-START.md",
          "type": "blob",
          "size": 5774
        },
        {
          "path": "tests/README.md",
          "type": "blob",
          "size": 24023
        },
        {
          "path": "tests/TESTING-STRATEGY.md",
          "type": "blob",
          "size": 13627
        },
        {
          "path": "tests/aggregate-results.sh",
          "type": "blob",
          "size": 6398
        },
        {
          "path": "tests/behavioral",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/behavioral/README.md",
          "type": "blob",
          "size": 11184
        },
        {
          "path": "tests/behavioral/harness",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/behavioral/harness/test-executor.md",
          "type": "blob",
          "size": 4573
        },
        {
          "path": "tests/execution",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/execution/README.md",
          "type": "blob",
          "size": 8113
        },
        {
          "path": "tests/execution/execute",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/execution/execute/parallel-stacking-4-tasks.sh",
          "type": "blob",
          "size": 5673
        },
        {
          "path": "tests/execution/execute/sequential-stacking.sh",
          "type": "blob",
          "size": 4682
        },
        {
          "path": "tests/execution/lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/execution/lib/test-harness.sh",
          "type": "blob",
          "size": 8308
        },
        {
          "path": "tests/fixtures",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/fixtures/README.md",
          "type": "blob",
          "size": 4627
        },
        {
          "path": "tests/fixtures/init-fixtures.sh",
          "type": "blob",
          "size": 1186
        },
        {
          "path": "tests/fixtures/simple-python",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/fixtures/simple-python/.gitignore",
          "type": "blob",
          "size": 91
        },
        {
          "path": "tests/fixtures/simple-python/CLAUDE.md",
          "type": "blob",
          "size": 539
        },
        {
          "path": "tests/fixtures/simple-python/pyproject.toml",
          "type": "blob",
          "size": 263
        },
        {
          "path": "tests/fixtures/simple-python/requirements.txt",
          "type": "blob",
          "size": 40
        },
        {
          "path": "tests/fixtures/simple-python/src",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/fixtures/simple-python/src/__init__.py",
          "type": "blob",
          "size": 42
        },
        {
          "path": "tests/fixtures/simple-python/src/main.py",
          "type": "blob",
          "size": 466
        },
        {
          "path": "tests/fixtures/simple-python/src/test_main.py",
          "type": "blob",
          "size": 720
        },
        {
          "path": "tests/fixtures/simple-typescript",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/fixtures/simple-typescript/.eslintrc.json",
          "type": "blob",
          "size": 227
        },
        {
          "path": "tests/fixtures/simple-typescript/.gitignore",
          "type": "blob",
          "size": 46
        },
        {
          "path": "tests/fixtures/simple-typescript/.prettierrc",
          "type": "blob",
          "size": 105
        },
        {
          "path": "tests/fixtures/simple-typescript/CLAUDE.md",
          "type": "blob",
          "size": 577
        },
        {
          "path": "tests/fixtures/simple-typescript/jest.config.js",
          "type": "blob",
          "size": 201
        },
        {
          "path": "tests/fixtures/simple-typescript/package-lock.json",
          "type": "blob",
          "size": 185164
        },
        {
          "path": "tests/fixtures/simple-typescript/package.json",
          "type": "blob",
          "size": 671
        },
        {
          "path": "tests/fixtures/simple-typescript/src",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/fixtures/simple-typescript/src/index.test.ts",
          "type": "blob",
          "size": 835
        },
        {
          "path": "tests/fixtures/simple-typescript/src/index.ts",
          "type": "blob",
          "size": 363
        },
        {
          "path": "tests/fixtures/simple-typescript/tsconfig.json",
          "type": "blob",
          "size": 430
        },
        {
          "path": "tests/fixtures/validate-fixtures.sh",
          "type": "blob",
          "size": 3761
        },
        {
          "path": "tests/pressure",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/pressure/README.md",
          "type": "blob",
          "size": 15714
        },
        {
          "path": "tests/pressure/execute",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/pressure/execute/phase-boundaries.md",
          "type": "blob",
          "size": 13540
        },
        {
          "path": "tests/pressure/lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/pressure/lib/execute-pressure-test.md",
          "type": "blob",
          "size": 8125
        },
        {
          "path": "tests/pressure/verification-skill-branch-creation-failures.md",
          "type": "blob",
          "size": 3516
        },
        {
          "path": "tests/results",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/results/.gitignore",
          "type": "blob",
          "size": 227
        },
        {
          "path": "tests/results/2025-11-07T142202",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/results/2025-11-07T142202/summary.md",
          "type": "blob",
          "size": 1327
        },
        {
          "path": "tests/results/2025-11-07T143044",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/results/2025-11-07T143044/summary.md",
          "type": "blob",
          "size": 1334
        },
        {
          "path": "tests/results/2025-11-07T143951",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/results/2025-11-07T143951/junit.xml",
          "type": "blob",
          "size": 2571
        },
        {
          "path": "tests/results/2025-11-07T143951/summary.md",
          "type": "blob",
          "size": 1406
        },
        {
          "path": "tests/results/2025-11-07T145816",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/results/2025-11-07T145816/junit.xml",
          "type": "blob",
          "size": 1891
        },
        {
          "path": "tests/results/2025-11-07T145816/summary.md",
          "type": "blob",
          "size": 1062
        },
        {
          "path": "tests/results/2025-11-08T154100",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/results/2025-11-08T154100/junit.xml",
          "type": "blob",
          "size": 2766
        },
        {
          "path": "tests/results/2025-11-08T154100/summary.md",
          "type": "blob",
          "size": 1564
        },
        {
          "path": "tests/run-tests.sh",
          "type": "blob",
          "size": 8020
        },
        {
          "path": "tests/scenarios",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/scenarios/README.md",
          "type": "blob",
          "size": 5015
        },
        {
          "path": "tests/scenarios/execute",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/scenarios/execute/README.md",
          "type": "blob",
          "size": 7387
        },
        {
          "path": "tests/scenarios/execute/code-review-rejection-loop.md",
          "type": "blob",
          "size": 15669
        },
        {
          "path": "tests/scenarios/execute/mixed-sequential-parallel-phases.md",
          "type": "blob",
          "size": 14257
        },
        {
          "path": "tests/scenarios/execute/parallel-stacking-4-tasks.md",
          "type": "blob",
          "size": 9562
        },
        {
          "path": "tests/scenarios/execute/phase-scope-boundary-enforcement.md",
          "type": "blob",
          "size": 15777
        },
        {
          "path": "tests/scenarios/execute/sequential-stacking.md",
          "type": "blob",
          "size": 9963
        },
        {
          "path": "tests/scenarios/execute/spec-injection-subagents.md",
          "type": "blob",
          "size": 17998
        },
        {
          "path": "tests/scenarios/init",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/scenarios/init/error-handling.md",
          "type": "blob",
          "size": 10280
        },
        {
          "path": "tests/scenarios/init/validate-git-spice.md",
          "type": "blob",
          "size": 10039
        },
        {
          "path": "tests/scenarios/init/validate-superpowers.md",
          "type": "blob",
          "size": 8989
        },
        {
          "path": "tests/scenarios/plan",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/scenarios/plan/task-decomposition.md",
          "type": "blob",
          "size": 11573
        },
        {
          "path": "tests/scenarios/spec",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/scenarios/spec/lean-spec-generation.md",
          "type": "blob",
          "size": 10483
        },
        {
          "path": "tests/scenarios/test",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/scenarios/test/meta-testing.md",
          "type": "blob",
          "size": 7703
        }
      ],
      "marketplace": {
        "name": "spectacular",
        "version": null,
        "description": "Marketplace for Spectacular skills/commands library",
        "owner_info": {
          "name": "Drew Ritter",
          "email": "drew@ritter.dev"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "spectacular",
            "description": "Spectacular skills/commands library for spec-anchored development and parallel task execution",
            "source": "./",
            "category": null,
            "version": "2.1.0-codex.beta3",
            "author": {
              "name": "Drew Ritter",
              "email": "drew@ritter.dev"
            },
            "install_commands": [
              "/plugin marketplace add arittr/spectacular",
              "/plugin install spectacular@spectacular"
            ],
            "signals": {
              "stars": 6,
              "forks": 0,
              "pushed_at": "2025-12-03T18:52:01Z",
              "created_at": "2025-10-21T09:28:37Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/codex-execute",
                "description": "Execute implementation plan via Codex MCP server with automatic parallel orchestration (Codex-only)",
                "path": ".codex/commands/codex-execute.md",
                "frontmatter": {
                  "description": "Execute implementation plan via Codex MCP server with automatic parallel orchestration (Codex-only)"
                },
                "content": "<!--\nDUPLICATION NOTICE:\nSteps 0a-0c and 1.5-1.7 (orchestration setup) are intentionally duplicated from commands/execute.md.\nThis duplication enables independent evolution of Codex and Claude Code execution paths.\n\nIf you update orchestration logic (Run ID extraction, worktree verification, validation, etc.),\ncheck BOTH files:\n- commands/execute.md (Claude Code - uses Task tool)\n- .codex/commands/codex-execute.md (Codex - uses MCP tool)\n\nThe ONLY difference is Step 2:\n- execute.md: Uses executing-parallel-phase and executing-sequential-phase skills with Task tool\n- codex-execute.md: Calls spectacular_execute MCP tool with plan_path (MCP server handles parsing)\n\nSee CLAUDE.md \"Codex-Specific Commands\" section for architecture rationale.\n-->\n\nYou are executing an implementation plan using the Codex MCP server.\n\n## Architecture\n\n**Execution Flow:**\n\n1. **Orchestrator (This Command)**: Validates worktree, setup, configures options\n2. **MCP Server** (spectacular-codex): Parses plan.md, spawns Codex CLI subagents\n3. **Codex Subagents**: Execute tasks in isolated worktrees (parallel or sequential)\n4. **Git State**: Branches track completion, worktrees provide isolation\n\n**Key Difference from Claude Code:**\n\n- Claude Code: Uses Task tool to spawn Claude subagents in same session\n- Codex: Calls spectacular_execute MCP tool which spawns separate Codex CLI processes with `--dangerously-bypass-approvals-and-sandbox --yolo`\n\n## Available Skills\n\n**Skills are referenced on-demand when you encounter the relevant step. Do not pre-read all skills upfront.**\n\n**Support Skills** (read as needed when referenced):\n\n- `validating-setup-commands` - Reference if CLAUDE.md setup validation needed (Step 1.1)\n- `using-git-spice` - Reference for git-spice command syntax (as needed)\n- `verification-before-completion` - Reference before claiming completion (Step 3)\n- `finishing-a-development-branch` - Reference after all phases complete (Step 4)\n\n## Input\n\nUser will provide: `codex-execute {plan-path}`\n\nExample: `codex-execute specs/a1b2c3-magic-link-auth/plan.md`\n\nWhere `a1b2c3` is the runId and `magic-link-auth` is the feature slug.\n\n## Workflow\n\n### Step 0a: Extract Run ID from Plan\n\n**User provided plan path**: The user gave you a plan path like `.worktrees/3a00a7-main/specs/3a00a7-agent-standardization-refactor/plan.md`\n\n**Extract RUN_ID from the path:**\n\nThe RUN_ID is the first segment of the spec directory name (before the first dash).\n\nFor example:\n\n- Path: `.worktrees/3a00a7-main/specs/3a00a7-agent-standardization-refactor/plan.md`\n- Directory: `3a00a7-agent-standardization-refactor`\n- RUN_ID: `3a00a7`\n\n```bash\n# Extract RUN_ID and FEATURE_SLUG from plan path (replace {the-plan-path-user-provided} with actual path)\nPLAN_PATH=\"{the-plan-path-user-provided}\"\nDIR_NAME=$(echo \"$PLAN_PATH\" | sed 's|^.*specs/||; s|/plan.md$||')\nRUN_ID=$(echo \"$DIR_NAME\" | cut -d'-' -f1)\nFEATURE_SLUG=$(echo \"$DIR_NAME\" | cut -d'-' -f2-)\n\necho \"Extracted RUN_ID: $RUN_ID\"\necho \"Extracted FEATURE_SLUG: $FEATURE_SLUG\"\n\n# Verify RUN_ID and FEATURE_SLUG are not empty\nif [ -z \"$RUN_ID\" ]; then\n  echo \"‚ùå Error: Could not extract RUN_ID from plan path: $PLAN_PATH\"\n  exit 1\nfi\n\nif [ -z \"$FEATURE_SLUG\" ]; then\n  echo \"‚ùå Error: Could not extract FEATURE_SLUG from plan path: $PLAN_PATH\"\n  exit 1\nfi\n```\n\n**CRITICAL**: Execute this entire block as a single multi-line Bash tool call. The comment on the first line is REQUIRED - without it, command substitution `$(...)` causes parse errors.\n\n**Store RUN_ID and FEATURE_SLUG for use in:**\n\n- Branch naming: `{run-id}-task-X-Y-name`\n- Filtering: `git branch | grep \"^  {run-id}-\"`\n- Spec path: `specs/{run-id}-{feature-slug}/spec.md`\n- Cleanup: Identify which branches/specs belong to this run\n\n**Announce:** \"Executing with RUN_ID: {run-id}, FEATURE_SLUG: {feature-slug}\"\n\n### Step 0b: Verify Worktree Exists\n\n**After extracting RUN_ID, verify the worktree exists:**\n\n```bash\n# Get absolute repo root (stay in main repo, don't cd into worktree)\nREPO_ROOT=$(git rev-parse --show-toplevel)\n\n# Verify worktree exists\nif [ ! -d \"$REPO_ROOT/.worktrees/${RUN_ID}-main\" ]; then\n  echo \"‚ùå Error: Worktree not found at .worktrees/${RUN_ID}-main\"\n  echo \"Run /spectacular:spec first to create the workspace.\"\n  exit 1\nfi\n\n# Verify it's a valid worktree\ngit worktree list | grep \"${RUN_ID}-main\"\n```\n\n**IMPORTANT: Orchestrator stays in main repo. All worktree operations use `git -C .worktrees/{run-id}-main` or absolute paths.**\n\n**This ensures task worktrees are created at the same level as {run-id}-main, not nested inside it.**\n\n**Announce:** \"Verified worktree exists: .worktrees/{run-id}-main/\"\n\n### Step 0c: Check for Existing Work\n\n**Check if implementation work already exists:**\n\n```bash\n# Get repo root\nREPO_ROOT=$(git rev-parse --show-toplevel)\n\n# Check current branch in main worktree\nCURRENT_BRANCH=$(git -C \"$REPO_ROOT/.worktrees/${RUN_ID}-main\" branch --show-current 2>/dev/null || echo \"\")\n\n# Count existing task branches for this RUN_ID\nEXISTING_TASKS=$(git branch 2>/dev/null | grep -c \"^  ${RUN_ID}-task-\" || echo \"0\")\n\n# Report status\nif [ \"$EXISTING_TASKS\" -gt 0 ]; then\n  echo \"üìã Found $EXISTING_TASKS existing task branch(es) for RUN_ID: $RUN_ID\"\n  echo \"   Current branch: $CURRENT_BRANCH\"\n  echo \"\"\n  echo \"Resuming from current state. The execution will:\"\n  echo \"- Sequential phases: Continue from current branch\"\n  echo \"- Parallel phases: Skip completed tasks, run remaining\"\n  echo \"\"\nelse\n  echo \"‚úÖ No existing work found - starting fresh execution\"\n  echo \"\"\nfi\n```\n\n**CRITICAL**: Execute this entire block as a single multi-line Bash tool call. The comment on the first line is REQUIRED - without it, command substitution `$(...)` causes parse errors.\n\n**Resume behavior:**\n- If `EXISTING_TASKS > 0`: Execution continues from current state in main worktree\n- If `EXISTING_TASKS = 0`: Execution starts from Phase 1, Task 1\n- Main worktree current branch indicates progress (latest completed work)\n\n**Note:** Orchestrator proceeds immediately to Step 1. MCP server handles resume by checking current branch and existing task branches.\n\n### Step 1.1: Validate Setup Commands (REQUIRED)\n\n**Use the `validating-setup-commands` skill:**\n\nThis skill validates that CLAUDE.md defines required setup commands BEFORE executing the plan. It provides clear error messages with examples if missing.\n\nThe skill will extract and return:\n- `INSTALL_CMD` - Required dependency installation command\n- `POSTINSTALL_CMD` - Optional post-install command (codegen, etc.)\n\nStore these commands for reference (MCP server will handle actual installation).\n\n### Step 1.2: Configure Code Review Frequency\n\n**Determine when to run code reviews:**\n\n```bash\n# Check if REVIEW_FREQUENCY env var is set\necho \"REVIEW_FREQUENCY=${REVIEW_FREQUENCY:-}\"\n```\n\n**If not set, prompt user for preference:**\n\nIf `REVIEW_FREQUENCY` is empty, use AskUserQuestion tool to prompt:\n\n```\nQuestion: \"How frequently should code reviews run during execution?\"\nHeader: \"Review Frequency\"\nOptions:\n  1. \"After each phase\"\n     Description: \"Run code review after every phase completes (safest - catches errors early, prevents compounding issues)\"\n  2. \"Optimize automatically\"\n     Description: \"Let Claude decide when to review based on phase risk/complexity (RECOMMENDED - balances speed and quality)\"\n  3. \"Only at end\"\n     Description: \"Skip per-phase reviews, run one review after all phases complete (faster, but errors may compound)\"\n  4. \"Skip reviews\"\n     Description: \"No automated code reviews (fastest, but requires manual review before merging)\"\n```\n\n**Store user choice:**\n- Option 1 ‚Üí `REVIEW_FREQUENCY=\"per-phase\"`\n- Option 2 ‚Üí `REVIEW_FREQUENCY=\"optimize\"`\n- Option 3 ‚Üí `REVIEW_FREQUENCY=\"end-only\"`\n- Option 4 ‚Üí `REVIEW_FREQUENCY=\"skip\"`\n\n**Announce decision:**\n```\nCode review frequency: {REVIEW_FREQUENCY}\n```\n\n**Note:** This setting will be passed to MCP server via environment variable.\n\n### Step 2: Execute via MCP Server\n\n**Call the `spectacular_execute` MCP tool with the plan path.**\n\n**IMPORTANT:** The MCP server will parse the plan.md file internally. You only need to provide the path.\n\n**Construct the plan path from extracted variables:**\n\nUsing the `RUN_ID` and `FEATURE_SLUG` you extracted in Step 0a, construct the absolute path to the plan.md file:\n\n```bash\n# Construct absolute path to plan.md in worktree\nREPO_ROOT=$(git rev-parse --show-toplevel)\nPLAN_PATH_FOR_MCP=\"${REPO_ROOT}/.worktrees/${RUN_ID}-main/specs/${RUN_ID}-${FEATURE_SLUG}/plan.md\"\necho \"Plan path for MCP: $PLAN_PATH_FOR_MCP\"\n\n# Verify the plan file exists before calling MCP tool\nif [ ! -f \"$PLAN_PATH_FOR_MCP\" ]; then\n  echo \"‚ùå Error: Plan file not found at $PLAN_PATH_FOR_MCP\"\n  echo \"Run /spectacular:plan first to create the plan.\"\n  exit 1\nfi\n```\n\n**Tool invocation:**\n\nCall the `spectacular_execute` MCP tool with the absolute path:\n\n```json\n{\n  \"plan_path\": \"/absolute/path/to/.worktrees/{RUN_ID}-main/specs/{RUN_ID}-{FEATURE_SLUG}/plan.md\",\n  \"base_branch\": \"main\"\n}\n```\n\n**CRITICAL:** Use the absolute path you constructed in the bash command above. Replace the placeholders with actual values.\n\n**Example with actual values:**\n\nIf `REPO_ROOT=/Users/drewritter/projects/bignight.party`, `RUN_ID=0729be`, and `FEATURE_SLUG=mobile-optimizations`, call:\n\n```json\n{\n  \"plan_path\": \"/Users/drewritter/projects/bignight.party/.worktrees/0729be-main/specs/0729be-mobile-optimizations/plan.md\",\n  \"base_branch\": \"main\"\n}\n```\n\n**Why absolute path?** The plan.md file lives in the worktree (`.worktrees/{runId}-main/specs/...`), not the main repo. The MCP server needs the full path to find it.\n\n**The MCP server will:**\n1. Parse plan.md to extract phases and tasks\n2. Bootstrap skills (superpowers, spectacular)\n3. Ensure `.worktrees/{run-id}-main` exists\n4. Execute each phase according to strategy:\n   - Sequential: Tasks run one-by-one in main worktree\n   - Parallel: Each task gets isolated worktree, runs simultaneously\n5. Spawn Codex CLI subagents with embedded skill instructions (using `codex run --dangerously-bypass-approvals-and-sandbox --yolo`)\n6. Track completion via git branches\n7. Run code reviews based on REVIEW_FREQUENCY environment variable\n8. Stack branches linearly with git-spice\n\n**Expected response:**\n\nThe tool will return immediately with:\n- **run_id**: The run identifier (should match your runId)\n- **status**: \"started\" (execution continues in background)\n\n**Store the run_id** for use in Step 2.1 (status polling).\n\n### Step 2.1: Poll Execution Status\n\n**Poll the `subagent_status` MCP tool periodically to track progress.**\n\n**Tool invocation:**\n\nCall the `subagent_status` MCP tool with:\n\n```json\n{\n  \"run_id\": \"{run-id}\"\n}\n```\n\n**Example:**\n```json\n{\n  \"run_id\": \"0729be\"\n}\n```\n\n**Expected response:**\n\nThe tool returns execution status containing:\n- **run_id**: The run identifier\n- **status**: Current status (\"running\", \"completed\", or \"failed\")\n- **phase**: Current phase number being executed\n- **tasks**: Array of task statuses with:\n  - **id**: Task identifier (e.g., \"1-1\", \"2-3\")\n  - **status**: Task status (\"pending\", \"running\", \"completed\", or \"failed\")\n  - **branch**: Git branch name (if task created a branch)\n  - **started_at**: ISO timestamp when task started (if running/completed)\n  - **completed_at**: ISO timestamp when task finished (if completed)\n- **started_at**: ISO timestamp when execution started\n- **completed_at**: ISO timestamp when execution finished (if completed/failed)\n- **error**: Error message (if status is \"failed\")\n\n**Display progress updates to user:**\n\n```\nExecution Status: Phase 2 of 5\n\n‚úÖ Task 1.1: Database schema (completed)\n   Branch: abc123-task-1-1-schema\n\n‚è≥ Task 2.1: API routes (running - started 5m ago)\n\nüìä Progress: 1/8 tasks completed\n```\n\n**Poll frequency:**\n- First minute: Every 10 seconds (fast startup)\n- After 1 minute: Every 30 seconds\n- Long-running tasks: Every 60 seconds\n\n**Continue polling until status is \"completed\" or \"failed\".**\n\n### Step 3: Verify Completion\n\nAfter execution completes (`status: \"completed\"`):\n\n**Use the `verification-before-completion` skill:**\n\nThis skill enforces verification BEFORE claiming work is done.\n\n**Required verifications:**\n```bash\n# Navigate to main worktree\ncd .worktrees/{run-id}-main\n\n# Run verification commands (detected from CLAUDE.md/constitution)\n# The verification-before-completion skill will guide you through this\n\n# Return to main repo\ncd ../..\n```\n\n**Critical:** Evidence before assertions. Never claim \"tests pass\" without running them.\n\n### Step 4: Finish Stack\n\nAfter verification passes:\n\nUse the `finishing-a-development-branch` skill to:\n\n1. Review all changes\n2. Choose next action:\n   - Submit stack as PRs: `gs stack submit` (per using-git-spice skill)\n   - Continue with dependent feature: `gs branch create`\n   - Mark complete and sync: `gs repo sync`\n\n### Step 5: Final Report\n\n```markdown\n‚úÖ Feature Implementation Complete\n\n**RUN_ID**: {run-id}\n**Feature**: {feature-name}\n**Worktree**: .worktrees/{run-id}-main/\n**Stack**: {count} task branches (all stacked on {run-id}-main)\n\n## Execution Summary\n\n**Phases Completed**: {count}\n\n- Sequential: {count} phases\n- Parallel: {count} phases\n\n**Tasks Completed**: {count}\n**Commits**: {count}\n\n**Isolation**: All work completed in worktree. Main repo unchanged.\n\n## Parallelization Results\n\n{For each parallel phase:}\n**Phase {id}**: {task-count} tasks in parallel\n\n- Estimated sequential time: {hours}h\n- Actual parallel time: {hours}h\n- Time saved: {hours}h\n\n**Total Time Saved**: {hours}h ({percent}%)\n\n## Quality Checks\n\n‚úÖ Tests passing\n‚úÖ Linting clean\n‚úÖ Build successful\n‚úÖ {total-commits} commits across {branch-count} task branches\n\n## Next Steps\n\n### Review Changes (from main repo)\n\n```bash\n# All these commands work from main repo root\ngs log short                      # View all branches and commits in stack\ngs log long                       # Detailed view with commit messages\ngit branch | grep \"^  {run-id}-\"  # List all branches for this run\n\n# To see changes in worktree:\ncd .worktrees/{run-id}-main\ngit diff main..HEAD               # See all changes in current stack\ncd ../..                          # Return to main repo\n```\n\n### Submit for Review (from main repo)\n\n```bash\n# git-spice commands work from main repo\ngs stack submit  # Submits entire stack as PRs (per using-git-spice skill)\n```\n\n### Or Continue with Dependent Feature (from worktree)\n\n```bash\ncd .worktrees/{run-id}-main       # Navigate to worktree\ngs branch create  # Creates new branch stacked on current\ncd ../..                          # Return to main repo when done\n```\n\n### Cleanup Worktree (after PRs merged)\n\n```bash\n# From main repo root:\ngit worktree remove .worktrees/{run-id}-main\n\n# Optional: Delete the {run-id}-main branch\ngit branch -d {run-id}-main\n```\n\n**Important**: Main repo remains unchanged. All work is in the worktree and task branches.\n```\n\n## Error Handling\n\n**If MCP tool call fails:**\n\nCheck error response from spectacular_execute:\n- `plan_path or plan must be provided`: Missing required argument\n- `Plan file not found`: Invalid path or file doesn't exist\n- `Invalid plan path`: Path doesn't match `specs/{runId}-{slug}/plan.md` format\n- `runId mismatch`: plan_path runId doesn't match plan content\n- Worktree errors: Verify `.worktrees/{run-id}-main` exists\n- Subagent spawn errors: Check Codex CLI is installed and configured\n- Git errors: Verify git-spice is installed and repo initialized\n\n**If execution status shows \"failed\":**\n\n```json\n{\n  \"run_id\": \"{run-id}\",\n  \"status\": \"failed\",\n  \"error\": \"Task 2.3 failed: Tests did not pass\",\n  \"phase\": 2,\n  \"tasks\": [...]\n}\n```\n\n**Recovery options:**\n\n1. **Resume from checkpoint**: Simply re-run the same execute command. MCP server auto-detects completed branches and skips them.\n\n2. **Manual intervention**: Navigate to worktree, fix issue, commit, then resume:\n   ```bash\n   cd .worktrees/{run-id}-main\n   # Fix the issue\n   git add .\n   git commit -m \"Fix: {description}\"\n   cd ../..\n   # Re-run execute command\n   ```\n\n3. **Abort and restart**: Remove failed branches, re-run from beginning:\n   ```bash\n   git branch | grep \"{run-id}-task-\" | xargs git branch -D\n   # Re-run execute command\n   ```\n\n## Important Notes\n\n- **MCP Server handles parsing** - Just pass plan_path, MCP server parses plan.md internally\n- **MCP Server delegates, never executes** - This command orchestrates, MCP server spawns Codex subagents\n- **Codex subagents own their operations** - Each task runs in isolated Codex CLI process with `--yolo` flag\n- **Skill-driven execution** - MCP server embeds skill instructions in subagent prompts\n- **Automatic orchestration** - MCP server reads plan strategies, executes accordingly\n- **Git-spice stacking** - Sequential tasks stack linearly; parallel tasks branch from same base\n- **No feature branch** - The stack of task branches IS the feature; never create empty branch upfront\n- **Worktree isolation** - Parallel tasks run in separate worktrees\n- **Git-based state** - Branches are source of truth for completion, not database\n- **Context management** - Each task runs in isolated Codex CLI process to avoid token bloat\n- **Constitution adherence** - All subagents follow project constitution\n- **Quality gates** - Tests and linting after every task, code review based on REVIEW_FREQUENCY\n- **Continuous commits** - Small, focused commits with [Task X.Y] markers throughout\n\nNow execute the plan from: {plan-path}"
              }
            ],
            "skills": [
              {
                "name": "decomposing-tasks",
                "description": "Use when you have a complete feature spec and need to plan implementation - analyzes task dependencies, groups into sequential/parallel phases, validates task quality (no XL tasks, explicit files), and calculates parallelization time savings",
                "path": "skills/decomposing-tasks/SKILL.md",
                "frontmatter": {
                  "name": "decomposing-tasks",
                  "description": "Use when you have a complete feature spec and need to plan implementation - analyzes task dependencies, groups into sequential/parallel phases, validates task quality (no XL tasks, explicit files), and calculates parallelization time savings"
                },
                "content": "# Task Decomposition\n\nAnalyze a feature specification and decompose it into an execution-ready plan with automatic phase grouping based on file dependencies.\n\n**When to use:** After completing a feature spec, before implementation.\n\n**Announce:** \"I'm using the Task Decomposition skill to create an execution plan.\"\n\n## Overview\n\nThis skill transforms a feature specification into a structured implementation plan by:\n\n1. Extracting tasks from spec\n2. Analyzing file dependencies between tasks\n3. Grouping into phases (sequential or parallel)\n4. Validating task quality\n5. Outputting executable plan.md\n\n## PR-Sized Chunks Philosophy\n\n**Tasks should be PR-sized, thematically coherent units** - not mechanical file-by-file splits.\n\n**Think like a senior engineer:**\n\n- ‚ùå \"Add schema\" + \"Install dependency\" + \"Add routes\" (3 tiny tasks)\n- ‚úÖ \"Database Foundation\" (schema + migration + dependencies as one unit)\n\n**Task chunking principles:**\n\n1. **Thematic Coherence** - Task represents a complete \"thing\"\n\n   - Complete subsystem (agent system with tools + config + types)\n   - Complete layer (all service methods for a feature)\n   - Complete feature slice (UI flow from form to preview to confirm)\n\n2. **Natural PR Size** - Reviewable in one sitting (4-7h)\n\n   - M (3-5h): Sweet spot for most tasks\n   - L (5-7h): Complex but coherent units (full UI layer, complete API surface)\n   - S (1-2h): Rare - only for truly standalone work\n\n3. **Logical Boundaries** - Clear separation points\n\n   - Layer boundaries (Models, Services, Actions, UI)\n   - Subsystem boundaries (Agent, Import Service, API)\n   - Feature boundaries (Auth, Import, Dashboard)\n\n4. **Stackable** - Dependencies flow cleanly\n   - Database ‚Üí Logic ‚Üí API ‚Üí UI\n   - Foundation ‚Üí Core ‚Üí Integration\n\n**Good chunking examples:**\n\n```\n‚úÖ GOOD: PR-sized, thematic chunks\n- Task 1: Database Foundation (M - 4h)\n  - Schema changes + migration + dependency install\n  - One coherent \"foundation\" PR\n\n- Task 2: Agent System (L - 6h)\n  - Agent config + tools + schemas + types\n  - Complete agent subsystem as a unit\n\n- Task 3: Import Service Layer (M - 4h)\n  - All service methods + business logic\n  - Clean layer boundary\n\n- Task 4: API Surface (L - 6h)\n  - Server actions + SSE route\n  - Complete API interface\n\n- Task 5: Import UI (L - 7h)\n  - All components + page + integration\n  - Complete user-facing feature\n\nTotal: 5 tasks, 27h\nEach task is a reviewable PR that adds value\n```\n\n```\n‚ùå BAD: Too granular, mechanical splits\n- Task 1: Add schema fields (S - 2h)\n- Task 2: Create migration (S - 1h)\n- Task 3: Install dependency (S - 1h)\n- Task 4: Create agent config (M - 3h)\n- Task 5: Create fetch tool (S - 1h)\n- Task 6: Create schemas (S - 2h)\n- Task 7: Create service (M - 4h)\n- Task 8: Create actions (M - 3h)\n- Task 9: Create SSE route (M - 3h)\n- Task 10: Create form component (S - 2h)\n- Task 11: Create progress component (S - 2h)\n- Task 12: Create preview component (M - 2h)\n- Task 13: Add routes (S - 1h)\n- Task 14: Integrate components (S - 1h)\n\nTotal: 14 tasks, 28h\nToo many tiny PRs, no coherent units\n```\n\n**Bundling heuristics:**\n\nIf you're creating S tasks, ask:\n\n- Can this bundle with a related M task?\n- Does this complete a subsystem or layer?\n- Would a senior engineer create a separate PR for this?\n\n**Common bundling patterns:**\n\n- Schema + migration + dependencies ‚Üí \"Database Foundation\"\n- Agent + tools + schemas ‚Üí \"Agent System\"\n- Service + helper functions ‚Üí \"Service Layer\"\n- Actions + API routes ‚Üí \"API Layer\"\n- All UI components for a flow ‚Üí \"UI Layer\"\n\n## The Process\n\n### Step 1: Read Spec and Extract/Design Tasks\n\nRead the spec file and extract tasks. The spec may provide tasks in two ways:\n\n**Option A: Spec has \"Implementation Plan\" section** (structured task breakdown)\n- Extract tasks directly from this section\n- Each task should have: ID, description, files, complexity, acceptance criteria\n\n**Option B: Spec has no \"Implementation Plan\"** (lean spec - requirements only)\n- Analyze the requirements and design task breakdown yourself\n- Look at: Functional Requirements, Architecture section, Files to Create/Modify\n- Design PR-sized chunks following the chunking philosophy above\n- Create tasks that implement all requirements\n\nFor each task (extracted or designed), capture:\n\n- **Task ID** (from heading)\n- **Description** (what to implement)\n- **Files** (explicit paths from spec)\n- **Complexity** (S/M/L/XL - estimated hours)\n- **Acceptance Criteria** (checklist items)\n- **Implementation Steps** (detailed steps)\n\n**Example extraction:**\n\n```markdown\nSpec has:\n\n### Task 1: Database Schema\n\n**Complexity**: M (2-4h)\n**Files**:\n\n- prisma/schema.prisma\n- prisma/migrations/\n\n**Description**: Add VerificationToken model for Auth.js...\n\n**Acceptance**:\n\n- [ ] Model matches Auth.js spec\n- [ ] Migration runs cleanly\n\nExtract to:\n{\nid: \"task-1-database-schema\",\ndescription: \"Add VerificationToken model\",\nfiles: [\"prisma/schema.prisma\", \"prisma/migrations/\"],\ncomplexity: \"M\",\nestimated_hours: 3,\nacceptance_criteria: [...],\nsteps: [...]\n}\n```\n\n### Step 2: Validate Task Quality & Chunking\n\nFor each task, check for quality issues:\n\n**CRITICAL (must fix):**\n\n- ‚ùå XL complexity (>8h) ‚Üí Must split into M/L tasks\n- ‚ùå No files specified ‚Üí Must add explicit file paths\n- ‚ùå No acceptance criteria ‚Üí Must add 3-5 testable criteria\n- ‚ùå Wildcard patterns (`src/**/*.ts`) ‚Üí Must use explicit paths\n- ‚ùå Too many S tasks (>30% of total) ‚Üí Bundle into thematic M/L tasks\n\n**HIGH (strongly recommend):**\n\n- ‚ö†Ô∏è Standalone S task that could bundle with related work\n- ‚ö†Ô∏è L complexity (5-8h) ‚Üí Verify it's a coherent unit, not arbitrary split\n- ‚ö†Ô∏è >10 files ‚Üí Likely too large, consider splitting by subsystem\n- ‚ö†Ô∏è <50 char description ‚Üí Add more detail about what subsystem/layer this completes\n- ‚ö†Ô∏è <3 acceptance criteria ‚Üí Add more specific criteria\n\n**Chunking validation:**\n\n- If task is S (1-2h), verify it's truly standalone:\n\n  - Can't be bundled with schema/migration/dependencies?\n  - Can't be bundled with related service/action/component?\n  - Would a senior engineer create a separate PR for this?\n\n- If >50% of tasks are S, that's a red flag:\n  - Likely too granular\n  - Missing thematic coherence\n  - Bundle related S tasks into M tasks\n\n**If CRITICAL issues found:**\n\n- STOP and report issues to user\n- User must update spec or adjust chunking\n- Re-run skill after fixes\n\n**If only HIGH issues:**\n\n- Report warnings\n- Offer to continue or fix\n\n### Step 3: Analyze File Dependencies\n\nBuild dependency graph by analyzing file overlaps:\n\n**Algorithm:**\n\n```\nFor each task T1:\n  For each task T2 (where T2 appears after T1):\n    shared_files = intersection(T1.files, T2.files)\n\n    If shared_files is not empty:\n      T2.dependencies.add(T1.id)\n      T2.dependency_reason = \"Shares files: {shared_files}\"\n```\n\n**Example:**\n\n```\nTask 1: [\"prisma/schema.prisma\"]\nTask 2: [\"src/lib/models/auth.ts\"]\nTask 3: [\"prisma/schema.prisma\", \"src/types/auth.ts\"]\n\nAnalysis:\n- Task 2: No dependencies (no shared files with Task 1)\n- Task 3: Depends on Task 1 (shares prisma/schema.prisma)\n```\n\n**Architectural dependencies:**\nAlso add dependencies based on layer order:\n\n- Models ‚Üí Services ‚Üí Actions ‚Üí UI\n- Database ‚Üí Types ‚Üí Logic ‚Üí API ‚Üí Components\n\n### Step 4: Group into Phases\n\nGroup tasks into phases using dependency graph:\n\n**Phase grouping algorithm:**\n\n```\n1. Start with tasks that have no dependencies (roots)\n2. Group all independent roots into Phase 1\n3. Remove roots from graph\n4. Repeat until all tasks grouped\n\nFor each phase:\n  - If all tasks independent: strategy = \"parallel\"\n  - If any dependencies exist: strategy = \"sequential\"\n```\n\n**Example:**\n\n```\nTasks:\n- Task 1: [] (no deps)\n- Task 2: [] (no deps)\n- Task 3: [task-1, task-2]\n- Task 4: [task-3]\n\nGrouping:\nPhase 1: [Task 1, Task 2] - parallel (independent)\nPhase 2: [Task 3] - sequential (waits for Phase 1)\nPhase 3: [Task 4] - sequential (waits for Phase 2)\n```\n\n### Step 5: Calculate Execution Estimates\n\nFor each phase, calculate:\n\n- **Sequential time**: Sum of all task hours\n- **Parallel time**: Max of all task hours (if parallel strategy)\n- **Time savings**: Sequential - Parallel\n\n**Example:**\n\n```\nPhase 2 (parallel):\n- Task A: 3h\n- Task B: 2h\n- Task C: 4h\n\nSequential: 3 + 2 + 4 = 9h\nParallel: max(3, 2, 4) = 4h\nSavings: 9 - 4 = 5h (56% faster)\n```\n\n### Step 6: Generate plan.md\n\nWrite plan to `{spec-directory}/plan.md`:\n\n**Template:**\n\n````markdown\n# Feature: {Feature Name} - Implementation Plan\n\n> **Generated by:** Task Decomposition skill\n> **From spec:** {spec-path}\n> **Created:** {date}\n\n## Execution Summary\n\n- **Total Tasks**: {count}\n- **Total Phases**: {count}\n- **Sequential Time**: {hours}h\n- **Parallel Time**: {hours}h\n- **Time Savings**: {hours}h ({percent}%)\n\n**Parallel Opportunities:**\n\n- Phase {id}: {task-count} tasks ({hours}h saved)\n\n---\n\n## Phase {N}: {Phase Name}\n\n**Strategy**: {sequential|parallel}\n**Reason**: {why this strategy}\n\n### Task {ID}: {Name}\n\n**Files**:\n\n- {file-path-1}\n- {file-path-2}\n\n**Complexity**: {S|M|L} ({hours}h)\n\n**Dependencies**: {[task-ids] or \"None\"}\n\n**Description**:\n{What to implement and why}\n\n**Implementation Steps**:\n\n1. {step-1}\n2. {step-2}\n3. {step-3}\n\n**Acceptance Criteria**:\n\n- [ ] {criterion-1}\n- [ ] {criterion-2}\n- [ ] {criterion-3}\n\n**Mandatory Patterns**:\n\n> **Constitution**: All code must follow @docs/constitutions/current/\n\nSee architecture.md for layer boundaries and patterns.md for required patterns.\n\n**TDD**: Follow `test-driven-development` skill (write test first, watch fail, minimal code, watch pass)\n\n**Quality Gates**:\n\n```bash\npnpm biome check --write .\npnpm test {test-files}\n```\n````\n\n---\n\n{Repeat for all tasks in all phases}\n\n````\n\n### Step 7: Report to User\n\nAfter generating plan:\n\n```markdown\n‚úÖ Task Decomposition Complete\n\n**Plan Location**: specs/{run-id}-{feature-slug}/plan.md\n\n## Breakdown\n- Phases: {count}\n- Tasks: {count}\n- Complexity: {XL}: {n}, {L}: {n}, {M}: {n}, {S}: {n}\n\n## Execution Strategy\n- Sequential Phases: {count} ({tasks} tasks)\n- Parallel Phases: {count} ({tasks} tasks)\n\n## Time Estimates\n- Sequential Execution: {hours}h\n- With Parallelization: {hours}h\n- **Time Savings: {hours}h ({percent}% faster)**\n\n## Next Steps\n\nReview plan:\n```bash\ncat specs/{run-id}-{feature-slug}/plan.md\n````\n\nExecute plan:\n\n```bash\n/spectacular:execute @specs/{run-id}-{feature-slug}/plan.md\n```\n\n```\n\n## Quality Rules\n\n**Task Sizing (PR-focused):**\n- ‚ö†Ô∏è S (1-2h): Rare - only truly standalone work (e.g., config-only changes)\n  - Most S tasks should bundle into M\n  - Ask: \"Would a senior engineer PR this alone?\"\n- ‚úÖ M (3-5h): Sweet spot - most tasks should be this size\n  - Complete subsystem, layer, or feature slice\n  - Reviewable in one sitting\n  - Thematically coherent unit\n- ‚úÖ L (5-7h): Complex coherent units (use for major subsystems)\n  - Full UI layer with all components\n  - Complete API surface (actions + routes)\n  - Major feature integration\n- ‚ùå XL (>8h): NEVER - always split into M/L tasks\n\n**Chunking Standards:**\n- ‚ùå <30% S tasks is a red flag (too granular)\n- ‚úÖ Most tasks should be M (60-80%)\n- ‚úÖ Some L tasks for major units (10-30%)\n- ‚úÖ Rare S tasks for truly standalone work (<10%)\n\n**File Specificity:**\n- ‚úÖ `src/lib/models/auth.ts`\n- ‚úÖ `src/components/auth/LoginForm.tsx`\n- ‚ùå `src/**/*.ts` (too vague)\n- ‚ùå `src/lib/models/` (specify exact files)\n\n**Acceptance Criteria:**\n- ‚úÖ 3-5 specific, testable criteria\n- ‚úÖ Quantifiable (tests pass, build succeeds, API returns 200)\n- ‚ùå Vague (\"works well\", \"is good\")\n- ‚ùå Too many (>7 - task is too large)\n\n**Dependencies:**\n- ‚úÖ Minimal (only true blockers)\n- ‚úÖ Explicit reasons (shares file X)\n- ‚ùå Circular dependencies\n- ‚ùå Over-constrained (everything depends on everything)\n\n## Error Handling\n\n### Spec Has Insufficient Information\n\nIf spec has neither \"Implementation Plan\" nor enough detail to design tasks:\n\n```\n\n‚ùå Cannot decompose - spec lacks implementation details\n\nThe spec must have either:\n- An \"Implementation Plan\" section with tasks, OR\n- Sufficient requirements and architecture details to design tasks\n\nCurrent spec has:\n- Functional Requirements: [YES/NO]\n- Architecture section: [YES/NO]\n- Files to create/modify: [YES/NO]\n\nAdd more implementation details to the spec, then re-run:\n/spectacular:plan @specs/{run-id}-{feature-slug}/spec.md\n\n```\n\n### Critical Quality Issues\n\nIf tasks have critical issues:\n\n```\n\n‚ùå Task Quality Issues - Cannot Generate Plan\n\nCritical Issues Found:\n\n- Task 3: XL complexity (12h) - must split\n- Task 5: No files specified\n- Task 7: No acceptance criteria\n\nFix these issues in the spec, then re-run:\n/spectacular:plan @specs/{run-id}-{feature-slug}/spec.md\n\n```\n\n### Circular Dependencies\n\nIf dependency graph has cycles:\n\n```\n\n‚ùå Circular Dependencies Detected\n\nTask A depends on Task B\nTask B depends on Task C\nTask C depends on Task A\n\nThis is impossible to execute. Review task organization.\n\n````\n\n## Integration with Other Skills\n\n**Before:** Use `brainstorming` and `spec-feature` to create complete spec\n\n**After:** Use `/execute` command to run plan with `subagent-driven-development`\n\n**Pairs with:**\n- `subagent-driven-development` - Executes individual tasks\n- `finishing-a-development-branch` - Completes implementation\n\n## Project-Specific Configuration\n\nFor projects with a constitution, reference it in every task:\n\n> **Constitution**: All tasks MUST follow @docs/constitutions/current/\n\nEvery task must include:\n- Reference to constitution for architecture (layer boundaries, dependencies)\n- Reference to constitution for patterns (validation, state management, etc.)\n- Quality gates (linting, testing, building)\n\n**Quality gates:**\n```bash\npnpm biome check --write .\npnpm test\n````"
              },
              {
                "name": "executing-parallel-phase",
                "description": "Use when orchestrating parallel phases in plan execution - creates isolated worktrees for concurrent task execution, installs dependencies, spawns parallel subagents, verifies completion, stacks branches linearly, and cleans up (mandatory for ALL parallel phases including N=1)",
                "path": "skills/executing-parallel-phase/SKILL.md",
                "frontmatter": {
                  "name": "executing-parallel-phase",
                  "description": "Use when orchestrating parallel phases in plan execution - creates isolated worktrees for concurrent task execution, installs dependencies, spawns parallel subagents, verifies completion, stacks branches linearly, and cleans up (mandatory for ALL parallel phases including N=1)"
                },
                "content": "# Executing Parallel Phase\n\n## Overview\n\n**Parallel phases enable TRUE concurrent execution via isolated git worktrees**, not just logical independence.\n\n**Critical distinction:** Worktrees are not an optimization to prevent file conflicts. They're the ARCHITECTURE that enables multiple subagents to work simultaneously.\n\n## When to Use\n\nUse this skill when `execute` command encounters a phase marked \"Parallel\" in plan.md:\n- ‚úÖ Always use for N‚â•2 tasks\n- ‚úÖ **Always use for N=1** (maintains architecture consistency)\n- ‚úÖ Even when files don't overlap\n- ‚úÖ Even under time pressure\n- ‚úÖ Even with disk space pressure\n\n**Never skip worktrees for parallel phases.** No exceptions.\n\n## The Iron Law\n\n```\nPARALLEL PHASE = WORKTREES + SUBAGENTS\n```\n\n**Violations of this law:**\n- ‚ùå Execute in main worktree (\"files don't overlap\")\n- ‚ùå Skip worktrees for N=1 (\"basically sequential\")\n- ‚ùå Use sequential strategy (\"simpler\")\n\n**All of these destroy the parallel execution architecture.**\n\n## Rationalization Table\n\n**Predictable shortcuts you WILL be tempted to make. DO NOT make them.**\n\n| Temptation | Why It's Wrong | What To Do |\n|------------|----------------|------------|\n| \"The spec is too long, I'll just read the task description\" | Task = WHAT files + verification. Spec = WHY architecture + requirements. Missing spec ‚Üí drift. | Read the full spec. It's 2-5 minutes that prevents hours of rework. |\n| \"I already read the constitution, that's enough context\" | Constitution = HOW to code. Spec = WHAT to build. Both needed for anchored implementation. | Read constitution AND spec, every time. |\n| \"The acceptance criteria are clear, I don't need the spec\" | Acceptance criteria = tests pass, files exist. Spec = user flow, business logic, edge cases. | Acceptance criteria verify implementation. Spec defines requirements. |\n| \"I'm a subagent in a parallel phase, other tasks probably read the spec\" | Each parallel subagent has isolated context. Other tasks' spec reading doesn't transfer. | Every subagent reads spec independently. No assumptions. |\n| \"The spec doesn't exist / I can't find it\" | If spec missing, STOP and report error. Never proceed without spec. | Check `specs/{run-id}-{feature-slug}/spec.md`. If missing, fail loudly. |\n| \"I'll implement first, then check spec to verify\" | Spec informs design decisions. Checking after implementation means rework. | Read spec BEFORE writing any code. |\n\n**If you find yourself thinking \"I can skip the spec because...\" - STOP. You're rationalizing. Read the spec.**\n\n## The Process\n\n**Announce:** \"I'm using executing-parallel-phase to orchestrate {N} concurrent tasks in Phase {phase-id}.\"\n\n### Step 1: Pre-Conditions Verification (MANDATORY)\n\n**Before ANY worktree creation, verify the environment is correct:**\n\n```bash\n# Get main repo root\nREPO_ROOT=$(git rev-parse --show-toplevel)\nCURRENT=$(pwd)\n\n# Check 1: Verify orchestrator is in main repo root\nif [ \"$CURRENT\" != \"$REPO_ROOT\" ]; then\n  echo \"‚ùå Error: Orchestrator must run from main repo root\"\n  echo \"Current: $CURRENT\"\n  echo \"Expected: $REPO_ROOT\"\n  echo \"\"\n  echo \"Return to main repo: cd $REPO_ROOT\"\n  exit 1\nfi\n\necho \"‚úÖ Orchestrator location verified: Main repo root\"\n\n# Check 2: Verify main worktree exists\nif [ ! -d .worktrees/{runid}-main ]; then\n  echo \"‚ùå Error: Main worktree not found at .worktrees/{runid}-main\"\n  echo \"Run /spectacular:spec first to create the workspace.\"\n  exit 1\nfi\n\n# Check 3: Verify main branch exists\nif ! git rev-parse --verify {runid}-main >/dev/null 2>&1; then\n  echo \"‚ùå Error: Branch {runid}-main does not exist\"\n  echo \"Spec must be created before executing parallel phase.\"\n  exit 1\nfi\n\n# Check 4: Verify we're on correct base branch for this phase\nCURRENT_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\nEXPECTED_BASE=\"{expected-base-branch}\"  # From plan: previous phase's last task, or {runid}-main for Phase 1\n\nif [ \"$CURRENT_BRANCH\" != \"$EXPECTED_BASE\" ]; then\n  echo \"‚ùå Error: Phase {phase-id} starting from unexpected branch\"\n  echo \"   Current: $CURRENT_BRANCH\"\n  echo \"   Expected: $EXPECTED_BASE\"\n  echo \"\"\n  echo \"Parallel phases must start from the correct base branch.\"\n  echo \"All parallel tasks will stack onto: $CURRENT_BRANCH\"\n  echo \"\"\n  echo \"If $CURRENT_BRANCH is wrong, the entire phase will be misplaced in the stack.\"\n  echo \"\"\n  echo \"To fix:\"\n  echo \"1. Verify previous phase completed: git log --oneline $EXPECTED_BASE\"\n  echo \"2. Switch to correct base: cd .worktrees/{runid}-main && git checkout $EXPECTED_BASE\"\n  echo \"3. Re-run /spectacular:execute\"\n  exit 1\nfi\n\necho \"‚úÖ Phase {phase-id} starting from correct base: $CURRENT_BRANCH\"\necho \"‚úÖ Pre-conditions verified - safe to create task worktrees\"\n```\n\n**Why mandatory:**\n- Prevents nested worktrees from wrong location (9f92a8 regression)\n- Catches upstream drift (execute.md or other skill left orchestrator in wrong place)\n- Catches missing prerequisites before wasting time on worktree creation\n- Provides clear error messages for common setup issues\n\n**Red flag:** \"Skip verification to save time\" - NO. 20ms verification saves hours of debugging.\n\n### Step 1.5: Check for Existing Work (Resume Support)\n\n**Before creating worktrees, check if tasks are already complete:**\n\n```bash\nCOMPLETED_TASKS=()\nPENDING_TASKS=()\n\nfor TASK_ID in {task-ids}; do\n  # Use pattern matching to find branch (short-name varies)\n  BRANCH_PATTERN=\"{runid}-task-{phase-id}-${TASK_ID}-\"\n  BRANCH_NAME=$(git branch | grep \"^  ${BRANCH_PATTERN}\" | sed 's/^  //' | head -n1)\n\n  if [ -n \"$BRANCH_NAME\" ]; then\n    echo \"‚úì Task ${TASK_ID} already complete: $BRANCH_NAME\"\n    COMPLETED_TASKS+=(\"$TASK_ID\")\n  else\n    PENDING_TASKS+=(\"$TASK_ID\")\n  fi\ndone\n\nif [ ${#PENDING_TASKS[@]} -eq 0 ]; then\n  echo \"‚úÖ All tasks already complete, skipping to stacking\"\n  # Jump to Step 6 (Stacking)\nelse\n  echo \"üìã Resuming: ${#COMPLETED_TASKS[@]} complete, ${#PENDING_TASKS[@]} pending\"\n  echo \"Will execute tasks: ${PENDING_TASKS[*]}\"\nfi\n```\n\n**Why check:** Enables resume after fixing failed tasks. Avoids re-executing successful tasks, which wastes time and can cause conflicts.\n\n**Red flags:**\n- \"Always create all worktrees\" - NO. Wastes resources on already-completed work.\n- \"Trust orchestrator state\" - NO. Branches are source of truth.\n\n### Step 2: Create Worktrees (BEFORE Subagents)\n\n**Create isolated worktree for EACH PENDING task (skip completed tasks):**\n\n```bash\n# Get base branch from main worktree\nBASE_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\n\n# Create worktrees only for pending tasks (from Step 1.5)\nfor TASK_ID in \"${PENDING_TASKS[@]}\"; do\n  git worktree add \".worktrees/{runid}-task-${TASK_ID}\" --detach \"$BASE_BRANCH\"\n  echo \"‚úÖ Created .worktrees/{runid}-task-${TASK_ID} (detached HEAD)\"\ndone\n\n# Verify all worktrees created\ngit worktree list | grep \"{runid}-task-\"\n```\n\n**Verify creation succeeded:**\n\n```bash\nCREATED_COUNT=$(git worktree list | grep -c \"{runid}-task-\")\nEXPECTED_COUNT=${#PENDING_TASKS[@]}\n\nif [ $CREATED_COUNT -ne $EXPECTED_COUNT ]; then\n  echo \"‚ùå Error: Expected $EXPECTED_COUNT worktrees, found $CREATED_COUNT\"\n  exit 1\nfi\n\necho \"‚úÖ Created $CREATED_COUNT worktrees for parallel execution\"\n```\n\n**Why --detach:** Git doesn't allow same branch in multiple worktrees. Detached HEAD enables parallel worktrees.\n\n**Red flags:**\n- \"Only 1 task, skip worktrees\" - NO. N=1 still uses architecture.\n- \"Files don't overlap, skip isolation\" - NO. Isolation enables parallelism, not prevents conflicts.\n\n### Step 3: Install Dependencies Per Worktree\n\n**Each PENDING worktree needs its own dependencies (skip completed tasks):**\n\n```bash\nfor TASK_ID in \"${PENDING_TASKS[@]}\"; do\n  if [ ! -d .worktrees/{runid}-task-${TASK_ID}/node_modules ]; then\n    bash -c \"cd .worktrees/{runid}-task-${TASK_ID} && {install-command} && {postinstall-command}\"\n  fi\ndone\n```\n\n**Why per-worktree:** Isolated worktrees can't share node_modules.\n\n**Why bash -c:** Orchestrator stays in main repo. Subshell navigates to worktree and exits after commands complete.\n\n**Red flag:** \"Share node_modules for efficiency\" - Breaks isolation and causes race conditions.\n\n### Step 3.5: Extract Phase Context (Before Dispatching)\n\n**Before spawning subagents, extract phase boundaries from plan:**\n\nThe orchestrator already parsed the plan in execute.md Step 1. Extract:\n- Current phase number and name\n- Tasks in THIS phase (what TO implement)\n- Tasks in LATER phases (what NOT to implement)\n\n**Format for subagent context:**\n```\nPHASE CONTEXT:\n- Phase {current-phase-id}/{total-phases}: {phase-name}\n- This phase includes: Task {task-ids-in-this-phase}\n\nLATER PHASES (DO NOT IMPLEMENT):\n- Phase {next-phase}: {phase-name} - {task-summary}\n- Phase {next+1}: {phase-name} - {task-summary}\n...\n\nIf implementing work beyond this phase's tasks, STOP and report scope violation.\n```\n\n**Why critical:** Spec describes WHAT to build (entire feature). Plan describes HOW/WHEN (phase breakdown). Subagents need both to avoid scope creep.\n\n### Step 4: Dispatch Parallel Tasks\n\n**CRITICAL: Single message with multiple Task tool calls (true parallelism):**\n\n**Only dispatch for PENDING tasks** (from Step 1.5). Completed tasks already have branches and should not be re-executed.\n\nFor each pending task, spawn subagent with embedded instructions (dispatch ALL in single message):\n```\nTask(Implement Task {task-id}: {task-name})\n\nROLE: Implement Task {task-id} in isolated worktree (parallel phase)\n\nWORKTREE: .worktrees/{run-id}-task-{task-id}\n\nTASK: {task-name}\nFILES: {files-list}\nACCEPTANCE CRITERIA: {criteria}\n\nPHASE BOUNDARIES:\n===== PHASE BOUNDARIES - CRITICAL =====\n\nPhase {current-phase-id}/{total-phases}: {phase-name}\nThis phase includes ONLY: Task {task-ids-in-this-phase}\n\nDO NOT CREATE ANY FILES from later phases.\n\nLater phases (DO NOT CREATE):\n- Phase {next-phase}: {phase-name} - {task-summary}\n  ‚ùå NO implementation files\n  ‚ùå NO stub functions (even with TODOs)\n  ‚ùå NO type definitions or interfaces\n  ‚ùå NO test scaffolding or temporary code\n\nIf tempted to create ANY file from later phases, STOP.\n\"Not fully implemented\" = violation.\n\"Just types/stubs/tests\" = violation.\n\"Temporary/for testing\" = violation.\n\n==========================================\n\nCONTEXT REFERENCES:\n- Spec: specs/{run-id}-{feature-slug}/spec.md\n- Constitution: docs/constitutions/current/\n- Plan: specs/{run-id}-{feature-slug}/plan.md\n- Worktree: .worktrees/{run-id}-task-{task-id}\n\nINSTRUCTIONS:\n\n1. Navigate to isolated worktree:\n   cd .worktrees/{run-id}-task-{task-id}\n\n2. Read constitution (if exists): docs/constitutions/current/\n\n3. Read feature specification: specs/{run-id}-{feature-slug}/spec.md\n\n   This provides:\n   - WHAT to build (requirements, user flows)\n   - WHY decisions were made (architecture rationale)\n   - HOW features integrate (system boundaries)\n\n   The spec is your source of truth for architectural decisions.\n   Constitution tells you HOW to code. Spec tells you WHAT to build.\n\n4. VERIFY PHASE SCOPE before implementing:\n   - Read the PHASE BOUNDARIES section above\n   - Confirm this task belongs to Phase {current-phase-id}\n   - If tempted to implement later phase work, STOP\n   - The plan exists for a reason - respect phase boundaries\n\n5. Implement task following spec + constitution + phase boundaries\n\n6. Run quality checks with exit code validation:\n\n   **CRITICAL**: Use heredoc to prevent bash parsing errors:\n\n   bash <<'EOF'\n   npm test\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Tests failed\"\n     exit 1\n   fi\n\n   npm run lint\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Lint failed\"\n     exit 1\n   fi\n\n   npm run build\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Build failed\"\n     exit 1\n   fi\n   EOF\n\n   **Why heredoc**: Prevents parsing errors when commands are wrapped by orchestrator.\n\n7. Create branch and detach HEAD using verification skill:\n\n   Skill: phase-task-verification\n\n   Parameters:\n   - RUN_ID: {run-id}\n   - TASK_ID: {phase}-{task}\n   - TASK_NAME: {short-name}\n   - COMMIT_MESSAGE: \"[Task {phase}.{task}] {task-name}\"\n   - MODE: parallel\n\n   The verification skill will:\n   a) Stage changes with git add .\n   b) Create branch with gs branch create\n   c) Detach HEAD with git switch --detach\n   d) Verify HEAD is detached (makes branch accessible in parent repo)\n\n8. Report completion\n\nCRITICAL:\n- Work in .worktrees/{run-id}-task-{task-id}, NOT main repo\n- Do NOT stay on branch - verification skill detaches HEAD\n- Do NOT create additional worktrees\n- Do NOT implement work from later phases (check PHASE BOUNDARIES above)\n```\n\n**Parallel dispatch:** All pending tasks dispatched in single message (true concurrency).\n\n**Red flags:**\n- \"I'll just do it myself\" - NO. Subagents provide fresh context.\n- \"Execute sequentially in main worktree\" - NO. Destroys parallelism.\n- \"Spec mentions feature X, I'll implement it now\" - NO. Check phase boundaries first.\n- \"I'll run git add myself\" - NO. Let subagent use phase-task-verification skill.\n\n### Step 5: Verify Completion (BEFORE Stacking)\n\n**Check ALL task branches exist AND have commits (includes both previously completed and newly created):**\n\n```bash\nCOMPLETED_TASKS=()\nFAILED_TASKS=()\n\n# Get base commit to verify branches have new work\nBASE_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\nBASE_SHA=$(git rev-parse \"$BASE_BRANCH\")\n\n# Check ALL task IDs, not just pending - need to verify complete set exists\nfor TASK_ID in {task-ids}; do\n  # Use pattern matching to find branch (short-name varies)\n  BRANCH_PATTERN=\"{runid}-task-{phase-id}-${TASK_ID}-\"\n  BRANCH_NAME=$(git branch | grep \"^  ${BRANCH_PATTERN}\" | sed 's/^  //' | head -n1)\n\n  if [ -z \"$BRANCH_NAME\" ]; then\n    FAILED_TASKS+=(\"Task ${TASK_ID}: Branch not found\")\n    continue\n  fi\n\n  # Verify branch has commits beyond base\n  BRANCH_SHA=$(git rev-parse \"$BRANCH_NAME\")\n  if [ \"$BRANCH_SHA\" = \"$BASE_SHA\" ]; then\n    FAILED_TASKS+=(\"Task ${TASK_ID}: Branch '$BRANCH_NAME' has no commits (still at base $BASE_SHA)\")\n    continue\n  fi\n\n  COMPLETED_TASKS+=(\"Task ${TASK_ID}: $BRANCH_NAME @ $BRANCH_SHA\")\ndone\n\nif [ ${#FAILED_TASKS[@]} -gt 0 ]; then\n  echo \"‚ùå Phase {phase-id} execution failed\"\n  echo \"\"\n  echo \"Completed tasks:\"\n  for task in \"${COMPLETED_TASKS[@]}\"; do\n    echo \"  ‚úÖ $task\"\n  done\n  echo \"\"\n  echo \"Failed tasks:\"\n  for task in \"${FAILED_TASKS[@]}\"; do\n    echo \"  ‚ùå $task\"\n  done\n  echo \"\"\n  echo \"Common causes:\"\n  echo \"- Subagent failed to implement task (check output above)\"\n  echo \"- Quality checks blocked commit (test/lint/build failures)\"\n  echo \"- git add . found no changes (implementation missing)\"\n  echo \"- gs branch create failed (check git-spice errors)\"\n  echo \"\"\n  echo \"To resume:\"\n  echo \"1. Review subagent output above for failure details\"\n  echo \"2. Fix failed task(s) in .worktrees/{runid}-task-{task-id}\"\n  echo \"3. Run quality checks manually to verify fixes\"\n  echo \"4. Create branch manually: gs branch create {runid}-task-{phase-id}-{task-id}-{name} -m 'message'\"\n  echo \"5. Re-run /spectacular:execute to complete phase\"\n  exit 1\nfi\n\necho \"‚úÖ All {task-count} tasks completed with valid commits\"\n```\n\n**Why verify:** Agents can fail. Quality checks can block commits. Verify branches exist before stacking.\n\n**Red flags:**\n- \"Agents said success, skip check\" - NO. Agent reports ‚â† branch existence.\n- \"Trust but don't verify\" - NO. Verify preconditions.\n\n### Step 6: Stack Branches Linearly (BEFORE Cleanup)\n\n**Use loop-based algorithm for any N (orchestrator stays in main repo):**\n\n```bash\n# Stack branches in main worktree using heredoc (orchestrator doesn't cd)\nbash <<'EOF'\ncd .worktrees/{runid}-main\n\n# Get base branch (what parallel tasks should stack onto)\nBASE_BRANCH=$(git branch --show-current)\n\n# Ensure base branch is tracked before stacking onto it\n# (Sequential phases may have created branches without tracking)\nif ! gs branch track --show \"$BASE_BRANCH\" >/dev/null 2>&1; then\n  echo \"‚è∫ Base branch not tracked yet, tracking now: $BASE_BRANCH\"\n  git checkout \"$BASE_BRANCH\"\n  gs branch track\nfi\n\nTASK_BRANCHES=( {array-of-branch-names} )\nTASK_COUNT=${#TASK_BRANCHES[@]}\n\n# Handle N=1 edge case\nif [ $TASK_COUNT -eq 1 ]; then\n  git checkout \"${TASK_BRANCHES[0]}\"\n  gs branch track\n  gs upstack onto \"$BASE_BRANCH\"  # Explicitly set base for single parallel task\nelse\n  # Handle N‚â•2\n  for i in \"${!TASK_BRANCHES[@]}\"; do\n    BRANCH=\"${TASK_BRANCHES[$i]}\"\n\n    if [ $i -eq 0 ]; then\n      # First task: track + upstack onto base branch (from previous phase)\n      git checkout \"$BRANCH\"\n      gs branch track\n      gs upstack onto \"$BASE_BRANCH\"  # Connect to previous phase's work\n    else\n      # Subsequent: track + upstack onto previous\n      PREV_BRANCH=\"${TASK_BRANCHES[$((i-1))]}\"\n      git checkout \"$BRANCH\"\n      gs branch track\n      gs upstack onto \"$PREV_BRANCH\"\n    fi\n  done\nfi\n\n# Leave main worktree on last branch for next phase continuity\n# Sequential phases will naturally stack on this branch\n\n# Display stack\necho \"üìã Stack after parallel phase:\"\ngs log short\necho \"\"\n\n# Verify stack correctness (catch duplicate commits)\necho \"üîç Verifying stack integrity...\"\nSTACK_VALID=1\ndeclare -A SEEN_COMMITS\n\nfor BRANCH in \"${TASK_BRANCHES[@]}\"; do\n  BRANCH_SHA=$(git rev-parse \"$BRANCH\")\n\n  # Check if this commit SHA was already seen\n  if [ -n \"${SEEN_COMMITS[$BRANCH_SHA]}\" ]; then\n    echo \"‚ùå ERROR: Stack integrity violation\"\n    echo \"   Branch '$BRANCH' points to commit $BRANCH_SHA\"\n    echo \"   But '${SEEN_COMMITS[$BRANCH_SHA]}' already points to that commit\"\n    echo \"\"\n    echo \"This means one of these branches has no unique commits.\"\n    echo \"Possible causes:\"\n    echo \"- Subagent failed to commit work\"\n    echo \"- Quality checks blocked commit\"\n    echo \"- Branch creation succeeded but commit failed\"\n    STACK_VALID=0\n    break\n  fi\n\n  SEEN_COMMITS[$BRANCH_SHA]=\"$BRANCH\"\n  echo \"  ‚úì $BRANCH @ $BRANCH_SHA\"\ndone\n\nif [ $STACK_VALID -eq 0 ]; then\n  echo \"\"\n  echo \"‚ùå Stack verification FAILED - preserving worktrees for debugging\"\n  echo \"\"\n  echo \"To investigate:\"\n  echo \"1. Check branch commits: git log --oneline $BRANCH\"\n  echo \"2. Check worktree state: ls -la .worktrees/\"\n  echo \"3. Review subagent output for failed task\"\n  echo \"4. Fix manually, then re-run /spectacular:execute\"\n  exit 1\nfi\n\necho \"‚úÖ Stack integrity verified - all branches have unique commits\"\nEOF\n```\n\n**Why heredoc:** Orchestrator stays in main repo. Heredoc creates subshell that navigates to worktree and exits.\n\n**Why before cleanup:** Need worktrees accessible for debugging if stacking fails.\n\n**Why verify stack:** Catches duplicate commits (two branches pointing to same SHA) which indicates missing work.\n\n**Red flag:** \"Clean up first to free disk space\" - NO. Stacking MUST happen first, and verification before cleanup.\n\n### Step 7: Clean Up Worktrees (AFTER Stacking)\n\n**IMPORTANT**: This step only runs if Step 5 verification passes. If any task fails, Step 5 exits with code 1, aborting the workflow. Failed task worktrees are preserved for debugging.\n\n**Remove task worktrees:**\n\n```bash\nfor TASK_ID in {task-ids}; do\n  git worktree remove \".worktrees/{runid}-task-${TASK_ID}\"\ndone\n\n# Verify cleanup\ngit worktree list | grep \"{runid}-task-\"\n# Should be empty\n```\n\n**Why after stacking:** Branches must be stacked and verified before destroying evidence.\n\n**Why conditional**: Failed worktrees must be preserved so users can debug, fix, and manually create branches before resuming.\n\n### Step 8: Code Review (Binary Quality Gate)\n\n**Check review frequency setting (from execute.md Step 1.7):**\n\n```bash\nREVIEW_FREQUENCY=${REVIEW_FREQUENCY:-per-phase}\n```\n\n**If REVIEW_FREQUENCY is \"end-only\" or \"skip\":**\n```\nSkipping per-phase code review (frequency: {REVIEW_FREQUENCY})\nPhase {N} complete - proceeding to next phase\n```\nMark phase complete and continue to next phase.\n\n**If REVIEW_FREQUENCY is \"optimize\":**\n\nAnalyze the completed phase to decide if code review is needed:\n\n**High-risk indicators (REVIEW REQUIRED):**\n- Schema or migration changes\n- Authentication/authorization logic\n- External API integrations or webhooks\n- Foundation phases (Phase 1-2 establishing patterns)\n- 3+ parallel tasks (coordination complexity)\n- New architectural patterns introduced\n- Security-sensitive code (payment, PII, access control)\n- Complex business logic with multiple edge cases\n- Changes affecting multiple layers (database ‚Üí API ‚Üí UI)\n\n**Low-risk indicators (SKIP REVIEW):**\n- Pure UI component additions (no state/logic)\n- Documentation or comment updates\n- Test additions without implementation changes\n- Refactoring with existing test coverage\n- Isolated utility functions\n- Configuration file updates (non-security)\n\n**Analyze this phase:**\n- Phase number: {N}\n- Tasks completed in parallel: {task-list}\n- Files modified across tasks: {file-list}\n- Types of changes: {describe changes}\n\n**Decision:**\nIf ANY high-risk indicator present ‚Üí Proceed to code review below\nIf ONLY low-risk indicators ‚Üí Skip review:\n```\n‚úì Phase {N} assessed as low-risk - skipping review (optimize mode)\n  Reasoning: {brief explanation of why low-risk}\nPhase {N} complete - proceeding to next phase\n```\n\n**If REVIEW_FREQUENCY is \"per-phase\" OR optimize mode decided to review:**\n\nUse `requesting-code-review` skill to call code-reviewer agent, then parse results STRICTLY:\n\n**CRITICAL - AUTONOMOUS EXECUTION (NO USER PROMPTS):**\n\nThis is an automated execution workflow. Code review rejections trigger automatic fix loops, NOT user prompts.\n\n**NEVER ask user what to do, even if:**\n- Issues seem \"architectural\" or \"require product decisions\"\n- Scope creep with passing quality checks (implement less, not ask)\n- Multiple rejections (use escalation limit at 3, not ask user)\n- Uncertain how to fix (fix subagent figures it out with spec + constitution context)\n- Code works but violates plan (plan violation = failure, auto-fix to plan)\n\n**Autonomous execution means AUTONOMOUS.** User prompts break automation and violate this skill.\n\n1. **Dispatch code review:**\n   ```\n   Skill tool: requesting-code-review\n\n   Context provided to reviewer:\n   - WORKTREE: .worktrees/{runid}-main\n   - PHASE: {phase-number}\n   - TASKS: {task-list}\n   - BASE_BRANCH: {base-branch-name}\n   - SPEC: specs/{run-id}-{feature-slug}/spec.md\n   - PLAN: specs/{run-id}-{feature-slug}/plan.md (for phase boundary validation)\n\n   **CRITICAL - EXHAUSTIVE FIRST-PASS REVIEW:**\n\n   This is your ONLY opportunity to find issues. Re-review is for verifying fixes, NOT discovering new problems.\n\n   Check EVERYTHING in this single review:\n   ‚ñ° Implementation correctness - logic bugs, edge cases, error handling, race conditions\n   ‚ñ° Test correctness - expectations match actual behavior, coverage is complete, no false positives\n   ‚ñ° Cross-file consistency - logic coherent across all files, no contradictions\n   ‚ñ° Architectural soundness - follows patterns, proper separation of concerns, no coupling issues\n   ‚ñ° Scope adherence - implements ONLY Phase {phase-number} work, no later-phase implementations\n   ‚ñ° Constitution compliance - follows all project standards and conventions\n\n   Find ALL issues NOW. If you catch yourself thinking \"I'll check that in re-review\" - STOP. Check it NOW.\n\n   Binary verdict required: \"Ready to merge? Yes\" (only if EVERYTHING passes) or \"Ready to merge? No\" (list ALL issues found)\n   ```\n\n2. **Parse output using binary algorithm:**\n\n   Read the code review output and search for \"Ready to merge?\" field:\n\n   - ‚úÖ **\"Ready to merge? Yes\"** ‚Üí APPROVED\n     - Announce: \"‚úÖ Code review APPROVED - Phase {N} complete, proceeding\"\n     - Continue to next phase\n\n   - ‚ùå **\"Ready to merge? No\"** ‚Üí REJECTED\n     - STOP execution\n     - Report: \"‚ùå Code review REJECTED - critical issues found\"\n     - List all Critical and Important issues from review\n     - Dispatch fix subagent IMMEDIATELY (no user prompt, no questions)\n     - Go to step 5 (re-review after fixes)\n\n   - ‚ùå **\"Ready to merge? With fixes\"** ‚Üí REJECTED\n     - STOP execution\n     - Report: \"‚ùå Code review requires fixes before proceeding\"\n     - List all issues from review\n     - Dispatch fix subagent IMMEDIATELY (no user prompt, no questions)\n     - Go to step 5 (re-review after fixes)\n\n   - ‚ö†Ô∏è **No output / empty response** ‚Üí RETRY ONCE\n     - Warn: \"‚ö†Ô∏è Code review returned no output - retrying once\"\n     - This may be a transient issue (timeout, connection error)\n     - Go to step 3 (retry review)\n     - If retry ALSO has no output ‚Üí FAILURE (go to step 4)\n\n   - ‚ùå **Soft language (e.g., \"APPROVED WITH MINOR SUGGESTIONS\")** ‚Üí REJECTED\n     - STOP execution\n     - Report: \"‚ùå Code review used soft language instead of binary verdict\"\n     - Warn: \"Binary gate requires explicit 'Ready to merge? Yes'\"\n     - Go to step 3 (re-review)\n\n   - ‚ö†Ô∏è **Missing \"Ready to merge?\" field** ‚Üí RETRY ONCE\n     - Warn: \"‚ö†Ô∏è Code review output missing 'Ready to merge?' field - retrying once\"\n     - This may be a transient issue (network glitch, model error)\n     - Go to step 3 (retry review)\n     - If retry ALSO missing field ‚Üí FAILURE (go to step 4)\n\n3. **Retry review (if malformed output):**\n   - Dispatch `requesting-code-review` skill again with same parameters\n   - Parse retry output using step 2 binary algorithm\n   - If retry succeeds with \"Ready to merge? Yes\":\n     - Announce: \"‚úÖ Code review APPROVED (retry succeeded) - Phase {N} complete, proceeding\"\n     - Continue to next phase\n   - If retry returns valid verdict (No/With fixes):\n     - Follow normal REJECTED flow (fix issues, re-review)\n   - If retry ALSO has missing \"Ready to merge?\" field:\n     - Go to step 4 (both attempts failed)\n\n4. **Both attempts malformed (FAILURE):**\n   - STOP execution immediately\n   - Report: \"‚ùå Code review failed twice with malformed output\"\n   - Display excerpts from both attempts for debugging\n   - Suggest: \"Review agent may not be following template - check code-reviewer skill\"\n   - DO NOT hallucinate issues from malformed text\n   - DO NOT dispatch fix subagents\n   - Fail execution\n\n5. **Re-review loop (if REJECTED with valid verdict):**\n\n   **Initialize iteration tracking:**\n   ```bash\n   REJECTION_COUNT=0\n   ```\n\n   **On each rejection:**\n   ```bash\n   REJECTION_COUNT=$((REJECTION_COUNT + 1))\n\n   # Check escalation limit\n   if [ $REJECTION_COUNT -gt 3 ]; then\n     echo \"‚ö†Ô∏è  Code review rejected $REJECTION_COUNT times\"\n     echo \"\"\n     echo \"Issues may require architectural changes beyond subagent scope.\"\n     echo \"Reporting to user for manual intervention:\"\n     echo \"\"\n     # Display all issues from latest review\n     # Suggest: Review architectural assumptions, may need spec revision\n     exit 1\n   fi\n\n   # Dispatch fix subagent\n   echo \"üîß Dispatching fix subagent to address issues (attempt $REJECTION_COUNT)...\"\n\n   # Use Task tool to dispatch fix subagent:\n   Task(Fix Phase {N} code review issues)\n   Prompt: Fix the following issues found in Phase {N} code review:\n\n   {List all issues from review output with severity (Critical/Important/Minor) and file locations}\n\n   CONTEXT FOR FIXES:\n\n   1. Read constitution (if exists): docs/constitutions/current/\n\n   2. Read feature specification: specs/{run-id}-{feature-slug}/spec.md\n\n      The spec provides architectural context for fixes:\n      - WHY decisions were made (rationale for current implementation)\n      - HOW features should integrate (system boundaries)\n      - WHAT requirements must be met (acceptance criteria)\n\n   3. Read implementation plan: specs/{run-id}-{feature-slug}/plan.md\n\n      The plan provides phase boundaries and scope:\n      - WHEN to implement features (which phase owns what)\n      - WHAT tasks belong to Phase {N} (scope boundaries)\n      - WHAT tasks belong to later phases (do NOT implement)\n\n      **If scope creep detected (implemented work from later phases):**\n      - Roll back to Phase {N} scope ONLY\n      - Remove implementations that belong to later phases\n      - Keep ONLY the work defined in Phase {N} tasks\n      - The plan exists for a reason - respect phase boundaries\n\n   4. Apply fixes following spec + constitution + plan boundaries\n\n   CRITICAL: Work in .worktrees/{runid}-main\n   CRITICAL: Amend existing branch or add new commit (do NOT create new branch)\n   CRITICAL: Run all quality checks before completion (test, lint, build)\n   CRITICAL: Verify all issues resolved before reporting completion\n   CRITICAL: If scope creep, implement LESS not ask user what to keep\n\n   # After fix completes\n   echo \"‚è∫ Re-reviewing Phase {N} after fixes (iteration $((REJECTION_COUNT + 1)))...\"\n   # Return to step 1 (dispatch review again)\n   ```\n\n   **On approval after fixes:**\n   ```bash\n   echo \"‚úÖ Code review APPROVED (after $REJECTION_COUNT fix iteration(s)) - Phase {N} complete\"\n   ```\n\n   **Escalation triggers:**\n   - After 3 rejections: Stop and report to user\n   - Prevents infinite loops on unsolvable architectural problems\n   - User can review, adjust spec, or proceed manually\n\n**Critical:** Only \"Ready to merge? Yes\" allows proceeding. Everything else stops execution.\n\n**Phase completion:**\n- If `REVIEW_FREQUENCY=\"per-phase\"`: Phase complete ONLY when:\n  - ‚úÖ All branches created\n  - ‚úÖ Linear stack verified\n  - ‚úÖ Worktrees cleaned up\n  - ‚úÖ Code review returns \"Ready to merge? Yes\"\n- If `REVIEW_FREQUENCY=\"end-only\"` or `\"skip\"`: Phase complete when:\n  - ‚úÖ All branches created\n  - ‚úÖ Linear stack verified\n  - ‚úÖ Worktrees cleaned up\n  - (Code review skipped)\n\n## Rationalization Table\n\n| Excuse | Reality |\n|--------|---------|\n| \"Only 1 task, skip worktrees\" | N=1 still uses parallel architecture. No special case. |\n| \"Files don't overlap, skip isolation\" | Worktrees enable parallelism, not prevent conflicts. |\n| \"Already spent 30min on setup\" | Sunk cost fallacy. Worktrees ARE the parallel execution. |\n| \"Simpler to execute sequentially\" | Simplicity ‚â† correctness. Parallel phase = worktrees. |\n| \"Agents said success, skip verification\" | Agent reports ‚â† branch existence. Verify preconditions. |\n| \"Disk space pressure, clean up first\" | Stacking must happen before cleanup. No exceptions. |\n| \"Git commands work from anywhere\" | TRUE, but path resolution is CWD-relative. Verify location. |\n| \"I'll just do it myself\" | Subagents provide fresh context and true parallelism. |\n| \"Worktrees are overhead\" | Worktrees ARE the product. Parallelism is the value. |\n| \"Review rejected, let me ask user what to do\" | Autonomous execution means automatic fixes. No asking. |\n| \"Issues are complex, user should decide\" | Fix subagent handles complexity. That's the architecture. |\n| \"Safer to get user input before fixing\" | Re-review provides safety. Fix, review, repeat until clean. |\n| \"Scope creep but quality passes, ask user to choose\" | Plan violation = failure. Fix subagent removes extra scope automatically. |\n| \"Work is done correctly, just ahead of schedule\" | Phases exist for review isolation. Implement less, not merge early. |\n| \"Spec mentions feature X, might as well implement now\" | Spec = WHAT to build total. Plan = WHEN to build each piece. Check phase. |\n\n## Red Flags - STOP and Follow Process\n\nIf you're thinking ANY of these, you're about to violate the skill:\n\n- \"This is basically sequential with N=1\"\n- \"Files don't conflict, isolation unnecessary\"\n- \"Worktree creation takes too long\"\n- \"Already behind schedule, skip setup\"\n- \"Agents succeeded, no need to verify\"\n- \"Disk space warning, clean up now\"\n- \"Current directory looks right\"\n- \"Relative paths are cleaner\"\n\n**All of these mean: STOP. Follow the process exactly.**\n\n## Common Mistakes\n\n### Mistake 1: Treating Parallel as \"Logically Independent\"\n\n**Wrong mental model:** \"Parallel means tasks are independent, so I can execute them sequentially in one worktree.\"\n\n**Correct model:** \"Parallel means tasks execute CONCURRENTLY via multiple subagents in isolated worktrees.\"\n\n**Impact:** Destroys parallelism. Turns 3-hour calendar time into 9-hour sequential execution.\n\n### Mistake 2: Efficiency Optimization\n\n**Wrong mental model:** \"Worktrees are overhead when files don't overlap.\"\n\n**Correct model:** \"Worktrees are the architecture. Without them, no concurrent execution exists.\"\n\n**Impact:** Sequential execution disguised as parallel. No time savings.\n\n### Mistake 3: Cleanup Sequencing\n\n**Wrong mental model:** \"Branches exist independently of worktrees, so cleanup order doesn't matter.\"\n\n**Correct model:** \"Stacking before cleanup allows debugging if stacking fails and runs integration tests on complete stack.\"\n\n**Impact:** Can't debug stacking failures. Premature cleanup destroys evidence.\n\n## Quick Reference\n\n**Mandatory sequence (no variations):**\n\n1. Verify location (main repo root)\n2. Create worktrees (ALL tasks, including N=1)\n3. Install dependencies (per worktree)\n4. Spawn subagents (parallel dispatch)\n5. Verify branches exist (before stacking)\n6. Stack branches (before cleanup)\n7. Clean up worktrees (after stacking)\n8. Code review\n\n**Never skip. Never reorder. No exceptions.**\n\n## The Bottom Line\n\n**Parallel phases use worktrees.** Always. Even N=1. Even when files don't overlap. Even under pressure.\n\nIf you're not creating worktrees, you're not executing parallel phases - you're executing sequential phases incorrectly labeled as parallel.\n\nThe skill is the architecture. Follow it exactly."
              },
              {
                "name": "executing-sequential-phase",
                "description": "Use when orchestrating sequential phases in plan execution - executes tasks one-by-one in main worktree using git-spice natural stacking (NO manual upstack commands, NO worktree creation, tasks build on each other)",
                "path": "skills/executing-sequential-phase/SKILL.md",
                "frontmatter": {
                  "name": "executing-sequential-phase",
                  "description": "Use when orchestrating sequential phases in plan execution - executes tasks one-by-one in main worktree using git-spice natural stacking (NO manual upstack commands, NO worktree creation, tasks build on each other)"
                },
                "content": "# Executing Sequential Phase\n\n## Overview\n\n**Sequential phases use natural git-spice stacking in the main worktree.**\n\nEach task creates a branch with `gs branch create`, which automatically stacks on the current HEAD. No manual stacking operations needed.\n\n**Critical distinction:** Sequential tasks BUILD ON each other. They need integration, not isolation.\n\n## When to Use\n\nUse this skill when `execute` command encounters a phase marked \"Sequential\" in plan.md:\n- ‚úÖ Tasks must run in order (dependencies)\n- ‚úÖ Execute in existing `{runid}-main` worktree\n- ‚úÖ Trust natural stacking (no manual `gs upstack onto`)\n- ‚úÖ Stay on task branches (don't switch to base between tasks)\n\n**Sequential phases never use worktrees.** They share one workspace where tasks build cumulatively.\n\n## The Natural Stacking Principle\n\n```\nSEQUENTIAL PHASE = MAIN WORKTREE + NATURAL STACKING\n```\n\n**What natural stacking means:**\n1. Start on base branch (or previous task's branch)\n2. Create new branch with `gs branch create` ‚Üí automatically stacks on current\n3. Stay on that branch when done\n4. Next task creates from there ‚Üí automatically stacks on previous\n\n**No manual commands needed.** The workflow IS the stacking.\n\n## The Process\n\n**Announce:** \"I'm using executing-sequential-phase to execute {N} tasks sequentially in Phase {phase-id}.\"\n\n### Step 0: Verify Orchestrator Location\n\n**MANDATORY: Verify orchestrator is in main repo root before any operations:**\n\n```bash\nREPO_ROOT=$(git rev-parse --show-toplevel)\nCURRENT=$(pwd)\n\nif [ \"$CURRENT\" != \"$REPO_ROOT\" ]; then\n  echo \"‚ùå Error: Orchestrator must run from main repo root\"\n  echo \"Current: $CURRENT\"\n  echo \"Expected: $REPO_ROOT\"\n  echo \"\"\n  echo \"Return to main repo: cd $REPO_ROOT\"\n  exit 1\nfi\n\necho \"‚úÖ Orchestrator location verified: Main repo root\"\n```\n\n**Why critical:**\n- Orchestrator delegates work but never changes directory\n- All operations use `git -C .worktrees/path` or `bash -c \"cd path && cmd\"`\n- This assertion catches upstream drift immediately\n\n### Step 1: Verify Setup and Base Branch\n\n**First, verify we're on the correct base branch for this phase:**\n\n```bash\n# Get current branch in main worktree\nCURRENT_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\nEXPECTED_BASE=\"{expected-base-branch}\"  # From plan: previous phase's last task, or {runid}-main for Phase 1\n\nif [ \"$CURRENT_BRANCH\" != \"$EXPECTED_BASE\" ]; then\n  echo \"‚ö†Ô∏è  WARNING: Phase {phase-id} starting from unexpected branch\"\n  echo \"   Current: $CURRENT_BRANCH\"\n  echo \"   Expected: $EXPECTED_BASE\"\n  echo \"\"\n  echo \"This means the previous phase ended on the wrong branch.\"\n  echo \"Possible causes:\"\n  echo \"- Code review or quality checks switched branches\"\n  echo \"- User manually checked out different branch\"\n  echo \"- Resume from interrupted execution\"\n  echo \"\"\n  echo \"To fix:\"\n  echo \"1. Verify previous phase completed: git log --oneline $EXPECTED_BASE\"\n  echo \"2. Switch to correct base: cd .worktrees/{runid}-main && git checkout $EXPECTED_BASE\"\n  echo \"3. Re-run /spectacular:execute\"\n  exit 1\nfi\n\necho \"‚úÖ Phase {phase-id} starting from correct base: $CURRENT_BRANCH\"\n```\n\n**Then check and install dependencies from main repo (orchestrator never cd's):**\n\n```bash\n# Check if dependencies installed in main worktree\nif [ ! -d .worktrees/{runid}-main/node_modules ]; then\n  echo \"Installing dependencies in main worktree...\"\n  bash <<'EOF'\n  cd .worktrees/{runid}-main\n  {install-command}\n  {postinstall-command}\n  EOF\nfi\n```\n\n**Why heredoc:** Orchestrator stays in main repo. Heredoc creates subshell that exits after commands.\n\n**Why main worktree:** Sequential tasks were created during spec generation. All sequential phases share this worktree.\n\n**Red flag:** \"Create phase-specific worktree\" - NO. Sequential = shared worktree.\n\n### Step 1.5: Extract Phase Context (Before Dispatching)\n\n**Before spawning subagents, extract phase boundaries from plan:**\n\nThe orchestrator already parsed the plan in execute.md Step 1. Extract:\n- Current phase number and name\n- Tasks in THIS phase (what TO implement)\n- Tasks in LATER phases (what NOT to implement)\n\n**Format for subagent context:**\n```\nPHASE CONTEXT:\n- Phase {current-phase-id}/{total-phases}: {phase-name}\n- This phase includes: Task {task-ids-in-this-phase}\n\nLATER PHASES (DO NOT IMPLEMENT):\n- Phase {next-phase}: {phase-name} - {task-summary}\n- Phase {next+1}: {phase-name} - {task-summary}\n...\n\nIf implementing work beyond this phase's tasks, STOP and report scope violation.\n```\n\n**Why critical:** Spec describes WHAT to build (entire feature). Plan describes HOW/WHEN (phase breakdown). Subagents need both to avoid scope creep.\n\n### Step 2: Execute Tasks Sequentially\n\n**For each task in order, spawn ONE subagent with embedded instructions:**\n\n```\nTask(Implement Task {task-id}: {task-name})\n\nROLE: Implement Task {task-id} in main worktree (sequential phase)\n\nWORKTREE: .worktrees/{run-id}-main\nCURRENT BRANCH: {current-branch}\n\nTASK: {task-name}\nFILES: {files-list}\nACCEPTANCE CRITERIA: {criteria}\n\nPHASE BOUNDARIES:\n===== PHASE BOUNDARIES - CRITICAL =====\n\nPhase {current-phase-id}/{total-phases}: {phase-name}\nThis phase includes ONLY: Task {task-ids-in-this-phase}\n\nDO NOT CREATE ANY FILES from later phases.\n\nLater phases (DO NOT CREATE):\n- Phase {next-phase}: {phase-name} - {task-summary}\n  ‚ùå NO implementation files\n  ‚ùå NO stub functions (even with TODOs)\n  ‚ùå NO type definitions or interfaces\n  ‚ùå NO test scaffolding or temporary code\n\nIf tempted to create ANY file from later phases, STOP.\n\"Not fully implemented\" = violation.\n\"Just types/stubs/tests\" = violation.\n\"Temporary/for testing\" = violation.\n\n==========================================\n\nCONTEXT REFERENCES:\n- Spec: specs/{run-id}-{feature-slug}/spec.md\n- Constitution: docs/constitutions/current/\n- Plan: specs/{run-id}-{feature-slug}/plan.md\n- Worktree: .worktrees/{run-id}-main\n\nINSTRUCTIONS:\n\n1. Navigate to main worktree:\n   cd .worktrees/{run-id}-main\n\n2. Read constitution (if exists): docs/constitutions/current/\n\n3. Read feature specification: specs/{run-id}-{feature-slug}/spec.md\n\n   This provides:\n   - WHAT to build (requirements, user flows)\n   - WHY decisions were made (architecture rationale)\n   - HOW features integrate (system boundaries)\n\n   The spec is your source of truth for architectural decisions.\n   Constitution tells you HOW to code. Spec tells you WHAT to build.\n\n4. VERIFY PHASE SCOPE before implementing:\n   - Read the PHASE BOUNDARIES section above\n   - Confirm this task belongs to Phase {current-phase-id}\n   - If tempted to implement later phase work, STOP\n   - The plan exists for a reason - respect phase boundaries\n\n5. Implement task following spec + constitution + phase boundaries\n\n6. Run quality checks with exit code validation:\n\n   **CRITICAL**: Use heredoc to prevent bash parsing errors:\n\n   bash <<'EOF'\n   npm test\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Tests failed\"\n     exit 1\n   fi\n\n   npm run lint\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Lint failed\"\n     exit 1\n   fi\n\n   npm run build\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Build failed\"\n     exit 1\n   fi\n   EOF\n\n   **Why heredoc**: Prevents parsing errors when commands are wrapped by orchestrator.\n\n7. Create stacked branch using verification skill:\n\n   Skill: phase-task-verification\n\n   Parameters:\n   - RUN_ID: {run-id}\n   - TASK_ID: {phase}-{task}\n   - TASK_NAME: {short-name}\n   - COMMIT_MESSAGE: \"[Task {phase}.{task}] {task-name}\"\n   - MODE: sequential\n\n   The verification skill will:\n   a) Stage changes with git add .\n   b) Create branch with gs branch create\n   c) Verify HEAD points to new branch\n   d) Stay on branch (next task builds on it)\n\n8. Report completion\n\nCRITICAL:\n- Work in .worktrees/{run-id}-main, NOT main repo\n- Stay on your branch when done (next task builds on it)\n- Do NOT create worktrees\n- Do NOT use `gs upstack onto`\n- Do NOT implement work from later phases (check PHASE BOUNDARIES above)\n```\n\n**Sequential dispatch:** Wait for each task to complete before starting next.\n\n**Red flags:**\n- \"Dispatch all tasks in parallel\" - NO. Sequential = one at a time.\n- \"Create task-specific worktrees\" - NO. Sequential = shared worktree.\n- \"Spec mentions feature X, I'll implement it now\" - NO. Check phase boundaries first.\n- \"I'll run git add myself\" - NO. Let subagent use phase-task-verification skill.\n\n### Step 3: Verify Natural Stack Formation\n\n**After all tasks complete (verify from main repo):**\n\n```bash\n# Display and verify stack using bash subshell (orchestrator stays in main repo)\nbash <<'EOF'\ncd .worktrees/{runid}-main\n\necho \"üìã Stack after sequential phase:\"\ngs log short\necho \"\"\n\n# Verify stack integrity (each task has unique commit)\necho \"üîç Verifying stack integrity...\"\nTASK_BRANCHES=( {array-of-branch-names} )\nSTACK_VALID=1\ndeclare -A SEEN_COMMITS\n\nfor BRANCH in \"${TASK_BRANCHES[@]}\"; do\n  if ! git rev-parse --verify \"$BRANCH\" >/dev/null 2>&1; then\n    echo \"‚ùå ERROR: Branch '$BRANCH' not found\"\n    STACK_VALID=0\n    break\n  fi\n\n  BRANCH_SHA=$(git rev-parse \"$BRANCH\")\n\n  # Check if this commit SHA was already seen\n  if [ -n \"${SEEN_COMMITS[$BRANCH_SHA]}\" ]; then\n    echo \"‚ùå ERROR: Stack integrity violation\"\n    echo \"   Branch '$BRANCH' points to commit $BRANCH_SHA\"\n    echo \"   But '${SEEN_COMMITS[$BRANCH_SHA]}' already points to that commit\"\n    echo \"\"\n    echo \"This means one task created no new commits.\"\n    echo \"Possible causes:\"\n    echo \"- Task implementation had no changes\"\n    echo \"- Quality checks blocked commit\"\n    echo \"- gs branch create failed silently\"\n    STACK_VALID=0\n    break\n  fi\n\n  SEEN_COMMITS[$BRANCH_SHA]=\"$BRANCH\"\n  echo \"  ‚úì $BRANCH @ $BRANCH_SHA\"\ndone\n\nif [ $STACK_VALID -eq 0 ]; then\n  echo \"\"\n  echo \"‚ùå Stack verification FAILED\"\n  echo \"\"\n  echo \"To investigate:\"\n  echo \"1. Check task branch commits: git log --oneline \\$BRANCH\"\n  echo \"2. Review subagent output for failed task\"\n  echo \"3. Check for quality check failures (test/lint/build)\"\n  echo \"4. Fix and re-run /spectacular:execute\"\n  exit 1\nfi\n\necho \"‚úÖ Stack integrity verified - all tasks have unique commits\"\nEOF\n```\n\n**Each `gs branch create` automatically stacked on the previous task's branch.**\n\n**Verification ensures:** Each task created a unique commit (no empty branches or duplicates).\n\n**Red flag:** \"Run `gs upstack onto` to ensure stacking\" - NO. Already stacked naturally.\n\n### Step 4: Code Review (Binary Quality Gate)\n\n**Check review frequency setting (from execute.md Step 1.7):**\n\n```bash\nREVIEW_FREQUENCY=${REVIEW_FREQUENCY:-per-phase}\n```\n\n**If REVIEW_FREQUENCY is \"end-only\" or \"skip\":**\n```\nSkipping per-phase code review (frequency: {REVIEW_FREQUENCY})\nPhase {N} complete - proceeding to next phase\n```\nMark phase complete and continue to next phase.\n\n**If REVIEW_FREQUENCY is \"optimize\":**\n\nAnalyze the completed phase to decide if code review is needed:\n\n**High-risk indicators (REVIEW REQUIRED):**\n- Schema or migration changes\n- Authentication/authorization logic\n- External API integrations or webhooks\n- Foundation phases (Phase 1-2 establishing patterns)\n- 3+ parallel tasks (coordination complexity)\n- New architectural patterns introduced\n- Security-sensitive code (payment, PII, access control)\n- Complex business logic with multiple edge cases\n- Changes affecting multiple layers (database ‚Üí API ‚Üí UI)\n\n**Low-risk indicators (SKIP REVIEW):**\n- Pure UI component additions (no state/logic)\n- Documentation or comment updates\n- Test additions without implementation changes\n- Refactoring with existing test coverage\n- Isolated utility functions\n- Configuration file updates (non-security)\n\n**Analyze this phase:**\n- Phase number: {N}\n- Tasks completed: {task-list}\n- Files modified: {file-list}\n- Types of changes: {describe changes}\n\n**Decision:**\nIf ANY high-risk indicator present ‚Üí Proceed to code review below\nIf ONLY low-risk indicators ‚Üí Skip review:\n```\n‚úì Phase {N} assessed as low-risk - skipping review (optimize mode)\n  Reasoning: {brief explanation of why low-risk}\nPhase {N} complete - proceeding to next phase\n```\n\n**If REVIEW_FREQUENCY is \"per-phase\" OR optimize mode decided to review:**\n\nUse `requesting-code-review` skill, then parse results STRICTLY.\n\n**AUTONOMOUS EXECUTION:** Code review rejections trigger automatic fix loops, NOT user prompts. Never ask user what to do.\n\n1. **Dispatch code review:**\n   ```\n   Skill: requesting-code-review\n\n   Context provided to reviewer:\n   - WORKTREE: .worktrees/{runid}-main\n   - PHASE: {phase-number}\n   - TASKS: {task-list}\n   - BASE_BRANCH: {base-branch-name}\n   - SPEC: specs/{run-id}-{feature-slug}/spec.md\n   - PLAN: specs/{run-id}-{feature-slug}/plan.md (for phase boundary validation)\n\n   **CRITICAL - EXHAUSTIVE FIRST-PASS REVIEW:**\n\n   This is your ONLY opportunity to find issues. Re-review is for verifying fixes, NOT discovering new problems.\n\n   Check EVERYTHING in this single review:\n   ‚ñ° Implementation correctness - logic bugs, edge cases, error handling, race conditions\n   ‚ñ° Test correctness - expectations match actual behavior, coverage is complete, no false positives\n   ‚ñ° Cross-file consistency - logic coherent across all files, no contradictions\n   ‚ñ° Architectural soundness - follows patterns, proper separation of concerns, no coupling issues\n   ‚ñ° Scope adherence - implements ONLY Phase {phase-number} work, no later-phase implementations\n   ‚ñ° Constitution compliance - follows all project standards and conventions\n\n   Find ALL issues NOW. If you catch yourself thinking \"I'll check that in re-review\" - STOP. Check it NOW.\n\n   Binary verdict required: \"Ready to merge? Yes\" (only if EVERYTHING passes) or \"Ready to merge? No\" (list ALL issues found)\n   ```\n\n2. **Parse \"Ready to merge?\" field:**\n   - **\"Yes\"** ‚Üí APPROVED, continue to next phase\n   - **\"No\"** or **\"With fixes\"** ‚Üí REJECTED, dispatch fix subagent, go to step 3\n   - **No output / missing field** ‚Üí RETRY ONCE, if retry fails ‚Üí STOP\n   - **Soft language** ‚Üí REJECTED, re-review required\n\n3. **Re-review loop (if REJECTED):**\n   - Track rejections (REJECTION_COUNT)\n   - If count > 3: Escalate to user (architectural issues beyond subagent scope)\n   - Dispatch fix subagent with:\n     * Issues list (severity + file locations)\n     * Context: constitution, spec, plan\n     * Scope enforcement: If scope creep, implement LESS (roll back to phase scope)\n     * Quality checks required\n   - Re-review after fixes (return to step 1)\n   - On approval: Announce completion with iteration count\n\n**Critical:** Only \"Ready to merge? Yes\" allows proceeding. Everything else stops execution.\n\n**Phase completion:**\n- If `REVIEW_FREQUENCY=\"per-phase\"`: Phase complete ONLY when code review returns \"Ready to merge? Yes\"\n- If `REVIEW_FREQUENCY=\"end-only\"` or `\"skip\"`: Phase complete after all tasks finish (code review skipped)\n\n## Rationalization Table\n\n| Excuse | Reality |\n|--------|---------|\n| \"Need manual stacking commands\" | `gs branch create` stacks automatically on current HEAD |\n| \"Files don't overlap, could parallelize\" | Plan says sequential for semantic dependencies |\n| \"Create phase-specific worktree\" | Sequential phases share main worktree |\n| \"Review rejected, ask user\" | Autonomous execution means automatic fixes |\n| \"Scope creep but quality passes\" | Plan violation = failure. Auto-fix to plan |"
              },
              {
                "name": "phase-task-verification",
                "description": "Shared branch creation and verification logic for sequential and parallel task execution - handles git operations, HEAD verification, and MODE-specific behavior",
                "path": "skills/phase-task-verification/SKILL.md",
                "frontmatter": {
                  "name": "phase-task-verification",
                  "description": "Shared branch creation and verification logic for sequential and parallel task execution - handles git operations, HEAD verification, and MODE-specific behavior"
                },
                "content": "# Phase Task Verification\n\n## When to Use\n\nInvoked by `sequential-phase-task` and `parallel-phase-task` after task implementation to create and verify git-spice branch.\n\n## Parameters\n\n- **RUN_ID**: 6-char run ID (e.g., \"8c8505\")\n- **TASK_ID**: Phase-task (e.g., \"1-1\")\n- **TASK_NAME**: Short name (e.g., \"create-verification-skill\")\n- **COMMIT_MESSAGE**: Full commit message\n- **MODE**: \"sequential\" or \"parallel\"\n\n## The Process\n\n**Step 1: Stage and create branch**\n```bash\ngit add .\ngs branch create {RUN_ID}-task-{TASK_ID}-{TASK_NAME} -m \"{COMMIT_MESSAGE}\"\n```\n\n**Step 2: Verify based on MODE**\n\n**MODE: sequential** - Verify HEAD points to expected branch:\n```bash\nCURRENT=$(git rev-parse --abbrev-ref HEAD)\nEXPECTED=\"{RUN_ID}-task-{TASK_ID}-{TASK_NAME}\"\n[ \"$CURRENT\" = \"$EXPECTED\" ] || { echo \"ERROR: HEAD=$CURRENT, expected $EXPECTED\"; exit 1; }\n```\n\n**MODE: parallel** - Detach HEAD (makes branch accessible in parent repo):\n```bash\ngit switch --detach\nCURRENT=$(git rev-parse --abbrev-ref HEAD)\n[ \"$CURRENT\" = \"HEAD\" ] || { echo \"ERROR: HEAD not detached ($CURRENT)\"; exit 1; }\n```\n\n## Rationalization Table\n\n| Rationalization | Why It's Wrong |\n|----------------|----------------|\n| \"Verification is optional\" | Silent failures lose work |\n| \"Skip detach in parallel mode\" | Breaks worktree cleanup |\n| \"Branch create errors are obvious\" | Silent failures aren't detected until cleanup fails |\n| \"Detach can happen later\" | Cleanup runs in parent repo - branch must be accessible |\n| \"HEAD verification adds overhead\" | <100ms cost prevents hours of lost work debugging |\n\n## Error Handling\n\n**git add fails:**\n- **No changes to stage**: Error is expected - task implementation failed or incomplete\n  - Check if task was actually implemented\n  - Verify files were modified in expected locations\n  - Do NOT continue with branch creation\n- **Permission issues**: Git repository permissions corrupted\n  - Check file ownership: `ls -la .git`\n  - Verify worktree is accessible\n  - Escalate to orchestrator\n\n**gs branch create fails:**\n- **Duplicate branch name**: Branch already exists\n  - Check existing branches: `git branch | grep {RUN_ID}-task-{TASK_ID}`\n  - Verify task wasn't already completed\n  - May indicate resume scenario - escalate to orchestrator\n- **Git-spice errors**: Repository state issues\n  - Run `gs repo sync` to fix state\n  - Verify git-spice initialized: `gs ls`\n  - Check for uncommitted changes blocking operation\n- **Invalid branch name**: Name contains invalid characters\n  - Verify RUN_ID is 6-char alphanumeric\n  - Verify TASK_NAME contains only alphanumeric + hyphens\n  - Do NOT sanitize - escalate to orchestrator (indicates data corruption)\n\n**HEAD verification fails (sequential mode):**\n- **Expected**: `gs branch create` should checkout new branch automatically\n- **Actual**: Still on previous branch or detached HEAD\n  - Indicates git-spice behavior change or bug\n  - Do NOT continue - task is not properly staged\n  - Escalate to orchestrator with exact HEAD state\n\n**HEAD verification fails (parallel mode):**\n- **Expected**: `git switch --detach` should detach HEAD\n- **Actual**: Still on branch after detach command\n  - Indicates git version issue or repository corruption\n  - Do NOT continue - cleanup will fail to access branch\n  - Escalate to orchestrator with git version: `git --version`"
              },
              {
                "name": "testing-workflows-with-subagents",
                "description": "Use when creating or editing commands, orchestrator prompts, or workflow documentation before deployment - applies RED-GREEN-REFACTOR to test instruction clarity by finding real execution failures, creating test scenarios, and verifying fixes with subagents",
                "path": "skills/testing-workflows-with-subagents/SKILL.md",
                "frontmatter": {
                  "name": "testing-workflows-with-subagents",
                  "description": "Use when creating or editing commands, orchestrator prompts, or workflow documentation before deployment - applies RED-GREEN-REFACTOR to test instruction clarity by finding real execution failures, creating test scenarios, and verifying fixes with subagents"
                },
                "content": "# Testing Workflows With Subagents\n\n## Overview\n\n**Testing workflows is TDD applied to orchestrator instructions and command documentation.**\n\nYou find real execution failures (git logs, error reports), create test scenarios that reproduce them, watch subagents follow ambiguous instructions incorrectly (RED), fix the instructions (GREEN), and verify subagents now follow correctly (REFACTOR).\n\n**Core principle:** If you didn't watch an agent misinterpret the instructions in a test, you don't know if your fix prevents the right failures.\n\n**REQUIRED BACKGROUND:** You MUST understand superpowers:test-driven-development before using this skill. That skill defines the fundamental RED-GREEN-REFACTOR cycle. This skill applies TDD to workflow documentation.\n\n## When to Use\n\nUse when:\n- Creating new commands (`.claude/commands/*.md`, `/spectacular:*`)\n- Editing orchestrator prompts for subagents\n- Updating workflow documentation in commands\n- You observed real execution failures (wrong branches, skipped steps, misinterpreted instructions)\n- Instructions involve multiple steps where order matters\n- Agents work under time pressure or cognitive load\n\nDon't test:\n- Pure reference documentation (no workflow steps)\n- Single-step commands with no ambiguity\n- Documentation without actionable instructions\n\n## TDD Mapping for Workflow Testing\n\n| TDD Phase | Workflow Testing | What You Do |\n|-----------|------------------|-------------|\n| **RED** | Find real failure | Check git logs, error reports for evidence of agents misinterpreting instructions |\n| **Verify RED** | Create failing test scenario | Reproduce the failure with test repo + pressure scenario |\n| **GREEN** | Fix instructions | Rewrite ambiguous steps with explicit ordering, warnings, examples |\n| **Verify GREEN** | Test with subagent | Same scenario with fixed instructions - agent follows correctly |\n| **REFACTOR** | Iterate on clarity | Find remaining ambiguities, improve wording, re-test |\n| **Stay GREEN** | Re-verify | Test again to ensure fix holds |\n\nSame cycle as code TDD, different test format.\n\n## RED Phase: Find Real Execution Failures\n\n**Goal:** Gather evidence of how instructions were misinterpreted in actual execution.\n\n**Where to look:**\n- **Git history**: Commits on wrong branches, missing branches, incorrect stack structure\n- **Run logs**: Steps skipped, wrong order executed, missing quality checks\n- **Error reports**: Failed tasks, cleanup issues, integration problems\n- **User reports**: \"Agents did X when I expected Y\"\n\n**Document evidence:**\n```markdown\n## RED Phase Evidence\n\n**Source**: bignight.party git log (Run ID: 082687)\n\n**Failure**: Task 4.3 commit on branch `082687-task-4.2-auth-domain-migration`\n\n**Expected**: Create branch `082687-task-4.3-server-actions`\n\n**Actual**: Committed to Task 4.2's branch instead\n\n**Root cause hypothesis**: Instructions ambiguous about creating branch before committing\n```\n\n**Critical:** Get actual git commits, branch names, error messages - not hypothetical scenarios.\n\n## Create RED Test Scenario\n\n**Goal:** Reproduce the failure in a controlled test environment.\n\n### Test Repository Setup\n\nCreate minimal repo that simulates real execution state:\n\n```bash\ncd /path/to/test-area\nmkdir workflow-test && cd workflow-test\ngit init\ngit config user.name \"Test\" && git config user.email \"test@test.com\"\n\n# Set up state that led to failure\n# (e.g., existing task branches for sequential phase testing)\n```\n\n### Pressure Scenario Document\n\nCreate test file with:\n1. **Role definition**: \"You are subagent implementing Task X\"\n2. **Current state**: Branch, uncommitted work, what's done\n3. **Actual instructions**: Copy current ambiguous instructions\n4. **Pressure context**: Combine 2-3 pressure types from table below\n5. **Options**: Give explicit choices (forces decision, no deferring)\n\n### Pressure Types for Workflow Testing\n\n| Pressure | Example | Effect on Agent |\n|----------|---------|-----------------|\n| **Time** | \"Orchestrator waiting\", \"4 more tasks to do\", \"Need to move fast\" | Skips reading skills, chooses fast option |\n| **Cognitive load** | \"2 hours in, tired\", \"Third sequential task\", \"Complex state\" | Misreads instructions, makes assumptions |\n| **Urgency** | \"Choose NOW\", \"Execute immediately\", \"No delays\" | Skips verification steps, commits to first interpretation |\n| **Task volume** | \"4 more tasks after this\", \"Part of 10-task phase\" | Rushes through steps, skips optional guidance |\n| **Complexity** | \"Multiple branches exist\", \"Shared worktree\", \"Parallel tasks running\" | Confused about current state, wrong branch |\n\n**Best test scenarios combine 2-3 pressures** to simulate realistic execution conditions.\n\n**Example:**\n```markdown\n# RED Test: Sequential Phase Task Execution\n\n**Role**: Implementation subagent for Task 2.3\n\n**Current state**: On branch `abc123-task-2-2-database`\nUncommitted changes in auth.js (your completed work)\n\n**Instructions from execute.md (CURRENT VERSION)**:\n```\n5. Use `using-git-spice` skill to:\n   - Create branch: abc123-task-2-3-auth\n   - Commit with message: \"[Task 2.3] Add auth\"\n```\n\n**Pressure**: 2 hours in, tired, 4 more tasks to do\n\n**Options**:\nA) Read skill (2 min delay)\nB) Just commit now\nC) Create branch with git, then commit\nD) Guess git-spice command\n\nChoose and execute NOW.\n```\n\n### Run RED Test\n\n```bash\n# Dispatch subagent with test scenario\n# Use haiku for speed and realistic \"under pressure\" behavior\n# Document exact choice and reasoning verbatim\n```\n\n**Expected RED result**: Agent makes wrong choice, commits to wrong branch, or skips creating branch.\n\nIf agent succeeds, your test scenario isn't realistic enough - add more pressure or make options more tempting.\n\n## GREEN Phase: Fix Instructions\n\n**Goal:** Rewrite instructions to prevent the specific failure observed in RED.\n\n### Analyze Root Cause\n\nFrom RED test, identify:\n- Which step was ambiguous?\n- What order was unclear?\n- What assumptions did agent make?\n- What did pressure cause them to skip?\n\n**Example analysis:**\n```markdown\n**Ambiguous**: \"Create branch\" and \"Commit\" as separate bullets\n**Unclear order**: Could mean \"create then commit\" OR \"commit then create\"\n**Assumption**: \"I'll just commit first, cleaner workflow\"\n**Pressure effect**: Skipped reading skill, chose fast option\n```\n\n### Fix Patterns\n\n**Pattern 1: Explicit Sequential Steps**\n\n<Before>\n```markdown\n- Create branch: X\n- Commit with message: Y\n- Stay on branch\n```\n</Before>\n\n<After>\n```markdown\na) FIRST: Stage changes\n   - Command: `git add .`\n\nb) THEN: Create branch (commits automatically)\n   - Command: `gs branch create X -m \"Y\"`\n\nc) Stay on new branch\n```\n</After>\n\n**Pattern 2: Critical Warnings**\n\nAdd consequences upfront:\n```markdown\nCRITICAL: Stage changes FIRST, then create branch.\n\nIf you commit BEFORE creating branch, work goes to wrong branch.\n```\n\n**Pattern 3: Show Commands**\n\nReduce friction under pressure - show exact commands:\n```markdown\nb) THEN: Create new stacked branch\n   - Command: `gs branch create {name} -m \"message\"`\n   - This creates branch and commits in one operation\n```\n\n**Pattern 4: Skill-Based Reference**\n\nBalance showing commands with learning:\n```markdown\nUse `using-git-spice` skill which teaches this two-step workflow:\n[commands here]\nRead the skill if uncertain about the workflow.\n```\n\n### Apply Fix\n\nEdit the actual command file with GREEN fix.\n\n## Verify GREEN: Test Fix\n\n**Goal:** Confirm agents now follow instructions correctly under same pressure.\n\n### Reset Test Repository\n\n```bash\ncd /path/to/workflow-test\ngit reset --hard initial-state\n# Recreate same starting conditions as RED test\n```\n\n### Create GREEN Test Scenario\n\nSame as RED test but:\n- Update to \"Instructions from execute.md (NEW IMPROVED VERSION)\"\n- Include the fixed instructions\n- Same pressure, same options available\n- Same \"execute NOW\" urgency\n\n### Run GREEN Test\n\n```bash\n# Dispatch subagent with GREEN scenario\n# Use same model (haiku) for consistency\n# Agent should now choose correct option and execute correctly\n```\n\n**Expected GREEN result**:\n- Agent follows fixed instructions\n- Creates branch before committing (or whatever correct behavior is)\n- Quotes reasoning showing they understood the explicit ordering\n- Work ends up in correct state\n\n**If agent still fails**: Instructions still ambiguous. Return to GREEN phase, improve clarity, re-test.\n\n## Meta-Testing (When GREEN Fails)\n\n**If agent still misinterprets after your fix, ask them directly:**\n\n```markdown\nyour human partner: You read the improved instructions and still chose the wrong option.\n\nHow could those instructions have been written differently to make\nthe correct workflow crystal clear?\n```\n\n**Three possible responses:**\n\n1. **\"The instructions WERE clear, I just rushed\"**\n   - Not a clarity problem - need stronger warning/consequence\n   - Add \"CRITICAL:\" or \"MUST\" language upfront\n   - State failure consequence explicitly\n\n2. **\"The instructions should have said X\"**\n   - Clarity problem - agent's suggestion usually good\n   - Add their exact wording verbatim\n   - Re-test to verify improvement\n\n3. **\"I didn't notice section Y\"**\n   - Organization problem - important info buried\n   - Move critical steps earlier\n   - Use formatting (bold, CRITICAL) to highlight\n\n**Use meta-testing to diagnose WHY fix didn't work, not just add more content.**\n\n## REFACTOR Phase: Iterate on Clarity\n\n**Goal:** Find and fix remaining ambiguities.\n\n### Check for Remaining Issues\n\nRun additional test scenarios:\n- Different pressure combinations\n- Different task positions (first task, middle, last)\n- Different states (clean vs dirty working tree)\n- Different agent models (haiku, sonnet)\n\n### Common Clarity Issues\n\n| Issue | Symptom | Fix |\n|-------|---------|-----|\n| **Order ambiguous** | Steps done out of order | Add \"a) FIRST, b) THEN\" labels |\n| **Missing consequences** | Agent skips step | Add \"If you skip X, Y will fail\" |\n| **Too abstract** | Agent guesses commands | Show exact commands inline |\n| **No warnings** | Agent makes wrong choice | Add \"CRITICAL:\" upfront |\n| **Assumes knowledge** | Agent doesn't know tool | Reference skill + show command |\n\n### Document Test Results\n\nCreate summary document:\n```markdown\n# Test Results: execute.md Sequential Phase Fix\n\n**RED Phase**: Task 4.3 committed to Task 4.2 branch (real failure)\n**GREEN Phase**: Agent created correct branch, no ambiguity\n**REFACTOR**: Tested with different models, all passed\n\n**Fix applied**: Lines 277-297 (sequential), 418-438 (parallel)\n**Success criteria**: New stacked branch created BEFORE commit\n```\n\n## Differences from Testing Skills\n\n**testing-skills-with-subagents** (discipline skills):\n- Tests agent **compliance under pressure** (will they follow rules?)\n- Focuses on **closing rationalization loopholes**\n- Uses **multiple combined pressures** (time + sunk cost + exhaustion)\n- Goal: **Bulletproof against shortcuts**\n\n**testing-workflows-with-subagents** (workflow documentation):\n- Tests **instruction clarity** (can they understand what to do?)\n- Focuses on **removing ambiguity in ordering and steps**\n- Uses **realistic execution pressure** (tired, more tasks, time limits)\n- Goal: **Unambiguous instructions agents can follow correctly**\n\nDifferent problem: Skills test \"will you comply?\" vs Workflows test \"can you understand?\"\n\n## Quick Reference: RED-GREEN-REFACTOR Cycle\n\n**RED Phase**:\n1. Find real execution failure (git log, error reports)\n2. Create test repo simulating pre-failure state\n3. Write pressure scenario with current instructions\n4. Launch subagent, document exact failure\n\n**GREEN Phase**:\n1. Analyze root cause (what was ambiguous?)\n2. Fix instructions (explicit order, warnings, commands)\n3. Reset test repo to same state\n4. Write GREEN scenario with fixed instructions\n5. Launch subagent, verify correct execution\n\n**REFACTOR Phase**:\n1. Test additional scenarios (different pressures, states)\n2. Find remaining ambiguities\n3. Improve clarity\n4. Re-verify all tests pass\n\n## Testing Checklist (TDD for Workflows)\n\n**IMPORTANT: Use TodoWrite to track these steps.**\n\n**RED Phase:**\n- [ ] Find real execution failure (git commits, logs, errors)\n- [ ] Document evidence (branch names, commit hashes, expected vs actual)\n- [ ] Create test repository simulating pre-failure state\n- [ ] Write pressure scenario with current instructions\n- [ ] Run subagent test, document exact failure and reasoning\n\n**GREEN Phase:**\n- [ ] Analyze root cause of ambiguity\n- [ ] Fix instructions (explicit ordering, warnings, commands)\n- [ ] Apply fix to actual command file\n- [ ] Reset test repository to same starting state\n- [ ] Write GREEN scenario with fixed instructions\n- [ ] Run subagent test, verify correct execution\n\n**REFACTOR Phase:**\n- [ ] Test with different pressure levels\n- [ ] Test with different execution states\n- [ ] Test with different agent models\n- [ ] Document all remaining ambiguities found\n- [ ] Improve clarity for each issue\n- [ ] Re-verify all scenarios pass\n\n**Documentation:**\n- [ ] Create test results summary\n- [ ] Document before/after instructions\n- [ ] Save test scenarios for regression testing\n- [ ] Note which lines in command file were changed\n\n## Common Mistakes\n\n**‚ùå Testing without real failure evidence**\nStart with hypothetical \"this might be confusing\" leads to fixes that don't address actual problems.\n‚úÖ **Fix:** Always start with git logs, error reports, real execution traces.\n\n**‚ùå Test scenario without pressure**\nAgents follow instructions carefully when not rushed - doesn't match real execution.\n‚úÖ **Fix:** Add time pressure, cognitive load (tired, many tasks), urgency.\n\n**‚ùå Improving instructions without testing**\nGuessing what's clear vs actually verifying leads to still-ambiguous docs.\n‚úÖ **Fix:** Always run GREEN verification with subagent before considering done.\n\n**‚ùå Testing once and done**\nFirst test might not catch all ambiguities.\n‚úÖ **Fix:** REFACTOR phase with varied scenarios, different models.\n\n**‚ùå Vague test options**\nGiving \"what do you do?\" instead of concrete choices lets agent defer.\n‚úÖ **Fix:** Force A/B/C/D choice with \"Choose NOW\" urgency.\n\n## Real-World Impact\n\n**From testing execute.md sequential phase instructions** (this session):\n\n**RED Phase**:\n- Found Task 4.3 committed to Task 4.2's branch in bignight.party\n- Created test scenario reproducing failure mode\n\n**GREEN Phase**:\n- Fixed instructions with \"a) FIRST, b) THEN\" explicit ordering\n- Added CRITICAL warning about staging before branch creation\n- Showed exact atomic command: `gs branch create -m`\n\n**Result**:\n- Agent followed corrected workflow perfectly\n- Quote: \"The two-step process is clear and effective\"\n- Prevents same failure class across all future executions\n\n**Time investment**: 1 hour testing, prevents repeated failures across all spectacular runs.\n\n## The Bottom Line\n\n**Test workflow documentation the same way you test code.**\n\nRED (find real failure) ‚Üí GREEN (fix and verify) ‚Üí REFACTOR (iterate on clarity).\n\nIf you wouldn't deploy code without tests, don't deploy commands without verifying agents can follow them correctly."
              },
              {
                "name": "troubleshooting-execute",
                "description": "Use when execute command encounters errors - diagnostic guide for phase failures, parallel agent failures, merge conflicts, worktree issues, and recovery strategies",
                "path": "skills/troubleshooting-execute/SKILL.md",
                "frontmatter": {
                  "name": "troubleshooting-execute",
                  "description": "Use when execute command encounters errors - diagnostic guide for phase failures, parallel agent failures, merge conflicts, worktree issues, and recovery strategies"
                },
                "content": "# Troubleshooting Execute Command\n\n## Overview\n\n**Reference guide for diagnosing and recovering from execute command failures.**\n\nThis skill provides recovery strategies for common execute command errors. Use it when execution fails or produces unexpected results.\n\n## When to Use\n\nUse this skill when:\n- Phase execution fails (sequential or parallel)\n- Parallel agent fails or doesn't complete\n- Merge conflicts occur during stacking\n- Worktree creation fails\n- Main worktree not found\n- Need to resume execution after fixing an issue\n\n**This is a reference skill** - consult when errors occur, not part of normal execution flow.\n\n## Error Categories\n\n### 1. Sequential Phase Execution Failure\n\n**Symptoms:**\n- Task agent fails mid-execution\n- Quality checks fail (test, lint, build)\n- Branch not created after task completes\n\n**Error message format:**\n```markdown\n‚ùå Phase {id} Execution Failed\n\n**Task**: {task-id}\n**Error**: {error-message}\n```\n\n**Resolution steps:**\n\n1. **Review the error output** - Understand what failed (test? build? implementation?)\n\n2. **Check current state:**\n   ```bash\n   cd .worktrees/{runid}-main\n   git status\n   git log --oneline -5\n   ```\n\n3. **Fix manually if needed:**\n   ```bash\n   # Current branch already has completed work from previous tasks\n   # Fix the issue in the working directory\n\n   # Run quality checks\n   bash <<'EOF'\n   npm test\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Tests failed\"\n     exit 1\n   fi\n\n   npm run lint\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Lint failed\"\n     exit 1\n   fi\n\n   npm run build\n   if [ $? -ne 0 ]; then\n     echo \"‚ùå Build failed\"\n     exit 1\n   fi\n   EOF\n\n   # Create branch if task completed but branch wasn't created\n   gs branch create {runid}-task-{phase}-{task}-{name} -m \"[Task {phase}.{task}] {description}\"\n   ```\n\n4. **Resume execution:**\n   - If fixed manually: Continue to next task\n   - If need fresh attempt: Reset branch and re-run task\n   - If plan was wrong: Update plan and re-execute from this phase\n\n### 2. Parallel Phase - Agent Failure\n\n**Symptoms:**\n- One or more parallel agents fail\n- Some task branches created, others missing\n- Error during concurrent execution\n\n**Error message format:**\n```markdown\n‚ùå Parallel Phase {id} - Agent Failure\n\n**Failed Task**: {task-id}\n**Branch**: {task-branch}\n**Error**: {error-message}\n\n**Successful Tasks**: {list}\n```\n\n**Resolution options:**\n\n#### Option A: Fix in Existing Branch\n\nUse when fix is small and task mostly completed:\n\n```bash\n# Navigate to task's worktree\ncd .worktrees/{runid}-task-{phase}-{task}\n\n# Debug and fix issue\n# Edit files, fix code\n\n# Run quality checks\nbash <<'EOF'\nnpm test\nif [ $? -ne 0 ]; then\n  echo \"‚ùå Tests failed\"\n  exit 1\nfi\n\nnpm run lint\nif [ $? -ne 0 ]; then\n  echo \"‚ùå Lint failed\"\n  exit 1\nfi\n\nnpm run build\nif [ $? -ne 0 ]; then\n  echo \"‚ùå Build failed\"\n  exit 1\nfi\nEOF\n\n# Commit fix on existing branch\ngit add --all\ngit commit -m \"[Task {phase}.{task}] Fix: {description}\"\n\n# Return to main repo\ncd \"$REPO_ROOT\"\n\n# Proceed with stacking (failed branch now exists)\n```\n\n#### Option B: Create Stacked Fix Branch\n\nUse when fix is significant or logically separate:\n\n```bash\n# Navigate to task's worktree\ncd .worktrees/{runid}-task-{phase}-{task}\n\n# Ensure original work is committed\ngit status  # Should be clean\n\n# Create stacked fix branch\ngs branch create {runid}-task-{phase}-{task}-fix-{issue} -m \"[Task {phase}.{task}] Fix: {issue}\"\n\n# Implement fix\n# Edit files\n\n# Commit fix\ngit add --all\ngit commit -m \"[Task {phase}.{task}] Fix: {description}\"\n\n# Return to main repo\ncd \"$REPO_ROOT\"\n```\n\n#### Option C: Restart Failed Agent\n\nUse when task implementation is fundamentally wrong:\n\n```bash\n# Navigate to main repo\ncd \"$REPO_ROOT\"\n\n# Remove task worktree\ngit worktree remove .worktrees/{runid}-task-{phase}-{task}\n\n# Delete failed branch if it exists\ngit branch -D {runid}-task-{phase}-{task}-{name}\n\n# Recreate worktree from base\nBASE_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\ngit worktree add .worktrees/{runid}-task-{phase}-{task} --detach \"$BASE_BRANCH\"\n\n# Install dependencies\ncd .worktrees/{runid}-task-{phase}-{task}\n{install-command}\n{postinstall-command}\n\n# Spawn fresh agent for this task only\n# [Use Task tool with task prompt]\n```\n\n#### Option D: Continue Without Failed Task\n\nUse when task is non-critical or can be addressed later:\n\n1. Stack successful task branches\n2. Mark failed task as follow-up work\n3. Continue to next phase\n4. Address failed task in separate branch later\n\n### 3. Merge Conflicts During Stacking\n\n**Symptoms:**\n- Stacking parallel branches causes conflicts\n- `gs upstack onto` fails with merge conflict\n- Git reports conflicting changes in same files\n\n**Error message format:**\n```markdown\n‚ùå Merge Conflict - Tasks Modified Same Files\n\n**Conflict**: {file-path}\n**Branches**: {branch-1}, {branch-2}\n\nThis should not happen if task independence was verified correctly.\n```\n\n**Root cause:** Tasks were marked parallel but have file dependencies.\n\n**Resolution steps:**\n\n1. **Verify task independence:**\n   ```bash\n   # Check which files each task modified\n   git diff {base-branch}..{task-1-branch} --name-only\n   git diff {base-branch}..{task-2-branch} --name-only\n   # Should have no overlap for parallel tasks\n   ```\n\n2. **Resolve conflict manually:**\n   ```bash\n   cd .worktrees/{runid}-main\n\n   # Checkout first task branch\n   git checkout {task-1-branch}\n\n   # Attempt merge with second task\n   git merge {task-2-branch}\n   # Conflict will occur\n\n   # Resolve in editor\n   # Edit conflicted files\n\n   # Complete merge\n   git add {conflicted-files}\n   git commit -m \"Merge {task-2-branch} into {task-1-branch}\"\n\n   # Continue stacking remaining branches\n   ```\n\n3. **Update plan for future:**\n   - Mark tasks as sequential, not parallel\n   - File dependencies mean tasks aren't independent\n   - Prevents conflict in future executions\n\n### 4. Worktree Not Found\n\n**Symptoms:**\n- Execute command can't find `{runid}-main` worktree\n- Error: `.worktrees/{runid}-main does not exist`\n\n**Error message format:**\n```markdown\n‚ùå Worktree Not Found\n\n**Error**: .worktrees/{run-id}-main does not exist\n\nThis means `/spectacular:spec` was not run, or the worktree was removed.\n```\n\n**Root cause:** Spec command not run, or worktree manually deleted.\n\n**Resolution:**\n\nRun the spec command first to create workspace:\n\n```bash\n/spectacular:spec {feature-name}\n```\n\n**This will:**\n1. Create `.worktrees/{runid}-main/` directory\n2. Generate `specs/{runid}-{feature-slug}/spec.md`\n3. Create base branch `{runid}-main`\n\n**Then:**\n1. Run `/spectacular:plan` to generate execution plan\n2. Run `/spectacular:execute` to execute the plan\n\n**Never skip spec** - execute depends on worktree structure created by spec.\n\n### 5. Parallel Task Worktree Creation Failure\n\n**Symptoms:**\n- `git worktree add` fails for parallel tasks\n- Error: \"path already exists\"\n- Error: \"working tree contains modified files\"\n\n**Error message format:**\n```markdown\n‚ùå Parallel Task Worktree Creation Failed\n\n**Error**: {error-message}\n```\n\n**Common causes and fixes:**\n\n#### Cause 1: Path Already Exists\n\n```bash\n# Clean existing path\nrm -rf .worktrees/{runid}-task-{phase}-{task}\n\n# Prune stale worktree entries\ngit worktree prune\n\n# Retry worktree creation\ngit worktree add .worktrees/{runid}-task-{phase}-{task} --detach {base-branch}\n```\n\n#### Cause 2: Uncommitted Changes on Current Branch\n\n```bash\n# Stash changes\ngit stash\n\n# Or commit changes\ngit add --all\ngit commit -m \"WIP: Save progress before parallel phase\"\n\n# Retry worktree creation\n```\n\n#### Cause 3: Working Directory Not Clean\n\n```bash\n# Check status\ngit status\n\n# Either commit or stash changes\ngit add --all\ngit commit -m \"[Task {X}.{Y}] Complete task\"\n\n# Or stash if work is incomplete\ngit stash\n\n# Retry worktree creation\n```\n\n#### Cause 4: Running from Wrong Directory\n\n```bash\n# Verify not in worktree\nREPO_ROOT=$(git rev-parse --show-toplevel)\nif [[ \"$REPO_ROOT\" =~ \\.worktrees ]]; then\n  echo \"Error: In worktree, navigate to main repo\"\n  cd \"$(dirname \"$(dirname \"$REPO_ROOT\")\")\"\nfi\n\n# Navigate to main repo root\nMAIN_REPO=$(git rev-parse --show-toplevel | sed 's/\\.worktrees.*//')\ncd \"$MAIN_REPO\"\n\n# Retry worktree creation\n```\n\n## Diagnostic Commands\n\n**Check execution state:**\n\n```bash\n# List all worktrees\ngit worktree list\n\n# View current branches\ngit branch | grep \"{runid}-\"\n\n# View stack structure\ncd .worktrees/{runid}-main\ngs log short\n\n# Check main worktree state\ncd .worktrees/{runid}-main\ngit status\ngit branch --show-current\n```\n\n**Verify phase readiness:**\n\n```bash\n# Before parallel phase\ncd .worktrees/{runid}-main\nBASE_BRANCH=$(git branch --show-current)\necho \"Parallel phase will build from: $BASE_BRANCH\"\n\n# Before sequential phase\ncd .worktrees/{runid}-main\nCURRENT_BRANCH=$(git branch --show-current)\necho \"Sequential phase starting from: $CURRENT_BRANCH\"\n```\n\n**Check task completion:**\n\n```bash\n# Verify all task branches exist\nTASK_BRANCHES=({runid}-task-{phase}-1-{name} {runid}-task-{phase}-2-{name})\nfor BRANCH in \"${TASK_BRANCHES[@]}\"; do\n  if git rev-parse --verify \"$BRANCH\" >/dev/null 2>&1; then\n    echo \"‚úÖ $BRANCH exists\"\n  else\n    echo \"‚ùå $BRANCH missing\"\n  fi\ndone\n```\n\n## Recovery Strategies\n\n### Resume After Manual Fix\n\nIf you fixed an issue manually:\n\n1. Verify state is clean:\n   ```bash\n   cd .worktrees/{runid}-main\n   git status  # Should be clean\n   git log --oneline -3  # Verify commits exist\n   ```\n\n2. Continue to next task/phase:\n   - Sequential: Next task creates branch from current HEAD\n   - Parallel: Remaining tasks execute in parallel\n\n### Reset Phase and Retry\n\nIf phase is fundamentally broken:\n\n1. **Reset main worktree to pre-phase state:**\n   ```bash\n   cd .worktrees/{runid}-main\n   git reset --hard {base-branch}\n   ```\n\n2. **Remove failed task branches:**\n   ```bash\n   git branch -D {failed-task-branches}\n   ```\n\n3. **Re-run phase:**\n   - Fix plan if needed\n   - Re-execute phase from execute command\n\n### Abandon Feature and Clean Up\n\nIf feature implementation should be abandoned:\n\n1. **Remove all worktrees:**\n   ```bash\n   git worktree remove .worktrees/{runid}-main\n   git worktree remove .worktrees/{runid}-task-*\n   git worktree prune\n   ```\n\n2. **Delete all feature branches:**\n   ```bash\n   git branch | grep \"^  {runid}-\" | xargs git branch -D\n   ```\n\n3. **Clean spec directory:**\n   ```bash\n   rm -rf specs/{runid}-{feature-slug}\n   ```\n\n## Prevention\n\n**Prevent failures before they occur:**\n\n1. **Validate plan before execution:**\n   - Check task independence for parallel phases\n   - Verify file paths are explicit, not wildcards\n   - Ensure no circular dependencies\n\n2. **Run setup validation:**\n   - Use `validating-setup-commands` skill\n   - Verify CLAUDE.md has install/postinstall commands\n   - Test quality check commands exist\n\n3. **Use skills correctly:**\n   - `executing-parallel-phase` for ALL parallel phases\n   - `executing-sequential-phase` for ALL sequential phases\n   - `understanding-cross-phase-stacking` for phase boundaries\n\n4. **Verify before proceeding:**\n   - Check branches exist after each phase\n   - Verify stack structure with `gs log short`\n   - Run quality checks manually if agents skip them\n\n## Quick Reference\n\n**Common error patterns:**\n\n| Error | Quick Fix |\n|-------|-----------|\n| Phase execution failed | Check error, fix manually, resume or retry |\n| Parallel agent failed | Fix in branch, restart agent, or continue without |\n| Merge conflict | Resolve manually, update plan to sequential |\n| Worktree not found | Run `/spectacular:spec` first |\n| Worktree creation failed | Clean path, stash changes, prune worktrees |\n\n**Diagnostic sequence:**\n\n1. Read error message carefully\n2. Check execution state (worktrees, branches, commits)\n3. Identify root cause (plan issue? implementation? environment?)\n4. Choose recovery strategy (fix, retry, or continue)\n5. Verify state is clean before proceeding\n\n## The Bottom Line\n\n**Most failures are recoverable.** Understand the error, verify state, fix the issue, and resume execution.\n\nThe execute command is designed to be resilient - you can fix issues manually and continue from any phase."
              },
              {
                "name": "understanding-cross-phase-stacking",
                "description": "Use before starting any new phase - explains how sequential and parallel phases automatically chain together through base branch inheritance (main worktree tracks progress, parallel phases inherit from current branch, no manual intervention needed)",
                "path": "skills/understanding-cross-phase-stacking/SKILL.md",
                "frontmatter": {
                  "name": "understanding-cross-phase-stacking",
                  "description": "Use before starting any new phase - explains how sequential and parallel phases automatically chain together through base branch inheritance (main worktree tracks progress, parallel phases inherit from current branch, no manual intervention needed)"
                },
                "content": "# Understanding Cross-Phase Stacking\n\n## Overview\n\n**Phases automatically build on each other's completed work.** Understanding how phases chain together is essential for correct execution.\n\nThis is a **reference skill** - read it to understand cross-phase dependencies, not to execute a workflow.\n\n## When to Use\n\nUse this skill when:\n- Starting a new phase (need to understand what base to build from)\n- Debugging stack relationships across phase boundaries\n- Verifying phases are chaining correctly\n- Understanding why parallel worktrees use specific base branches\n\n**Mental model check:** If you're thinking \"create worktrees from `{runid}-main` branch\", you need this skill.\n\n## The Cross-Phase Inheritance Principle\n\n```\nMAIN WORKTREE CURRENT BRANCH = LATEST COMPLETED WORK\n```\n\n**Key insight:**\n- Sequential phases leave main worktree **on their last task's branch**\n- Parallel phases leave main worktree **on their last stacked branch**\n- Next phase (sequential or parallel) inherits from **current branch**, not original base\n\n**This creates automatic linear chaining across all phases.**\n\n## Example: Sequential ‚Üí Parallel ‚Üí Sequential\n\n### Phase 1 (Sequential) - Database Setup\n\n```bash\n# Working in: .worktrees/{runid}-main\n# Starting from: {runid}-main (base branch)\n\n# Task 1: Database schema\ngs branch create {runid}-task-1-1-database-schema\n# Creates branch, commits work\n# Main worktree now on: {runid}-task-1-1-database-schema ‚Üê KEY STATE\n```\n\n**Phase 1 result:**\n- Branch created: `{runid}-task-1-1-database-schema`\n- Main worktree current branch: `{runid}-task-1-1-database-schema`\n- **This branch becomes Phase 2's base**\n\n### Phase 2 (Parallel) - Three Feature Implementations\n\n```bash\n# Base detection (CRITICAL):\nBASE_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\n# Returns: {runid}-task-1-1-database-schema ‚Üê Inherits from Phase 1\n\n# Create parallel worktrees FROM Phase 1's completed branch\ngit worktree add .worktrees/{runid}-task-2-1 --detach \"$BASE_BRANCH\"\ngit worktree add .worktrees/{runid}-task-2-2 --detach \"$BASE_BRANCH\"\ngit worktree add .worktrees/{runid}-task-2-3 --detach \"$BASE_BRANCH\"\n\n# All 3 parallel tasks build on Phase 1's database schema\n```\n\n**After parallel tasks complete and stack:**\n\n```bash\n# In main worktree (.worktrees/{runid}-main):\n# Branch 1: {runid}-task-2-1-user-service ‚Üí tracked\n# Branch 2: {runid}-task-2-2-product-service ‚Üí tracked, upstacked onto Branch 1\n# Branch 3: {runid}-task-2-3-order-service ‚Üí tracked, upstacked onto Branch 2\n\n# Main worktree now on: {runid}-task-2-3-order-service ‚Üê KEY STATE\n```\n\n**Phase 2 result:**\n- Linear stack: database-schema ‚Üí user-service ‚Üí product-service ‚Üí order-service\n- Main worktree current branch: `{runid}-task-2-3-order-service`\n- **This branch becomes Phase 3's base**\n\n### Phase 3 (Sequential) - Integration Tests\n\n```bash\n# Working in: .worktrees/{runid}-main (reused from Phase 1)\n# Current branch: {runid}-task-2-3-order-service (from Phase 2)\n\n# Task 1: Integration tests\ngs branch create {runid}-task-3-1-integration-tests\n# Automatically stacks on Phase 2's last task via natural stacking\n```\n\n**Phase 3 result:**\n- Linear chain: Phase 1 ‚Üí Phase 2 tasks ‚Üí Phase 3\n- Complete stack shows all work in order\n\n## Verification Between Phases\n\n**Before starting parallel phase (check inheritance):**\n\n```bash\n# Verify base branch before creating worktrees\nBASE_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\necho \"Starting parallel phase from: $BASE_BRANCH\"\n# Should show previous phase's completed branch, NOT {runid}-main\n```\n\n**Before starting sequential phase (check current state):**\n\n```bash\n# Verify starting point\nCURRENT_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\necho \"Starting sequential phase from: $CURRENT_BRANCH\"\n# Should show previous phase's last stacked branch\n```\n\n**After phase completes (verify stack):**\n\n```bash\ncd .worktrees/{runid}-main\ngs log short\n# Should show linear chain including all previous phases\n```\n\n## Key Principles\n\n1. **Main worktree tracks progress**\n   - Current branch = latest completed work\n   - Not static - changes as phases complete\n\n2. **Parallel phases inherit from current**\n   - Use `git -C .worktrees/{runid}-main branch --show-current` as base\n   - NOT `{runid}-main` (that's the original starting point)\n\n3. **Parallel stacking preserves continuity**\n   - Last stacked branch becomes next phase's base\n   - Checkout last branch after stacking completes\n\n4. **Sequential phases extend naturally**\n   - `gs branch create` stacks on current HEAD\n   - No manual base specification needed\n\n5. **No manual intervention needed**\n   - Cross-phase chaining is automatic\n   - Following per-phase patterns creates correct chain\n\n## Common Mistake: Creating From Wrong Base\n\n### ‚ùå Wrong: Creating parallel worktrees from original base\n\n```bash\n# DON'T DO THIS:\ngit worktree add .worktrees/{runid}-task-2-1 --detach {runid}-main\n```\n\n**Why wrong:** Ignores Phase 1's completed work. Phase 2 won't have database schema from Phase 1.\n\n**Result:** Broken dependency chain. Phase 2 builds on stale base instead of Phase 1's changes.\n\n### ‚úÖ Correct: Creating parallel worktrees from current branch\n\n```bash\n# DO THIS:\nBASE_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\ngit worktree add .worktrees/{runid}-task-2-1 --detach \"$BASE_BRANCH\"\n```\n\n**Why correct:** Inherits all previous work. Phase 2 builds on Phase 1's completed branch.\n\n**Result:** Linear chain across all phases.\n\n## Mental Model Check\n\n**If you're thinking:**\n- \"Create worktrees from `{runid}-main`\" ‚Üí WRONG. Use current branch.\n- \"Parallel tasks should start fresh\" ‚Üí WRONG. They inherit previous work.\n- \"Phase boundaries break the stack\" ‚Üí WRONG. Stack is continuous across phases.\n\n**Correct mental model:**\n- Main worktree is a **moving cursor** pointing to latest work\n- Each phase **extends** the cursor position, doesn't reset it\n- Stack is **one continuous chain**, not per-phase segments\n\n## Quick Reference\n\n**Starting parallel phase:**\n```bash\nBASE_BRANCH=$(git -C .worktrees/{runid}-main branch --show-current)\n# Use $BASE_BRANCH for all worktree creation\n```\n\n**Starting sequential phase:**\n```bash\n# Already on correct branch - just create next branch\ngs branch create {runid}-task-{phase}-{task}-{name}\n# Automatically stacks on current HEAD\n```\n\n**Verifying cross-phase chain:**\n```bash\ncd .worktrees/{runid}-main\ngs log short\n# Should show linear progression through all phases\n```\n\n## The Bottom Line\n\n**Phases chain automatically through main worktree's current branch.**\n\nIf you're manually specifying base branches or creating worktrees from `{runid}-main`, you're breaking the automatic inheritance system.\n\nTrust the pattern: main worktree tracks progress, new phases build from current state."
              },
              {
                "name": "using-git-spice",
                "description": "Use when working with stacked branches, managing dependent PRs/CRs, or uncertain about git-spice commands (stack vs upstack vs downstack) - provides command reference, workflow patterns, and common pitfalls for the git-spice CLI tool",
                "path": "skills/using-git-spice/SKILL.md",
                "frontmatter": {
                  "name": "using-git-spice",
                  "description": "Use when working with stacked branches, managing dependent PRs/CRs, or uncertain about git-spice commands (stack vs upstack vs downstack) - provides command reference, workflow patterns, and common pitfalls for the git-spice CLI tool"
                },
                "content": "# Using git-spice\n\n## Overview\n\n**git-spice (`gs`) is a CLI tool for managing stacked Git branches and their Change Requests.**\n\nCore principle: git-spice tracks branch relationships (stacks) and automates rebasing/submitting dependent branches.\n\n## Key Concepts\n\n**Stack terminology:**\n- **Stack**: All branches connected to current branch (both upstack and downstack)\n- **Upstack**: Branches built on top of current branch (children and descendants)\n- **Downstack**: Branches below current branch down to trunk (parents and ancestors)\n- **Trunk**: Main integration branch (typically `main` or `master`)\n\n**Example stack:**\n```\n‚îå‚îÄ‚îÄ feature-c     ‚Üê upstack from feature-b\n‚îú‚îÄ‚îÄ feature-b     ‚Üê upstack from feature-a, downstack from feature-c\n‚îú‚îÄ‚îÄ feature-a     ‚Üê downstack from feature-b\nmain (trunk)\n```\n\nWhen on `feature-b`:\n- **Upstack**: feature-c\n- **Downstack**: feature-a, main\n- **Stack**: feature-a, feature-b, feature-c\n\n## Quick Reference\n\n| Task | Command | Notes |\n|------|---------|-------|\n| **Initialize repo** | `gs repo init` | Required once per repo. Sets trunk branch. |\n| **Create stacked branch** | `gs branch create <name>` | Creates branch on top of current. Use `gs bc` shorthand. |\n| **View stack** | `gs log short` | Shows current stack. Use `gs ls` or `gs log long` (`gs ll`) for details. |\n| **Submit stack as PRs** | `gs stack submit` | Submits entire stack. Use `gs ss` shorthand. |\n| **Submit upstack only** | `gs upstack submit` | Current branch + children. Use `gs us s` shorthand. |\n| **Submit downstack only** | `gs downstack submit` | Current branch + parents to trunk. Use `gs ds s` shorthand. |\n| **Rebase entire stack** | `gs repo restack` | Rebases all tracked branches on their bases. |\n| **Rebase current stack** | `gs stack restack` | Rebases current branch's stack. Use `gs sr` shorthand. |\n| **Rebase upstack** | `gs upstack restack` | Current branch + children. Use `gs us r` shorthand. |\n| **Move branch to new base** | `gs upstack onto <base>` | Moves current + upstack to new base. |\n| **Sync with remote** | `gs repo sync` | Pulls latest, deletes merged branches. |\n| **Track existing branch** | `gs branch track [branch]` | Adds branch to git-spice tracking. |\n| **Delete branch** | `gs branch delete [branch]` | Deletes branch, restacks children. Use `gs bd` shorthand. |\n\n**Command shortcuts:** Most commands have short aliases. Use `gs --help` to see all aliases.\n\n## Common Workflows\n\n### Workflow 1: Create and Submit Stack\n\n```bash\n# One-time setup\ngs repo init\n# Prompt asks for trunk branch (usually 'main')\n\n# Create stacked branches\ngs branch create feature-a\n# Make changes, commit with git\ngit add . && git commit -m \"Implement A\"\n\ngs branch create feature-b  # Stacks on feature-a\n# Make changes, commit\ngit add . && git commit -m \"Implement B\"\n\ngs branch create feature-c  # Stacks on feature-b\n# Make changes, commit\ngit add . && git commit -m \"Implement C\"\n\n# View the stack\ngs log short\n\n# Submit entire stack as PRs\ngs stack submit\n# Creates/updates PRs for all branches in stack\n```\n\n### Workflow 2: Update Branch After Review\n\n```bash\n# You have feature-a ‚Üí feature-b ‚Üí feature-c\n# Reviewer requested changes on feature-b\n\ngit checkout feature-b\n# Make changes, commit\ngit add . && git commit -m \"Address review feedback\"\n\n# Rebase upstack (feature-c) on updated feature-b\ngs upstack restack\n\n# Submit changes to update PRs\ngs upstack submit\n# Note: restack only rebases locally, submit pushes and updates PRs\n```\n\n**CRITICAL: Don't manually rebase feature-c!** Use `gs upstack restack` to maintain stack relationships.\n\n### Workflow 3: Sync After Upstream Merge\n\n```bash\n# feature-a was merged to main\n# Need to update feature-b and feature-c\n\n# Sync with remote (pulls main, deletes merged branches)\ngs repo sync\n\n# Restack everything on new main\ngs repo restack\n\n# Verify stack looks correct\ngs log short\n\n# Push updated branches\ngs stack submit\n```\n\n**CRITICAL: Don't rebase feature-c onto main!** After feature-a merges:\n- feature-b rebases onto main (its new base)\n- feature-c rebases onto feature-b (maintains dependency)\n\n## When to Use Git vs git-spice\n\n**Use git-spice for:**\n- Creating branches in a stack: `gs branch create`\n- Rebasing stacks: `gs upstack restack`, `gs repo restack`\n- Submitting PRs: `gs stack submit`, `gs upstack submit`\n- Viewing stack structure: `gs log short`\n- Deleting branches: `gs branch delete` (restacks children)\n\n**Use git for:**\n- Making changes: `git add`, `git commit`\n- Checking status: `git status`, `git diff`\n- Viewing commit history: `git log`\n- Individual branch operations: `git checkout`, `git switch`\n\n**Never use `git rebase` directly on stacked branches** - use git-spice restack commands to maintain relationships.\n\n## Common Mistakes\n\n| Mistake | Why It's Wrong | Correct Approach |\n|---------|---------------|------------------|\n| Rebasing child onto trunk after parent merges | Breaks stack relationships, creates conflicts | Use `gs repo sync && gs repo restack` |\n| Using `git push --force` after changes | Bypasses git-spice tracking | Use `gs upstack submit` or `gs stack submit` |\n| Manually rebasing with `git rebase` | git-spice doesn't track the rebase | Use `gs upstack restack` or `gs stack restack` |\n| Running `gs stack submit` on wrong branch | Might submit unintended branches | Check `gs log short` first to see what's in stack |\n| Forgetting `gs repo init` | Commands fail with unclear errors | Run `gs repo init` once per repository |\n| Using `stack` when you mean `upstack` | Submits downstack branches too (parents) | Use `upstack` to submit only current + children |\n| Assuming `restack` runs automatically | After commits, stack can drift | Explicitly run `gs upstack restack` after changes |\n\n## Red Flags - Check Documentation\n\n- Confused about stack/upstack/downstack scope\n- About to run `git rebase` on a tracked branch\n- Unsure which submit command to use\n- Getting \"not tracked\" errors\n\n**When uncertain, run `gs <command> --help` for detailed usage.**\n\n## Authentication and Setup\n\n**First time setup:**\n```bash\n# Authenticate with GitHub/GitLab\ngs auth login\n# Follow prompts for OAuth or token auth\n\n# Initialize repository\ngs repo init\n# Sets trunk branch and remote\n\n# Verify setup\ngs auth status\n```\n\n## Handling Conflicts\n\nIf `gs upstack restack` or `gs repo restack` encounters conflicts:\n1. Resolve conflicts using standard git workflow (`git status`, edit files, `git add`)\n2. Continue with `git rebase --continue`\n3. git-spice will resume restacking remaining branches\n4. After resolution, run `gs upstack submit` to push changes\n\nIf you need to abort a restack, check `gs --help` for recovery options.\n\n## Additional Resources\n\n- Full CLI reference: `gs --help`\n- Command-specific help: `gs <command> --help`\n- Configuration: `gs config --help`\n- Official docs: https://abhinav.github.io/git-spice/"
              },
              {
                "name": "using-spectacular",
                "description": "Use when starting any conversation in a project using spectacular - establishes mandatory workflows for spec-anchored development, including when to use /spectacular commands and how to work with constitutions",
                "path": "skills/using-spectacular/SKILL.md",
                "frontmatter": {
                  "name": "using-spectacular",
                  "description": "Use when starting any conversation in a project using spectacular - establishes mandatory workflows for spec-anchored development, including when to use /spectacular commands and how to work with constitutions"
                },
                "content": "<EXTREMELY_IMPORTANT>\nYou have spectacular.\n\n**The content below is your introduction to using spectacular:**\n\n---\n\n# Using Spectacular\n\nSpectacular extends superpowers with spec-anchored development workflows. Before responding to user requests for features or refactors, you MUST check if spectacular workflows apply.\n\n## MANDATORY FIRST RESPONSE PROTOCOL\n\nBefore responding to ANY user message about features, refactors, or implementations:\n\n1. ‚òê Does request involve implementing/refactoring features?\n2. ‚òê Is there a `docs/constitutions/current/` directory in this project?\n3. ‚òê If yes ‚Üí Use spectacular workflow (spec ‚Üí plan ‚Üí execute)\n4. ‚òê If no constitution ‚Üí Ask if user wants to use spectacular\n\n**Responding to feature requests WITHOUT this check = automatic failure.**\n\n## Core Spectacular Workflow\n\n```\nUser request ‚Üí /spectacular:spec ‚Üí /spectacular:plan ‚Üí /spectacular:execute\n```\n\n**Each command has a specific purpose:**\n\n1. **`/spectacular:spec`** - Generate feature specification\n   - When: User describes a feature to implement or refactor\n   - Output: `specs/{runId}-{feature-slug}/spec.md`\n   - Includes: Requirements, architecture, acceptance criteria\n   - References: Constitution rules (doesn't duplicate them)\n\n2. **`/spectacular:plan`** - Decompose spec into execution plan\n   - When: After spec is reviewed and approved\n   - Input: Path to spec.md\n   - Output: `specs/{runId}-{feature-slug}/plan.md`\n   - Analyzes: Task dependencies, file overlaps\n   - Generates: Sequential/parallel phases with time estimates\n\n3. **`/spectacular:execute`** - Execute plan with parallel orchestration\n   - When: After plan is reviewed and approved\n   - Input: Path to plan.md\n   - Creates: Worktrees, spawns subagents, stacks branches\n   - Quality gates: Tests/lint after each task, code review after each phase\n\n## Constitutions: Architectural Truth\n\nIf `docs/constitutions/current/` exists, it contains **immutable architectural rules**:\n\n- **architecture.md** - Layer boundaries, project structure\n- **patterns.md** - Mandatory patterns (e.g., \"use Zod for validation\")\n- **tech-stack.md** - Approved libraries and versions\n- **testing.md** - Testing requirements\n\n**Critical:**\n- ‚úÖ ALWAYS reference constitution in specs (don't duplicate)\n- ‚úÖ ALWAYS validate implementation against constitution\n- ‚ùå NEVER violate constitutional patterns\n- ‚ùå NEVER copy-paste constitution rules into specs\n\n## Common Rationalizations That Mean You're Failing\n\nIf you catch yourself thinking ANY of these, STOP and use spectacular:\n\n| Rationalization | Why It's Wrong | What to Do Instead |\n|----------------|----------------|-------------------|\n| \"Request is clear, no spec needed\" | Clear request = easier to spec, not permission to skip | Use `/spectacular:spec` |\n| \"Feature is small, just code it\" | Small features drift without specs | Use `/spectacular:spec` |\n| \"User wants it fast\" | Workflow IS faster (parallel + fewer bugs) | Use `/spectacular:spec` |\n| \"Constitution doesn't apply\" | Constitution always applies | Reference in spec |\n| \"I can plan mentally\" | Mental = no review, no parallelization | Use `/spectacular:plan` |\n| \"Just a bugfix/refactor\" | Multi-file changes are features | If complex: use `/spectacular:spec` |\n\n## Workflow Enforcement\n\n**User instructions describe WHAT to build, not permission to skip workflows.**\n\n- \"Just implement X\" ‚Üí Use `/spectacular:spec` first\n- \"Quick refactor of Y\" ‚Üí Use `/spectacular:spec` first\n- \"I need Z now\" ‚Üí Use `/spectacular:spec` first (it's faster!)\n\n**Why workflows matter:**\n- Specs catch requirements drift before code\n- Plans enable parallelization (3-5x faster)\n- Constitution prevents architectural debt\n- Quality gates catch bugs early\n\n## Summary: Mandatory Workflow\n\n**For feature/refactor requests:**\n\n1. ‚úÖ Check if spectacular applies (constitution exists?)\n2. ‚úÖ Use `/spectacular:spec` to create specification\n3. ‚úÖ User reviews spec (STOP until approved)\n4. ‚úÖ Use `/spectacular:plan` to decompose into tasks\n5. ‚úÖ User reviews plan (STOP until approved)\n6. ‚úÖ Use `/spectacular:execute` to implement with quality gates\n\n**Skipping steps = violating quality standards.**\n\nWhen in doubt: \"Should I use spectacular for this?\" ‚Üí Almost always YES for multi-file changes.\n\n</EXTREMELY_IMPORTANT>"
              },
              {
                "name": "validating-setup-commands",
                "description": "Use before creating worktrees or executing tasks - validates that CLAUDE.md defines required setup commands (install, optional postinstall) and provides clear error messages with examples if missing",
                "path": "skills/validating-setup-commands/SKILL.md",
                "frontmatter": {
                  "name": "validating-setup-commands",
                  "description": "Use before creating worktrees or executing tasks - validates that CLAUDE.md defines required setup commands (install, optional postinstall) and provides clear error messages with examples if missing"
                },
                "content": "# Validating Setup Commands\n\n## Overview\n\n**Worktrees require dependency installation before tasks can execute.** Projects MUST define setup commands in CLAUDE.md.\n\nThis skill validates setup commands exist BEFORE creating worktrees, preventing cryptic failures later.\n\n## When to Use\n\nUse this skill when:\n- Creating new worktrees (spec, execute commands)\n- Before executing tasks that need dependencies\n- Any time you need to verify project setup is documented\n\n**Use early:** Validate during setup phase, not during task execution.\n\n## Why This Matters\n\n**Without validation:**\n- Worktrees get created\n- Tasks start executing\n- Fail with \"command not found\" errors\n- User debugging nightmare: \"Why is npm/pytest/cargo missing?\"\n\n**With validation:**\n- Missing commands detected immediately\n- Clear error with exact CLAUDE.md section to add\n- User fixes once, all worktrees work\n\n## The Validation Process\n\n**Announce:** \"Validating CLAUDE.md setup commands before creating worktrees.\"\n\n### Step 1: Check File Exists\n\n```bash\n# Get repo root\nREPO_ROOT=$(git rev-parse --show-toplevel)\n\n# Check if CLAUDE.md exists\nif [ ! -f \"$REPO_ROOT/CLAUDE.md\" ]; then\n  echo \"‚ùå Error: CLAUDE.md not found in repository root\"\n  echo \"\"\n  echo \"Spectacular requires CLAUDE.md to define setup commands.\"\n  echo \"See: https://docs.claude.com/claude-code\"\n  exit 1\nfi\n```\n\n**Why fail fast:** No CLAUDE.md = no command configuration. Stop before creating any worktrees.\n\n### Step 2: Parse Setup Section\n\n```bash\n# Parse CLAUDE.md for setup section\nINSTALL_CMD=$(grep -A 10 \"^### Setup\" \"$REPO_ROOT/CLAUDE.md\" | grep \"^- \\*\\*install\\*\\*:\" | sed 's/.*: `\\(.*\\)`.*/\\1/')\n\nif [ -z \"$INSTALL_CMD\" ]; then\n  echo \"‚ùå Error: Setup commands not defined in CLAUDE.md\"\n  echo \"\"\n  echo \"Worktrees require dependency installation before tasks can execute.\"\n  echo \"\"\n  echo \"Add this section to CLAUDE.md:\"\n  echo \"\"\n  echo \"## Development Commands\"\n  echo \"\"\n  echo \"### Setup\"\n  echo \"- **install**: \\`npm install\\`  (or your package manager)\"\n  echo \"- **postinstall**: \\`npx prisma generate\\`  (optional - any codegen)\"\n  echo \"\"\n  echo \"Example for different package managers:\"\n  echo \"- Node.js: npm install, pnpm install, yarn, or bun install\"\n  echo \"- Python: pip install -r requirements.txt\"\n  echo \"- Rust: cargo build\"\n  echo \"- Go: go mod download\"\n  echo \"\"\n  echo \"See: https://docs.claude.com/claude-code\"\n  echo \"\"\n  echo \"Execution stopped. Add setup commands to CLAUDE.md and retry.\"\n  exit 1\nfi\n\n# Extract postinstall command (optional)\nPOSTINSTALL_CMD=$(grep -A 10 \"^### Setup\" \"$REPO_ROOT/CLAUDE.md\" | grep \"^- \\*\\*postinstall\\*\\*:\" | sed 's/.*: `\\(.*\\)`.*/\\1/')\n```\n\n**Parsing logic:**\n- Look for `### Setup` header\n- Extract `**install**:` command (required)\n- Extract `**postinstall**:` command (optional)\n- Use sed to extract command from backticks\n\n### Step 3: Report Success\n\n```bash\n# Report detected commands\necho \"‚úÖ Setup commands found in CLAUDE.md\"\necho \"   install: $INSTALL_CMD\"\nif [ -n \"$POSTINSTALL_CMD\" ]; then\n  echo \"   postinstall: $POSTINSTALL_CMD\"\nfi\n```\n\n**Store for later use:**\n- Return `INSTALL_CMD` to caller\n- Return `POSTINSTALL_CMD` (may be empty)\n- Caller uses these in worktree dependency installation\n\n## Expected CLAUDE.md Format\n\nThe skill expects this exact format:\n\n```markdown\n## Development Commands\n\n### Setup\n- **install**: `npm install`\n- **postinstall**: `npx prisma generate`  (optional)\n```\n\n**Format requirements:**\n- Section header: `### Setup` (exactly)\n- Install line: `- **install**: `command`` (required)\n- Postinstall line: `- **postinstall**: `command`` (optional)\n- Commands must be in backticks\n\n**Multi-language examples:**\n\n```markdown\n### Setup\n- **install**: `npm install`           # Node.js\n- **install**: `pip install -r requirements.txt`  # Python\n- **install**: `cargo build`           # Rust\n- **install**: `go mod download`       # Go\n- **install**: `bundle install`        # Ruby\n```\n\n## Error Messages\n\n### Error 1: CLAUDE.md Not Found\n\n```\n‚ùå Error: CLAUDE.md not found in repository root\n\nSpectacular requires CLAUDE.md to define setup commands.\nSee: https://docs.claude.com/claude-code\n```\n\n**User action:** Create CLAUDE.md in repository root.\n\n### Error 2: Setup Commands Missing\n\n```\n‚ùå Error: Setup commands not defined in CLAUDE.md\n\nWorktrees require dependency installation before tasks can execute.\n\nAdd this section to CLAUDE.md:\n\n## Development Commands\n\n### Setup\n- **install**: `npm install`  (or your package manager)\n- **postinstall**: `npx prisma generate`  (optional - any codegen)\n\nExample for different package managers:\n- Node.js: npm install, pnpm install, yarn, or bun install\n- Python: pip install -r requirements.txt\n- Rust: cargo build\n- Go: go mod download\n\nSee: https://docs.claude.com/claude-code\n\nExecution stopped. Add setup commands to CLAUDE.md and retry.\n```\n\n**User action:** Add Setup section with at least `install` command.\n\n## Integration Pattern\n\n**How commands use this skill:**\n\n```bash\n# In execute.md or spec.md:\n\n# Step 1.5: Validate Setup Commands\n# Use validating-setup-commands skill to extract and verify\nINSTALL_CMD=$(validate_setup_commands_install)\nPOSTINSTALL_CMD=$(validate_setup_commands_postinstall)\n\n# Step 3: Create worktrees\ngit worktree add .worktrees/{runid}-task-1\n\n# Step 4: Install dependencies using validated commands\ncd .worktrees/{runid}-task-1\n$INSTALL_CMD\nif [ -n \"$POSTINSTALL_CMD\" ]; then\n  $POSTINSTALL_CMD\nfi\n```\n\n**Reusable across:**\n- `/spectacular:spec` - Validates before creating main worktree\n- `/spectacular:execute` - Validates before creating task worktrees\n- Future commands that create worktrees\n\n## Common Mistakes\n\n### Mistake 1: Running Validation Too Late\n\n**Wrong:** Create worktrees, then validate\n**Right:** Validate BEFORE creating ANY worktrees\n\n**Why:** Failed validation after worktrees exist leaves orphaned directories.\n\n### Mistake 2: Not Providing Examples\n\n**Wrong:** \"Error: Add setup commands\"\n**Right:** \"Error: Add setup commands. Here's the exact format: [example]\"\n\n**Why:** Users need to know WHAT to add and WHERE.\n\n### Mistake 3: Requiring Postinstall\n\n**Wrong:** Fail if postinstall missing\n**Right:** Postinstall is optional (codegen only needed in some projects)\n\n**Why:** Not all projects have codegen (Prisma, GraphQL, etc.).\n\n## Quick Reference\n\n**Validation sequence:**\n1. Check CLAUDE.md exists (exit if missing)\n2. Parse for `### Setup` section\n3. Extract `install` command (exit if missing)\n4. Extract `postinstall` command (optional)\n5. Report success and return commands\n\n**Exit points:**\n- Missing CLAUDE.md ‚Üí Error with creation instructions\n- Missing setup section ‚Üí Error with exact format example\n- Success ‚Üí Return INSTALL_CMD and POSTINSTALL_CMD\n\n**Format validated:**\n- `### Setup` header\n- `- **install**: `command``\n- `- **postinstall**: `command`` (optional)\n\n## The Bottom Line\n\n**Validate setup commands BEFORE creating worktrees.**\n\nEarly validation with clear error messages prevents confusing failures during task execution.\n\nThe skill provides users with exact examples of what to add, making fixes easy."
              },
              {
                "name": "versioning-constitutions",
                "description": "Use when architectural patterns evolve, tech stack changes, or foundational rules need updates - creates new constitution version directory, migrates/organizes content into modular files, updates symlink, and documents changes",
                "path": "skills/versioning-constitutions/SKILL.md",
                "frontmatter": {
                  "name": "versioning-constitutions",
                  "description": "Use when architectural patterns evolve, tech stack changes, or foundational rules need updates - creates new constitution version directory, migrates/organizes content into modular files, updates symlink, and documents changes"
                },
                "content": "# Versioning Constitutions\n\n## Core Principle\n\n**Constitution versions are immutable snapshots of architectural truth.**\n\nWhen foundational rules change (patterns, tech stack, architecture), create a new version rather than editing in place. This preserves history, enables rollback, and makes changes explicit.\n\n## When to Use This Skill\n\n**ALWAYS create a new version when:**\n- Adding a new mandatory pattern (e.g., adopting effect-ts for error handling)\n- **Removing OR relaxing a mandatory pattern** (e.g., making next-safe-action optional)\n- Changing tech stack (e.g., migrating from Prisma to Drizzle)\n- Updating architectural boundaries (e.g., adding new layer)\n- Deprecating rules that are no longer valid\n- Major library version changes with breaking patterns (e.g., Next.js 15 ‚Üí 16)\n\n**CRITICAL:** Removing or relaxing a mandatory pattern ALWAYS requires a new version, even if existing code would still work. \"Non-breaking\" is not sufficient - any change to mandatory patterns needs versioning for audit trail.\n\n**Do NOT use for:**\n- Fixing typos or clarifying existing rules (edit current version directly)\n- Adding examples to existing patterns (edit current version directly)\n- Project-specific implementation details (those go in specs/)\n\n**Test for Constitutionality:**\n\nBefore adding content to constitution, ask: \"If we violate this rule, does the architecture break?\"\n- ‚úÖ Constitutional: \"Must use next-safe-action\" ‚Üí violating breaks type safety & validation\n- ‚ùå Not constitutional: \"Forms should have wrapper, fields, button\" ‚Üí violating just looks different\n\n**Constitution = Architectural rules. Specs = Implementation patterns.**\n\n## Process\n\n### Step 1: Determine Version Number\n\nRead `docs/constitutions/current/meta.md` to get current version.\n\n**Version increment rules:**\n- Increment by 1 (v1 ‚Üí v2, v2 ‚Üí v3)\n- No semantic versioning (major.minor.patch)\n- Sequential only\n\n### Step 2: Create New Version Directory\n\n```bash\n# Create new version directory\nmkdir -p docs/constitutions/v{N}\n\n# Copy structure from current\ncp docs/constitutions/current/*.md docs/constitutions/v{N}/\n```\n\n### Step 3: Update Content\n\nEdit files in new version directory with changes:\n- `meta.md` - Update version number, date, changelog\n- `architecture.md` - Update if architectural boundaries changed\n- `patterns.md` - Update if mandatory patterns changed\n- `tech-stack.md` - Update if libraries added/removed\n- `schema-rules.md` - Update if database philosophy changed\n- `testing.md` - Update if testing requirements changed\n\n**Critical - Minimal Changes Only:**\n- Only change what NEEDS changing for this version\n- NO reorganizing sections (\"while I'm here\")\n- NO reformatting code examples\n- NO alphabetizing lists\n- NO renaming headings for style\n- NO creating new categories unless absolutely required\n\nThe diff should show ONLY the substantive change, not stylistic improvements.\n\n### Step 4: Update Symlink\n\n```bash\n# Remove old symlink\nrm docs/constitutions/current\n\n# Create new symlink pointing to new version\nln -s v{N} docs/constitutions/current\n```\n\n### Step 5: Verify References\n\nCheck that all references still work:\n\n```bash\n# Find all references to constitutions\ngrep -r \"@docs/constitutions/current\" .claude/\ngrep -r \"docs/constitutions/current\" .claude/\n```\n\nAll references should use `current/` symlink, never hardcoded versions.\n\n### Step 6: Document in meta.md\n\n**MANDATORY:** Update `meta.md` with complete documentation:\n- New version number (e.g., \"Version: 2\")\n- Creation date (e.g., \"Created: 2025-01-17\")\n- Previous version reference (e.g., \"Previous: v1\")\n- **Summary of WHAT changed** (e.g., \"Removed Redux prohibition\")\n- **Rationale for WHY** (e.g., \"React Server Components handle all state needs, Redux adds complexity without benefit\")\n\n**The WHY is critical.** In 6 months, the context will be lost. Document:\n- What problem does this change solve?\n- What decision or discussion led to this?\n- Why now vs earlier/later?\n\nDO NOT rely on git commit messages or external docs. meta.md must be self-contained.\n\n## Quality Checklist\n\nBefore updating symlink:\n- [ ] New version directory exists at `docs/constitutions/v{N}/`\n- [ ] All 6 files present (meta, architecture, patterns, tech-stack, schema-rules, testing)\n- [ ] `meta.md` has correct version number and changelog\n- [ ] Changes documented with rationale (why, not just what)\n- [ ] Old version remains untouched (immutable)\n- [ ] References in commands use `current/` not `v{N}/`\n\n## Common Mistakes\n\n### Mistake 1: Editing Current Version for Breaking Changes\n**Wrong:** Edit `docs/constitutions/current/patterns.md` directly when removing next-safe-action requirement\n\n**Right:** Create v2, update patterns.md in v2, update symlink\n\n**Why:** Breaking changes need versioning. Commands/specs may reference old patterns.\n\n### Mistake 2: Hardcoding Version in References\n**Wrong:** `@docs/constitutions/v2/architecture.md`\n\n**Right:** `@docs/constitutions/current/architecture.md`\n\n**Why:** When v3 is created, all references break. Symlink abstracts version.\n\n### Mistake 3: Reorganizing for Style\n**Wrong:** \"Let me alphabetize sections and rename files while versioning\"\n\n**Right:** Only change content that needs substantive updates\n\n**Why:** Gratuitous changes obscure what actually changed. Diff should show real changes.\n\n### Mistake 4: Forgetting to Update meta.md\n**Wrong:** Copy files, update content, update symlink, done\n\n**Right:** Update meta.md with version, date, and changelog\n\n**Why:** Future you won't remember why version changed. Document the why.\n\n### Mistake 5: Versioning Implementation Details\n**Wrong:** Create v2 because we changed button component structure\n\n**Right:** Constitution = foundational rules only. Implementation goes in specs/\n\n**Why:** Constitution is for patterns/architecture/stack, not implementation choices.\n\n### Mistake 6: Rationalizing In-Place Edits\n**Wrong:** \"This change is non-breaking, so I can edit v1 in-place per the meta.md guidance\"\n\n**Right:** Removing/relaxing ANY mandatory pattern requires versioning, even if \"non-breaking\"\n\n**Why:** Audit trail matters more than technical breaking changes. Future readers need to know WHEN rules changed, not just that they did. Git history is not sufficient - constitution versions create explicit snapshots.\n\n## Quick Reference\n\n```bash\n# Check current version\ncat docs/constitutions/current/meta.md\n\n# Create new version\nmkdir -p docs/constitutions/v{N}\ncp docs/constitutions/current/*.md docs/constitutions/v{N}/\n\n# Edit content\n# Update meta.md, then other files as needed\n\n# Update symlink\nrm docs/constitutions/current\nln -s v{N} docs/constitutions/current\n\n# Verify\nls -la docs/constitutions/current\ngrep -r \"constitutions/v[0-9]\" .claude/  # Should return nothing\n```\n\n## Example: Adding New Pattern\n\nScenario: We're adopting `effect-ts` for error handling and deprecating throw/catch.\n\n**Step 1:** Current version is v1 (read meta.md)\n\n**Step 2:** Create v2\n```bash\nmkdir -p docs/constitutions/v2\ncp docs/constitutions/current/*.md docs/constitutions/v2/\n```\n\n**Step 3:** Update content\n- `meta.md`: Version 2, date, \"Added effect-ts error handling pattern\"\n- `patterns.md`: Add new section on Effect error handling\n- `tech-stack.md`: Add effect-ts to approved libraries\n- Leave other files unchanged\n\n**Step 4:** Update symlink\n```bash\nrm docs/constitutions/current\nln -s v2 docs/constitutions/current\n```\n\n**Step 5:** Verify references (should all use `current/`)\n\n**Step 6:** meta.md documents why (type-safe error handling, eliminate throw)\n\n## Testing This Skill\n\nSee `test-scenarios.md` for pressure scenarios and RED-GREEN-REFACTOR tests."
              },
              {
                "name": "writing-specs",
                "description": "Use when creating feature specifications after brainstorming - generates lean spec documents that reference constitutions heavily, link to external docs instead of embedding examples, and focus on WHAT not HOW (implementation plans handled separately)",
                "path": "skills/writing-specs/SKILL.md",
                "frontmatter": {
                  "name": "writing-specs",
                  "description": "Use when creating feature specifications after brainstorming - generates lean spec documents that reference constitutions heavily, link to external docs instead of embedding examples, and focus on WHAT not HOW (implementation plans handled separately)"
                },
                "content": "# Writing Specifications\n\n## Overview\n\nA **specification** defines WHAT to build and WHY. It is NOT an implementation plan.\n\n**Core principle:** Reference constitutions, link to docs, keep it lean. The `/plan` command handles task decomposition.\n\n**Spec = Requirements + Architecture**\n**Plan = Tasks + Dependencies**\n\n## When to Use\n\nUse this skill when:\n- Creating `specs/{run-id}-{feature-slug}/spec.md` after brainstorming\n- Called from `/spectacular:spec` slash command (after brainstorming phases 1-3)\n- Need to document feature requirements and architecture\n\nDo NOT use for:\n- Implementation plans with task breakdown ‚Üí Use `/spectacular:plan` instead\n- API documentation ‚Üí Goes in code comments or separate docs\n- Runbooks or operational guides ‚Üí Different document type\n\n## Spec Structure\n\n```markdown\n# Feature: {Feature Name}\n\n**Status**: Draft\n**Created**: {date}\n\n## Problem Statement\n\n**Current State:**\n{What exists today and what's missing/broken}\n\n**Desired State:**\n{What we want to achieve}\n\n**Gap:**\n{Specific problem this feature solves}\n\n## Requirements\n\n> **Note**: All features must follow @docs/constitutions/current/\n\n### Functional Requirements\n- FR1: {specific requirement}\n- FR2: {specific requirement}\n\n### Non-Functional Requirements\n- NFR1: {performance/security/DX requirement}\n- NFR2: {performance/security/DX requirement}\n\n## Architecture\n\n> **Layer boundaries**: @docs/constitutions/current/architecture.md\n> **Required patterns**: @docs/constitutions/current/patterns.md\n\n### Components\n\n**New Files:**\n- `src/lib/models/{name}.ts` - {purpose}\n- `src/lib/services/{name}-service.ts` - {purpose}\n- `src/lib/actions/{name}-actions.ts` - {purpose}\n\n**Modified Files:**\n- `{path}` - {what changes}\n\n### Dependencies\n\n**New packages:**\n- `{package}` - {purpose}\n- See: {link to official docs}\n\n**Schema changes:**\n- {migration name} - {purpose}\n- Rules: @docs/constitutions/current/schema-rules.md\n\n### Integration Points\n\n- Auth: Uses existing Auth.js setup\n- Database: Prisma client per @docs/constitutions/current/tech-stack.md\n- Validation: Zod schemas per @docs/constitutions/current/patterns.md\n\n## Acceptance Criteria\n\n**Constitution compliance:**\n- [ ] All patterns followed (@docs/constitutions/current/patterns.md)\n- [ ] Architecture boundaries respected (@docs/constitutions/current/architecture.md)\n- [ ] Testing requirements met (@docs/constitutions/current/testing.md)\n\n**Feature-specific:**\n- [ ] {criterion for this feature}\n- [ ] {criterion for this feature}\n- [ ] {criterion for this feature}\n\n**Verification:**\n- [ ] All tests pass\n- [ ] Linting passes\n- [ ] Feature works end-to-end\n\n## Open Questions\n\n{List any unresolved questions or decisions needed}\n\n## References\n\n- Architecture: @docs/constitutions/current/architecture.md\n- Patterns: @docs/constitutions/current/patterns.md\n- Schema Rules: @docs/constitutions/current/schema-rules.md\n- Tech Stack: @docs/constitutions/current/tech-stack.md\n- Testing: @docs/constitutions/current/testing.md\n- {External SDK}: {link to official docs}\n```\n\n## Iron Laws\n\n### 1. Reference, Don't Duplicate\n\n‚ùå **NEVER recreate constitution rules in the spec**\n\n<Bad>\n```markdown\n## Layered Architecture\n\nThe architecture has three layers:\n- Models: Data access with Prisma\n- Services: Business logic\n- Actions: Input validation with Zod\n```\n</Bad>\n\n<Good>\n```markdown\n## Architecture\n\n> **Layer boundaries**: @docs/constitutions/current/architecture.md\n\nComponents follow the established 3-layer pattern.\n```\n</Good>\n\n### 2. Link to Docs, Don't Embed Examples\n\n‚ùå **NEVER include code examples from external libraries**\n\n<Bad>\n```markdown\n### Zod Validation\n\n```typescript\nimport { z } from 'zod';\n\nexport const schema = z.object({\n  name: z.string().min(3),\n  email: z.string().email()\n});\n```\n```\n</Bad>\n\n<Good>\n```markdown\n### Validation\n\nUse Zod schemas per @docs/constitutions/current/patterns.md\n\nSee: https://zod.dev for object schema syntax\n```\n</Good>\n\n### 3. No Implementation Plans\n\n‚ùå **NEVER include task breakdown or migration phases**\n\n<Bad>\n```markdown\n## Migration Plan\n\n### Phase 1: Database Schema\n1. Create Prisma migration\n2. Run migration\n3. Verify indexes\n\n### Phase 2: Backend Implementation\n...\n```\n</Bad>\n\n<Good>\n```markdown\n## Dependencies\n\n**Schema changes:**\n- Migration: `init_rooms` - Add Room, RoomParticipant, WaitingListEntry models\n\nImplementation order determined by `/plan` command.\n```\n</Good>\n\n### 4. No Success Metrics\n\n‚ùå **NEVER include adoption metrics, performance targets, or measurement strategies**\n\n<Bad>\n```markdown\n## Success Metrics\n\n1. Adoption: 80% of users use feature within first month\n2. Performance: Page loads in <500ms\n3. Engagement: <5% churn rate\n```\n</Bad>\n\n<Good>\n```markdown\n## Non-Functional Requirements\n\n- NFR1: Page load performance <500ms (measured per @docs/constitutions/current/testing.md)\n- NFR2: Support 1000 concurrent users\n```\n</Good>\n\n## Common Mistakes\n\n| Mistake | Why It's Wrong | Fix |\n|---------|---------------|-----|\n| Including full Prisma schemas | Duplicates what goes in code | List model names + purposes, reference schema-rules.md |\n| Writing test code examples | Shows HOW not WHAT | List what to test, reference testing.md for how |\n| Explaining ts-pattern syntax | Already in patterns.md | Reference patterns.md, list where pattern applies |\n| Creating `/notes` subdirectory | Violates single-file principle | Keep spec lean, remove supporting docs |\n| Adding timeline estimates | That's project management | Focus on requirements and architecture |\n\n## Rationalization Table\n\n| Excuse | Reality |\n|--------|---------|\n| \"Thorough means showing complete code\" | Thorough = complete requirements. Code = implementation. |\n| \"Spec needs examples so people understand\" | Link to docs. Don't copy-paste library examples. |\n| \"Migration plan shows full picture\" | `/plan` command handles decomposition. Spec = WHAT not HOW. |\n| \"Include constitutions for context\" | Constitutions exist to avoid duplication. Reference, don't recreate. |\n| \"Testing code shows approach\" | testing.md shows approach. Spec lists WHAT to test. |\n| \"Metrics demonstrate value\" | NFRs show requirements. Metrics = measurement strategy (different doc). |\n| \"More detail = more helpful\" | More detail = harder to maintain. Lean + links = durable. |\n\n## Red Flags - STOP and Fix\n\nSeeing any of these? Delete and reference instead:\n\n- Full code examples from libraries (Zod, Prisma, Socket.io, etc.)\n- Migration phases or implementation steps\n- Success metrics or adoption targets\n- Recreated architecture explanations\n- Test implementation code\n- Files in `specs/{run-id}-{feature-slug}/notes/` directory\n- Spec > 300 lines (probably duplicating constitutions)\n\n**All of these mean: Too much implementation detail. Focus on WHAT not HOW.**\n\n## Workflow Integration\n\nThis skill is called from `/spectacular:spec` command:\n\n1. **User runs**: `/spectacular:spec {feature description}`\n2. **Brainstorming**: Phases 1-3 run (understanding, exploration, design)\n3. **This skill**: Generate `specs/{run-id}-{feature-slug}/spec.md`\n4. **User reviews**: Check spec for completeness\n5. **Next step**: `/spectacular:plan @specs/{run-id}-{feature-slug}/spec.md` for task decomposition\n\n## Quality Checklist\n\nBefore finalizing spec:\n\n- [ ] Problem statement shows current ‚Üí desired state gap\n- [ ] All FRs and NFRs are testable/verifiable\n- [ ] Architecture section lists files (not code examples)\n- [ ] All constitution rules referenced (not recreated)\n- [ ] All external libraries linked to docs (not copied)\n- [ ] No implementation plan (saved for `/spectacular:plan`)\n- [ ] No success metrics or timelines\n- [ ] Single file at `specs/{run-id}-{feature-slug}/spec.md`\n- [ ] Spec < 300 lines (if longer, check for duplication)\n\n## The Bottom Line\n\n**Specs define WHAT and WHY. Plans define HOW and WHEN.**\n\nReference heavily. Link to docs. Keep it lean.\n\nIf you're copy-pasting code or recreating rules, you're writing the wrong document."
              }
            ]
          }
        ]
      }
    }
  ]
}