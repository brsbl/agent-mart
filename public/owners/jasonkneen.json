{
  "owner": {
    "id": "jasonkneen",
    "display_name": " ðŸ¤— Jason Kneen",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/502002?u=4ba6a2081d398991c7dd9e9b3f2c678c67b64f7b&v=4",
    "url": "https://github.com/jasonkneen",
    "bio": "Seasoned developer, engineer, innovator, building AI solutions and tooling, MCPs and innovate solutions to every day problems. Mobile and App Dev, Dev Rel.",
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 8,
      "total_stars": 464,
      "total_forks": 141
    }
  },
  "repos": [
    {
      "full_name": "jasonkneen/kiro",
      "url": "https://github.com/jasonkneen/kiro",
      "description": "Complete System Prompts for Kiro IDE by Amazon",
      "homepage": null,
      "signals": {
        "stars": 464,
        "forks": 141,
        "pushed_at": "2026-01-12T14:28:33Z",
        "created_at": "2025-07-16T17:47:23Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 351
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 709
        },
        {
          "path": ".kiro",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kiro/README.md",
          "type": "blob",
          "size": 57
        },
        {
          "path": ".kiro/Screenshot 2025-07-16 at 18.45.46.png",
          "type": "blob",
          "size": 172134
        },
        {
          "path": ".kiro/steering",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kiro/steering/api-design.md",
          "type": "blob",
          "size": 1113
        },
        {
          "path": ".kiro/steering/development-environment.md",
          "type": "blob",
          "size": 1265
        },
        {
          "path": ".kiro/steering/frontend-standards.md",
          "type": "blob",
          "size": 1505
        },
        {
          "path": ".kiro/steering/git-workflow.md",
          "type": "blob",
          "size": 958
        },
        {
          "path": ".kiro/steering/project-standards.md",
          "type": "blob",
          "size": 1403
        },
        {
          "path": ".kiro/steering/steering-creation-guide.md",
          "type": "blob",
          "size": 6007
        },
        {
          "path": ".kiro/system",
          "type": "tree",
          "size": null
        },
        {
          "path": ".kiro/system/README.md",
          "type": "blob",
          "size": 953
        },
        {
          "path": ".kiro/system/capabilities.md",
          "type": "blob",
          "size": 7729
        },
        {
          "path": ".kiro/system/complete-instructions.md",
          "type": "blob",
          "size": 15563
        },
        {
          "path": ".kiro/system/guidelines.md",
          "type": "blob",
          "size": 3362
        },
        {
          "path": ".kiro/system/quality-standards.md",
          "type": "blob",
          "size": 1955
        },
        {
          "path": ".kiro/system/response-style.md",
          "type": "blob",
          "size": 3276
        },
        {
          "path": ".kiro/system/workflow-patterns.md",
          "type": "blob",
          "size": 2084
        },
        {
          "path": ".vscode",
          "type": "tree",
          "size": null
        },
        {
          "path": ".vscode/settings.json",
          "type": "blob",
          "size": 2
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1068
        },
        {
          "path": "PLUGIN.md",
          "type": "blob",
          "size": 3711
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 11267
        },
        {
          "path": "codebase.md",
          "type": "blob",
          "size": 482331
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/create-steering-documents-standalone.md",
          "type": "blob",
          "size": 16231
        },
        {
          "path": "commands/create-steering-documents.md",
          "type": "blob",
          "size": 5819
        },
        {
          "path": "kiro-web-app",
          "type": "tree",
          "size": null
        },
        {
          "path": "kiro-web-app/.gitignore",
          "type": "blob",
          "size": 1052
        },
        {
          "path": "kiro-web-app/README.md",
          "type": "blob",
          "size": 2650
        },
        {
          "path": "kiro-web-app/index.html",
          "type": "blob",
          "size": 677
        },
        {
          "path": "kiro-web-app/package-lock.json",
          "type": "blob",
          "size": 144809
        },
        {
          "path": "kiro-web-app/package.json",
          "type": "blob",
          "size": 1141
        },
        {
          "path": "kiro-web-app/postcss.config.js",
          "type": "blob",
          "size": 80
        },
        {
          "path": "kiro-web-app/src",
          "type": "tree",
          "size": null
        },
        {
          "path": "kiro-web-app/src/App.tsx",
          "type": "blob",
          "size": 1876
        },
        {
          "path": "kiro-web-app/src/components",
          "type": "tree",
          "size": null
        },
        {
          "path": "kiro-web-app/src/components/Layout.tsx",
          "type": "blob",
          "size": 8565
        },
        {
          "path": "kiro-web-app/src/index.css",
          "type": "blob",
          "size": 907
        },
        {
          "path": "kiro-web-app/src/main.tsx",
          "type": "blob",
          "size": 236
        },
        {
          "path": "kiro-web-app/src/pages",
          "type": "tree",
          "size": null
        },
        {
          "path": "kiro-web-app/src/pages/AIReasoning.tsx",
          "type": "blob",
          "size": 3065
        },
        {
          "path": "kiro-web-app/src/pages/Commands.tsx",
          "type": "blob",
          "size": 6666
        },
        {
          "path": "kiro-web-app/src/pages/ContentCoverage.tsx",
          "type": "blob",
          "size": 10667
        },
        {
          "path": "kiro-web-app/src/pages/Examples.tsx",
          "type": "blob",
          "size": 2425
        },
        {
          "path": "kiro-web-app/src/pages/Execution.tsx",
          "type": "blob",
          "size": 1407
        },
        {
          "path": "kiro-web-app/src/pages/Home.tsx",
          "type": "blob",
          "size": 8691
        },
        {
          "path": "kiro-web-app/src/pages/Methodology.tsx",
          "type": "blob",
          "size": 5247
        },
        {
          "path": "kiro-web-app/src/pages/Navigation.tsx",
          "type": "blob",
          "size": 23043
        },
        {
          "path": "kiro-web-app/src/pages/Process.tsx",
          "type": "blob",
          "size": 2365
        },
        {
          "path": "kiro-web-app/src/pages/Prompting.tsx",
          "type": "blob",
          "size": 2167
        },
        {
          "path": "kiro-web-app/src/pages/Resources.tsx",
          "type": "blob",
          "size": 1949
        },
        {
          "path": "kiro-web-app/src/pages/SteeringDocs.tsx",
          "type": "blob",
          "size": 5444
        },
        {
          "path": "kiro-web-app/src/pages/SystemDocs.tsx",
          "type": "blob",
          "size": 10983
        },
        {
          "path": "kiro-web-app/src/pages/Templates.tsx",
          "type": "blob",
          "size": 2519
        },
        {
          "path": "kiro-web-app/src/pages/ValidationReport.tsx",
          "type": "blob",
          "size": 8201
        },
        {
          "path": "kiro-web-app/tailwind.config.js",
          "type": "blob",
          "size": 914
        },
        {
          "path": "kiro-web-app/tsconfig.json",
          "type": "blob",
          "size": 652
        },
        {
          "path": "kiro-web-app/tsconfig.node.json",
          "type": "blob",
          "size": 236
        },
        {
          "path": "kiro-web-app/vite.config.ts",
          "type": "blob",
          "size": 289
        },
        {
          "path": "mcp-server",
          "type": "tree",
          "size": null
        },
        {
          "path": "mcp-server/.gitignore",
          "type": "blob",
          "size": 328
        },
        {
          "path": "mcp-server/LICENSE",
          "type": "blob",
          "size": 1068
        },
        {
          "path": "mcp-server/MANIFEST.in",
          "type": "blob",
          "size": 77
        },
        {
          "path": "mcp-server/QUICKSTART.md",
          "type": "blob",
          "size": 3739
        },
        {
          "path": "mcp-server/README.md",
          "type": "blob",
          "size": 2532
        },
        {
          "path": "mcp-server/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "mcp-server/examples/README.md",
          "type": "blob",
          "size": 2332
        },
        {
          "path": "mcp-server/examples/mcp-config.json",
          "type": "blob",
          "size": 277
        },
        {
          "path": "mcp-server/pyproject.toml",
          "type": "blob",
          "size": 518
        },
        {
          "path": "mcp-server/src",
          "type": "tree",
          "size": null
        },
        {
          "path": "mcp-server/src/kiro_mcp_server",
          "type": "tree",
          "size": null
        },
        {
          "path": "mcp-server/src/kiro_mcp_server/__init__.py",
          "type": "blob",
          "size": 85
        },
        {
          "path": "mcp-server/src/kiro_mcp_server/__main__.py",
          "type": "blob",
          "size": 152
        },
        {
          "path": "mcp-server/src/kiro_mcp_server/server.py",
          "type": "blob",
          "size": 9465
        },
        {
          "path": "mcp-server/tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "mcp-server/tests/__init__.py",
          "type": "blob",
          "size": 33
        },
        {
          "path": "mcp-server/tests/test_server.py",
          "type": "blob",
          "size": 1724
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/validate-skills.sh",
          "type": "blob",
          "size": 2555
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/README.md",
          "type": "blob",
          "size": 2554
        },
        {
          "path": "skills/ai-prompting",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/ai-prompting/SKILL.md",
          "type": "blob",
          "size": 10093
        },
        {
          "path": "skills/create-steering-documents",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/create-steering-documents/SKILL.md",
          "type": "blob",
          "size": 11413
        },
        {
          "path": "skills/design-documentation",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/design-documentation/SKILL.md",
          "type": "blob",
          "size": 10525
        },
        {
          "path": "skills/quality-assurance",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/quality-assurance/SKILL.md",
          "type": "blob",
          "size": 9015
        },
        {
          "path": "skills/requirements-engineering",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/requirements-engineering/SKILL.md",
          "type": "blob",
          "size": 8602
        },
        {
          "path": "skills/spec-driven-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/spec-driven-development/SKILL.md",
          "type": "blob",
          "size": 6417
        },
        {
          "path": "skills/task-breakdown",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/task-breakdown/SKILL.md",
          "type": "blob",
          "size": 10228
        },
        {
          "path": "skills/troubleshooting",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/troubleshooting/SKILL.md",
          "type": "blob",
          "size": 10566
        },
        {
          "path": "spec-process-guide",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/NAVIGATION.md",
          "type": "blob",
          "size": 10811
        },
        {
          "path": "spec-process-guide/ai-reasoning",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/ai-reasoning/README.md",
          "type": "blob",
          "size": 1954
        },
        {
          "path": "spec-process-guide/ai-reasoning/decision-frameworks.md",
          "type": "blob",
          "size": 8241
        },
        {
          "path": "spec-process-guide/ai-reasoning/examples.md",
          "type": "blob",
          "size": 14341
        },
        {
          "path": "spec-process-guide/ai-reasoning/thought-processes.md",
          "type": "blob",
          "size": 17180
        },
        {
          "path": "spec-process-guide/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/examples/README.md",
          "type": "blob",
          "size": 2252
        },
        {
          "path": "spec-process-guide/examples/case-studies.md",
          "type": "blob",
          "size": 22151
        },
        {
          "path": "spec-process-guide/examples/complex-system-spec.md",
          "type": "blob",
          "size": 36276
        },
        {
          "path": "spec-process-guide/examples/lightweight-examples.md",
          "type": "blob",
          "size": 9957
        },
        {
          "path": "spec-process-guide/examples/simple-feature-spec.md",
          "type": "blob",
          "size": 19849
        },
        {
          "path": "spec-process-guide/examples/spec-upgrade-examples.md",
          "type": "blob",
          "size": 13634
        },
        {
          "path": "spec-process-guide/examples/troubleshooting-pitfalls.md",
          "type": "blob",
          "size": 11238
        },
        {
          "path": "spec-process-guide/execution",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/execution/README.md",
          "type": "blob",
          "size": 1913
        },
        {
          "path": "spec-process-guide/execution/implementation-guide.md",
          "type": "blob",
          "size": 9604
        },
        {
          "path": "spec-process-guide/execution/quality-assurance.md",
          "type": "blob",
          "size": 15398
        },
        {
          "path": "spec-process-guide/execution/troubleshooting.md",
          "type": "blob",
          "size": 15492
        },
        {
          "path": "spec-process-guide/methodology",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/methodology/README.md",
          "type": "blob",
          "size": 9080
        },
        {
          "path": "spec-process-guide/methodology/lightweight-specs.md",
          "type": "blob",
          "size": 8168
        },
        {
          "path": "spec-process-guide/methodology/overview.md",
          "type": "blob",
          "size": 5657
        },
        {
          "path": "spec-process-guide/methodology/philosophy.md",
          "type": "blob",
          "size": 7345
        },
        {
          "path": "spec-process-guide/methodology/when-to-use.md",
          "type": "blob",
          "size": 10681
        },
        {
          "path": "spec-process-guide/process",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/process/README.md",
          "type": "blob",
          "size": 2690
        },
        {
          "path": "spec-process-guide/process/change-management.md",
          "type": "blob",
          "size": 7507
        },
        {
          "path": "spec-process-guide/process/design-phase.md",
          "type": "blob",
          "size": 15122
        },
        {
          "path": "spec-process-guide/process/requirements-phase.md",
          "type": "blob",
          "size": 11085
        },
        {
          "path": "spec-process-guide/process/tasks-phase.md",
          "type": "blob",
          "size": 40134
        },
        {
          "path": "spec-process-guide/process/workflow-diagrams.md",
          "type": "blob",
          "size": 10468
        },
        {
          "path": "spec-process-guide/prompting",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/prompting/README.md",
          "type": "blob",
          "size": 1903
        },
        {
          "path": "spec-process-guide/prompting/best-practices.md",
          "type": "blob",
          "size": 12245
        },
        {
          "path": "spec-process-guide/prompting/strategies.md",
          "type": "blob",
          "size": 12606
        },
        {
          "path": "spec-process-guide/prompting/templates.md",
          "type": "blob",
          "size": 8436
        },
        {
          "path": "spec-process-guide/resources",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/resources/README.md",
          "type": "blob",
          "size": 1771
        },
        {
          "path": "spec-process-guide/resources/further-reading.md",
          "type": "blob",
          "size": 12054
        },
        {
          "path": "spec-process-guide/resources/standards.md",
          "type": "blob",
          "size": 13983
        },
        {
          "path": "spec-process-guide/resources/tool-integration-guide.md",
          "type": "blob",
          "size": 34666
        },
        {
          "path": "spec-process-guide/resources/tools.md",
          "type": "blob",
          "size": 26407
        },
        {
          "path": "spec-process-guide/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "spec-process-guide/templates/README.md",
          "type": "blob",
          "size": 2463
        },
        {
          "path": "spec-process-guide/templates/checklists.md",
          "type": "blob",
          "size": 19230
        },
        {
          "path": "spec-process-guide/templates/design-template.md",
          "type": "blob",
          "size": 10777
        },
        {
          "path": "spec-process-guide/templates/micro-spec-template.md",
          "type": "blob",
          "size": 6386
        },
        {
          "path": "spec-process-guide/templates/quick-spec-template.md",
          "type": "blob",
          "size": 8400
        },
        {
          "path": "spec-process-guide/templates/requirements-template.md",
          "type": "blob",
          "size": 7481
        },
        {
          "path": "spec-process-guide/templates/tasks-template.md",
          "type": "blob",
          "size": 11135
        }
      ],
      "marketplace": {
        "name": "kiro-marketplace",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Jason Kneen",
          "url": "https://github.com/jasonkneen"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "kiro-spec-driven",
            "description": "Spec-driven development methodology with skills for requirements, design, tasks, AI prompting, QA, and troubleshooting",
            "source": "./",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add jasonkneen/kiro",
              "/plugin install kiro-spec-driven@kiro-marketplace"
            ],
            "signals": {
              "stars": 464,
              "forks": 141,
              "pushed_at": "2026-01-12T14:28:33Z",
              "created_at": "2025-07-16T17:47:23Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "ai-prompting",
                "description": "Effective communication strategies for AI-assisted development. Learn context-first prompting, phased interactions, iterative refinement, and validation techniques to get better results from Claude and other AI coding assistants.",
                "path": "skills/ai-prompting/SKILL.md",
                "frontmatter": {
                  "name": "ai-prompting",
                  "description": "Effective communication strategies for AI-assisted development. Learn context-first prompting, phased interactions, iterative refinement, and validation techniques to get better results from Claude and other AI coding assistants.",
                  "license": "MIT",
                  "compatibility": "Claude Code, Cursor, VS Code, Windsurf",
                  "metadata": {
                    "category": "methodology",
                    "complexity": "beginner",
                    "author": "Kiro Team",
                    "version": "1.0.0"
                  }
                },
                "content": "# AI Prompting Strategies\n\nMaster the art of communicating with AI coding assistants to get better results faster. These strategies are optimized for spec-driven development but apply broadly to AI collaboration.\n\n## When to Use This Skill\n\nUse these prompting strategies when:\n- Working with Claude Code, Cursor, or other AI assistants\n- Creating specs through AI collaboration\n- Getting inconsistent or low-quality AI responses\n- Need to improve AI output accuracy\n- Want faster iteration cycles\n\n## Core Strategies\n\n### Strategy 1: Context-First Prompting\n\nAlways provide sufficient context before making requests.\n\n**Poor Approach:**\n```\nCreate requirements for a user profile feature.\n```\n\n**Better Approach:**\n```\nI'm working on a web application for a fitness tracking platform. We need to add user profile functionality where users can manage their personal information and fitness goals.\n\nContext:\n- Technology: React frontend, Node.js backend\n- User base: Health-conscious individuals, age 18-65\n- Key constraint: Must comply with GDPR for EU users\n- Integration: Will connect with existing authentication system\n\nPlease help me create requirements for the user profile feature.\n```\n\n**Why It Works:**\n- Provides domain context for better decisions\n- Identifies technical constraints early\n- Clarifies compliance requirements\n- Enables more relevant suggestions\n\n### Strategy 2: Phased Interaction\n\nWork through spec phases sequentially. Complete each phase before moving to the next.\n\n**Phase 1 - Requirements:**\n```\nLet's start with the requirements phase for [feature name].\n\nCurrent situation: [describe current state]\nProblem to solve: [describe the problem]\nUsers affected: [describe user types]\nSuccess criteria: [how we'll know it works]\n\nPlease help me develop comprehensive requirements using the EARS format.\n```\n\n**Phase 2 - Design (after requirements approved):**\n```\nNow that we have clear requirements, let's create the technical design.\n\nRequirements summary: [key requirements]\nTechnical context: [architecture, frameworks, patterns]\nConstraints: [performance, scalability, security]\n\nPlease propose a technical design that addresses these requirements.\n```\n\n**Phase 3 - Tasks (after design approved):**\n```\nWith the design finalized, let's break this into implementation tasks.\n\nDesign summary: [key components and interactions]\nTeam context: [team size, skill levels]\nDependencies: [what must be built first]\n\nPlease create a sequenced task breakdown for implementation.\n```\n\n### Strategy 3: Iterative Refinement\n\nTreat spec development as conversation, not single requests.\n\n**Initial Request:**\n```\nHelp me define requirements for email notification preferences.\n```\n\n**Refinement Round 1:**\n```\nGreat start! Let's refine a few areas:\n1. For notification frequency, can we add daily digest option?\n2. How should we handle changing preferences during pending notifications?\n3. Can you elaborate on the unsubscribe requirement for GDPR compliance?\n```\n\n**Refinement Round 2:**\n```\nPerfect. Now let's add requirements for:\n- Mobile push notifications (in addition to email)\n- Notification history (last 30 days)\n- Per-notification-type controls (not just global on/off)\n```\n\n### Strategy 4: Example-Driven Prompting\n\nProvide concrete examples of what you want.\n\n**For Requirements:**\n```\nI need acceptance criteria for a file upload feature. Use the EARS format like this example:\n\nGood example from our auth feature:\n\"WHEN a user enters valid credentials THEN the system SHALL authenticate within 2 seconds\"\n\nAvoid vague requirements like:\n\"System should handle file uploads efficiently\"\n\nFocus on specific, testable criteria for:\n- File size limits\n- Supported file types\n- Upload progress indication\n- Error handling\n```\n\n**For Design:**\n```\nCreate a component architecture. Follow this existing pattern:\n\n[Reference existing architecture]\n\nKey elements to include:\n- Component responsibilities\n- Data flow\n- API boundaries\n- Error handling paths\n```\n\n### Strategy 5: Constraint-Explicit Prompting\n\nMake all constraints explicit. Don't assume AI knows your limitations.\n\n```\nDesign a caching strategy for product catalog data.\n\nExplicit constraints:\n- Infrastructure: AWS with Redis, PostgreSQL\n- Performance: API response < 200ms for cached data\n- Scale: 10,000 products, 1,000 concurrent users\n- Budget: Cache cost < $100/month\n- Freshness: Updates visible within 5 minutes\n- Maintenance: 2-person ops team\n\nFlexibility allowed:\n- Cache invalidation strategy (time or event-based)\n- Cache key structure (optimize as needed)\n- Failover approach (as long as reliable)\n```\n\n### Strategy 6: Role-Based Prompting\n\nFrame requests from specific perspectives.\n\n**Product Owner Perspective:**\n```\nAs a product owner defining checkout requirements:\n- Business goals: Reduce cart abandonment\n- User value: Smooth, trustworthy purchase experience\n- Success metrics: Checkout completion rate > 80%\n\nWhat requirements should I capture?\n```\n\n**Technical Lead Perspective:**\n```\nAs tech lead designing a notification system:\n- Integrates with existing microservices\n- Handles 100k notifications/day with room to grow\n- Maintains health if notification service fails\n- Aligns with event-driven architecture\n\nWhat design approach would you recommend?\n```\n\n**Developer Perspective:**\n```\nAs a mid-level developer implementing this:\n- Need clear tasks (2-4 hours each)\n- Explicit dependencies between tasks\n- Guidance on testing approach\n- References to existing code patterns\n\nCan you break down the implementation accordingly?\n```\n\n### Strategy 7: Validation-Oriented Prompting\n\nBuild quality checks into your prompts.\n\n**After Requirements:**\n```\nReview these requirements and check:\n1. Are all requirements testable and measurable?\n2. Have we covered error cases and edge cases?\n3. Do any requirements conflict with each other?\n4. Are there gaps in the user journey?\n5. Do requirements map to all user stories?\n\nProvide a validation summary.\n```\n\n**After Design:**\n```\nValidate this design against:\n1. Does it address all requirements?\n2. Are there single points of failure?\n3. What are the performance bottlenecks?\n4. How does it handle scale growth?\n5. What security concerns exist?\n\nProvide a critical review.\n```\n\n### Strategy 8: Trade-Off Exploration\n\nExplore options rather than seeking single answers.\n\n```\nWe need real-time notifications. Compare these options:\n\nOption A: WebSocket connections\nOption B: Server-Sent Events (SSE)\nOption C: Long polling\n\nFor each, evaluate:\n- Implementation complexity\n- Browser compatibility\n- Server resource usage\n- Scalability characteristics\n- Maintenance overhead\n\nPresent trade-offs in a comparison table.\n```\n\n## Phase-Specific Patterns\n\n### Requirements Phase Patterns\n\n**User Story Expansion:**\n```\nI have this user story: [basic story]\n\nPlease help me:\n1. Expand with detailed acceptance criteria (EARS format)\n2. Identify edge cases and error scenarios\n3. Define non-functional requirements\n4. Suggest validation criteria\n```\n\n**Completeness Check:**\n```\nHere are my draft requirements: [requirements]\n\nCheck for completeness:\n- Are all user workflows covered?\n- Have we addressed error handling?\n- Are there accessibility requirements?\n- What about data privacy and security?\n- Have we considered mobile vs desktop?\n```\n\n### Design Phase Patterns\n\n**Architecture Exploration:**\n```\nGiven these requirements: [summary]\n\nPropose 2-3 different architectural approaches:\n1. For each, describe components and interactions\n2. List pros and cons\n3. Identify risks and mitigations\n4. Estimate complexity\n\nHelp me compare and choose.\n```\n\n**Integration Design:**\n```\nThis feature integrates with: [list systems]\n\nDesign the integration:\n1. Define API contracts\n2. Specify data flow and transformation\n3. Plan error handling and retries\n4. Document assumptions and dependencies\n```\n\n### Tasks Phase Patterns\n\n**Task Sequencing:**\n```\nBased on this design: [summary]\n\nCreate implementation tasks that:\n1. Are sequenced to minimize dependencies\n2. Enable incremental testing\n3. Separate setup, core features, and polish\n4. Include testing tasks\n5. Range from 2-4 hours each\n```\n\n**Task Validation:**\n```\nReview these tasks: [task list]\n\nVerify:\n1. Can each task be completed independently?\n2. Are dependencies clearly marked?\n3. Do tasks map to design components?\n4. Are testing steps included?\n5. Is anything missing?\n```\n\n## Advanced Techniques\n\n### Specification by Example\nProvide examples of good and bad outputs to calibrate responses.\n\n### Incremental Context Building\nStart broad, add detail as AI demonstrates understanding.\n\n### Meta-Prompting\nAsk AI how to prompt it better for your specific context.\n\n### Comparative Prompting\nPresent multiple versions, ask which is better and why.\n\n## Common Mistakes\n\n1. **Too little context:** AI can't read your mind\n2. **All at once:** Work in phases, not giant prompts\n3. **Accept first response:** Iterate and refine\n4. **No examples:** Show what you want\n5. **Hidden constraints:** Make limitations explicit\n6. **Skip validation:** Always verify outputs\n\n## Quick Reference\n\n**Starting a spec:**\n```\nI'm working on [project]. We need [feature].\nContext: [tech stack, constraints, users]\nPlease help me develop [requirements/design/tasks].\n```\n\n**Refining output:**\n```\nGood progress. Let's improve:\n1. [Specific area to expand]\n2. [Missing element to add]\n3. [Clarification needed]\n```\n\n**Validating output:**\n```\nReview this [document] and identify:\n- Missing elements\n- Ambiguities\n- Conflicts\n- Quality issues\n```\n\n**Exploring options:**\n```\nCompare these approaches: [options]\nEvaluate: [criteria]\nPresent trade-offs for decision-making.\n```"
              },
              {
                "name": "create-steering-documents",
                "description": "Create comprehensive steering documents for development projects. Generates project-specific standards, git workflows, and technology guidelines in .kiro/steering/ directory.",
                "path": "skills/create-steering-documents/SKILL.md",
                "frontmatter": {
                  "name": "create-steering-documents",
                  "description": "Create comprehensive steering documents for development projects. Generates project-specific standards, git workflows, and technology guidelines in .kiro/steering/ directory.",
                  "version": "1.0.0",
                  "license": "MIT",
                  "compatibility": [
                    "Claude Code",
                    "Cursor",
                    "VS Code Copilot",
                    "Windsurf"
                  ],
                  "metadata": {
                    "category": "project-setup",
                    "complexity": "intermediate",
                    "triggers": [
                      "create steering documents",
                      "setup project standards",
                      "initialize kiro steering",
                      "project guidelines"
                    ]
                  }
                },
                "content": "# Create Steering Documents\n\nCreate comprehensive steering documents for a development project based on the project type and requirements.\n\n## Usage\n\n```\nCreate steering documents for [project description]\n```\n\n## Examples\n\n- `Create steering documents for a React TypeScript e-commerce application`\n- `Create steering documents for a Python Django REST API with PostgreSQL`\n- `Create steering documents for a Node.js microservices architecture`\n- `Create steering documents for a Vue.js component library`\n\n## What Are Steering Documents?\n\nSteering documents are contextual guidelines that influence how AI assistants approach development tasks. They contain project-specific standards, conventions, and best practices that help provide more relevant and consistent assistance.\n\n### How They Work\n\n1. **Always Included (Default)**: Documents without front-matter are included in every interaction\n2. **File Match Conditional**: Documents with `inclusion: fileMatch` are included when specific files are in context\n3. **Manual Inclusion**: Documents with `inclusion: manual` are only included when explicitly referenced\n\n## Process\n\n### 1. Project Analysis\n\nFirst, analyze the project requirements and determine which steering documents are needed:\n\n**For Frontend Projects (React, Vue, Angular):**\n- Include: project-standards.md, git-workflow.md, frontend-standards.md, development-environment.md\n- Consider: component-library.md, testing-strategy.md\n\n**For Backend/API Projects (Node.js, Python, Java):**\n- Include: project-standards.md, git-workflow.md, api-design.md, development-environment.md\n- Consider: database-standards.md, security-guidelines.md\n\n**For Full-Stack Projects:**\n- Include: All core documents plus technology-specific ones\n- Consider: deployment-standards.md, monitoring-guidelines.md\n\n**For Library/Package Projects:**\n- Include: project-standards.md, git-workflow.md, documentation-standards.md\n- Consider: versioning-strategy.md, publishing-guidelines.md\n\n### 2. Core Document Templates\n\n#### project-standards.md\n\n```markdown\n# Project Standards and Guidelines\n\n## Code Quality Standards\n- Follow language-specific style guides (ESLint for JS/TS, Black for Python, etc.)\n- Maintain consistent naming conventions across the codebase\n- Write self-documenting code with clear variable and function names\n- Include meaningful comments for complex business logic\n- Keep functions small and focused on single responsibilities\n\n## Testing Requirements\n- Write unit tests for all business logic functions\n- Maintain minimum 80% code coverage\n- Include integration tests for API endpoints\n- Write end-to-end tests for critical user flows\n- Use descriptive test names that explain the scenario being tested\n\n## Documentation Standards\n- Update README.md for any significant changes\n- Document API endpoints with clear examples\n- Include setup and deployment instructions\n- Maintain changelog for version releases\n- Document architectural decisions in ADR format\n\n## Security Practices\n- Never commit secrets, API keys, or passwords\n- Use environment variables for configuration\n- Validate all user inputs\n- Implement proper authentication and authorization\n- Follow OWASP security guidelines\n\n## Performance Guidelines\n- Optimize database queries and avoid N+1 problems\n- Implement caching where appropriate\n- Use lazy loading for large datasets\n- Monitor and profile performance regularly\n- Consider scalability in architectural decisions\n```\n\n#### git-workflow.md\n\n```markdown\n# Git Workflow and Branching Strategy\n\n## Branch Naming Convention\n- Feature branches: `feature/description-of-feature`\n- Bug fixes: `fix/description-of-bug`\n- Hotfixes: `hotfix/critical-issue-description`\n- Releases: `release/version-number`\n\n## Commit Message Format\nFollow conventional commits format:\n```\ntype(scope): description\n\n[optional body]\n\n[optional footer]\n```\n\nTypes: feat, fix, docs, style, refactor, test, chore\n\n## Pull Request Guidelines\n- Create PR from feature branch to main/develop\n- Include clear description of changes\n- Link related issues using keywords (fixes #123)\n- Ensure all tests pass before requesting review\n- Squash commits when merging to keep history clean\n\n## Code Review Process\n- At least one approval required before merge\n- Review for code quality, security, and performance\n- Check that tests cover new functionality\n- Verify documentation is updated if needed\n- Ensure no breaking changes without proper versioning\n```\n\n#### frontend-standards.md\n\n```markdown\n---\ninclusion: fileMatch\nfileMatchPattern: '*.tsx|*.jsx|*.vue|*.svelte'\n---\n\n# Frontend Development Standards\n\n## Component Architecture\n- Use functional components with hooks (React)\n- Keep components small and focused\n- Implement proper prop validation\n- Use TypeScript for type safety\n- Follow component composition patterns\n\n## State Management\n- Use local state for component-specific data\n- Implement global state for shared application data\n- Use proper state management libraries (Redux, Zustand, Pinia)\n- Avoid prop drilling with context or state management\n\n## Styling Guidelines\n- Use CSS modules or styled-components for component styling\n- Follow BEM methodology for CSS class naming\n- Implement responsive design with mobile-first approach\n- Use CSS custom properties for theming\n- Maintain consistent spacing and typography scales\n\n## Performance Optimization\n- Implement code splitting and lazy loading\n- Use React.memo or similar for expensive components\n- Optimize images and assets\n- Implement proper caching strategies\n- Monitor bundle size and performance metrics\n\n## Accessibility Standards\n- Use semantic HTML elements\n- Implement proper ARIA attributes\n- Ensure keyboard navigation support\n- Maintain proper color contrast ratios\n- Test with screen readers\n```\n\n#### api-design.md\n\n```markdown\n---\ninclusion: manual\n---\n\n# API Design Guidelines\n\n## RESTful API Standards\n- Use HTTP methods appropriately (GET, POST, PUT, DELETE, PATCH)\n- Follow resource-based URL patterns: `/api/v1/users/{id}`\n- Use plural nouns for resource collections\n- Implement proper HTTP status codes\n- Include API versioning in URL path\n\n## Request/Response Format\n- Use JSON for request and response bodies\n- Follow consistent naming conventions (camelCase or snake_case)\n- Include pagination for list endpoints\n- Implement proper error response format:\n\n```json\n{\n  \"error\": {\n    \"code\": \"VALIDATION_ERROR\",\n    \"message\": \"Invalid input provided\",\n    \"details\": [\"Email is required\", \"Password too short\"]\n  }\n}\n```\n\n## Authentication and Authorization\n- Use JWT tokens for stateless authentication\n- Implement proper token refresh mechanisms\n- Use role-based access control (RBAC)\n- Rate limit API endpoints to prevent abuse\n\n## Documentation\n- Use OpenAPI/Swagger for API documentation\n- Include request/response examples\n- Document all possible error responses\n- Provide SDK or client library examples\n```\n\n#### development-environment.md\n\n```markdown\n---\ninclusion: fileMatch\nfileMatchPattern: 'package.json|requirements.txt|Dockerfile|docker-compose.yml'\n---\n\n# Development Environment Setup\n\n## Local Development\n- Use Node.js version specified in .nvmrc file\n- Install dependencies with `npm ci` for consistent builds\n- Use Docker for local database and service dependencies\n- Run linting and formatting before committing changes\n\n## Environment Variables\n- Copy `.env.example` to `.env` for local development\n- Never commit actual environment files\n- Document all required environment variables in README\n- Use different prefixes for different environments (DEV_, PROD_, etc.)\n\n## Database Management\n- Use migrations for all schema changes\n- Include rollback scripts for migrations\n- Seed data should be idempotent\n- Backup database before major changes\n\n## Build and Deployment\n- Ensure builds are reproducible across environments\n- Use multi-stage Docker builds for optimization\n- Include health checks in containerized applications\n- Document deployment procedures and rollback steps\n\n## Debugging and Logging\n- Use structured logging with appropriate log levels\n- Include correlation IDs for request tracing\n- Set up proper error monitoring and alerting\n- Use debugger instead of console.log for development\n```\n\n### 3. Content Customization\n\n**Language/Framework Specific Adaptations:**\n- **JavaScript/TypeScript**: ESLint, Prettier, Jest, package.json scripts\n- **Python**: Black, flake8, pytest, requirements.txt, virtual environments\n- **Java**: Checkstyle, Maven/Gradle, JUnit, Spring Boot conventions\n- **Go**: gofmt, go mod, testing patterns, project structure\n- **Rust**: rustfmt, Cargo.toml, cargo test, clippy\n\n**Project Scale Adaptations:**\n- **Small Projects**: Lightweight processes, minimal tooling\n- **Team Projects**: Code review requirements, shared standards\n- **Enterprise**: Comprehensive security, compliance, documentation\n\n**Domain Specific Considerations:**\n- **E-commerce**: PCI compliance, performance, security\n- **Healthcare**: HIPAA compliance, data privacy, audit trails\n- **Finance**: Security standards, regulatory compliance\n- **Open Source**: Contribution guidelines, licensing, community standards\n\n### 4. File Reference Integration\n\nInclude relevant external files using the `#[[file:path]]` syntax:\n- OpenAPI specifications for API projects\n- Database schemas for backend projects\n- Design system tokens for frontend projects\n- Configuration files for environment setup\n\n### 5. Quality Checklist\n\nBefore finalizing steering documents, ensure:\n- [ ] All documents have appropriate front-matter for inclusion logic\n- [ ] Guidelines are specific and actionable, not generic\n- [ ] Examples are provided for complex concepts\n- [ ] No conflicting standards between documents\n- [ ] Security and performance considerations are included\n- [ ] Documentation covers the full development lifecycle\n- [ ] File references are correctly formatted and valid\n\n## Output Structure\n\nCreate steering documents in the `.kiro/steering/` directory:\n\n```\n.kiro/steering/\nâ”œâ”€â”€ project-standards.md      (always included)\nâ”œâ”€â”€ git-workflow.md           (always included)\nâ”œâ”€â”€ frontend-standards.md     (fileMatch: *.tsx,*.jsx)\nâ”œâ”€â”€ api-design.md             (manual inclusion)\nâ””â”€â”€ development-environment.md (fileMatch: package.json)\n```\n\n## Front-matter Options\n\n```yaml\n---\ninclusion: always|fileMatch|manual\nfileMatchPattern: 'glob-pattern'  # for fileMatch only\n---\n```\n\n## Best Practices\n\n### Do:\n- Keep documents focused and specific\n- Use clear, actionable language\n- Include concrete examples\n- Reference external specifications\n- Update regularly as project evolves\n- Use appropriate inclusion mechanisms\n\n### Don't:\n- Create overly broad or generic guidelines\n- Duplicate information across multiple documents\n- Include sensitive information or secrets\n- Create conflicting standards\n- Make documents too long or complex"
              },
              {
                "name": "design-documentation",
                "description": "Transform approved requirements into comprehensive technical designs. Define system architecture, component interactions, data models, and interfaces to create a blueprint for implementation.",
                "path": "skills/design-documentation/SKILL.md",
                "frontmatter": {
                  "name": "design-documentation",
                  "description": "Transform approved requirements into comprehensive technical designs. Define system architecture, component interactions, data models, and interfaces to create a blueprint for implementation.",
                  "license": "MIT",
                  "compatibility": "Claude Code, Cursor, VS Code, Windsurf",
                  "metadata": {
                    "category": "methodology",
                    "complexity": "intermediate",
                    "author": "Kiro Team",
                    "version": "1.0.0"
                  }
                },
                "content": "# Design Documentation\n\nCreate technical blueprints that bridge requirements and implementation. This skill teaches how to document architecture decisions, component design, and system interactions.\n\n## When to Use This Skill\n\nUse design documentation when:\n- Requirements phase is complete and approved\n- You need to plan technical implementation\n- Multiple developers will work on the feature\n- Architecture decisions need documentation\n- The feature involves complex integrations\n\n## Design Document Structure\n\n### Standard Template\n\n```markdown\n# Design Document: [Feature Name]\n\n## Overview\n[High-level summary of the feature and approach]\n\n## Architecture\n[System architecture and component overview]\n\n## Components and Interfaces\n[Detailed component descriptions and interactions]\n\n## Data Models\n[Data structures and relationships]\n\n## Error Handling\n[Error scenarios and response strategies]\n\n## Testing Strategy\n[Testing approach and quality assurance]\n```\n\n## Step-by-Step Process\n\n### Step 1: Requirements Analysis\n\nBefore designing, ensure you understand:\n- All functional requirements\n- Non-functional requirements (performance, security, scalability)\n- Constraints (technology stack, timeline, resources)\n- Integration points with existing systems\n\n**Analysis Questions:**\n- What does the system need to do?\n- What are the performance expectations?\n- What existing code/systems does this touch?\n- What are the security requirements?\n- What could go wrong?\n\n### Step 2: Research and Context Building\n\nIdentify areas needing research:\n- Technology choices and alternatives\n- Third-party integrations and APIs\n- Best practices for similar systems\n- Security and compliance considerations\n\n**Research Documentation:**\n```markdown\n## Research Findings\n\n### [Topic]\n**Sources:** [Links/references]\n**Key Insights:**\n- [Finding 1]\n- [Finding 2]\n**Impact on Design:** [How this affects our approach]\n```\n\n### Step 3: Define System Architecture\n\nDocument the high-level structure:\n\n```markdown\n## Architecture\n\n### System Overview\n[How the overall system works]\n\n### Component Architecture\n[Major components and their responsibilities]\n\n### Data Flow\n[How information moves through the system]\n\n### Technology Decisions\n[Key technology choices and rationale]\n```\n\n**Architecture Diagram (Mermaid):**\n```mermaid\ngraph TD\n    A[Client] --> B[API Gateway]\n    B --> C[Auth Service]\n    B --> D[Feature Service]\n    D --> E[Database]\n    D --> F[Cache]\n```\n\n### Step 4: Design Components and Interfaces\n\nFor each major component:\n\n```markdown\n## Components and Interfaces\n\n### [Component Name]\n**Purpose:** [What this component does]\n\n**Responsibilities:**\n- [Responsibility 1]\n- [Responsibility 2]\n\n**Interfaces:**\n- Input: [What it receives]\n- Output: [What it produces]\n- Dependencies: [What it requires]\n\n**API Definition:**\n```typescript\ninterface ComponentName {\n  method(input: InputType): Promise<OutputType>;\n}\n```\n```\n\n### Step 5: Define Data Models\n\nDocument all data structures:\n\n```markdown\n## Data Models\n\n### [Entity Name]\n**Purpose:** [What this entity represents]\n\n**Properties:**\n| Field | Type | Required | Description |\n|-------|------|----------|-------------|\n| id | string | Yes | Unique identifier |\n| name | string | Yes | Display name |\n| createdAt | Date | Yes | Creation timestamp |\n\n**Validation Rules:**\n- [Rule 1]\n- [Rule 2]\n\n**Relationships:**\n- [Relationship to other entities]\n\n**Example:**\n```json\n{\n  \"id\": \"abc123\",\n  \"name\": \"Example\",\n  \"createdAt\": \"2024-01-15T10:30:00Z\"\n}\n```\n```\n\n### Step 6: Plan Error Handling\n\nDocument error scenarios:\n\n```markdown\n## Error Handling\n\n### Error Categories\n1. **Validation Errors:** Invalid user input\n2. **Authentication Errors:** Unauthorized access\n3. **External Service Errors:** Third-party failures\n4. **System Errors:** Internal failures\n\n### Error Response Strategy\n\n| Error Type | HTTP Code | User Message | System Action |\n|------------|-----------|--------------|---------------|\n| Validation | 400 | Specific field error | Log, return details |\n| Auth | 401 | \"Please log in\" | Redirect to login |\n| Not Found | 404 | \"Resource not found\" | Log, return error |\n| Server | 500 | \"Something went wrong\" | Log, alert, retry |\n\n### Recovery Mechanisms\n- [Retry strategies]\n- [Fallback behaviors]\n- [Circuit breaker patterns]\n```\n\n### Step 7: Define Testing Strategy\n\n```markdown\n## Testing Strategy\n\n### Unit Testing\n- **Coverage Target:** 80%+\n- **Focus Areas:** [Critical business logic]\n- **Mocking Strategy:** [What to mock]\n\n### Integration Testing\n- **Scope:** [Component interactions to test]\n- **Environment:** [Test environment setup]\n- **Data Strategy:** [Test data approach]\n\n### End-to-End Testing\n- **Critical Paths:** [User journeys to test]\n- **Tools:** [Testing tools]\n\n### Performance Testing\n- **Load Targets:** [Expected load]\n- **Benchmarks:** [Performance requirements]\n```\n\n## Decision Documentation\n\nDocument key decisions using this template:\n\n```markdown\n### Decision: [Brief Title]\n\n**Context:** [Situation requiring a decision]\n\n**Options Considered:**\n\n**Option 1: [Name]**\n- Pros: [Benefits]\n- Cons: [Drawbacks]\n- Effort: [Low/Medium/High]\n\n**Option 2: [Name]**\n- Pros: [Benefits]\n- Cons: [Drawbacks]\n- Effort: [Low/Medium/High]\n\n**Decision:** [Chosen option]\n\n**Rationale:** [Why this option was selected]\n\n**Implications:** [What this means for implementation]\n```\n\n## Common Design Decisions\n\n### API Design\n```markdown\n### Decision: API Architecture\n\n**Options:**\n1. **REST API** - Standard HTTP methods, well-understood\n2. **GraphQL** - Flexible queries, single endpoint\n3. **RPC-style** - Direct operation mapping\n\n**Decision:** REST API\n**Rationale:** Standard CRUD operations, team familiarity, good tooling support\n```\n\n### Data Storage\n```markdown\n### Decision: Database Choice\n\n**Options:**\n1. **PostgreSQL** - ACID compliance, complex queries\n2. **MongoDB** - Schema flexibility, horizontal scaling\n3. **Redis** - High performance, limited queries\n\n**Decision:** PostgreSQL with JSON columns\n**Rationale:** Data consistency needs + flexibility for user preferences\n```\n\n### Authentication\n```markdown\n### Decision: Authentication Strategy\n\n**Options:**\n1. **Session-based** - Server-controlled, simple\n2. **JWT tokens** - Stateless, scalable\n3. **OAuth 2.0** - External provider, no password management\n\n**Decision:** JWT with refresh token rotation\n**Rationale:** Scalability requirements, API-first architecture\n```\n\n## Quality Checklist\n\nBefore finalizing design:\n\n**Completeness:**\n- [ ] All requirements addressed in design\n- [ ] Major system components defined\n- [ ] Data models cover all entities\n- [ ] Error handling covers expected failures\n- [ ] Testing strategy addresses all layers\n\n**Clarity:**\n- [ ] Design decisions clearly explained\n- [ ] Component responsibilities well-defined\n- [ ] Interfaces between components specified\n- [ ] Technical choices include rationale\n\n**Feasibility:**\n- [ ] Design is technically achievable\n- [ ] Performance requirements can be met\n- [ ] Security requirements addressed\n- [ ] Implementation complexity reasonable\n\n**Traceability:**\n- [ ] Design elements map to requirements\n- [ ] All requirements covered by design\n- [ ] Testing validates requirement fulfillment\n\n## Common Pitfalls\n\n1. **Over-Engineering:** Design for current requirements, not hypothetical futures\n2. **Under-Specified Interfaces:** Define clear component boundaries\n3. **Ignoring Non-Functional Requirements:** Address performance, security, scalability\n4. **Technology-First Design:** Let requirements drive technology choices\n5. **Insufficient Error Handling:** Plan for failures, not just happy paths\n\n## Example: User Profile Design\n\n```markdown\n# Design Document: User Profile Management\n\n## Overview\nEnable users to view and edit their profile information, including personal details, preferences, and profile picture.\n\n## Architecture\n\n### Component Architecture\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Client    â”‚â”€â”€â”€â”€â–¶â”‚  Profile API â”‚â”€â”€â”€â”€â–¶â”‚  Database   â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                           â”‚\n                           â–¼\n                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                    â”‚ Image Store  â”‚\n                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Technology Stack\n- API: Node.js with Express\n- Database: PostgreSQL\n- Image Storage: S3-compatible object storage\n- Cache: Redis for session data\n\n## Components\n\n### ProfileService\n**Purpose:** Manage user profile CRUD operations\n\n**Interface:**\n```typescript\ninterface ProfileService {\n  getProfile(userId: string): Promise<UserProfile>;\n  updateProfile(userId: string, data: ProfileUpdate): Promise<UserProfile>;\n  uploadAvatar(userId: string, image: File): Promise<string>;\n  deleteAvatar(userId: string): Promise<void>;\n}\n```\n\n## Data Models\n\n### UserProfile\n| Field | Type | Required | Validation |\n|-------|------|----------|------------|\n| id | UUID | Yes | Auto-generated |\n| email | string | Yes | Valid email format |\n| displayName | string | Yes | 2-50 characters |\n| bio | string | No | Max 500 characters |\n| avatarUrl | string | No | Valid URL |\n| preferences | JSON | No | Valid JSON object |\n| updatedAt | timestamp | Yes | Auto-updated |\n\n## Error Handling\n\n| Scenario | Response | Action |\n|----------|----------|--------|\n| Profile not found | 404 | Return error message |\n| Invalid update data | 400 | Return validation errors |\n| Image too large | 413 | Return size limit error |\n| Unauthorized | 401 | Redirect to login |\n\n## Testing Strategy\n- Unit tests for validation logic\n- Integration tests for API endpoints\n- E2E test for profile edit flow\n```\n\n## Next Steps\n\nAfter completing design:\n1. Get design review and approval\n2. Move to Task Planning phase\n3. Break design into implementation tasks\n4. Begin systematic implementation"
              },
              {
                "name": "quality-assurance",
                "description": "Comprehensive testing and validation strategies for spec-driven development. Learn phase-specific validation techniques, quality gates, and testing approaches to ensure high-quality implementation.",
                "path": "skills/quality-assurance/SKILL.md",
                "frontmatter": {
                  "name": "quality-assurance",
                  "description": "Comprehensive testing and validation strategies for spec-driven development. Learn phase-specific validation techniques, quality gates, and testing approaches to ensure high-quality implementation.",
                  "license": "MIT",
                  "compatibility": "Claude Code, Cursor, VS Code, Windsurf",
                  "metadata": {
                    "category": "methodology",
                    "complexity": "intermediate",
                    "author": "Kiro Team",
                    "version": "1.0.0"
                  }
                },
                "content": "# Quality Assurance\n\nEnsure quality throughout the spec-driven development process with validation techniques, quality gates, and testing strategies.\n\n## When to Use This Skill\n\nUse quality assurance practices when:\n- Completing any spec phase (requirements, design, tasks)\n- Transitioning between phases\n- Implementing features from specs\n- Reviewing completed work\n- Establishing team quality standards\n\n## Core Principles\n\n1. **Requirements-Driven Testing:** Every test traces to a requirement\n2. **Phase-Appropriate Validation:** Different techniques for each phase\n3. **Continuous Quality:** Checks throughout development\n4. **Automated Where Possible:** Reduce manual effort\n5. **Fast Feedback:** Catch issues early\n\n## Phase-Specific Validation\n\n### Requirements Phase Validation\n\n**Quality Checklist:**\n- [ ] All user stories have acceptance criteria\n- [ ] Requirements are unambiguous and specific\n- [ ] Each requirement can be validated/tested\n- [ ] EARS format used consistently\n- [ ] Requirements link to business objectives\n- [ ] No conflicting requirements\n\n**Review Process:**\n1. **Self Review:** Author checks completeness\n2. **Stakeholder Review:** Business validates requirements\n3. **Technical Review:** Team assesses feasibility\n4. **Approval:** Formal sign-off before design\n\n**Validation Techniques:**\n- **Scenario Walkthroughs:** Step through user journeys\n- **Edge Case Analysis:** Identify boundary conditions\n- **Conflict Detection:** Check for contradictions\n- **Completeness Analysis:** Ensure all needs covered\n\n### Design Phase Validation\n\n**Quality Checklist:**\n- [ ] Design addresses all requirements\n- [ ] Scalability considerations documented\n- [ ] Maintainability assessed\n- [ ] Security addressed\n- [ ] Performance requirements considered\n- [ ] External integrations defined\n\n**Review Process:**\n1. **Architecture Review:** Senior team validates design\n2. **Security Review:** Security implications assessed\n3. **Performance Review:** Performance characteristics evaluated\n4. **Integration Review:** External dependencies validated\n\n**Validation Techniques:**\n- **Design Walkthroughs:** Step through system interactions\n- **Threat Modeling:** Identify security vulnerabilities\n- **Performance Modeling:** Estimate system performance\n- **Dependency Analysis:** Map external requirements\n\n### Tasks Phase Validation\n\n**Quality Checklist:**\n- [ ] Each task has clear deliverables\n- [ ] Task sequence is logical\n- [ ] All design elements covered\n- [ ] Each task can be validated\n- [ ] Tasks appropriately sized (2-4 hours)\n- [ ] Dependencies clearly defined\n\n**Review Process:**\n1. **Completeness Review:** All design elements have tasks\n2. **Sequencing Review:** Task order is logical\n3. **Scope Review:** Tasks are appropriately sized\n4. **Dependency Review:** Dependencies clear\n\n## Quality Gates\n\n### Requirements Phase Exit Criteria\n- [ ] All user stories follow proper format\n- [ ] Acceptance criteria use EARS format\n- [ ] Requirements are testable and measurable\n- [ ] No conflicting requirements\n- [ ] Stakeholders have approved\n- [ ] Edge cases documented\n\n### Design Phase Exit Criteria\n- [ ] Architecture addresses all requirements\n- [ ] Non-functional requirements addressed\n- [ ] External dependencies identified\n- [ ] Data models clearly defined\n- [ ] Error handling documented\n- [ ] Security considerations addressed\n- [ ] Technical review completed\n\n### Tasks Phase Exit Criteria\n- [ ] All design elements have tasks\n- [ ] Tasks properly sequenced\n- [ ] Each task is actionable\n- [ ] Requirements references included\n- [ ] Test approach defined\n- [ ] Task breakdown reviewed\n\n### Task-Level Quality Gates\n\n**Before Starting:**\n- [ ] Task requirements understood\n- [ ] Test strategy defined\n- [ ] Dependencies available\n- [ ] Environment ready\n\n**During Implementation:**\n- [ ] Code follows standards\n- [ ] Tests written alongside code\n- [ ] Coverage meets thresholds (80%+)\n- [ ] No critical vulnerabilities\n\n**Before Marking Complete:**\n- [ ] All tests pass\n- [ ] Code review completed\n- [ ] Documentation updated\n- [ ] Requirements validated\n\n## Testing Strategies\n\n### Test Pyramid\n\n```\n       /\\\n      /  \\     E2E Tests (10%)\n     /____\\    Integration Tests (20%)\n    /      \\\n   /________\\   Unit Tests (70%)\n```\n\n### Unit Testing\n- Fast execution (< 1 second per test)\n- Test individual functions/classes\n- Mock external dependencies\n- Target 80%+ coverage\n\n### Integration Testing\n- Test component interactions\n- Use real dependencies where practical\n- Validate API contracts\n- Test critical workflows\n\n### End-to-End Testing\n- Test complete user journeys\n- Production-like environment\n- Focus on critical business flows\n- Minimal but comprehensive\n\n### Test-Driven Development\n\nFor each task:\n1. **Write tests first** based on acceptance criteria\n2. **Run tests** - verify they fail (red)\n3. **Write code** - minimal to pass tests (green)\n4. **Refactor** - improve while keeping tests green\n5. **Validate** - ensure requirements satisfied\n\n## Quality Metrics\n\n### Code Quality\n- **Line Coverage:** % of code lines executed\n- **Branch Coverage:** % of code branches tested\n- **Cyclomatic Complexity:** Code complexity\n- **Technical Debt:** Accumulated issues\n\n### Testing Effectiveness\n- **Test Pass Rate:** % of tests passing\n- **Execution Time:** Time to run tests\n- **Defect Detection Rate:** Bugs found by tests vs production\n- **Test Maintenance:** Time spent maintaining tests\n\n## Common Quality Issues\n\n### Flaky Tests\n**Symptoms:** Tests pass/fail inconsistently\n**Solutions:**\n- Identify timing dependencies\n- Use proper wait conditions\n- Isolate test data\n- Fix race conditions\n\n### Slow Test Suites\n**Symptoms:** Tests take too long\n**Solutions:**\n- Parallelize execution\n- Optimize database operations\n- Use test doubles for external services\n- Profile and optimize slow tests\n\n### Low Coverage\n**Symptoms:** Insufficient code coverage\n**Solutions:**\n- Add tests for uncovered paths\n- Focus on critical business logic\n- Use mutation testing\n- Set coverage gates in CI\n\n### Test Maintenance Burden\n**Symptoms:** Tests require frequent updates\n**Solutions:**\n- Improve test design\n- Use page object patterns for UI\n- Reduce coupling to implementation\n- Regular test refactoring\n\n## Validation Checklists\n\n### Requirements Validation\n```markdown\n## Requirements Review\n\n**Completeness:**\n- [ ] All user roles addressed\n- [ ] Happy path scenarios covered\n- [ ] Edge cases documented\n- [ ] Error cases handled\n- [ ] Business rules captured\n\n**Clarity:**\n- [ ] Precise language used\n- [ ] No ambiguous terms\n- [ ] Technical jargon avoided\n- [ ] Behaviors are specific\n\n**Testability:**\n- [ ] Each requirement verifiable\n- [ ] Success criteria observable\n- [ ] Inputs/outputs specified\n```\n\n### Design Validation\n```markdown\n## Design Review\n\n**Architecture:**\n- [ ] Requirements addressed\n- [ ] Components well-defined\n- [ ] Interfaces specified\n- [ ] Data flow documented\n\n**Quality Attributes:**\n- [ ] Performance considered\n- [ ] Security addressed\n- [ ] Scalability planned\n- [ ] Maintainability assessed\n\n**Risks:**\n- [ ] Single points of failure identified\n- [ ] Bottlenecks documented\n- [ ] Mitigations planned\n```\n\n### Implementation Validation\n```markdown\n## Implementation Review\n\n**Code Quality:**\n- [ ] Follows standards\n- [ ] Well-documented\n- [ ] Tests included\n- [ ] No security issues\n\n**Requirements:**\n- [ ] All criteria met\n- [ ] Edge cases handled\n- [ ] Error handling complete\n\n**Integration:**\n- [ ] Works with existing code\n- [ ] APIs functioning\n- [ ] Performance acceptable\n```\n\n## Best Practices\n\n### Testing Best Practices\n1. Write tests first when possible\n2. Each test verifies one thing\n3. Use descriptive test names\n4. Maintain test independence\n5. Keep tests up-to-date\n\n### Quality Assurance Best Practices\n1. Find issues early (shift left)\n2. Automate everything possible\n3. Use metrics to drive improvements\n4. Make quality everyone's responsibility\n5. Continuous learning and improvement\n\n### Process Integration\n1. Link tests to requirements\n2. Provide quick feedback\n3. Focus testing on high-risk areas\n4. Keep documentation current\n5. Integrate tools with workflow\n\n## Quick Reference\n\n**Phase Transition Questions:**\n- Requirements â†’ Design: \"Does design address all requirements?\"\n- Design â†’ Tasks: \"Do tasks cover all design elements?\"\n- Tasks â†’ Implementation: \"Does code satisfy task specifications?\"\n\n**Quality Gate Questions:**\n- \"Is this testable and measurable?\"\n- \"Have we considered what could go wrong?\"\n- \"Would another developer understand this?\"\n- \"Does this meet our standards?\""
              },
              {
                "name": "requirements-engineering",
                "description": "Transform vague feature ideas into clear, testable requirements using EARS format. Capture user stories, define acceptance criteria, identify edge cases, and validate completeness before moving to design.",
                "path": "skills/requirements-engineering/SKILL.md",
                "frontmatter": {
                  "name": "requirements-engineering",
                  "description": "Transform vague feature ideas into clear, testable requirements using EARS format. Capture user stories, define acceptance criteria, identify edge cases, and validate completeness before moving to design.",
                  "license": "MIT",
                  "compatibility": "Claude Code, Cursor, VS Code, Windsurf",
                  "metadata": {
                    "category": "methodology",
                    "complexity": "beginner",
                    "author": "Kiro Team",
                    "version": "1.0.0"
                  }
                },
                "content": "# Requirements Engineering\n\nMaster the art of capturing what needs to be built before diving into how to build it. This skill teaches the EARS (Easy Approach to Requirements Syntax) format for creating clear, testable requirements.\n\n## When to Use This Skill\n\nUse requirements engineering when:\n- Starting any new feature or project\n- Clarifying ambiguous stakeholder requests\n- Creating acceptance criteria for user stories\n- Documenting system behavior for testing\n- Ensuring all team members share understanding\n\n## The EARS Format\n\nEARS provides consistent patterns for writing requirements that are specific, testable, and unambiguous.\n\n### Basic Patterns\n\n**Event-Response (Most Common):**\n```\nWHEN [triggering event] THEN [system] SHALL [required response]\n```\n\n**Conditional Behavior:**\n```\nIF [precondition is met] THEN [system] SHALL [required response]\n```\n\n**Complex Conditions:**\n```\nWHEN [event] AND [additional condition] THEN [system] SHALL [response]\n```\n\n**Optional Conditions:**\n```\nWHEN [event] OR [alternative event] THEN [system] SHALL [response]\n```\n\n### Advanced Patterns\n\n**State-Based:**\n```\nWHEN [system is in specific state] THEN [system] SHALL [behavior]\n```\n\n**Performance:**\n```\nWHEN [user action] THEN [system] SHALL [respond within X seconds/milliseconds]\n```\n\n**Security:**\n```\nIF [authentication condition] THEN [system] SHALL [security response]\n```\n\n## Step-by-Step Process\n\n### Step 1: Capture User Stories\n\nFormat: **As a [role], I want [feature], so that [benefit]**\n\nFocus on:\n- Who is the user? (role)\n- What do they want to accomplish? (feature)\n- Why does it matter? (benefit/value)\n\n**Example:**\n```markdown\nAs a returning customer, I want to save my payment methods, so that I can checkout faster in the future.\n```\n\n### Step 2: Generate Acceptance Criteria\n\nFor each user story, define specific acceptance criteria using EARS:\n\n**Example for payment methods:**\n```markdown\n**User Story:** As a returning customer, I want to save my payment methods, so that I can checkout faster.\n\n**Acceptance Criteria:**\n1. WHEN user adds a valid credit card THEN system SHALL securely store card details\n2. WHEN user adds a card with invalid number THEN system SHALL display validation error\n3. WHEN user has saved cards THEN system SHALL display list during checkout\n4. WHEN user selects saved card THEN system SHALL pre-fill payment form\n5. WHEN user deletes saved card THEN system SHALL remove card from list\n6. IF user is not authenticated THEN system SHALL redirect to login before saving card\n7. WHEN user adds card THEN system SHALL mask all but last 4 digits in display\n```\n\n### Step 3: Identify Edge Cases\n\nFor each requirement, ask:\n- What if the input is empty/null?\n- What if the input is at boundary values?\n- What if the operation fails?\n- What if the user is not authorized?\n- What if there are concurrent operations?\n\n**Edge case patterns:**\n```markdown\n**Error Handling:**\n- WHEN [operation fails] THEN system SHALL [display error / retry / log]\n\n**Boundary Conditions:**\n- WHEN [value equals minimum/maximum] THEN system SHALL [specific behavior]\n\n**Concurrent Access:**\n- WHEN [multiple users access same resource] THEN system SHALL [conflict resolution]\n\n**Empty States:**\n- WHEN [collection is empty] THEN system SHALL [display empty state message]\n```\n\n### Step 4: Validate Requirements\n\nUse this checklist:\n\n**Completeness:**\n- [ ] All user roles identified and addressed\n- [ ] Normal flow scenarios covered\n- [ ] Edge cases documented\n- [ ] Error cases handled\n- [ ] Business rules captured\n\n**Clarity:**\n- [ ] Each requirement uses precise language\n- [ ] No ambiguous terms (fast, easy, user-friendly)\n- [ ] Technical jargon avoided or defined\n- [ ] Expected behaviors are specific\n\n**Consistency:**\n- [ ] EARS format used throughout\n- [ ] Terminology consistent across requirements\n- [ ] No contradictory requirements\n- [ ] Similar scenarios handled similarly\n\n**Testability:**\n- [ ] Each requirement can be verified\n- [ ] Success criteria are observable\n- [ ] Inputs and expected outputs specified\n- [ ] Performance requirements are measurable\n\n## Common Mistakes to Avoid\n\n### Mistake 1: Vague Requirements\n**Bad:** \"System should be fast\"\n**Good:** \"WHEN user submits search THEN system SHALL return results within 2 seconds\"\n\n### Mistake 2: Implementation Details\n**Bad:** \"System shall use Redis for caching\"\n**Good:** \"WHEN user requests frequently accessed data THEN system SHALL return cached results\"\n\n### Mistake 3: Missing Error Cases\n**Bad:** Only documenting happy path\n**Good:** Include WHEN/IF statements for all error conditions\n\n### Mistake 4: Untestable Requirements\n**Bad:** \"System should be user-friendly\"\n**Good:** \"WHEN new user completes onboarding THEN system SHALL require no more than 3 clicks to reach main dashboard\"\n\n### Mistake 5: Conflicting Requirements\n**Bad:** Requirements that contradict each other\n**Good:** Review all requirements together, resolve conflicts explicitly\n\n## Examples\n\n### Example 1: File Upload Feature\n\n```markdown\n**User Story:** As a user, I want to upload files, so that I can share documents with my team.\n\n**Acceptance Criteria:**\n1. WHEN user selects file under 10MB THEN system SHALL accept file for upload\n2. WHEN user selects file over 10MB THEN system SHALL display \"file too large (max 10MB)\" error\n3. WHEN user selects unsupported file type THEN system SHALL display \"unsupported format\" error with list of allowed types\n4. WHEN upload is in progress THEN system SHALL display progress indicator with percentage\n5. WHEN upload completes successfully THEN system SHALL display success message with file link\n6. WHEN upload fails due to network error THEN system SHALL display retry option\n7. IF user is not authenticated THEN system SHALL redirect to login before upload\n8. WHEN user uploads file with same name as existing file THEN system SHALL prompt for rename or replace\n\n**Supported File Types:** PDF, DOC, DOCX, XLS, XLSX, PNG, JPG, GIF\n**Maximum File Size:** 10MB\n**Maximum Files Per Upload:** 5\n```\n\n### Example 2: Search Feature\n\n```markdown\n**User Story:** As a customer, I want to search products, so that I can find items quickly.\n\n**Acceptance Criteria:**\n1. WHEN user enters search term THEN system SHALL display matching products\n2. WHEN search returns results THEN system SHALL show result count\n3. WHEN search returns no results THEN system SHALL display \"no products found\" with suggestions\n4. WHEN user searches with special characters THEN system SHALL sanitize input and search\n5. WHEN user submits empty search THEN system SHALL display validation message\n6. WHEN results exceed 20 items THEN system SHALL paginate with 20 items per page\n7. WHEN user searches THEN system SHALL return results within 2 seconds\n8. WHEN user types in search box THEN system SHALL show autocomplete suggestions after 3 characters\n\n**Search Fields:** Product name, description, category, SKU\n**Minimum Search Length:** 2 characters\n```\n\n## Requirements Document Template\n\n```markdown\n# Requirements Document: [Feature Name]\n\n## Overview\n[Brief description of the feature and its purpose]\n\n## User Roles\n- [Role 1]: [Description of this user type]\n- [Role 2]: [Description of this user type]\n\n## Requirements\n\n### Requirement 1: [Name]\n**User Story:** As a [role], I want [feature], so that [benefit]\n\n**Acceptance Criteria:**\n1. WHEN [event] THEN system SHALL [response]\n2. IF [condition] THEN system SHALL [response]\n3. WHEN [event] AND [condition] THEN system SHALL [response]\n\n**Edge Cases:**\n- [Edge case 1 and how it's handled]\n- [Edge case 2 and how it's handled]\n\n### Requirement 2: [Name]\n[Continue pattern...]\n\n## Non-Functional Requirements\n- **Performance:** [Specific metrics]\n- **Security:** [Security requirements]\n- **Accessibility:** [Accessibility standards]\n\n## Out of Scope\n- [Items explicitly not included in this feature]\n\n## Open Questions\n- [Questions that need stakeholder input]\n```\n\n## Next Steps\n\nAfter completing requirements:\n1. Review with stakeholders for accuracy\n2. Get explicit approval before proceeding\n3. Move to Design Phase to create technical architecture\n4. Use requirements as foundation for acceptance testing"
              },
              {
                "name": "spec-driven-development",
                "description": "Systematic three-phase approach to feature development using Requirements, Design, and Tasks phases. Transforms vague feature ideas into well-defined, implementable solutions that reduce ambiguity, improve quality, and enable effective AI collaboration.",
                "path": "skills/spec-driven-development/SKILL.md",
                "frontmatter": {
                  "name": "spec-driven-development",
                  "description": "Systematic three-phase approach to feature development using Requirements, Design, and Tasks phases. Transforms vague feature ideas into well-defined, implementable solutions that reduce ambiguity, improve quality, and enable effective AI collaboration.",
                  "license": "MIT",
                  "compatibility": "Claude Code, Cursor, VS Code, Windsurf",
                  "metadata": {
                    "category": "methodology",
                    "complexity": "intermediate",
                    "author": "Kiro Team",
                    "version": "1.0.0"
                  }
                },
                "content": "# Spec-Driven Development\n\nA comprehensive methodology for systematic software feature development that ensures quality, maintainability, and successful delivery through structured planning.\n\n## When to Use This Skill\n\n**Ideal scenarios:**\n- Complex features with multiple components, integrations, or user interactions\n- High-stakes projects where rework costs are significant\n- Team collaboration requiring shared understanding\n- AI-assisted development where clear structure improves output quality\n- Knowledge preservation for future maintainers\n\n**Less suitable:**\n- Simple bug fixes with obvious solutions\n- Experimental prototypes for rapid iteration\n- Time-critical hotfixes requiring immediate action\n- Well-established patterns with minimal ambiguity\n\n## The Three-Phase Workflow\n\n### Phase 1: Requirements Gathering\n\n**Purpose:** Transform vague feature ideas into clear, testable requirements\n\n**Process:**\n1. Capture user stories expressing value and purpose\n2. Define acceptance criteria using EARS format (Easy Approach to Requirements Syntax)\n3. Identify edge cases and constraints\n4. Validate completeness and feasibility\n\n**EARS Format Patterns:**\n```\nWHEN [event] THEN [system] SHALL [response]\nIF [precondition] THEN [system] SHALL [response]\nWHEN [event] AND [condition] THEN [system] SHALL [response]\n```\n\n**Example:**\n```markdown\n**User Story:** As a new user, I want to create an account, so that I can access personalized features.\n\n**Acceptance Criteria:**\n1. WHEN user provides valid email and password THEN system SHALL create new account\n2. WHEN user provides existing email THEN system SHALL display \"email already registered\" error\n3. WHEN user provides password shorter than 8 characters THEN system SHALL display \"password too short\" error\n4. WHEN account creation succeeds THEN system SHALL send confirmation email\n```\n\n### Phase 2: Design Documentation\n\n**Purpose:** Create a comprehensive technical plan for implementation\n\n**Process:**\n1. Research technical approaches and constraints\n2. Define system architecture and component interactions\n3. Specify data models and interfaces\n4. Plan error handling and testing strategies\n\n**Design Document Structure:**\n```markdown\n## Overview\n[High-level summary of approach]\n\n## Architecture\n[System components and their relationships]\n\n## Components and Interfaces\n[Detailed component descriptions]\n\n## Data Models\n[Data structures and validation rules]\n\n## Error Handling\n[Error scenarios and response strategies]\n\n## Testing Strategy\n[Testing approach for different layers]\n```\n\n**Decision Documentation:**\n```markdown\n### Decision: [Title]\n**Context:** [Situation requiring decision]\n**Options Considered:**\n1. [Option 1] - Pros: [benefits] / Cons: [drawbacks]\n2. [Option 2] - Pros: [benefits] / Cons: [drawbacks]\n**Decision:** [Chosen option]\n**Rationale:** [Why this was selected]\n```\n\n### Phase 3: Task Planning\n\n**Purpose:** Break design into actionable, sequential implementation steps\n\n**Process:**\n1. Convert design elements into specific coding tasks\n2. Sequence tasks to enable incremental progress\n3. Define clear objectives and completion criteria\n4. Reference requirements for traceability\n\n**Task Structure:**\n```markdown\n- [ ] 1. [Epic/Major Component]\n- [ ] 1.1 [Specific implementation task]\n  - [Implementation details]\n  - [Files/components to create]\n  - _Requirements: [Requirement references]_\n```\n\n**Task Sequencing Strategies:**\n- **Foundation-First:** Core interfaces before dependent components\n- **Feature-Slice:** End-to-end vertical slices for early validation\n- **Risk-First:** Tackle uncertain areas early\n- **Hybrid:** Combine approaches based on project needs\n\n## Quality Checklists\n\n### Requirements Checklist\n- [ ] All user roles identified and addressed\n- [ ] Normal, edge, and error cases covered\n- [ ] Requirements are testable and measurable\n- [ ] No conflicting requirements\n- [ ] EARS format used consistently\n\n### Design Checklist\n- [ ] All requirements addressed in design\n- [ ] Component responsibilities well-defined\n- [ ] Interfaces between components specified\n- [ ] Error handling covers expected failures\n- [ ] Security considerations addressed\n\n### Tasks Checklist\n- [ ] All design components have implementation tasks\n- [ ] Tasks ordered to respect dependencies\n- [ ] Each task produces testable code\n- [ ] Requirements references included\n- [ ] Scope is appropriate (2-4 hours each)\n\n## Integration with AI Workflows\n\n**For Claude Code / AI Assistants:**\n\n1. **Start with context:** Provide project background, constraints, and goals\n2. **Work in phases:** Complete requirements before design, design before tasks\n3. **Iterate:** Refine outputs through conversation rather than single requests\n4. **Validate:** Ask AI to review outputs against checklists\n5. **Trace:** Maintain links between requirements, design, and tasks\n\n**Example prompt for starting a spec:**\n```\nI'm working on [project context]. We need to add [feature description].\n\nContext:\n- Technology: [stack]\n- Users: [target audience]\n- Constraints: [key limitations]\n\nPlease help me develop requirements using the EARS format, starting with user stories and acceptance criteria.\n```\n\n## Common Pitfalls to Avoid\n\n1. **Skipping phases:** Each phase builds on the previous; shortcuts create problems\n2. **Vague requirements:** \"System should be fast\" vs specific, measurable criteria\n3. **Implementation details in requirements:** Focus on what, not how\n4. **Over-engineering design:** Solve current requirements, not hypothetical future ones\n5. **Monolithic tasks:** Break down into 2-4 hour increments\n6. **Missing error cases:** Always consider what happens when things go wrong\n\n## Next Steps\n\nAfter completing a spec:\n1. Begin implementation following task sequence\n2. Track progress by marking tasks complete\n3. Update spec if implementation reveals gaps\n4. Validate completed work against requirements\n5. Document learnings for future specs"
              },
              {
                "name": "task-breakdown",
                "description": "Convert technical designs into actionable, sequenced implementation tasks. Create clear coding tasks that enable incremental progress, respect dependencies, and provide a roadmap for systematic feature development.",
                "path": "skills/task-breakdown/SKILL.md",
                "frontmatter": {
                  "name": "task-breakdown",
                  "description": "Convert technical designs into actionable, sequenced implementation tasks. Create clear coding tasks that enable incremental progress, respect dependencies, and provide a roadmap for systematic feature development.",
                  "license": "MIT",
                  "compatibility": "Claude Code, Cursor, VS Code, Windsurf",
                  "metadata": {
                    "category": "methodology",
                    "complexity": "intermediate",
                    "author": "Kiro Team",
                    "version": "1.0.0"
                  }
                },
                "content": "# Task Breakdown\n\nTransform designs into actionable implementation plans. This skill teaches how to create well-structured task lists that enable efficient, systematic development.\n\n## When to Use This Skill\n\nUse task breakdown when:\n- Design phase is complete and approved\n- Ready to begin implementation\n- Need to coordinate work across developers\n- Want to track incremental progress\n- Planning sprints or work assignments\n\n## Task Structure\n\n### Two-Level Hierarchy\n\n```markdown\n- [ ] 1. [Epic/Major Component]\n- [ ] 1.1 [Specific implementation task]\n  - [Implementation details]\n  - [Files/components to create]\n  - _Requirements: [Requirement references]_\n- [ ] 1.2 [Next specific task]\n  - [Details]\n  - _Requirements: [References]_\n\n- [ ] 2. [Next Epic/Major Component]\n- [ ] 2.1 [Specific task]\n```\n\n### Task Specification Elements\n\nEach task should include:\n1. **Clear Objective:** What specific code to write/modify\n2. **Implementation Details:** Files, components, functions\n3. **Requirements Reference:** Which requirements this implements\n4. **Completion Criteria:** How to know the task is done\n\n## Step-by-Step Process\n\n### Step 1: Analyze Design Components\n\nIdentify all implementation needs:\n- Data models and validation\n- Services and business logic\n- API endpoints and handlers\n- UI components\n- Tests for each layer\n- Integration points\n\n### Step 2: Identify Dependencies\n\nMap what needs to be built first:\n- **Technical:** Code dependencies (models before services)\n- **Logical:** Feature dependencies (login before profile)\n- **Data:** What data must exist first\n\n### Step 3: Sequence Tasks\n\nOrder tasks to:\n- Respect dependencies\n- Enable early validation\n- Allow incremental testing\n- Minimize blocking between tasks\n\n### Step 4: Write Task Descriptions\n\nFor each task, specify:\n```markdown\n- [ ] X.Y [Task Title]\n  - [What to implement]\n  - [Files to create/modify]\n  - [Key functionality]\n  - [Tests to write]\n  - _Requirements: [Req-1, Req-2]_\n```\n\n## Sequencing Strategies\n\n### Strategy 1: Foundation-First\n\nBuild core infrastructure before features.\n\n```markdown\n1. Project setup and core interfaces\n2. Data models and validation\n3. Data access layer\n4. Business logic services\n5. API endpoints\n6. Integration and wiring\n```\n\n**Best for:** New projects, complex systems\n\n### Strategy 2: Feature-Slice (Vertical)\n\nBuild complete features end-to-end.\n\n```markdown\n1. User registration (complete flow)\n2. User authentication (complete flow)\n3. User profile management (complete flow)\n4. Advanced features\n```\n\n**Best for:** MVP development, early validation\n\n### Strategy 3: Risk-First\n\nTackle uncertain areas early.\n\n```markdown\n1. Most complex/uncertain components\n2. External integrations\n3. Core business logic\n4. User interface\n5. Polish and optimization\n```\n\n**Best for:** High uncertainty, proof-of-concepts\n\n### Strategy 4: Hybrid (Recommended)\n\nCombine approaches pragmatically.\n\n```markdown\n1. Minimal foundation (core interfaces)\n2. High-risk/high-value feature slice\n3. Expand foundation as needed\n4. Additional feature slices\n5. Integration and polish\n```\n\n## Task Categories\n\n### Foundation Tasks\n```markdown\n- [ ] 1. Set up project foundation\n- [ ] 1.1 Create project structure and interfaces\n  - Set up directory structure\n  - Define TypeScript interfaces for core types\n  - Configure testing framework\n  - _Requirements: 1.1_\n```\n\n### Data Layer Tasks\n```markdown\n- [ ] 2. Implement data layer\n- [ ] 2.1 Create core data models\n  - Implement User model with validation\n  - Add database migrations\n  - Write unit tests for validation\n  - _Requirements: 2.1, 2.2_\n```\n\n### Business Logic Tasks\n```markdown\n- [ ] 3. Implement business logic\n- [ ] 3.1 Create authentication service\n  - Implement registration logic\n  - Add password hashing\n  - Create session management\n  - Write unit tests\n  - _Requirements: 1.2, 4.1_\n```\n\n### API Tasks\n```markdown\n- [ ] 4. Implement API layer\n- [ ] 4.1 Create user endpoints\n  - Implement POST /users endpoint\n  - Add request validation\n  - Write integration tests\n  - _Requirements: 1.2, 2.3_\n```\n\n### Integration Tasks\n```markdown\n- [ ] 5. Integration and testing\n- [ ] 5.1 Wire up components\n  - Connect services to API layer\n  - Implement middleware\n  - Add end-to-end tests\n  - _Requirements: 5.1_\n```\n\n## Writing Effective Tasks\n\n### Good Task Example\n```markdown\n- [ ] 2.1 Create User model with validation\n  - Implement User class with email, password, name fields\n  - Add email validation (RFC 5322 format)\n  - Add password validation (8+ chars, mixed case, numbers)\n  - Write unit tests for valid/invalid scenarios\n  - _Requirements: 1.2, 2.1_\n```\n\n### Poor Task Example\n```markdown\n- [ ] 2.1 Build user stuff\n  - Make user things work\n  - _Requirements: 1.2_\n```\n\n### Task Scope Guidelines\n\n**Appropriate:** 2-4 hours of focused work\n\n**Too Large:**\n```markdown\n- [ ] 1.1 Implement complete user management system\n```\n\n**Too Small:**\n```markdown\n- [ ] 1.1 Add semicolon to line 42\n```\n\n**Just Right:**\n```markdown\n- [ ] 1.1 Create User model with validation methods\n```\n\n## Dependency Management\n\n### Types of Dependencies\n\n**Technical Dependencies:**\n```markdown\n- [ ] 1.1 Create database connection â† Foundation\n- [ ] 2.1 Create User model â† Depends on 1.1\n- [ ] 3.1 Create UserService â† Depends on 2.1\n```\n\n**Logical Dependencies:**\n```markdown\n- [ ] 1.1 User registration â† Must exist first\n- [ ] 2.1 User login â† Depends on 1.1\n- [ ] 3.1 Password reset â† Depends on 2.1\n```\n\n### Handling Circular Dependencies\n\n**Problem:**\n```\nUserService needs AuthService\nAuthService needs UserService\n```\n\n**Solution - Interface Extraction:**\n```markdown\n- [ ] 1.1 Create IUserService and IAuthService interfaces\n- [ ] 1.2 Implement UserService using IAuthService\n- [ ] 1.3 Implement AuthService using IUserService\n- [ ] 1.4 Wire up dependency injection\n```\n\n## Complete Example\n\n```markdown\n# Implementation Plan: User Authentication\n\n- [ ] 1. Set up authentication foundation\n- [ ] 1.1 Create project structure and interfaces\n  - Set up directory structure for auth, models, API\n  - Define TypeScript interfaces for User, Session, AuthRequest\n  - Configure Jest for testing\n  - _Requirements: 1.1_\n\n- [ ] 1.2 Set up database and migrations\n  - Configure database connection\n  - Create user and session tables\n  - Set up test database\n  - _Requirements: 1.1, 2.1_\n\n- [ ] 2. Implement core data models\n- [ ] 2.1 Create User model with validation\n  - Implement User class with email, password, profile fields\n  - Add email format validation\n  - Add password strength validation (8+ chars)\n  - Write unit tests for all validation rules\n  - _Requirements: 1.2, 2.1_\n\n- [ ] 2.2 Create Session model\n  - Implement Session class with token, expiration\n  - Add session validation logic\n  - Write unit tests for session management\n  - _Requirements: 1.2, 4.1_\n\n- [ ] 3. Create authentication services\n- [ ] 3.1 Implement registration service\n  - Create UserService with register method\n  - Add password hashing with bcrypt\n  - Implement duplicate email checking\n  - Write unit tests for registration\n  - _Requirements: 1.2_\n\n- [ ] 3.2 Implement login service\n  - Add login method with password verification\n  - Implement JWT token generation\n  - Create refresh token rotation\n  - Write unit tests for login flow\n  - _Requirements: 1.2, 4.1_\n\n- [ ] 4. Create API endpoints\n- [ ] 4.1 Implement registration endpoint\n  - Create POST /auth/register endpoint\n  - Add request validation middleware\n  - Implement error responses\n  - Write integration tests\n  - _Requirements: 1.2, 2.3_\n\n- [ ] 4.2 Implement login endpoint\n  - Create POST /auth/login endpoint\n  - Add authentication middleware\n  - Implement logout functionality\n  - Write integration tests\n  - _Requirements: 1.2, 4.1_\n\n- [ ] 5. Integration and security\n- [ ] 5.1 Add security middleware\n  - Implement rate limiting\n  - Add CORS configuration\n  - Create JWT validation middleware\n  - Write security tests\n  - _Requirements: 4.1, 2.3_\n\n- [ ] 5.2 End-to-end testing\n  - Create complete auth flow tests\n  - Test error scenarios\n  - Validate security measures\n  - _Requirements: 1.2, 4.1_\n```\n\n## Quality Checklist\n\nBefore finalizing tasks:\n\n**Completeness:**\n- [ ] All design components have tasks\n- [ ] All requirements are addressed\n- [ ] Testing tasks included throughout\n- [ ] Integration tasks connect components\n\n**Clarity:**\n- [ ] Each task has specific objective\n- [ ] Files/components specified\n- [ ] Requirements referenced\n- [ ] Completion criteria clear\n\n**Sequencing:**\n- [ ] Dependencies respected\n- [ ] Foundation before features\n- [ ] Core before optional\n- [ ] Integration after components\n\n**Feasibility:**\n- [ ] Tasks are 2-4 hours each\n- [ ] Can be completed independently\n- [ ] No external blockers\n- [ ] Complexity increases gradually\n\n## Common Pitfalls\n\n1. **Tasks too abstract:** \"Implement user management\" vs specific actions\n2. **Missing dependencies:** Tasks that can't be completed in sequence\n3. **Non-coding tasks:** Include only implementation activities\n4. **Monolithic tasks:** Break into 2-4 hour increments\n5. **Missing tests:** Include testing in each task\n\n## Task Execution Tips\n\n**Before starting a task:**\n1. Read task details thoroughly\n2. Review referenced requirements\n3. Check dependencies are complete\n4. Plan implementation approach\n\n**During implementation:**\n1. Mark task as in-progress\n2. Write tests alongside code\n3. Test continuously\n4. Document as you go\n\n**Before marking complete:**\n1. All tests pass\n2. Requirements validated\n3. Code reviewed\n4. Documentation updated\n\n## Next Steps\n\nAfter completing task breakdown:\n1. Review task list with team\n2. Assign tasks to developers\n3. Begin implementation in sequence\n4. Track progress by marking tasks complete\n5. Update tasks if implementation reveals gaps"
              },
              {
                "name": "troubleshooting",
                "description": "Diagnose and resolve common issues during spec-driven development and implementation. Learn strategies for handling spec-reality divergence, dependency blocks, unclear requirements, and other execution challenges.",
                "path": "skills/troubleshooting/SKILL.md",
                "frontmatter": {
                  "name": "troubleshooting",
                  "description": "Diagnose and resolve common issues during spec-driven development and implementation. Learn strategies for handling spec-reality divergence, dependency blocks, unclear requirements, and other execution challenges.",
                  "license": "MIT",
                  "compatibility": "Claude Code, Cursor, VS Code, Windsurf",
                  "metadata": {
                    "category": "methodology",
                    "complexity": "intermediate",
                    "author": "Kiro Team",
                    "version": "1.0.0"
                  }
                },
                "content": "# Troubleshooting\n\nDiagnose and resolve common problems that arise during spec-driven development and feature implementation.\n\n## When to Use This Skill\n\nUse troubleshooting strategies when:\n- Implementation doesn't match spec expectations\n- Tasks are blocked by dependencies\n- Requirements are unclear during coding\n- Tests are failing or hard to write\n- Performance doesn't meet requirements\n- Integration problems occur\n\n## Issue 1: Spec and Reality Diverge\n\n### Symptoms\n- Code structure doesn't match spec assumptions\n- APIs are unavailable or deprecated\n- Performance differs from expectations\n- Integration points work differently than specified\n\n### Resolution\n\n**Immediate Actions:**\n1. Document the gap exactly\n2. Assess impact (minor detail vs fundamental issue)\n3. Stop implementing until you understand implications\n\n**Resolution Options:**\n\n**Option 1: Update Spec (Minor Deviations)**\n```\nIf difference is minor and doesn't affect requirements:\n1. Update design section with actual approach\n2. Adjust affected tasks\n3. Document why change was needed\n4. Continue implementation\n```\n\n**Option 2: Redesign (Major Deviations)**\n```\nIf core assumptions are wrong:\n1. Return to design phase\n2. Incorporate new understanding\n3. Re-validate against requirements\n4. Create new task breakdown\n5. Restart with corrected plan\n```\n\n**Option 3: Adjust Requirements (Fundamental Issues)**\n```\nIf requirements can't be met as stated:\n1. Document why requirements aren't achievable\n2. Propose alternative approach\n3. Get stakeholder approval\n4. Update entire spec\n5. Restart process\n```\n\n### Prevention\n- Validate assumptions with code exploration during design\n- Prototype risky integrations before finalizing spec\n- Include technical spikes in task breakdown\n\n## Issue 2: Task Dependencies Block Progress\n\n### Symptoms\n- Can't complete task without later features\n- Multiple tasks need same file changes\n- Tests need features not yet built\n- Circular dependencies between tasks\n\n### Resolution\n\n**Strategy 1: Reorder Tasks**\n```\nIf dependency was missed in planning:\n1. Identify the prerequisite task\n2. Complete it first\n3. Return to blocked task\n4. Update task sequence for future\n```\n\n**Strategy 2: Split Tasks**\n```\nIf task is too large:\n1. Break blocked task into smaller pieces\n2. Complete parts that aren't blocked\n3. Queue dependent parts for later\n4. Update task breakdown\n```\n\n**Strategy 3: Use Mocking/Stubbing**\n```\nIf dependency is complex:\n1. Create minimal stub/mock of dependency\n2. Complete current task against stub\n3. Replace stub when real dependency ready\n4. Add integration testing task\n```\n\n**Strategy 4: Parallel Development**\n```\nIf dependency is in progress:\n1. Define clear interface/contract\n2. Implement against interface\n3. Test with mock implementation\n4. Integrate when dependency completes\n```\n\n### Prevention\n- Map dependencies explicitly during task planning\n- Order tasks to minimize blocking\n- Identify tasks that can be parallelized\n\n## Issue 3: Requirements Unclear During Implementation\n\n### Symptoms\n- Multiple valid interpretations\n- Edge cases not addressed\n- Conflicting requirements discovered\n- UX details missing\n\n### Resolution\n\n**Step 1: Analyze the Ambiguity**\n- What exactly is unclear?\n- What are possible interpretations?\n- What's the impact of each?\n- Is this common or edge case?\n\n**Step 2: Propose Solution**\n- What's most consistent with existing requirements?\n- What aligns with user needs?\n- What's technically simplest?\n- Make recommendation with rationale\n\n**Step 3: Get Clarification**\n- Update requirements with clarification\n- Update acceptance criteria if needed\n- Document decision rationale\n- Proceed with implementation\n\n**Step 4: Update Tasks**\n- Adjust current task if needed\n- Add new tasks if solution is complex\n- Update testing tasks\n\n### Prevention\n- Probe for edge cases during requirements phase\n- Use examples to clarify requirements\n- Review requirements with developers before design\n\n## Issue 4: Technical Debt Creates Friction\n\n### Symptoms\n- Need to refactor before adding feature\n- Tests are brittle or missing\n- Code is tightly coupled\n- No clear extension points\n\n### Resolution\n\n**Strategy 1: Refactor-First**\n```\nIf refactoring is bounded and low-risk:\n1. Create refactoring tasks separate from feature\n2. Get approval for additional work\n3. Complete refactoring with tests\n4. Proceed with feature\n```\n\n**Strategy 2: Parallel Track**\n```\nIf refactoring is extensive:\n1. Implement feature with workarounds\n2. Create separate refactoring initiative\n3. Document technical debt created\n4. Plan future cleanup\n```\n\n**Strategy 3: Incremental Improvement**\n```\nIf refactoring can be done in pieces:\n1. Refactor only what you touch\n2. Leave code better than you found it\n3. Add tests for refactored areas\n4. Continue feature implementation\n```\n\n### Prevention\n- Assess existing code quality during design\n- Include refactoring tasks when needed\n- Set realistic timelines accounting for debt\n\n## Issue 5: Tests Failing or Hard to Write\n\n### Symptoms\n- Tests fail randomly (flaky)\n- Setup code is complex\n- Mocking is complicated\n- Tests take too long\n\n### Resolution\n\n**For Tightly Coupled Code:**\n- Extract interfaces for dependencies\n- Use dependency injection\n- Create test fixtures/factories\n- Implement test doubles\n\n**For Complex Setup:**\n- Create reusable test utilities\n- Use test builders/factories\n- Implement setup helpers\n- Share fixtures across tests\n\n**For Flaky Tests:**\n- Remove timing dependencies\n- Eliminate global state\n- Mock external dependencies\n- Use deterministic test data\n\n**For Slow Tests:**\n- Use test doubles for expensive operations\n- Parallelize test execution\n- Optimize database setup/teardown\n- Cache expensive setups\n\n### Prevention\n- Design for testability during design phase\n- Include test strategy in design document\n- Write tests alongside implementation\n\n## Issue 6: Performance Problems\n\n### Symptoms\n- Slow response times\n- High memory usage\n- Database query issues\n- Excessive network calls\n\n### Resolution\n\n**Step 1: Measure**\n- Profile the code\n- Identify bottlenecks\n- Quantify the gap\n- Establish baseline\n\n**Step 2: Analyze**\n- Algorithmic complexity?\n- Database inefficiency?\n- Network latency?\n- Resource contention?\n\n**Step 3: Optimize**\n- Target biggest bottleneck first\n- Make one change at a time\n- Measure after each change\n- Document optimizations\n\n**Step 4: Validate**\n- Verify requirements met\n- Check no regressions\n- Add performance tests\n- Document characteristics\n\n**Common Fixes:**\n- Database: Add indexes, optimize queries, implement caching\n- Algorithm: Better data structures, reduce complexity, lazy loading\n- Network: Batch requests, compression, reduce payload size\n\n### Prevention\n- Include performance requirements in spec\n- Design with performance in mind\n- Profile early and often\n\n## Issue 7: Integration Problems\n\n### Symptoms\n- Works locally, fails in integration\n- Timing issues in production\n- Data format mismatches\n- Auth failures\n\n### Resolution\n\n**Step 1: Isolate Problem**\n- Does it work in isolation?\n- Which integration point fails?\n- Consistent or intermittent?\n- What's different in integration environment?\n\n**Step 2: Verify Contracts**\n- Check API specifications\n- Validate data formats\n- Verify authentication flow\n- Review error responses\n\n**Step 3: Test Integration Points**\n- Test each integration separately\n- Use integration test environment\n- Verify error handling\n- Check timeout behavior\n\n**Step 4: Fix and Validate**\n- Implement fix\n- Add integration tests\n- Verify in integration environment\n- Update spec if assumptions wrong\n\n**Common Issues:**\n- Configuration differences (URLs, credentials)\n- Data format issues (dates, encoding, nulls)\n- Timing issues (race conditions, timeouts)\n\n### Prevention\n- Test in integration environment early\n- Document integration requirements clearly\n- Include integration tests in task breakdown\n\n## Issue 8: Scope Creep During Implementation\n\n### Symptoms\n- \"While I'm here, I should also...\"\n- \"It would be easy to add...\"\n- Tasks taking longer than estimated\n- Feature complexity growing\n\n### Resolution\n\n**Step 1: Recognize It**\n- Notice when going beyond spec\n- Identify additions vs requirements\n- Assess if it's scope creep\n\n**Step 2: Evaluate**\n- Is it required for current requirements?\n- Is it a bug fix or enhancement?\n- Cost of doing now vs later?\n\n**Step 3: Decide**\n\n**Option A: Required for Current Feature**\n- Update spec with new requirement\n- Add to current work\n- Adjust timeline\n\n**Option B: Nice to Have**\n- Document as future enhancement\n- Complete current spec first\n- Create separate spec later\n\n**Option C: Out of Scope**\n- Note as explicitly excluded\n- Create future spec if valuable\n- Stay focused on current work\n\n### Red Flags\n- \"Just one more feature\"\n- \"While we're changing this...\"\n- Refactoring beyond what's needed\n- Gold-plating solutions\n\n### Prevention\n- Clear requirements and acceptance criteria\n- Regular review against spec\n- Time-box implementation tasks\n\n## Debugging Strategies\n\n### Rubber Duck Debugging\nExplain the problem out loud. Often the explanation reveals the solution.\n\n### Binary Search\nIsolate by dividing code in half repeatedly until you find the issue.\n\n### Strategic Logging\nAdd logging to understand code flow and data transformations.\n\n### Minimal Reproduction\nCreate smallest test case that reproduces the issue.\n\n### Compare Working vs Broken\nFind similar working code and compare differences.\n\n## When to Update the Spec\n\n**Always Update When:**\n- Design assumptions were wrong\n- Requirements need clarification\n- Tasks need reordering\n- New edge cases discovered\n- Technical approach changes\n\n**Document:**\n- Why changes were made\n- When they were made\n- Impact on timeline\n- Alternatives considered\n\n## Getting Unstuck\n\nWhen truly blocked:\n1. **Take a break** - Solution often comes when you step away\n2. **Review the spec** - Re-read requirements and design\n3. **Ask for help** - Get a second pair of eyes\n4. **Simplify** - Solve a simpler version first\n5. **Prototype** - Try multiple approaches quickly\n6. **Go back a phase** - Maybe the spec needs work"
              }
            ]
          }
        ]
      }
    }
  ]
}