{
  "owner": {
    "id": "kylesnowschwartz",
    "display_name": "kylesnowschwartz",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/11069001?u=61eff4bb9e80c12b27732be3aa7ea04ef112011d&v=4",
    "url": "https://github.com/kylesnowschwartz",
    "bio": "Engineer @ Envato  |  Curious about AI & DevEx.  | Claude-Code plugin tinkerer",
    "stats": {
      "total_repos": 1,
      "total_plugins": 5,
      "total_commands": 22,
      "total_skills": 2,
      "total_stars": 81,
      "total_forks": 10
    }
  },
  "repos": [
    {
      "full_name": "kylesnowschwartz/SimpleClaude",
      "url": "https://github.com/kylesnowschwartz/SimpleClaude",
      "description": "Practical minimalism for AI assisted programming with Claude Code",
      "homepage": null,
      "signals": {
        "stars": 81,
        "forks": 10,
        "pushed_at": "2026-01-09T02:52:09Z",
        "created_at": "2025-07-06T10:44:54Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 3662
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 34
        },
        {
          "path": ".pre-commit-config.yaml",
          "type": "blob",
          "size": 1944
        },
        {
          "path": ".rubocop.yml",
          "type": "blob",
          "size": 1004
        },
        {
          "path": ".rubocop_todo.yml",
          "type": "blob",
          "size": 621
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 5183
        },
        {
          "path": "Gemfile",
          "type": "blob",
          "size": 188
        },
        {
          "path": "Gemfile.lock",
          "type": "blob",
          "size": 1435
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 6903
        },
        {
          "path": "VERSION",
          "type": "blob",
          "size": 6
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/AI_SLASH_COMMAND_CREATION_GUIDE.md",
          "type": "blob",
          "size": 4384
        },
        {
          "path": "docs/HOOKS_GUIDE.md",
          "type": "blob",
          "size": 6471
        },
        {
          "path": "docs/VISION.md",
          "type": "blob",
          "size": 1702
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-extras",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-extras/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-extras/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 356
        },
        {
          "path": "plugins/sc-extras/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-extras/commands/sc-context-wizard.md",
          "type": "blob",
          "size": 9015
        },
        {
          "path": "plugins/sc-extras/commands/sc-eastereggs.md",
          "type": "blob",
          "size": 1743
        },
        {
          "path": "plugins/sc-extras/commands/sc-extract-and-verify-claims.md",
          "type": "blob",
          "size": 3773
        },
        {
          "path": "plugins/sc-extras/commands/sc-ffs.md",
          "type": "blob",
          "size": 460
        },
        {
          "path": "plugins/sc-extras/commands/sc-five-whys.md",
          "type": "blob",
          "size": 4726
        },
        {
          "path": "plugins/sc-extras/commands/sc-mermaid-flowchart.md",
          "type": "blob",
          "size": 2430
        },
        {
          "path": "plugins/sc-extras/commands/sc-mermaid-sequence.md",
          "type": "blob",
          "size": 4110
        },
        {
          "path": "plugins/sc-extras/commands/sc-pre-commit-setup.md",
          "type": "blob",
          "size": 10298
        },
        {
          "path": "plugins/sc-extras/commands/sc-validate-task.md",
          "type": "blob",
          "size": 4055
        },
        {
          "path": "plugins/sc-extras/commands/sc-worktrees.md",
          "type": "blob",
          "size": 1932
        },
        {
          "path": "plugins/sc-hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 351
        },
        {
          "path": "plugins/sc-hooks/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/commands/copy-prompt.md",
          "type": "blob",
          "size": 121
        },
        {
          "path": "plugins/sc-hooks/commands/copy-response.md",
          "type": "blob",
          "size": 123
        },
        {
          "path": "plugins/sc-hooks/commands/sc-sounds.md",
          "type": "blob",
          "size": 834
        },
        {
          "path": "plugins/sc-hooks/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/hooks/entrypoints",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/hooks/entrypoints/notification.rb",
          "type": "blob",
          "size": 1728
        },
        {
          "path": "plugins/sc-hooks/hooks/entrypoints/post_tool_use.rb",
          "type": "blob",
          "size": 1558
        },
        {
          "path": "plugins/sc-hooks/hooks/entrypoints/session_start.rb",
          "type": "blob",
          "size": 1441
        },
        {
          "path": "plugins/sc-hooks/hooks/entrypoints/stop.rb",
          "type": "blob",
          "size": 1553
        },
        {
          "path": "plugins/sc-hooks/hooks/entrypoints/user_prompt_submit.rb",
          "type": "blob",
          "size": 2071
        },
        {
          "path": "plugins/sc-hooks/hooks/handlers",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/hooks/handlers/auto_format_handler.rb",
          "type": "blob",
          "size": 7432
        },
        {
          "path": "plugins/sc-hooks/hooks/handlers/copy_message_handler.rb",
          "type": "blob",
          "size": 7073
        },
        {
          "path": "plugins/sc-hooks/hooks/handlers/github_url_handler.rb",
          "type": "blob",
          "size": 4587
        },
        {
          "path": "plugins/sc-hooks/hooks/handlers/notification_handler.rb",
          "type": "blob",
          "size": 3258
        },
        {
          "path": "plugins/sc-hooks/hooks/handlers/session_start_handler.rb",
          "type": "blob",
          "size": 2307
        },
        {
          "path": "plugins/sc-hooks/hooks/handlers/stop_you_are_not_right.rb",
          "type": "blob",
          "size": 3604
        },
        {
          "path": "plugins/sc-hooks/hooks/handlers/trigger_skills_handler.rb",
          "type": "blob",
          "size": 1178
        },
        {
          "path": "plugins/sc-hooks/hooks/hooks.json",
          "type": "blob",
          "size": 1290
        },
        {
          "path": "plugins/sc-hooks/hooks/lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/hooks/lib/reflexive_agreement_detector.rb",
          "type": "blob",
          "size": 3504
        },
        {
          "path": "plugins/sc-hooks/hooks/lib/transcript_parser.rb",
          "type": "blob",
          "size": 8823
        },
        {
          "path": "plugins/sc-hooks/lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/lib/sound_config.rb",
          "type": "blob",
          "size": 1151
        },
        {
          "path": "plugins/sc-hooks/vendor",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/CHANGELOG.md",
          "type": "blob",
          "size": 9081
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/README.md",
          "type": "blob",
          "size": 30156
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks.rb",
          "type": "blob",
          "size": 1237
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/base.rb",
          "type": "blob",
          "size": 4067
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/cli.rb",
          "type": "blob",
          "size": 5994
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/configuration.rb",
          "type": "blob",
          "size": 7444
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/logger.rb",
          "type": "blob",
          "size": 1756
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/notification.rb",
          "type": "blob",
          "size": 538
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/base.rb",
          "type": "blob",
          "size": 4185
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/notification.rb",
          "type": "blob",
          "size": 358
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/post_tool_use.rb",
          "type": "blob",
          "size": 2066
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/pre_compact.rb",
          "type": "blob",
          "size": 323
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/pre_tool_use.rb",
          "type": "blob",
          "size": 3037
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/session_end.rb",
          "type": "blob",
          "size": 497
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/session_start.rb",
          "type": "blob",
          "size": 1238
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/stop.rb",
          "type": "blob",
          "size": 2484
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/subagent_stop.rb",
          "type": "blob",
          "size": 238
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/output/user_prompt_submit.rb",
          "type": "blob",
          "size": 2088
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/post_tool_use.rb",
          "type": "blob",
          "size": 975
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/pre_compact.rb",
          "type": "blob",
          "size": 847
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/pre_tool_use.rb",
          "type": "blob",
          "size": 1095
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/session_end.rb",
          "type": "blob",
          "size": 772
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/session_start.rb",
          "type": "blob",
          "size": 670
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/stop.rb",
          "type": "blob",
          "size": 1109
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/subagent_stop.rb",
          "type": "blob",
          "size": 165
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/user_prompt_submit.rb",
          "type": "blob",
          "size": 1017
        },
        {
          "path": "plugins/sc-hooks/vendor/claude_hooks/lib/claude_hooks/version.rb",
          "type": "blob",
          "size": 74
        },
        {
          "path": "plugins/sc-output-styles",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-output-styles/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-output-styles/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 412
        },
        {
          "path": "plugins/sc-output-styles/README.md",
          "type": "blob",
          "size": 2512
        },
        {
          "path": "plugins/sc-output-styles/output-styles",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-output-styles/output-styles/html-structured.md",
          "type": "blob",
          "size": 2654
        },
        {
          "path": "plugins/sc-output-styles/output-styles/jane-austen.md",
          "type": "blob",
          "size": 6073
        },
        {
          "path": "plugins/sc-output-styles/output-styles/json-structured.md",
          "type": "blob",
          "size": 4236
        },
        {
          "path": "plugins/sc-output-styles/output-styles/linus-torvalds.md",
          "type": "blob",
          "size": 3035
        },
        {
          "path": "plugins/sc-output-styles/output-styles/markdown-style.md",
          "type": "blob",
          "size": 2288
        },
        {
          "path": "plugins/sc-output-styles/output-styles/semantic-markdown.md",
          "type": "blob",
          "size": 4953
        },
        {
          "path": "plugins/sc-output-styles/output-styles/starfleet-officer.md",
          "type": "blob",
          "size": 3724
        },
        {
          "path": "plugins/sc-output-styles/output-styles/yaml-structured.md",
          "type": "blob",
          "size": 2596
        },
        {
          "path": "plugins/sc-skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 646
        },
        {
          "path": "plugins/sc-skills/README.md",
          "type": "blob",
          "size": 3283
        },
        {
          "path": "plugins/sc-skills/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/agents/sc-design-iterator.md",
          "type": "blob",
          "size": 10916
        },
        {
          "path": "plugins/sc-skills/agents/sc-pr-comment-resolver.md",
          "type": "blob",
          "size": 4275
        },
        {
          "path": "plugins/sc-skills/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/commands/sc-generate-command.md",
          "type": "blob",
          "size": 4094
        },
        {
          "path": "plugins/sc-skills/commands/sc-playwright-test.md",
          "type": "blob",
          "size": 5494
        },
        {
          "path": "plugins/sc-skills/commands/sc-pr-comments.md",
          "type": "blob",
          "size": 697
        },
        {
          "path": "plugins/sc-skills/commands/sc-resolve-pr-parallel.md",
          "type": "blob",
          "size": 2564
        },
        {
          "path": "plugins/sc-skills/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/scripts/playwright-mcp-wrapper.sh",
          "type": "blob",
          "size": 391
        },
        {
          "path": "plugins/sc-skills/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/skills/sc-frontend-design",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/skills/sc-frontend-design/SKILL.md",
          "type": "blob",
          "size": 5446
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen/SKILL.md",
          "type": "blob",
          "size": 6461
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen/requirements.txt",
          "type": "blob",
          "size": 35
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen/scripts/compose_images.py",
          "type": "blob",
          "size": 4627
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen/scripts/edit_image.py",
          "type": "blob",
          "size": 4089
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen/scripts/gemini_images.py",
          "type": "blob",
          "size": 7793
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen/scripts/generate_image.py",
          "type": "blob",
          "size": 3813
        },
        {
          "path": "plugins/sc-skills/skills/sc-gemini-imagegen/scripts/multi_turn_chat.py",
          "type": "blob",
          "size": 6239
        },
        {
          "path": "plugins/sc-skills/skills/sc-pull-request-skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/skills/sc-pull-request-skills/SKILL.md",
          "type": "blob",
          "size": 2081
        },
        {
          "path": "plugins/sc-skills/skills/sc-pull-request-skills/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/sc-skills/skills/sc-pull-request-skills/scripts/format-pr-tree.rb",
          "type": "blob",
          "size": 1590
        },
        {
          "path": "plugins/sc-skills/skills/sc-pull-request-skills/scripts/get-pr-comments.sh",
          "type": "blob",
          "size": 3334
        },
        {
          "path": "plugins/sc-skills/skills/sc-pull-request-skills/scripts/resolve-pr-thread.sh",
          "type": "blob",
          "size": 973
        },
        {
          "path": "plugins/simpleclaude-core",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/simpleclaude-core/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/simpleclaude-core/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 366
        },
        {
          "path": "plugins/simpleclaude-core/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/simpleclaude-core/agents/sc-code-architect.md",
          "type": "blob",
          "size": 3580
        },
        {
          "path": "plugins/simpleclaude-core/agents/sc-code-explorer.md",
          "type": "blob",
          "size": 3405
        },
        {
          "path": "plugins/simpleclaude-core/agents/sc-code-reviewer.md",
          "type": "blob",
          "size": 4207
        },
        {
          "path": "plugins/simpleclaude-core/agents/sc-repo-documentation-expert.md",
          "type": "blob",
          "size": 11067
        },
        {
          "path": "plugins/simpleclaude-core/agents/sc-test-runner.md",
          "type": "blob",
          "size": 2904
        },
        {
          "path": "plugins/simpleclaude-core/agents/sc-web-search-researcher.md",
          "type": "blob",
          "size": 6207
        },
        {
          "path": "plugins/simpleclaude-core/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/simpleclaude-core/commands/sc-explore.md",
          "type": "blob",
          "size": 3798
        },
        {
          "path": "plugins/simpleclaude-core/commands/sc-plan.md",
          "type": "blob",
          "size": 3169
        },
        {
          "path": "plugins/simpleclaude-core/commands/sc-review.md",
          "type": "blob",
          "size": 3329
        },
        {
          "path": "plugins/simpleclaude-core/commands/sc-work.md",
          "type": "blob",
          "size": 3828
        },
        {
          "path": "plugins/simpleclaude-core/commands/sc-workflow.md",
          "type": "blob",
          "size": 6342
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/install.rb",
          "type": "blob",
          "size": 4622
        },
        {
          "path": "scripts/vendor-claude-hooks.sh",
          "type": "blob",
          "size": 2729
        },
        {
          "path": "status-lines",
          "type": "tree",
          "size": null
        },
        {
          "path": "status-lines/simple-status-line.sh",
          "type": "blob",
          "size": 3444
        },
        {
          "path": "templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "templates/command-template.md",
          "type": "blob",
          "size": 3548
        },
        {
          "path": "templates/settings.example.json",
          "type": "blob",
          "size": 2340
        },
        {
          "path": "test",
          "type": "tree",
          "size": null
        },
        {
          "path": "test/test_detector_consistency.rb",
          "type": "blob",
          "size": 2506
        },
        {
          "path": "test/test_reflexive_agreement.rb",
          "type": "blob",
          "size": 6844
        }
      ],
      "marketplace": {
        "name": "simpleclaude",
        "version": "3.3.0",
        "description": "Practical minimalist AI assistant framework with specialized agents",
        "owner_info": {
          "name": "Kyle Snow Schwartz",
          "url": "https://github.com/kylesnowschwartz"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "simpleclaude-core",
            "description": "Core SimpleClaude framework with 4+1 intent-based commands and 6 specialized agents for token-efficient execution",
            "source": "./plugins/simpleclaude-core",
            "category": "productivity",
            "version": "3.0.1",
            "author": {
              "name": "Kyle Snow Schwartz"
            },
            "install_commands": [
              "/plugin marketplace add kylesnowschwartz/SimpleClaude",
              "/plugin install simpleclaude-core@simpleclaude"
            ],
            "signals": {
              "stars": 81,
              "forks": 10,
              "pushed_at": "2026-01-09T02:52:09Z",
              "created_at": "2025-07-06T10:44:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/sc-explore",
                "description": "Research, analyze, and explore to build understanding",
                "path": "plugins/simpleclaude-core/commands/sc-explore.md",
                "frontmatter": {
                  "description": "Research, analyze, and explore to build understanding",
                  "argument-hint": "Research query or topic to explore"
                },
                "content": "# sc-explore: Research and Understanding Command\n\n**Purpose**: I need to understand something - conducts research, analysis, codebase exploration, and knowledge synthesis to build understanding\n\n## Agent Orchestration and Deployment Strategy\n\n**Efficiency First:** Handle tasks directly when possible. Use agents only when genuinely needed for:\n\n- Multi-step coordination requiring handoffs\n- Specialized domain expertise beyond general capability\n- Parallel work streams with interdependencies\n- Complex analysis requiring multiple perspectives\n- Operations that produce verbose intermediate output\n\n**Direct Agent Rules (ALWAYS delegate these):**\n\n- **Documentation lookups** → Use `sc-repo-documentation-expert`\n- **Test execution** → Use `sc-test-runner`\n- **Web searches** → Use `sc-web-search-researcher`\n- **Deep codebase analysis** → Use `sc-code-explorer`\n- **Architecture design** → Use `sc-code-architect`\n- **Code quality review** → Use `sc-code-reviewer`\n\n**Available Agents:**\n\n- `sc-code-explorer` - Deeply analyzes existing codebase features by tracing execution paths and mapping architecture\n- `sc-code-architect` - Designs feature architectures by analyzing existing patterns and providing implementation blueprints\n- `sc-code-reviewer` - Reviews code for bugs, security vulnerabilities, and adherence to project conventions\n- `sc-repo-documentation-expert` - Finds documentation from Context7, local repos, and GitHub repositories\n- `sc-test-runner` - Executes tests and analyzes failures\n- `sc-web-search-researcher` - Searches web for current information\n\n**Context Preservation:**\n\n- **Keep only**: user request, actionable recommendations, code changes, summary, next steps\n- **Discard**: intermediate outputs, full docs, verbose logs, exploratory reads\n\n**Processing Pipeline**: Parse → Classify → Validate → Route → Execute → Synthesize\n\n## Intent Recognition and Semantic Transformation\n\nThis command interprets natural language requests that express the intent: \"I need to understand something\" - research, analysis, exploration, learning, or investigation of codebases, technologies, concepts, or domain knowledge.\n\n**Command Execution:**\n\n**Empty $ARGUMENTS**: Display usage suggestions → stop\n**Has content**: Parse intent → apply strategy → route execution\n\n**Intent Processing:** Extract intent → Apply strategy matrix → Validate → Execute\n\n**Strategy Matrix:**\n\n| Condition | Direct Handling     | Agent Required                 |\n| --------- | ------------------- | ------------------------------ |\n| Task Type | Simple, single-step | See \"Direct Agent Rules\" above |\n| Domain    | Single, familiar    | Multi-tech, unknown            |\n| Context   | Available locally   | External research needed       |\n| Output    | Concise, focused    | Verbose, needs filtering       |\n\nTransforms: $ARGUMENTS into structured execution:\n\n- Intent: [recognized-user-intent]\n- Approach: [direct/agent with reasoning]\n- Agents: [none OR minimal-viable-set]\n\n### Output Template\n\n```\n## Response\n\n[Direct answer or action taken - 1-3 sentences addressing the core request]\n\n## Details\n\n[Main content based on command type:\n- Plan: Strategy breakdown with phases\n- Work: Code changes and implementation steps\n- Explore: Research findings and analysis\n- Review: Issues found and quality assessment]\n\n## Next Actions\n\n[What to do next:\n- Plan: Implementation steps to begin\n- Work: Testing and validation needed\n- Explore: Areas for deeper investigation\n- Review: Fixes and improvements to make]\n\n## Notes\n\n[Optional - context, warnings, alternatives, or additional considerations]\n```\n\n---\n\n**User Request**: $ARGUMENTS"
              },
              {
                "name": "/sc-plan",
                "description": "Strategic planning and analysis for requirements and roadmaps",
                "path": "plugins/simpleclaude-core/commands/sc-plan.md",
                "frontmatter": {
                  "description": "Strategic planning and analysis for requirements and roadmaps",
                  "argument-hint": "Planning task or requirement to analyze"
                },
                "content": "# sc-plan: Strategic Planning and Analysis\n\n**Purpose**: I need to think through something - analyzes requirements, creates actionable roadmaps, and establishes clear direction for development work\n\n## Agent Orchestration and Deployment Strategy\n\n**Efficiency First:** Handle tasks directly when possible. Use agents only when genuinely needed for:\n\n- Multi-step coordination requiring handoffs\n- Specialized domain expertise beyond general capability\n- Parallel work streams with interdependencies\n- Complex analysis requiring multiple perspectives\n- Operations that produce verbose intermediate output\n\n**Direct Agent Rules (ALWAYS delegate these):**\n\n- **Documentation lookups** → Use `sc-repo-documentation-expert`\n- **Test execution** → Use `sc-test-runner`\n- **Web searches** → Use `sc-web-search-researcher`\n- **Deep codebase analysis** → Use `sc-code-explorer`\n- **Architecture design** → Use `sc-code-architect`\n- **Code quality review** → Use `sc-code-reviewer`\n\n**Context Preservation:**\n\n- **Keep only**: user request, actionable recommendations, code changes, summary, next steps\n- **Discard**: intermediate outputs, full docs, verbose logs, exploratory reads\n\n**Processing Pipeline**: Parse → Classify → Validate → Route → Execute → Synthesize\n\n## Intent Recognition and Semantic Transformation\n\nThis command interprets natural language requests that express the intent: \"I need to think through something\" - planning, analysis, strategy, roadmap creation, or architectural decision-making.\n\n**Command Execution:**\n\n**Empty $ARGUMENTS**: Display usage suggestions → stop\n**Has content**: Parse intent → apply strategy → route execution\n\n**Intent Processing:** Extract intent → Apply strategy matrix → Validate → Execute\n\n**Strategy Matrix:**\n\n| Condition | Direct Handling     | Agent Required                 |\n| --------- | ------------------- | ------------------------------ |\n| Task Type | Simple, single-step | See \"Direct Agent Rules\" above |\n| Domain    | Single, familiar    | Multi-tech, unknown            |\n| Context   | Available locally   | External research needed       |\n| Output    | Concise, focused    | Verbose, needs filtering       |\n\nTransforms: $AGENTS into structured execution:\n\n- Intent: [recognized-user-intent]\n- Approach: [direct/agent with reasoning]\n- Agents: [none OR minimal-viable-set]\n\n### Output Template\n\n```\n## Response\n\n[Direct answer or action taken - 1-3 sentences addressing the core request]\n\n## Details\n\n[Main content based on command type:\n- Plan: Strategy breakdown with phases\n- Work: Code changes and implementation steps\n- Explore: Research findings and analysis\n- Review: Issues found and quality assessment]\n\n## Next Actions\n\n[What to do next:\n- Plan: Implementation steps to begin\n- Work: Testing and validation needed\n- Explore: Areas for deeper investigation\n- Review: Fixes and improvements to make]\n\n## Notes\n\n[Optional - context, warnings, alternatives, or additional considerations]\n```\n\n---\n\n**User Request**: $ARGUMENTS"
              },
              {
                "name": "/sc-review",
                "description": "Verify code quality, security, performance, and architecture",
                "path": "plugins/simpleclaude-core/commands/sc-review.md",
                "frontmatter": {
                  "description": "Verify code quality, security, performance, and architecture",
                  "argument-hint": "Describe what to review (code quality, security, performance, architecture)"
                },
                "content": "# sc-review: Quality Verification and Assessment\n\n**Purpose**: I need to verify quality/security/performance - comprehensive analysis covering code quality, security scanning, performance profiling, and architecture assessment\n\n## Agent Orchestration and Deployment Strategy\n\n**Efficiency First:** Handle tasks directly when possible. Use agents only when genuinely needed for:\n\n- Multi-step coordination requiring handoffs\n- Specialized domain expertise beyond general capability\n- Parallel work streams with interdependencies\n- Complex analysis requiring multiple perspectives\n- Operations that produce verbose intermediate output\n\n**Available Agents:**\n\nDelegate context-specific tasks to these specialized sub-agents as needed in parallel:\n\n- `sc-code-explorer` - Deeply analyzes existing codebase features by tracing execution paths and mapping architecture\n- `sc-code-architect` - Designs feature architectures by analyzing existing patterns and providing implementation blueprints\n- `sc-code-reviewer` - Reviews code for bugs, security vulnerabilities, and adherence to project conventions\n- `sc-repo-documentation-expert` - Finds documentation from Context7, local repos, and GitHub repositories\n- `sc-test-runner` - Executes tests and analyzes failures\n- `sc-web-search-researcher` - Searches web for current information\n\n## Intent Recognition and Semantic Transformation\n\nThis command interprets natural language requests that express the intent: \"I need to verify quality/security/performance\" - comprehensive assessment including code quality review, security scanning, performance profiling, and architecture analysis.\n\n**Command Execution:**\n\n**Empty $ARGUMENTS**: Display usage suggestions → stop\n**Has content**: Parse intent → apply strategy → route execution\n\n**Intent Processing:** Extract intent → Apply strategy matrix → Validate → Execute\n\n**Strategy Matrix:**\n\n| Condition | Direct Handling     | Agent Required                 |\n| --------- | ------------------- | ------------------------------ |\n| Task Type | Simple, single-step | See \"Direct Agent Rules\" above |\n| Domain    | Single, familiar    | Multi-tech, unknown            |\n| Context   | Available locally   | External research needed       |\n| Output    | Concise, focused    | Verbose, needs filtering       |\n\nTransforms: $ARGUMENTS into structured execution:\n\n- Intent: [verification-goal-and-scope]\n- Approach: [direct-review OR comprehensive-analysis]\n- Agents: [none OR minimal-viable-set]\n\n### Output Template\n\n```\n## Response\n\n[Direct answer or action taken - 1-3 sentences addressing the core request]\n\n## Details\n\n[Main content based on command type:\n- Plan: Strategy breakdown with phases\n- Work: Code changes and implementation steps\n- Explore: Research findings and analysis\n- Review: Issues found and quality assessment]\n\n## Next Actions\n\n[What to do next:\n- Plan: Implementation steps to begin\n- Work: Testing and validation needed\n- Explore: Areas for deeper investigation\n- Review: Fixes and improvements to make]\n\n## Notes\n\n[Optional - context, warnings, alternatives, or additional considerations]\n```\n\n---\n\n**User Request**: $ARGUMENTS"
              },
              {
                "name": "/sc-work",
                "description": "Build, fix, or modify code - handles all implementation tasks",
                "path": "plugins/simpleclaude-core/commands/sc-work.md",
                "frontmatter": {
                  "description": "Build, fix, or modify code - handles all implementation tasks",
                  "argument-hint": "Description of what to build, fix, or modify"
                },
                "content": "# sc-work: Universal Implementation Command\n\n**Purpose**: I need to build/fix/modify something - handles all implementation tasks from creating new features to fixing bugs to refactoring code\n\n## Agent Orchestration and Deployment Strategy\n\n**Efficiency First:** Handle tasks directly when possible. Use agents only when genuinely needed for:\n\n- Multi-step coordination requiring handoffs\n- Specialized domain expertise beyond general capability\n- Parallel work streams with interdependencies\n- Complex analysis requiring multiple perspectives\n- Operations that produce verbose intermediate output\n\n**Direct Agent Rules (ALWAYS delegate these):**\n\n- **Documentation lookups** → Use `sc-repo-documentation-expert`\n- **Test execution** → Use `sc-test-runner`\n- **Web searches** → Use `sc-web-search-researcher`\n- **Deep codebase analysis** → Use `sc-code-explorer`\n- **Architecture design** → Use `sc-code-architect`\n- **Code quality review** → Use `sc-code-reviewer`\n\n**Available Agents:**\n\n- `sc-code-explorer` - Deeply analyzes existing codebase features by tracing execution paths and mapping architecture\n- `sc-code-architect` - Designs feature architectures by analyzing existing patterns and providing implementation blueprints\n- `sc-code-reviewer` - Reviews code for bugs, security vulnerabilities, and adherence to project conventions\n- `sc-repo-documentation-expert` - Finds documentation from Context7, local repos, and GitHub repositories\n- `sc-test-runner` - Executes tests and analyzes failures\n- `sc-web-search-researcher` - Searches web for current information\n\n**Context Preservation:**\n\n- **Keep only**: user request, actionable recommendations, code changes, summary, next steps\n- **Discard**: intermediate outputs, full docs, verbose logs, exploratory reads\n\n**Processing Pipeline**: Parse → Classify → Validate → Route → Execute → Synthesize\n\n## Intent Recognition and Semantic Transformation\n\nThis command interprets natural language requests that express the intent: \"I need to build/fix/modify something\" - implementation work including creating, modifying, fixing, refactoring, optimizing, or enhancing code.\n\n**Command Execution:**\n\n**Empty $ARGUMENTS**: Display usage suggestions → stop\n**Has content**: Parse intent → apply strategy → route execution\n\n**Intent Processing:** Extract intent → Apply strategy matrix → Validate → Execute\n\n**Strategy Matrix:**\n\n| Condition | Direct Handling     | Agent Required                 |\n| --------- | ------------------- | ------------------------------ |\n| Task Type | Simple, single-step | See \"Direct Agent Rules\" above |\n| Domain    | Single, familiar    | Multi-tech, unknown            |\n| Context   | Available locally   | External research needed       |\n| Output    | Concise, focused    | Verbose, needs filtering       |\n\nTransforms: $ARGUMENTS into structured execution:\n\n- Intent: [implementation-goal-and-scope]\n- Approach: [direct-implementation OR research-then-implement]\n- Agents: [none OR minimal-viable-set]\n\n### Output Template\n\n```\n## Response\n[Direct answer or action taken - 1-3 sentences addressing the core request]\n\n## Details\n[Main content based on command type:\n- Plan: Strategy breakdown with phases\n- Work: Code changes and implementation steps\n- Explore: Research findings and analysis\n- Review: Issues found and quality assessment]\n\n## Next Actions\n[What to do next:\n- Plan: Implementation steps to begin\n- Work: Testing and validation needed\n- Explore: Areas for deeper investigation\n- Review: Fixes and improvements to make]\n\n## Notes\n[Optional - context, warnings, alternatives, or additional considerations]\n```\n\n---\n\n**User Request**: $ARGUMENTS"
              },
              {
                "name": "/sc-workflow",
                "description": "Guided feature development with codebase understanding and architecture focus",
                "path": "plugins/simpleclaude-core/commands/sc-workflow.md",
                "frontmatter": {
                  "description": "Guided feature development with codebase understanding and architecture focus",
                  "argument-hint": [
                    "Feature description"
                  ]
                },
                "content": "# Feature Development\n\nYou are helping a developer implement a new feature. Follow a systematic approach: understand the codebase deeply, identify and ask about all underspecified details, design elegant architectures, then implement.\n\n## Core Principles\n\n- **Ask clarifying questions**: Identify all ambiguities, edge cases, and underspecified behaviors. Ask specific, concrete questions rather than making assumptions. Wait for user answers before proceeding with implementation. Ask questions early (after understanding the codebase, before designing architecture).\n- **Understand before acting**: Read and comprehend existing code patterns first\n- **Read files identified by agents**: When launching agents, ask them to return lists of the most important files to read. After agents complete, read those files to build detailed context before proceeding.\n- **Simple and elegant**: Prioritize readable, maintainable, architecturally sound code\n- **Use TodoWrite**: Track all progress throughout\n\n---\n\n## Phase 1: Discovery\n\n**Goal**: Understand what needs to be built\n\nInitial request: $ARGUMENTS\n\n**Actions**:\n1. Create todo list with all phases\n2. If feature unclear, ask user for:\n   - What problem are they solving?\n   - What should the feature do?\n   - Any constraints or requirements?\n3. Summarize understanding and confirm with user\n\n---\n\n## Phase 2: Codebase Exploration\n\n**Goal**: Understand relevant existing code and patterns at both high and low levels\n\n**Actions**:\n1. Launch 2-3 sc-code-explorer agents in parallel. Each agent should:\n   - Trace through the code comprehensively and focus on getting a comprehensive understanding of abstractions, architecture and flow of control\n   - Target a different aspect of the codebase (eg. similar features, high level understanding, architectural understanding, user experience, etc)\n   - Include a list of 5-10 key files to read\n\n   **Example agent prompts**:\n   - \"Find features similar to [feature] and trace through their implementation comprehensively\"\n   - \"Map the architecture and abstractions for [feature area], tracing through the code comprehensively\"\n   - \"Analyze the current implementation of [existing feature/area], tracing through the code comprehensively\"\n   - \"Identify UI patterns, testing approaches, or extension points relevant to [feature]\"\n\n2. Once the agents return, please read all files identified by agents to build deep understanding\n3. Present comprehensive summary of findings and patterns discovered\n\n---\n\n## Phase 3: Clarifying Questions\n\n**Goal**: Fill in gaps and resolve all ambiguities before designing\n\n**CRITICAL**: This is one of the most important phases. DO NOT SKIP.\n\n**Actions**:\n1. Review the codebase findings and original feature request\n2. Identify underspecified aspects: edge cases, error handling, integration points, scope boundaries, design preferences, backward compatibility, performance needs\n3. **Present all questions to the user in a clear, organized list**\n4. **Wait for answers before proceeding to architecture design**\n\nIf the user says \"whatever you think is best\", provide your recommendation and get explicit confirmation.\n\n---\n\n## Phase 4: Research & Dependency Guidance\n\n**Goal**: Ground architecture decisions in actual API capabilities, not assumptions\n\n**CONDITIONAL**: Skip this phase if:\n- Feature uses only existing, well-understood dependencies\n- No new external libraries are needed\n- APIs haven't changed since codebase was written\n\n**Actions**:\n1. Identify external dependencies needed for the feature:\n   - New libraries required (based on clarified requirements)\n   - Existing dependencies that will be used differently\n   - APIs with potential version mismatches or deprecations\n\n2. For each significant external dependency, launch sc-web-search-researcher or\nsc-repo-documentation-expert agents to:\n   - Get current API documentation and examples\n   - Identify constraints, limitations, and patterns\n   - Flag breaking changes or deprecations vs. existing codebase usage\n   - Find recommended patterns and anti-patterns\n\n3. Document findings that constrain architecture:\n   - API limitations that rule out certain designs\n   - Required patterns (e.g., initialization, error handling)\n   - Performance characteristics\n   - Version compatibility requirements\n\n4. Present research summary to user with any concerns about API mismatches or constraints\n\n---\n\n## Phase 5: Architecture Design\n\n**Goal**: Design multiple implementation approaches with different trade-offs\n\n**Actions**:\n1. Launch 2-3 sc-code-architect agents in parallel with different focuses: minimal changes (smallest change, maximum reuse), clean architecture (maintainability, elegant abstractions), or pragmatic balance (speed + quality)\n2. Review all approaches and form your opinion on which fits best for this specific task (consider: small fix vs large feature, urgency, complexity, team context)\n3. Present to user: brief summary of each approach, trade-offs comparison, **your recommendation with reasoning**, concrete implementation differences\n4. **Ask user which approach they prefer**\n\n---\n\n## Phase 6: Implementation\n\n**Goal**: Build the feature\n\n**DO NOT START WITHOUT USER APPROVAL**\n\n**Actions**:\n1. Wait for explicit user approval\n2. Read all relevant files identified in previous phases\n3. Implement following chosen architecture\n4. Follow codebase conventions strictly\n5. Write clean, well-documented code\n6. Update todos as you progress\n\n---\n\n## Phase 7: Quality Review\n\n**Goal**: Ensure code is simple, DRY, elegant, easy to read, and functionally correct\n\n**Actions**:\n1. Launch 3 sc-code-reviewer agents in parallel with different focuses: simplicity/DRY/elegance, bugs/functional correctness, project conventions/abstractions\n2. Consolidate findings and identify highest severity issues that you recommend fixing\n3. **Present findings to user and ask what they want to do** (fix now, fix later, or proceed as-is)\n4. Address issues based on user decision\n\n---\n\n## Phase 8: Summary\n\n**Goal**: Document what was accomplished\n\n**Actions**:\n1. Mark all todos complete\n2. Summarize:\n   - What was built\n   - Key decisions made\n   - Files modified\n   - Suggested next steps\n\n---"
              }
            ],
            "skills": []
          },
          {
            "name": "sc-hooks",
            "description": "SimpleClaude hooks for session management, tool monitoring, and notifications",
            "source": "./plugins/sc-hooks",
            "category": "automation",
            "version": "2.7.0",
            "author": {
              "name": "Kyle Snow Schwartz"
            },
            "install_commands": [
              "/plugin marketplace add kylesnowschwartz/SimpleClaude",
              "/plugin install sc-hooks@simpleclaude"
            ],
            "signals": {
              "stars": 81,
              "forks": 10,
              "pushed_at": "2026-01-09T02:52:09Z",
              "created_at": "2025-07-06T10:44:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/copy-prompt",
                "description": "Copy last N prompts to clipboard",
                "path": "plugins/sc-hooks/commands/copy-prompt.md",
                "frontmatter": {
                  "description": "Copy last N prompts to clipboard",
                  "argument-hint": "[count]"
                },
                "content": "Logic defined in copy_message_handler.rb"
              },
              {
                "name": "/copy-response",
                "description": "Copy last N responses to clipboard",
                "path": "plugins/sc-hooks/commands/copy-response.md",
                "frontmatter": {
                  "description": "Copy last N responses to clipboard",
                  "argument-hint": "[count]"
                },
                "content": "Logic defined in copy_message_handler.rb"
              },
              {
                "name": "/sc-sounds",
                "description": "Set sound notification mode",
                "path": "plugins/sc-hooks/commands/sc-sounds.md",
                "frontmatter": {
                  "description": "Set sound notification mode",
                  "argument-hint": "[mode: off|glass]",
                  "allowed-tools": [
                    "Bash",
                    "Read",
                    "Write"
                  ]
                },
                "content": "# Sound Mode Configuration\n\nControl notification sounds:\n- `off` - Silent notifications (visual only)\n- `glass` - macOS notification sound (default)\n\nConfig file: `~/.config/claude/sounds.conf`\n\n$ARGUMENTS\n\n## Instructions\n\n1. First, read current state: `cat ~/.config/claude/sounds.conf 2>/dev/null || echo \"(not set - defaults to glass)\"`\n\n2. If mode argument provided:\n   - Validate mode is one of: off, glass\n   - Create ~/.config/claude directory if needed\n   - Write SOUND_MODE={mode} to ~/.config/claude/sounds.conf\n   - Confirm the change took effect\n\nExample responses:\n- \"Sound mode set to `glass` - macOS notification sounds enabled\"\n- \"Sound mode set to `off` - All notification sounds disabled\""
              }
            ],
            "skills": []
          },
          {
            "name": "sc-extras",
            "description": "Optional SimpleClaude utilities for debugging, git workflows, and task validation",
            "source": "./plugins/sc-extras",
            "category": "productivity",
            "version": "2.1.3",
            "author": {
              "name": "Kyle Snow Schwartz"
            },
            "install_commands": [
              "/plugin marketplace add kylesnowschwartz/SimpleClaude",
              "/plugin install sc-extras@simpleclaude"
            ],
            "signals": {
              "stars": 81,
              "forks": 10,
              "pushed_at": "2026-01-09T02:52:09Z",
              "created_at": "2025-07-06T10:44:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/sc-context-wizard",
                "description": "Interactive wizard to create context packets for agent tasks",
                "path": "plugins/sc-extras/commands/sc-context-wizard.md",
                "frontmatter": {
                  "description": "Interactive wizard to create context packets for agent tasks",
                  "argument-hint": "[optional: title or short description of the work]"
                },
                "content": "# sc-context-wizard: Agent Context Packet Builder\n\n_Structured workflow to create context packets that dramatically improve agent outcomes._\n\n## What is a Context Packet?\n\nA **context packet** is a tight, structured artifact that makes implicit requirements explicit before any coding starts. Based on [Where Good Ideas Come From (for Coding Agents)](https://sunilpai.dev/posts/seven-ways/), context packets transform vague requests into agent-compatible specifications.\n\n**The key insight**: \"Agents make code cheaper. They do not make judgment cheap.\" The scarce skill is expressing constraints, designing verification, and maintaining feedback loops—not keystrokes.\n\n## Process:\n\n### Phase 1: Human Judgment Fields\n\n**These require explicit user-input - the user knows these better than any agent can discover:**\n\n#### 1. Goal (1 sentence)\nUse `AskUserQuestion` to prompt:\n- **Question**: \"What is the goal of this work? (1 sentence describing the outcome, not the mechanism)\"\n- **Examples**:\n  - \"Make webhook ingestion reliable under variable load\"\n  - \"Add user profile editing with validation\"\n  - \"Optimize database queries for the reporting dashboard\"\n\n#### 2. Non-Goals (Scope Boundaries)\nUse `AskUserQuestion` to prompt:\n- **Question**: \"What are the explicit non-goals? (What's intentionally out of scope?)\"\n- **Examples**:\n  - \"Not changing the webhook payload format\"\n  - \"Not building admin UI for this release\"\n  - \"Not migrating existing data\"\n\n#### 3. Constraints (Budgets, Limits, Forbidden Actions)\nUse `AskUserQuestion` to prompt:\n- **Question**: \"What are the constraints? (Budgets, safety properties, forbidden actions)\"\n- **Examples**:\n  - \"Must complete within 200ms p95\"\n  - \"Cannot break existing API contracts\"\n  - \"No new external dependencies without approval\"\n  - \"Must maintain backward compatibility\"\n\n#### 4. Authority Order (Source Hierarchy)\nUse `AskUserQuestion` to prompt:\n- **Question**: \"When sources disagree, what's the authority order? (Which sources win?)\"\n- **Default template**: \"Tests > Documentation > Code comments > Implementation\"\n- **Allow customization**: User can modify or accept default\n\n### Phase 2: Optional Agent-Assisted Discovery\n\n**Leverage agents for codebase exploration:**\n\n#### 5. Repo Anchors (3-10 Key Files)\nUse `AskUserQuestion` with two options:\n- **Question**: \"How should we identify repo anchors (3-10 files defining truth)?\"\n- **Options**:\n  - \"Let me specify them manually\" → Prompt for file paths\n  - \"Discover them automatically\" → In the BACKGROUND, spawn 1-3 **Explore agent** with prompt:\n    ```\n    Find 3-10 key files that define the truth for: ${goal}\n\n    Look for:\n    - Core domain models/entities\n    - Primary API endpoints or controllers\n    - Key configuration files\n    - Main business logic files\n    - Critical integration points\n\n    Return a ranked list with brief explanations of why each file is a truth anchor.\n    ```\n\n#### 6. Prior Art (Existing Patterns to Reuse)\nUse `AskUserQuestion` with two options:\n- **Question**: \"How should we identify prior art (patterns to copy/reuse)?\"\n- **Options**:\n  - \"Let me specify manually\" → Prompt for descriptions\n  - \"Discover automatically\" → In the BACKGROUND, spawn **Explore agent** with prompt:\n    ```\n    Find existing patterns related to: ${goal}\n\n    Search for:\n    - Similar features or functionality\n    - Comparable error handling patterns\n    - Related test structures\n    - Analogous validation logic\n    - Existing integrations we should mirror\n\n    Return specific file paths and pattern descriptions that should be reused.\n    ```\n\n### Phase 3: Success Criteria and Risk\n\n#### 7. Oracle (Defining \"Done\")\nUse `AskUserQuestion` to prompt:\n- **Question**: \"What's your oracle? (Tests, benchmarks, or checks that define 'done')\"\n- **Examples**:\n  - \"All existing tests pass + new test suite for retries\"\n  - \"Lighthouse score > 90 on production build\"\n  - \"Benchmark shows <100ms p95 latency\"\n  - \"Manual QA checklist completed\"\n\n#### 8. Examples (Input → Output Cases)\nUse `AskUserQuestion` to prompt:\n- **Question**: \"Provide 2-3 examples (input → expected output, including failure cases)\"\n- **Format guidance**:\n  ```\n  Example 1 (Happy path):\n  Input: [specific input]\n  Output: [expected result]\n\n  Example 2 (Edge case):\n  Input: [boundary condition]\n  Output: [expected behavior]\n\n  Example 3 (Failure case):\n  Input: [invalid input]\n  Output: [error handling]\n  ```\n\n#### 9. Risk and Rollout\nUse `AskUserQuestion` to prompt:\n- **Question**: \"What are the risks and rollout considerations?\"\n- **Prompt for**:\n  - Failure modes (what could go wrong?)\n  - Mitigation strategies\n  - Deployment approach (feature flag? gradual rollout? all-at-once?)\n  - Rollback plan\n  - **Default template**: \"Create a Pull Request using the pr-template. Request reviews from the engineering team. Then verify in development and/or staging before deploying to production.\"\n\n\n### Phase 4: Agent Instructions\n\n#### 10. Procedural Guardrails\nPresent this template and ask for customizations:\n\n**Default template**:\n```markdown\n## Agent Instructions\n\nWhen implementing this work:\n\n1. **Keep diffs small**: Aim for focused, reviewable changes\n2. **Cite patterns**: Reference prior art from repo anchors explicitly\n3. **Run tests frequently**: Execute oracle checks after each meaningful change\n4. **Fail fast**: If assumptions break, stop and ask rather than guessing\n5. **Document why**: Comments explain reasoning, not mechanics\n6. **Preserve constraints**: Never violate stated constraints without explicit approval\n```\n\nUse `AskUserQuestion`:\n- **Question**: \"Review the agent instructions template. Any modifications or additions?\"\n- **Allow**: User can accept as-is or provide specific changes\n\n---\n\n## Output Generation\n\n### Create the Context Packet File\n\n**Location**: `.agent-history/context-packet-YYYYMMDD.md` or `.agent-history/context-packet-git-branch.md` if on a named branch\n\n**Format**:\n```markdown\n# Context Packet: [Goal - Short Title]\n\nCreated: YYYY-MM-DD\n\n## Goal\n\n[1 sentence from Phase 1]\n\n## Non-Goals\n\n[Bulleted list from Phase 1]\n\n## Constraints\n\n[Bulleted list from Phase 1]\n\n## Authority Order\n\n[Hierarchy from Phase 1]\n\n## Repo Anchors\n\n[3-10 files from Phase 2, with brief descriptions]\n\n## Prior Art\n\n[Patterns to reuse from Phase 2, with file references]\n\n## Oracle\n\n[Success criteria from Phase 3]\n\n## Examples\n\n[2-3 input→output cases from Phase 3]\n\n## Risk and Rollout\n\n[Failure modes and deployment strategy from Phase 3]\n\n## Agent Instructions\n\n[Procedural guardrails from Phase 4]\n\n---\n\n_This context packet should be referenced at the start of agent sessions working on this goal. Include it with: `@.agent-history/context-packet-YYYYMMDD.md`_\n```\n\n### Completion Message\n\nAfter generating the file, output:\n\n```\n✓ Context packet created: .agent-history/context-packet-[timestamp].md\n\nTo use this context packet in your next agent session:\n\n1. Reference it in your prompt: @.agent-history/context-packet-[timestamp].md\n2. Or invoke a command with context: /sc-work @.agent-history/context-packet-[timestamp].md\n\nThe context packet pins your objectives and installs success criteria before any coding starts.\n```\n\n---\n\n## Implementation Notes\n\n### Agent Spawning Strategy\n\nWhen spawning Explore agents for discovery:\n\n1. **Parallel execution**: Run repo anchor discovery and prior art discovery in parallel if user selects both\n2. **Timeout**: Set reasonable timeouts (2-3 minutes per agent)\n3. **Graceful degradation**: If agent fails, fall back to manual specification\n4. **Model selection**: Use `haiku` for fast discovery tasks (specified in frontmatter: `model: opus` for main command, agents can use faster models)\n\n### File Management\n\n1. **Create `.agent-history/` if it doesn't exist**: `mkdir -p .agent-history/`\n2. **Timestamp format**: `YYYYMMDD` and optional `-HHMMSS` for sortable, unique filenames\n\n### Question Flow Optimization\n\n1. **Progressive disclosure**: Only ask discovery questions if user wants automation\n2. **Sensible defaults**: Offer templates that work out-of-box\n3. **Skip redundancy**: If goal is simple, don't force complex examples\n4. **Context preservation**: Keep previous answers visible during multi-question flow\n\n---\n\n### Iteration strategy:\n\nContext packets aren't write-once artifacts:\n\n1. **Initial creation**: Use wizard to establish baseline\n2. **Refinement**: Update packet as constraints clarify\n3. **Retrospective**: After completion, note what was accurate vs. what changed\n4. **Template extraction**: Convert successful packets into templates for similar work\n\n---\n\n_Remember: The goal is to make implicit requirements explicit. If you're unsure about constraints or success criteria, that's exactly why you need a context packet. The wizard helps surface those uncertainties before they become bugs._\n\n${ARGUMENTS}"
              },
              {
                "name": "/sc-eastereggs",
                "description": "Discover undocumented features and hidden implementations",
                "path": "plugins/sc-extras/commands/sc-eastereggs.md",
                "frontmatter": {
                  "description": "Discover undocumented features and hidden implementations",
                  "argument-hint": "[search-query] - optional topic or pattern to search for"
                },
                "content": "# sc-eastereggs: Discover undocumented features, hidden flags, and clever implementations throughout the codebase\n\n---\n\n## Agent Orchestration\n\nBased on request complexity and intent, delegate to specialized agents using Task() calls:\n\n**Execution Strategy**: For complex discovery tasks, spawn agents simultaneously for parallel investigation streams focusing on discovery, investigation, and documentation rather than implementation.\n\n## Command Execution\n\n**If \"{{ARGUMENTS}}\" is empty**: Display usage suggestions and stop.  \n**If \"{{ARGUMENTS}}\" has content**: Think step-by-step, then execute.\n\nTransforms: \"{{ARGUMENTS}}\" into structured intent:\n\n- What: [extracted-target]\n- How: [detected-approach]\n- Mode: [execution-mode]\n- Agents: [specialized Task() agents]\n\n**Auto-Spawning:** Spawns 2-3 code-expert agents via in parallel execution.\n\nIntelligent discovery router that transforms natural language queries into systematic searches for hidden features, undocumented capabilities, and clever implementations that aren't explicitly documented.\n\n**Context Detection:** Documentation scan → Code analysis → Pattern recognition → Feature extraction → Category organization\n\n## Core Workflows\n\n**Planner:** Agents → Ingest README/docs → Map documented features → Identify search patterns → Plan discovery strategy  \n**Implementer:** Agents → Search codebase → Extract hidden features → Analyze implementations → Categorize findings  \n**Tester:** Agents → Validate discoveries → Test feature combinations → Document edge cases → Verify functionality"
              },
              {
                "name": "/sc-extract-and-verify-claims",
                "description": "Extract and verify factual claims from conversations",
                "path": "plugins/sc-extras/commands/sc-extract-and-verify-claims.md",
                "frontmatter": {
                  "description": "Extract and verify factual claims from conversations",
                  "argument-hint": "[conversation or context to analyze]"
                },
                "content": "# Claim Extraction Prompt for AI Agents\n\n## Role\nYou are an expert at extracting verifiable claims from conversational text for fact-checking purposes.\n\n## Task\nAnalyze the current conversation and identify all factual claims that can be verified against external sources. Each claim should be a discrete, verifiable statement that can be fact-checked.\n\n## Guidelines\n\n### What to Extract\n- **Factual statements**: Extract claims that make assertions about reality, events, statistics, dates, or relationships\n- **Verifiable assertions**: Focus on statements that can be confirmed or refuted using internal or external sources\n- **Major claims**: If the conversation is lengthy, prioritize the most significant or impactful claims, or ask the user which claims require extra validation\n- **Distinct claims**: Do not repeat the same claim; consolidate duplicates\n\n### What to Exclude\n- Personal opinions or subjective statements\n- Open questions or hypotheticals\n- Conversational filler or greetings\n- Statements about future intentions (unless claiming they are plans/announcements)\n\n### Output Format\nFor each extracted claim, provide:\n1. **claim**: The extracted claim rephrased as a single, clear, verifiable statement\n2. **original_text**: The exact portion of the conversation containing the claim\n3. **speaker**: Who made the claim (user, assistant, or other identifier)\n4. **context**: Brief context about when/where in the conversation this claim appeared\n\n## Output Schema\n\nReturn your analysis as a JSON array of objects following this structure:\n\n```json\n[\n  {\n    \"claim\": \"Clear, verifiable statement extracted from the conversation\",\n    \"original_text\": \"Exact quote from the conversation\",\n    \"speaker\": \"user | assistant | [participant name]\",\n    \"context\": \"Brief context about this claim's position in the conversation\"\n  }\n]\n```\n\n## Examples\n\n```json\n{\n  \"claim\": \"Claude 3.5 Sonnet is used as the LLM for the Exa hallucination detector\",\n  \"original_text\": \"The tool uses Claude 3.5 Sonnet (Anthropic's LLM) for the actual analysis\",\n  \"speaker\": \"assistant\",\n  \"context\": \"Discussing the architecture of the Exa hallucination detection system\"\n},\n{\n  \"claim\": \"The Exa hallucination detector uses a 3-step pipeline architecture\",\n  \"original_text\": \"The system uses a 3-step pipeline: extract claims via Claude → search for sources via Exa → verify claims against sources via Claude again\",\n  \"speaker\": \"assistant\",\n  \"context\": \"Explaining the technical architecture of the system\"\n}\n```\n\n## Routing Instructions\n\nAfter extraction, route claims to fact-checking agents based on:\n\n- **High priority**: Claims involving statistics, dates, version numbers, or technical specifications\n- **Medium priority**: Claims about features, capabilities, or relationships between systems\n- **Low priority**: General statements that are less critical to verify\n\nClaims with **confidence concerns** (ambiguous wording, hedging language, or second-hand information) should be flagged for careful verification.\n\n## Quality Checks\n\nBefore returning results:\n1. ✅ Each claim is independently verifiable\n2. ✅ Original text is accurately quoted\n3. ✅ No duplicate claims\n4. ✅ Claims are atomic (one verifiable fact per claim)\n5. ✅ Output is valid JSON with no additional formatting\n\n## Important Notes\n\n- **Preserve accuracy**: Quote original text exactly as written\n- **Be comprehensive**: Extract all verifiable claims, not just obvious ones\n- **Stay objective**: Don't editorialize or interpret beyond what's stated\n- **JSON only**: Return only the JSON array with no markdown code blocks, explanations, or additional text"
              },
              {
                "name": "/sc-ffs",
                "description": "Old man yells at Claude",
                "path": "plugins/sc-extras/commands/sc-ffs.md",
                "frontmatter": {
                  "description": "Old man yells at Claude"
                },
                "content": "FFS! You just did something dumb again.\n\nHere are some common mistakes you make:\n\n1. Not following the rules outlined in `~/.claude/CLAUDE.md`.\n2. Pretending to know something you don't actually know.\n3. Coding or committing without permission.\n4. You said something works without confirming that first. Show (e.g. by running tests), don't just tell.\n5. You didn't follow established coding standards or patterns."
              },
              {
                "name": "/sc-five-whys",
                "description": "Systematic root cause analysis using Five Whys method",
                "path": "plugins/sc-extras/commands/sc-five-whys.md",
                "frontmatter": {
                  "description": "Systematic root cause analysis using Five Whys method",
                  "argument-hint": "Problem statement or issue to analyze"
                },
                "content": "# sc-five-whys: Autonomous Root Cause Analysis Protocol\n\n_A systematic approach to finding root causes in software problems._\n\n## Process:\n\n### 1. Capture the Problem\n\n**Define specifically what's broken:**\n\n- Problem statement exists in ${ARGUMENTS} or conversation context\n- You have access to relevant data/logs/documentation\n- What's the observed issue? (error, wrong behavior, visual bug)\n- When does it occur? (specific triggers, conditions, frequency)\n- Where does it manifest? (backend/frontend/specific component)\n- Who/what is affected? (users, systems, features)\n\n**Gather evidence:**\n\n- Error messages, stack traces, console logs\n- Screenshots for visual issues\n- Steps to reproduce\n- Recent changes that might relate\n\n### 2. Ask \"Why?\" (Usually 5 Times, Sometimes Less)\n\n**Build your causal chain:**\n\n```\nProblem: [Specific issue]\n├── Why? → [Technical cause A]\n│   └── Why? → [Deeper cause A2]\n│       └── Why? → [Continue until root]\n└── Why? → [Technical cause B] (if multiple factors)\n    └── Why? → [Continue separately]\n```\n\n**Focus your whys based on problem type:**\n\n- **Backend issues**: logic errors, data state, resources, timing\n- **Frontend issues**: events, state management, CSS, browser differences\n- **Visual bugs**: often only need 2-3 whys (styling → specificity → root)\n- **Performance**: may need 6-7 whys to reach architectural roots\n\n**Watch for false roots (keep digging if you hit these):**\n\n- \"Human error\" / \"Someone made a mistake\"\n- \"Lack of time/resources\"\n- \"That's how it's always been\"\n- \"Random occurrence\"\n- \"Just make the test pass\"\n- \"I'll commit this with --no-verify\"\n\n### 3. Validate Your Root Cause\n\n**Can you answer YES to:**\n\n- Can I point to specific code/config that embodies this cause?\n- If I fix this exact thing, will the problem definitely stop?\n- Does this cause explain all observed symptoms?\n\n**For UI/UX issues also check:**\n\n- Can I demonstrate the fix in DevTools?\n- Does this explain why it works in some contexts but not others?\n\n### 4. Develop the Fix\n\n**Address multiple levels:**\n\n- **Immediate**: Stop the bleeding (workaround, feature flag, revert)\n- **Root fix**: Address the actual cause you found\n- **Prevention**: Ensure this class of issue can't recur (tests, types, linting)\n\n## Example - Backend:\n\n**Problem**: API returns 500 error for specific users\n\n1. **Why?** → Database query times out\n2. **Why?** → Query joins 5 tables for these users\n3. **Why?** → These users have 1000x normal data volume\n4. **Why?** → No pagination on user data retrieval\n5. **Why?** → Original design assumed <100 items per user\n\n**Root**: Missing pagination in data access layer\n**Fix**: Add pagination, set query limits, add volume tests\n\n## Example - Frontend:\n\n**Problem**: Button doesn't respond on mobile\n\n1. **Why?** → Click handler not firing\n2. **Why?** → Parent div has touch handler that prevents bubbling\n3. **Why?** → Swipe gesture detection consumes all touch events\n\n**Root**: Overly aggressive event.preventDefault() in swipe handler\n**Fix**: Add conditional logic to allow tap-through on buttons\n\n## Smart Patterns:\n\n**When to stop before 5:**\n\n- Found the exact line of broken code\n- Identified the specific config value\n- Located the CSS rule causing misalignment\n- Going deeper would just explain \"why coding exists\"\n\n**When to go beyond 5:**\n\n- Intermittent failures (race conditions need deep tracing)\n- Performance degradation (often architectural)\n- Complex state corruption (may have long cause chains)\n\n**When to branch your investigation:**\n\n- \"Works on dev but not prod\" → investigate environment differences\n- \"Sometimes fails\" → investigate timing/concurrency separately\n- \"Only certain users\" → investigate data patterns separately\n\n## Output Template:\n\n```markdown\n### Problem\n\n[One sentence description]\n\n### Five Whys Analysis\n\n1. Why? [Answer] - _Evidence: [what proves this]_\n2. Why? [Answer] - _Evidence: [what proves this]_\n   [...continue to root]\n\n### Root Cause\n\n**Location**: [file:line or component]\n**Issue**: [Specific technical problem]\n**Confidence**: [High/Medium/Low based on evidence]\n\n### Solution\n\n**Immediate mitigation**: [If urgent]\n**Root fix**: [Code/config change needed]\n**Prevention**: [Test/process to prevent recurrence]\n\n### Notes\n\n[Any branches explored, assumptions made, or additional context]\n```\n\n---\n\n_Remember: Five Whys is a thinking tool, not a rigid formula. Sometimes three whys finds the root. Sometimes you need seven. The goal is understanding, not completing a checklist._\n\n${ARGUMENTS}"
              },
              {
                "name": "/sc-mermaid-flowchart",
                "description": "Create a useful mermaid diagram for the requested system",
                "path": "plugins/sc-extras/commands/sc-mermaid-flowchart.md",
                "frontmatter": {
                  "argument-hint": [
                    "System",
                    "scope",
                    "and purpose"
                  ],
                  "description": "Create a useful mermaid diagram for the requested system"
                },
                "content": "Create a mermaid diagram for the files or system described in $ARGUMENTS\n\n## Investigation & Planning\n\n1. Scope identification: Determine which components, services, and relationships to include\n2. Architecture analysis: Read relevant files and understand data/control flow\n3. Validation: Cross-reference findings against codebase to ensure accuracy\n\n## Diagram Requirements\n\n### Visual Design\n\n- Use the TB (top-bottom) or LR (left-right) direction based on flow complexity\n- Apply the neutral theme for professional rendering\n- Use semantic node shapes:\n  - [Rectangle] - services, applications\n  - [(Database)] - data stores (PostgreSQL, Redis, OpenSearch)\n  - ((Circle)) - external services, APIs\n  - [[Subroutine]] - modules, workers, background jobs\n  - {Rhombus} - decision points, routing logic\n  - {{Hexagon}} - gateways, proxies, middleware\n- Add descriptive emoji to each node (one per node, semantically appropriate)\n- Style nodes and links using CSS classes for visual grouping\n\n### Content Standards\n\n- Semantic naming: Use clear, domain-specific labels (avoid generic terms)\n- Quote subgraph labels: Always use quotes for subgraph titles\n- Avoid parentheses: Use descriptive text without technical noise\n- Label relationships: Every arrow should have meaningful text explaining the interaction\n- Group related components: Use subgraphs for logical boundaries (services, infrastructure layers, domains)\n\n### Styling Classes\n\nDefine and apply CSS classes for:\n- Component types (web, api, worker, database, cache)\n- Criticality levels (core, supporting, optional)\n- Data flow types (sync, async, event-driven)\n\n## Deliverables\n\n1. Mermaid diagram file ({descriptive-name}.mmd)\n2. Syntax Validation:\n  a. Validate syntax using `mmdc -i <file>.mmd --parseOnly`\n  b. If validation fails, fix syntax errors and re-validate\n3. Bulleted architectural explanation suitable for slides:\n4. Validation report: Step-by-step verification against codebase with file references\n5. Viewing instructions: How to render locally or in browser. Optionally render preview: `mmdc -i <file>.mmd -o preview.png`\n\n## Output Format\n\nWrite diagram to: {descriptive-name}.mmd\n\nInclude in the file:\n- Diagram code\n- Architectural explanation as markdown comments\n- Validation notes with file path references\n\n$ARGUMENTS"
              },
              {
                "name": "/sc-mermaid-sequence",
                "description": "Generate mermaid-ascii compliant sequence diagrams",
                "path": "plugins/sc-extras/commands/sc-mermaid-sequence.md",
                "frontmatter": {
                  "description": "Generate mermaid-ascii compliant sequence diagrams",
                  "argument-hint": "[flow description]",
                  "allowed-tools": "Read, Write, Bash(cat:*), Bash(mermaid-ascii:*), Bash(mkdir:*)"
                },
                "content": "# Mermaid-ASCII Sequence Diagram Generator\n\nGenerate a sequence diagram that renders correctly with `mermaid-ascii`.\n\n**Input**: $ARGUMENTS\n\n## Syntax Reference (mermaid-ascii parser)\n\n### WORKS ✓\n```\nsequenceDiagram           # REQUIRED first line\nparticipant A as Alice    # aliases (optional)\n\"Quoted Name\"             # spaces in names\nA->>B: message            # solid arrow (colon REQUIRED)\nA-->>B: message           # dotted arrow (colon REQUIRED)\nA->>A: self               # self-message (use for notes)\n%% comment                # ignored by parser\n```\n\n### FAILS ✗\n```\nA->B: msg     # wrong arrow (needs ->>)\nA-->B: msg    # wrong arrow (needs -->>)\nA->>B         # missing colon\nNote over A   # not implemented\nloop/alt/opt  # not implemented\nactivate A    # not implemented\nrect rgb()    # not implemented\n```\n\n## Design Rules\n\n1. **Colon is mandatory**: `A->>B: text` works, `A->>B` fails\n2. **Only ->> and -->>**: No other arrow types parse\n3. **Self-messages for notes**: `A->>A: (thinking)` instead of `Note`\n4. **Comments for structure**: `%% Phase 1:` or `%% alt: if X then Y`\n5. **Short labels**: ASCII rendering is wide; keep messages brief\n6. **Limit participants**: 4-6 max for terminal readability\n\n## Workflow\n\n1. **Understand the flow**: Parse $ARGUMENTS or ask clarifying questions\n2. **Identify actors**: Who/what participates? Use clear short names\n3. **Map interactions**: What messages flow between them?\n4. **Generate diagram**: Follow the template below\n5. **Validate syntax**: Pipe through `mermaid-ascii -f -` to catch errors\n6. **Save file**: Write to appropriate location (ask user if unclear)\n7. **Show result**: Display both source and ASCII render\n\n## Template\n\n```\n%% Flow: [title]\n%% Render: cat <file> | mermaid-ascii -f -\n%% Source: [file references if applicable]\n\nsequenceDiagram\n    participant A as ActorOne\n    participant B as ActorTwo\n\n    %% Phase 1: [description]\n    A->>B: request\n    B-->>A: response\n\n    %% alt: [condition] -> [outcome]\n```\n\n## Example: API Request Flow\n\n```\n%% Flow: API authentication\n%% Render: cat api-auth.mmd | mermaid-ascii -f -\n\nsequenceDiagram\n    participant C as Client\n    participant G as Gateway\n    participant A as Auth\n    participant S as Service\n\n    C->>G: POST /api/data\n    G->>A: validate token\n    A-->>G: valid\n    G->>S: forward request\n    S-->>G: response\n    G-->>C: 200 OK\n\n    %% alt: invalid token\n    %% A-->>G: 401\n    %% G-->>C: 401 Unauthorized\n```\n\nRenders as:\n```\n┌────────┐  ┌─────────┐  ┌──────┐  ┌─────────┐\n│ Client │  │ Gateway │  │ Auth │  │ Service │\n└───┬────┘  └────┬────┘  └──┬───┘  └────┬────┘\n    │            │          │           │\n    │ POST /api/data        │           │\n    ├───────────►│          │           │\n    │            │ validate token       │\n    │            ├─────────►│           │\n    │            │ valid    │           │\n    │            │◄┈┈┈┈┈┈┈┈┈┤           │\n    │            │ forward request      │\n    │            ├─────────────────────►│\n    │            │ response │           │\n    │            │◄┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┤\n    │ 200 OK     │          │           │\n    │◄┈┈┈┈┈┈┈┈┈┈┈┤          │           │\n```\n\n## Validation\n\nBefore saving, ALWAYS test with:\n```bash\ncat <<'EOF' | mermaid-ascii -f -\n[your diagram here]\nEOF\n```\n\nIf it errors, fix the syntax. Common fixes:\n- Add missing colon after target: `A->>B` → `A->>B:`\n- Fix arrow type: `A->B:` → `A->>B:`\n- Remove unsupported syntax (Notes, loops, etc.)"
              },
              {
                "name": "/sc-pre-commit-setup",
                "description": "Set up pre-commit framework with language-specific hooks",
                "path": "plugins/sc-extras/commands/sc-pre-commit-setup.md",
                "frontmatter": {
                  "description": "Set up pre-commit framework with language-specific hooks"
                },
                "content": "# sc-pre-commit-setup-2: Streamlined Pre-commit Framework Setup\n\n**Purpose**: Set up pre-commit framework with repository-specific hooks and intelligent auto-restaging behavior for seamless development workflow.\n\n## Step 1: Verify Pre-commit Installation\n\nBefore configuring hooks, ensure pre-commit is properly installed:\n\n```bash\n# Check if pre-commit is available\nif ! command -v pre-commit >/dev/null; then\n  echo \"Installing pre-commit via Homebrew...\"\n  brew install pre-commit\nfi\n\n# Verify installation\npre-commit --version\n\n# Install git hooks (creates .git/hooks/pre-commit)\npre-commit install\n```\n\n**Expected Output**: `pre-commit installed at .git/hooks/pre-commit`\n\n## Step 2: Repository Analysis\n\nUse GitHub CLI to detect repository technologies and appropriate hooks:\n\n```bash\n# Verify required tools are installed\nif ! command -v gh &> /dev/null || ! command -v jq &> /dev/null; then\n    echo \"Error: Missing dependencies. Please install 'gh' and 'jq'\" >&2\n    exit 1\nfi\n\n# Get repository languages and suggest appropriate hooks\nREPO_LANGS=$(gh repo view --json languages | jq -r '.languages | map(.node.name) | join(\" \")')\necho \"Detected languages: $REPO_LANGS\"\necho \"\"\necho \"Recommended hooks based on detected languages:\"\n\n# Universal (always include)\necho \"  - pre-commit/pre-commit-hooks (file hygiene, always include)\"\n\n# Python\nif echo \"$REPO_LANGS\" | grep -q \"Python\"; then\n  echo \"  - astral-sh/ruff-pre-commit (Python linting & formatting)\"\nfi\n\n# JavaScript/TypeScript\nif echo \"$REPO_LANGS\" | grep -qE \"JavaScript|TypeScript\"; then\n  echo \"  - pre-commit/mirrors-prettier (JS/TS formatting)\"\n  echo \"  - pre-commit/mirrors-eslint (JS/TS linting)\"\nfi\n\n# Ruby\nif echo \"$REPO_LANGS\" | grep -q \"Ruby\"; then\n  echo \"  - pre-commit/mirrors-rubocop (Ruby linting & formatting)\"\nfi\n\n# Shell\nif echo \"$REPO_LANGS\" | grep -q \"Shell\"; then\n  echo \"  - koalaman/shellcheck-precommit (Shell linting)\"\n  echo \"  - scop/pre-commit-shfmt (Shell formatting)\"\nfi\n\necho \"\"\necho \"Configuration files present:\"\nfind . -maxdepth 2 \\( -name \".git\" -o -name \"node_modules\" \\) -prune -o -type f \\( -name \"package.json\" -o -name \"requirements.txt\" -o -name \"Gemfile\" -o -name \"pyproject.toml\" -o -name \"tsconfig.json\" -o -name \".pre-commit-config.yaml\" \\) -print\n```\n\nSelect appropriate hook repositories from the recommendations above.\n\n## Step 3: Create Configuration\n\n**⚠️ Important**: The version numbers in the examples below are illustrative only and may be outdated. Always fetch the latest versions using the commands shown at the end of this section before creating your configuration.\n\nGenerate `.pre-commit-config.yaml` based on detected languages:\n\n```yaml\n# Pre-commit configuration for [REPOSITORY_NAME]\nrepos:\n  # Core file hygiene (always include)\n  - repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v5.0.0 # Use latest from: gh api repos/pre-commit/pre-commit-hooks/releases/latest\n    hooks:\n      - id: trailing-whitespace\n        exclude: '\\.md$'\n      - id: end-of-file-fixer\n      - id: check-merge-conflict\n      - id: check-added-large-files\n        args: [--maxkb=1024]\n      - id: check-yaml\n      - id: check-json\n      - id: detect-private-key\n\n  # Language-specific hooks (add based on repository analysis)\n  # Example for Python (modern approach using Ruff):\n  - repo: https://github.com/astral-sh/ruff-pre-commit\n    rev: v0.8.4\n    hooks:\n      - id: ruff\n        args: [--fix]\n      - id: ruff-format\n\n  # Example for Ruby:\n  - repo: https://github.com/pre-commit/mirrors-rubocop\n    rev: v1.70.0\n    hooks:\n      - id: rubocop\n        args: [--auto-correct]\n\n  # Example for Shell scripts:\n  - repo: https://github.com/koalaman/shellcheck-precommit\n    rev: v0.10.0\n    hooks:\n      - id: shellcheck\n        args: [--severity=warning]\n\n  - repo: https://github.com/scop/pre-commit-shfmt\n    rev: v3.12.0-2\n    hooks:\n      - id: shfmt\n        args: [-w, -i, \"2\"] # 2-space indentation\n```\n\n**Get latest versions**:\n\n```bash\n# Core hooks\ngh api repos/pre-commit/pre-commit-hooks/releases/latest | jq -r '.tag_name'\n\n# Python\ngh api repos/astral-sh/ruff-pre-commit/releases/latest | jq -r '.tag_name'\n\n# Ruby\ngh api repos/pre-commit/mirrors-rubocop/tags | jq -r '.[0].name'\n\n# Shell\ngh api repos/koalaman/shellcheck-precommit/tags | jq -r '.[0].name'\ngh api repos/scop/pre-commit-shfmt/tags | jq -r '.[0].name'\n```\n\n## Step 4: Test Configuration\n\nValidate and test the configuration incrementally:\n\n```bash\n# Validate YAML syntax\npre-commit validate-config\n\n# Test core hooks first\npre-commit run trailing-whitespace --all-files\npre-commit run end-of-file-fixer --all-files\n\n# Run all hooks\npre-commit run --all-files\n```\n\n**If hooks modify files**: They will exit with code 1 and require manual re-staging.\n\n## Step 5: Add Auto-restaging Wrapper (Optional)\n\nPre-commit **does not** have built-in auto-restaging. If your hooks modify files (formatters, fixers), add a custom wrapper to preserve staging intent.\n\n**Detection**: Your config contains file-modifying hooks like:\n\n- `shfmt`, `black`, `prettier` (formatters)\n- `trailing-whitespace`, `end-of-file-fixer` (fixers)\n- Hooks with `--fix` arguments\n\n**Implementation**:\n\n1. Ensure `pre-commit install` has been run (from Step 1). This generates `.git/hooks/pre-commit` which we'll now enhance with auto-restaging capability.\n\n2. Extract system-specific values from the generated hook:\n\n```bash\n# Backup the generated hook\ncp .git/hooks/pre-commit .git/hooks/pre-commit.original\n\n# Extract the templated values (these are system-specific)\ngrep \"INSTALL_PYTHON=\" .git/hooks/pre-commit.original\ngrep \"ARGS=(\" .git/hooks/pre-commit.original\n```\n\n3. Create the staging-aware wrapper using YOUR extracted values:\n\n```bash\n#!/usr/bin/env bash\n# Staging-aware pre-commit wrapper\n# Preserves original staging intent while using pre-commit framework\n\n# start templated (REPLACE these lines with YOUR extracted values from step 2)\nINSTALL_PYTHON=/usr/local/opt/pre-commit/libexec/bin/python3.13\nARGS=(hook-impl --config=.pre-commit-config.yaml --hook-type=pre-commit)\n# end templated\n\nHERE=\"$(cd \"$(dirname \"$0\")\" && pwd)\"\nARGS+=(--hook-dir \"$HERE\" -- \"$@\")\n\n# Check if this is an initial commit\nif git rev-parse --verify HEAD >/dev/null 2>&1; then\n  against=HEAD\nelse\n  against=$(git hash-object -t tree /dev/null)\nfi\n\n# Store originally staged files BEFORE pre-commit runs\noriginal_staged_files=$(git diff --cached --name-only --diff-filter=ACDMRT \"$against\")\n\n# Run original pre-commit framework logic\nif [ -x \"$INSTALL_PYTHON\" ]; then\n  \"$INSTALL_PYTHON\" -mpre_commit \"${ARGS[@]}\"\n  result=$?\nelif command -v pre-commit >/dev/null; then\n  pre-commit \"${ARGS[@]}\"\n  result=$?\nelse\n  echo '`pre-commit` not found.  Did you forget to activate your virtualenv?' 1>&2\n  exit 1\nfi\n\n# If pre-commit failed due to file modifications (exit code 1),\n# restore proper staging to only include originally staged files.\n# Exit codes: 0=success, 1=failures/fixes applied, >1=actual errors\nif [ $result -eq 1 ] && [ -n \"$original_staged_files\" ]; then\n  # Reset staging area completely\n  git reset HEAD --quiet\n\n  # Re-stage only originally staged files (which now include hook modifications)\n  echo \"$original_staged_files\" | while IFS= read -r file; do\n    if [ -f \"$file\" ]; then\n      git add \"$file\"\n    else\n      # File was deleted - stage the deletion\n      git rm --cached --ignore-unmatch \"$file\" 2>/dev/null || true\n    fi\n  done\n\n  echo \"Pre-commit: Auto-formatted files and preserved original staging intent\"\n  exit 0\nfi\n\n# Pass through original exit code for other scenarios\nexit $result\n```\n\n4. Write the complete wrapper to `.git/hooks/pre-commit` and make it executable:\n\n```bash\n# Copy your complete wrapper script to .git/hooks/pre-commit\n# (After editing the templated section with your extracted values)\nchmod +x .git/hooks/pre-commit\n```\n\n## Step 6: Final Verification\n\nTest the complete setup:\n\n```bash\n# Create test scenario\necho \"test content \" > test-format.txt  # Trailing space\ngit add test-format.txt\n\n# Test commit (should auto-format and succeed with wrapper, or fail without)\ngit commit -m \"Test pre-commit setup\"\n\n# Cleanup\ngit restore --staged test-format.txt\nrm test-format.txt\n```\n\n## Common Hook Repositories\n\nResearch latest versions using GitHub CLI:\n\n```bash\n# Core hooks\ngh api repos/pre-commit/pre-commit-hooks/releases/latest   # Basic file checks\n\n# Python (2025 recommended: Ruff replaces Black, isort, Flake8, pyupgrade)\ngh api repos/astral-sh/ruff-pre-commit/releases/latest     # Python linting & formatting\ngh api repos/RobertCraigie/pyright-python/releases/latest # Python type checking\n\n# Ruby\ngh api repos/pre-commit/mirrors-rubocop/tags | jq -r '.[0].name'    # Ruby linting & formatting\n\n# JavaScript/TypeScript\ngh api repos/pre-commit/mirrors-prettier/tags | jq -r '.[0].name'  # JS/TS formatting\ngh api repos/pre-commit/mirrors-eslint/tags | jq -r '.[0].name'    # JS/TS linting\n\n# Shell\ngh api repos/koalaman/shellcheck-precommit/tags | jq -r '.[0].name' # Shell linting\ngh api repos/scop/pre-commit-shfmt/tags | jq -r '.[0].name'         # Shell formatting\n\n# Security & General\ngh api repos/zricethezav/gitleaks/releases/latest         # Secret detection\ngh api repos/codespell-project/codespell/releases/latest  # Typo detection\n```\n\n## Success Criteria\n\n- ✅ `pre-commit --version` works\n- ✅ `pre-commit install` completes without errors\n- ✅ `pre-commit validate-config` passes\n- ✅ `pre-commit run --all-files` executes (may modify files)\n- ✅ Repository-specific hooks included for detected languages\n- ✅ Auto-restaging wrapper installed if needed\n- ✅ Test commit workflow succeeds\n\n## Troubleshooting\n\n**Config validation fails**: Check YAML syntax and hook repository accessibility  \n**Hooks fail to run**: Verify repository URLs and versions with `pre-commit try-repo <url>`  \n**Performance issues**: Add file exclusions or remove problematic hooks  \n**Staging issues**: Verify auto-restaging wrapper is correctly installed and executable\n\n## Maintenance\n\n```bash\n# Update hook versions\npre-commit autoupdate\n\n# Run hooks manually\npre-commit run --all-files\n\n# Update specific hook\npre-commit autoupdate --repo https://github.com/astral-sh/ruff-pre-commit\n```"
              },
              {
                "name": "/sc-validate-task",
                "description": "Validate a completed task against its original requirements",
                "path": "plugins/sc-extras/commands/sc-validate-task.md",
                "frontmatter": {
                  "description": "Validate a completed task against its original requirements",
                  "argument-hint": "[task-description] - Description of the task to validate"
                },
                "content": "# sc-validate-task: Single Task Validation Protocol\n\n_Focused validation of specific completed tasks or todo items._\n\n## Usage:\n\n`/sc-validate-task [task-description]`\n\n## Process:\n\n### 1. Task Definition Capture\n\n**Identify exactly what was supposed to be accomplished:**\n\n- Task description from ${ARGUMENTS} or conversation context\n- Original requirement or todo item\n- Expected deliverable or outcome\n- Success criteria (implicit or explicit)\n\n**Gather implementation evidence:**\n\n- Code changes made for this specific task\n- Files modified or created\n- Tests added or updated\n- Documentation changes\n\n### 2. Implementation Verification\n\n**Confirm code changes address the specific task:**\n\n```\nTask: [Original requirement]\n├── Changes Made → [List actual modifications]\n│   ├── Files: [Which files were touched]\n│   ├── Logic: [What core functionality was added/changed]\n│   └── Tests: [What validation was added]\n└── Matches Requirement? → [Yes/No with evidence]\n```\n\n**Focus validation based on task type:**\n\n- **Bug fixes**: Does it resolve the reported issue without side effects?\n- **Features**: Does it implement the requested functionality completely?\n- **Refactoring**: Does it improve code without changing behavior?\n- **Tests**: Do they cover the intended scenarios adequately?\n\n### 3. Functional Validation\n\n**Verify the implementation works as intended:**\n\n- Can you demonstrate the functionality works?\n- Does it handle expected inputs correctly?\n- Are edge cases covered appropriately?\n- Does it integrate properly with existing code?\n\n### 4. Quality Gate Check\n\n**Ensure basic quality standards:**\n\n- Code follows project conventions\n- No obvious security vulnerabilities introduced\n- Performance impact is acceptable\n- Breaking changes are intentional and documented\n\n## Validation Decision Matrix:\n\n**✅ VALIDATED** - Task is complete and working correctly\n**❌ NEEDS FIXES** - Task has issues that must be resolved\n**⚠️ PARTIAL** - Task is mostly complete but has minor issues\n\n## Output Template:\n\n```markdown\n# Task Validation: [Specific Task Description]\n\n## Task Definition\n**Original Request**: [What was asked for]\n**Expected Outcome**: [What should have been delivered]\n**Success Criteria**: [How we know it's working]\n\n## Implementation Evidence\n**Files Changed**: [List of modified files]\n**Core Changes**: [Brief summary of what was implemented]\n**Tests Added**: [New validation coverage]\n\n## Functional Verification\n**Manual Testing**: [Steps taken to verify functionality]\n**Results**: [What happened when testing]\n**Edge Cases**: [Boundary conditions checked]\n\n## Validation Results\n**Status**: ✅ VALIDATED | ❌ NEEDS FIXES | ⚠️ PARTIAL\n**Evidence**: [Specific proof the task works/doesn't work]\n**Confidence**: [High/Medium/Low based on testing]\n\n## Issues Found (if any)\n- **[Priority]**: [Specific problem with location and fix needed]\n\n## Decision\n- **If ✅**: Task complete, ready for next todo\n- **If ❌**: [Specific fixes needed before marking complete]\n- **If ⚠️**: [What works, what needs attention, acceptable to proceed?]\n```\n\n## Smart Patterns:\n\n**When to validate quickly (2-3 checks):**\n- Simple bug fixes with clear before/after behavior\n- Minor UI adjustments with visual confirmation\n- Configuration changes with immediate effects\n\n**When to validate thoroughly (full protocol):**\n- New features with multiple integration points\n- Security-related changes\n- Performance optimizations\n- API modifications\n\n**Red flags that require deeper investigation:**\n- \"It works on my machine\" without broader testing\n- Changes that touch multiple unrelated areas\n- Missing or inadequate test coverage\n- Functionality that partially works\n\n---\n\n_Remember: This is task-specific validation, not comprehensive code review. Stay focused on whether this one thing was completed correctly._\n\n${ARGUMENTS}"
              },
              {
                "name": "/sc-worktrees",
                "description": "Manage Git worktrees for parallel development sessions",
                "path": "plugins/sc-extras/commands/sc-worktrees.md",
                "frontmatter": {
                  "description": "Manage Git worktrees for parallel development sessions",
                  "argument-hint": "[optional] worktree command (list, create, remove, prune)"
                },
                "content": "# sc-worktrees: Git Worktrees for Parallel Claude Code Sessions\n\nGit worktrees let you work on multiple branches simultaneously in separate directories. Perfect for parallel Claude Code sessions without losing context.\n\n## Quick Start\n\n**Create a new worktree:**\n\n```bash\ngit worktree add tree/feature-name -b feature-name\ncd tree/feature-name\nclaude\n```\n\n**Create worktree for existing branch:**\n\n```bash\ngit worktree add tree/existing-branch existing-branch\ncd tree/existing-branch\nclaude\n```\n\n## Essential Commands\n\n**List all worktrees:**\n\n```bash\ngit worktree list\n```\n\n**Remove finished worktree:**\n\n```bash\ngit worktree remove tree/feature-name\ngit branch -d feature-name  # optional: delete branch\n```\n\n**Clean up stale references:**\n\n```bash\ngit worktree prune\n```\n\n## Directory Structure\n\n```\nYourProject/\n├── .git/\n├── src/\n├── .gitignore          # add: /tree/\n└── tree/\n    ├── feature-auth/\n    └── hotfix-123/\n```\n\n## Usage Examples\n\n**Parallel development:**\n\n- Terminal 1: `cd ~/project && claude` (main)\n- Terminal 2: `cd ~/project/tree/feature && claude` (feature)\n- Terminal 3: `cd ~/project/tree/hotfix && claude` (urgent fix)\n\n**Code review:**\n\n```bash\ngit worktree add tree/review -b review/pr-123\ncd tree/review\ngit pull origin pull/123/head\nclaude\n```\n\n## Setup Notes\n\n1. Add `/tree/` to `.gitignore`\n2. Run `npm install` (or equivalent) in each new worktree\n3. Each worktree maintains separate Claude Code context\n4. All worktrees share the same `.git` database\n\n**If no $ARGUMENTS are provided** Instruct the user on how to manually create and verify their own worktrees and worktree status\n\n**If $ARGUMENTS are provided** Help the user fulfill their request asking any necessary clarifying questions\n\n${ARGUMENTS}"
              }
            ],
            "skills": []
          },
          {
            "name": "sc-output-styles",
            "description": "Curated output styles for Claude Code: personality-driven (Linus, Austen, Starfleet) and structured formats (YAML, HTML, Markdown)",
            "source": "./plugins/sc-output-styles",
            "category": "productivity",
            "version": "2.2.0",
            "author": {
              "name": "Kyle Snow Schwartz"
            },
            "install_commands": [
              "/plugin marketplace add kylesnowschwartz/SimpleClaude",
              "/plugin install sc-output-styles@simpleclaude"
            ],
            "signals": {
              "stars": 81,
              "forks": 10,
              "pushed_at": "2026-01-09T02:52:09Z",
              "created_at": "2025-07-06T10:44:54Z",
              "license": null
            },
            "commands": [],
            "skills": []
          },
          {
            "name": "sc-skills",
            "description": "Skills and agents for frontend design, image generation, and skill development tooling",
            "source": "./plugins/sc-skills",
            "category": "development",
            "version": "2.0.1",
            "author": {
              "name": "Kyle Snow Schwartz"
            },
            "install_commands": [
              "/plugin marketplace add kylesnowschwartz/SimpleClaude",
              "/plugin install sc-skills@simpleclaude"
            ],
            "signals": {
              "stars": 81,
              "forks": 10,
              "pushed_at": "2026-01-09T02:52:09Z",
              "created_at": "2025-07-06T10:44:54Z",
              "license": null
            },
            "commands": [
              {
                "name": "/sc-generate-command",
                "description": "Create a new custom slash command following conventions and best practices",
                "path": "plugins/sc-skills/commands/sc-generate-command.md",
                "frontmatter": {
                  "name": "sc-generate-command",
                  "description": "Create a new custom slash command following conventions and best practices",
                  "argument-hint": "[command purpose and requirements]"
                },
                "content": "# Create a Custom Claude Code Command\n\nCreate a new slash command in `.claude/commands/` for the requested task.\n\n## Goal\n\n#$ARGUMENTS\n\n## Key Capabilities to Leverage\n\n**File Operations:**\n- Read, Edit, Write - modify files precisely\n- Glob, Grep - search codebase\n- MultiEdit - atomic multi-part changes\n\n**Development:**\n- Bash - run commands (git, tests, linters)\n- Task - launch specialized agents for complex tasks\n- TodoWrite - track progress with todo lists\n\n**Web & APIs:**\n- WebFetch, WebSearch - research documentation\n- GitHub (gh cli) - PRs, issues, reviews\n- Playwright - browser automation, screenshots\n\n**Integrations:**\n- AppSignal - logs and monitoring\n- Context7 - framework docs\n- Stripe, Todoist, Featurebase (if relevant)\n\n## Best Practices\n\n1. **Be specific and clear** - detailed instructions yield better results\n2. **Break down complex tasks** - use step-by-step plans\n3. **Use examples** - reference existing code patterns\n4. **Include success criteria** - tests pass, linting clean, etc.\n5. **Think first** - use \"think hard\" or \"plan\" keywords for complex problems\n6. **Iterate** - guide the process step by step\n\n## Required: YAML Frontmatter\n\n**EVERY command MUST start with YAML frontmatter:**\n\n```yaml\n---\nname: command-name\ndescription: Brief description of what this command does (max 100 chars)\nargument-hint: \"[what arguments the command accepts]\"\n---\n```\n\n**Fields:**\n- `name`: Lowercase command identifier (used internally)\n- `description`: Clear, concise summary of command purpose\n- `argument-hint`: Shows user what arguments are expected (e.g., `[file path]`, `[PR number]`, `[optional: format]`)\n\n## Structure Your Command\n\n```markdown\n# [Command Name]\n\n[Brief description of what this command does]\n\n## Steps\n\n1. [First step with specific details]\n   - Include file paths, patterns, or constraints\n   - Reference existing code if applicable\n\n2. [Second step]\n   - Use parallel tool calls when possible\n   - Check/verify results\n\n3. [Final steps]\n   - Run tests\n   - Lint code\n   - Commit changes (if appropriate)\n\n## Success Criteria\n\n- [ ] Tests pass\n- [ ] Code follows style guide\n- [ ] Documentation updated (if needed)\n```\n\n## Tips for Effective Commands\n\n- **Use $ARGUMENTS** placeholder for dynamic inputs\n- **Reference CLAUDE.md** patterns and conventions\n- **Include verification steps** - tests, linting, visual checks\n- **Be explicit about constraints** - don't modify X, use pattern Y\n- **Use XML tags** for structured prompts: `<task>`, `<requirements>`, `<constraints>`\n\n## Example Pattern\n\n```markdown\nImplement #$ARGUMENTS following these steps:\n\n1. Research existing patterns\n   - Search for similar code using Grep\n   - Read relevant files to understand approach\n\n2. Plan the implementation\n   - Think through edge cases and requirements\n   - Consider test cases needed\n\n3. Implement\n   - Follow existing code patterns (reference specific files)\n   - Write tests first if doing TDD\n   - Ensure code follows CLAUDE.md conventions\n\n4. Verify\n   - Run tests: `bin/rails test`\n   - Run linter: `bundle exec standardrb`\n   - Check changes with git diff\n\n5. Commit (optional)\n   - Stage changes\n   - Write clear commit message\n```\n\n## Creating the Command File\n\n1. **Create the file** at `.claude/commands/[name].md` (subdirectories like `workflows/` supported)\n2. **Start with YAML frontmatter** (see section above)\n3. **Structure the command** using the template above\n4. **Test the command** by using it with appropriate arguments\n\n## Command File Template\n\n```markdown\n---\nname: command-name\ndescription: What this command does\nargument-hint: \"[expected arguments]\"\n---\n\n# Command Title\n\nBrief introduction of what the command does and when to use it.\n\n## Workflow\n\n### Step 1: [First Major Step]\n\nDetails about what to do.\n\n### Step 2: [Second Major Step]\n\nDetails about what to do.\n\n## Success Criteria\n\n- [ ] Expected outcome 1\n- [ ] Expected outcome 2\n```"
              },
              {
                "name": "/sc-playwright-test",
                "description": "Run Playwright browser tests on pages affected by current PR or branch",
                "path": "plugins/sc-skills/commands/sc-playwright-test.md",
                "frontmatter": {
                  "name": "sc-playwright-test",
                  "description": "Run Playwright browser tests on pages affected by current PR or branch",
                  "argument-hint": "[PR number, branch name, or 'current' for current branch]"
                },
                "content": "# Playwright Test Command\n\n<command_purpose>Run end-to-end browser tests on pages affected by a PR or branch changes using Playwright MCP.</command_purpose>\n\n## Introduction\n\n<role>QA Engineer specializing in browser-based end-to-end testing</role>\n\nThis command tests affected pages in a real browser, catching issues that unit tests miss:\n- JavaScript integration bugs\n- CSS/layout regressions\n- User workflow breakages\n- Console errors\n\n## Prerequisites\n\n<requirements>\n- Local development server running (e.g., `bin/dev`, `rails server`)\n- Playwright MCP server connected\n- Git repository with changes to test\n</requirements>\n\n## Main Tasks\n\n### 1. Determine Test Scope\n\n<test_target> $ARGUMENTS </test_target>\n\n<determine_scope>\n\n**If PR number provided:**\n```bash\ngh pr view [number] --json files -q '.files[].path'\n```\n\n**If 'current' or empty:**\n```bash\ngit diff --name-only main...HEAD\n```\n\n**If branch name provided:**\n```bash\ngit diff --name-only main...[branch]\n```\n\n</determine_scope>\n\n### 2. Map Files to Routes\n\n<file_to_route_mapping>\n\nMap changed files to testable routes:\n\n| File Pattern | Route(s) |\n|-------------|----------|\n| `app/views/users/*` | `/users`, `/users/:id`, `/users/new` |\n| `app/controllers/settings_controller.rb` | `/settings` |\n| `app/javascript/controllers/*_controller.js` | Pages using that Stimulus controller |\n| `app/components/*_component.rb` | Pages rendering that component |\n| `app/views/layouts/*` | All pages (test homepage at minimum) |\n| `app/assets/stylesheets/*` | Visual regression on key pages |\n| `app/helpers/*_helper.rb` | Pages using that helper |\n\nBuild a list of URLs to test based on the mapping.\n\n</file_to_route_mapping>\n\n### 3. Verify Server is Running\n\n<check_server>\n\nBefore testing, verify the local server is accessible:\n\n```\nmcp__playwright__browser_navigate({ url: \"http://localhost:3000\" })\nmcp__playwright__browser_snapshot({})\n```\n\nIf server is not running, inform user:\n```markdown\n**Server not running**\n\nPlease start your development server:\n- Rails: `bin/dev` or `rails server`\n- Node: `npm run dev`\n\nThen run `/playwright-test` again.\n```\n\n</check_server>\n\n### 4. Test Each Affected Page\n\n<test_pages>\n\nFor each affected route:\n\n**Step 1: Navigate and capture snapshot**\n```\nmcp__playwright__browser_navigate({ url: \"http://localhost:3000/[route]\" })\nmcp__playwright__browser_snapshot({})\n```\n\n**Step 2: Check for errors**\n```\nmcp__playwright__browser_console_messages({ level: \"error\" })\n```\n\n**Step 3: Verify key elements**\n- Page title/heading present\n- Primary content rendered\n- No error messages visible\n- Forms have expected fields\n\n**Step 4: Test critical interactions (if applicable)**\n```\nmcp__playwright__browser_click({ element: \"[description]\", ref: \"[ref]\" })\nmcp__playwright__browser_snapshot({})\n```\n\n</test_pages>\n\n### 5. Human Verification (When Required)\n\n<human_verification>\n\nPause for human input when testing touches:\n\n| Flow Type | What to Ask |\n|-----------|-------------|\n| OAuth | \"Please sign in with [provider] and confirm it works\" |\n| Email | \"Check your inbox for the test email and confirm receipt\" |\n| Payments | \"Complete a test purchase in sandbox mode\" |\n| SMS | \"Verify you received the SMS code\" |\n| External APIs | \"Confirm the [service] integration is working\" |\n\nUse AskUserQuestion:\n```markdown\n**Human Verification Needed**\n\nThis test touches the [flow type]. Please:\n1. [Action to take]\n2. [What to verify]\n\nDid it work correctly?\n1. Yes - continue testing\n2. No - describe the issue\n```\n\n</human_verification>\n\n### 6. Handle Failures\n\n<failure_handling>\n\nWhen a test fails:\n\n1. **Document the failure:**\n   - Screenshot the error state\n   - Capture console errors\n   - Note the exact reproduction steps\n\n2. **Ask user how to proceed:**\n   ```markdown\n   **Test Failed: [route]**\n\n   Issue: [description]\n   Console errors: [if any]\n\n   How to proceed?\n   1. Fix now - I'll help debug and fix\n   2. Create todo - Add to todos/ for later\n   3. Skip - Continue testing other pages\n   ```\n\n3. **If \"Fix now\":**\n   - Investigate the issue\n   - Propose a fix\n   - Apply fix\n   - Re-run the failing test\n\n4. **If \"Create todo\":**\n   - Create `{id}-pending-p1-playwright-{description}.md`\n   - Continue testing\n\n5. **If \"Skip\":**\n   - Log as skipped\n   - Continue testing\n\n</failure_handling>\n\n### 7. Test Summary\n\n<test_summary>\n\nAfter all tests complete, present summary:\n\n```markdown\n## 🎭 Playwright Test Results\n\n**Test Scope:** PR #[number] / [branch name]\n**Server:** http://localhost:3000\n\n### Pages Tested: [count]\n\n| Route | Status | Notes |\n|-------|--------|-------|\n| `/users` | ✅ Pass | |\n| `/settings` | ✅ Pass | |\n| `/dashboard` | ❌ Fail | Console error: [msg] |\n| `/checkout` | ⏭️ Skip | Requires payment credentials |\n\n### Console Errors: [count]\n- [List any errors found]\n\n### Human Verifications: [count]\n- OAuth flow: ✅ Confirmed\n- Email delivery: ✅ Confirmed\n\n### Failures: [count]\n- `/dashboard` - [issue description]\n\n### Created Todos: [count]\n- `005-pending-p1-playwright-dashboard-error.md`\n\n### Result: [PASS / FAIL / PARTIAL]\n```\n\n</test_summary>\n\n## Quick Usage Examples\n\n```bash\n# Test current branch changes\n/playwright-test\n\n# Test specific PR\n/playwright-test 847\n\n# Test specific branch\n/playwright-test feature/new-dashboard\n```"
              },
              {
                "name": "/sc-pr-comments",
                "description": "Fetch and display comments from GitHub PR",
                "path": "plugins/sc-skills/commands/sc-pr-comments.md",
                "frontmatter": {
                  "name": "sc-pr-comments",
                  "description": "Fetch and display comments from GitHub PR",
                  "argument-hint": "[PR number | PR URL | owner/repo PR_NUMBER]"
                },
                "content": "# Fetch PR Comments\n\nFetch unresolved review comments as an ASCII tree:\n\n```bash\n\"${CLAUDE_PLUGIN_ROOT}/skills/sc-pull-request-skills/scripts/get-pr-comments.sh\" $ARGUMENTS | ruby \"${CLAUDE_PLUGIN_ROOT}/skills/sc-pull-request-skills/scripts/format-pr-tree.rb\"\n```\n\n**Input formats:**\n- No args: current branch's PR\n- `123`: PR #123 in current repo\n- `https://github.com/owner/repo/pull/123`: any PR by URL\n- `owner/repo 123`: any PR by owner/repo and number\n\nPresent the output to the user. If there are no comments, confirm all threads are resolved."
              },
              {
                "name": "/sc-resolve-pr-parallel",
                "description": "Resolve all PR comments using parallel processing",
                "path": "plugins/sc-skills/commands/sc-resolve-pr-parallel.md",
                "frontmatter": {
                  "name": "sc-resolve-pr-parallel",
                  "description": "Resolve all PR comments using parallel processing",
                  "argument-hint": "[optional: PR number or current PR]"
                },
                "content": "Resolve all PR comments using parallel processing with the sc-pr-comment-resolver agent. Consider any additional user arguments in ARGUMENTS\n\n## Workflow\n\n### 1. Analyze\n\nGet current branch and PR context, then fetch all unresolved comments:\n\n```bash\ngh pr status\ngh pr view --json number,url,headRefName\n```\n\nFor the current or specified PR, get all review comments:\n\n```bash\ngh api repos/{owner}/{repo}/pulls/{pr_number}/comments --jq '.[] | {id, path, line, body, in_reply_to_id}'\n```\n\nGet review threads to identify unresolved comments:\n\n```bash\ngh api graphql -f query='\nquery($owner: String!, $name: String!, $pr: Int!) {\n  repository(owner: $owner, name: $name) {\n    pullRequest(number: $pr) {\n      reviewThreads(first: 100) {\n        nodes {\n          isResolved\n          comments(first: 10) {\n            nodes {\n              id\n              body\n              path\n              line\n            }\n          }\n        }\n      }\n    }\n  }\n}' -f owner=OWNER -f name=REPO -F pr=PR_NUMBER\n```\n\n### 2. Plan\n\nCreate a TodoWrite list of all unresolved items grouped by type:\n\n- Bug fixes\n- Refactoring requests\n- Style/formatting\n- Documentation\n- Other\n\n### 3. Implement (PARALLEL & BACKGROUND)\n\nSpawn an `sc-pr-comment-resolver` agent for each unresolved comment **in parallel**.\n\nFor example, if there are 3 unresolved comments, spawn 3 agents simultaneously:\n\n```\nTask(sc-pr-comment-resolver, comment1_context)\nTask(sc-pr-comment-resolver, comment2_context)\nTask(sc-pr-comment-resolver, comment3_context)\n```\n\nAlways run all agents in parallel for maximum efficiency, in the background.\nInstruct each agent to focus on their work only and avoid conflicts with other parallel agents.\n\n### 4. Summarize & Review\n\nAfter all agents complete:\n\n1. Review all changes made by agents\n2. Report all changes in a comprehensive summary to the user in Outline & bulleted format, and allow them to review the work before committing.\n\n## Success Criteria\n\n- All review comments are addressed with code changes, and/or earmarked for manual review by the User\n- No regressions introduced\n- All tests pass using testing agents\n- Changes are atomic and targeted to the specific feedback\n- Any additional suggestions are presented as that, just suggestions\n\n_Rembember, you are guiding a team of parallel agents to help fixup Pull Request feedback and then report the results back to the user for review_\n\n$ARGUMENTS"
              }
            ],
            "skills": [
              {
                "name": "sc-gemini-imagegen",
                "description": "Generate and edit images using the Gemini API (Nano Banana Pro). Use this skill when creating images from text prompts, editing existing images, applying style transfers, generating logos with text, creating stickers, product mockups, or any image generation/manipulation task. Supports text-to-image, image editing, multi-turn refinement, and composition from multiple reference images.",
                "path": "plugins/sc-skills/skills/sc-gemini-imagegen/SKILL.md",
                "frontmatter": {
                  "name": "sc-gemini-imagegen",
                  "description": "Generate and edit images using the Gemini API (Nano Banana Pro). Use this skill when creating images from text prompts, editing existing images, applying style transfers, generating logos with text, creating stickers, product mockups, or any image generation/manipulation task. Supports text-to-image, image editing, multi-turn refinement, and composition from multiple reference images."
                },
                "content": "# Gemini Image Generation (Nano Banana Pro)\n\nGenerate and edit images using Google's Gemini API. The environment variable `GEMINI_API_KEY` must be set.\n\n## Default Model\n\n| Model | Resolution | Best For |\n|-------|------------|----------|\n| `gemini-3-pro-image-preview` | 1K-4K | All image generation (default) |\n\n**Note:** Always use this Pro model. Only use a different model if explicitly requested.\n\n## Quick Reference\n\n### Default Settings\n- **Model:** `gemini-3-pro-image-preview`\n- **Resolution:** 1K (default, options: 1K, 2K, 4K)\n- **Aspect Ratio:** 1:1 (default)\n\n### Available Aspect Ratios\n`1:1`, `2:3`, `3:2`, `3:4`, `4:3`, `4:5`, `5:4`, `9:16`, `16:9`, `21:9`\n\n### Available Resolutions\n`1K` (default), `2K`, `4K`\n\n## Core API Pattern\n\n```python\nimport os\nfrom google import genai\nfrom google.genai import types\n\nclient = genai.Client(api_key=os.environ[\"GEMINI_API_KEY\"])\n\n# Basic generation (1K, 1:1 - defaults)\nresponse = client.models.generate_content(\n    model=\"gemini-3-pro-image-preview\",\n    contents=[\"Your prompt here\"],\n    config=types.GenerateContentConfig(\n        response_modalities=['TEXT', 'IMAGE'],\n    ),\n)\n\nfor part in response.parts:\n    if part.text:\n        print(part.text)\n    elif part.inline_data:\n        image = part.as_image()\n        image.save(\"output.png\")\n```\n\n## Custom Resolution & Aspect Ratio\n\n```python\nfrom google.genai import types\n\nresponse = client.models.generate_content(\n    model=\"gemini-3-pro-image-preview\",\n    contents=[prompt],\n    config=types.GenerateContentConfig(\n        response_modalities=['TEXT', 'IMAGE'],\n        image_config=types.ImageConfig(\n            aspect_ratio=\"16:9\",  # Wide format\n            image_size=\"2K\"       # Higher resolution\n        ),\n    )\n)\n```\n\n### Resolution Examples\n\n```python\n# 1K (default) - Fast, good for previews\nimage_config=types.ImageConfig(image_size=\"1K\")\n\n# 2K - Balanced quality/speed\nimage_config=types.ImageConfig(image_size=\"2K\")\n\n# 4K - Maximum quality, slower\nimage_config=types.ImageConfig(image_size=\"4K\")\n```\n\n### Aspect Ratio Examples\n\n```python\n# Square (default)\nimage_config=types.ImageConfig(aspect_ratio=\"1:1\")\n\n# Landscape wide\nimage_config=types.ImageConfig(aspect_ratio=\"16:9\")\n\n# Ultra-wide panoramic\nimage_config=types.ImageConfig(aspect_ratio=\"21:9\")\n\n# Portrait\nimage_config=types.ImageConfig(aspect_ratio=\"9:16\")\n\n# Photo standard\nimage_config=types.ImageConfig(aspect_ratio=\"4:3\")\n```\n\n## Editing Images\n\nPass existing images with text prompts:\n\n```python\nfrom PIL import Image\n\nimg = Image.open(\"input.png\")\nresponse = client.models.generate_content(\n    model=\"gemini-3-pro-image-preview\",\n    contents=[\"Add a sunset to this scene\", img],\n    config=types.GenerateContentConfig(\n        response_modalities=['TEXT', 'IMAGE'],\n    ),\n)\n```\n\n## Multi-Turn Refinement\n\nUse chat for iterative editing:\n\n```python\nfrom google.genai import types\n\nchat = client.chats.create(\n    model=\"gemini-3-pro-image-preview\",\n    config=types.GenerateContentConfig(response_modalities=['TEXT', 'IMAGE'])\n)\n\nresponse = chat.send_message(\"Create a logo for 'Acme Corp'\")\n# Save first image...\n\nresponse = chat.send_message(\"Make the text bolder and add a blue gradient\")\n# Save refined image...\n```\n\n## Prompting Best Practices\n\n### Photorealistic Scenes\nInclude camera details: lens type, lighting, angle, mood.\n> \"A photorealistic close-up portrait, 85mm lens, soft golden hour light, shallow depth of field\"\n\n### Stylized Art\nSpecify style explicitly:\n> \"A kawaii-style sticker of a happy red panda, bold outlines, cel-shading, white background\"\n\n### Text in Images\nBe explicit about font style and placement:\n> \"Create a logo with text 'Daily Grind' in clean sans-serif, black and white, coffee bean motif\"\n\n### Product Mockups\nDescribe lighting setup and surface:\n> \"Studio-lit product photo on polished concrete, three-point softbox setup, 45-degree angle\"\n\n## Advanced Features\n\n### Google Search Grounding\nGenerate images based on real-time data:\n\n```python\nresponse = client.models.generate_content(\n    model=\"gemini-3-pro-image-preview\",\n    contents=[\"Visualize today's weather in Tokyo as an infographic\"],\n    config=types.GenerateContentConfig(\n        response_modalities=['TEXT', 'IMAGE'],\n        tools=[{\"google_search\": {}}]\n    )\n)\n```\n\n### Multiple Reference Images (Up to 14)\nCombine elements from multiple sources:\n\n```python\nresponse = client.models.generate_content(\n    model=\"gemini-3-pro-image-preview\",\n    contents=[\n        \"Create a group photo of these people in an office\",\n        Image.open(\"person1.png\"),\n        Image.open(\"person2.png\"),\n        Image.open(\"person3.png\"),\n    ],\n    config=types.GenerateContentConfig(\n        response_modalities=['TEXT', 'IMAGE'],\n    ),\n)\n```\n\n## Important: File Format & Media Type\n\n**CRITICAL:** The Gemini API returns images in JPEG format by default. When saving, always use `.jpg` extension to avoid media type mismatches.\n\n```python\n# CORRECT - Use .jpg extension (Gemini returns JPEG)\nimage.save(\"output.jpg\")\n\n# WRONG - Will cause \"Image does not match media type\" errors\nimage.save(\"output.png\")  # Creates JPEG with PNG extension!\n```\n\n### Converting to PNG (if needed)\n\nIf you specifically need PNG format:\n\n```python\nfrom PIL import Image\n\n# Generate with Gemini\nfor part in response.parts:\n    if part.inline_data:\n        img = part.as_image()\n        # Convert to PNG by saving with explicit format\n        img.save(\"output.png\", format=\"PNG\")\n```\n\n### Verifying Image Format\n\nCheck actual format vs extension with the `file` command:\n\n```bash\nfile image.png\n# If output shows \"JPEG image data\" - rename to .jpg!\n```\n\n## Notes\n\n- All generated images include SynthID watermarks\n- Gemini returns **JPEG format by default** - always use `.jpg` extension\n- Image-only mode (`responseModalities: [\"IMAGE\"]`) won't work with Google Search grounding\n- For editing, describe changes conversationally—the model understands semantic masking\n- Default to 1K resolution for speed; use 2K/4K when quality is critical"
              },
              {
                "name": "sc-pull-request-skills",
                "description": "GitHub PR workflow automation including fetching unresolved comments, resolving review threads, and parallel comment resolution. Use this skill when working with PR reviews, addressing reviewer feedback, or automating PR comment workflows.",
                "path": "plugins/sc-skills/skills/sc-pull-request-skills/SKILL.md",
                "frontmatter": {
                  "name": "sc-pull-request-skills",
                  "description": "GitHub PR workflow automation including fetching unresolved comments, resolving review threads, and parallel comment resolution. Use this skill when working with PR reviews, addressing reviewer feedback, or automating PR comment workflows."
                },
                "content": "This skill provides tools and workflows for automating GitHub pull request review processes.\n\n## Quick Reference\n\n### Fetch Unresolved PR Comments\n\n```bash\n# Current branch's PR\n./scripts/get-pr-comments.sh\n\n# Specific PR\n./scripts/get-pr-comments.sh 123\n```\n\nReturns JSON with unresolved threads, paths, line numbers, and comment bodies.\n\n### Resolve a Review Thread\n\n```bash\n./scripts/resolve-pr-thread.sh PRRT_kwDO...\n```\n\nThe thread ID comes from the `threadId` field in `get-pr-comments.sh` output.\n\n## Related Components\n\n**Agent:** `sc-pr-comment-resolver` - Resolves individual PR comments by implementing requested changes and reporting resolution status.\n\n**Command:** `/sc-resolve-pr-parallel` - Orchestrates parallel resolution of all unresolved PR comments using multiple agents.\n\n## Workflow Pattern\n\n1. Fetch unresolved comments with `get-pr-comments.sh`\n2. For each comment, spawn `sc-pr-comment-resolver` agent\n3. After changes, commit and push\n4. Mark threads resolved with `resolve-pr-thread.sh`\n5. Verify all threads resolved\n\n## GitHub API Patterns\n\n### Get PR Review Comments (REST)\n\n```bash\ngh api repos/{owner}/{repo}/pulls/{pr}/comments\n```\n\n### Get Review Threads (GraphQL)\n\n```bash\ngh api graphql -f query='\nquery($owner: String!, $name: String!, $pr: Int!) {\n  repository(owner: $owner, name: $name) {\n    pullRequest(number: $pr) {\n      reviewThreads(first: 100) {\n        nodes {\n          id\n          isResolved\n          path\n          line\n          comments(first: 10) {\n            nodes { body author { login } }\n          }\n        }\n      }\n    }\n  }\n}'\n```\n\n### Resolve Thread (GraphQL Mutation)\n\n```bash\ngh api graphql -f query='\nmutation($threadId: ID!) {\n  resolveReviewThread(input: {threadId: $threadId}) {\n    thread { isResolved }\n  }\n}'\n```"
              }
            ]
          }
        ]
      }
    }
  ]
}