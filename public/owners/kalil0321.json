{
  "owner": {
    "id": "kalil0321",
    "display_name": "kalil0321",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/92564081?u=c6db0bd0a6a94ffeb38ddcd6b42b6c1bc8ea86c7&v=4",
    "url": "https://github.com/kalil0321",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 4,
      "total_skills": 1,
      "total_stars": 264,
      "total_forks": 16
    }
  },
  "repos": [
    {
      "full_name": "kalil0321/reverse-api-engineer",
      "url": "https://github.com/kalil0321/reverse-api-engineer",
      "description": "Claude engineer that captures traffic, writes documentation and automatically generates API clients. Reverse engineer APIs!",
      "homepage": "",
      "signals": {
        "stars": 264,
        "forks": 16,
        "pushed_at": "2026-01-10T19:01:15Z",
        "created_at": "2025-12-23T14:04:45Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 322
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 1025
        },
        {
          "path": ".python-version",
          "type": "blob",
          "size": 5
        },
        {
          "path": "CHANGELOG.md",
          "type": "blob",
          "size": 9711
        },
        {
          "path": "CLAUDE.md",
          "type": "blob",
          "size": 8314
        },
        {
          "path": "CONTRIBUTING.md",
          "type": "blob",
          "size": 987
        },
        {
          "path": "INTERVIEW.md",
          "type": "blob",
          "size": 324
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1066
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 12404
        },
        {
          "path": "RELEASING.md",
          "type": "blob",
          "size": 1264
        },
        {
          "path": "assets",
          "type": "tree",
          "size": null
        },
        {
          "path": "assets/reverse-api-banner.svg",
          "type": "blob",
          "size": 3034
        },
        {
          "path": "assets/reverse-api-engineer.gif",
          "type": "blob",
          "size": 5691347
        },
        {
          "path": "assets/reverse-api-logo.svg",
          "type": "blob",
          "size": 1449
        },
        {
          "path": "examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/apple",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/apple/INDEX.md",
          "type": "blob",
          "size": 5530
        },
        {
          "path": "examples/apple/QUICKSTART.md",
          "type": "blob",
          "size": 5141
        },
        {
          "path": "examples/apple/README.md",
          "type": "blob",
          "size": 10603
        },
        {
          "path": "examples/apple/SUMMARY.md",
          "type": "blob",
          "size": 8127
        },
        {
          "path": "examples/apple/api_client.py",
          "type": "blob",
          "size": 13086
        },
        {
          "path": "examples/apple/extract_job_fields.py",
          "type": "blob",
          "size": 5590
        },
        {
          "path": "examples/apple/main.py",
          "type": "blob",
          "size": 912
        },
        {
          "path": "examples/apple/quick_example.py",
          "type": "blob",
          "size": 3216
        },
        {
          "path": "examples/apple/requirements.txt",
          "type": "blob",
          "size": 17
        },
        {
          "path": "examples/ashby",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/ashby/API_SUMMARY.txt",
          "type": "blob",
          "size": 4830
        },
        {
          "path": "examples/ashby/QUICKSTART.md",
          "type": "blob",
          "size": 1517
        },
        {
          "path": "examples/ashby/README.md",
          "type": "blob",
          "size": 19497
        },
        {
          "path": "examples/ashby/api_client.py",
          "type": "blob",
          "size": 30053
        },
        {
          "path": "examples/ashby/example_usage.py",
          "type": "blob",
          "size": 5968
        },
        {
          "path": "examples/ashby/requirements.txt",
          "type": "blob",
          "size": 30
        },
        {
          "path": "examples/autoscout24",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/autoscout24/README.md",
          "type": "blob",
          "size": 9165
        },
        {
          "path": "examples/autoscout24/SUMMARY.md",
          "type": "blob",
          "size": 5413
        },
        {
          "path": "examples/autoscout24/api_client.py",
          "type": "blob",
          "size": 15716
        },
        {
          "path": "examples/ikea",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/ikea/README.md",
          "type": "blob",
          "size": 9251
        },
        {
          "path": "examples/ikea/api_client.py",
          "type": "blob",
          "size": 18661
        },
        {
          "path": "examples/uber",
          "type": "tree",
          "size": null
        },
        {
          "path": "examples/uber/API_ANALYSIS_SUMMARY.md",
          "type": "blob",
          "size": 7184
        },
        {
          "path": "examples/uber/README.md",
          "type": "blob",
          "size": 9281
        },
        {
          "path": "examples/uber/api_client.py",
          "type": "blob",
          "size": 15507
        },
        {
          "path": "examples/uber/example_fetch_all_jobs.py",
          "type": "blob",
          "size": 6066
        },
        {
          "path": "examples/uber/quick_start.py",
          "type": "blob",
          "size": 2427
        },
        {
          "path": "examples/uber/requirements.txt",
          "type": "blob",
          "size": 17
        },
        {
          "path": "llm-docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "llm-docs/OPENCODE_API_SUMMARY.md",
          "type": "blob",
          "size": 12782
        },
        {
          "path": "llm-docs/claude-agent-sdk",
          "type": "tree",
          "size": null
        },
        {
          "path": "llm-docs/claude-agent-sdk/QUICKSTART.md",
          "type": "blob",
          "size": 65941
        },
        {
          "path": "llm-docs/claude-agent-sdk/TODO_LIST.md",
          "type": "blob",
          "size": 5860
        },
        {
          "path": "llm-docs/claude-agent-sdk/TOOLS.md",
          "type": "blob",
          "size": null
        },
        {
          "path": "llm-docs/opencode-api.json",
          "type": "blob",
          "size": 394720
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 950
        },
        {
          "path": "plugins/reverse-api-engineer/CHANGELOG.md",
          "type": "blob",
          "size": 937
        },
        {
          "path": "plugins/reverse-api-engineer/LICENSE",
          "type": "blob",
          "size": 1062
        },
        {
          "path": "plugins/reverse-api-engineer/README.md",
          "type": "blob",
          "size": 5720
        },
        {
          "path": "plugins/reverse-api-engineer/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/agents/api-reverse-engineer.md",
          "type": "blob",
          "size": 13187
        },
        {
          "path": "plugins/reverse-api-engineer/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/commands/agent.md",
          "type": "blob",
          "size": 15398
        },
        {
          "path": "plugins/reverse-api-engineer/commands/capture.md",
          "type": "blob",
          "size": 5326
        },
        {
          "path": "plugins/reverse-api-engineer/commands/engineer.md",
          "type": "blob",
          "size": 12993
        },
        {
          "path": "plugins/reverse-api-engineer/commands/manual.md",
          "type": "blob",
          "size": 11752
        },
        {
          "path": "plugins/reverse-api-engineer/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/CHANGELOG.md",
          "type": "blob",
          "size": 1258
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/LICENSE",
          "type": "blob",
          "size": 1066
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/SKILL.md",
          "type": "blob",
          "size": 10659
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/references",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/references/AUTH_PATTERNS.md",
          "type": "blob",
          "size": 15265
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/references/HAR_ANALYSIS.md",
          "type": "blob",
          "size": 9225
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_analyze.py",
          "type": "blob",
          "size": 17497
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py",
          "type": "blob",
          "size": 10569
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_utils.py",
          "type": "blob",
          "size": 9674
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_validate.py",
          "type": "blob",
          "size": 13046
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/templates",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/templates/api_client.py",
          "type": "blob",
          "size": 13496
        },
        {
          "path": "pyproject.toml",
          "type": "blob",
          "size": 2800
        },
        {
          "path": "scripts",
          "type": "tree",
          "size": null
        },
        {
          "path": "scripts/clean_build.sh",
          "type": "blob",
          "size": 867
        },
        {
          "path": "src",
          "type": "tree",
          "size": null
        },
        {
          "path": "src/reverse_api",
          "type": "tree",
          "size": null
        },
        {
          "path": "src/reverse_api/__init__.py",
          "type": "blob",
          "size": 305
        },
        {
          "path": "src/reverse_api/action_recorder.py",
          "type": "blob",
          "size": 1468
        },
        {
          "path": "src/reverse_api/auto_engineer.py",
          "type": "blob",
          "size": 25183
        },
        {
          "path": "src/reverse_api/base_engineer.py",
          "type": "blob",
          "size": 18012
        },
        {
          "path": "src/reverse_api/browser.py",
          "type": "blob",
          "size": 49103
        },
        {
          "path": "src/reverse_api/cli.py",
          "type": "blob",
          "size": 62166
        },
        {
          "path": "src/reverse_api/collector.py",
          "type": "blob",
          "size": 11567
        },
        {
          "path": "src/reverse_api/collector_ui.py",
          "type": "blob",
          "size": 4514
        },
        {
          "path": "src/reverse_api/config.py",
          "type": "blob",
          "size": 3288
        },
        {
          "path": "src/reverse_api/engineer.py",
          "type": "blob",
          "size": 14674
        },
        {
          "path": "src/reverse_api/messages.py",
          "type": "blob",
          "size": 2721
        },
        {
          "path": "src/reverse_api/opencode_engineer.py",
          "type": "blob",
          "size": 20916
        },
        {
          "path": "src/reverse_api/opencode_ui.py",
          "type": "blob",
          "size": 13785
        },
        {
          "path": "src/reverse_api/playwright_codegen.py",
          "type": "blob",
          "size": 5259
        },
        {
          "path": "src/reverse_api/pricing.py",
          "type": "blob",
          "size": 7265
        },
        {
          "path": "src/reverse_api/session.py",
          "type": "blob",
          "size": 2725
        },
        {
          "path": "src/reverse_api/sync.py",
          "type": "blob",
          "size": 9557
        },
        {
          "path": "src/reverse_api/tui.py",
          "type": "blob",
          "size": 8260
        },
        {
          "path": "src/reverse_api/utils.py",
          "type": "blob",
          "size": 15096
        },
        {
          "path": "tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/__init__.py",
          "type": "blob",
          "size": 3
        },
        {
          "path": "uv.lock",
          "type": "blob",
          "size": 540443
        }
      ],
      "marketplace": {
        "name": "reverse-api-engineer",
        "version": null,
        "description": null,
        "owner_info": {
          "name": "Kalil Sama Bouzigues",
          "email": "kalil.bouzigues@gmail.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "reverse-api-engineer",
            "description": "A plugin to reverse engineer APIs from websites",
            "source": "./plugins/reverse-api-engineer",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add kalil0321/reverse-api-engineer",
              "/plugin install reverse-api-engineer@reverse-api-engineer"
            ],
            "signals": {
              "stars": 264,
              "forks": 16,
              "pushed_at": "2026-01-10T19:01:15Z",
              "created_at": "2025-12-23T14:04:45Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/agent",
                "description": "Autonomous browser navigation with HAR capture and API client generation",
                "path": "plugins/reverse-api-engineer/commands/agent.md",
                "frontmatter": {
                  "description": "Autonomous browser navigation with HAR capture and API client generation",
                  "argument-hint": "[task] [url]",
                  "allowed-tools": [
                    "MCP:rae-playwright-mcp",
                    "Read",
                    "Write",
                    "Bash"
                  ]
                },
                "content": "# Agent Mode - Autonomous Browser Navigation\n\nFully autonomous browser navigation using Playwright MCP. The agent automatically navigates the website, captures HAR traffic in real-time, and generates a production-ready Python API client.\n\n## Prerequisites\n\nEnsure the `reverse-engineering-api` skill is loaded for guidance on HAR analysis and code generation.\n\n## Command Arguments\n\n- `task` (required): Description of what to automate (e.g., \"find all job listings\", \"search for products\")\n- `url` (optional): Starting URL for the browser\n\nIf arguments are not provided, prompt the user interactively.\n\n## Task Tracking\n\nBefore starting the workflow, create a todo list to track progress:\n\n```python\nTodoWrite([\n  {\"content\": \"Launch browser with HAR recording\", \"status\": \"pending\", \"activeForm\": \"Launching browser\"},\n  {\"content\": \"Navigate autonomously to complete task\", \"status\": \"pending\", \"activeForm\": \"Navigating autonomously\"},\n  {\"content\": \"Verify HAR capture\", \"status\": \"pending\", \"activeForm\": \"Verifying HAR file\"},\n  {\"content\": \"Filter HAR using har_filter.py\", \"status\": \"pending\", \"activeForm\": \"Filtering HAR\"},\n  {\"content\": \"Analyze HAR using har_analyze.py\", \"status\": \"pending\", \"activeForm\": \"Analyzing endpoints\"},\n  {\"content\": \"Generate API client code\", \"status\": \"pending\", \"activeForm\": \"Generating code\"},\n  {\"content\": \"Validate code using har_validate.py\", \"status\": \"pending\", \"activeForm\": \"Validating code\"},\n  {\"content\": \"Test API client implementation\", \"status\": \"pending\", \"activeForm\": \"Testing implementation\"},\n  {\"content\": \"Generate documentation\", \"status\": \"pending\", \"activeForm\": \"Writing README\"}\n])\n```\n\n**CRITICAL:** Mark each task as `in_progress` when starting, `completed` when done. NEVER skip tasks - complete all 9 steps.\n\n## Workflow\n\n### Step 1: Gather Task Information\n\nIf `task` argument is not provided:\n```\nAsk: \"What would you like the agent to do? (e.g., 'navigate to jobs page and list all postings')\"\n```\n\nIf `url` argument is not provided:\n```\nAsk: \"What URL should I start from? (optional, press Enter to skip)\"\n```\n\n### Step 2: Generate Run ID and Setup Paths\n\nGenerate a unique run ID using UUID format:\n```\nrun_id = uuid4() (e.g., \"abc-123-def-456\")\n```\n\nSetup paths:\n```\nhar_dir = ~/.reverse-api/runs/har/{run_id}\nhar_path = {har_dir}/recording.har\n```\n\nEnsure directory exists:\n```bash\nmkdir -p ~/.reverse-api/runs/har/{run_id}\n```\n\n### Step 3: Launch Browser with HAR Recording\n\nUse the Playwright MCP `rae-playwright-mcp` to launch a browser with HAR recording enabled:\n\n```\nCall MCP tool: playwright_navigate\nParameters:\n  - url: {url} or \"about:blank\" if no URL provided\n  - options:\n      - record_har: true\n      - har_path: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\nInform the user:\n```\nAgent mode started with HAR recording enabled.\nTask: {task}\nStarting URL: {url}\n\nI'll navigate autonomously and capture all API traffic.\nHAR will be saved to: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n### Step 4: Autonomous Navigation\n\nUse Playwright MCP tools to autonomously navigate and complete the task:\n\n**Available Playwright MCP actions:**\n- `playwright_navigate(url)` - Navigate to URL\n- `playwright_click(selector)` - Click element\n- `playwright_fill(selector, text)` - Fill form field\n- `playwright_get_text(selector)` - Extract text\n- `playwright_wait_for_selector(selector)` - Wait for element\n- `playwright_screenshot()` - Take screenshot\n- `playwright_evaluate(script)` - Execute JavaScript\n- `playwright_get_har_entries()` - Get captured HAR entries in real-time\n\n**Navigation strategy:**\n\n1. **Analyze the page**: Use `playwright_get_text()` to understand page structure\n2. **Plan actions**: Based on task, determine what elements to interact with\n3. **Execute actions**: Use `playwright_click()`, `playwright_fill()` to navigate\n4. **Monitor traffic**: Periodically check `playwright_get_har_entries()` to see captured API calls\n5. **Iterate**: Continue until task is complete or sufficient API traffic captured\n\n**Real-time monitoring:**\n```\nProgress update:\n- Navigated to: {current_url}\n- Actions taken: {count}\n- API calls captured: {har_entry_count}\n- Current step: {description}\n```\n\n**Example navigation for \"find all job listings\":**\n```\n1. Navigate to homepage\n2. Look for \"Careers\" or \"Jobs\" link\n3. Click to navigate to jobs page\n4. Wait for job listings to load\n5. Capture API calls for job data\n6. Check for pagination\n7. If pagination exists, load next pages to capture all API patterns\n8. Close browser when done\n```\n\n### Step 5: Verify HAR Capture\n\nWhen navigation is complete, verify HAR file exists and contains data:\n\n```bash\nif [ -f ~/.reverse-api/runs/har/{run_id}/recording.har ]; then\n    size=$(ls -lh ~/.reverse-api/runs/har/{run_id}/recording.har | awk '{print $5}')\n    echo \"HAR file captured: $size\"\nelse\n    echo \"Error: HAR file not found\"\n    exit 1\nfi\n```\n\nRead HAR file to count entries:\n```python\nimport json\nwith open(\"~/.reverse-api/runs/har/{run_id}/recording.har\", \"r\") as f:\n    har_data = json.load(f)\n    entry_count = len(har_data[\"log\"][\"entries\"])\n```\n\nDisplay:\n```\nBrowser session completed.\nCaptured {entry_count} network requests in HAR file.\nAnalyzing for API endpoints...\n```\n\n### Step 6: Analyze HAR File\n\n**Mark todo in_progress: \"Filter HAR using har_filter.py\"**\n\nFilter the HAR file to remove static assets, analytics, and CDN resources:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py ~/.reverse-api/runs/har/{run_id}/recording.har --output {output_dir}/filtered.har --stats\n```\n\nRead and display the filtering statistics:\n```\nFiltering complete!\nTotal entries: {total}\nAPI endpoints found: {filtered_entries}\nRemoved:\n- Static assets: {removed_static}\n- Analytics/tracking: {removed_analytics}\n- CDN resources: {removed_cdn}\n\nAPI patterns detected: {api_patterns_found}\n```\n\n**Mark todo completed**\n\n**Mark todo in_progress: \"Analyze HAR using har_analyze.py\"**\n\nExtract structured endpoint information from filtered HAR:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_analyze.py {output_dir}/filtered.har --output {output_dir}/analysis.json\n```\n\nRead analysis.json and summarize for the user:\n\n```bash\ncat {output_dir}/analysis.json\n```\n\nDisplay summary:\n```\nAnalysis complete!\n\nBase URL: {base_url}\nAuthentication: {authentication.type} ({authentication.description})\nUnique endpoints: {unique_endpoints}\nPagination: {pagination.type if pagination.detected else \"Not detected\"}\n\nEndpoints found:\n{for each endpoint in endpoints:}\n- {endpoint.methods} {endpoint.pattern}\n  Calls observed: {endpoint.calls_observed}\n  Auth required: {endpoint.requires_auth}\n  Query params: {endpoint.query_params.required + endpoint.query_params.optional}\n```\n\n**Mark todo completed**\n\n### Step 7: Generate API Client\n\nGenerate a descriptive name for the script based on the task:\n```\ntask_name = sanitize(task)  # e.g., \"job_listings_api\"\noutput_dir = ./scripts/{task_name}/\n```\n\nCreate output directory:\n```bash\nmkdir -p ./scripts/{task_name}/\n```\n\nGenerate `api_client.py` with the following structure:\n\n```python\n\"\"\"\nAuto-generated API client for {domain}\nGenerated from autonomous agent capture on {date}\n\nTask: {task}\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any, List\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass {ClassName}Client:\n    \"\"\"API client for {domain}.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str = \"{base_url}\",\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = session or requests.Session()\n        self._setup_session()\n\n    def _setup_session(self):\n        \"\"\"Configure session with default headers.\"\"\"\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (compatible)\",\n            \"Accept\": \"application/json\",\n            # Add detected required headers\n        })\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n\n    # Generated endpoint methods\n    # For each detected endpoint, create a method like:\n\n    def get_example(self, param: str) -> Dict[str, Any]:\n        \"\"\"\n        {Method description based on endpoint}.\n\n        Args:\n            param: {Parameter description}\n\n        Returns:\n            JSON response data\n\n        Raises:\n            requests.exceptions.RequestException: If request fails\n        \"\"\"\n        response = self._request(\"GET\", f\"/api/example/{param}\")\n        return response.json()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    client = {ClassName}Client()\n    # Add example calls based on captured endpoints\n```\n\nGenerate `README.md`:\n```markdown\n# {Task Name} API Client\n\nAuto-generated Python API client from autonomous browser agent.\n\n## Generated From\n\n- **Run ID**: {run_id}\n- **HAR File**: ~/.reverse-api/runs/har/{run_id}/recording.har\n- **Date**: {date}\n- **Task**: {task}\n- **Base URL**: {base_url}\n- **Mode**: Agent (autonomous navigation)\n\n## Installation\n\n```bash\npip install requests\n```\n\n## Usage\n\n```python\nfrom api_client import {ClassName}Client\n\nclient = {ClassName}Client()\n\n# Example: {endpoint_1}\nresult = client.{method_1}({params})\nprint(result)\n```\n\n## Available Methods\n\n{List all generated methods with descriptions}\n\n## Authentication\n\n{Describe detected authentication mechanism and how to configure}\n\n## Agent Navigation Path\n\nThe agent autonomously performed these actions:\n{List navigation steps taken by agent}\n\n## Notes\n\n- Generated from autonomous agent capture\n- Agent task: {task}\n- Endpoints based on observed API calls during navigation\n- May require authentication tokens/API keys\n- Test thoroughly before production use\n```\n\n### Step 7.5: Validate Generated Code\n\n**Mark todo in_progress: \"Validate code using har_validate.py\"**\n\nValidate the generated API client against the HAR analysis:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_validate.py {output_dir}/api_client.py {output_dir}/analysis.json\n```\n\nCheck the validation score and issues:\n\n**If validation score < 90:**\n1. Read the validation issues carefully\n2. Fix each issue in api_client.py:\n   - Missing endpoints: Add methods for each missing endpoint\n   - Missing auth: Implement authentication from analysis.json\n   - Missing error handling: Add try-except blocks and custom exceptions\n   - Missing type hints: Add type hints to all methods\n3. Save the updated api_client.py\n4. Run validation again\n5. Repeat until score >= 90\n\n**Example validation loop:**\n```\nAttempt 1:\n- Score: 75\n- Issues: 2 missing endpoints, no auth implementation\n- Fix: Add missing endpoints, implement bearer token auth\n- Regenerate api_client.py\n\nAttempt 2:\n- Score: 92\n- Issues: 1 info (minor type hint improvement)\n- Result: PASS (score >= 90)\n```\n\nDisplay validation result:\n```\nValidation complete!\nScore: {score}/100\nCoverage: {coverage.percentage}% ({coverage.endpoints_covered}/{coverage.endpoints_total} endpoints)\nIssues: {summary.errors} errors, {summary.warnings} warnings, {summary.info} info\n\n{if score >= 90:}\n✓ Code validation passed!\n{else:}\n✗ Code validation failed - fixing issues and regenerating...\n```\n\n**Mark todo completed** (only when score >= 90)\n\n### Step 8: Save Run History\n\nUpdate `~/.reverse-api/history.json` with run metadata:\n\n```json\n{\n  \"run_id\": \"{run_id}\",\n  \"mode\": \"agent\",\n  \"task\": \"{task}\",\n  \"url\": \"{url}\",\n  \"timestamp\": \"{ISO timestamp}\",\n  \"har_path\": \"~/.reverse-api/runs/har/{run_id}/recording.har\",\n  \"output_dir\": \"./scripts/{task_name}/\",\n  \"navigation_steps\": {count},\n  \"status\": \"completed\"\n}\n```\n\n### Step 9: Summary\n\nPresent final summary to user:\n```\nAgent completed task successfully!\n\nTask: {task}\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n\nAgent navigation:\n- Pages visited: {page_count}\n- Actions taken: {action_count}\n- API calls captured: {entry_count}\n\nGenerated files:\n- ./scripts/{task_name}/api_client.py\n- ./scripts/{task_name}/README.md\n\nDetected endpoints: {count}\nAuthentication: {auth_type}\n\nNext steps:\n1. Review the generated code\n2. Test with: python ./scripts/{task_name}/api_client.py\n3. Integrate into your project\n```\n\n## Error Handling\n\n- **Navigation fails**: Agent couldn't complete task (suggest manual mode or retry with clearer instructions)\n- **HAR file empty**: No network traffic captured (check if site has API endpoints)\n- **No API endpoints found**: All entries were filtered out (adjust filters or try different navigation)\n- **Agent stuck**: Navigation loop detected (suggest manual mode for complex interactions)\n\n## Tips for Users\n\n- **Clear tasks**: Provide specific, actionable task descriptions\n- **Starting URL**: Provide URL when possible to speed up navigation\n- **Complex sites**: Use manual mode for sites with heavy JavaScript or complex auth flows\n- **Simple tasks**: Agent works best for straightforward navigation patterns\n- **Re-engineer**: Use `/reverse-api-engineer:engineer {run_id}` to regenerate if needed\n\n## Real-time Monitoring Benefits\n\nAgent mode with Playwright MCP offers unique advantages:\n\n1. **Live HAR access**: Can check captured API calls during navigation via `playwright_get_har_entries()`\n2. **Adaptive navigation**: Can adjust strategy based on observed API patterns\n3. **Early termination**: Can stop once sufficient endpoints are captured\n4. **Smart pagination**: Can detect when all data patterns are captured\n\n## Examples\n\n```\n# Full specification\n/reverse-api-engineer:agent \"find all job listings\" https://jobs.apple.com\n\n# Task only (agent will search for starting page)\n/reverse-api-engineer:agent \"scrape product catalog\"\n\n# Interactive mode\n/reverse-api-engineer:agent\n> \"navigate to pricing page and capture API calls\"\n> \"https://example.com\"\n```\n\n## Agent vs Manual Mode\n\n**Use Agent Mode when:**\n- Task is straightforward and automatable\n- Site structure is simple\n- You want hands-off operation\n- Real-time HAR monitoring is beneficial\n\n**Use Manual Mode when:**\n- Site requires complex interactions\n- Custom authentication flows\n- Need precise control over captured endpoints\n- Site has bot detection\n- Task involves manual judgment\n\n## Advanced: Real-time HAR Monitoring\n\nDuring navigation, you can periodically check captured HAR entries:\n\n```\n# Check every few actions\nentries = playwright_get_har_entries()\n\n# Analyze on-the-fly\napi_calls = filter_api_endpoints(entries)\n\n# Decide if done\nif len(api_calls) >= 5 and pagination_pattern_detected:\n    stop_navigation()\n    proceed_to_analysis()\n```\n\nThis allows intelligent navigation that adapts based on captured API patterns."
              },
              {
                "name": "/capture",
                "description": "Launch browser with HAR recording for manual traffic capture",
                "path": "plugins/reverse-api-engineer/commands/capture.md",
                "frontmatter": {
                  "description": "Launch browser with HAR recording for manual traffic capture",
                  "argument-hint": "[url]",
                  "allowed-tools": [
                    "MCP:rae-playwright-mcp",
                    "Bash",
                    "Read"
                  ]
                },
                "content": "# Capture Mode - Browser HAR Recording Only\n\nLaunch a browser with HAR (HTTP Archive) recording enabled. Navigate manually, then close the browser to save the HAR file. This command does NOT generate code - use `/reverse-api-engineer:engineer <run_id>` afterward to analyze the captured traffic and generate an API client.\n\n## Purpose\n\nCapture mode is useful when you want to:\n- Record multiple browsing sessions before analysis\n- Separate capture from code generation\n- Share HAR files with others for analysis\n- Capture traffic first, decide on implementation later\n\n## Workflow\n\n### Step 1: Generate Run ID\n\nCreate a unique run ID for this capture session:\n\n```bash\nrun_id=$(uuidgen | tr '[:upper:]' '[:lower:]' | tr -d '-' | cut -c1-12)\necho \"Starting capture session: ${run_id}\"\n```\n\nSetup HAR file path:\n```bash\nhar_dir=\"${HOME}/.reverse-api/runs/har/${run_id}\"\nmkdir -p \"${har_dir}\"\nhar_path=\"${har_dir}/recording.har\"\n```\n\nDisplay to user:\n```\nCapture session started!\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n### Step 2: Launch Browser\n\nLaunch browser with HAR recording enabled using Playwright MCP:\n\n```\nCall MCP tool: playwright_navigate\nParameters:\n  - url: {url} (if provided) or \"about:blank\"\n  - options:\n      - record_har: true\n      - har_path: ~/.reverse-api/runs/har/{run_id}/recording.har\n      - headless: false\n```\n\nDisplay instructions to user:\n```\nBrowser launched with HAR recording enabled.\n\nInstructions:\n1. Navigate to the website you want to capture\n2. Perform the actions you want to reverse engineer:\n   - Log in (to capture authentication)\n   - Browse pages (to capture GET requests)\n   - Submit forms (to capture POST/PUT requests)\n   - Trigger any API calls you need\n3. Close the browser when done\n\nThe HAR file will be automatically saved when you close the browser.\n```\n\n### Step 3: Wait for Browser Close\n\nMonitor the browser session. When the browser window closes, proceed to verification.\n\n### Step 4: Verify HAR Capture\n\nCheck that the HAR file was created and contains data:\n\n```bash\nif [ -f ~/.reverse-api/runs/har/{run_id}/recording.har ]; then\n    size=$(ls -lh ~/.reverse-api/runs/har/{run_id}/recording.har | awk '{print $5}')\n    echo \"✓ HAR file saved: $size\"\nelse\n    echo \"✗ Error: HAR file not found\"\n    exit 1\nfi\n```\n\nCount network requests in the HAR file:\n\n```python\nimport json\nfrom pathlib import Path\n\nhar_path = Path.home() / \".reverse-api\" / \"runs\" / \"har\" / \"{run_id}\" / \"recording.har\"\n\nwith open(har_path, 'r') as f:\n    har_data = json.load(f)\n    entry_count = len(har_data['log']['entries'])\n\nprint(f\"Captured {entry_count} network requests\")\n```\n\n### Step 5: Save Capture Metadata\n\nSave metadata about this capture session:\n\n```bash\ncat > ~/.reverse-api/runs/har/{run_id}/metadata.json <<EOF\n{\n  \"run_id\": \"{run_id}\",\n  \"mode\": \"capture\",\n  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\",\n  \"har_path\": \"~/.reverse-api/runs/har/{run_id}/recording.har\",\n  \"url\": \"{url or 'manual navigation'}\",\n  \"entry_count\": {entry_count}\n}\nEOF\n```\n\n### Step 6: Display Summary\n\nPresent completion summary to user:\n\n```\nCapture complete!\n\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\nFile size: {size}\nNetwork requests captured: {entry_count}\n\nNext steps:\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n\nOption 1: Analyze and generate API client\n  /reverse-api-engineer:engineer {run_id}\n\nOption 2: View captured HAR file\n  cat ~/.reverse-api/runs/har/{run_id}/recording.har | jq\n\nOption 3: Filter HAR to see API calls only\n  python plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py \\\\\n    ~/.reverse-api/runs/har/{run_id}/recording.har --stats\n\nTip: You can capture multiple times and analyze later!\n```\n\n## Advantages Over /manual Mode\n\n- **Faster**: No analysis step during capture\n- **Flexible**: Capture once, analyze multiple times with different approaches\n- **Shareable**: HAR files can be shared with team members\n- **Clean separation**: Capture and analysis are independent steps\n\n## Example Usage\n\n```bash\n# Capture with starting URL\n/reverse-api-engineer:capture https://api.example.com\n\n# Capture with manual navigation (no starting URL)\n/reverse-api-engineer:capture\n\n# After capture, analyze whenever ready\n/reverse-api-engineer:engineer abc123def456\n```\n\n## Tips\n\n1. **Capture thoroughly**: Include all API calls you want to reverse engineer\n2. **Authentication**: If the site requires login, make sure to log in during capture\n3. **Pagination**: If listing data, navigate through pages to capture pagination patterns\n4. **Multiple captures**: You can run multiple capture sessions and analyze them separately\n\n## Error Handling\n\n**Browser doesn't launch:**\n- Ensure Playwright MCP is properly configured\n- Check that the browser binary is installed\n\n**HAR file is empty:**\n- Make sure you performed actions in the browser\n- Some sites may have very few network requests\n\n**HAR file is too large:**\n- This is normal for sites with many static assets\n- Use har_filter.py to reduce it before analysis"
              },
              {
                "name": "/engineer",
                "description": "Re-analyze existing HAR capture to generate new API client",
                "path": "plugins/reverse-api-engineer/commands/engineer.md",
                "frontmatter": {
                  "description": "Re-analyze existing HAR capture to generate new API client",
                  "argument-hint": "<run_id|har_path>",
                  "allowed-tools": [
                    "Read",
                    "Write",
                    "Bash"
                  ]
                },
                "content": "# Engineer Mode - Re-engineer from Existing HAR\n\nRe-run AI generation on an existing HAR capture. This is useful when you want to regenerate the client with a different approach, extract additional endpoints, or improve the implementation without re-capturing traffic.\n\n## Prerequisites\n\nEnsure the `reverse-engineering-api` skill is loaded for guidance on HAR analysis and code generation.\n\n## Command Arguments\n\n- `run_id_or_path` (required): Either a run ID (e.g., \"abc-123-def\") or direct path to HAR file\n\n## Task Tracking\n\nBefore starting the workflow, create a todo list to track progress:\n\n```python\nTodoWrite([\n  {\"content\": \"Verify HAR file exists\", \"status\": \"pending\", \"activeForm\": \"Verifying HAR file\"},\n  {\"content\": \"Filter HAR using har_filter.py\", \"status\": \"pending\", \"activeForm\": \"Filtering HAR\"},\n  {\"content\": \"Analyze HAR using har_analyze.py\", \"status\": \"pending\", \"activeForm\": \"Analyzing endpoints\"},\n  {\"content\": \"Generate API client code\", \"status\": \"pending\", \"activeForm\": \"Generating code\"},\n  {\"content\": \"Validate code using har_validate.py\", \"status\": \"pending\", \"activeForm\": \"Validating code\"},\n  {\"content\": \"Test API client implementation\", \"status\": \"pending\", \"activeForm\": \"Testing implementation\"},\n  {\"content\": \"Generate documentation\", \"status\": \"pending\", \"activeForm\": \"Writing README\"}\n])\n```\n\n**CRITICAL:** Mark each task as `in_progress` when starting, `completed` when done. NEVER skip tasks - complete all 7 steps.\n\n## Workflow\n\n### Step 1: Parse Input Argument\n\nDetermine if the argument is a run_id or a file path:\n\n```python\nimport os\n\narg = \"{argument}\"\n\nif os.path.exists(arg) and arg.endswith('.har'):\n    # Direct HAR file path\n    har_path = arg\n    run_id = None\nelif '/' in arg or '\\\\' in arg:\n    # Looks like a path but doesn't exist\n    Error: \"HAR file not found at: {arg}\"\nelif arg:\n    # Looks like a run_id\n    run_id = arg\n    har_path = f\"~/.reverse-api/runs/har/{run_id}/recording.har\"\nelse:\n    # No argument provided\n    Error: \"Please provide either a run_id or path to HAR file\"\n```\n\n### Step 2: Verify HAR File Exists\n\nCheck if the HAR file exists and is readable:\n\n```bash\nif [ -f {har_path} ]; then\n    echo \"HAR file found: {har_path}\"\n    ls -lh {har_path}\nelse\n    echo \"Error: HAR file not found at {har_path}\"\n    exit 1\nfi\n```\n\nIf using run_id but HAR file doesn't exist:\n```\nError: \"No HAR file found for run_id: {run_id}\n\nExpected location: ~/.reverse-api/runs/har/{run_id}/recording.har\n\nAvailable runs:\n{list runs in ~/.reverse-api/runs/}\"\n```\n\n### Step 3: List Available Runs (if needed)\n\nIf the HAR file is not found and a run_id was provided, list available runs to help the user:\n\n```bash\nls -1 ~/.reverse-api/runs/ | head -10\n```\n\nDisplay:\n```\nAvailable run IDs:\n- abc-123-def (2025-01-01)\n- xyz-789-ghi (2025-01-02)\n...\n\nUse: /reverse-api-engineer:engineer <run_id>\nOr provide direct path: /reverse-api-engineer:engineer /path/to/capture.har\n```\n\n### Step 4: Read Existing Run Metadata (if available)\n\nIf using run_id, try to read metadata from history:\n\n```bash\nif [ -f ~/.reverse-api/history.json ]; then\n    # Read history.json and find entry for this run_id\n    # Extract: task, url, timestamp, original mode\nfi\n```\n\nDisplay context:\n```\nRe-engineering HAR capture:\n- Run ID: {run_id}\n- Original task: {task}\n- Captured on: {timestamp}\n- Original mode: {mode}\n```\n\n### Step 5: Prompt for New Task Description\n\nAsk the user what to focus on for this regeneration:\n\n```\nThe HAR file contains captured API traffic from a previous session.\n\nWhat would you like to generate? (e.g., \"focus on authentication endpoints\", \"create a simpler client\", \"add pagination support\")\n\nPress Enter to use original task: \"{original_task}\"\n```\n\nIf user provides new description, use it. Otherwise, use original task.\n\n### Step 6: Analyze HAR File\n\n**Mark todo in_progress: \"Filter HAR using har_filter.py\"**\n\nFilter the HAR file to remove static assets, analytics, and CDN resources:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py {har_path} --output {output_dir}/filtered.har --stats\n```\n\nRead and display the filtering statistics:\n```\nFiltering HAR file: {har_path}\nTotal entries: {total}\nAPI endpoints found: {filtered_entries}\nRemoved:\n- Static assets: {removed_static}\n- Analytics/tracking: {removed_analytics}\n- CDN resources: {removed_cdn}\n\nAPI patterns detected: {api_patterns_found}\n```\n\n**Mark todo completed**\n\n**Mark todo in_progress: \"Analyze HAR using har_analyze.py\"**\n\nExtract structured endpoint information from filtered HAR:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_analyze.py {output_dir}/filtered.har --output {output_dir}/analysis.json\n```\n\nRead analysis.json and summarize for the user:\n\n```bash\ncat {output_dir}/analysis.json\n```\n\nDisplay summary:\n```\nAnalysis complete!\n\nBase URL: {base_url}\nAuthentication: {authentication.type} ({authentication.description})\nUnique endpoints: {unique_endpoints}\nPagination: {pagination.type if pagination.detected else \"Not detected\"}\n\nEndpoints found:\n{for each endpoint in endpoints:}\n- {endpoint.methods} {endpoint.pattern}\n  Calls observed: {endpoint.calls_observed}\n  Auth required: {endpoint.requires_auth}\n  Query params: {endpoint.query_params.required + endpoint.query_params.optional}\n```\n\n**Mark todo completed**\n\n### Step 7: Generate New Run ID\n\nGenerate a new run ID for this regeneration:\n\n```python\nimport uuid\nnew_run_id = str(uuid.uuid4())\n```\n\nThis keeps the original capture separate from the new generation.\n\n### Step 8: Generate API Client\n\nGenerate a descriptive name for the script based on the task:\n\n```\ntask_name = sanitize(task)  # e.g., \"apple_jobs_api\"\noutput_dir = ./scripts/{task_name}/\n```\n\nCreate output directory:\n```bash\nmkdir -p ./scripts/{task_name}/\n```\n\nGenerate `api_client.py` with the following structure:\n\n```python\n\"\"\"\nAuto-generated API client for {domain}\nGenerated from HAR capture on {date}\n\nOriginal Run ID: {original_run_id}\nOriginal HAR file: {har_path}\nRegenerated Run ID: {new_run_id}\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any, List\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass {ClassName}Client:\n    \"\"\"API client for {domain}.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str = \"{base_url}\",\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = session or requests.Session()\n        self._setup_session()\n\n    def _setup_session(self):\n        \"\"\"Configure session with default headers.\"\"\"\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (compatible)\",\n            \"Accept\": \"application/json\",\n            # Add detected required headers\n        })\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n\n    # Generated endpoint methods\n    # For each detected endpoint, create a method like:\n\n    def get_example(self, param: str) -> Dict[str, Any]:\n        \"\"\"\n        {Method description based on endpoint}.\n\n        Args:\n            param: {Parameter description}\n\n        Returns:\n            JSON response data\n\n        Raises:\n            requests.exceptions.RequestException: If request fails\n        \"\"\"\n        response = self._request(\"GET\", f\"/api/example/{param}\")\n        return response.json()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    client = {ClassName}Client()\n    # Add example calls based on captured endpoints\n```\n\nGenerate `README.md`:\n```markdown\n# {Task Name} API Client\n\nAuto-generated Python API client from browser traffic capture.\n\n## Generated From\n\n- **Original Run ID**: {original_run_id}\n- **HAR File**: {har_path}\n- **Regenerated**: {date}\n- **Regeneration Run ID**: {new_run_id}\n- **Base URL**: {base_url}\n\n## Installation\n\n```bash\npip install requests\n```\n\n## Usage\n\n```python\nfrom api_client import {ClassName}Client\n\nclient = {ClassName}Client()\n\n# Example: {endpoint_1}\nresult = client.{method_1}({params})\nprint(result)\n```\n\n## Available Methods\n\n{List all generated methods with descriptions}\n\n## Authentication\n\n{Describe detected authentication mechanism and how to configure}\n\n## Notes\n\n- Regenerated from previous HAR capture\n- Original capture: {original_date}\n- Endpoints based on observed API calls\n- May require authentication tokens/API keys\n- Test thoroughly before production use\n```\n\n### Step 8.5: Validate Generated Code\n\n**Mark todo in_progress: \"Validate code using har_validate.py\"**\n\nValidate the generated API client against the HAR analysis:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_validate.py {output_dir}/api_client.py {output_dir}/analysis.json\n```\n\nCheck the validation score and issues:\n\n**If validation score < 90:**\n1. Read the validation issues carefully\n2. Fix each issue in api_client.py:\n   - Missing endpoints: Add methods for each missing endpoint\n   - Missing auth: Implement authentication from analysis.json\n   - Missing error handling: Add try-except blocks and custom exceptions\n   - Missing type hints: Add type hints to all methods\n3. Save the updated api_client.py\n4. Run validation again\n5. Repeat until score >= 90\n\n**Example validation loop:**\n```\nAttempt 1:\n- Score: 75\n- Issues: 2 missing endpoints, no auth implementation\n- Fix: Add missing endpoints, implement bearer token auth\n- Regenerate api_client.py\n\nAttempt 2:\n- Score: 92\n- Issues: 1 info (minor type hint improvement)\n- Result: PASS (score >= 90)\n```\n\nDisplay validation result:\n```\nValidation complete!\nScore: {score}/100\nCoverage: {coverage.percentage}% ({coverage.endpoints_covered}/{coverage.endpoints_total} endpoints)\nIssues: {summary.errors} errors, {summary.warnings} warnings, {summary.info} info\n\n{if score >= 90:}\n✓ Code validation passed!\n{else:}\n✗ Code validation failed - fixing issues and regenerating...\n```\n\n**Mark todo completed** (only when score >= 90)\n\n### Step 9: Save Run History\n\nUpdate `~/.reverse-api/history.json` with run metadata:\n\n```json\n{\n  \"run_id\": \"{new_run_id}\",\n  \"mode\": \"engineer\",\n  \"task\": \"{task}\",\n  \"source_run_id\": \"{original_run_id}\",\n  \"har_path\": \"{har_path}\",\n  \"timestamp\": \"{ISO timestamp}\",\n  \"output_dir\": \"./scripts/{task_name}/\",\n  \"status\": \"completed\"\n}\n```\n\n### Step 10: Summary\n\nPresent final summary to user:\n\n```\nAPI client re-generated successfully!\n\nOriginal HAR: {har_path}\nOriginal Run ID: {original_run_id}\nNew Run ID: {new_run_id}\n\nGenerated files:\n- ./scripts/{task_name}/api_client.py\n- ./scripts/{task_name}/README.md\n\nDetected endpoints: {count}\nAuthentication: {auth_type}\n\nNext steps:\n1. Review the generated code\n2. Test with: python ./scripts/{task_name}/api_client.py\n3. Compare with previous version (if any)\n4. Integrate into your project\n\nTo regenerate with different focus:\n/reverse-api-engineer:engineer {original_run_id}\n```\n\n## Error Handling\n\n- **HAR file not found**: Provide list of available runs and suggest correct usage\n- **Invalid HAR format**: Check file is valid JSON and follows HAR specification\n- **No API endpoints found**: All entries were filtered out (suggest adjusting filters or recapturing)\n- **Generation fails**: Retry with different approach or analyze HAR manually\n\n## Tips for Users\n\n- **Different approaches**: Try regenerating with different focus areas\n- **Refinement**: Use engineer mode to improve previous generations\n- **Testing**: Compare multiple generated versions to find the best implementation\n- **Documentation**: Each regeneration creates a new run_id for tracking\n- **Original HAR**: The original HAR file is never modified\n\n## Examples\n\n```\n# Using run_id\n/reverse-api-engineer:engineer abc-123-def\n\n# Using direct path\n/reverse-api-engineer:engineer ~/.reverse-api/runs/har/xyz-789/recording.har\n\n# Using relative path\n/reverse-api-engineer:engineer ./captures/myapp.har\n\n# Re-engineer with focus\n/reverse-api-engineer:engineer abc-123-def\n> \"focus on authentication endpoints only\"\n```\n\n## Use Cases\n\n1. **Improve previous generation**: Regenerate with better endpoint detection\n2. **Extract subset**: Focus on specific endpoints from large capture\n3. **Different implementation**: Generate alternative client architecture\n4. **Update documentation**: Regenerate with better docstrings and examples\n5. **Fix issues**: Address problems in previous generation without re-capturing"
              },
              {
                "name": "/manual",
                "description": "Launch browser with HAR recording, capture traffic manually, then generate Python API client",
                "path": "plugins/reverse-api-engineer/commands/manual.md",
                "frontmatter": {
                  "description": "Launch browser with HAR recording, capture traffic manually, then generate Python API client",
                  "argument-hint": "[task] [url]",
                  "allowed-tools": [
                    "MCP:rae-playwright-mcp",
                    "Read",
                    "Write",
                    "Bash"
                  ]
                },
                "content": "# Manual Mode - Browser Capture and API Generation\n\nLaunch a browser with HAR recording enabled. The user will navigate manually to trigger the desired API calls. When the browser closes, analyze the captured HAR file and generate a production-ready Python API client.\n\n## Prerequisites\n\nEnsure the `reverse-engineering-api` skill is loaded for guidance on HAR analysis and code generation.\n\n## Command Arguments\n\n- `task` (optional): Description of what to reverse engineer (e.g., \"fetch Apple jobs\", \"scrape product data\")\n- `url` (optional): Starting URL for the browser\n\nIf arguments are not provided, prompt the user interactively.\n\n## Task Tracking\n\nBefore starting the workflow, create a todo list to track progress:\n\n```python\nTodoWrite([\n  {\"content\": \"Launch browser with HAR recording\", \"status\": \"pending\", \"activeForm\": \"Launching browser\"},\n  {\"content\": \"Wait for user to complete manual navigation\", \"status\": \"pending\", \"activeForm\": \"Recording traffic\"},\n  {\"content\": \"Verify HAR capture\", \"status\": \"pending\", \"activeForm\": \"Verifying HAR file\"},\n  {\"content\": \"Filter HAR using har_filter.py\", \"status\": \"pending\", \"activeForm\": \"Filtering HAR\"},\n  {\"content\": \"Analyze HAR using har_analyze.py\", \"status\": \"pending\", \"activeForm\": \"Analyzing endpoints\"},\n  {\"content\": \"Generate API client\", \"status\": \"pending\", \"activeForm\": \"Generating code\"},\n  {\"content\": \"Validate code using har_validate.py\", \"status\": \"pending\", \"activeForm\": \"Validating code\"},\n  {\"content\": \"Test implementation\", \"status\": \"pending\", \"activeForm\": \"Testing API client\"},\n  {\"content\": \"Generate documentation\", \"status\": \"pending\", \"activeForm\": \"Writing README\"}\n])\n```\n\n**CRITICAL:** Mark each task as `in_progress` when starting, `completed` when done. NEVER skip tasks - complete all 9 steps.\n\n## Workflow\n\n### Step 1: Gather Task Information\n\nIf `task` argument is not provided:\n```\nAsk: \"What would you like to reverse engineer? (e.g., 'fetch job listings from Company X')\"\n```\n\nIf `url` argument is not provided:\n```\nAsk: \"What URL should I open? (optional, press Enter to skip)\"\n```\n\n### Step 2: Generate Run ID and Setup Paths\n\nGenerate a unique run ID using UUID format:\n```\nrun_id = uuid4() (e.g., \"abc-123-def-456\")\n```\n\nSetup paths:\n```\nhar_dir = ~/.reverse-api/runs/har/{run_id}/\nhar_path = {har_dir}/recording.har\n```\n\nEnsure directory exists:\n```bash\nmkdir -p ~/.reverse-api/runs/har/{run_id}/\n```\n\n### Step 3: Launch Browser with HAR Recording\n\nUse the Playwright MCP `rae-playwright-mcp` to launch a browser with HAR recording:\n\n```\nCall MCP tool: playwright_navigate\nParameters:\n  - url: {url} or \"about:blank\" if no URL provided\n  - options:\n      - record_har: true\n      - har_path: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\nInform the user:\n```\nBrowser launched with HAR recording enabled.\nNavigate to the website and interact with it to trigger API calls.\nClose the browser when you're done to proceed with analysis.\n\nHAR will be saved to: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n### Step 4: Wait for Browser to Close\n\nMonitor the browser session. When it closes, the HAR file will be saved automatically.\n\nVerify HAR file exists:\n```bash\nls -lh ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\nIf file doesn't exist or is empty:\n```\nError: \"HAR file not found or empty. Please ensure you interacted with the website before closing the browser.\"\nExit with error\n```\n\n### Step 5: Analyze HAR File\n\n**Mark todo in_progress: \"Filter HAR using har_filter.py\"**\n\nFilter the HAR file to remove static assets, analytics, and CDN resources:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_filter.py ~/.reverse-api/runs/har/{run_id}/recording.har --output {output_dir}/filtered.har --stats\n```\n\nRead and display the filtering statistics:\n```\nFiltering complete!\nTotal entries: {total}\nAPI endpoints found: {filtered_entries}\nRemoved:\n- Static assets: {removed_static}\n- Analytics/tracking: {removed_analytics}\n- CDN resources: {removed_cdn}\n\nAPI patterns detected: {api_patterns_found}\n```\n\n**Mark todo completed**\n\n**Mark todo in_progress: \"Analyze HAR using har_analyze.py\"**\n\nExtract structured endpoint information from filtered HAR:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_analyze.py {output_dir}/filtered.har --output {output_dir}/analysis.json\n```\n\nRead analysis.json and summarize for the user:\n\n```bash\ncat {output_dir}/analysis.json\n```\n\nDisplay summary:\n```\nAnalysis complete!\n\nBase URL: {base_url}\nAuthentication: {authentication.type} ({authentication.description})\nUnique endpoints: {unique_endpoints}\nPagination: {pagination.type if pagination.detected else \"Not detected\"}\n\nEndpoints found:\n{for each endpoint in endpoints:}\n- {endpoint.methods} {endpoint.pattern}\n  Calls observed: {endpoint.calls_observed}\n  Auth required: {endpoint.requires_auth}\n  Query params: {endpoint.query_params.required + endpoint.query_params.optional}\n```\n\n**Mark todo completed**\n\n### Step 6: Generate API Client\n\nGenerate a descriptive name for the script based on the task:\n```\ntask_name = sanitize(task)  # e.g., \"apple_jobs_api\"\noutput_dir = ./scripts/{task_name}/\n```\n\nCreate output directory:\n```bash\nmkdir -p ./scripts/{task_name}/\n```\n\nGenerate `api_client.py` with the following structure:\n\n```python\n\"\"\"\nAuto-generated API client for {domain}\nGenerated from HAR capture on {date}\n\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any, List\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass {ClassName}Client:\n    \"\"\"API client for {domain}.\"\"\"\n\n    def __init__(\n        self,\n        base_url: str = \"{base_url}\",\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = session or requests.Session()\n        self._setup_session()\n\n    def _setup_session(self):\n        \"\"\"Configure session with default headers.\"\"\"\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (compatible)\",\n            \"Accept\": \"application/json\",\n            # Add detected required headers\n        })\n\n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n\n    # Generated endpoint methods\n    # For each detected endpoint, create a method like:\n\n    def get_example(self, param: str) -> Dict[str, Any]:\n        \"\"\"\n        {Method description based on endpoint}.\n\n        Args:\n            param: {Parameter description}\n\n        Returns:\n            JSON response data\n\n        Raises:\n            requests.exceptions.RequestException: If request fails\n        \"\"\"\n        response = self._request(\"GET\", f\"/api/example/{param}\")\n        return response.json()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    client = {ClassName}Client()\n    # Add example calls based on captured endpoints\n```\n\nGenerate `README.md`:\n```markdown\n# {Task Name} API Client\n\nAuto-generated Python API client from browser traffic capture.\n\n## Generated From\n\n- **Run ID**: {run_id}\n- **HAR File**: ~/.reverse-api/runs/har/{run_id}/recording.har\n- **Date**: {date}\n- **Base URL**: {base_url}\n\n## Installation\n\n```bash\npip install requests\n```\n\n## Usage\n\n```python\nfrom api_client import {ClassName}Client\n\nclient = {ClassName}Client()\n\n# Example: {endpoint_1}\nresult = client.{method_1}({params})\nprint(result)\n```\n\n## Available Methods\n\n{List all generated methods with descriptions}\n\n## Authentication\n\n{Describe detected authentication mechanism and how to configure}\n\n## Notes\n\n- Generated from captured browser traffic\n- Endpoints based on observed API calls\n- May require authentication tokens/API keys\n- Test thoroughly before production use\n```\n\n### Step 6.5: Validate Generated Code\n\n**Mark todo in_progress: \"Validate code using har_validate.py\"**\n\nValidate the generated API client against the HAR analysis:\n\n```bash\npython plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/har_validate.py {output_dir}/api_client.py {output_dir}/analysis.json\n```\n\nCheck the validation score and issues:\n\n**If validation score < 90:**\n1. Read the validation issues carefully\n2. Fix each issue in api_client.py:\n   - Missing endpoints: Add methods for each missing endpoint\n   - Missing auth: Implement authentication from analysis.json\n   - Missing error handling: Add try-except blocks and custom exceptions\n   - Missing type hints: Add type hints to all methods\n3. Save the updated api_client.py\n4. Run validation again\n5. Repeat until score >= 90\n\n**Example validation loop:**\n```\nAttempt 1:\n- Score: 75\n- Issues: 2 missing endpoints, no auth implementation\n- Fix: Add missing endpoints, implement bearer token auth\n- Regenerate api_client.py\n\nAttempt 2:\n- Score: 92\n- Issues: 1 info (minor type hint improvement)\n- Result: PASS (score >= 90)\n```\n\nDisplay validation result:\n```\nValidation complete!\nScore: {score}/100\nCoverage: {coverage.percentage}% ({coverage.endpoints_covered}/{coverage.endpoints_total} endpoints)\nIssues: {summary.errors} errors, {summary.warnings} warnings, {summary.info} info\n\n{if score >= 90:}\n✓ Code validation passed!\n{else:}\n✗ Code validation failed - fixing issues and regenerating...\n```\n\n**Mark todo completed** (only when score >= 90)\n\n### Step 7: Save Run History\n\nUpdate `~/.reverse-api/history.json` with run metadata:\n\n```json\n{\n  \"run_id\": \"{run_id}\",\n  \"mode\": \"manual\",\n  \"task\": \"{task}\",\n  \"url\": \"{url}\",\n  \"timestamp\": \"{ISO timestamp}\",\n  \"har_path\": \"~/.reverse-api/runs/har/{run_id}/recording.har\",\n  \"output_dir\": \"./scripts/{task_name}/\",\n  \"status\": \"completed\"\n}\n```\n\n### Step 8: Summary\n\nPresent final summary to user:\n```\nAPI client generated successfully!\n\nRun ID: {run_id}\nHAR file: ~/.reverse-api/runs/har/{run_id}/recording.har\n\nGenerated files:\n- ./scripts/{task_name}/api_client.py\n- ./scripts/{task_name}/README.md\n\nDetected endpoints: {count}\nAuthentication: {auth_type}\n\nNext steps:\n1. Review the generated code\n2. Test with: python ./scripts/{task_name}/api_client.py\n3. Integrate into your project\n```\n\n## Error Handling\n\n- **Browser launch fails**: Check Playwright MCP is running and accessible\n- **HAR file empty**: User didn't interact with website, or no network traffic captured\n- **No API endpoints found**: All entries were filtered out (adjust filters or capture more traffic)\n- **Generation fails**: Use `/reverse-api-engineer:engineer {run_id}` to retry with different approach\n\n## Tips for Users\n\n- **Login flows**: Log in during capture to record authentication\n- **Pagination**: Navigate through pages to capture query parameter patterns\n- **Different actions**: Create, read, update, delete to capture all CRUD endpoints\n- **Multiple captures**: You can run manual mode multiple times for different flows\n- **Re-engineer**: Use `/reverse-api-engineer:engineer {run_id}` to regenerate from same capture\n\n## Examples\n\n```\n/reverse-api-engineer:manual \"fetch Apple jobs\" https://jobs.apple.com\n/reverse-api-engineer:manual \"scrape product data\"\n/reverse-api-engineer:manual\n```"
              }
            ],
            "skills": [
              {
                "name": "reverse-engineering-api",
                "description": "Reverse engineer web APIs by capturing browser traffic (HAR files) and generating production-ready Python API clients. Use when the user wants to create an API client for a website, automate web interactions, or understand undocumented APIs. Activate on tasks mentioning \"reverse engineer\", \"API client\", \"HAR file\", \"capture traffic\", or \"automate website\".",
                "path": "plugins/reverse-api-engineer/skills/reverse-engineering-api/SKILL.md",
                "frontmatter": {
                  "name": "reverse-engineering-api",
                  "description": "Reverse engineer web APIs by capturing browser traffic (HAR files) and generating production-ready Python API clients. Use when the user wants to create an API client for a website, automate web interactions, or understand undocumented APIs. Activate on tasks mentioning \"reverse engineer\", \"API client\", \"HAR file\", \"capture traffic\", or \"automate website\".",
                  "compatibility": "Requires Playwright MCP for browser control. HAR files saved to ~/.reverse-api/runs/har/{run_id}",
                  "metadata": {
                    "author": "reverse-api-engineer",
                    "version": "1.0"
                  },
                  "allowed-tools": "Bash(python:*) Bash(uv:*) Read Write Edit"
                },
                "content": "# Reverse Engineering API Skill\n\nThis skill enables you to reverse engineer web APIs by:\n1. Controlling a browser with HAR recording enabled\n2. Analyzing captured network traffic\n3. Generating production-ready Python API clients\n\n## Prerequisites\n\n- **Playwright MCP**: You must have access to Playwright MCP tools for browser control\n- **HAR Recording**: The browser must be configured to record HAR files\n- **Python**: For running analysis scripts and generated clients\n\n## Workflow Overview\n\n```\n[User Task] -> [Browser Capture] -> [HAR Analysis] -> [API Client Generation] -> [Testing & Refinement]\n```\n\n## Phase 0: Preparation (Using HAR Helper Scripts)\n\n### Available Helper Scripts\n\nThis skill provides Python utilities for HAR analysis located at:\n\n**Script Directory:** `plugins/reverse-api-engineer/skills/reverse-engineering-api/scripts/`\n\n**Available Scripts:**\n- `har_filter.py` - Filter HAR files to API endpoints only\n- `har_analyze.py` - Extract structured endpoint information\n- `har_validate.py` - Validate generated code against HAR analysis\n- `har_utils.py` - Shared utility functions\n\n### Script Usage Pattern\n\nUse these scripts in sequence for optimal code generation:\n\n```bash\n# 1. Filter HAR to remove noise (static assets, analytics, CDN)\npython {SKILL_DIR}/scripts/har_filter.py {har_path} --output filtered.har --stats\n\n# 2. Analyze endpoints and extract patterns\npython {SKILL_DIR}/scripts/har_analyze.py filtered.har --output analysis.json\n\n# 3. Read analysis for code generation guidance\ncat analysis.json\n\n# 4. Generate API client code based on analysis\n\n# 5. Validate generated code\npython {SKILL_DIR}/scripts/har_validate.py api_client.py analysis.json\n```\n\n### Why Use These Scripts?\n\n**har_filter.py benefits:**\n- Reduces HAR file size by 80-90% (removes noise)\n- Focuses analysis on actual API calls\n- Significantly improves code generation quality\n- Outputs statistics showing what was filtered\n\n**har_analyze.py benefits:**\n- Provides structured endpoint information\n- Detects authentication patterns automatically\n- Identifies pagination mechanisms\n- Extracts request/response schemas\n- Groups endpoints by pattern\n\n**har_validate.py benefits:**\n- Ensures all endpoints are implemented\n- Validates authentication handling\n- Checks for proper error handling\n- Calculates coverage score (must be >= 90)\n- Identifies missing features\n\n### Task Tracking\n\nUse TodoWrite to track workflow progress:\n- Mark tasks as `pending`, `in_progress`, or `completed`\n- Only ONE task should be `in_progress` at a time\n- Complete ALL tasks - never stop early\n\n**Example TodoWrite usage:**\n```python\nTodoWrite([\n  {\"content\": \"Filter HAR using har_filter.py\", \"status\": \"in_progress\", \"activeForm\": \"Filtering HAR\"},\n  {\"content\": \"Analyze HAR using har_analyze.py\", \"status\": \"pending\", \"activeForm\": \"Analyzing endpoints\"},\n  {\"content\": \"Generate API client\", \"status\": \"pending\", \"activeForm\": \"Generating code\"},\n  {\"content\": \"Validate using har_validate.py\", \"status\": \"pending\", \"activeForm\": \"Validating code\"},\n  {\"content\": \"Test implementation\", \"status\": \"pending\", \"activeForm\": \"Testing API client\"}\n])\n```\n\n**CRITICAL:** Task tracking ensures complete workflow execution. Never skip tasks or stop early.\n\n## Phase 1: Browser Capture with HAR Recording\n\n### Starting the Browser\n\nWhen starting a browser session for API capture:\n\n1. Launch browser with HAR recording enabled via Playwright MCP\n2. Generate a unique run ID: `{run_id}`\n3. Configure HAR output path: `~/.reverse-api/runs/har/{run_id}/recording.har`\n\n### During Capture\n\nNavigate autonomously to trigger the API calls needed:\n- Login flows (capture authentication)\n- Data fetching (capture GET endpoints)\n- Form submissions (capture POST/PUT endpoints)\n- Pagination (capture query parameter patterns)\n\n### On Browser Close\n\nWhen the browser closes, note the HAR file location:\n```\nHAR file saved to: ~/.reverse-api/runs/har/{run_id}/recording.har\n```\n\n## Phase 2: HAR Analysis\n\n### Reading the HAR File\n\nHAR files are JSON with this structure:\n```json\n{\n  \"log\": {\n    \"entries\": [\n      {\n        \"request\": {\n          \"method\": \"GET|POST|PUT|DELETE\",\n          \"url\": \"https://api.example.com/endpoint\",\n          \"headers\": [...],\n          \"postData\": {...}\n        },\n        \"response\": {\n          \"status\": 200,\n          \"headers\": [...],\n          \"content\": {...}\n        }\n      }\n    ]\n  }\n}\n```\n\n### Filtering Relevant Entries\n\nFilter out noise by excluding:\n- Static assets: `.js`, `.css`, `.png`, `.jpg`, `.svg`, `.woff`, `.ico`\n- Analytics: `google-analytics`, `segment`, `mixpanel`, `hotjar`\n- Ads: `doubleclick`, `adsense`, `facebook.com/tr`\n- CDN resources: `cloudflare`, `cdn.`, `static.`\n\nFocus on:\n- API endpoints: `/api/`, `/v1/`, `/v2/`, `/graphql`\n- XHR/Fetch requests with JSON responses\n- Requests with authentication headers\n\n### Extracting Patterns\n\nFor each relevant endpoint, extract:\n\n1. **URL Pattern**: Base URL, path, query parameters\n2. **Method**: GET, POST, PUT, DELETE, PATCH\n3. **Headers**: \n   - Required headers (Authorization, Content-Type, custom headers)\n   - Optional headers (User-Agent, Accept)\n4. **Request Body**: JSON schema, form data structure\n5. **Response Schema**: JSON structure, status codes\n6. **Authentication**: See [references/AUTH_PATTERNS.md](references/AUTH_PATTERNS.md)\n\n## Phase 3: API Client Generation\n\n### Code Structure\n\nGenerate a Python module with:\n\n```\n{output_dir}/\n  api_client.py    # Main API client class\n  README.md        # Usage documentation\n```\n\n### api_client.py Template\n\n```python\n\"\"\"\nAuto-generated API client for {domain}\nGenerated from HAR capture on {date}\n\"\"\"\n\nimport requests\nfrom typing import Optional, Dict, Any, List\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n\nclass {ClassName}Client:\n    \"\"\"API client for {domain}.\"\"\"\n    \n    def __init__(\n        self,\n        base_url: str = \"{base_url}\",\n        session: Optional[requests.Session] = None,\n    ):\n        self.base_url = base_url.rstrip(\"/\")\n        self.session = session or requests.Session()\n        self._setup_session()\n    \n    def _setup_session(self):\n        \"\"\"Configure session with default headers.\"\"\"\n        self.session.headers.update({\n            \"User-Agent\": \"Mozilla/5.0 (compatible)\",\n            \"Accept\": \"application/json\",\n            # Add other required headers\n        })\n    \n    def _request(\n        self,\n        method: str,\n        endpoint: str,\n        **kwargs,\n    ) -> requests.Response:\n        \"\"\"Make an HTTP request with error handling.\"\"\"\n        url = f\"{self.base_url}{endpoint}\"\n        try:\n            response = self.session.request(method, url, **kwargs)\n            response.raise_for_status()\n            return response\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Request failed: {e}\")\n            raise\n    \n    # Generated endpoint methods go here\n    def get_example(self, param: str) -> Dict[str, Any]:\n        \"\"\"\n        Fetch example data.\n        \n        Args:\n            param: Description of parameter\n            \n        Returns:\n            JSON response data\n        \"\"\"\n        response = self._request(\"GET\", f\"/api/example/{param}\")\n        return response.json()\n\n\n# Example usage\nif __name__ == \"__main__\":\n    client = {ClassName}Client()\n    # Example calls\n```\n\n### Code Quality Requirements\n\nAll generated code must include:\n\n1. **Type hints** for all parameters and return values\n2. **Docstrings** for all public methods\n3. **Error handling** with try-except blocks\n4. **Logging** for debugging\n5. **Session management** for connection reuse\n6. **Authentication handling** based on detected patterns\n\n## Phase 4: Testing & Refinement\n\n### Testing the Generated Client\n\nAfter generating the client:\n\n1. Run the example usage section\n2. Verify responses match expected structure\n3. Handle any errors encountered\n\n### Iteration Protocol\n\nYou have up to 5 attempts to fix issues:\n\n```\nAttempt 1: Initial implementation\n  - What was tried\n  - What failed (if anything)\n  - What was changed\n\nAttempt 2: Refinement\n  ...\n```\n\n### Common Issues\n\n| Issue | Solution |\n|-------|----------|\n| 403 Forbidden | Add missing headers, check authentication |\n| Bot detection | Switch to Playwright with stealth mode |\n| Rate limiting | Add delays, respect Retry-After headers |\n| Session expiry | Implement token refresh logic |\n| CORS errors | Use server-side requests (not applicable to Python) |\n\n## Domain Discovery (Optional)\n\nBefore capture, you may want to map the domain to understand its structure.\n\n### Using the Mapper Script\n\nRun `scripts/mapper.py` to quickly discover:\n- All pages on the domain or subdomains\n- Subdomains\n\nIt is useful for generalizing your scripts on multitenants websites.\n\nFor example, for Ashby ATS or Workday it's useful to find other companies using this ATS when trying to generalize your script.\n\n```bash\npython scripts/mapper.py https://example.com\n```\n\n### Using the Sitemap Parser\n\nRun `scripts/sitemap.py` to extract URLs from sitemaps:\n\n```bash\npython scripts/sitemap.py https://example.com\n```\n\n## Output Locations\n\n- **HAR files**: `~/.reverse-api/runs/har/{run_id}/`\n- **Generated scripts**: `./{task_name}`\n\n## Example Session\n\n```\nUser: \"Create an API client for the Apple Jobs website\"\n\n\n1. [Browser Capture]\n   Launch browser with HAR recording\n   Navigate to jobs.apple.com\n   Perform search, browse listings\n   Close browser\n   HAR saved to: ~/.reverse-api/runs/har/{run_id}/recording.har\n\n   Note: you can monitor browser requests with the Playwright MCP\n\n2. [HAR Analysis]\n   Found endpoints:\n   - GET /api/role/search?query=...\n   - GET /api/role/{id}\n   Authentication: None required (public API)\n\n3. [Generate Client]\n   Create : {task_name}/api_client.py\n   \n4. [Test]\n   Ran example usage - Success!\n   \n5. [Summary]\n   Generated Apple Jobs API client with:\n   - search_roles(query, location, page)\n   - get_role(role_id)\n   Files: ./{task_name}/\n```"
              }
            ]
          }
        ]
      }
    }
  ]
}