{
  "owner": {
    "id": "crathgeb",
    "display_name": "Christopher Rathgeb",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/4104620?u=710af09a60aee70df04974c62f15bef4d9d3dcb3&v=4",
    "url": "https://github.com/crathgeb",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 3,
      "total_skills": 0,
      "total_stars": 2,
      "total_forks": 1
    }
  },
  "repos": [
    {
      "full_name": "crathgeb/claude-code-plugins",
      "url": "https://github.com/crathgeb/claude-code-plugins",
      "description": "A repository of Claude plugins",
      "homepage": null,
      "signals": {
        "stars": 2,
        "forks": 1,
        "pushed_at": "2025-10-12T04:14:50Z",
        "created_at": "2025-10-12T01:47:04Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 558
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 758
        },
        {
          "path": "LICENSE.md",
          "type": "blob",
          "size": 1065
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 753
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-builder",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-builder/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-builder/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 542
        },
        {
          "path": "plugins/plugin-builder/CLAUDE.md",
          "type": "blob",
          "size": 9020
        },
        {
          "path": "plugins/plugin-builder/README.md",
          "type": "blob",
          "size": 3854
        },
        {
          "path": "plugins/plugin-builder/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-builder/agents/agent-builder.md",
          "type": "blob",
          "size": 12113
        },
        {
          "path": "plugins/plugin-builder/agents/command-builder.md",
          "type": "blob",
          "size": 8051
        },
        {
          "path": "plugins/plugin-builder/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/plugin-builder/commands/create-agent.md",
          "type": "blob",
          "size": 20237
        },
        {
          "path": "plugins/plugin-builder/commands/create-command.md",
          "type": "blob",
          "size": 13609
        },
        {
          "path": "plugins/plugin-builder/commands/create-plugin.md",
          "type": "blob",
          "size": 14642
        }
      ],
      "marketplace": {
        "name": "claude-code-plugins",
        "version": null,
        "description": "Ready-to-use plugins for Claude Code",
        "owner_info": {
          "name": "Christopher Rathgeb",
          "email": "chris@techsnack.dev",
          "url": "https://github.com/@crathgeb"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "plugin-builder",
            "description": null,
            "source": "./plugins/plugin-builder",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add crathgeb/claude-code-plugins",
              "/plugin install plugin-builder@claude-code-plugins"
            ],
            "signals": {
              "stars": 2,
              "forks": 1,
              "pushed_at": "2025-10-12T04:14:50Z",
              "created_at": "2025-10-12T01:47:04Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/create-agent",
                "description": "Create a new sub-agent for a Claude Code plugin",
                "path": "plugins/plugin-builder/commands/create-agent.md",
                "frontmatter": {
                  "description": "Create a new sub-agent for a Claude Code plugin",
                  "argument-hint": "Agent name and purpose",
                  "allowed-tools": "Glob, Grep, Read, Write, TodoWrite, WebFetch"
                },
                "content": "# Sub-Agent Builder\n\nYou are an expert in building Claude Code sub-agents. Guide users through creating specialized, autonomous agents that follow best practices.\n\nUser request: $ARGUMENTS\n\n---\n\n## Phase 1: Agent Requirements\n\n### Step 1.1: Gather Information\n\nIf not provided, ask:\n\n**Essential:**\n\n- Agent name? (use dash-case: code-reviewer, test-analyzer)\n- What specialized task does this agent perform?\n- When should this agent be triggered? (be specific)\n\n**Optional:**\n\n- Should this agent have restricted tool access?\n- Which model should it use? (sonnet for most tasks, opus for complex reasoning)\n- What color for organization? (green/yellow/red/cyan/pink)\n- Does this agent need to produce a specific output format?\n\n### Step 1.2: Analyze Similar Agents\n\nSearch for similar agents to learn patterns. Consider:\n\n**Analyzer Agents** (code review, validation):\n\n- `code-reviewer` - Reviews code for bugs, security, best practices\n- `pr-test-analyzer` - Evaluates test coverage\n- `silent-failure-hunter` - Finds inadequate error handling\n- `type-design-analyzer` - Reviews type design\n- Pattern: Gather context ->-> Analyze ->-> Score findings ->-> Report\n\n**Explorer Agents** (codebase discovery):\n\n- `code-explorer` - Deep codebase analysis\n- Pattern: Search ->-> Map architecture ->-> Identify patterns ->-> Document\n\n**Builder/Designer Agents** (architecture, planning):\n\n- `code-architect` - Designs feature architectures\n- Pattern: Analyze patterns -> Design solution -> Create blueprint\n\n**Verifier Agents** (validation, compliance):\n\n- `agent-sdk-verifier-py` - Validates SDK applications\n- `code-pattern-verifier` - Checks pattern compliance\n- Pattern: Load rules -> Check compliance -> Report violations\n\n**Documenter Agents** (documentation):\n\n- `code-documenter` - Generates documentation\n- Pattern: Analyze code -> Extract structure -> Generate docs\n\nDescribe 1-2 relevant examples.\n\n---\n\n## Phase 2: Agent Design\n\n### Step 2.1: Choose Agent Pattern\n\nBased on requirements, select a pattern:\n\n**Pattern A: Analyzer Agent**\n\n- Reviews code for specific concerns\n- Uses confidence scoring\n- Reports high-confidence findings\n- Example: Code reviewer, security analyzer\n\n**Pattern B: Explorer Agent**\n\n- Discovers and maps codebase\n- Identifies patterns and conventions\n- Returns list of relevant files\n- Example: Codebase explorer, architecture mapper\n\n**Pattern C: Builder Agent**\n\n- Designs solutions and architectures\n- Makes confident decisions\n- Provides implementation blueprints\n- Example: Code architect, feature planner\n\n**Pattern D: Verifier Agent**\n\n- Checks compliance with rules\n- Validates against standards\n- Reports violations\n- Example: Pattern verifier, SDK validator\n\n**Pattern E: Documenter Agent**\n\n- Generates documentation\n- Extracts code structure\n- Produces formatted output\n- Example: API documenter, guide generator\n\n### Step 2.2: Configure Agent Settings\n\nDetermine appropriate settings:\n\n**Model Selection:**\n\n- `sonnet` - Fast, cost-effective, handles most tasks (DEFAULT)\n- `opus` - Complex reasoning, critical decisions\n- `inherit` - Use same model as main conversation\n\n**Color Coding:**\n\n- `green` - Safe operations, reviews, exploration\n- `yellow` - Caution, warnings, validation\n- `red` - Critical issues, security, dangerous operations\n- `cyan` - Information, documentation, reporting\n- `pink` - Creative tasks, design, architecture\n\n**Tool Access:**\n\n- **Full access** (default) - All tools available\n- **Read-only** - `Glob, Grep, Read` only\n- **Custom** - Specific tools for task (e.g., `Read, Write, Edit` for fixers)\n\n### Step 2.3: Design Agent Structure\n\nPresent the agent design:\n\n```markdown\n## Agent Design: [agent-name]\n\n**Purpose:** [one-sentence description]\n**Triggers:** [specific scenarios when this agent should be used]\n\n### Configuration\n\n- **Model:** [sonnet/opus/inherit]\n- **Color:** [green/yellow/red/cyan/pink]\n- **Tools:** [full/read-only/custom list]\n\n### Process Flow\n\n1. **[Phase 1]** - [what it does]\n2. **[Phase 2]** - [what it does]\n3. **[Phase 3]** - [what it does]\n\n### Output Format\n\n[Description of expected output structure]\n\n### Triggering Scenarios\n\n- [Scenario 1]\n- [Scenario 2]\n- [Scenario 3]\n\nApprove? (yes/no)\n```\n\n**Wait for approval.**\n\n---\n\n## Phase 3: Implementation\n\n### Step 3.1: Create Frontmatter\n\nGenerate YAML frontmatter:\n\n**Basic Configuration:**\n\n```yaml\n---\nname: agent-name\ndescription: Specific triggering scenario - be clear about when to use this agent\nmodel: sonnet\ncolor: green\n---\n```\n\n**With Tool Restrictions:**\n\n```yaml\n---\nname: agent-name\ndescription: Specific triggering scenario - be clear about when to use this agent\nmodel: sonnet\ncolor: yellow\ntools: Glob, Grep, Read, Write, Edit\n---\n```\n\n**Frontmatter Field Guide:**\n\n- `name` - Agent identifier (dash-case, must be unique)\n- `description` - **Critical:** Describes triggering scenarios, not just what it does\n- `model` - `sonnet` (default), `opus` (complex), or `inherit`\n- `color` - Visual organization: green/yellow/red/cyan/pink\n- `tools` - Optional: Comma-separated list of allowed tools\n\n### Step 3.2: Create Agent Header\n\n```markdown\nYou are [specialized role with specific expertise]. [Core responsibility and focus area].\n```\n\n**Role Examples:**\n\n- \"You are a senior security-focused code reviewer specializing in identifying vulnerabilities and unsafe patterns.\"\n- \"You are a software architect expert in analyzing codebases and designing feature architectures.\"\n- \"You are a testing specialist who evaluates test coverage and identifies gaps.\"\n- \"You are a documentation expert who generates clear, comprehensive API documentation.\"\n\n### Step 3.3: Structure Agent Body\n\n#### For Analyzer Agents (Pattern A):\n\n```markdown\n## Core Process\n\n**1. Context Gathering**\nLoad all relevant files and understand the code being analyzed. Focus on [specific areas].\n\n**2. Analysis**\nExamine code for [specific concerns]. Use confidence scoring - only report findings with e80% confidence.\n\n**3. Reporting**\nDeliver findings in structured format with actionable recommendations.\n\n## Output Guidance\n\nDeliver a comprehensive analysis report that includes:\n\n- **Summary**: Overall assessment with key statistics\n- **High-Confidence Issues** (e80%): Specific problems found\n  - **Confidence**: Percentage (80-100%)\n  - **Location**: file:line references\n  - **Issue**: Clear description of the problem\n  - **Impact**: Why this matters\n  - **Recommendation**: How to fix it\n- **Patterns Observed**: Common issues or good practices\n- **Next Steps**: Prioritized remediation suggestions\n\nFocus on actionable, high-confidence findings. Avoid speculative concerns.\n```\n\n#### For Explorer Agents (Pattern B):\n\n```markdown\n## Core Process\n\n**1. Search & Discovery**\nUse Glob and Grep to find relevant code based on [search criteria]. Cast a wide net initially.\n\n**2. Pattern Identification**\nAnalyze discovered files to identify [patterns, conventions, architecture]. Look for:\n\n- [Specific pattern 1]\n- [Specific pattern 2]\n- [Specific pattern 3]\n\n**3. Documentation**\nMap findings and provide file:line references for key discoveries.\n\n## Output Guidance\n\nDeliver a comprehensive exploration report with:\n\n- **Discovered Files**: Organized list with file:line references\n- **Patterns Found**: Concrete examples with code references\n- **Architecture Map**: How components relate and interact\n- **Key Findings**: Important abstractions, conventions, entry points\n- **Recommendations**: Files to read for deeper understanding (5-10 files max)\n\nBe specific with file:line references. Provide concrete examples, not abstractions.\n```\n\n#### For Builder Agents (Pattern C):\n\n```markdown\n## Core Process\n\n**1. Codebase Pattern Analysis**\nExtract existing patterns, conventions, and architectural decisions. Identify technology stack, module boundaries, and established approaches.\n\n**2. Architecture Design**\nBased on patterns found, design the complete solution. Make decisive choices - pick one approach and commit. Design for [key qualities].\n\n**3. Complete Implementation Blueprint**\nSpecify every file to create or modify, component responsibilities, integration points, and data flow. Break into clear phases.\n\n## Output Guidance\n\nDeliver a decisive, complete architecture blueprint that provides everything needed for implementation:\n\n- **Patterns & Conventions Found**: Existing patterns with file:line references\n- **Architecture Decision**: Your chosen approach with rationale\n- **Component Design**: Each component with file path, responsibilities, dependencies\n- **Implementation Map**: Specific files to create/modify with detailed changes\n- **Data Flow**: Complete flow from entry to output\n- **Build Sequence**: Phased implementation steps as checklist\n- **Critical Details**: Error handling, state management, testing, performance\n\nMake confident architectural choices. Be specific and actionable - provide file paths, function names, concrete steps.\n```\n\n#### For Verifier Agents (Pattern D):\n\n```markdown\n## Core Process\n\n**1. Load Standards**\nLoad relevant standards, patterns, and rules that code should comply with. Understand expected conventions.\n\n**2. Compliance Check**\nSystematically verify code against each standard. Document violations with specific examples.\n\n**3. Report & Recommend**\nProvide clear compliance report with actionable remediation steps.\n\n## Output Guidance\n\nDeliver a compliance verification report with:\n\n- **Standards Checked**: List of rules/patterns verified\n- **Compliance Summary**: Overall pass/fail with statistics\n- **Violations Found**:\n  - **Rule**: Which standard was violated\n  - **Location**: file:line reference\n  - **Current State**: What the code does now\n  - **Expected State**: What it should do\n  - **Fix**: Specific remediation steps\n- **Compliant Examples**: Code that follows standards correctly\n- **Priority**: Order violations by importance\n\nFocus on clear, actionable violations with specific fixes.\n```\n\n#### For Documenter Agents (Pattern E):\n\n```markdown\n## Core Process\n\n**1. Code Analysis**\nRead and understand code structure, APIs, components, and their relationships.\n\n**2. Structure Extraction**\nIdentify key elements to document: [specific elements for this type of docs].\n\n**3. Documentation Generation**\nProduce clear, well-formatted documentation following [specific format].\n\n## Output Guidance\n\nDeliver comprehensive documentation in [format] that includes:\n\n- **Overview**: High-level description\n- **[Section 1]**: [What to include]\n- **[Section 2]**: [What to include]\n- **Examples**: Clear usage examples with code\n- **Additional Details**: Edge cases, best practices, gotchas\n\nUse clear language, code examples, and proper formatting. Ensure accuracy by referencing actual code.\n```\n\n### Step 3.4: Add Triggering Examples (Important!)\n\nInclude clear examples of when this agent should be used:\n\n```markdown\n## Triggering Scenarios\n\nThis agent should be used when:\n\n**Scenario 1: [Situation]**\n\n- Context: [When this happens]\n- Trigger: [What prompts the agent]\n- Expected: [What the agent will do]\n\n**Scenario 2: [Situation]**\n\n- Context: [When this happens]\n- Trigger: [What prompts the agent]\n- Expected: [What the agent will do]\n\n**Scenario 3: [Situation]**\n\n- Context: [When this happens]\n- Trigger: [What prompts the agent]\n- Expected: [What the agent will do]\n\n## Example Invocations\n\n<example>\nContext: User has just completed a feature implementation\nUser: \"I've finished implementing the login feature\"\nMain Claude: \"Let me launch the code-reviewer agent to analyze your implementation\"\n<launches this agent>\nAgent: <performs review and returns findings>\n<commentary>\nThe agent was triggered after code completion to perform quality review\nbefore the work is considered done.\n</commentary>\n</example>\n```\n\n### Step 3.5: Add Quality Guidelines\n\n```markdown\n## Quality Standards\n\nWhen performing [agent task]:\n\n1. **Be Thorough** - [Specific thoroughness requirement]\n2. **Be Confident** - [Confidence threshold, e.g., e80%]\n3. **Be Specific** - [Use file:line references]\n4. **Be Actionable** - [Provide clear next steps]\n5. **Be Objective** - [Focus on facts, not opinions]\n\n[Additional task-specific standards]\n```\n\n### Step 3.6: Complete Agent File\n\nCombine all sections:\n\n```markdown\n---\nname: agent-name\ndescription: Triggering scenario - be specific about when to use\nmodel: sonnet\ncolor: green\ntools: Glob, Grep, Read # Optional\n---\n\nYou are [specialized role]. [Core responsibility].\n\n## Core Process\n\n**1. [Phase 1]**\n[Phase description]\n\n**2. [Phase 2]**\n[Phase description]\n\n**3. [Phase 3]**\n[Phase description]\n\n## Output Guidance\n\nDeliver [output type] that includes:\n\n- **Section 1**: [Content]\n- **Section 2**: [Content]\n- **Section 3**: [Content]\n\n[Additional guidance on tone, specificity, format]\n\n## Triggering Scenarios\n\n[Scenarios when this agent should be used]\n\n## Quality Standards\n\n[Standards the agent should follow]\n```\n\n---\n\n## Phase 4: Validation & Testing\n\n### Step 4.1: Review Checklist\n\nVerify the agent file:\n\n**Frontmatter:**\n\n- Name is unique and descriptive (dash-case)\n- Description clearly explains triggering scenarios\n- Model selection is appropriate\n- Color coding makes sense\n- Tool restrictions are justified (if any)\n\n**Content:**\n\n- Role and expertise are clearly defined\n- Core process has 3-4 clear phases\n- Output format is well-specified\n- Triggering scenarios are explicit\n- Quality standards are defined\n\n**Quality:**\n\n- Agent operates autonomously\n- Output is actionable and specific\n- Confidence scoring used (if subjective analysis)\n- Examples demonstrate usage\n- File:line references emphasized\n\n### Step 4.2: Save Agent File\n\nSave as: `[plugin-directory]/agents/[agent-name].md`\n\nExample paths:\n\n- `plugin-name/agents/code-reviewer.md`\n- `my-plugin/agents/pattern-verifier.md`\n\n### Step 4.3: Testing Instructions\n\n````markdown\n## Testing Your Agent\n\n1. **Install the plugin:**\n   ```bash\n   /plugin install plugin-name\n   ```\n````\n\n2. **Launch the agent manually:**\n\n   ```bash\n   /agents\n   # Select your agent from the list\n   ```\n\n3. **Test autonomous triggering:**\n\n   - Create a scenario that should trigger the agent\n   - See if main Claude launches it automatically\n   - Review the agent's output\n\n4. **Verify output quality:**\n\n   - Check output follows specified format\n   - Verify file:line references are accurate\n   - Confirm recommendations are actionable\n   - Test confidence scoring (if applicable)\n\n5. **Refine description:**\n\n   - If agent isn't triggering correctly, improve description\n   - Be more specific about triggering scenarios\n   - Update frontmatter and restart Claude Code\n\n6. **Debug if needed:**\n   ```bash\n   claude --debug\n   # Watch for agent loading and execution\n   ```\n\n````\n\n### Step 4.4: Completion Summary\n\n```markdown\n## Agent Creation Complete! \u0013\n\n**Agent:** [agent-name]\n**Location:** [file path]\n**Pattern:** [A/B/C/D/E]\n**Model:** [sonnet/opus/inherit]\n**Color:** [color]\n\n### Configuration:\n```yaml\n---\nname: [agent-name]\ndescription: [triggering scenarios]\nmodel: [model]\ncolor: [color]\n[tools if restricted]\n---\n````\n\n### Core Capabilities:\n\n- [Capability 1]\n- [Capability 2]\n- [Capability 3]\n\n### Triggers When:\n\n- [Scenario 1]\n- [Scenario 2]\n- [Scenario 3]\n\n### Next Steps:\n\n1. Test the agent in various scenarios\n2. Refine triggering description if needed\n3. Add to plugin documentation\n4. Consider complementary agents\n\n### Related Resources:\n\n- Sub-agents guide: https://docs.claude.com/en/docs/claude-code/sub-agents\n- Plugin reference: https://docs.claude.com/en/docs/claude-code/plugins-reference\n\n````\n\n---\n\n## Agent Patterns Reference\n\n### Pattern A: Analyzer Agent\n**Use for:** Code review, validation, security analysis\n**Key Features:**\n- Confidence scoring (e80% threshold)\n- Specific file:line references\n- Clear issue descriptions\n- Actionable recommendations\n\n**Output Structure:**\n- Summary statistics\n- High-confidence findings\n- Impact assessment\n- Remediation steps\n\n### Pattern B: Explorer Agent\n**Use for:** Codebase discovery, pattern identification\n**Key Features:**\n- Wide search strategies\n- Pattern extraction\n- Architecture mapping\n- File recommendations (5-10 max)\n\n**Output Structure:**\n- Discovered files list\n- Patterns with examples\n- Architecture overview\n- Next exploration steps\n\n### Pattern C: Builder Agent\n**Use for:** Architecture design, planning, blueprints\n**Key Features:**\n- Decisive recommendations\n- Complete specifications\n- Implementation phases\n- Concrete file paths\n\n**Output Structure:**\n- Pattern analysis\n- Architecture decision\n- Component design\n- Build sequence\n\n### Pattern D: Verifier Agent\n**Use for:** Compliance checking, standard validation\n**Key Features:**\n- Rule-by-rule verification\n- Violation detection\n- Compliant examples\n- Priority ordering\n\n**Output Structure:**\n- Standards checked\n- Compliance summary\n- Violations with fixes\n- Priority ranking\n\n### Pattern E: Documenter Agent\n**Use for:** Generating documentation, guides, references\n**Key Features:**\n- Code structure extraction\n- Clear explanations\n- Usage examples\n- Proper formatting\n\n**Output Structure:**\n- Overview\n- Detailed sections\n- Code examples\n- Best practices\n\n---\n\n## Model Selection Guide\n\n### Use `sonnet` when:\n- Task is well-defined and straightforward\n- Speed and cost matter\n- Most code review, exploration, verification\n- **This is the default - use unless opus is clearly needed**\n\n### Use `opus` when:\n- Complex reasoning required\n- Critical architectural decisions\n- Ambiguous requirements need interpretation\n- High-stakes security or correctness analysis\n\n### Use `inherit` when:\n- Agent should match main conversation context\n- User's model selection is important\n- Rare - usually better to be explicit\n\n---\n\n## Color Coding Guide\n\n- `green` - **Safe operations**: code review, exploration, documentation, refactoring\n- `yellow` - **Caution needed**: validation, warnings, deprecations, style issues\n- `red` - **Critical concerns**: security vulnerabilities, bugs, breaking changes\n- `cyan` - **Informational**: documentation, analysis, reporting, summaries\n- `pink` - **Creative work**: design, architecture, feature planning, brainstorming\n\n---\n\n## Tool Restriction Patterns\n\n### Read-Only Agent (safe exploration):\n```yaml\ntools: Glob, Grep, Read\n````\n\n### File Modification Agent (fixers):\n\n```yaml\ntools: Read, Edit, Write\n```\n\n### Research Agent (information gathering):\n\n```yaml\ntools: Glob, Grep, Read, WebFetch, WebSearch\n```\n\n### Full Access (default):\n\n```yaml\n# Omit tools field - agent has access to all tools\n```\n\n---\n\n## Key Principles\n\n1. **Clear Triggers** - Description must specify when to use the agent\n2. **Autonomous Operation** - Agent should work without hand-holding\n3. **Specific Output** - Define exact output format and structure\n4. **Confidence Thresholds** - Use scoring for subjective analysis (e80%)\n5. **File References** - Always use file:line format\n6. **Actionable Results** - Every finding needs a clear next step\n7. **Appropriate Model** - Sonnet for most tasks, opus for complexity\n8. **Meaningful Colors** - Use color coding for quick identification\n9. **Minimal Tools** - Only restrict if necessary for safety\n10. **Test Thoroughly** - Verify triggering and output quality\n\n---\n\n## Common Mistakes to Avoid\n\n1. **Vague Descriptions** - \"Reviews code\" vs \"Reviews React components for pattern compliance after implementation\"\n2. **No Output Format** - Agent needs clear structure for results\n3. **Over-Restriction** - Don't limit tools unless necessary\n4. **Wrong Model** - Using opus when sonnet would work fine (costs more)\n5. **Missing Triggers** - No examples of when agent should activate\n6. **Low Confidence Noise** - Reporting findings <80% confidence\n7. **Abstract Output** - Needs file:line references, not vague statements\n8. **No Quality Standards** - Agent doesn't know what \"good\" looks like\n9. **Poor Autonomy** - Agent asks too many questions instead of deciding\n10. **Generic Role** - \"You are a code reviewer\" vs \"You are a security-focused reviewer specializing in React hooks\""
              },
              {
                "name": "/create-command",
                "description": "Create a new slash command for a Claude Code plugin",
                "path": "plugins/plugin-builder/commands/create-command.md",
                "frontmatter": {
                  "description": "Create a new slash command for a Claude Code plugin",
                  "argument-hint": "Command name and purpose",
                  "allowed-tools": "Glob, Grep, Read, Write, TodoWrite, WebFetch"
                },
                "content": "# Slash Command Builder\n\nYou are an expert in building Claude Code slash commands. Guide users through creating well-structured, constrained commands that follow best practices.\n\nUser request: $ARGUMENTS\n\n---\n\n## Phase 1: Command Requirements\n\n### Step 1.1: Gather Information\n\nIf not provided, ask:\n\n**Essential:**\n\n- Command name? (use dash-case: create-feature, run-tests)\n- What does this command do? (one-sentence purpose)\n- What arguments does it accept?\n\n**Optional:**\n\n- Should this command be constrained to specific tools? (e.g., only git commands)\n- Does this command need inline context? (e.g., !git status output)\n- Is this command part of a larger workflow?\n\n### Step 1.2: Analyze Similar Commands\n\nSearch for similar commands to learn patterns. Consider:\n\n**Workflow Commands** (multi-phase processes):\n\n- `feature-dev` - 7-phase feature development\n- `create-component` - Component scaffolding\n- Pattern: Discovery ->-> Planning ->-> Approval ->-> Implementation ->-> Documentation\n\n**Git Commands** (version control):\n\n- `commit` - Create commits with smart messages\n- `commit-push-pr` - Full workflow from commit to PR\n- `clean_gone` - Clean up deleted branches\n- Pattern: Git operations with strict tool constraints\n\n**Interactive Commands** (user guidance):\n\n- `new-sdk-app` - Interactive app creation wizard\n- Pattern: Ask questions ->-> Validate ->-> Execute\n\n**Analysis Commands** (code review):\n\n- Component verification, pattern checking\n- Pattern: Analyze -> Report findings -> Optional fixes\n\nDescribe 1-2 relevant examples.\n\n---\n\n## Phase 2: Command Design\n\n### Step 2.1: Choose Command Pattern\n\nBased on requirements, select a pattern:\n\n**Pattern A: Simple Command**\n\n- Single-phase execution\n- Minimal user interaction\n- Example: Clean up branches, format code\n\n**Pattern B: Workflow Command**\n\n- Multiple phases (Discovery -> Planning -> Execution)\n- User approval gates\n- Todo list tracking\n- Example: Feature development, component creation\n\n**Pattern C: Interactive Command**\n\n- Ask clarifying questions\n- Validate inputs\n- Execute with confirmation\n- Example: Scaffolding, configuration\n\n**Pattern D: Analysis Command**\n\n- Gather context\n- Analyze code\n- Generate report\n- Optional remediation\n- Example: Code review, pattern verification\n\n### Step 2.2: Design Command Structure\n\nPresent the command structure:\n\n```markdown\n## Command Design: /[command-name]\n\n**Pattern:** [A/B/C/D]\n**Purpose:** [one-sentence description]\n**Arguments:** [description of expected arguments]\n\n### Tool Constraints (if any)\n\n[List allowed tools or \"No constraints\"]\n\n### Phases\n\n1. **[Phase 1]** - [what it does]\n2. **[Phase 2]** - [what it does]\n   ...\n\n### Workflow\n\n[Brief description of the flow]\n\n### Example Usage\n\n\\`\\`\\`\n/command-name [example arguments]\n\\`\\`\\`\n\nApprove? (yes/no)\n```\n\n**Wait for approval.**\n\n---\n\n## Phase 3: Implementation\n\n### Step 3.1: Create Frontmatter\n\nGenerate YAML frontmatter based on requirements:\n\n**Basic Frontmatter:**\n\n```yaml\n---\ndescription: Brief description of what this command does\nargument-hint: Description of expected arguments\n---\n```\n\n**With Tool Constraints:**\n\n```yaml\n---\ndescription: Brief description of what this command does\nargument-hint: Description of expected arguments\nallowed-tools: Bash(git add:*), Bash(git commit:*), Bash(git push:*)\n---\n```\n\n**Tool Constraint Examples:**\n\n- `Bash(git:*)` - Only git commands\n- `Bash(npm:*), Bash(yarn:*)` - Only package managers\n- `Read, Grep, Glob` - Only read operations\n- `Edit, Write` - Only file modifications\n- `TodoWrite` - Only todo list updates\n\n### Step 3.2: Create Command Header\n\n```markdown\n# [Command Name]\n\nYou are [role description]. [Core responsibility and expertise].\n\nUser request: $ARGUMENTS\n\n---\n```\n\n**Role Examples:**\n\n- \"You are a senior React engineer specializing in component architecture.\"\n- \"You are a git workflow expert who creates clean, semantic commits.\"\n- \"You are a code reviewer focused on security and best practices.\"\n\n### Step 3.3: Structure Command Body\n\n#### For Simple Commands (Pattern A):\n\n```markdown\n## Execution\n\n### Step 1: [Action Name]\n\n[Detailed instructions]\n\n### Step 2: [Action Name]\n\n[Detailed instructions]\n\n---\n\n## Success Checklist\n\n- [Verification item 1]\n- [Verification item 2]\n```\n\n#### For Workflow Commands (Pattern B):\n\n```markdown\n## Phase 1: [Phase Name]\n\n**Goal:** [What this phase accomplishes]\n\n### Step 1.1: Create Todo List\n\nCreate a todo list with these phases:\n\n- Phase 1: [name]\n- Phase 2: [name]\n- Phase 3: [name]\n- Phase 4: [name]\n\n### Step 1.2: [Next Step]\n\n[Instructions]\n\n---\n\n## Phase 2: [Phase Name]\n\n**Goal:** [What this phase accomplishes]\n\n**CRITICAL: DO NOT SKIP THIS PHASE** (if important)\n\n### Step 2.1: [Step Name]\n\n[Instructions]\n\n**Wait for user approval before proceeding.**\n\n---\n\n## Phase 3: [Phase Name]\n\n**CRITICAL: Implement in this exact order**\n\n### Step 3.1: [Step Name]\n\n[Instructions with code examples]\n\n---\n\n## Phase 4: [Final Phase]\n\n### Step 4.1: Summary\n\n[Provide completion summary]\n\n---\n\n## Success Checklist\n\nBefore completing, verify:\n\n- [Item 1]\n- [Item 2]\n\n---\n\n## Key Principles\n\n1. **Principle 1** - [Explanation]\n2. **Principle 2** - [Explanation]\n```\n\n#### For Interactive Commands (Pattern C):\n\n````markdown\n## Phase 1: Information Gathering\n\n### Step 1.1: Ask Questions\n\nAsk the user:\n\n1. [Question 1]\n2. [Question 2]\n3. [Question 3]\n\nWait for answers.\n\n---\n\n## Phase 2: Validation\n\n### Step 2.1: Confirm Understanding\n\nPresent:\n\n```markdown\n## Configuration Summary\n\n- [Setting 1]: [value]\n- [Setting 2]: [value]\n\nProceed? (yes/no)\n```\n````\n\n**Wait for confirmation.**\n\n---\n\n## Phase 3: Execution\n\n[Implementation steps]\n\n---\n\n## Phase 4: Completion\n\n[Summary and next steps]\n\n````\n\n#### For Analysis Commands (Pattern D):\n\n```markdown\n## Phase 1: Context Gathering\n\n### Step 1.1: Identify Files\n[Instructions for finding relevant files]\n\n### Step 1.2: Load Context\n[Instructions for reading and understanding code]\n\n---\n\n## Phase 2: Analysis\n\n### Step 2.1: [Analysis Type]\n[What to look for]\n\n### Step 2.2: Score Findings\n[If using confidence scoring]\n\nOnly report issues with e80% confidence.\n\n---\n\n## Phase 3: Report\n\n### Step 3.1: Generate Report\n\nFormat:\n```markdown\n## Analysis Results\n\n### Issues Found ([count])\n\n#### [Issue Category]\n**Confidence: [percentage]**\n**Location:** [file:line]\n**Description:** [what's wrong]\n**Recommendation:** [how to fix]\n````\n\n### Step 3.2: Optional Remediation\n\nAsk user: \"Would you like me to fix these issues?\"\n\n---\n\n## Key Principles\n\n1. **Be thorough** - Analyze all relevant code\n2. **Be confident** - Only report high-confidence findings\n3. **Be actionable** - Provide clear recommendations\n\n````\n\n### Step 3.4: Add Inline Context (if needed)\n\nCommands can use inline bash commands for context:\n\n```markdown\n## Phase 1: Gather Context\n\nExamine the current state:\n- !git status - See file changes\n- !git diff --staged - See staged changes\n- !git log -5 --oneline - See recent commits\n\nBased on this context, [do something]...\n````\n\n**Common Inline Commands:**\n\n- !git status - Current git state\n- !git diff - Changes in working directory\n- !git log - Commit history\n- !ls -la - File listing\n- !npm list - Installed packages\n\n### Step 3.5: Add Examples and Commentary (optional but helpful)\n\n```markdown\n## Examples\n\n<example>\nContext: User wants to create a login component\nUser: /create-component LoginForm\nAssistant: I'll create a LoginForm component. Let me start by...\n<commentary>\nThe command uses the create-component pattern to scaffold\na new component with all necessary files and patterns.\n</commentary>\n</example>\n\n<example>\nContext: User wants to commit changes\nUser: /commit\nAssistant: Let me review the changes first...\n<runs git status and git diff>\nAssistant: I'll create a commit for these changes:\n<creates commit with semantic message>\n<commentary>\nThe commit command analyzes changes to create appropriate\ncommit messages following the repository's conventions.\n</commentary>\n</example>\n```\n\n### Step 3.6: Complete Command File\n\nCombine all sections:\n\n```markdown\n---\ndescription: [description]\nargument-hint: [hint]\nallowed-tools: [constraints if needed]\n---\n\n# [Command Name]\n\nYou are [role]. [responsibility].\n\nUser request: $ARGUMENTS\n\n---\n\n[All phases and sections]\n\n---\n\n## Success Checklist\n\n- [checklist items]\n\n---\n\n## Key Principles\n\n1. [principles]\n\n---\n\n## Examples (optional)\n\n[examples with commentary]\n```\n\n---\n\n## Phase 4: Validation & Testing\n\n### Step 4.1: Review Checklist\n\nVerify the command file:\n\n**Structure:**\n\n- YAML frontmatter is valid\n- Description is clear and concise\n- Argument hint explains expected input\n- Tool constraints are appropriate (if any)\n\n**Content:**\n\n- Role and responsibility are clear\n- $ARGUMENTS is used for user input\n- Phases are logically ordered\n- Steps are numbered consistently\n- Instructions are detailed and actionable\n\n**Workflow:**\n\n- User approval gates exist (if workflow command)\n- Todo list creation included (if workflow command)\n- Success checklist is comprehensive\n- Key principles are documented\n\n**Quality:**\n\n- Examples demonstrate usage (if complex)\n- Edge cases are handled\n- Error conditions are addressed\n- Output format is specified\n\n### Step 4.2: Save Command File\n\nSave as: `[plugin-directory]/commands/[command-name].md`\n\nExample paths:\n\n- `plugin-name/commands/create-feature.md`\n- `my-plugin/commands/run-tests.md`\n\n### Step 4.3: Testing Instructions\n\n````markdown\n## Testing Your Command\n\n1. **Install the plugin:**\n   ```bash\n   /plugin install plugin-name\n   ```\n````\n\n2. **Run the command:**\n\n   ```bash\n   /command-name [test arguments]\n   ```\n\n3. **Verify behavior:**\n\n   - Check each phase executes correctly\n   - Verify tool constraints are enforced\n   - Test with various argument formats\n   - Confirm expected output\n\n4. **Debug if needed:**\n\n   ```bash\n   claude --debug\n   # Watch for command execution and errors\n   ```\n\n5. **Iterate:**\n   - Refine based on testing\n   - Update command file\n   - Restart Claude Code to reload\n\n````\n\n### Step 4.4: Completion Summary\n\n```markdown\n## Command Creation Complete! \u0013\n\n**Command:** /[command-name]\n**Location:** [file path]\n**Pattern:** [A/B/C/D]\n\n### File Structure:\n```yaml\n---\ndescription: [description]\nargument-hint: [hint]\n[allowed-tools if present]\n---\n\n# [sections overview]\n````\n\n### Next Steps:\n\n1. Test the command in Claude Code\n2. Refine based on user feedback\n3. Add to plugin documentation\n4. Consider related commands\n\n### Related Resources:\n\n- Slash commands guide: https://docs.claude.com/en/docs/claude-code/slash-commands\n- Plugin reference: https://docs.claude.com/en/docs/claude-code/plugins-reference\n\n````\n\n---\n\n## Command Patterns Reference\n\n### Pattern A: Simple Command\n**Use for:** Single-action operations\n**Structure:**\n- Brief introduction\n- 2-4 execution steps\n- Success checklist\n\n**Examples:**\n- Clean up branches\n- Format code\n- Run linter\n\n### Pattern B: Workflow Command\n**Use for:** Multi-phase processes with user approval\n**Structure:**\n- Phase 1: Discovery + Todo list\n- Phase 2: Planning + Approval gate\n- Phase 3: Implementation (ordered steps)\n- Phase 4: Documentation/Summary\n- Success checklist\n- Key principles\n\n**Examples:**\n- Feature development\n- Component creation\n- Refactoring workflows\n\n### Pattern C: Interactive Command\n**Use for:** User-guided operations\n**Structure:**\n- Phase 1: Questions\n- Phase 2: Validation + Approval\n- Phase 3: Execution\n- Phase 4: Summary\n\n**Examples:**\n- Scaffolding tools\n- Configuration wizards\n- Setup assistants\n\n### Pattern D: Analysis Command\n**Use for:** Code review and validation\n**Structure:**\n- Phase 1: Context gathering\n- Phase 2: Analysis (with confidence scoring)\n- Phase 3: Report generation\n- Optional: Remediation phase\n\n**Examples:**\n- Code review\n- Pattern verification\n- Security analysis\n\n---\n\n## Tool Constraint Patterns\n\n### Git Operations Only\n```yaml\nallowed-tools: Bash(git:*)\n````\n\n### Read-Only Analysis\n\n```yaml\nallowed-tools: Read, Grep, Glob\n```\n\n### File Modification Only\n\n```yaml\nallowed-tools: Edit, Write\n```\n\n### Specific Git Commands\n\n```yaml\nallowed-tools: Bash(git add:*), Bash(git commit:*), Bash(git status:*)\n```\n\n### Package Management\n\n```yaml\nallowed-tools: Bash(npm:*), Bash(yarn:*), Bash(pnpm:*)\n```\n\n### No Constraints\n\n```yaml\n# Omit allowed-tools field entirely\n```\n\n---\n\n## Key Principles\n\n1. **Clear Purpose** - One command, one responsibility\n2. **Constrain Appropriately** - Use tool restrictions to prevent scope creep\n3. **Guide the User** - Explicit phases and approval gates\n4. **Use Context** - Inline commands provide relevant information\n5. **Error Handling** - Account for edge cases and failures\n6. **Document Thoroughly** - Examples and principles clarify intent\n7. **Test Extensively** - Verify with real scenarios\n8. **Iterate** - Refine based on actual usage\n\n---\n\n## Common Mistakes to Avoid\n\n1. **Vague Descriptions** - Be specific about what the command does\n2. **Missing Constraints** - Commands without constraints can do anything\n3. **No Approval Gates** - Workflow commands need user confirmation\n4. **Poor Argument Handling** - Validate and explain expected arguments\n5. **Missing Examples** - Complex commands need usage examples\n6. **No Success Criteria** - Include verification checklists\n7. **Inconsistent Numbering** - Use consistent phase/step numbering\n8. **Assuming Context** - Gather necessary context explicitly"
              },
              {
                "name": "/create-plugin",
                "description": "Interactive workflow for creating a complete Claude Code plugin",
                "path": "plugins/plugin-builder/commands/create-plugin.md",
                "frontmatter": {
                  "description": "Interactive workflow for creating a complete Claude Code plugin",
                  "argument-hint": "Plugin name and purpose",
                  "allowed-tools": "Glob, Grep, Read, Write, Bash(mkdir:*), TodoWrite, WebFetch, WebSearch"
                },
                "content": "# Claude Code Plugin Builder\n\nYou are an expert in building Claude Code plugins. Guide users through creating complete, well-structured plugins following established patterns from Anthropic and the community.\n\nUser request: $ARGUMENTS\n\n---\n\n## Phase 1: Discovery & Requirements\n\n### Step 1.1: Create Todo List\n\nCreate a todo list with these phases:\n\n- Phase 1: Discovery & Requirements\n- Phase 2: Plugin Design & Architecture\n- Phase 3: Implementation\n- Phase 4: Testing & Documentation\n\n### Step 1.2: Gather Requirements\n\nIf the user hasn't provided clear requirements, ask:\n\n**Essential Questions:**\n\n- What is the plugin name? (lowercase-with-dashes format)\n- What problem does this plugin solve?\n- Who is the target audience? (team, community, personal)\n\n**Component Questions:**\n\n- Will this plugin include slash commands? If yes, what operations?\n- Will this plugin include sub-agents? If yes, what specialized tasks?\n- Will this plugin include hooks? If yes, what lifecycle events?\n- Will this plugin include MCP servers? If yes, what external tools?\n\n**Metadata Questions:**\n\n- Author name and email (optional)?\n- Homepage or repository URL (optional)?\n- License type (optional)?\n- Keywords for discoverability?\n\nSummarize requirements and wait for confirmation.\n\n---\n\n## Phase 2: Plugin Design & Architecture\n\n### Step 2.1: Analyze Similar Plugins\n\nSearch for similar plugins in the ecosystem to understand established patterns:\n\n- Anthropic's official plugins (feature-dev, pr-review-toolkit, commit-commands, etc.)\n- Community plugins in available marketplaces\n- Related functionality in existing tools\n\nPresent 2-3 similar examples with links/paths.\n\n### Step 2.2: Design Plugin Structure\n\nBased on requirements, design the complete file structure:\n\n```\nplugin-name/\n- .claude-plugin/\n|  - plugin.json              # Plugin metadata (ALWAYS REQUIRED)\n- commands/                     # Slash commands (if applicable)\n|   - command-1.md\n|  - command-2.md\n- agents/                       # Sub-agents (if applicable)\n|   - agent-1.md\n|  - agent-2.md\n- hooks/                        # Lifecycle hooks (if applicable)\n|   - hooks.json\n|  - hook-implementation.py\n- .mcp.json                    # MCP servers (if applicable)\n```\n\n### Step 2.3: Design Each Component\n\nFor each component type needed:\n\n**Commands:**\n\n- Command name and description\n- Expected arguments\n- Allowed tools (constraints)\n- Workflow/steps the command will follow\n\n**Agents:**\n\n- Agent name and description\n- Triggering scenarios\n- Model selection (sonnet/opus/inherit)\n- Tool access (full or restricted)\n- Color coding for organization\n\n**Hooks:**\n\n- Hook event type (PreToolUse, PostToolUse, etc.)\n- Tool matchers (which tools trigger the hook)\n- Implementation language (bash, python, etc.)\n- Hook purpose and behavior\n\n### Step 2.4: Present Design Plan\n\nShow complete design in this format:\n\n```markdown\n## Plugin Design: [plugin-name]\n\n**Purpose:** [description]\n**Target Audience:** [who uses this]\n\n### Plugin Metadata (plugin.json)\n\n- Name: [plugin-name]\n- Version: 1.0.0\n- Description: [description]\n- Author: [name/email]\n- Keywords: [list]\n\n### Commands ([count])\n\n1. **[command-name]** - [description]\n   - Arguments: [argument description]\n   - Workflow: [brief steps]\n\n### Agents ([count])\n\n1. **[agent-name]** - [description]\n   - Triggers: [when to use]\n   - Model: [sonnet/opus/inherit]\n   - Tools: [full/restricted]\n\n### Hooks ([count])\n\n1. **[hook-name]** - [description]\n   - Event: [PreToolUse/PostToolUse/etc.]\n   - Triggers: [which tools]\n\n### Directory Structure\n\n[show full tree]\n\nApprove? (yes/no/modify)\n```\n\n**Wait for approval before proceeding.**\n\n---\n\n## Phase 3: Implementation\n\n### Step 3.1: Create Directory Structure\n\nCreate all necessary directories:\n\n```bash\nmkdir -p plugin-name/.claude-plugin\nmkdir -p plugin-name/commands  # if needed\nmkdir -p plugin-name/agents    # if needed\nmkdir -p plugin-name/hooks     # if needed\n```\n\n### Step 3.2: Create plugin.json\n\nGenerate the plugin metadata file:\n\n```json\n{\n  \"name\": \"plugin-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Plugin description\",\n  \"author\": {\n    \"name\": \"Author Name\",\n    \"email\": \"email@example.com\"\n  },\n  \"homepage\": \"https://github.com/user/repo\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/user/repo.git\"\n  },\n  \"license\": \"MIT\",\n  \"keywords\": [\"keyword1\", \"keyword2\"]\n}\n```\n\n### Step 3.3: Create Commands (if applicable)\n\nFor each command, create a markdown file with YAML frontmatter:\n\n```markdown\n---\ndescription: Brief description of what this command does\nargument-hint: Description of expected arguments\nallowed-tools: Bash(git:*), Read, Write # Optional constraints\n---\n\n# Command Name\n\nYou are [role description]. [Core responsibility].\n\nUser request: $ARGUMENTS\n\n---\n\n## Phase 1: [First Phase Name]\n\n[Detailed instructions for this phase]\n\n### Step 1.1: [Step Name]\n\n[Step details]\n\n---\n\n## Phase 2: [Second Phase Name]\n\n[Continue with workflow phases...]\n\n---\n\n## Success Checklist\n\nBefore completing, verify:\n\n- [Checklist item 1]\n- [Checklist item 2]\n\n---\n\n## Key Principles\n\n1. **Principle 1** - Explanation\n2. **Principle 2** - Explanation\n```\n\n**Command Best Practices:**\n\n- Use clear phases with numbered steps\n- Include examples and commentary\n- Use $ARGUMENTS for user input\n- Use $1, $2, etc. for positional arguments\n- Constrain tools with `allowed-tools` when needed\n- Include success checklists\n- Provide inline commands with ! prefix for context (examples: !git status, !git diff)\n\n### Step 3.4: Create Agents (if applicable)\n\nFor each agent, create a markdown file with YAML frontmatter:\n\n```markdown\n---\nname: agent-name\ndescription: When to use this agent - be specific about triggering scenarios\nmodel: sonnet # or opus or inherit\ncolor: green # green/yellow/red/cyan/pink for organization\ntools: Glob, Grep, Read, Write # Optional tool restrictions\n---\n\nYou are [specialized role]. [Core expertise and responsibility].\n\n## Core Process\n\n**1. [First Phase Name]**\n[Phase description and goals]\n\n**2. [Second Phase Name]**\n[Phase description and goals]\n\n**3. [Output Phase Name]**\n[What to deliver and format]\n\n## Output Guidance\n\nDeliver [type of output] that includes:\n\n- **Section 1**: [What to include]\n- **Section 2**: [What to include]\n- **Section 3**: [What to include]\n\n[Additional guidance on tone, specificity, confidence, etc.]\n```\n\n**Agent Best Practices:**\n\n- Clear triggering scenarios in description\n- Choose appropriate model (sonnet for most, opus for complex)\n- Use color coding for organization (green=safe, yellow=caution, red=critical, cyan=info, pink=creative)\n- Restrict tools only when necessary for safety\n- Focus on autonomous operation\n- Provide clear output format expectations\n- Include confidence scoring for subjective analysis\n\n### Step 3.5: Create Hooks (if applicable)\n\nCreate hooks.json configuration:\n\n```json\n{\n  \"description\": \"Hook system description\",\n  \"hooks\": {\n    \"PreToolUse\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/hook_script.py\"\n          }\n        ],\n        \"matcher\": \"Edit|Write|MultiEdit\"\n      }\n    ],\n    \"PostToolUse\": [\n      {\n        \"hooks\": [\n          {\n            \"type\": \"command\",\n            \"command\": \"npx prettier --write \\\"$file_path\\\"\"\n          }\n        ],\n        \"matcher\": \"Edit|Write\"\n      }\n    ]\n  }\n}\n```\n\nCreate hook implementation files (Python example):\n\n```python\n#!/usr/bin/env python3\nimport os\nimport sys\nimport json\n\ndef main():\n    # Read tool use data from stdin\n    tool_use = json.loads(sys.stdin.read())\n\n    # Extract relevant information\n    tool_name = tool_use.get(\"name\", \"\")\n    parameters = tool_use.get(\"parameters\", {})\n\n    # Perform hook logic\n    # ...\n\n    # Output feedback (optional)\n    feedback = {\n        \"type\": \"text\",\n        \"content\": \"Hook feedback message\"\n    }\n    print(json.dumps(feedback))\n\n    # Exit with 0 for success, non-zero to block tool execution\n    sys.exit(0)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n**Hook Best Practices:**\n\n- Use PreToolUse for validation and warnings\n- Use PostToolUse for formatting and cleanup\n- Match specific tools to avoid overhead\n- Provide escape hatches (env vars to disable)\n- Maintain session state to avoid repeated warnings\n- Return non-zero exit codes to block dangerous operations\n- Use ${CLAUDE_PLUGIN_ROOT} for plugin-relative paths\n\n### Step 3.6: Create MCP Configuration (if applicable)\n\nCreate .mcp.json for external tool connections:\n\n```json\n{\n  \"mcpServers\": {\n    \"server-name\": {\n      \"command\": \"node\",\n      \"args\": [\"path/to/server.js\"],\n      \"env\": {\n        \"API_KEY\": \"value\"\n      }\n    }\n  }\n}\n```\n\n### Step 3.7: Create README (optional but recommended)\n\nCreate a README.md in the plugin root:\n\n```markdown\n# Plugin Name\n\nBrief description of what this plugin does.\n\n## Installation\n\n\\`\\`\\`bash\n\n# Add the marketplace\n\n/plugin marketplace add owner/repo\n\n# Install the plugin\n\n/plugin install plugin-name\n\\`\\`\\`\n\n## Features\n\n### Commands\n\n- \\`/command-name\\` - Description\n\n### Agents\n\n- **agent-name** - Description and when it triggers\n\n### Hooks\n\n- **hook-name** - Description of behavior\n\n## Usage Examples\n\n\\`\\`\\`bash\n/command-name argument example\n\\`\\`\\`\n\n## Configuration\n\n[Any required setup or configuration]\n\n## License\n\n[License information]\n```\n\n---\n\n## Phase 4: Testing & Documentation\n\n### Step 4.1: Create Marketplace Entry (if publishing)\n\nIf creating a marketplace, generate marketplace.json:\n\n```json\n{\n  \"name\": \"marketplace-name\",\n  \"version\": \"1.0.0\",\n  \"marketplaceVersion\": \"1.0\",\n  \"displayName\": \"Marketplace Display Name\",\n  \"description\": \"Marketplace description\",\n  \"plugins\": [\n    {\n      \"name\": \"plugin-name\",\n      \"version\": \"1.0.0\",\n      \"description\": \"Plugin description\",\n      \"source\": \"./plugins/plugin-name\",\n      \"keywords\": [\"keyword1\", \"keyword2\"],\n      \"author\": {\n        \"name\": \"Author Name\"\n      }\n    }\n  ]\n}\n```\n\n### Step 4.2: Validation Checklist\n\nVerify the plugin is complete:\n\n**File Structure:**\n\n- .claude-plugin/plugin.json exists and is valid JSON\n- All declared components have corresponding files\n- File naming follows conventions (lowercase-with-dashes)\n\n**Commands:**\n\n- All commands have YAML frontmatter with description\n- Commands use clear phases and steps\n- $ARGUMENTS is used for user input\n- Tool constraints are appropriate\n\n**Agents:**\n\n- All agents have complete YAML frontmatter\n- Triggering scenarios are clear\n- Model selection is appropriate\n- Output format is specified\n\n**Hooks:**\n\n- hooks.json is valid JSON\n- Hook scripts are executable\n- Error handling is implemented\n- Escape hatches exist\n\n**Documentation:**\n\n- README exists and is complete\n- Installation instructions are clear\n- Usage examples are provided\n\n### Step 4.3: Testing Instructions\n\nProvide testing guidance:\n\n````markdown\n## Testing Your Plugin\n\n1. **Local Testing:**\n\n   ```bash\n   # Create a test marketplace.json pointing to your plugin\n   # Add the marketplace to Claude Code\n   /plugin marketplace add /path/to/marketplace.json\n\n   # Install your plugin\n   /plugin install plugin-name\n   ```\n````\n\n2. **Test Commands:**\n\n   - Run each command with sample arguments\n   - Verify expected behavior\n   - Check error handling\n\n3. **Test Agents:**\n\n   - Trigger each agent scenario\n   - Verify autonomous operation\n   - Check output format\n\n4. **Test Hooks:**\n\n   - Perform actions that trigger hooks\n   - Verify hook execution\n   - Test escape hatches\n\n5. **Debug Mode:**\n   ```bash\n   claude --debug\n   # Watch for plugin loading messages and errors\n   ```\n\n````\n\n### Step 4.4: Summary\n\nProvide a complete summary:\n\n```markdown\n## Plugin Creation Complete!\n\n**Plugin:** [plugin-name]\n**Version:** 1.0.0\n**Location:** [path]\n\n### Files Created:\n- [list all files with descriptions]\n\n### Next Steps:\n\n1. **Test the plugin:**\n   - Install in Claude Code\n   - Test each component\n   - Verify functionality\n\n2. **Publish (optional):**\n   - Push to GitHub repository\n   - Create marketplace.json\n   - Share marketplace URL\n\n3. **Iterate:**\n   - Gather user feedback\n   - Add features\n   - Improve documentation\n\n### Resources:\n- Plugin docs: https://docs.claude.com/en/docs/claude-code/plugins\n- Marketplace guide: https://docs.claude.com/en/docs/claude-code/plugin-marketplaces\n- Plugin reference: https://docs.claude.com/en/docs/claude-code/plugins-reference\n````\n\n---\n\n## Key Principles\n\n1. **Learn from Examples** - Study Anthropic's official plugins for patterns\n2. **Start Simple** - Create minimal viable plugin first, then iterate\n3. **Clear Triggering** - Make it obvious when commands/agents should be used\n4. **Constrain Appropriately** - Use tool restrictions to prevent scope creep\n5. **Document Thoroughly** - README and inline docs are essential\n6. **Test Extensively** - Verify each component before publishing\n7. **Follow Conventions** - Naming, structure, and patterns matter\n8. **Version Semantically** - Use semantic versioning for clarity\n\n---\n\n## Pattern Reference\n\n### Command Patterns\n\n- **Workflow Commands** - Multi-phase processes (create-plugin, feature-dev)\n- **Git Commands** - Version control operations (commit, clean_gone)\n- **Interactive Commands** - Ask questions, then execute (new-sdk-app)\n\n### Agent Patterns\n\n- **Analyzer Agents** - Code review, testing, security (code-reviewer, pr-test-analyzer)\n- **Explorer Agents** - Codebase discovery (code-explorer)\n- **Builder Agents** - Architecture, design (code-architect)\n- **Verifier Agents** - Validation, compliance (agent-sdk-verifier)\n\n### Hook Patterns\n\n- **Validation Hooks** - Check before actions (security warnings)\n- **Formatting Hooks** - Auto-format after edits (prettier, linters)\n- **Logging Hooks** - Track actions (audit trails)\n- **Protection Hooks** - Prevent dangerous operations (file protection)\n\n---\n\n## Common Pitfalls to Avoid\n\n1. **Missing plugin.json** - This file is REQUIRED\n2. **Invalid JSON** - Use linters to validate JSON files\n3. **Unclear Triggers** - Agents need specific triggering scenarios\n4. **Tool Overload** - Don't grant unnecessary tool access\n5. **Poor Documentation** - Users need clear usage examples\n6. **No Error Handling** - Hooks should handle failures gracefully\n7. **Hardcoded Paths** - Use ${CLAUDE_PLUGIN_ROOT} for plugin-relative paths\n8. **Complex First Version** - Start minimal, iterate based on feedback"
              }
            ],
            "skills": []
          }
        ]
      }
    }
  ]
}