{
  "owner": {
    "id": "jahanson",
    "display_name": "Joseph Hanson",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/1548511?u=649488617a339b375b218427a8057343ed733c81&v=4",
    "url": "https://github.com/jahanson",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 2,
      "total_commands": 0,
      "total_skills": 5,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "jahanson/cc-plugins",
      "url": "https://github.com/jahanson/cc-plugins",
      "description": "Custom skills, hooks, etc for things I use regularly. ",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-08T21:48:48Z",
        "created_at": "2025-12-23T15:52:29Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 463
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 845
        },
        {
          "path": "deno-lsp",
          "type": "tree",
          "size": null
        },
        {
          "path": "deno-lsp/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "deno-lsp/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 1144
        },
        {
          "path": "deno-lsp/.lsp.json",
          "type": "blob",
          "size": 721
        },
        {
          "path": "deno-lsp/README.md",
          "type": "blob",
          "size": 5285
        },
        {
          "path": "deno-lsp/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "deno-lsp/skills/deno-core",
          "type": "tree",
          "size": null
        },
        {
          "path": "deno-lsp/skills/deno-core/SKILL.md",
          "type": "blob",
          "size": 11560
        },
        {
          "path": "deno-lsp/skills/deno-ddd",
          "type": "tree",
          "size": null
        },
        {
          "path": "deno-lsp/skills/deno-ddd/SKILL.md",
          "type": "blob",
          "size": 18711
        },
        {
          "path": "deno-lsp/skills/deno-patterns",
          "type": "tree",
          "size": null
        },
        {
          "path": "deno-lsp/skills/deno-patterns/SKILL.md",
          "type": "blob",
          "size": 14967
        },
        {
          "path": "deno-lsp/skills/deno-typescript",
          "type": "tree",
          "size": null
        },
        {
          "path": "deno-lsp/skills/deno-typescript/SKILL.md",
          "type": "blob",
          "size": 5602
        },
        {
          "path": "jsr-audit",
          "type": "tree",
          "size": null
        },
        {
          "path": "jsr-audit/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "jsr-audit/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 316
        },
        {
          "path": "jsr-audit/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "jsr-audit/skills/jsr-audit",
          "type": "tree",
          "size": null
        },
        {
          "path": "jsr-audit/skills/jsr-audit/SKILL.md",
          "type": "blob",
          "size": 9876
        }
      ],
      "marketplace": {
        "name": "local-plugins",
        "version": null,
        "description": "Local development plugins",
        "owner_info": {
          "name": "Local Developer"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "deno-lsp",
            "description": "Deno LSP integration for TypeScript/JavaScript development",
            "source": "./deno-lsp",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add jahanson/cc-plugins",
              "/plugin install deno-lsp@local-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-08T21:48:48Z",
              "created_at": "2025-12-23T15:52:29Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "deno-core",
                "description": "Essential Deno TypeScript practices for ALL Deno development: configuration, imports, testing, permissions, and anti-patterns. Read this skill for any Deno project setup, dependency management, or core development work.",
                "path": "deno-lsp/skills/deno-core/SKILL.md",
                "frontmatter": {
                  "name": "deno-core",
                  "description": "Essential Deno TypeScript practices for ALL Deno development: configuration, imports, testing, permissions, and anti-patterns. Read this skill for any Deno project setup, dependency management, or core development work."
                },
                "content": "# Deno Core Best Practices\n\n## When to Use This Skill\n\nUse this skill for ALL Deno TypeScript development:\n- Setting up new Deno projects\n- Writing Deno applications or libraries\n- Configuring build, test, and deployment\n- Working with dependencies and imports\n\n## Core Deno Philosophy\n\n### One Tool, Zero Dependencies\n- Deno is the **only tool you need** for TypeScript development\n- Built-in tooling: typecheck, lint, format, test, coverage, benchmark\n- **Avoid `node_modules` at all costs** - reduce supply chain attack surface\n- No need for: tsc, eslint, prettier, jest, vitest, webpack, etc.\n\n### TypeScript Excellence\n- **Strict TypeScript adherence** - not just \"TS support\"\n- **Bleeding-edge TypeScript features by default** - no flags, no config needed\n- No compilation step - just run your code\n- Target **ES2024+** with Stage 3 TC39 proposals\n\n### Security First\n- Explicit permissions model (no implicit file system or network access)\n- Supply chain security through minimal external dependencies\n- First-class support for modern security patterns\n\n---\n\n## Language & Compiler\n\n### TypeScript Configuration\n\n- **Do not use `tsconfig.json`** - Deno uses `deno.json(c)` as the single source of truth\n- Type-checking powered by `deno check` / `deno test` - **do not** rely on external `tsc`\n- Default module format is **ESM only** - no CommonJS interop\n- Prefer Deno's **runtime-provided types** (`Deno.*`, Web APIs, Fetch, URLPattern) over polyfills\n\n### Strictest Compiler Settings\n\nAlways use the strictest possible settings in `deno.json`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\": true,\n    \"noImplicitThis\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"exactOptionalPropertyTypes\": true\n  }\n}\n```\n\n---\n\n## Configuration & Tasks\n\n### deno.json - Single Source of Truth\n\nUse `deno.json` or `deno.jsonc` as the single configuration file for:\n- Compiler options\n- Linting and formatting rules\n- Tasks (script aliases)\n- Import maps (dependency management)\n- Exclusions\n\n**Complete Configuration Example:**\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\": true,\n    \"noImplicitThis\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true\n  },\n  \"tasks\": {\n    \"dev\": \"deno run --watch --allow-net --allow-read --allow-env src/main.ts\",\n    \"test\": \"deno test --allow-net --allow-read --allow-env --coverage=coverage src/\",\n    \"test:unit\": \"deno test --allow-net --allow-read --allow-env --coverage=coverage src/\",\n    \"test:e2e\": \"deno test --allow-net --allow-read --allow-env tests/e2e/\",\n    \"test:watch\": \"deno test --allow-net --allow-read --allow-env --watch --fail-fast\",\n    \"coverage\": \"deno coverage coverage --html\",\n    \"check\": \"deno check $(find src -name '*.ts' -not -name '*.sql')\",\n    \"lint\": \"deno lint\",\n    \"fmt\": \"deno fmt\"\n  },\n  \"imports\": {\n    \"@/\": \"./src/\",\n    \"@/domain/\": \"./src/domain/\",\n    \"@/infrastructure/\": \"./src/infrastructure/\",\n    \"@/application/\": \"./src/application/\",\n    \"@std/assert\": \"jsr:@std/assert@^1.0.14\",\n    \"@std/fs\": \"jsr:@std/fs@^1.0.19\",\n    \"@std/testing\": \"jsr:@std/testing@^1.0.15\",\n    \"@std/ulid\": \"jsr:@std/ulid@1\",\n    \"zod\": \"npm:zod@^3.23.8\"\n  },\n  \"exclude\": [\n    \"coverage/\",\n    \"node_modules/\"\n  ],\n  \"lock\": true\n}\n```\n\n### Essential Tasks\n\nDefine these **`deno task`** aliases at minimum:\n- `dev` - Development with watch mode\n- `test`, `test:watch` - Testing\n- `coverage` - Generate coverage reports\n- `check` - Type-check all files\n- `lint`, `fmt` - Code quality\n\n### Lockfile Management\n\n- **Always commit** `deno.lock` to version control\n- Run with `--lock=deno.lock --lock-write=false` in CI\n- Update lockfile: `deno cache --lock=deno.lock --lock-write`\n\n---\n\n## Imports & Module Resolution\n\n### Import Strategy\n\n**CRITICAL:** Never use direct JSR/npm imports in source files. All external dependencies MUST be declared in `deno.json` import map.\n\n**Import Order in Source Files:**\n\n```typescript\n// 1. Standard library imports (via import map)\nimport { assertEquals } from \"@std/assert\";\n\n// 2. Third-party imports (via import map)\nimport { z } from \"zod\";\n\n// 3. Internal imports (absolute paths using import map)\nimport { Agent } from \"@/domain/agent.ts\";\n\n// 4. Relative imports (only within same module/context)\nimport { validatePrompt } from \"./validation.ts\";\n```\n\n### Dependency Source Priority\n\nUse sources in this order:\n\n1. **`jsr:` registry** (first choice for TypeScript modules)\n   ```json\n   \"@std/assert\": \"jsr:@std/assert@^1.0.14\"\n   ```\n\n2. **`npm:` specifier** (when needed; prefer ESM-compatible)\n   ```json\n   \"zod\": \"npm:zod@^3.23.8\"\n   ```\n\n3. **URL imports** (rarely needed with import maps)\n\n### Version Pinning\n\n**CRITICAL:** Version pin all external imports. No floating `@latest` in committed code.\n\n```json\n{\n  \"imports\": {\n    \"zod\": \"npm:zod@^3.23.8\",           // GOOD - pinned\n    \"zod\": \"npm:zod\",                    // BAD - no version\n    \"@std/assert\": \"jsr:@std/assert@1\"   // GOOD - pinned\n  }\n}\n```\n\n### Internal Path Aliases\n\nUse import map aliases for clean internal imports:\n\n```json\n{\n  \"imports\": {\n    \"@/\": \"./src/\",\n    \"@/domain/\": \"./src/domain/\",\n    \"@/infrastructure/\": \"./src/infrastructure/\"\n  }\n}\n```\n\n```typescript\n// GOOD - Clean, refactor-safe\nimport { Agent } from \"@/domain/agent.ts\";\n\n// BAD - Brittle relative paths\nimport { Agent } from \"../../../domain/agent.ts\";\n```\n\n### Type-Only Imports\n\nUse type-only imports when importing types:\n\n```typescript\nimport type { Agent } from \"@/domain/agent.ts\";\nimport type { z } from \"zod\";\n```\n\n---\n\n## Testing\n\n### Test Organization\n\n**Unit Tests - Co-located with Source:**\n\n```\nsrc/\n└── domain/\n    ├── agent.ts\n    └── agent.test.ts          # Unit tests next to code\n```\n\n**Integration & E2E Tests - Separate Directory:**\n\n```\ntests/\n├── integration/\n│   └── openai_provider.test.ts\n└── e2e/\n    └── workflow.test.ts\n```\n\n**Why Co-location:**\n- Discoverability - tests next to code\n- Maintenance - easy to keep in sync\n- Deno convention - follows `deno test` discovery\n\n### Coverage Requirements\n\n**Non-Negotiable:**\n\n- **Line coverage: 80%+** - MUST be met\n- **Branch coverage: 60-80%** - MUST be met\n\n```bash\ndeno test --coverage=coverage\ndeno coverage coverage --html\n```\n\n### Test Structure\n\n**Always use explicit AAA (Arrange-Act-Assert):**\n\n```typescript\nimport { assertEquals } from \"@std/assert\";\n\nDeno.test(\"agent should process valid input\", () => {\n  // Arrange\n  const agent = new Agent({ name: \"TestAgent\" });\n  const input = \"Hello, world!\";\n\n  // Act\n  const result = agent.process(input);\n\n  // Assert\n  assertEquals(result.status, \"success\");\n});\n```\n\n### Test Development\n\n**Red-Green-Refactor with fast feedback:**\n\n```bash\n# Watch mode with fail-fast\ndeno test --watch --fail-fast\n\n# Run specific file\ndeno test src/domain/agent.test.ts --watch\n```\n\n### Deterministic Tests\n\n**CRITICAL:** All tests must be deterministic.\n\n**Test Flakiness Policy:**\n- Flakiness = **highest priority bug**\n- **Never ignore, retry, or \"fix\" with delays**\n- Action: investigate, quarantine, fix\n- Do NOT merge flaky tests\n\n**Use stable seeds and fixtures:**\n\n```typescript\nimport { FakeTime } from \"@std/testing/time\";\n\nDeno.test(\"timer test\", () => {\n  using time = new FakeTime();\n  // Deterministic time control\n  time.tick(1000);\n});\n```\n\n### Test File Naming\n\nAll test files must end with `.test.ts`:\n\n```\nagent.test.ts     # GOOD\nagent_test.ts     # BAD\nagent.spec.ts     # BAD\n```\n\n### Testing Tools\n\n- Use `@std/assert` for assertions\n- Use `@std/testing/mock` for test doubles\n- Use `@std/testing/time` for time control\n- **Do NOT use Jest** - use Deno's built-in runner\n\n---\n\n## Permissions & Security\n\n### Principle of Least Privilege\n\nDefault to minimum required permissions:\n\n```bash\n# BAD\ndeno run --allow-all script.ts\n\n# GOOD\ndeno run --allow-read=./data --allow-net=api.example.com script.ts\n```\n\n### Common Permission Flags\n\n```bash\n--allow-read[=<path>]      # File system read\n--allow-write[=<path>]     # File system write\n--allow-net[=<domain>]     # Network access\n--allow-env[=<var>]        # Environment variables\n--allow-run[=<program>]    # Subprocess execution\n```\n\n### Document Required Permissions\n\n```typescript\n/**\n * Fetches data from API and caches locally.\n *\n * Required permissions:\n * - --allow-net=api.example.com\n * - --allow-read=./cache\n * - --allow-write=./cache\n */\nexport async function fetchData(): Promise<Data> {\n  // ...\n}\n```\n\n### Secrets Management\n\n```typescript\n// BAD - Hardcoded\nconst apiKey = \"sk-1234\";\n\n// GOOD - From environment\nconst apiKey = Deno.env.get(\"API_KEY\");\nif (!apiKey) {\n  throw new Error(\"API_KEY required\");\n}\n```\n\nRun with: `deno run --allow-env=API_KEY script.ts`\n\n---\n\n## Anti-Patterns to Avoid\n\n### Import Anti-Patterns\n\n```typescript\n// BAD - Direct JSR/npm imports in source\nimport { z } from \"npm:zod@^3.23.8\";\n\n// GOOD - Use import map\nimport { z } from \"zod\";\n```\n\n```json\n// BAD - Floating versions\n\"zod\": \"npm:zod\"\n\n// GOOD - Pinned versions\n\"zod\": \"npm:zod@^3.23.8\"\n```\n\n### Node.js Anti-Patterns\n\n```typescript\n// BAD - Node.js APIs\nconst fs = require(\"fs\");\nimport * as fs from \"node:fs\";\n\n// GOOD - Deno APIs\nawait Deno.readTextFile(\"file.txt\");\n```\n\n### Testing Anti-Patterns\n\n```typescript\n// BAD - Unnecessary delay\nawait new Promise(r => setTimeout(r, 100));\n\n// GOOD - Deterministic time\nimport { FakeTime } from \"@std/testing/time\";\nusing time = new FakeTime();\ntime.tick(100);\n```\n\n### Permission Anti-Patterns\n\n```bash\n# BAD - Overly broad\ndeno run --allow-all script.ts\n\n# GOOD - Specific\ndeno run --allow-read=./data script.ts\n```\n\n### Async Anti-Patterns\n\n```typescript\n// BAD - Unnecessary async\nasync function validate(input: string): Promise<boolean> {\n  return input.length > 0;\n}\n\n// GOOD - Remove async if no await\nfunction validate(input: string): boolean {\n  return input.length > 0;\n}\n```\n\n---\n\n## Quick Command Reference\n\n### Development\n\n```bash\n# Run with watch\ndeno run --watch src/main.ts\n\n# Type-check\ndeno check src/**/*.ts\n\n# Format\ndeno fmt\n\n# Lint\ndeno lint\n```\n\n### Testing\n\n```bash\n# Run all tests\ndeno test\n\n# With coverage\ndeno test --coverage=coverage\ndeno coverage coverage --html\n\n# Watch mode\ndeno test --watch --fail-fast\n```\n\n### Dependencies\n\n```bash\n# Update dependencies\ndeno cache --reload\n\n# Update lockfile\ndeno cache --lock=deno.lock --lock-write\n```\n\n### Tasks\n\n```bash\n# Run tasks from deno.json\ndeno task dev\ndeno task test\ndeno task coverage\n```\n\n---\n\n## Key Principles Summary\n\n1. **One tool** - Deno replaces tsc, eslint, prettier, jest\n2. **Security first** - Explicit permissions, minimal dependencies\n3. **Import maps** - All deps in `deno.json`, never direct imports\n4. **Version pinning** - No floating versions\n5. **Co-located tests** - Unit tests next to source\n6. **80%/60% coverage** - Line/branch, non-negotiable\n7. **No flakiness** - Highest priority, never ignore\n8. **AAA pattern** - Explicit in every test\n9. **Least privilege** - Minimal permissions\n10. **ESM only** - No CommonJS\n\n---\n\n## Additional Resources\n\n- **Deno Manual:** https://docs.deno.com/\n- **Deno Standard Library:** https://jsr.io/@std\n- **JSR Registry:** https://jsr.io/"
              },
              {
                "name": "deno-ddd",
                "description": "Domain-Driven Design patterns and architecture for Deno TypeScript applications. Use when building complex business logic, implementing bounded contexts, or structuring large-scale Deno applications with clear separation of concerns.",
                "path": "deno-lsp/skills/deno-ddd/SKILL.md",
                "frontmatter": {
                  "name": "deno-ddd",
                  "description": "Domain-Driven Design patterns and architecture for Deno TypeScript applications. Use when building complex business logic, implementing bounded contexts, or structuring large-scale Deno applications with clear separation of concerns."
                },
                "content": "# Domain-Driven Design in Deno\n\n## When to Use This Skill\n\nUse this skill when:\n- Building applications with complex business logic\n- Implementing hexagonal/clean architecture in Deno\n- Structuring large-scale Deno applications\n- Separating domain logic from infrastructure\n- Working with bounded contexts and aggregates\n- Need clear separation between layers\n\n**Prerequisites:** Always read `deno-core.md` first for essential Deno configuration.\n\n---\n\n## Project Philosophy\n\n> **Clean, Modern TypeScript**: Embrace Deno's vision of secure, modern JavaScript/TypeScript development without the baggage of Node.js legacy patterns.\n\n> **Domain-Driven Design**: Follow DDD principles with clear separation between domain logic, application services, and infrastructure concerns.\n\n> **TypeScript-First**: Leverage TypeScript's type system for safety and developer experience. No `any` types in production code.\n\n---\n\n## Core DDD Principles\n\n### Ubiquitous Language\n- Use domain terminology consistently in code, docs, and conversations\n- Type names, method names, and variables should match business concepts\n- Avoid technical jargon in domain layer\n\n### Bounded Contexts\n- Each context has its own models and language\n- Clear boundaries between contexts\n- Explicit translation between contexts\n\n### Layered Architecture\n1. **Domain Layer** - Pure business logic, no dependencies\n2. **Application Layer** - Use cases, orchestration\n3. **Infrastructure Layer** - External services, databases, APIs\n4. **API Layer** - HTTP handlers, CLI, GraphQL resolvers\n\n---\n\n## Project Structure\n\n### Recommended Directory Layout\n\n```\nsrc/\n├── domain/                    # Domain layer - core business logic\n│   ├── entities/              # Domain entities (Memory, User, Order)\n│   │   ├── user.ts\n│   │   └── order.ts\n│   ├── value-objects/         # Immutable values (Email, Money, Status)\n│   │   ├── email.ts\n│   │   ├── money.ts\n│   │   └── order-status.ts\n│   ├── aggregates/            # Consistency boundaries\n│   │   └── order-aggregate.ts\n│   ├── repositories/          # Repository interfaces (ports)\n│   │   ├── user-repository.ts\n│   │   └── order-repository.ts\n│   ├── services/              # Domain services\n│   │   └── pricing-service.ts\n│   ├── events/                # Domain events\n│   │   └── order-created.ts\n│   └── errors/                # Domain-specific errors\n│       ├── validation-error.ts\n│       └── business-rule-error.ts\n│\n├── application/               # Application layer - use cases\n│   ├── use-cases/             # Use case implementations\n│   │   ├── create-order.ts\n│   │   ├── update-user.ts\n│   │   └── process-payment.ts\n│   ├── services/              # Application services\n│   ├── dto/                   # Data transfer objects\n│   │   ├── create-order-dto.ts\n│   │   └── user-response-dto.ts\n│   └── errors/                # Application-specific errors\n│       ├── not-found-error.ts\n│       └── unauthorized-error.ts\n│\n├── infrastructure/            # Infrastructure layer - technical details\n│   ├── persistence/           # Database implementations\n│   │   ├── postgres/\n│   │   │   ├── user-repository-impl.ts\n│   │   │   └── order-repository-impl.ts\n│   │   └── migrations/\n│   ├── external/              # External service integrations\n│   │   ├── payment-gateway.ts\n│   │   └── email-service.ts\n│   ├── logging/               # Structured logging\n│   │   └── logger.ts\n│   ├── config/                # Configuration\n│   │   └── database.ts\n│   └── errors/                # Infrastructure errors\n│       ├── database-error.ts\n│       └── external-api-error.ts\n│\n├── web/                       # Web/API layer - HTTP entry points\n│   ├── controllers/           # Request handlers\n│   │   ├── user-controller.ts\n│   │   └── order-controller.ts\n│   ├── middleware/            # HTTP middleware\n│   │   ├── auth.ts\n│   │   ├── validation.ts\n│   │   ├── error-handler.ts\n│   │   └── logging.ts\n│   ├── routes/                # Route definitions\n│   │   ├── user-routes.ts\n│   │   └── order-routes.ts\n│   └── server.ts              # HTTP server setup\n│\n└── shared/                    # Shared kernel\n    ├── types/\n    │   └── result.ts\n    └── utils/\n        └── validation.ts\n\ntests/\n├── domain/                    # Domain tests (unit)\n│   ├── entities/\n│   │   └── user.test.ts\n│   └── value-objects/\n│       └── email.test.ts\n├── application/               # Application tests (integration)\n│   └── use-cases/\n│       └── create-order.test.ts\n└── e2e/                       # End-to-end tests\n    └── order-workflow.test.ts\n```\n\n### Import Map Configuration\n\nConfigure `deno.json` for clean imports across all layers:\n\n```json\n{\n  \"imports\": {\n    \"@/\": \"./src/\",\n    \"@/domain/\": \"./src/domain/\",\n    \"@/application/\": \"./src/application/\",\n    \"@/infrastructure/\": \"./src/infrastructure/\",\n    \"@/web/\": \"./src/web/\",\n    \"@/shared/\": \"./src/shared/\"\n  }\n}\n```\n\n---\n\n## Layer Dependencies\n\nUnderstanding and enforcing layer dependencies is critical for maintaining a clean DDD architecture.\n\n### Allowed Dependencies\n\n- **`domain`** → (no external dependencies - pure business logic)\n- **`application`** → `domain`\n- **`infrastructure`** → `domain` + `application`\n- **`web`** (or `api`) → `domain` + `application` + `infrastructure`\n\n### Forbidden Dependencies\n\n**NEVER allow these dependencies:**\n- **`domain`** → `application`, `infrastructure`, `web`\n- **`application`** → `infrastructure`, `web`\n- **`infrastructure`** → `web`\n\n### Dependency Flow Visualization\n\n```\n    ┌─────────────┐\n    │     web     │  (HTTP handlers, routes, middleware)\n    └──────┬──────┘\n           │\n    ┌──────▼──────┐\n    │infrastructure│  (Database, external APIs)\n    └──────┬──────┘\n           │\n    ┌──────▼──────┐\n    │ application │  (Use cases, orchestration)\n    └──────┬──────┘\n           │\n    ┌──────▼──────┐\n    │   domain    │  (Entities, value objects, business rules)\n    └─────────────┘\n```\n\n**Key Principle:** Dependencies flow inward. Inner layers have no knowledge of outer layers.\n\n---\n\n## Domain Layer\n\n### Entities\n\nEntities have identity and lifecycle. Use classes with private constructors.\n\n```typescript\n// src/domain/entities/user.ts\nimport type { Email } from \"@/domain/value-objects/email.ts\";\nimport type { UserId } from \"@/domain/value-objects/user-id.ts\";\n\nexport class User {\n  private constructor(\n    private readonly id: UserId,\n    private name: string,\n    private email: Email,\n    private readonly createdAt: Date,\n  ) {}\n\n  // Factory method - ensures valid construction\n  static create(name: string, email: Email): User {\n    if (name.trim().length === 0) {\n      throw new Error(\"User name cannot be empty\");\n    }\n    return new User(\n      UserId.generate(),\n      name,\n      email,\n      new Date(),\n    );\n  }\n\n  // Reconstruct from persistence\n  static reconstitute(\n    id: UserId,\n    name: string,\n    email: Email,\n    createdAt: Date,\n  ): User {\n    return new User(id, name, email, createdAt);\n  }\n\n  // Business logic methods\n  changeName(newName: string): void {\n    if (newName.trim().length === 0) {\n      throw new Error(\"User name cannot be empty\");\n    }\n    this.name = newName;\n  }\n\n  // Getters\n  getId(): UserId { return this.id; }\n  getName(): string { return this.name; }\n  getEmail(): Email { return this.email; }\n  getCreatedAt(): Date { return this.createdAt; }\n}\n```\n\n### Value Objects\n\nValue objects have no identity, compared by value.\n\n```typescript\n// src/domain/value-objects/email.ts\nexport class Email {\n  private constructor(private readonly value: string) {}\n\n  static create(value: string): Email {\n    if (!Email.isValid(value)) {\n      throw new Error(`Invalid email: ${value}`);\n    }\n    return new Email(value.toLowerCase());\n  }\n\n  private static isValid(value: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(value);\n  }\n\n  getValue(): string { return this.value; }\n  equals(other: Email): boolean { return this.value === other.value; }\n  toString(): string { return this.value; }\n}\n```\n\n```typescript\n// src/domain/value-objects/money.ts\nexport class Money {\n  private constructor(\n    private readonly amount: number,\n    private readonly currency: string,\n  ) {}\n\n  static create(amount: number, currency: string): Money {\n    if (amount < 0) {\n      throw new Error(\"Money amount cannot be negative\");\n    }\n    if (![\"USD\", \"EUR\", \"GBP\"].includes(currency)) {\n      throw new Error(`Unsupported currency: ${currency}`);\n    }\n    return new Money(amount, currency);\n  }\n\n  add(other: Money): Money {\n    if (this.currency !== other.currency) {\n      throw new Error(\"Cannot add money with different currencies\");\n    }\n    return new Money(this.amount + other.amount, this.currency);\n  }\n\n  multiply(factor: number): Money {\n    return new Money(this.amount * factor, this.currency);\n  }\n\n  getAmount(): number { return this.amount; }\n  getCurrency(): string { return this.currency; }\n  equals(other: Money): boolean {\n    return this.amount === other.amount && this.currency === other.currency;\n  }\n}\n```\n\n### Aggregates\n\nAggregates enforce consistency boundaries and business invariants.\n\n```typescript\n// src/domain/aggregates/order-aggregate.ts\nimport type { OrderId } from \"@/domain/value-objects/order-id.ts\";\nimport type { Money } from \"@/domain/value-objects/money.ts\";\nimport type { OrderLine } from \"@/domain/entities/order-line.ts\";\n\nexport enum OrderStatus {\n  PENDING = \"PENDING\",\n  CONFIRMED = \"CONFIRMED\",\n  SHIPPED = \"SHIPPED\",\n  DELIVERED = \"DELIVERED\",\n  CANCELLED = \"CANCELLED\",\n}\n\nexport class Order {\n  private constructor(\n    private readonly id: OrderId,\n    private status: OrderStatus,\n    private readonly lines: OrderLine[],\n    private readonly createdAt: Date,\n  ) {}\n\n  static create(lines: OrderLine[]): Order {\n    if (lines.length === 0) {\n      throw new Error(\"Order must have at least one line\");\n    }\n    return new Order(\n      OrderId.generate(),\n      OrderStatus.PENDING,\n      lines,\n      new Date(),\n    );\n  }\n\n  // Business logic - enforce invariants\n  confirm(): void {\n    if (this.status !== OrderStatus.PENDING) {\n      throw new Error(`Cannot confirm order with status ${this.status}`);\n    }\n    this.status = OrderStatus.CONFIRMED;\n  }\n\n  cancel(): void {\n    if (this.status === OrderStatus.SHIPPED || this.status === OrderStatus.DELIVERED) {\n      throw new Error(\"Cannot cancel shipped or delivered order\");\n    }\n    this.status = OrderStatus.CANCELLED;\n  }\n\n  calculateTotal(): Money {\n    return this.lines.reduce(\n      (total, line) => total.add(line.getSubtotal()),\n      Money.create(0, \"USD\"),\n    );\n  }\n\n  getId(): OrderId { return this.id; }\n  getStatus(): OrderStatus { return this.status; }\n  getLines(): ReadonlyArray<OrderLine> { return this.lines; }\n}\n```\n\n### Repository Interfaces (Ports)\n\nDefine interfaces in domain layer, implement in infrastructure.\n\n```typescript\n// src/domain/repositories/user-repository.ts\nimport type { User } from \"@/domain/entities/user.ts\";\nimport type { UserId } from \"@/domain/value-objects/user-id.ts\";\nimport type { Email } from \"@/domain/value-objects/email.ts\";\n\nexport interface UserRepository {\n  save(user: User): Promise<void>;\n  findById(id: UserId): Promise<User | null>;\n  findByEmail(email: Email): Promise<User | null>;\n  delete(id: UserId): Promise<void>;\n}\n```\n\n---\n\n## Application Layer\n\n### Use Cases\n\nUse cases orchestrate domain logic without containing business rules.\n\n```typescript\n// src/application/use-cases/create-order.ts\nimport type { UserRepository } from \"@/domain/repositories/user-repository.ts\";\nimport type { OrderRepository } from \"@/domain/repositories/order-repository.ts\";\nimport { Order } from \"@/domain/aggregates/order-aggregate.ts\";\nimport { OrderLine } from \"@/domain/entities/order-line.ts\";\nimport type { CreateOrderDto } from \"@/application/dto/create-order-dto.ts\";\nimport { Result } from \"@/shared/types/result.ts\";\n\nexport class CreateOrderUseCase {\n  constructor(\n    private readonly userRepository: UserRepository,\n    private readonly orderRepository: OrderRepository,\n  ) {}\n\n  async execute(dto: CreateOrderDto): Promise<Result<Order>> {\n    try {\n      const user = await this.userRepository.findById(dto.userId);\n      if (!user) {\n        return Result.fail(\"User not found\");\n      }\n\n      const lines = dto.items.map((item) =>\n        OrderLine.create(item.productId, item.quantity, item.price)\n      );\n\n      const order = Order.create(lines);\n      await this.orderRepository.save(order);\n\n      return Result.ok(order);\n    } catch (error) {\n      return Result.fail(error.message);\n    }\n  }\n}\n```\n\n---\n\n## Error Handling by Layer\n\n### Domain Layer - Domain Errors\n\n```typescript\n// src/domain/errors/validation-error.ts\nexport class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\n```\n\n### Application Layer - Application Errors\n\n```typescript\n// src/application/errors/not-found-error.ts\nexport class MemoryNotFoundError extends Error {\n  constructor(id: string) {\n    super(`Memory with id ${id} not found`);\n    this.name = \"MemoryNotFoundError\";\n  }\n}\n```\n\n### Infrastructure Layer - Infrastructure Errors\n\n```typescript\n// src/infrastructure/errors/database-error.ts\nexport class DatabaseError extends Error {\n  constructor(message: string, public readonly cause?: Error) {\n    super(message);\n    this.name = \"DatabaseError\";\n  }\n}\n```\n\n### Web Layer - HTTP Error Handling\n\n```typescript\n// src/web/middleware/error-handler.ts\nimport { ValidationError } from \"@/domain/errors/validation-error.ts\";\nimport { MemoryNotFoundError } from \"@/application/errors/memory-not-found-error.ts\";\nimport { DatabaseError } from \"@/infrastructure/errors/database-error.ts\";\n\nexport function errorHandler(error: Error): Response {\n  if (error instanceof ValidationError) {\n    return new Response(\n      JSON.stringify({ error: error.message }),\n      { status: 400, headers: { \"Content-Type\": \"application/json\" } },\n    );\n  }\n\n  if (error instanceof MemoryNotFoundError) {\n    return new Response(\n      JSON.stringify({ error: error.message }),\n      { status: 404, headers: { \"Content-Type\": \"application/json\" } },\n    );\n  }\n\n  if (error instanceof DatabaseError) {\n    console.error(\"Database error:\", error);\n    return new Response(\n      JSON.stringify({ error: \"Database service unavailable\" }),\n      { status: 503, headers: { \"Content-Type\": \"application/json\" } },\n    );\n  }\n\n  console.error(\"Unexpected error:\", error);\n  return new Response(\n    JSON.stringify({ error: \"Internal server error\" }),\n    { status: 500, headers: { \"Content-Type\": \"application/json\" } },\n  );\n}\n```\n\n---\n\n## Common Patterns\n\n### Result Type\n\nAvoid throwing exceptions across boundaries.\n\n```typescript\n// src/shared/types/result.ts\nexport class Result<T> {\n  private constructor(\n    private readonly success: boolean,\n    private readonly value?: T,\n    private readonly error?: string,\n  ) {}\n\n  static ok<T>(value: T): Result<T> {\n    return new Result(true, value);\n  }\n\n  static fail<T>(error: string): Result<T> {\n    return new Result(false, undefined, error);\n  }\n\n  isSuccess(): boolean { return this.success; }\n  isFailure(): boolean { return !this.success; }\n\n  getValue(): T {\n    if (!this.success) throw new Error(\"Cannot get value from failed result\");\n    return this.value!;\n  }\n\n  getError(): string {\n    if (this.success) throw new Error(\"Cannot get error from successful result\");\n    return this.error!;\n  }\n}\n```\n\n---\n\n## Anti-Patterns to Avoid\n\n### Anemic Domain Model\n\n```typescript\n// BAD - No behavior, just data\nexport class User {\n  id: string;\n  name: string;\n  email: string;\n}\n\n// GOOD - Rich domain model\nexport class User {\n  private name: string;\n\n  changeName(newName: string): void {\n    if (newName.trim().length === 0) {\n      throw new Error(\"Name cannot be empty\");\n    }\n    this.name = newName;\n  }\n}\n```\n\n### Infrastructure Leaking into Domain\n\n```typescript\n// BAD - Domain depends on infrastructure\nimport { Pool } from \"@db/postgres\";\n\nexport class User {\n  async save(pool: Pool): Promise<void> { /* ... */ }\n}\n\n// GOOD - Domain defines interface\nexport interface UserRepository {\n  save(user: User): Promise<void>;\n}\n```\n\n### Exposing Mutable State\n\n```typescript\n// BAD - Direct access to mutable array\nexport class Order {\n  public lines: OrderLine[] = [];\n}\n\n// GOOD - Encapsulation with readonly\nexport class Order {\n  private readonly lines: OrderLine[];\n\n  getLines(): ReadonlyArray<OrderLine> {\n    return this.lines;\n  }\n}\n```\n\n---\n\n## Key Principles Summary\n\n1. **Domain layer has no dependencies** - pure business logic\n2. **Follow dependency flow** - dependencies point inward\n3. **TypeScript-first** - No `any` types in production code\n4. **Use value objects for immutable concepts**\n5. **Entities have identity and lifecycle**\n6. **Aggregates enforce invariants**\n7. **Repositories are interfaces in domain**\n8. **Use cases orchestrate, don't contain business rules**\n9. **DTOs cross boundaries**\n10. **Layer-specific error handling**\n11. **Test domain logic in isolation**\n12. **Encapsulate state**\n13. **Use Result type for expected failures**\n14. **Error translation at boundaries**\n\n---\n\n## Additional Resources\n\n- **DDD Book (Eric Evans):** https://www.domainlanguage.com/ddd/\n- **Implementing DDD (Vaughn Vernon):** https://vaughnvernon.com/\n- **Martin Fowler's DDD:** https://martinfowler.com/tags/domain%20driven%20design.html"
              },
              {
                "name": "deno-patterns",
                "description": "Modern TypeScript patterns and migration guidance for Deno: resource management with 'using', async generators, error handling, and Web Standard APIs. Use when migrating from Node.js, implementing cleanup logic, or learning modern JS/TS patterns.",
                "path": "deno-lsp/skills/deno-patterns/SKILL.md",
                "frontmatter": {
                  "name": "deno-patterns",
                  "description": "Modern TypeScript patterns and migration guidance for Deno: resource management with 'using', async generators, error handling, and Web Standard APIs. Use when migrating from Node.js, implementing cleanup logic, or learning modern JS/TS patterns."
                },
                "content": "# Deno Modern Patterns & Migration\n\n## When to Use This Skill\n\nUse this skill when:\n- Migrating from Node.js to Deno\n- Learning modern JavaScript/TypeScript patterns\n- Implementing resource management\n- Working with timers, polling, or cleanup logic\n- Handling errors in Deno\n- Choosing between old and new patterns\n\n**Note:** Always read `deno-core.md` first for essential configuration and practices.\n\n---\n\n## Resource Management with `using`\n\n### The Problem with Manual Cleanup\n\n**Old Pattern:**\n\n```javascript\n// Manual timer cleanup - error-prone\nconst id = setInterval(() => {\n  console.log(\"Tick!\");\n}, 1000);\n\n// Later, cleanup (easy to forget!)\nclearInterval(id);\n```\n\n**Problems:**\n- Resource leaks if cleanup is missed\n- Not exception-safe\n- Resource not tied to lexical scope\n- Cleanup code separated from acquisition\n\n### The `using` Statement (Deno >= v2.4)\n\n**New Pattern:**\n\n```typescript\n// Automatic, exception-safe cleanup\nclass Timer {\n  #handle: number;\n\n  constructor(cb: () => void, ms: number) {\n    this.#handle = setInterval(cb, ms);\n  }\n\n  [Symbol.dispose]() {\n    clearInterval(this.#handle);\n    console.log(\"Timer disposed\");\n  }\n}\n\nusing timer = new Timer(() => {\n  console.log(\"Tick!\");\n}, 1000);\n// Timer automatically cleaned up at end of scope\n```\n\n**Benefits:**\n- Automatic cleanup at scope exit\n- Exception-safe (cleanup happens even if errors occur)\n- Follows RAII (Resource Acquisition Is Initialization) principles\n- Prevents resource leaks in complex control flows\n- Composable with multiple `using` declarations\n\n### Async Resource Management\n\nFor async cleanup, use `await using` with `Symbol.asyncDispose`:\n\n```typescript\nclass DatabaseConnection {\n  #conn: Connection;\n\n  constructor(conn: Connection) {\n    this.#conn = conn;\n  }\n\n  async [Symbol.asyncDispose]() {\n    await this.#conn.close();\n    console.log(\"Database connection closed\");\n  }\n}\n\n// Automatically closes when scope exits\nawait using db = new DatabaseConnection(conn);\nawait db.query(\"SELECT * FROM users\");\n// Connection closed here, even if query throws\n```\n\n### When to Use `using`\n\nUse `using` for any resource that needs cleanup:\n- Timers (setInterval, setTimeout)\n- File handles\n- Database connections\n- Network connections\n- Locks and mutexes\n- Any object with teardown logic\n\n---\n\n## Async Iteration Over Polling\n\n### The Problem with Traditional Polling\n\n**Old Pattern:**\n\n```javascript\n// Traditional polling - not cancelable, drift-prone\nlet running = true;\n\nfunction poll() {\n  if (!running) return;\n  // ...check something...\n  setTimeout(poll, 1000);\n}\n\npoll();\nrunning = false;  // Unreliable cancellation\n```\n\n**Problems:**\n- Timer drift accumulates over time\n- Race conditions with cancellation flag\n- Hard to compose or integrate with other async code\n- Not part of the structured concurrency model\n\n### Async Generators for Polling\n\n**New Pattern:**\n\n```typescript\n// Async generator - naturally cancelable\nasync function* interval(ms: number) {\n  while (true) {\n    yield;\n    await new Promise((r) => setTimeout(r, ms));\n  }\n}\n\n// Usage with for-await-of\nfor await (const _ of interval(1000)) {\n  // ...do work...\n  if (shouldStop()) break;  // Clean, immediate cancellation\n}\n```\n\n**Benefits:**\n- Natural cancellation by breaking the loop\n- No timer drift - explicit timing control\n- Composable with Promise.race, yield*, etc.\n- Integrates with all async iterable APIs\n- Clear control flow\n\n### Advanced Polling Patterns\n\n**Polling with timeout:**\n\n```typescript\nasync function* intervalWithTimeout(intervalMs: number, timeoutMs: number) {\n  const startTime = Date.now();\n\n  while (Date.now() - startTime < timeoutMs) {\n    yield;\n    await new Promise((r) => setTimeout(r, intervalMs));\n  }\n}\n\nfor await (const _ of intervalWithTimeout(1000, 10000)) {\n  // Polls every 1s, stops after 10s\n  await checkCondition();\n}\n```\n\n---\n\n## Async/Promise Best Practices\n\n### Remove Unnecessary `async`\n\n**Incorrect:**\n\n```typescript\n// BAD - Unnecessary async wrapper\nasync function validateMemory(content: string): boolean {\n  if (content.trim().length === 0) {\n    throw new Error(\"Content cannot be empty\");\n  }\n  return true;\n}\n```\n\n**Correct:**\n\n```typescript\n// GOOD - No async needed\nfunction validateMemory(content: string): boolean {\n  if (content.trim().length === 0) {\n    throw new Error(\"Content cannot be empty\");\n  }\n  return true;\n}\n```\n\n### Interface Compliance with Promise.resolve()\n\nWhen implementing an interface that requires `Promise<T>` but your logic is synchronous:\n\n```typescript\ninterface QueueMessageHandler {\n  handle(message: QueueMessage): Promise<void>;\n}\n\n// GOOD - Return Promise.resolve() explicitly\nclass SyncMessageHandler implements QueueMessageHandler {\n  handle(message: QueueMessage): Promise<void> {\n    this.processSync(message);\n    return Promise.resolve();\n  }\n}\n\n// GOOD - Return Promise.reject() for errors\nclass ValidatingHandler implements QueueMessageHandler {\n  handle(message: QueueMessage): Promise<void> {\n    if (message.corrupted) {\n      return Promise.reject(new Error(\"Message corrupted\"));\n    }\n    return Promise.resolve();\n  }\n}\n```\n\n### Only Use `async` When You Actually `await`\n\n```typescript\n// GOOD - async because we await\nasync function processMemory(content: string): Promise<ProcessedMemory> {\n  const embedding = await ollama.generateEmbedding(content);\n  const entities = await ollama.extractEntities(content);\n  return { content, embedding, entities };\n}\n\n// GOOD - no async because no await\nfunction validateConfig(config: Config): boolean {\n  return config.apiKey !== undefined;\n}\n```\n\n---\n\n## Error Handling\n\n### Deno's Class-Based Errors\n\n**Old Pattern (Node.js):**\n\n```javascript\n// String-based error codes\ntry {\n  fs.readFileSync('file');\n} catch (err) {\n  if (err.code === 'ENOENT') {\n    // handle not found\n  }\n}\n```\n\n**New Pattern (Deno):**\n\n```typescript\n// Type-safe error classes\ntry {\n  await Deno.readTextFile(\"file.txt\");\n} catch (err) {\n  if (err instanceof Deno.errors.NotFound) {\n    // handle not found\n  } else if (err instanceof Deno.errors.PermissionDenied) {\n    // handle permission error\n  }\n}\n```\n\n### Available Deno Error Classes\n\n```typescript\nDeno.errors.NotFound\nDeno.errors.PermissionDenied\nDeno.errors.ConnectionRefused\nDeno.errors.ConnectionReset\nDeno.errors.ConnectionAborted\nDeno.errors.NotConnected\nDeno.errors.AddrInUse\nDeno.errors.AddrNotAvailable\nDeno.errors.BrokenPipe\nDeno.errors.AlreadyExists\nDeno.errors.InvalidData\nDeno.errors.TimedOut\nDeno.errors.Interrupted\nDeno.errors.WriteZero\nDeno.errors.UnexpectedEof\nDeno.errors.BadResource\nDeno.errors.Busy\n```\n\n### Error Handling Best Practices\n\n```typescript\n// Specific error handling\nasync function loadConfig(path: string): Promise<Config> {\n  try {\n    const content = await Deno.readTextFile(path);\n    return JSON.parse(content);\n  } catch (err) {\n    if (err instanceof Deno.errors.NotFound) {\n      throw new Error(`Config file not found: ${path}`);\n    } else if (err instanceof Deno.errors.PermissionDenied) {\n      throw new Error(`Permission denied reading config: ${path}`);\n    } else if (err instanceof SyntaxError) {\n      throw new Error(`Invalid JSON in config: ${path}`);\n    }\n    throw err;  // Re-throw unknown errors\n  }\n}\n```\n\n**Benefits:**\n- Type-safe - no magic string codes\n- Better IDE autocomplete\n- Easier refactoring\n- Clear error hierarchies\n\n---\n\n## Web-Standard APIs\n\n### HTTP Server\n\n**Old (Node.js):**\n\n```javascript\n// Node.js style\nconst http = require(\"http\");\nhttp.createServer((req, res) => {\n  res.writeHead(200);\n  res.end(\"OK\");\n}).listen(8000);\n```\n\n**New (Deno):**\n\n```typescript\n// Deno - serverless-compatible\nDeno.serve((req) => new Response(\"OK\"));\n```\n\n**Benefits:**\n- Simpler, cleaner API\n- Native Request/Response objects\n- Works with serverless platforms\n- No legacy API constraints\n\n### File Operations\n\n**Old (Node.js):**\n\n```javascript\n// Node.js callbacks\nfs.readFile('file.txt', 'utf8', (err, data) => {\n  if (err) throw err;\n  console.log(data);\n});\n```\n\n**New (Deno):**\n\n```typescript\n// Deno - async/await\nconst data = await Deno.readTextFile(\"file.txt\");\nconsole.log(data);\n```\n\n### Fetch API\n\nDeno has native `fetch()` with no imports needed:\n\n```typescript\n// Native fetch - no imports\nconst response = await fetch(\"https://api.example.com/data\");\nconst data = await response.json();\n```\n\n### Streams\n\nUse Web Streams API:\n\n```typescript\n// Web Streams\nconst file = await Deno.open(\"large-file.txt\");\nconst readable = file.readable;\n\nfor await (const chunk of readable) {\n  // Process chunk\n}\n```\n\n### Crypto\n\nUse Web Crypto API:\n\n```typescript\n// Web Crypto\nconst data = new TextEncoder().encode(\"hello\");\nconst hashBuffer = await crypto.subtle.digest(\"SHA-256\", data);\nconst hashArray = Array.from(new Uint8Array(hashBuffer));\nconst hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n```\n\n---\n\n## Standard Library Utilities\n\n### Path Operations\n\n```typescript\nimport { join, dirname, basename } from \"@std/path\";\n\nconst fullPath = join(\"/users\", \"alice\", \"documents\", \"file.txt\");\nconst dir = dirname(fullPath);  // /users/alice/documents\nconst file = basename(fullPath);  // file.txt\n```\n\n### File System\n\n```typescript\nimport { ensureDir, exists } from \"@std/fs\";\n\n// Ensure directory exists\nawait ensureDir(\"./data/cache\");\n\n// Check if file exists\nif (await exists(\"config.json\")) {\n  // ...\n}\n```\n\n### Time-Based Identifiers\n\nUse `@std/ulid` for sortable IDs:\n\n```typescript\nimport { ulid } from \"@std/ulid\";\n\n// Generate ULID (sortable by creation time)\nconst id = ulid();  // 01ARZ3NDEKTSV4RRFFQ69G5FAV\n\n// ULIDs are lexicographically sortable by time\nconst ids = [ulid(), ulid(), ulid()];\nids.sort();  // Automatically sorted by creation time\n```\n\n**When to use ULID:**\n- Need UUID-like identifiers sortable by time\n- Want to avoid UUID v4 random collisions\n- Need efficient database indexing by creation time\n- Want to extract timestamp from ID\n\n---\n\n## Pattern Migration Guide\n\n### Quick Reference\n\n| Use Case         | Old Pattern                        | Modern (Deno) Pattern                      |\n|------------------|------------------------------------|--------------------------------------------|\n| Timer            | `setInterval` + `clearInterval`    | `using` + class w/ `Symbol.dispose`        |\n| Polling          | Repeated `setTimeout`              | Async generator (`for await...of`)         |\n| Cleanup          | Manual try/finally                 | `using`/`await using`                      |\n| Error Handling   | `if (err.code === ...)`            | `if (err instanceof Deno.errors.*)`        |\n| HTTP Server      | `http.createServer`                | `Deno.serve`                               |\n| File Reading     | `fs.readFileSync`                  | `await Deno.readTextFile`                  |\n| Environment Vars | `process.env.VAR`                  | `Deno.env.get(\"VAR\")`                      |\n| Module Format    | CommonJS (`require`)               | ESM (`import`)                             |\n\n### Migration Examples\n\n**Timer Management:**\n\n```typescript\n// Old:\nconst id = setInterval(doWork, 1000);\n// ... later ...\nclearInterval(id);\n\n// New:\nclass Timer {\n  #id;\n  constructor(cb, ms) { this.#id = setInterval(cb, ms); }\n  [Symbol.dispose]() { clearInterval(this.#id); }\n}\nusing t = new Timer(doWork, 1000);\n// Automatically disposed at end of scope\n```\n\n**Async Polling:**\n\n```typescript\n// Old:\nlet running = true;\nconst poll = () => {\n  if (!running) return;\n  doWork();\n  setTimeout(poll, 1000);\n};\npoll();\nrunning = false;  // To stop\n\n// New:\nasync function* poller(ms) {\n  while (true) {\n    yield;\n    await new Promise(r => setTimeout(r, ms));\n  }\n}\nfor await (const _ of poller(1000)) {\n  doWork();\n  if (shouldStop()) break;  // Natural cancellation\n}\n```\n\n**File Operations:**\n\n```typescript\n// Old (Node.js):\nconst fs = require('fs');\nconst data = fs.readFileSync('file.txt', 'utf8');\n\n// New (Deno):\nconst data = await Deno.readTextFile(\"file.txt\");\n```\n\n**Environment Variables:**\n\n```typescript\n// Old (Node.js):\nconst apiKey = process.env.API_KEY;\n\n// New (Deno):\nconst apiKey = Deno.env.get(\"API_KEY\");\n// Requires: --allow-env=API_KEY\n```\n\n---\n\n## Structured Concurrency\n\n### AbortController for Cancellation\n\n```typescript\nasync function fetchWithTimeout(url: string, timeoutMs: number): Promise<Response> {\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\n\n  try {\n    const response = await fetch(url, { signal: controller.signal });\n    return response;\n  } finally {\n    clearTimeout(timeoutId);\n  }\n}\n\n// Usage:\ntry {\n  const response = await fetchWithTimeout(\"https://slow-api.com\", 5000);\n} catch (err) {\n  if (err.name === 'AbortError') {\n    console.log(\"Request timed out\");\n  }\n}\n```\n\n### Racing Multiple Promises\n\n```typescript\n// First successful response wins\nconst response = await Promise.race([\n  fetch(\"https://api1.com/data\"),\n  fetch(\"https://api2.com/data\"),\n  fetch(\"https://api3.com/data\"),\n]);\n\n// All must succeed\nconst [user, posts, comments] = await Promise.all([\n  fetchUser(id),\n  fetchPosts(id),\n  fetchComments(id),\n]);\n```\n\n---\n\n## Performance Considerations\n\n### Resource Management\n\n**No Runtime Overhead:**\n- `using` has no performance penalty vs manual cleanup\n- More robust in exception paths\n- Prevents resource leaks that degrade performance\n\n### Async Generators\n\n**Minimal Overhead:**\n- Async generators are efficient\n- No additional allocations per iteration\n- Better than callback-based patterns\n\n### Type-Only Imports\n\n**Build-Time Optimization:**\n\n```typescript\n// GOOD - Erased at runtime\nimport type { User } from \"./types.ts\";\n\n// BAD - Bundled even if only used for types\nimport { User } from \"./types.ts\";\n```\n\n---\n\n## Summary: Modern Pattern Principles\n\n1. **Use `using` for any resource needing cleanup**\n2. **Prefer async generators over polling loops**\n3. **Remove `async` if no `await` is present**\n4. **Use Promise.resolve() for interface compliance**\n5. **Handle errors with Deno's class-based system**\n6. **Prefer Web Standard APIs over Node.js patterns**\n7. **Use AbortController for cancellable operations**\n8. **Leverage @std library for common operations**\n9. **Use ULID for time-based sortable IDs**\n10. **Always prefer structured, composable patterns**\n\n---\n\n## Additional Resources\n\n- **TC39 Explicit Resource Management:** https://github.com/tc39/proposal-explicit-resource-management\n- **Deno Web APIs:** https://docs.deno.com/runtime/manual/runtime/web_platform_apis\n- **Async Iterators:** https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/asyncIterator"
              },
              {
                "name": "Deno TypeScript LSP",
                "description": "Use this skill when working with TypeScript/JavaScript files (.ts, .tsx, .js, .jsx, .mts, .cts, .mjs, .cjs) in Deno projects, or when the user asks about Deno-specific patterns, imports, configuration, testing, or tooling.",
                "path": "deno-lsp/skills/deno-typescript/SKILL.md",
                "frontmatter": {
                  "name": "Deno TypeScript LSP",
                  "description": "Use this skill when working with TypeScript/JavaScript files (.ts, .tsx, .js, .jsx, .mts, .cts, .mjs, .cjs) in Deno projects, or when the user asks about Deno-specific patterns, imports, configuration, testing, or tooling.",
                  "version": "1.0.0"
                },
                "content": "# Deno TypeScript Development\n\nDeno is the primary TypeScript/JavaScript runtime and language server. It replaces the entire Node.js toolchain: no tsc, eslint, prettier, jest, webpack needed.\n\n## Core Philosophy\n\n- **One tool** - Deno handles typecheck, lint, format, test, coverage, benchmark\n- **Security first** - Explicit permissions, minimal external dependencies\n- **Import maps** - All dependencies declared in `deno.json`, never direct imports\n- **ESM only** - No CommonJS, always include `.ts` extensions in relative imports\n\n## Configuration - deno.json\n\nSingle source of truth for all project configuration:\n\n```json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true\n  },\n  \"imports\": {\n    \"@/\": \"./src/\",\n    \"@std/assert\": \"jsr:@std/assert@^1.0.14\",\n    \"@std/fs\": \"jsr:@std/fs@^1.0.19\",\n    \"zod\": \"npm:zod@^3.23.8\"\n  },\n  \"tasks\": {\n    \"dev\": \"deno run --watch --allow-net --allow-read src/main.ts\",\n    \"test\": \"deno test --allow-all --coverage=coverage\",\n    \"check\": \"deno check src/**/*.ts\",\n    \"lint\": \"deno lint\",\n    \"fmt\": \"deno fmt\"\n  },\n  \"exclude\": [\"coverage/\", \"node_modules/\"],\n  \"lock\": true\n}\n```\n\n## Import Strategy\n\n**CRITICAL:** Never use direct JSR/npm imports in source files.\n\n```typescript\n// ✅ GOOD - Use import map aliases\nimport { assertEquals } from \"@std/assert\";\nimport { z } from \"zod\";\nimport { Agent } from \"@/domain/agent.ts\";\nimport { helper } from \"./utils.ts\";  // Extension required!\n\n// ❌ BAD - Direct registry imports\nimport { z } from \"npm:zod@^3.23.8\";\nimport { assertEquals } from \"jsr:@std/assert\";\n```\n\n**Import Order:**\n1. Standard library (`@std/*`)\n2. Third-party (`zod`, etc.)\n3. Internal absolute (`@/domain/...`)\n4. Relative (`./utils.ts`)\n\n**Version Pinning:** Always pin versions in `deno.json`. No floating `@latest`.\n\n## Dependency Sources (Priority Order)\n\n1. **`jsr:` registry** - First choice for TypeScript modules\n2. **`npm:` specifier** - When JSR unavailable, prefer ESM-compatible\n3. **URL imports** - Rarely needed with import maps\n\n```json\n{\n  \"imports\": {\n    \"@std/assert\": \"jsr:@std/assert@^1.0.14\",\n    \"zod\": \"npm:zod@^3.23.8\"\n  }\n}\n```\n\n## Testing\n\n**Co-locate unit tests with source:**\n\n```\nsrc/\n└── domain/\n    ├── agent.ts\n    └── agent.test.ts    # Test file next to source\n```\n\n**Test file naming:** Always use `.test.ts` suffix.\n\n**AAA Pattern (Arrange-Act-Assert):**\n\n```typescript\nimport { assertEquals } from \"@std/assert\";\n\nDeno.test(\"agent processes valid input\", () => {\n  // Arrange\n  const agent = new Agent({ name: \"Test\" });\n\n  // Act\n  const result = agent.process(\"hello\");\n\n  // Assert\n  assertEquals(result.status, \"success\");\n});\n```\n\n**Coverage requirements:**\n- Line coverage: 80%+ (non-negotiable)\n- Branch coverage: 60-80% (non-negotiable)\n\n**Use `@std/testing` for test utilities:**\n\n```typescript\nimport { FakeTime } from \"@std/testing/time\";\nimport { stub, spy } from \"@std/testing/mock\";\n\nDeno.test(\"timer behavior\", () => {\n  using time = new FakeTime();\n  time.tick(1000);\n  // Deterministic time control\n});\n```\n\n## Permissions Model\n\nDefault to minimum required permissions:\n\n```bash\n# ❌ BAD\ndeno run --allow-all script.ts\n\n# ✅ GOOD\ndeno run --allow-read=./data --allow-net=api.example.com script.ts\n```\n\n**Common flags:**\n- `--allow-read[=<path>]` - File system read\n- `--allow-write[=<path>]` - File system write\n- `--allow-net[=<domain>]` - Network access\n- `--allow-env[=<var>]` - Environment variables\n- `--allow-run[=<program>]` - Subprocess execution\n\n## Essential Commands\n\n```bash\n# Development\ndeno run --watch src/main.ts     # Watch mode\ndeno check src/**/*.ts           # Type-check\ndeno fmt                         # Format\ndeno lint                        # Lint\n\n# Testing\ndeno test                        # Run tests\ndeno test --watch --fail-fast    # Watch mode\ndeno test --coverage=coverage    # With coverage\ndeno coverage coverage --html    # Generate report\n\n# Dependencies\ndeno add jsr:@std/path           # Add dependency\ndeno cache --reload              # Update cache\ndeno cache --lock=deno.lock --lock-write  # Update lockfile\n\n# Tasks\ndeno task dev                    # Run defined task\n```\n\n## Standard Library (@std/*)\n\nUse JSR standard library for common utilities:\n\n- `@std/assert` - Testing assertions\n- `@std/fs` - File system utilities\n- `@std/path` - Path manipulation\n- `@std/http` - HTTP server/client\n- `@std/async` - Async utilities (debounce, retry, etc.)\n- `@std/testing` - Mock, spy, FakeTime\n- `@std/ulid` - ULID generation\n\n## Anti-Patterns to Avoid\n\n```typescript\n// ❌ Direct registry imports in source\nimport { z } from \"npm:zod@^3.23.8\";\n\n// ❌ Missing file extension\nimport { helper } from \"./utils\";\n\n// ❌ Node.js APIs\nimport * as fs from \"node:fs\";\nconst fs = require(\"fs\");\n\n// ❌ Unnecessary async wrapper\nasync function validate(input: string): Promise<boolean> {\n  return input.length > 0;  // No await needed\n}\n\n// ❌ Test delays instead of FakeTime\nawait new Promise(r => setTimeout(r, 100));\n```\n\n## Lockfile Management\n\n- **Always commit** `deno.lock` to version control\n- Update lockfile: `deno cache --lock=deno.lock --lock-write`\n- CI mode: `deno run --lock=deno.lock --lock-write=false`"
              }
            ]
          },
          {
            "name": "jsr-audit",
            "description": "Audit Deno/TypeScript packages for JSR compliance and publishing readiness",
            "source": "./jsr-audit",
            "category": null,
            "version": null,
            "author": null,
            "install_commands": [
              "/plugin marketplace add jahanson/cc-plugins",
              "/plugin install jsr-audit@local-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-08T21:48:48Z",
              "created_at": "2025-12-23T15:52:29Z",
              "license": null
            },
            "commands": [],
            "skills": [
              {
                "name": "jsr-audit",
                "description": "This skill should be used when the user asks to 'audit for JSR', 'check JSR readiness', 'review JSR config', 'verify package for JSR', 'publish to JSR', 'prepare for JSR publishing', 'JSR compliance check', 'run JSR audit', or wants to ensure their Deno/TypeScript package meets JSR standards before publishing.",
                "path": "jsr-audit/skills/jsr-audit/SKILL.md",
                "frontmatter": {
                  "name": "jsr-audit",
                  "description": "This skill should be used when the user asks to 'audit for JSR', 'check JSR readiness', 'review JSR config', 'verify package for JSR', 'publish to JSR', 'prepare for JSR publishing', 'JSR compliance check', 'run JSR audit', or wants to ensure their Deno/TypeScript package meets JSR standards before publishing.",
                  "version": "1.0.0"
                },
                "content": "# JSR Publishing Audit\n\nComprehensive audit guide for JSR (JavaScript Registry) compliance and scoring optimization.\n\n---\n\n## Understanding the JSR Score\n\nJSR assigns packages a quality score from 0-100%, displayed with color coding:\n- **Red**: Below 60%\n- **Orange**: 60-90%\n- **Green**: 90%+ (target this)\n\nThe score directly influences search ranking. View any package's breakdown at `jsr.io/@scope/package/score`.\n\n### The 9 Scoring Factors\n\n| Category | Factor | Impact |\n|----------|--------|--------|\n| **Documentation** | Has README or module doc | High |\n| | Has examples in README/module doc | High |\n| | Has module docs in all entrypoints | High |\n| | Has docs for most symbols | High |\n| **Best Practices** | No slow types | Medium |\n| | Has provenance (SLSA attestation) | Medium |\n| **Discoverability** | Has description (≤250 chars) | Low |\n| **Compatibility** | At least one runtime marked compatible | Low |\n| | At least two runtimes compatible | Low |\n\n**Key insight**: Documentation carries the heaviest weight. Comprehensive JSDoc + README + `@module` tags will score higher than perfect types with minimal docs.\n\n---\n\n## Audit Checklist\n\n| Check | Command/Location | What to Look For |\n|-------|------------------|------------------|\n| Required metadata | `deno.json` | `name`, `version`, `exports` fields |\n| Scoped package name | `name` field | Format: `@scope/package-name` |\n| Package description | `description` field | ≤250 characters for discoverability |\n| Valid exports | `exports` field | Entry points exist and are correct |\n| No slow types | `deno publish --dry-run` | No slow type warnings |\n| Clean file list | `deno publish --dry-run` | Only intended files included |\n| ESM only | Source files | No CommonJS (`module.exports`, `require()`) |\n| Module documentation | Entry point files | `@module` JSDoc tag present |\n| Symbol documentation | Exported symbols | JSDoc with `@param`, `@returns`, `@example` |\n\n---\n\n## Audit Process\n\n### Step 1: Check Required Metadata\n\nRead `deno.json` (or `jsr.json`) and verify:\n\n```json\n{\n  \"name\": \"@scope/package-name\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Concise package description under 250 characters\",\n  \"exports\": \"./mod.ts\"\n}\n```\n\n**Package name rules:**\n- Must start with `@scope/`\n- Lowercase letters, numbers, hyphens only\n- 2-40 characters (excluding scope)\n\n**Config file choice:**\n- Deno projects: Use `deno.json`\n- Node/Bun/other: Use `jsr.json`\n- Never split config between both files\n\n### Step 2: Verify Exports\n\nCheck all entry points exist:\n\n```json\n{\n  \"exports\": {\n    \".\": \"./mod.ts\",\n    \"./utils\": \"./src/utils/mod.ts\"\n  }\n}\n```\n\nFor each entry point, confirm:\n- File exists at specified path\n- Exports are properly defined\n- Type annotations are explicit (no slow types)\n- Has `@module` JSDoc tag\n\n### Step 3: Audit Documentation Quality\n\n**Module-level documentation** (top of entry points):\n\n```typescript\n/**\n * A module providing string utilities for common transformations.\n *\n * @example\n * ```ts\n * import { camelCase } from \"@scope/cases\";\n * camelCase(\"hello world\"); // \"helloWorld\"\n * ```\n *\n * @module\n */\n```\n\n**Symbol documentation**:\n\n```typescript\n/**\n * Converts a string to camelCase format.\n *\n * @param input - The string to convert\n * @returns The camelCase formatted string\n *\n * @example\n * ```ts\n * camelCase(\"hello world\"); // \"helloWorld\"\n * camelCase(\"foo-bar-baz\"); // \"fooBarBaz\"\n * ```\n */\nexport function camelCase(input: string): string {\n  // ...\n}\n```\n\n**JSDoc tags reference:**\n- `@param name - description` - Document parameters\n- `@returns description` - Document return value\n- `@example` - Runnable code examples (use triple backticks)\n- `@deprecated message` - Mark deprecated APIs\n- `@see SymbolName` - Cross-reference related symbols\n- `@throws ErrorType` - Document thrown errors\n- `{@link SymbolName}` - Inline links\n- `{@linkcode SymbolName}` - Inline links with monospace\n\n### Step 4: Run Dry-Run Verification\n\n```bash\ndeno publish --dry-run --allow-dirty\n```\n\nThis reveals:\n- **Slow types**: Exports without explicit type annotations\n- **File list**: Everything that would be published\n- **Metadata errors**: Invalid name, version, etc.\n\n### Step 5: Audit the File List\n\nReview dry-run output for files that should NOT be published:\n\n**Common offenders:**\n- `.claude/`, `.zed/`, `.vscode/` - IDE settings\n- `.github/`, `.gitlab/` - CI/CD configs\n- `.mise.toml`, `.tool-versions` - Local tooling\n- `coverage/` - Test coverage data\n- `docs/`, `*.md` (except LICENSE/README) - Documentation\n- `deno.lock` - Lock files\n- `*.test.ts`, `**/test_utils/**` - Test files\n- `sonar-project.properties`, `*.config.js` - Build configs\n- `.env`, `*.local.*` - Local configuration\n\n### Step 6: Configure Publish Filtering\n\nUse `include` (whitelist) + `exclude` (filter):\n\n```json\n{\n  \"publish\": {\n    \"include\": [\n      \"LICENSE\",\n      \"README.md\",\n      \"deno.json\",\n      \"mod.ts\",\n      \"src/**/*.ts\"\n    ],\n    \"exclude\": [\n      \"**/*.test.ts\",\n      \"**/test_utils/**\"\n    ]\n  }\n}\n```\n\n**Why both?**\n- `include` whitelists only intended files\n- `exclude` filters test files from `src/**/*.ts` glob\n- `exclude` takes precedence when both match\n\n### Step 7: Verify Clean Output\n\nRun dry-run again. Only these should appear:\n- `LICENSE`\n- `README.md`\n- `deno.json`\n- Entry point files (`mod.ts`, etc.)\n- Source code (`src/**/*.ts` minus tests)\n\n---\n\n## Fixing Slow Types\n\nSlow types are exports without explicit type annotations. They prevent JSR from generating `.d.ts` files efficiently and degrade npm compatibility by 1.5-2x slower type checking.\n\n### Function Return Types\n\n```typescript\n// SLOW - inferred return type\nexport function greet(name: string) {\n  return \"Hello, \" + name + \"!\";\n}\n\n// FIXED - explicit return type\nexport function greet(name: string): string {\n  return \"Hello, \" + name + \"!\";\n}\n```\n\n### Constants\n\n```typescript\n// SLOW - inferred type\nexport const GLOBAL_ID = crypto.randomUUID();\n\n// FIXED - explicit annotation\nexport const GLOBAL_ID: string = crypto.randomUUID();\n```\n\n### Class Properties\n\n```typescript\n// SLOW - inferred property type\nexport class Config {\n  timeout = 5000;\n}\n\n// FIXED - explicit property type\nexport class Config {\n  timeout: number = 5000;\n}\n```\n\n### Detection Commands\n\n```bash\n# Catch slow types before publishing\ndeno publish --dry-run\n\n# Validate documentation generation\ndeno doc --lint\n```\n\n**Note**: TypeScript 5.5's `isolatedDeclarations` mode produces code that automatically satisfies JSR's no-slow-types requirement.\n\n---\n\n## Prohibited Patterns\n\nJSR enforces ESM-only architecture:\n\n| Prohibited | Alternative |\n|------------|-------------|\n| `require()` | `import` |\n| `module.exports` | `export` |\n| `declare global` | Module-scoped types |\n| `declare module` | Module-scoped types |\n| HTTP imports | `jsr:`, `npm:`, `node:` specifiers only |\n\n---\n\n## Multiple Entry Points\n\nFor packages with multiple exports:\n\n```json\n{\n  \"exports\": {\n    \".\": \"./mod.ts\",\n    \"./providers\": \"./providers.ts\",\n    \"./utils\": \"./src/utils/mod.ts\"\n  }\n}\n```\n\nUsers import as:\n```typescript\nimport { main } from \"@scope/pkg\";\nimport { OpenAI } from \"@scope/pkg/providers\";\nimport { helper } from \"@scope/pkg/utils\";\n```\n\nEach entry point should have its own `@module` JSDoc tag.\n\n---\n\n## Dependencies\n\nDeclare in `imports`:\n\n```json\n{\n  \"imports\": {\n    \"@std/assert\": \"jsr:@std/assert@^1.0.0\",\n    \"zod\": \"npm:zod@^3.22.0\"\n  }\n}\n```\n\nSupported specifiers:\n- `jsr:@scope/pkg@version` - JSR packages\n- `npm:package@version` - npm packages\n- `node:module` - Node.js built-ins\n\n---\n\n## CI Publishing with Provenance\n\nGitHub Actions OIDC enables tokenless publishing with automatic SLSA provenance:\n\n```yaml\nname: Publish to JSR\non:\n  push:\n    tags: ['v*']\n\njobs:\n  publish:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n      id-token: write  # Required for OIDC and provenance\n\n    steps:\n      - uses: actions/checkout@v5\n      - uses: denoland/setup-deno@v2\n        with:\n          deno-version: v2.x\n      - run: deno publish\n```\n\n**Requirements for provenance:**\n1. Link package to GitHub repo in JSR settings\n2. Include `id-token: write` permission\n3. Provenance generated automatically\n\nNo API tokens needed - JSR uses GitHub OIDC authentication.\n\n---\n\n## Audit Report Template\n\nAfter completing the audit:\n\n```markdown\n## JSR Publishing Audit Results\n\n| Check | Status |\n|-------|--------|\n| Required metadata | ✓ / ✗ |\n| Scoped package name | ✓ / ✗ |\n| Package description | ✓ / ✗ |\n| Valid exports | ✓ / ✗ |\n| No slow types | ✓ / ✗ |\n| Clean file list | ✓ / ✗ |\n| ESM only | ✓ / ✗ |\n| Module documentation | ✓ / ✗ |\n| Symbol documentation | ✓ / ✗ |\n\n### Estimated Score Impact\n- Documentation: X/4 factors\n- Best Practices: X/2 factors\n- Discoverability: X/1 factors\n- Compatibility: X/2 factors\n\n### Files Published\n[List from dry-run]\n\n### Issues Found\n[List any problems]\n\n### Recommendations\n[Suggested fixes prioritized by score impact]\n```\n\n---\n\n## Quick Commands\n\n```bash\n# Full audit dry-run\ndeno publish --dry-run --allow-dirty\n\n# Validate documentation\ndeno doc --lint\n\n# Type check\ndeno check **/*.ts\n\n# Lint\ndeno lint\n\n# Format\ndeno fmt\n\n# Publish (when ready)\ndeno publish\n```\n\n---\n\n## Known Limitations (2024-2025)\n\n- **Private packages**: Not yet available (most requested feature)\n- **JSX publishing**: Not supported\n- **HTTP imports**: Prohibited\n- **Complex inference**: Libraries like Zod/ArkType may require `--allow-slow-types`"
              }
            ]
          }
        ]
      }
    }
  ]
}