{
  "owner": {
    "id": "DataflightSolutions",
    "display_name": "DataflightSolutions",
    "type": "Organization",
    "avatar_url": "https://avatars.githubusercontent.com/u/177332119?v=4",
    "url": "https://github.com/DataflightSolutions",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 2,
      "total_commands": 10,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "DataflightSolutions/claude-plugins",
      "url": "https://github.com/DataflightSolutions/claude-plugins",
      "description": null,
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2025-12-01T14:39:08Z",
        "created_at": "2025-11-28T13:18:50Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1263
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 230
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1067
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 2487
        },
        {
          "path": "plugins",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/graphite",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/graphite/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/graphite/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 320
        },
        {
          "path": "plugins/graphite/.gitignore",
          "type": "blob",
          "size": 214
        },
        {
          "path": "plugins/graphite/README.md",
          "type": "blob",
          "size": 3793
        },
        {
          "path": "plugins/graphite/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/graphite/commands/create-submit.md",
          "type": "blob",
          "size": 3346
        },
        {
          "path": "plugins/graphite/commands/create.md",
          "type": "blob",
          "size": 3617
        },
        {
          "path": "plugins/graphite/commands/gt-create-submit.md",
          "type": "blob",
          "size": 250
        },
        {
          "path": "plugins/graphite/commands/gt-create.md",
          "type": "blob",
          "size": 220
        },
        {
          "path": "plugins/graphite/commands/gt-submit.md",
          "type": "blob",
          "size": 219
        },
        {
          "path": "plugins/graphite/commands/submit.md",
          "type": "blob",
          "size": 2200
        },
        {
          "path": "plugins/playwright",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/playwright/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/playwright/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 454
        },
        {
          "path": "plugins/playwright/.gitignore",
          "type": "blob",
          "size": 61
        },
        {
          "path": "plugins/playwright/API_REFERENCE.md",
          "type": "blob",
          "size": 14971
        },
        {
          "path": "plugins/playwright/README.md",
          "type": "blob",
          "size": 5539
        },
        {
          "path": "plugins/playwright/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/playwright/commands/check-links.md",
          "type": "blob",
          "size": 4596
        },
        {
          "path": "plugins/playwright/commands/screenshot.md",
          "type": "blob",
          "size": 2118
        },
        {
          "path": "plugins/playwright/commands/test-page.md",
          "type": "blob",
          "size": 6685
        },
        {
          "path": "plugins/playwright/commands/test-responsive.md",
          "type": "blob",
          "size": 7702
        },
        {
          "path": "plugins/playwright/lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/playwright/lib/helpers.js",
          "type": "blob",
          "size": 47456
        },
        {
          "path": "plugins/playwright/package-lock.json",
          "type": "blob",
          "size": 3374
        },
        {
          "path": "plugins/playwright/package.json",
          "type": "blob",
          "size": 588
        },
        {
          "path": "plugins/playwright/run.js",
          "type": "blob",
          "size": 6256
        },
        {
          "path": "plugins/playwright/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/playwright/skills/playwright",
          "type": "tree",
          "size": null
        },
        {
          "path": "plugins/playwright/skills/playwright/SKILL.md",
          "type": "blob",
          "size": 14893
        }
      ],
      "marketplace": {
        "name": "dataflight-claude-plugins",
        "version": "1.0.0",
        "description": "Official Claude Code plugins for DataFlight workflows",
        "owner_info": {
          "name": "DataflightSolutions",
          "url": "https://github.com/DataflightSolutions"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "graphite",
            "description": "Automate Graphite stacked-PR workflow with commands for creating diffs and submitting PRs (includes gt-create, gt-submit, gt-create-submit aliases)",
            "source": "./plugins/graphite",
            "category": null,
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add DataflightSolutions/claude-plugins",
              "/plugin install graphite@dataflight-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-01T14:39:08Z",
              "created_at": "2025-11-28T13:18:50Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/create-submit",
                "description": "Create a Graphite stacked diff and submit as PR in one step",
                "path": "plugins/graphite/commands/create-submit.md",
                "frontmatter": {
                  "description": "Create a Graphite stacked diff and submit as PR in one step",
                  "allowed-tools": "Bash(gt:*), Bash(git:*)"
                },
                "content": "# Create Diff and Submit PR\n\nCreate a stacked diff from current changes and immediately submit it as a pull request. This combines `/graphite:create` and `/graphite:submit` into a single workflow.\n\n## When to Use This Command\n\nUse this command when:\n- You have a complete, self-contained change ready for review\n- You want to create and submit a PR in one step\n- The change represents a single logical unit of work\n\nFor iterative work where you want to create multiple diffs before submitting, use `/graphite:create` instead.\n\n## Stacked Diff Philosophy\n\nEach diff should represent exactly one logical change. Before creating the diff, consider:\n- Is this a single, atomic change?\n- Could this be reviewed independently?\n- Does it have a clear, focused purpose?\n\nIf the changes span multiple unrelated concerns, consider splitting them into separate diffs.\n\n## Execution Steps\n\nExecute these steps in order. Stop and report errors if any step fails.\n\n### Step 1: Validate Environment\n\n```bash\ngit rev-parse --is-inside-work-tree\n```\n\nIf this fails, tell the user: \"Not in a git repository. Navigate to a git repo first.\"\n\n```bash\ngt --version\n```\n\nIf this fails, tell the user: \"Graphite CLI not found. Install with: npm install -g @withgraphite/graphite-cli@latest\"\n\n### Step 2: Check for Changes\n\n```bash\ngit status --short\n```\n\nIf output is empty, tell the user: \"No changes to commit.\" and stop.\n\n```bash\ngit diff --stat\n```\n\nNote the files changed count and line changes for the summary.\n\n### Step 3: Analyze Changes for Commit Message\n\n```bash\ngit diff\ngit diff --staged\ngit log -5 --oneline\n```\n\n### Step 4: Generate Commit Message\n\nWrite a commit message following these rules:\n\n**Subject line:**\n- Format: `type(scope): description`\n- Types: feat, fix, refactor, docs, test, chore, perf, style, build, ci\n- Keep under 72 characters\n- Use imperative mood\n- No period at the end\n\n**Body (if needed):**\n- Explain what and why\n- Wrap at 72 characters\n\n**Footer (required):**\n```\nCo-Authored-By: Claude Code\n```\n\n### Step 5: Create the Diff\n\n```bash\ngt create --all -m \"<commit_message>\"\n```\n\nIf this fails, show the error and stop. Do not proceed to submit.\n\n### Step 6: Submit the PR\n\n```bash\ngt submit\n```\n\nThis pushes the branch and creates the pull request.\n\n### Step 7: Report Results\n\nAfter successful completion, report:\n- The commit message\n- Number of files changed and lines modified\n- The branch name\n- The PR URL\n\nExample output format:\n```\nDiff created and PR submitted.\n\nBranch: feature/auth-token-handling\nCommit: fix(auth): handle expired JWT tokens gracefully\nChanges: 3 files, +45 -12\n\nPR URL: https://github.com/user/repo/pull/123\n```\n\n## Error Handling\n\n**If gt create fails:**\n- Show the exact error\n- Do not proceed to gt submit\n- Common causes: not on valid base branch, conflicts\n\n**If gt submit fails:**\n- The diff was created but not submitted\n- Show the error\n- User can retry with `/graphite:submit`\n- Common causes: auth issues, network problems\n\n## Notes\n\n- This is a convenience command combining two operations\n- If you need to review the diff before submitting, use `/graphite:create` then `/graphite:submit` separately\n- The PR title and description are derived from the commit message"
              },
              {
                "name": "/create",
                "description": "Create a new Graphite stacked diff from current changes",
                "path": "plugins/graphite/commands/create.md",
                "frontmatter": {
                  "description": "Create a new Graphite stacked diff from current changes",
                  "allowed-tools": "Bash(gt:*), Bash(git:*)"
                },
                "content": "# Create Graphite Stacked Diff\n\nCreate a stacked diff (commit + branch) from current changes using the Graphite CLI.\n\n## Stacked Diff Philosophy\n\nEach diff in a stack should represent exactly one logical change. This makes code review easier and allows changes to land independently. When generating commit messages, think about what single thing this diff accomplishes.\n\nGood examples of atomic changes:\n- Add a new function or component\n- Fix a specific bug\n- Refactor a single module\n- Update configuration for one purpose\n\nAvoid combining unrelated changes in a single diff.\n\n## Execution Steps\n\nExecute these steps in order. Stop and report errors if any step fails.\n\n### Step 1: Validate Environment\n\nRun both commands to verify the environment is ready:\n\n```bash\ngit rev-parse --is-inside-work-tree\n```\n\nIf this fails, tell the user: \"Not in a git repository. Navigate to a git repo first.\"\n\n```bash\ngt --version\n```\n\nIf this fails, tell the user: \"Graphite CLI not found. Install with: npm install -g @withgraphite/graphite-cli@latest\"\n\n### Step 2: Check for Changes\n\n```bash\ngit status --short\n```\n\nIf output is empty, tell the user: \"No changes to commit.\" and stop.\n\n```bash\ngit diff --stat\n```\n\nNote the files changed count and line changes for the summary.\n\n### Step 3: Analyze Changes for Commit Message\n\nRun these commands to understand what changed:\n\n```bash\ngit diff\ngit diff --staged\n```\n\nAlso check recent commit style:\n\n```bash\ngit log -5 --oneline\n```\n\n### Step 4: Generate Commit Message\n\nBased on the diff analysis, write a commit message following these rules:\n\n**Subject line (first line):**\n- Use conventional commit format: `type(scope): description`\n- Types: feat, fix, refactor, docs, test, chore, perf, style, build, ci\n- Scope is optional but helpful (module name, component, file area)\n- Keep under 72 characters\n- Use imperative mood (\"add feature\" not \"added feature\")\n- No period at the end\n\n**Body (optional, separated by blank line):**\n- Explain what and why, not how (the diff shows how)\n- Wrap at 72 characters\n- Only include if the subject line needs clarification\n\n**Footer (required):**\n```\nCo-Authored-By: Claude Code\n```\n\n**Example commit message:**\n```\nfix(auth): handle expired JWT tokens gracefully\n\nReturn 401 with clear error message instead of 500 when token\nvalidation fails due to expiration.\n\nCo-Authored-By: Claude Code\n```\n\n### Step 5: Create the Diff\n\nRun the gt create command with the generated message:\n\n```bash\ngt create --all -m \"<commit_message>\"\n```\n\nThe `--all` flag stages all changes automatically. Pass the full commit message including the footer.\n\n### Step 6: Report Results\n\nAfter successful creation, report to the user:\n- The commit message that was used\n- Number of files changed\n- Lines added/removed\n- The branch name created by gt\n\nExample output format:\n```\nDiff created on branch: feature/auth-token-handling\n\nCommit: fix(auth): handle expired JWT tokens gracefully\n\nChanges: 3 files, +45 -12\n```\n\n## Error Handling\n\nIf `gt create` fails:\n- Show the exact error output from gt\n- Common issues: not on a valid base branch, merge conflicts, gt not initialized\n- Suggest running `gt init` if the repo hasn't been set up with Graphite\n\n## Important Notes\n\n- Each invocation creates one diff in the stack\n- The branch name is auto-generated by gt based on the commit message\n- Use `/graphite:submit` (or `/gt:submit`) when ready to open a PR for this diff\n- Multiple diffs can be stacked by running this command multiple times"
              },
              {
                "name": "/gt-create-submit",
                "description": "Create a Graphite stacked diff and submit as PR in one step (alias for /graphite:create-submit)",
                "path": "plugins/graphite/commands/gt-create-submit.md",
                "frontmatter": {
                  "description": "Create a Graphite stacked diff and submit as PR in one step (alias for /graphite:create-submit)",
                  "allowed-tools": "Bash(gt:*), Bash(git:*), Bash(gh:*)"
                },
                "content": "Execute the `/graphite:create-submit` command. This is an alias for convenience."
              },
              {
                "name": "/gt-create",
                "description": "Create a new Graphite stacked diff from current changes (alias for /graphite:create)",
                "path": "plugins/graphite/commands/gt-create.md",
                "frontmatter": {
                  "description": "Create a new Graphite stacked diff from current changes (alias for /graphite:create)",
                  "allowed-tools": "Bash(gt:*), Bash(git:*)"
                },
                "content": "Execute the `/graphite:create` command. This is an alias for convenience."
              },
              {
                "name": "/gt-submit",
                "description": "Submit the current branch as a Graphite PR (alias for /graphite:submit)",
                "path": "plugins/graphite/commands/gt-submit.md",
                "frontmatter": {
                  "description": "Submit the current branch as a Graphite PR (alias for /graphite:submit)",
                  "allowed-tools": "Bash(gt:*), Bash(git:*), Bash(gh:*)"
                },
                "content": "Execute the `/graphite:submit` command. This is an alias for convenience."
              },
              {
                "name": "/submit",
                "description": "Submit the current branch as a Graphite PR",
                "path": "plugins/graphite/commands/submit.md",
                "frontmatter": {
                  "description": "Submit the current branch as a Graphite PR",
                  "allowed-tools": "Bash(gt:*), Bash(git:*)"
                },
                "content": "# Submit Current Branch as PR\n\nSubmit the current stacked diff branch as a pull request using the Graphite CLI.\n\n## What This Command Does\n\nThis command runs `gt submit` which:\n- Creates or updates a pull request for the current branch\n- Sets up the PR with the correct base branch (the parent in the stack)\n- Links the PR to the Graphite stack for easy navigation\n\n## Execution Steps\n\nExecute these steps in order. Stop and report errors if any step fails.\n\n### Step 1: Validate Environment\n\n```bash\ngit rev-parse --is-inside-work-tree\n```\n\nIf this fails, tell the user: \"Not in a git repository. Navigate to a git repo first.\"\n\n```bash\ngt --version\n```\n\nIf this fails, tell the user: \"Graphite CLI not found. Install with: npm install -g @withgraphite/graphite-cli@latest\"\n\n### Step 2: Check Current Branch\n\n```bash\ngit branch --show-current\n```\n\nIf the branch is `main` or `master`, warn the user: \"You are on the trunk branch. PRs are typically submitted from feature branches created with gt create.\"\n\n### Step 3: Submit the PR\n\n```bash\ngt submit\n```\n\nThis command will:\n- Push the branch to the remote\n- Create a pull request (or update existing one)\n- Output the PR URL\n\n### Step 4: Report Results\n\nAfter successful submission, report:\n- The branch name that was submitted\n- The PR URL from the gt output\n- Confirmation that the PR is ready for review\n\nExample output format:\n```\nPR submitted for branch: feature/auth-token-handling\n\nPR URL: https://github.com/user/repo/pull/123\n\nThe pull request is now open and ready for review.\n```\n\n## Error Handling\n\nIf `gt submit` fails:\n- Show the exact error output from gt\n- Common issues:\n  - Not authenticated with GitHub (run `gt auth`)\n  - Branch not tracked by Graphite (use `gt create` first)\n  - Remote push rejected (may need to pull or rebase)\n\n## Notes\n\n- This submits only the current branch, not the entire stack\n- To submit all branches in a stack, the user should run `gt submit --stack` manually\n- The PR description and title come from the commit message\n- Subsequent runs of `gt submit` on the same branch update the existing PR"
              }
            ],
            "skills": []
          },
          {
            "name": "playwright",
            "description": "Browser automation with Playwright. Auto-invoked skill for custom automation plus quick commands for screenshots, link checking, and responsive testing.",
            "source": "./plugins/playwright",
            "category": null,
            "version": "1.0.0",
            "author": null,
            "install_commands": [
              "/plugin marketplace add DataflightSolutions/claude-plugins",
              "/plugin install playwright@dataflight-claude-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2025-12-01T14:39:08Z",
              "created_at": "2025-11-28T13:18:50Z",
              "license": "MIT"
            },
            "commands": [
              {
                "name": "/check-links",
                "description": "Check for broken links on a webpage",
                "path": "plugins/playwright/commands/check-links.md",
                "frontmatter": {
                  "description": "Check for broken links on a webpage",
                  "allowed-tools": "Bash(node:*), Bash(npm:*)"
                },
                "content": "# Check Links Command\n\nScan a webpage for broken links. Tests all anchor tags with HTTP/HTTPS hrefs and reports working vs broken links.\n\n## Execution Steps\n\nExecute these steps in order. Stop and report errors if any step fails.\n\n### Step 1: Determine Target URL\n\nIf user provided a URL argument, use it directly.\n\nIf no URL provided, detect running dev servers:\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node -e \"require('./lib/helpers').detectDevServers().then(s => console.log(JSON.stringify(s)))\"\n```\n\n**Decision tree:**\n- **1 server found**: Use it automatically\n- **Multiple servers found**: Ask user which one to check\n- **No servers found**: Ask user for URL\n\n### Step 2: Generate Link Check Script\n\nWrite a script to `/tmp/playwright-check-links.js`:\n\n```javascript\nconst { chromium } = require('playwright');\n\nconst TARGET_URL = '<detected-or-provided-url>';\n\n(async () => {\n  console.log('Checking links on:', TARGET_URL);\n  console.log('');\n\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  try {\n    await page.goto(TARGET_URL, { waitUntil: 'networkidle', timeout: 30000 });\n    console.log('Page loaded:', await page.title());\n    console.log('');\n\n    // Get all links\n    const links = await page.locator('a[href]').all();\n    console.log(`Found ${links.length} links to check`);\n    console.log('');\n\n    const results = {\n      working: [],\n      broken: [],\n      skipped: []\n    };\n\n    for (const link of links) {\n      const href = await link.getAttribute('href');\n      const text = (await link.textContent())?.trim().slice(0, 50) || '[no text]';\n\n      // Skip non-HTTP links\n      if (!href || !href.startsWith('http')) {\n        results.skipped.push({ href, text, reason: 'not HTTP' });\n        continue;\n      }\n\n      try {\n        const response = await page.request.head(href, { timeout: 10000 });\n        const status = response.status();\n\n        if (response.ok()) {\n          results.working.push({ href, text, status });\n          console.log(`OK [${status}]: ${href}`);\n        } else {\n          results.broken.push({ href, text, status });\n          console.log(`BROKEN [${status}]: ${href}`);\n        }\n      } catch (e) {\n        results.broken.push({ href, text, error: e.message });\n        console.log(`ERROR: ${href} - ${e.message}`);\n      }\n    }\n\n    // Summary\n    console.log('');\n    console.log('=== SUMMARY ===');\n    console.log(`Working links: ${results.working.length}`);\n    console.log(`Broken links: ${results.broken.length}`);\n    console.log(`Skipped (non-HTTP): ${results.skipped.length}`);\n\n    if (results.broken.length > 0) {\n      console.log('');\n      console.log('=== BROKEN LINKS ===');\n      results.broken.forEach(link => {\n        console.log(`  ${link.href}`);\n        console.log(`    Status: ${link.status || link.error}`);\n        console.log(`    Text: ${link.text}`);\n      });\n    }\n\n  } catch (error) {\n    console.error('Link check failed:', error.message);\n    process.exit(1);\n  } finally {\n    await browser.close();\n  }\n})();\n```\n\nReplace `<detected-or-provided-url>` with the actual URL.\n\n### Step 3: Execute Link Check Script\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node run.js /tmp/playwright-check-links.js\n```\n\n### Step 4: Report Results\n\nAfter execution, provide a summary:\n- Total links found\n- Number of working links\n- Number of broken links (with details)\n- Number of skipped links (non-HTTP like mailto:, tel:, etc.)\n\nExample output:\n```\nLink Check Complete for: http://localhost:3847\n\nResults:\n- Working: 15 links\n- Broken: 2 links\n- Skipped: 3 links (non-HTTP)\n\nBroken Links:\n1. https://example.com/old-page\n   Status: 404\n   Link text: \"Old Documentation\"\n\n2. https://api.service.com/health\n   Error: Connection refused\n   Link text: \"API Status\"\n```\n\n## Error Handling\n\nIf the script fails:\n- Show the error message\n- Common issues:\n  - Page not accessible: Check if URL is correct\n  - Timeout: Some external links may be slow\n  - Too many links: Script may take a while on large pages\n\n## Options\n\nUser can optionally specify:\n- **URL**: Direct URL to check\n- **internal**: Only check internal links (same domain)\n- **external**: Only check external links\n\n## Notes\n\n- Uses HEAD requests for efficiency (doesn't download full page)\n- External links may timeout due to network issues\n- Some sites block HEAD requests, may show false positives\n- Links with `#` anchors are checked against base URL\n- mailto:, tel:, and javascript: links are skipped"
              },
              {
                "name": "/screenshot",
                "description": "Take a screenshot of a webpage",
                "path": "plugins/playwright/commands/screenshot.md",
                "frontmatter": {
                  "description": "Take a screenshot of a webpage",
                  "allowed-tools": "Bash(node:*), Write"
                },
                "content": "# Screenshot Command\n\nTake a full-page screenshot of a webpage. Automatically detects running dev servers or uses a provided URL.\n\n## Execution Steps\n\n### Step 1: Determine Target URL\n\nIf user provided a URL argument, use it directly.\n\nIf no URL provided, detect running dev servers:\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node -e \"require('./lib/helpers').detectDevServers().then(s => console.log(JSON.stringify(s)))\"\n```\n\n**Decision tree:**\n- **1 server found**: Use it automatically, inform user which port\n- **Multiple servers found**: Ask user which one to screenshot\n- **No servers found**: Ask user for URL\n\n### Step 2: Write Screenshot Script\n\nWrite a script to `/tmp/playwright-screenshot.js` with the target URL:\n\n```javascript\nconst { chromium } = require('playwright');\n\n(async () => {\n  console.log('Taking screenshot of: TARGET_URL');\n\n  const browser = await chromium.launch({ headless: false, slowMo: 50 });\n  const page = await browser.newPage();\n\n  try {\n    await page.goto('TARGET_URL', { waitUntil: 'networkidle', timeout: 30000 });\n    console.log('Page loaded:', await page.title());\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const filename = `/tmp/screenshot-${timestamp}.png`;\n\n    await page.screenshot({ path: filename, fullPage: true });\n    console.log('Screenshot saved:', filename);\n  } catch (error) {\n    console.error('Screenshot failed:', error.message);\n    process.exit(1);\n  } finally {\n    await browser.close();\n  }\n})();\n```\n\nReplace `TARGET_URL` with the actual URL.\n\n### Step 3: Execute Script\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node run.js /tmp/playwright-screenshot.js\n```\n\n### Step 4: Display Screenshot\n\nAfter successful execution, use the Read tool to display the screenshot image to the user.\n\n### Step 5: Report Result\n\nTell the user:\n- Which URL was captured\n- The path to the saved screenshot\n\n## Error Handling\n\n- If navigation fails, check if the server is running\n- If Playwright is not installed, run `npm run setup` in the plugin directory"
              },
              {
                "name": "/test-page",
                "description": "Basic page health check - verify page loads without errors",
                "path": "plugins/playwright/commands/test-page.md",
                "frontmatter": {
                  "description": "Basic page health check - verify page loads without errors",
                  "allowed-tools": "Bash(node:*), Bash(npm:*)"
                },
                "content": "# Test Page Command\n\nPerform a basic health check on a webpage. Verifies the page loads successfully, checks for JavaScript errors, and captures a verification screenshot.\n\n## Execution Steps\n\nExecute these steps in order. Stop and report errors if any step fails.\n\n### Step 1: Determine Target URL\n\nIf user provided a URL argument, use it directly.\n\nIf no URL provided, detect running dev servers:\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node -e \"require('./lib/helpers').detectDevServers().then(s => console.log(JSON.stringify(s)))\"\n```\n\n**Decision tree:**\n- **1 server found**: Use it automatically\n- **Multiple servers found**: Ask user which one to test\n- **No servers found**: Ask user for URL\n\n### Step 2: Generate Test Script\n\nWrite a script to `/tmp/playwright-test-page.js`:\n\n```javascript\nconst { chromium } = require('playwright');\n\nconst TARGET_URL = '<detected-or-provided-url>';\n\n(async () => {\n  console.log('Testing page:', TARGET_URL);\n  console.log('');\n\n  const browser = await chromium.launch({ headless: false, slowMo: 50 });\n  const page = await browser.newPage();\n\n  const results = {\n    url: TARGET_URL,\n    passed: true,\n    checks: [],\n    consoleErrors: [],\n    pageErrors: []\n  };\n\n  // Capture console errors\n  page.on('console', msg => {\n    if (msg.type() === 'error') {\n      results.consoleErrors.push(msg.text());\n    }\n  });\n\n  // Capture page errors (uncaught exceptions)\n  page.on('pageerror', error => {\n    results.pageErrors.push(error.message);\n  });\n\n  try {\n    // Check 1: Page loads successfully\n    console.log('Check 1: Page loads...');\n    const response = await page.goto(TARGET_URL, {\n      waitUntil: 'networkidle',\n      timeout: 30000\n    });\n\n    const status = response?.status() || 0;\n    if (status >= 200 && status < 400) {\n      results.checks.push({ name: 'Page loads', passed: true, detail: `Status: ${status}` });\n      console.log(`  PASS - Status: ${status}`);\n    } else {\n      results.checks.push({ name: 'Page loads', passed: false, detail: `Status: ${status}` });\n      results.passed = false;\n      console.log(`  FAIL - Status: ${status}`);\n    }\n\n    // Check 2: Page has title\n    console.log('Check 2: Page has title...');\n    const title = await page.title();\n    if (title && title.length > 0) {\n      results.checks.push({ name: 'Has title', passed: true, detail: title });\n      console.log(`  PASS - Title: \"${title}\"`);\n    } else {\n      results.checks.push({ name: 'Has title', passed: false, detail: 'No title found' });\n      results.passed = false;\n      console.log('  FAIL - No title found');\n    }\n\n    // Check 3: Page has content\n    console.log('Check 3: Page has content...');\n    const bodyText = await page.locator('body').textContent();\n    const hasContent = bodyText && bodyText.trim().length > 0;\n    if (hasContent) {\n      results.checks.push({ name: 'Has content', passed: true, detail: `${bodyText.trim().length} characters` });\n      console.log(`  PASS - ${bodyText.trim().length} characters`);\n    } else {\n      results.checks.push({ name: 'Has content', passed: false, detail: 'Empty page' });\n      results.passed = false;\n      console.log('  FAIL - Empty page');\n    }\n\n    // Wait a moment for any delayed errors\n    await page.waitForTimeout(2000);\n\n    // Check 4: No console errors\n    console.log('Check 4: No console errors...');\n    if (results.consoleErrors.length === 0) {\n      results.checks.push({ name: 'No console errors', passed: true });\n      console.log('  PASS - No console errors');\n    } else {\n      results.checks.push({ name: 'No console errors', passed: false, detail: results.consoleErrors });\n      results.passed = false;\n      console.log(`  FAIL - ${results.consoleErrors.length} console error(s)`);\n      results.consoleErrors.forEach(err => console.log(`    - ${err.slice(0, 100)}`));\n    }\n\n    // Check 5: No page errors\n    console.log('Check 5: No uncaught exceptions...');\n    if (results.pageErrors.length === 0) {\n      results.checks.push({ name: 'No page errors', passed: true });\n      console.log('  PASS - No uncaught exceptions');\n    } else {\n      results.checks.push({ name: 'No page errors', passed: false, detail: results.pageErrors });\n      results.passed = false;\n      console.log(`  FAIL - ${results.pageErrors.length} uncaught exception(s)`);\n      results.pageErrors.forEach(err => console.log(`    - ${err.slice(0, 100)}`));\n    }\n\n    // Take verification screenshot\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const screenshotPath = `/tmp/test-page-${timestamp}.png`;\n    await page.screenshot({ path: screenshotPath, fullPage: true });\n    console.log('');\n    console.log(`Screenshot saved: ${screenshotPath}`);\n\n    // Final summary\n    console.log('');\n    console.log('=== TEST SUMMARY ===');\n    const passedCount = results.checks.filter(c => c.passed).length;\n    console.log(`Checks passed: ${passedCount}/${results.checks.length}`);\n    console.log(`Overall: ${results.passed ? 'PASS' : 'FAIL'}`);\n\n  } catch (error) {\n    results.passed = false;\n    results.checks.push({ name: 'Page loads', passed: false, detail: error.message });\n    console.error('Test failed:', error.message);\n  } finally {\n    await browser.close();\n  }\n\n  process.exit(results.passed ? 0 : 1);\n})();\n```\n\nReplace `<detected-or-provided-url>` with the actual URL.\n\n### Step 3: Execute Test Script\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node run.js /tmp/playwright-test-page.js\n```\n\n### Step 4: Report Results\n\nProvide a clear summary:\n- Overall pass/fail status\n- Individual check results\n- Any errors encountered\n- Screenshot location\n\nExample output:\n```\nPage Test Complete: http://localhost:3847\n\nOverall: PASS\n\nChecks:\n1. Page loads: PASS (Status: 200)\n2. Has title: PASS (\"My App - Home\")\n3. Has content: PASS (1,234 characters)\n4. No console errors: PASS\n5. No uncaught exceptions: PASS\n\nScreenshot: /tmp/test-page-2024-01-15T10-30-45-123Z.png\n```\n\n## What Gets Tested\n\n1. **Page loads** - HTTP status code is 2xx or 3xx\n2. **Has title** - Page has a non-empty title tag\n3. **Has content** - Page body has text content\n4. **No console errors** - No console.error() calls\n5. **No page errors** - No uncaught JavaScript exceptions\n\n## Error Handling\n\nIf the test fails:\n- Report which specific checks failed\n- Show error details\n- Screenshot still captured for debugging\n\n## Notes\n\n- This is a basic health check, not comprehensive testing\n- Console warnings are not counted as errors\n- Network errors during page load will fail the test\n- Browser opens visibly for observation"
              },
              {
                "name": "/test-responsive",
                "description": "Test page across multiple viewports (desktop, tablet, mobile)",
                "path": "plugins/playwright/commands/test-responsive.md",
                "frontmatter": {
                  "description": "Test page across multiple viewports (desktop, tablet, mobile)",
                  "allowed-tools": "Bash(node:*), Bash(npm:*)"
                },
                "content": "# Test Responsive Command\n\nTest a webpage across multiple viewport sizes to verify responsive design. Captures screenshots at desktop, tablet, and mobile breakpoints.\n\n## Execution Steps\n\nExecute these steps in order. Stop and report errors if any step fails.\n\n### Step 1: Determine Target URL\n\nIf user provided a URL argument, use it directly.\n\nIf no URL provided, detect running dev servers:\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node -e \"require('./lib/helpers').detectDevServers().then(s => console.log(JSON.stringify(s)))\"\n```\n\n**Decision tree:**\n- **1 server found**: Use it automatically\n- **Multiple servers found**: Ask user which one to test\n- **No servers found**: Ask user for URL\n\n### Step 2: Generate Responsive Test Script\n\nWrite a script to `/tmp/playwright-test-responsive.js`:\n\n```javascript\nconst { chromium } = require('playwright');\n\nconst TARGET_URL = '<detected-or-provided-url>';\n\nconst VIEWPORTS = [\n  { name: 'Desktop', width: 1920, height: 1080 },\n  { name: 'Laptop', width: 1366, height: 768 },\n  { name: 'Tablet', width: 768, height: 1024 },\n  { name: 'Mobile', width: 375, height: 667 }\n];\n\n(async () => {\n  console.log('Testing responsive design:', TARGET_URL);\n  console.log('');\n\n  const browser = await chromium.launch({ headless: false, slowMo: 100 });\n  const page = await browser.newPage();\n\n  const results = [];\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n\n  try {\n    for (const viewport of VIEWPORTS) {\n      console.log(`Testing ${viewport.name} (${viewport.width}x${viewport.height})...`);\n\n      // Set viewport\n      await page.setViewportSize({\n        width: viewport.width,\n        height: viewport.height\n      });\n\n      // Navigate (or reload if already loaded)\n      await page.goto(TARGET_URL, { waitUntil: 'networkidle', timeout: 30000 });\n\n      // Wait for any responsive adjustments\n      await page.waitForTimeout(500);\n\n      // Check for common responsive issues\n      const checks = await page.evaluate(() => {\n        const body = document.body;\n        const html = document.documentElement;\n\n        // Check horizontal overflow\n        const hasHorizontalScroll = body.scrollWidth > window.innerWidth;\n\n        // Check if content is cut off\n        const viewportWidth = window.innerWidth;\n        const allElements = document.querySelectorAll('*');\n        let overflowingElements = 0;\n        allElements.forEach(el => {\n          const rect = el.getBoundingClientRect();\n          if (rect.right > viewportWidth + 10) {\n            overflowingElements++;\n          }\n        });\n\n        // Check font readability (very small text)\n        let smallTextElements = 0;\n        allElements.forEach(el => {\n          const style = window.getComputedStyle(el);\n          const fontSize = parseFloat(style.fontSize);\n          if (fontSize > 0 && fontSize < 12 && el.textContent?.trim()) {\n            smallTextElements++;\n          }\n        });\n\n        // Check touch targets (buttons/links too small on mobile)\n        let smallTouchTargets = 0;\n        document.querySelectorAll('a, button, input, select').forEach(el => {\n          const rect = el.getBoundingClientRect();\n          if (rect.width > 0 && rect.height > 0) {\n            if (rect.width < 44 || rect.height < 44) {\n              smallTouchTargets++;\n            }\n          }\n        });\n\n        return {\n          hasHorizontalScroll,\n          overflowingElements,\n          smallTextElements,\n          smallTouchTargets\n        };\n      });\n\n      // Take screenshot\n      const screenshotName = viewport.name.toLowerCase().replace(/\\s+/g, '-');\n      const screenshotPath = `/tmp/responsive-${screenshotName}-${timestamp}.png`;\n      await page.screenshot({ path: screenshotPath, fullPage: true });\n\n      const result = {\n        viewport: viewport.name,\n        dimensions: `${viewport.width}x${viewport.height}`,\n        screenshot: screenshotPath,\n        issues: []\n      };\n\n      // Report issues\n      if (checks.hasHorizontalScroll) {\n        result.issues.push('Horizontal scrollbar detected');\n      }\n      if (checks.overflowingElements > 0) {\n        result.issues.push(`${checks.overflowingElements} elements overflow viewport`);\n      }\n      if (checks.smallTextElements > 5) {\n        result.issues.push(`${checks.smallTextElements} elements have very small text (<12px)`);\n      }\n      if (viewport.name === 'Mobile' && checks.smallTouchTargets > 3) {\n        result.issues.push(`${checks.smallTouchTargets} touch targets are too small (<44px)`);\n      }\n\n      results.push(result);\n\n      if (result.issues.length === 0) {\n        console.log(`  PASS - No issues detected`);\n      } else {\n        console.log(`  WARN - ${result.issues.length} issue(s):`);\n        result.issues.forEach(issue => console.log(`    - ${issue}`));\n      }\n      console.log(`  Screenshot: ${screenshotPath}`);\n      console.log('');\n    }\n\n    // Final summary\n    console.log('=== RESPONSIVE TEST SUMMARY ===');\n    console.log('');\n\n    let totalIssues = 0;\n    results.forEach(r => {\n      totalIssues += r.issues.length;\n      const status = r.issues.length === 0 ? 'PASS' : 'WARN';\n      console.log(`${r.viewport} (${r.dimensions}): ${status}`);\n      if (r.issues.length > 0) {\n        r.issues.forEach(i => console.log(`  - ${i}`));\n      }\n    });\n\n    console.log('');\n    console.log(`Total viewports tested: ${VIEWPORTS.length}`);\n    console.log(`Total issues found: ${totalIssues}`);\n    console.log('');\n    console.log('Screenshots saved to /tmp/responsive-*');\n\n  } catch (error) {\n    console.error('Responsive test failed:', error.message);\n    process.exit(1);\n  } finally {\n    await browser.close();\n  }\n})();\n```\n\nReplace `<detected-or-provided-url>` with the actual URL.\n\n### Step 3: Execute Responsive Test Script\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node run.js /tmp/playwright-test-responsive.js\n```\n\n### Step 4: Report Results\n\nProvide a comprehensive summary:\n- Results for each viewport\n- Any responsive issues detected\n- Screenshot paths\n\nExample output:\n```\nResponsive Test Complete: http://localhost:3847\n\nResults by Viewport:\n\nDesktop (1920x1080): PASS\n  Screenshot: /tmp/responsive-desktop-2024-01-15T10-30-45Z.png\n\nLaptop (1366x768): PASS\n  Screenshot: /tmp/responsive-laptop-2024-01-15T10-30-45Z.png\n\nTablet (768x1024): PASS\n  Screenshot: /tmp/responsive-tablet-2024-01-15T10-30-45Z.png\n\nMobile (375x667): WARN\n  - 5 touch targets are too small (<44px)\n  Screenshot: /tmp/responsive-mobile-2024-01-15T10-30-45Z.png\n\nSummary: 4 viewports tested, 1 issue found\n```\n\n## Viewport Sizes Tested\n\n| Name    | Width  | Height | Use Case                    |\n|---------|--------|--------|-----------------------------|\n| Desktop | 1920px | 1080px | Full HD monitors            |\n| Laptop  | 1366px | 768px  | Common laptop resolution    |\n| Tablet  | 768px  | 1024px | iPad portrait               |\n| Mobile  | 375px  | 667px  | iPhone 8/SE                 |\n\n## Issues Detected\n\n1. **Horizontal scrollbar** - Content wider than viewport\n2. **Overflowing elements** - Elements extend past viewport edge\n3. **Small text** - Text smaller than 12px (hard to read)\n4. **Small touch targets** - Buttons/links smaller than 44px (hard to tap on mobile)\n\n## Error Handling\n\nIf the test fails:\n- Report which viewport failed\n- Show error details\n- Previous screenshots still saved\n\n## Notes\n\n- Screenshots are full-page captures\n- Issues are warnings, not failures\n- Some issues may be intentional (e.g., data tables with horizontal scroll)\n- Touch target check only applies to mobile viewport"
              }
            ],
            "skills": [
              {
                "name": "Playwright Browser Automation",
                "description": "Complete browser automation with Playwright. Auto-detects dev servers, writes clean test scripts to /tmp. Test pages, fill forms, take screenshots, check responsive design, validate UX, test login flows, check links, automate any browser task. Use when user wants to test websites, automate browser interactions, validate web functionality, or perform any browser-based testing.",
                "path": "plugins/playwright/skills/playwright/SKILL.md",
                "frontmatter": {
                  "name": "Playwright Browser Automation",
                  "description": "Complete browser automation with Playwright. Auto-detects dev servers, writes clean test scripts to /tmp. Test pages, fill forms, take screenshots, check responsive design, validate UX, test login flows, check links, automate any browser task. Use when user wants to test websites, automate browser interactions, validate web functionality, or perform any browser-based testing.",
                  "version": "1.0.0",
                  "author": "DataFlight",
                  "tags": [
                    "testing",
                    "automation",
                    "browser",
                    "e2e",
                    "playwright",
                    "web-testing"
                  ]
                },
                "content": "# Playwright Browser Automation\n\nGeneral-purpose browser automation skill. I write custom Playwright code for any automation task and execute it via the universal executor.\n\n## Quick Commands Available\n\nFor common tasks, these slash commands are faster:\n- `/screenshot` - Take a quick screenshot of a webpage\n- `/check-links` - Find broken links on a page\n- `/test-page` - Basic page health check\n- `/test-responsive` - Test across multiple viewports\n\nFor custom automation beyond these common tasks, I write specialized Playwright code.\n\n## Critical Workflow\n\n**IMPORTANT - Path Resolution:**\nUse `${CLAUDE_PLUGIN_ROOT}` for all paths. This resolves to the plugin installation directory.\n\n### Step 1: Auto-Detect Dev Servers (ALWAYS FIRST for localhost)\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node -e \"require('./lib/helpers').detectDevServers().then(servers => console.log(JSON.stringify(servers, null, 2)))\"\n```\n\n**Decision tree:**\n- **1 server found**: Use it automatically, inform user\n- **Multiple servers found**: Ask user which one to test\n- **No servers found**: Ask for URL or offer to help start dev server\n\n### Step 2: Write Scripts to /tmp\n\nNEVER write test files to plugin directory. Always use `/tmp/playwright-test-*.js`\n\n**Script template:**\n```javascript\n// /tmp/playwright-test-{descriptive-name}.js\nconst { chromium } = require('playwright');\nconst helpers = require('./lib/helpers');\n\n// Parameterized URL (auto-detected or user-provided)\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false, slowMo: 100 });\n  const page = await browser.newPage();\n\n  try {\n    await page.goto(TARGET_URL, { waitUntil: 'networkidle' });\n    console.log('Page loaded:', await page.title());\n\n    // Test code here...\n\n    await page.screenshot({ path: '/tmp/screenshot.png', fullPage: true });\n    console.log('Screenshot saved to /tmp/screenshot.png');\n  } catch (error) {\n    console.error('Test failed:', error.message);\n    await page.screenshot({ path: '/tmp/error-screenshot.png' });\n  } finally {\n    await browser.close();\n  }\n})();\n```\n\n### Step 3: Execute from Plugin Directory\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node run.js /tmp/playwright-test-{name}.js\n```\n\n### Step 4: Default to Visible Browser\n\nALWAYS use `headless: false` unless user explicitly requests headless mode. This lets users see what's happening.\n\n## Setup (First Time)\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && npm run setup\n```\n\nInstalls Playwright and Chromium browser. Only needed once.\n\n## Common Patterns\n\n### Test a Page (Basic)\n\n```javascript\nconst { chromium } = require('playwright');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  await page.goto(TARGET_URL);\n  console.log('Title:', await page.title());\n  console.log('URL:', page.url());\n\n  await page.screenshot({ path: '/tmp/page.png', fullPage: true });\n  await browser.close();\n})();\n```\n\n### Test Responsive Design\n\n```javascript\nconst { chromium } = require('playwright');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  const viewports = [\n    { name: 'Desktop', width: 1920, height: 1080 },\n    { name: 'Tablet', width: 768, height: 1024 },\n    { name: 'Mobile', width: 375, height: 667 }\n  ];\n\n  for (const viewport of viewports) {\n    await page.setViewportSize({ width: viewport.width, height: viewport.height });\n    await page.goto(TARGET_URL);\n    await page.screenshot({ path: `/tmp/${viewport.name.toLowerCase()}.png`, fullPage: true });\n    console.log(`${viewport.name} screenshot saved`);\n  }\n\n  await browser.close();\n})();\n```\n\n### Test Login Flow\n\n```javascript\nconst { chromium } = require('playwright');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false, slowMo: 100 });\n  const page = await browser.newPage();\n\n  await page.goto(`${TARGET_URL}/login`);\n\n  await page.fill('input[name=\"email\"]', 'test@example.com');\n  await page.fill('input[name=\"password\"]', 'password123');\n  await page.click('button[type=\"submit\"]');\n\n  await page.waitForURL('**/dashboard');\n  console.log('Login successful, redirected to dashboard');\n\n  await browser.close();\n})();\n```\n\n### Fill and Submit Form\n\n```javascript\nconst { chromium } = require('playwright');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false, slowMo: 50 });\n  const page = await browser.newPage();\n\n  await page.goto(`${TARGET_URL}/contact`);\n\n  await page.fill('input[name=\"name\"]', 'John Doe');\n  await page.fill('input[name=\"email\"]', 'john@example.com');\n  await page.fill('textarea[name=\"message\"]', 'Test message');\n  await page.click('button[type=\"submit\"]');\n\n  await page.waitForSelector('.success-message');\n  console.log('Form submitted successfully');\n\n  await browser.close();\n})();\n```\n\n### Check for Broken Links\n\n```javascript\nconst { chromium } = require('playwright');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  await page.goto(TARGET_URL);\n\n  const links = await page.locator('a[href^=\"http\"]').all();\n  const results = { working: 0, broken: [] };\n\n  for (const link of links) {\n    const href = await link.getAttribute('href');\n    try {\n      const response = await page.request.head(href);\n      if (response.ok()) {\n        results.working++;\n      } else {\n        results.broken.push({ url: href, status: response.status() });\n      }\n    } catch (e) {\n      results.broken.push({ url: href, error: e.message });\n    }\n  }\n\n  console.log(`Working links: ${results.working}`);\n  console.log(`Broken links:`, results.broken);\n\n  await browser.close();\n})();\n```\n\n### Run Accessibility Audit\n\n```javascript\nconst { chromium } = require('playwright');\nconst helpers = require('./lib/helpers');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  await page.goto(TARGET_URL);\n\n  const results = await helpers.checkAccessibility(page);\n  console.log('Accessibility audit complete');\n  console.log(`Critical issues: ${results.summary.critical}`);\n  console.log(`Serious issues: ${results.summary.serious}`);\n\n  await browser.close();\n})();\n```\n\n### Measure Performance\n\n```javascript\nconst { chromium } = require('playwright');\nconst helpers = require('./lib/helpers');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  const metrics = await helpers.measurePageLoad(page, TARGET_URL);\n  console.log('Load time:', metrics.loadTime, 'ms');\n  console.log('TTFB:', metrics.metrics.ttfb, 'ms');\n  console.log('DOM Content Loaded:', metrics.metrics.domContentLoaded, 'ms');\n\n  const lcp = await helpers.measureLCP(page);\n  console.log('LCP:', lcp, 'ms');\n\n  await browser.close();\n})();\n```\n\n### Mock API Response\n\n```javascript\nconst { chromium } = require('playwright');\nconst helpers = require('./lib/helpers');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const page = await browser.newPage();\n\n  // Mock the API before navigating\n  await helpers.mockAPIResponse(page, '**/api/users', [\n    { id: 1, name: 'Mock User 1' },\n    { id: 2, name: 'Mock User 2' }\n  ]);\n\n  await page.goto(TARGET_URL);\n  // Page will receive mocked data\n\n  await browser.close();\n})();\n```\n\n### Test Mobile Device\n\n```javascript\nconst { chromium, devices } = require('playwright');\nconst TARGET_URL = 'http://localhost:3847';\n\n(async () => {\n  const browser = await chromium.launch({ headless: false });\n  const context = await browser.newContext({\n    ...devices['iPhone 12']\n  });\n  const page = await context.newPage();\n\n  await page.goto(TARGET_URL);\n  await page.screenshot({ path: '/tmp/iphone12.png' });\n\n  await browser.close();\n})();\n```\n\n## Available Helpers\n\nThe `lib/helpers.js` provides 42 utility functions:\n\n**Browser & Context:**\n- `launchBrowser(browserType?, options?)` - Launch browser with defaults\n- `createContext(browser, options?)` - Create context with viewport/locale\n- `createPage(context, options?)` - Create page with timeout\n- `saveStorageState(context, path)` - Save session for reuse\n- `loadStorageState(browser, path)` - Restore saved session\n- `detectDevServers(customPorts?)` - Scan for running dev servers\n\n**Navigation & Waiting:**\n- `waitForPageReady(page, options?)` - Smart page ready detection\n- `navigateWithRetry(page, url, options?)` - Navigate with automatic retry\n- `waitForSPA(page, options?)` - Wait for SPA route changes\n- `waitForElement(page, selector, options?)` - Wait for element state\n\n**Safe Interactions:**\n- `safeClick(page, selector, options?)` - Click with retry logic\n- `safeType(page, selector, text, options?)` - Type with clear option\n- `safeSelect(page, selector, value, options?)` - Safe dropdown selection\n- `safeCheck(page, selector, checked?, options?)` - Safe checkbox/radio\n- `scrollPage(page, direction, distance?)` - Scroll in any direction\n- `scrollToElement(page, selector, options?)` - Scroll element into view\n- `authenticate(page, credentials, selectors?)` - Handle login flow\n- `handleCookieBanner(page, timeout?)` - Dismiss cookie consent\n\n**Form Helpers:**\n- `getFormFields(page, formSelector?)` - Extract form field metadata\n- `getRequiredFields(page, formSelector?)` - Get required fields\n- `getFieldErrors(page, formSelector?)` - Get validation errors\n- `validateFieldState(page, selector)` - Check field validity\n- `fillFormFromData(page, formSelector, data, options?)` - Auto-fill form\n- `submitAndValidate(page, formSelector, options?)` - Submit and check errors\n\n**Accessibility:**\n- `checkAccessibility(page, options?)` - Run axe-core audit\n- `getARIAInfo(page, selector)` - Extract ARIA attributes\n- `checkFocusOrder(page, options?)` - Verify tab order\n- `getFocusableElements(page)` - List focusable elements\n\n**Performance:**\n- `measurePageLoad(page, url, options?)` - Comprehensive load metrics\n- `measureLCP(page)` - Largest Contentful Paint\n- `measureFCP(page)` - First Contentful Paint\n- `measureCLS(page)` - Cumulative Layout Shift\n\n**Network:**\n- `mockAPIResponse(page, urlPattern, response, options?)` - Mock API\n- `blockResources(page, resourceTypes)` - Block images/fonts/etc\n- `captureRequests(page, urlPattern?)` - Capture network requests\n- `captureResponses(page, urlPattern?)` - Capture responses\n- `waitForAPI(page, urlPattern, options?)` - Wait for API call\n\n**Visual:**\n- `takeScreenshot(page, name, options?)` - Timestamped screenshot\n- `compareScreenshots(baseline, current, options?)` - Visual diff\n- `takeElementScreenshot(page, selector, name, options?)` - Element screenshot\n\n**Mobile:**\n- `emulateDevice(browser, deviceName)` - Emulate iPhone/Pixel/etc\n- `setGeolocation(context, coords)` - Set GPS coordinates\n- `simulateTouchEvent(page, type, coords)` - Trigger touch events\n- `swipe(page, direction, distance?, options?)` - Swipe gesture\n\n**Multi-page:**\n- `handlePopup(page, triggerAction, options?)` - Handle popup windows\n- `handleNewTab(page, triggerAction, options?)` - Handle new tabs\n- `closeAllPopups(context)` - Close extra pages\n- `handleDialog(page, action, text?)` - Handle alert/confirm/prompt\n\n**Data Extraction:**\n- `extractTexts(page, selector)` - Get text from elements\n- `extractTableData(page, tableSelector)` - Parse table to JSON\n- `extractMetaTags(page)` - Get meta tag info\n- `extractOpenGraph(page)` - Get OG metadata\n- `extractJsonLD(page)` - Get structured data\n- `extractLinks(page, options?)` - Get all links\n\n**Console Monitoring:**\n- `captureConsoleLogs(page, options?)` - Capture console output\n- `capturePageErrors(page)` - Capture JS errors\n- `getConsoleErrors(consoleCapture)` - Get collected errors\n- `assertNoConsoleErrors(consoleCapture)` - Fail if errors exist\n\n**Files:**\n- `uploadFile(page, selector, filePath, options?)` - Upload file\n- `uploadMultipleFiles(page, selector, filePaths)` - Upload multiple\n- `downloadFile(page, triggerAction, options?)` - Download and save\n- `waitForDownload(page, triggerAction)` - Wait for download\n\n**Utilities:**\n- `retryWithBackoff(fn, maxRetries?, initialDelay?)` - Retry with backoff\n- `delay(ms)` - Promise-based delay\n\n## Inline Execution\n\nFor quick one-off tasks, execute code inline:\n\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && node run.js \"\nconst browser = await chromium.launch({ headless: false });\nconst page = await browser.newPage();\nawait page.goto('http://localhost:3847');\nconsole.log('Title:', await page.title());\nawait page.screenshot({ path: '/tmp/quick.png' });\nawait browser.close();\n\"\n```\n\n**When to use:**\n- **Inline**: Quick tasks (screenshot, check element, get title)\n- **Files**: Complex tests, responsive design, anything to re-run\n\n## Tips\n\n- **CRITICAL: Detect servers FIRST** - Always run `detectDevServers()` before localhost testing\n- **Use /tmp for scripts** - Write to `/tmp/playwright-test-*.js`, never plugin directory\n- **Parameterize URLs** - Put URL in `TARGET_URL` constant at top\n- **Visible browser default** - Always `headless: false` unless explicitly requested\n- **Slow down for debugging** - Use `slowMo: 100` to see actions\n- **Smart waits** - Use `waitForURL`, `waitForSelector` instead of timeouts\n- **Error handling** - Always use try-catch for robust automation\n\n## Troubleshooting\n\n**Playwright not installed:**\n```bash\ncd ${CLAUDE_PLUGIN_ROOT} && npm run setup\n```\n\n**Module not found:**\nRun from plugin directory via `run.js` wrapper\n\n**Browser doesn't open:**\nCheck `headless: false` and ensure display available\n\n**Element not found:**\nAdd wait: `await page.waitForSelector('.element', { timeout: 10000 })`\n\n## Advanced Usage\n\nFor comprehensive Playwright API documentation, see [API_REFERENCE.md](../../API_REFERENCE.md):\n\n- Selectors & Locators best practices\n- Network interception & API mocking\n- Authentication & session management\n- Visual regression testing\n- Mobile device emulation\n- Performance testing\n- CI/CD integration"
              }
            ]
          }
        ]
      }
    }
  ]
}