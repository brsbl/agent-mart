{
  "owner": {
    "id": "jvishnefske",
    "display_name": "John Vishnefske",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/8574077?u=d63221886bd79f481d66af4b0b28d1942a521c23&v=4",
    "url": "https://github.com/jvishnefske",
    "bio": "ðŸ¤– meta-programming ðŸŒš ",
    "stats": {
      "total_repos": 1,
      "total_plugins": 2,
      "total_commands": 4,
      "total_skills": 1,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "jvishnefske/swiss-cheese",
      "url": "https://github.com/jvishnefske/swiss-cheese",
      "description": "agentic skills plugin",
      "homepage": "",
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-08T05:49:54Z",
        "created_at": "2025-12-16T01:43:05Z",
        "license": null
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 1220
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/workflows/ci.yml",
          "type": "blob",
          "size": 813
        },
        {
          "path": ".github/workflows/python-app.yml",
          "type": "blob",
          "size": 1182
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 4588
        },
        {
          "path": "Makefile",
          "type": "blob",
          "size": 209
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 7337
        },
        {
          "path": "design.md",
          "type": "blob",
          "size": 4251
        },
        {
          "path": "swiss-cheese",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 338
        },
        {
          "path": "swiss-cheese/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/agents/architecture-agent.md",
          "type": "blob",
          "size": 2251
        },
        {
          "path": "swiss-cheese/agents/dynamic-analysis-agent.md",
          "type": "blob",
          "size": 3473
        },
        {
          "path": "swiss-cheese/agents/formal-verification-agent.md",
          "type": "blob",
          "size": 3330
        },
        {
          "path": "swiss-cheese/agents/implementation-agent.md",
          "type": "blob",
          "size": 2841
        },
        {
          "path": "swiss-cheese/agents/requirements-agent.md",
          "type": "blob",
          "size": 3282
        },
        {
          "path": "swiss-cheese/agents/review-agent.md",
          "type": "blob",
          "size": 2832
        },
        {
          "path": "swiss-cheese/agents/safety-agent.md",
          "type": "blob",
          "size": 3346
        },
        {
          "path": "swiss-cheese/agents/static-analysis-agent.md",
          "type": "blob",
          "size": 2583
        },
        {
          "path": "swiss-cheese/agents/tdd-agent.md",
          "type": "blob",
          "size": 2653
        },
        {
          "path": "swiss-cheese/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/commands/design.md",
          "type": "blob",
          "size": 3273
        },
        {
          "path": "swiss-cheese/commands/gate.md",
          "type": "blob",
          "size": 4125
        },
        {
          "path": "swiss-cheese/commands/implementation.md",
          "type": "blob",
          "size": 2956
        },
        {
          "path": "swiss-cheese/examples",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/examples/Makefile.swiss-cheese",
          "type": "blob",
          "size": 8156
        },
        {
          "path": "swiss-cheese/examples/example_project.toml",
          "type": "blob",
          "size": 7542
        },
        {
          "path": "swiss-cheese/hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/hooks/__pycache__",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/hooks/__pycache__/orchestrate.cpython-312.pyc",
          "type": "blob",
          "size": 52583
        },
        {
          "path": "swiss-cheese/hooks/__pycache__/orchestrate.cpython-39.pyc",
          "type": "blob",
          "size": 30708
        },
        {
          "path": "swiss-cheese/hooks/__pycache__/schema.cpython-312.pyc",
          "type": "blob",
          "size": 14425
        },
        {
          "path": "swiss-cheese/hooks/__pycache__/schema.cpython-39.pyc",
          "type": "blob",
          "size": 10539
        },
        {
          "path": "swiss-cheese/hooks/hooks.json",
          "type": "blob",
          "size": 581
        },
        {
          "path": "swiss-cheese/hooks/orchestrate.py",
          "type": "blob",
          "size": 35076
        },
        {
          "path": "swiss-cheese/hooks/session_start.py",
          "type": "blob",
          "size": 15044
        },
        {
          "path": "swiss-cheese/hooks/subagent_stop.py",
          "type": "blob",
          "size": 4824
        },
        {
          "path": "swiss-cheese/hooks/verify_gate.py",
          "type": "blob",
          "size": 2258
        },
        {
          "path": "swiss-cheese/pyproject.toml",
          "type": "blob",
          "size": 1215
        },
        {
          "path": "swiss-cheese/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/skills/design-review.md",
          "type": "blob",
          "size": 3778
        },
        {
          "path": "swiss-cheese/skills/gate-validation.md",
          "type": "blob",
          "size": 3914
        },
        {
          "path": "swiss-cheese/skills/swiss-cheese-guide.md",
          "type": "blob",
          "size": 5116
        },
        {
          "path": "swiss-cheese/skills/swiss-cheese-patterns.md",
          "type": "blob",
          "size": 6044
        },
        {
          "path": "swiss-cheese/tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "swiss-cheese/tests/__init__.py",
          "type": "blob",
          "size": 28
        },
        {
          "path": "swiss-cheese/tests/test_hooks.py",
          "type": "blob",
          "size": 25279
        },
        {
          "path": "ultrathink-orchestrator",
          "type": "tree",
          "size": null
        },
        {
          "path": "ultrathink-orchestrator/.claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": "ultrathink-orchestrator/.claude-plugin/plugin.json",
          "type": "blob",
          "size": 380
        },
        {
          "path": "ultrathink-orchestrator/agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "ultrathink-orchestrator/agents/ultrathink-orchestrator.md",
          "type": "blob",
          "size": 6166
        },
        {
          "path": "ultrathink-orchestrator/commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "ultrathink-orchestrator/commands/ultra.md",
          "type": "blob",
          "size": 2731
        },
        {
          "path": "ultrathink-orchestrator/skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "ultrathink-orchestrator/skills/ultraplan",
          "type": "tree",
          "size": null
        },
        {
          "path": "ultrathink-orchestrator/skills/ultraplan/SKILL.md",
          "type": "blob",
          "size": 5319
        }
      ],
      "marketplace": {
        "name": "jvishnefske-agent-plugins",
        "version": "1.0.0",
        "description": "Swiss Cheese Model verification plugins for Rust development using multi-layer AI agents",
        "owner_info": {
          "name": "Swiss Cheese Project",
          "email": "support@example.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "swiss-cheese",
            "description": "Agentic Rust development using the NASA Swiss Cheese Model. Full lifecycle from requirements validation through CI verification with 9 independent verification layers.",
            "source": "./swiss-cheese",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "Swiss Cheese Project",
              "email": "jvishnefske@gmail.com"
            },
            "install_commands": [
              "/plugin marketplace add jvishnefske/swiss-cheese",
              "/plugin install swiss-cheese@jvishnefske-agent-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-08T05:49:54Z",
              "created_at": "2025-12-16T01:43:05Z",
              "license": null
            },
            "commands": [
              {
                "name": "/design",
                "description": "Analyze requirements and produce TOML task specification",
                "path": "swiss-cheese/commands/design.md",
                "frontmatter": {
                  "description": "Analyze requirements and produce TOML task specification",
                  "arguments": [
                    {
                      "name": "requirements_source",
                      "description": "Path to requirements document, URL, or description",
                      "required": false
                    }
                  ]
                },
                "content": "You are conducting requirements analysis to produce a task specification.\n\n## Goal\n\nProduce `.claude/tasks.toml` - a validated task list ready for implementation.\n\n## Process\n\n{{#if requirements_source}}\n1. Read and analyze: `{{requirements_source}}`\n{{else}}\n1. Look for existing requirements in: README.md, docs/, requirements.md, design.md\n{{/if}}\n2. Extract functional requirements with testable acceptance criteria\n3. Break into implementable tasks with dependencies\n4. Validate the task graph (no cycles, all deps exist)\n5. Write `.claude/tasks.toml`\n\n## Task Specification Schema (TOML)\n\n```toml\nversion = 1\nstatus = \"ready_for_implementation\"  # or: \"draft\", \"needs_review\"\n\n[project]\nname = \"project-name\"\ndescription = \"Brief project description\"\nworktree_base = \".worktrees\"  # Where task worktrees are created\n\n[[tasks]]\nid = \"task-001\"\ntitle = \"Short imperative title\"\nacceptance = \"Specific testable criteria\"\ndeps = []  # List of task IDs this depends on\nstatus = \"pending\"  # pending | in_progress | complete\nspec_file = \"specs/task-001.md\"  # Optional: detailed specification\n\n[[tasks]]\nid = \"task-002\"\ntitle = \"Another task\"\nacceptance = \"Tests pass, no compiler warnings\"\ndeps = [\"task-001\"]  # Depends on task-001\nstatus = \"pending\"\n```\n\n## Requirements for Each Task\n\n1. **id**: Unique identifier (task-NNN format)\n2. **title**: Short, imperative description (e.g., \"Implement user login\")\n3. **acceptance**: Testable criteria - what \"done\" looks like\n4. **deps**: Array of task IDs that must complete first\n5. **status**: Always start as `pending`\n6. **spec_file**: Optional path to detailed specification\n7. **worktree**: Optional custom worktree path\n\n## Validation Checklist\n\nBefore setting `status = \"ready_for_implementation\"`:\n\n- [ ] All tasks have unique IDs\n- [ ] All dependency references are valid task IDs\n- [ ] No circular dependencies (topological sort must succeed)\n- [ ] Each task has testable acceptance criteria\n- [ ] Dependencies form a valid DAG (directed acyclic graph)\n\n## Output\n\nCreate `.claude/tasks.toml` with:\n1. All requirements broken into tasks\n2. Dependencies correctly mapped\n3. Testable acceptance criteria\n4. Status set to `ready_for_implementation`\n\n## Git Worktree Integration\n\nEach task gets its own git worktree for parallel development:\n\n```bash\n# Worktrees created at: <worktree_base>/<task-id>\n.worktrees/\nâ”œâ”€â”€ task-001/\nâ”œâ”€â”€ task-002/\nâ””â”€â”€ task-003/\n```\n\nThe `SubagentStop` hook ensures branches are rebased into linear history.\n\n## Makefile Integration\n\nEnsure a `Makefile` exists with verification target:\n\n```makefile\n.PHONY: verify\n\nverify:\n\tcargo build --all-targets 2>&1 | grep -E \"^warning:\" && exit 1 || true\n\tcargo test --all-features\n\tcargo clippy --all-targets -- -D warnings\n\tcargo fmt --check\n```\n\nThe `Stop` hook runs `make verify` before allowing completion.\n\n## Next Steps\n\nAfter completing the design:\n1. Run `/swiss-cheese:implementation` to begin TDD workflow\n2. The SessionStart hook parses tasks.toml and shows ready tasks\n3. Work through tasks in topological order"
              },
              {
                "name": "/gate",
                "description": "Gate to run: requirements, architecture, tdd, implementation, static-analysis, formal-verification, dynamic-analysis, review, safety-case",
                "path": "swiss-cheese/commands/gate.md",
                "frontmatter": {
                  "description": "Gate to run: requirements, architecture, tdd, implementation, static-analysis, formal-verification, dynamic-analysis, review, safety-case",
                  "arguments": [
                    {
                      "name": "gate_name",
                      "description": "Gate to run: requirements, architecture, tdd, implementation, static-analysis, formal-verification, dynamic-analysis, review, safety-case",
                      "required": true
                    }
                  ]
                },
                "content": "You are manually running the **{{gate_name}}** verification gate.\n\n## Running the Gate\n\nExecute the Makefile target for this gate:\n\n```bash\nmake validate-{{gate_name}}\n```\n\n## Gate Details\n\n{{#if (eq gate_name \"requirements\")}}\n### Layer 1: Requirements Validation\n\n**Makefile Target**: `validate-requirements`\n\n**What it checks**:\n- `design.toml` exists and is valid TOML\n- All requirements have `acceptance_criteria`\n- Requirement IDs follow REQ-NNN pattern\n\n**To pass manually**:\n1. Ensure `design.toml` exists with valid [[requirements]] section\n2. Each requirement needs: id, title, description, acceptance_criteria\n\n{{else if (eq gate_name \"architecture\")}}\n### Layer 2: Architecture Design\n\n**Makefile Target**: `validate-architecture`\n\n**What it checks**:\n- Architecture documentation exists (docs/architecture.md or ARCHITECTURE.md)\n- Cargo.toml is valid (if Rust project)\n\n**To pass manually**:\n1. Create architecture documentation\n2. Ensure Cargo.toml structure is valid\n\n{{else if (eq gate_name \"tdd\")}}\n### Layer 3: Test-Driven Development\n\n**Makefile Target**: `validate-tdd`\n\n**What it checks**:\n- Test files exist\n- Tests compile (`cargo test --no-run`)\n\n**To pass manually**:\n1. Write tests for all requirements\n2. Tests should compile but may fail (TDD red phase)\n\n{{else if (eq gate_name \"implementation\")}}\n### Layer 4: Implementation\n\n**Makefile Target**: `validate-implementation`\n\n**What it checks**:\n- `cargo build --all-targets` succeeds\n- `cargo test --all-features` passes\n\n**To pass manually**:\n1. Implement code to pass all tests\n2. No build errors or warnings\n\n{{else if (eq gate_name \"static-analysis\")}}\n### Layer 5: Static Analysis\n\n**Makefile Target**: `validate-static-analysis`\n\n**What it checks**:\n- `cargo clippy -- -D warnings` passes\n- `cargo audit` (if installed) - no critical vulnerabilities\n- `cargo deny check` (if configured) - license compliance\n\n**To pass manually**:\n1. Fix all Clippy warnings\n2. Address any security advisories\n3. Ensure license compliance\n\n{{else if (eq gate_name \"formal-verification\")}}\n### Layer 6: Formal Verification (Optional)\n\n**Makefile Target**: `validate-formal-verification`\n\n**What it checks**:\n- `cargo kani` passes (if Kani installed)\n\n**This layer is optional**. Skip with justification if:\n- No unsafe code\n- No critical invariants\n- Kani not available\n\n{{else if (eq gate_name \"dynamic-analysis\")}}\n### Layer 7: Dynamic Analysis\n\n**Makefile Target**: `validate-dynamic-analysis`\n\n**What it checks**:\n- `cargo +nightly miri test` (if available)\n- `cargo llvm-cov` coverage >= threshold\n\n**To pass manually**:\n1. Run Miri to check for undefined behavior\n2. Achieve coverage target (typically 70-80%)\n\n{{else if (eq gate_name \"review\")}}\n### Layer 8: Code Review\n\n**Makefile Target**: `validate-review`\n\n**What it checks**:\n- Review documentation exists (REVIEW.md or .claude/review.md)\n\n**To pass manually**:\n1. Conduct code review\n2. Document findings and resolutions\n\n{{else if (eq gate_name \"safety-case\")}}\n### Layer 9: Safety Case\n\n**Makefile Target**: `validate-safety-case`\n\n**What it checks**:\n- All previous gates passed\n- Traceability report generated\n\n**To pass manually**:\n1. Verify all evidence assembled\n2. Make release decision\n3. Traceability matrix complete\n\n{{else}}\n### Unknown Gate: {{gate_name}}\n\nValid gates are:\n- requirements\n- architecture\n- tdd\n- implementation\n- static-analysis\n- formal-verification\n- dynamic-analysis\n- review\n- safety-case\n\n{{/if}}\n\n## Instructions\n\n1. Run `make validate-{{gate_name}}`\n2. If it fails, review the output and fix issues\n3. Re-run until the gate passes\n4. The orchestrator will automatically advance when the gate passes\n\n## Exit Codes\n\n- **0**: Gate passed\n- **Non-zero**: Gate failed (see output for details)"
              },
              {
                "name": "/implementation",
                "description": "Begin TDD implementation from task specification",
                "path": "swiss-cheese/commands/implementation.md",
                "frontmatter": {
                  "description": "Begin TDD implementation from task specification"
                },
                "content": "You are starting Test-Driven Development for tasks defined in `.claude/tasks.yaml`.\n\n## TDD Workflow\n\nFor each task, follow the Red-Green-Refactor cycle:\n\n### 1. RED: Write Failing Tests First\n\nBefore writing any implementation:\n\n```rust\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_req_001_acceptance_criterion() {\n        // Test the acceptance criteria from tasks.yaml\n        // This test MUST fail initially (no implementation exists)\n    }\n}\n```\n\n- One test per acceptance criterion\n- Name tests `test_req_NNN_*` for traceability\n- Run `cargo test` - confirm tests fail (red)\n\n### 2. GREEN: Minimal Implementation\n\nWrite the minimum code to make tests pass:\n\n```bash\ncargo test           # Must pass\ncargo build          # Must pass\ncargo clippy -- -D warnings  # No warnings allowed\n```\n\n- Only add code that tests require\n- No speculative features\n- No unused code paths\n\n### 3. REFACTOR: Remove Uncovered Code\n\nWith tests covering all requirements, aggressively refactor:\n\n```bash\ncargo llvm-cov --html  # Generate coverage report\n```\n\n- **Delete any uncovered code** - if tests don't need it, remove it\n- Simplify implementations\n- Extract common patterns\n- Tests must still pass after refactoring\n\n## Cargo Requirements\n\nAll cargo commands must pass without warnings:\n\n```bash\ncargo build --all-targets 2>&1 | grep -E \"^warning:\" && exit 1\ncargo test --all-features\ncargo clippy --all-targets -- -D warnings\ncargo fmt --check\n```\n\nThe `make verify` target enforces these.\n\n## Task Cycle\n\n### 1. Select Ready Task\n\nTasks are ready when `status: pending` and all `deps` are `complete`.\n\n### 2. Mark In Progress\n\n```yaml\n- id: task-001\n  status: in_progress\n```\n\n### 3. Read Specification\n\nIf task has `spec_file`, read it for detailed requirements.\n\n### 4. TDD Cycle\n\n```\nRED    â†’ Write failing test for acceptance criterion\nGREEN  â†’ Write minimal code to pass\nREFACTOR â†’ Remove uncovered code, simplify\n```\n\nRepeat for each acceptance criterion.\n\n### 5. Verify\n\n```bash\nmake verify  # Must pass: build, test, clippy, fmt\n```\n\n### 6. Mark Complete\n\n```yaml\n- id: task-001\n  status: complete\n```\n\n## Coverage-Driven Refactoring\n\nIn the refactor step:\n\n1. Run coverage: `cargo llvm-cov`\n2. Identify uncovered lines\n3. For each uncovered line, ask: \"Is this required by any test?\"\n4. If no test requires it â†’ **delete it**\n5. If a test should require it â†’ add a test first\n\nThis ensures:\n- All code is justified by requirements\n- Dead code is eliminated\n- Implementation is minimal\n\n## Verification Gate\n\nThe Stop hook blocks until `make verify` passes:\n- `cargo build --all-targets` (no warnings)\n- `cargo test --all-features` (all pass)\n- `cargo clippy -- -D warnings` (no warnings)\n- `cargo fmt --check` (formatted)\n\n## Commands\n\n- `/swiss-cheese:design` - Create task specification\n- `/swiss-cheese:implementation` - Begin TDD implementation"
              }
            ],
            "skills": []
          },
          {
            "name": "ultrathink-orchestrator",
            "description": "Parallel orchestration workflow with up to 100 subagent invocations. Ensures Claude Code always uses subagents for planning and implementation tasks.",
            "source": "./ultrathink-orchestrator",
            "category": "development",
            "version": "1.0.0",
            "author": {
              "name": "jvishnefske",
              "email": "jvishnefske@gmail.com"
            },
            "install_commands": [
              "/plugin marketplace add jvishnefske/swiss-cheese",
              "/plugin install ultrathink-orchestrator@jvishnefske-agent-plugins"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-08T05:49:54Z",
              "created_at": "2025-12-16T01:43:05Z",
              "license": null
            },
            "commands": [
              {
                "name": "/ultra",
                "description": null,
                "path": "ultrathink-orchestrator/commands/ultra.md",
                "frontmatter": null,
                "content": "---\ndescription: Parallel orchestration workflow with up to 100 subagent invocations\nargument-hint: [target] [--depth shallow|standard|deep]\nmodel: opus\n---\n\n# Ultra Parallel Orchestration Command\n\nInitiate the **ultrathink** parallel orchestration workflow. This command MANDATES the use of subagents via the Task tool for all planning and implementation work.\n\n## Arguments Received\n\n- **Target**: $1 (module name, file path, or task description)\n- **Depth**: $2 (--depth shallow|standard|deep, default: standard)\n\n## CRITICAL: Subagent Delegation Requirement\n\n**USE THE TASK TOOL FOR ALL WORK.**\n\nDo NOT perform analysis or implementation directly. Instead:\n1. Spawn parallel subagents for independent work items\n2. Run up to 100 Task invocations in a SINGLE message when work items are independent\n3. Wait for subagent completion before synthesizing results\n\n## Parallel Subagent Dispatch Protocol\n\n### Step 1: Scope Analysis (Spawn 1 analysis subagent)\n\nLaunch a Task subagent to:\n- Identify all files relevant to target \"$1\"\n- Map dependencies between modules\n- Determine which work items are independent (parallelizable)\n- Return a work decomposition plan\n\n### Step 2: Parallel Work Execution (Spawn N subagents)\n\nBased on Step 1 results, spawn parallel Task subagents:\n\n- Subagent per affected module\n- Subagent for test coverage analysis\n- Subagent for documentation verification\n\n### Step 3: Synthesis (Spawn 1 integration subagent)\n\nLaunch a Task subagent to:\n- Collect all parallel subagent outputs\n- Verify consistency across results\n- Generate unified report with:\n  - Changes needed per file\n  - Test coverage status\n  - Recommended next steps\n\n## Depth Profiles\n\n| Depth | Subagent Count | Analysis Level | Use Case |\n|-------|----------------|----------------|----------|\n| shallow | 2-5 | File-level | Quick reconnaissance |\n| standard | 10-30 | Function-level | Balanced exploration |\n| deep | 50-100 | Line-level | Comprehensive verification |\n\n## Subagent Spawning Feedback\n\nFor EACH Task invocation, output:\n\n```\n[SUBAGENT SPAWN] Purpose: <brief description>\n  Target: <file or module>\n  Parallelizable: yes|no\n  Estimated complexity: low|medium|high\n```\n\nAfter ALL parallel subagents complete:\n\n```\n[ORCHESTRATION COMPLETE]\n  Subagents spawned: <count>\n  Parallel batches: <count>\n  Results synthesized: yes|no\n```\n\n## Begin Orchestration\n\nAnalyze the target \"$1\" and immediately spawn parallel subagents using the Task tool. Do NOT attempt to perform the work yourself - delegate everything to subagents.\n\nRemember: Invoke up to 100 Task tools in a SINGLE response message for maximum parallelism when work items are independent.\n\nStart now by spawning your first batch of parallel subagents for target: $1\n"
              }
            ],
            "skills": [
              {
                "name": "Ultraplan",
                "description": "This skill should be used when the user asks to \"start parallel implementation\", \"orchestrate tasks\", \"run ultraplan\", \"launch ultrathink workflow\", \"parallel subagent execution\", \"plan and implement feature\", \"coordinate implementation across phases\", \"run 100 agents\", \"massive parallel work\", or needs guidance on orchestrating multi-phase implementation workflows with parallel Task invocations.",
                "path": "ultrathink-orchestrator/skills/ultraplan/SKILL.md",
                "frontmatter": {
                  "name": "Ultraplan",
                  "description": "This skill should be used when the user asks to \"start parallel implementation\", \"orchestrate tasks\", \"run ultraplan\", \"launch ultrathink workflow\", \"parallel subagent execution\", \"plan and implement feature\", \"coordinate implementation across phases\", \"run 100 agents\", \"massive parallel work\", or needs guidance on orchestrating multi-phase implementation workflows with parallel Task invocations.",
                  "version": "1.0.0"
                },
                "content": "# Ultraplan - Parallel Orchestration Workflow\n\nUltraplan enables coordinated multi-phase implementation using parallel Task invocations (up to 100 simultaneous). It leverages subagents for each implementation phase.\n\n## Core Concept\n\nUltraplan orchestrates work through phases:\n\n| Phase | Purpose | Subagent Role |\n|-------|---------|---------------|\n| Phase 1 | Exploration | Understand codebase areas |\n| Phase 2 | Planning | Design implementation approach |\n| Phase 3 | Implementation | Execute planned changes |\n| Phase 4 | Verification | Validate correctness |\n\nEach phase may spawn multiple parallel Task invocations for independent subtasks.\n\n## Invocation Process\n\n### Step 1: Context Gathering\n\nBefore orchestrating, gather implementation context:\n\n1. Identify target areas of the codebase\n2. Determine parallelization opportunities - independent subtasks within each phase\n3. Map dependencies - which tasks block others\n\nQuery the user if context is insufficient:\n- \"Which areas should I focus on?\"\n- \"Should I work on a specific phase or orchestrate all phases?\"\n\n### Step 2: Task Decomposition\n\nFor each task, decompose into parallelizable subtasks:\n\n**Parallelization Rules:**\n- Tasks within the same phase MAY run in parallel if no data dependency\n- Tasks across phases MUST respect phase ordering (1 -> 2 -> 3 -> 4)\n- Maximum 100 parallel Task invocations per orchestration batch\n\n**Task Schema:**\n```\ntask_id: unique-task-identifier\nphase: 1|2|3|4\ndescription: imperative description\ndeps: [task_id, ...]\nfiles: [affected files]\nacceptance: testable criteria\n```\n\n### Step 3: Subagent Dispatch\n\nLaunch parallel Task invocations for independent subtasks:\n\n**Dispatch Pattern:**\n```\nFor each phase in [1, 2, 3, 4]:\n  identify_ready_tasks(phase)  # Tasks with satisfied deps\n  batch_tasks = partition(ready_tasks, max_batch=100)\n  for batch in batch_tasks:\n    parallel_invoke(Task, batch)  # Up to 100 simultaneous\n  await_all(batch)\n  validate_phase_output()\n  proceed_to_next_phase()\n```\n\n**Subagent Prompt Template:**\n\nEach Task invocation receives:\n1. Specific task identifier\n2. Target file paths\n3. Acceptance criteria\n4. Phase-specific instructions\n\n### Step 4: Progress Tracking\n\nTrack implementation progress:\n\n1. **Before work**: Mark task as in-progress\n2. **After completion**: Mark task as complete\n3. **Add traceability**: Note validation method\n\n### Step 5: Verification Gate\n\nBefore marking orchestration complete:\n\n1. Run build - no warnings\n2. Run tests - all pass\n3. Run linting - no warnings\n\n## Phase-Specific Subagent Instructions\n\n### Phase 1 Subagent: Exploration\n\nInstructions for Phase 1 Task invocations:\n- Read and understand target files\n- Identify key types and APIs\n- Find existing patterns\n- Map dependencies\n- Report findings (do NOT make changes)\n\n### Phase 2 Subagent: Planning\n\nInstructions for Phase 2 Task invocations:\n- Design changes based on exploration\n- Specify file paths and line ranges\n- Order changes by dependency\n- Identify test cases needed\n- Return structured plan\n\n### Phase 3 Subagent: Implementation\n\nInstructions for Phase 3 Task invocations:\n- Execute planned changes\n- Follow existing code patterns\n- Add documentation\n- Run local tests\n- Report completion status\n\n### Phase 4 Subagent: Verification\n\nInstructions for Phase 4 Task invocations:\n- Run full test suite\n- Check linting\n- Verify documentation\n- Report any issues found\n\n## Orchestration Commands\n\n| Action | How to Invoke |\n|--------|---------------|\n| Start ultraplan | \"Run /ultraplan\" or \"start parallel implementation\" |\n| Target specific area | \"Implement changes to the auth module\" |\n| Single phase only | \"Run exploration phase only\" |\n| Check status | \"What tasks remain?\" |\n| Verify completion | \"Validate all tasks are complete\" |\n\n## Error Handling\n\nWhen a subagent Task fails:\n\n1. Capture failure context - error message, affected files\n2. Determine retry eligibility - transient vs. fundamental failure\n3. Isolate affected tasks - do not block unrelated parallel work\n4. Report to orchestrator - aggregate failure summary\n5. Suggest remediation - specific fix guidance\n\n## Best Practices\n\n### Parallelization Guidelines\n\n1. Maximize parallelism within phases (independent subtasks)\n2. Respect phase boundaries - never start Phase N+1 before Phase N completes\n3. Batch appropriately - group related subtasks to minimize context switches\n4. Use explicit dependencies - model task DAG accurately\n\n### Code Quality Gates\n\nEvery subagent must ensure:\n- No compiler/linter warnings\n- All tests pass\n- Documentation complete\n\n## Quick Start\n\nTo begin an ultraplan orchestration:\n\n1. Identify target areas of the codebase\n2. Confirm scope with user\n3. Decompose into parallelizable tasks\n4. Dispatch Phase 1 subagents in parallel\n5. On Phase 1 completion, dispatch Phase 2, etc.\n6. Run verification gate\n7. Report final status"
              }
            ]
          }
        ]
      }
    }
  ]
}