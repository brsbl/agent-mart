{
  "owner": {
    "id": "bgrober",
    "display_name": "Brian",
    "type": "User",
    "avatar_url": "https://avatars.githubusercontent.com/u/7087466?u=086f669b3652f4087ca123645f519dd23dd8033a&v=4",
    "url": "https://github.com/bgrober",
    "bio": null,
    "stats": {
      "total_repos": 1,
      "total_plugins": 1,
      "total_commands": 0,
      "total_skills": 10,
      "total_stars": 0,
      "total_forks": 0
    }
  },
  "repos": [
    {
      "full_name": "bgrober/indie-stack",
      "url": "https://github.com/bgrober/indie-stack",
      "description": "Claude Code plugin for indie devs: Swift/SwiftUI, Supabase, Vercel, AI SDK. 3-stage review with UX focus.",
      "homepage": null,
      "signals": {
        "stars": 0,
        "forks": 0,
        "pushed_at": "2026-01-07T13:20:43Z",
        "created_at": "2026-01-07T02:05:10Z",
        "license": "MIT"
      },
      "file_tree": [
        {
          "path": ".claude-plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".claude-plugin/marketplace.json",
          "type": "blob",
          "size": 514
        },
        {
          "path": ".claude-plugin/plugin.json",
          "type": "blob",
          "size": 340
        },
        {
          "path": ".codex",
          "type": "tree",
          "size": null
        },
        {
          "path": ".codex/INSTALL.md",
          "type": "blob",
          "size": 922
        },
        {
          "path": ".codex/superpowers-bootstrap.md",
          "type": "blob",
          "size": 1574
        },
        {
          "path": ".codex/superpowers-codex",
          "type": "blob",
          "size": 9739
        },
        {
          "path": ".github",
          "type": "tree",
          "size": null
        },
        {
          "path": ".github/FUNDING.yml",
          "type": "blob",
          "size": 62
        },
        {
          "path": ".gitignore",
          "type": "blob",
          "size": 39
        },
        {
          "path": ".opencode",
          "type": "tree",
          "size": null
        },
        {
          "path": ".opencode/INSTALL.md",
          "type": "blob",
          "size": 2993
        },
        {
          "path": ".opencode/plugin",
          "type": "tree",
          "size": null
        },
        {
          "path": ".opencode/plugin/superpowers.js",
          "type": "blob",
          "size": 8293
        },
        {
          "path": "LICENSE",
          "type": "blob",
          "size": 1070
        },
        {
          "path": "README.md",
          "type": "blob",
          "size": 3912
        },
        {
          "path": "RELEASE-NOTES.md",
          "type": "blob",
          "size": 28609
        },
        {
          "path": "agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "agents/backend-reviewer.md",
          "type": "blob",
          "size": 4655
        },
        {
          "path": "agents/code-reviewer.md",
          "type": "blob",
          "size": 3888
        },
        {
          "path": "agents/ios-reviewer.md",
          "type": "blob",
          "size": 4198
        },
        {
          "path": "agents/ux-reviewer.md",
          "type": "blob",
          "size": 6048
        },
        {
          "path": "commands",
          "type": "tree",
          "size": null
        },
        {
          "path": "commands/brainstorm.md",
          "type": "blob",
          "size": 326
        },
        {
          "path": "commands/execute-plan.md",
          "type": "blob",
          "size": 188
        },
        {
          "path": "commands/write-plan.md",
          "type": "blob",
          "size": 196
        },
        {
          "path": "docs",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/README.codex.md",
          "type": "blob",
          "size": 3414
        },
        {
          "path": "docs/README.opencode.md",
          "type": "blob",
          "size": 6281
        },
        {
          "path": "docs/plans",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/plans/2025-11-22-opencode-support-design.md",
          "type": "blob",
          "size": 8831
        },
        {
          "path": "docs/plans/2025-11-22-opencode-support-implementation.md",
          "type": "blob",
          "size": 27530
        },
        {
          "path": "docs/plans/2025-11-28-skills-improvements-from-user-feedback.md",
          "type": "blob",
          "size": 21033
        },
        {
          "path": "docs/testing.md",
          "type": "blob",
          "size": 9884
        },
        {
          "path": "docs/windows",
          "type": "tree",
          "size": null
        },
        {
          "path": "docs/windows/polyglot-hooks.md",
          "type": "blob",
          "size": 6296
        },
        {
          "path": "hooks",
          "type": "tree",
          "size": null
        },
        {
          "path": "hooks/hooks.json",
          "type": "blob",
          "size": 287
        },
        {
          "path": "hooks/run-hook.cmd",
          "type": "blob",
          "size": 493
        },
        {
          "path": "hooks/session-start.sh",
          "type": "blob",
          "size": 1995
        },
        {
          "path": "lib",
          "type": "tree",
          "size": null
        },
        {
          "path": "lib/skills-core.js",
          "type": "blob",
          "size": 6461
        },
        {
          "path": "skills",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/brainstorming",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/brainstorming/SKILL.md",
          "type": "blob",
          "size": 8878
        },
        {
          "path": "skills/dispatching-parallel-agents",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/dispatching-parallel-agents/SKILL.md",
          "type": "blob",
          "size": 6104
        },
        {
          "path": "skills/receiving-code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/receiving-code-review/SKILL.md",
          "type": "blob",
          "size": 6314
        },
        {
          "path": "skills/requesting-code-review",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/requesting-code-review/SKILL.md",
          "type": "blob",
          "size": 2700
        },
        {
          "path": "skills/requesting-code-review/code-reviewer.md",
          "type": "blob",
          "size": 3385
        },
        {
          "path": "skills/subagent-driven-development",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/subagent-driven-development/SKILL.md",
          "type": "blob",
          "size": 6131
        },
        {
          "path": "skills/subagent-driven-development/code-quality-reviewer-prompt.md",
          "type": "blob",
          "size": 630
        },
        {
          "path": "skills/subagent-driven-development/implementer-prompt.md",
          "type": "blob",
          "size": 2195
        },
        {
          "path": "skills/subagent-driven-development/spec-reviewer-prompt.md",
          "type": "blob",
          "size": 1999
        },
        {
          "path": "skills/subagent-driven-development/ux-reviewer-prompt.md",
          "type": "blob",
          "size": 1729
        },
        {
          "path": "skills/supabase-setup",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/supabase-setup/SKILL.md",
          "type": "blob",
          "size": 9661
        },
        {
          "path": "skills/swift-ios-app",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/swift-ios-app/SKILL.md",
          "type": "blob",
          "size": 7781
        },
        {
          "path": "skills/systematic-debugging",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/systematic-debugging/CREATION-LOG.md",
          "type": "blob",
          "size": 4268
        },
        {
          "path": "skills/systematic-debugging/SKILL.md",
          "type": "blob",
          "size": 9884
        },
        {
          "path": "skills/systematic-debugging/condition-based-waiting-example.ts",
          "type": "blob",
          "size": 5054
        },
        {
          "path": "skills/systematic-debugging/condition-based-waiting.md",
          "type": "blob",
          "size": 3516
        },
        {
          "path": "skills/systematic-debugging/defense-in-depth.md",
          "type": "blob",
          "size": 3650
        },
        {
          "path": "skills/systematic-debugging/find-polluter.sh",
          "type": "blob",
          "size": 1528
        },
        {
          "path": "skills/systematic-debugging/root-cause-tracing.md",
          "type": "blob",
          "size": 5327
        },
        {
          "path": "skills/systematic-debugging/test-academic.md",
          "type": "blob",
          "size": 653
        },
        {
          "path": "skills/systematic-debugging/test-pressure-1.md",
          "type": "blob",
          "size": 1900
        },
        {
          "path": "skills/systematic-debugging/test-pressure-2.md",
          "type": "blob",
          "size": 2283
        },
        {
          "path": "skills/systematic-debugging/test-pressure-3.md",
          "type": "blob",
          "size": 2692
        },
        {
          "path": "skills/testing-flexible",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/testing-flexible/SKILL.md",
          "type": "blob",
          "size": 5809
        },
        {
          "path": "skills/testing-flexible/testing-anti-patterns.md",
          "type": "blob",
          "size": 8251
        },
        {
          "path": "skills/verification-before-completion",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/verification-before-completion/SKILL.md",
          "type": "blob",
          "size": 4201
        },
        {
          "path": "skills/writing-plans",
          "type": "tree",
          "size": null
        },
        {
          "path": "skills/writing-plans/SKILL.md",
          "type": "blob",
          "size": 3264
        },
        {
          "path": "tests",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/claude-code",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/claude-code/README.md",
          "type": "blob",
          "size": 4289
        },
        {
          "path": "tests/claude-code/analyze-token-usage.py",
          "type": "blob",
          "size": 6723
        },
        {
          "path": "tests/claude-code/run-skill-tests.sh",
          "type": "blob",
          "size": 5136
        },
        {
          "path": "tests/claude-code/test-helpers.sh",
          "type": "blob",
          "size": 5098
        },
        {
          "path": "tests/claude-code/test-subagent-driven-development-integration.sh",
          "type": "blob",
          "size": 9454
        },
        {
          "path": "tests/claude-code/test-subagent-driven-development.sh",
          "type": "blob",
          "size": 3738
        },
        {
          "path": "tests/explicit-skill-requests",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/explicit-skill-requests/prompts",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/explicit-skill-requests/prompts/action-oriented.txt",
          "type": "blob",
          "size": 161
        },
        {
          "path": "tests/explicit-skill-requests/prompts/after-planning-flow.txt",
          "type": "blob",
          "size": 539
        },
        {
          "path": "tests/explicit-skill-requests/prompts/claude-suggested-it.txt",
          "type": "blob",
          "size": 486
        },
        {
          "path": "tests/explicit-skill-requests/prompts/i-know-what-sdd-means.txt",
          "type": "blob",
          "size": 354
        },
        {
          "path": "tests/explicit-skill-requests/prompts/mid-conversation-execute-plan.txt",
          "type": "blob",
          "size": 107
        },
        {
          "path": "tests/explicit-skill-requests/prompts/please-use-brainstorming.txt",
          "type": "blob",
          "size": 73
        },
        {
          "path": "tests/explicit-skill-requests/prompts/skip-formalities.txt",
          "type": "blob",
          "size": 159
        },
        {
          "path": "tests/explicit-skill-requests/prompts/subagent-driven-development-please.txt",
          "type": "blob",
          "size": 36
        },
        {
          "path": "tests/explicit-skill-requests/prompts/use-systematic-debugging.txt",
          "type": "blob",
          "size": 52
        },
        {
          "path": "tests/explicit-skill-requests/run-all.sh",
          "type": "blob",
          "size": 1969
        },
        {
          "path": "tests/explicit-skill-requests/run-claude-describes-sdd.sh",
          "type": "blob",
          "size": 3113
        },
        {
          "path": "tests/explicit-skill-requests/run-extended-multiturn-test.sh",
          "type": "blob",
          "size": 3387
        },
        {
          "path": "tests/explicit-skill-requests/run-haiku-test.sh",
          "type": "blob",
          "size": 4010
        },
        {
          "path": "tests/explicit-skill-requests/run-multiturn-test.sh",
          "type": "blob",
          "size": 4478
        },
        {
          "path": "tests/explicit-skill-requests/run-test.sh",
          "type": "blob",
          "size": 4261
        },
        {
          "path": "tests/opencode",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/opencode/run-tests.sh",
          "type": "blob",
          "size": 4319
        },
        {
          "path": "tests/opencode/setup.sh",
          "type": "blob",
          "size": 2319
        },
        {
          "path": "tests/opencode/test-plugin-loading.sh",
          "type": "blob",
          "size": 2618
        },
        {
          "path": "tests/opencode/test-priority.sh",
          "type": "blob",
          "size": 6857
        },
        {
          "path": "tests/opencode/test-skills-core.sh",
          "type": "blob",
          "size": 12859
        },
        {
          "path": "tests/opencode/test-tools.sh",
          "type": "blob",
          "size": 3631
        },
        {
          "path": "tests/skill-triggering",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/skill-triggering/prompts",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/skill-triggering/prompts/dispatching-parallel-agents.txt",
          "type": "blob",
          "size": 413
        },
        {
          "path": "tests/skill-triggering/prompts/executing-plans.txt",
          "type": "blob",
          "size": 110
        },
        {
          "path": "tests/skill-triggering/prompts/requesting-code-review.txt",
          "type": "blob",
          "size": 183
        },
        {
          "path": "tests/skill-triggering/prompts/systematic-debugging.txt",
          "type": "blob",
          "size": 335
        },
        {
          "path": "tests/skill-triggering/prompts/test-driven-development.txt",
          "type": "blob",
          "size": 248
        },
        {
          "path": "tests/skill-triggering/prompts/writing-plans.txt",
          "type": "blob",
          "size": 380
        },
        {
          "path": "tests/skill-triggering/run-all.sh",
          "type": "blob",
          "size": 1129
        },
        {
          "path": "tests/skill-triggering/run-test.sh",
          "type": "blob",
          "size": 2591
        },
        {
          "path": "tests/subagent-driven-dev",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/subagent-driven-dev/go-fractals",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/subagent-driven-dev/go-fractals/design.md",
          "type": "blob",
          "size": 1973
        },
        {
          "path": "tests/subagent-driven-dev/go-fractals/plan.md",
          "type": "blob",
          "size": 4957
        },
        {
          "path": "tests/subagent-driven-dev/go-fractals/scaffold.sh",
          "type": "blob",
          "size": 1017
        },
        {
          "path": "tests/subagent-driven-dev/run-test.sh",
          "type": "blob",
          "size": 2856
        },
        {
          "path": "tests/subagent-driven-dev/svelte-todo",
          "type": "tree",
          "size": null
        },
        {
          "path": "tests/subagent-driven-dev/svelte-todo/design.md",
          "type": "blob",
          "size": 2413
        },
        {
          "path": "tests/subagent-driven-dev/svelte-todo/plan.md",
          "type": "blob",
          "size": 4834
        },
        {
          "path": "tests/subagent-driven-dev/svelte-todo/scaffold.sh",
          "type": "blob",
          "size": 1039
        }
      ],
      "marketplace": {
        "name": "superpowers-dev",
        "version": null,
        "description": "Development marketplace for Superpowers core skills library",
        "owner_info": {
          "name": "Jesse Vincent",
          "email": "jesse@fsck.com"
        },
        "keywords": [],
        "plugins": [
          {
            "name": "superpowers",
            "description": "Core skills library for Claude Code: TDD, debugging, collaboration patterns, and proven techniques",
            "source": "./",
            "category": null,
            "version": "4.0.3",
            "author": {
              "name": "Jesse Vincent",
              "email": "jesse@fsck.com"
            },
            "install_commands": [
              "/plugin marketplace add bgrober/indie-stack",
              "/plugin install superpowers@superpowers-dev"
            ],
            "signals": {
              "stars": 0,
              "forks": 0,
              "pushed_at": "2026-01-07T13:20:43Z",
              "created_at": "2026-01-07T02:05:10Z",
              "license": "MIT"
            },
            "commands": [],
            "skills": [
              {
                "name": "brainstorming",
                "description": "MUST use before building features, creating components, adding functionality, or designing new behavior. Use when user says 'build', 'create', 'add feature', 'implement', 'design', or describes something new to build. Explores requirements through questions before writing code.",
                "path": "skills/brainstorming/SKILL.md",
                "frontmatter": {
                  "name": "brainstorming",
                  "description": "MUST use before building features, creating components, adding functionality, or designing new behavior. Use when user says 'build', 'create', 'add feature', 'implement', 'design', or describes something new to build. Explores requirements through questions before writing code."
                },
                "content": "# Brainstorming Ideas Into Designs\n\n## Overview\n\nHelp turn ideas into fully formed designs and specs through natural collaborative dialogue.\n\nStart by understanding the current project context, then ask questions one at a time to refine the idea. Once you understand what you're building, present the design in small sections (200-300 words), checking after each section whether it looks right so far.\n\n## The Process\n\n**Understanding the idea:**\n- Check out the current project state first (files, docs, recent commits)\n- Ask questions one at a time to refine the idea\n- Prefer multiple choice questions when possible, but open-ended is fine too\n- Only one question per message - if a topic needs more exploration, break it into multiple questions\n- Focus on understanding: purpose, constraints, success criteria\n\n**Exploring approaches:**\n- Propose 2-3 different approaches with trade-offs\n- Present options conversationally with your recommendation and reasoning\n- Lead with your recommended option and explain why\n\n**Presenting the design:**\n- Once you believe you understand what you're building, present the design\n- Break it into sections of 200-300 words\n- Ask after each section whether it looks right so far\n- Cover: architecture, components, data flow, error handling, testing\n- Be ready to go back and clarify if something doesn't make sense\n\n## Stack-Specific Decision Trees\n\nWhen brainstorming features for your stack, work through these decision trees:\n\n### Platform Decision\n\n```\nIs this feature...\n├── iOS/native only?\n│   └── Use indie-stack:swift-ios-app patterns\n├── Web only?\n│   └── Use Next.js + Vercel patterns\n├── Backend/API only?\n│   └── Use indie-stack:supabase-setup patterns\n└── Full stack (mobile + web + backend)?\n    └── Design backend first, then platform UIs\n```\n\n### Data Architecture\n\n```\nDoes this feature need data persistence?\n├── No → Local state only (SwiftUI @State, React useState)\n├── Yes, local only → SwiftData (iOS) or localStorage (web)\n├── Yes, synced across devices →\n│   ├── Real-time sync needed?\n│   │   ├── Yes → Supabase Realtime\n│   │   └── No → Supabase REST + manual sync\n│   └── Offline support needed?\n│       ├── Yes → SwiftData + SyncService pattern\n│       └── No → Direct Supabase queries\n└── Yes, shared between users →\n    └── Supabase with appropriate RLS policies\n```\n\n### Authentication Strategy\n\n```\nDoes this feature need auth?\n├── No → Public access\n├── Yes, identified user only →\n│   ├── New app? → Sign in with Apple (iOS) or magic link (web)\n│   ├── Existing app? → Use existing AuthService\n│   └── Trial flow? → One free action, then require sign-in\n└── Yes, with roles/permissions →\n    └── Add roles to profiles table + RLS policies\n```\n\n### AI Integration\n\n```\nDoes this feature use AI?\n├── No → Skip this section\n├── Yes →\n│   ├── Where does AI run?\n│   │   ├── Edge Function (Supabase) → indie-stack:edge-function\n│   │   └── Client-side → Not recommended (API key exposure)\n│   ├── What AI provider?\n│   │   ├── Vision/multimodal → Gemini (good price/performance)\n│   │   ├── Text generation → Claude or GPT-4\n│   │   └── Embeddings → OpenAI text-embedding-3-small\n│   └── Structured output needed?\n│       ├── Yes → Use JSON mode + Zod validation\n│       └── No → Stream response to UI\n```\n\n### Offline-First Decision\n\n```\nShould this work offline?\n├── Core feature that users expect to work anywhere →\n│   └── YES: SwiftData local-first, sync when connected\n├── Real-time collaborative feature →\n│   └── NO: Require connection, show clear offline state\n├── Read-heavy feature (viewing history, stats) →\n│   └── YES: Cache data locally, refresh when connected\n└── Write-heavy feature (creating content) →\n    └── YES: Save locally, queue uploads for later\n```\n\n## Consulting Specialized Agents\n\n**IMPORTANT: Don't guess on domain-specific questions. Consult experts.**\n\nWhen you encounter questions that require specialized knowledge, dispatch the appropriate agent to get informed recommendations before presenting options to the user.\n\n### When to Consult\n\n| Question Type | Agent to Consult | Example Questions |\n|---------------|------------------|-------------------|\n| **UX/User Flow** | `product-ux-strategist` | \"How should onboarding work?\", \"Modal vs sheet?\", \"Where should this button go?\" |\n| **iOS Architecture** | `principal-ios-engineer` | \"Actor vs class?\", \"How to handle state?\", \"Navigation pattern?\" |\n| **Backend Design** | `staff-backend-architect` | \"RLS policy approach?\", \"Edge Function structure?\", \"Caching strategy?\" |\n\n### How to Consult\n\n1. **Formulate the question** with full context about the feature being designed\n2. **Dispatch the agent** with a specific question and the options you're considering\n3. **Get the recommendation** with reasoning\n4. **Present to user** with the agent's recommendation marked as \"(Recommended by [agent])\"\n\n### Example Flow\n\n```\nUser: \"I want to add a delete feature for pours\"\n\nYou (thinking): This involves UX decisions. Let me consult the UX expert.\n\n[Dispatch product-ux-strategist]:\n\"We're designing a delete feature for pour photos. The user wants to delete\npours from their history. What's the best UX pattern for destructive actions\nin a mobile app? Options I'm considering:\n1. Swipe to delete with undo toast\n2. Delete button with confirmation dialog\n3. Edit mode with multi-select delete\nContext: This is a latte art grading app, pours have sentimental value.\"\n\n[Agent returns]: \"Recommend option 1 (swipe + undo) because...\"\n\nYou (to user): \"For the delete interaction, I consulted a UX expert. Here are the options:\n\n**Option 1: Swipe to delete with undo toast** (Recommended by UX strategist)\n- Quick gesture for single deletions\n- 5-second undo window prevents accidents\n- Matches iOS conventions\n\nOption 2: Confirmation dialog\n- More explicit but adds friction\n- Better for truly irreversible actions\n\nOption 3: Edit mode with multi-select\n- Good for bulk operations\n- Overkill for occasional single deletes\n\nThe UX strategist recommends Option 1. What do you think?\"\n```\n\n### Agents Available\n\n- **`product-ux-strategist`** - User flows, onboarding, UI patterns, navigation, platform conventions\n- **`principal-ios-engineer`** - Swift architecture, SwiftUI patterns, SwiftData, concurrency, performance\n- **`staff-backend-architect`** - Supabase, database design, API patterns, caching, AI integration\n\n### Rules for Consultation\n\n1. **Always consult for UX questions** - Don't guess on user experience\n2. **Consult for architecture decisions** - \"How should I structure this?\" → ask the expert\n3. **Don't consult for simple decisions** - \"What should I name this variable?\" → decide yourself\n4. **Present the recommendation clearly** - Mark which option the expert recommended and why\n5. **User can override** - The recommendation is advice, not a mandate\n\n## Key Questions to Ask\n\nWhen brainstorming, make sure to cover:\n\n1. **Platform**: iOS only, web only, or both?\n2. **Auth**: Who can use this? Anonymous, authenticated, or specific roles?\n3. **Data**: Where does data live? Local, synced, or shared?\n4. **Offline**: Should this work without internet?\n5. **AI**: Is AI involved? Where should it run?\n6. **UX**: What's the happy path? What are the error cases? **(Consult UX strategist)**\n\n## After the Design\n\n**Documentation:**\n- Write the validated design to `docs/plans/YYYY-MM-DD-<topic>-design.md`\n- Commit the design document to git\n\n**Implementation (if continuing):**\n- Ask: \"Ready to create the implementation plan?\"\n- Use indie-stack:writing-plans to create detailed implementation plan\n- Use indie-stack:subagent-driven-development to execute\n\n## Key Principles\n\n- **One question at a time** - Don't overwhelm with multiple questions\n- **Multiple choice preferred** - Easier to answer than open-ended when possible\n- **YAGNI ruthlessly** - Remove unnecessary features from all designs\n- **Explore alternatives** - Always propose 2-3 approaches before settling\n- **Incremental validation** - Present design in sections, validate each\n- **Be flexible** - Go back and clarify when something doesn't make sense\n- **Think UX first** - Every feature should have clear user flows"
              },
              {
                "name": "dispatching-parallel-agents",
                "description": "Use when facing 2+ independent tasks that can be worked on without shared state or sequential dependencies",
                "path": "skills/dispatching-parallel-agents/SKILL.md",
                "frontmatter": {
                  "name": "dispatching-parallel-agents",
                  "description": "Use when facing 2+ independent tasks that can be worked on without shared state or sequential dependencies"
                },
                "content": "# Dispatching Parallel Agents\n\n## Overview\n\nWhen you have multiple unrelated failures (different test files, different subsystems, different bugs), investigating them sequentially wastes time. Each investigation is independent and can happen in parallel.\n\n**Core principle:** Dispatch one agent per independent problem domain. Let them work concurrently.\n\n## When to Use\n\n```dot\ndigraph when_to_use {\n    \"Multiple failures?\" [shape=diamond];\n    \"Are they independent?\" [shape=diamond];\n    \"Single agent investigates all\" [shape=box];\n    \"One agent per problem domain\" [shape=box];\n    \"Can they work in parallel?\" [shape=diamond];\n    \"Sequential agents\" [shape=box];\n    \"Parallel dispatch\" [shape=box];\n\n    \"Multiple failures?\" -> \"Are they independent?\" [label=\"yes\"];\n    \"Are they independent?\" -> \"Single agent investigates all\" [label=\"no - related\"];\n    \"Are they independent?\" -> \"Can they work in parallel?\" [label=\"yes\"];\n    \"Can they work in parallel?\" -> \"Parallel dispatch\" [label=\"yes\"];\n    \"Can they work in parallel?\" -> \"Sequential agents\" [label=\"no - shared state\"];\n}\n```\n\n**Use when:**\n- 3+ test files failing with different root causes\n- Multiple subsystems broken independently\n- Each problem can be understood without context from others\n- No shared state between investigations\n\n**Don't use when:**\n- Failures are related (fix one might fix others)\n- Need to understand full system state\n- Agents would interfere with each other\n\n## The Pattern\n\n### 1. Identify Independent Domains\n\nGroup failures by what's broken:\n- File A tests: Tool approval flow\n- File B tests: Batch completion behavior\n- File C tests: Abort functionality\n\nEach domain is independent - fixing tool approval doesn't affect abort tests.\n\n### 2. Create Focused Agent Tasks\n\nEach agent gets:\n- **Specific scope:** One test file or subsystem\n- **Clear goal:** Make these tests pass\n- **Constraints:** Don't change other code\n- **Expected output:** Summary of what you found and fixed\n\n### 3. Dispatch in Parallel\n\n```typescript\n// In Claude Code / AI environment\nTask(\"Fix agent-tool-abort.test.ts failures\")\nTask(\"Fix batch-completion-behavior.test.ts failures\")\nTask(\"Fix tool-approval-race-conditions.test.ts failures\")\n// All three run concurrently\n```\n\n### 4. Review and Integrate\n\nWhen agents return:\n- Read each summary\n- Verify fixes don't conflict\n- Run full test suite\n- Integrate all changes\n\n## Agent Prompt Structure\n\nGood agent prompts are:\n1. **Focused** - One clear problem domain\n2. **Self-contained** - All context needed to understand the problem\n3. **Specific about output** - What should the agent return?\n\n```markdown\nFix the 3 failing tests in src/agents/agent-tool-abort.test.ts:\n\n1. \"should abort tool with partial output capture\" - expects 'interrupted at' in message\n2. \"should handle mixed completed and aborted tools\" - fast tool aborted instead of completed\n3. \"should properly track pendingToolCount\" - expects 3 results but gets 0\n\nThese are timing/race condition issues. Your task:\n\n1. Read the test file and understand what each test verifies\n2. Identify root cause - timing issues or actual bugs?\n3. Fix by:\n   - Replacing arbitrary timeouts with event-based waiting\n   - Fixing bugs in abort implementation if found\n   - Adjusting test expectations if testing changed behavior\n\nDo NOT just increase timeouts - find the real issue.\n\nReturn: Summary of what you found and what you fixed.\n```\n\n## Common Mistakes\n\n**❌ Too broad:** \"Fix all the tests\" - agent gets lost\n**✅ Specific:** \"Fix agent-tool-abort.test.ts\" - focused scope\n\n**❌ No context:** \"Fix the race condition\" - agent doesn't know where\n**✅ Context:** Paste the error messages and test names\n\n**❌ No constraints:** Agent might refactor everything\n**✅ Constraints:** \"Do NOT change production code\" or \"Fix tests only\"\n\n**❌ Vague output:** \"Fix it\" - you don't know what changed\n**✅ Specific:** \"Return summary of root cause and changes\"\n\n## When NOT to Use\n\n**Related failures:** Fixing one might fix others - investigate together first\n**Need full context:** Understanding requires seeing entire system\n**Exploratory debugging:** You don't know what's broken yet\n**Shared state:** Agents would interfere (editing same files, using same resources)\n\n## Real Example from Session\n\n**Scenario:** 6 test failures across 3 files after major refactoring\n\n**Failures:**\n- agent-tool-abort.test.ts: 3 failures (timing issues)\n- batch-completion-behavior.test.ts: 2 failures (tools not executing)\n- tool-approval-race-conditions.test.ts: 1 failure (execution count = 0)\n\n**Decision:** Independent domains - abort logic separate from batch completion separate from race conditions\n\n**Dispatch:**\n```\nAgent 1 → Fix agent-tool-abort.test.ts\nAgent 2 → Fix batch-completion-behavior.test.ts\nAgent 3 → Fix tool-approval-race-conditions.test.ts\n```\n\n**Results:**\n- Agent 1: Replaced timeouts with event-based waiting\n- Agent 2: Fixed event structure bug (threadId in wrong place)\n- Agent 3: Added wait for async tool execution to complete\n\n**Integration:** All fixes independent, no conflicts, full suite green\n\n**Time saved:** 3 problems solved in parallel vs sequentially\n\n## Key Benefits\n\n1. **Parallelization** - Multiple investigations happen simultaneously\n2. **Focus** - Each agent has narrow scope, less context to track\n3. **Independence** - Agents don't interfere with each other\n4. **Speed** - 3 problems solved in time of 1\n\n## Verification\n\nAfter agents return:\n1. **Review each summary** - Understand what changed\n2. **Check for conflicts** - Did agents edit same code?\n3. **Run full suite** - Verify all fixes work together\n4. **Spot check** - Agents can make systematic errors\n\n## Real-World Impact\n\nFrom debugging session (2025-10-03):\n- 6 failures across 3 files\n- 3 agents dispatched in parallel\n- All investigations completed concurrently\n- All fixes integrated successfully\n- Zero conflicts between agent changes"
              },
              {
                "name": "receiving-code-review",
                "description": "Use when receiving code review feedback, before implementing suggestions, especially if feedback seems unclear or technically questionable - requires technical rigor and verification, not performative agreement or blind implementation",
                "path": "skills/receiving-code-review/SKILL.md",
                "frontmatter": {
                  "name": "receiving-code-review",
                  "description": "Use when receiving code review feedback, before implementing suggestions, especially if feedback seems unclear or technically questionable - requires technical rigor and verification, not performative agreement or blind implementation"
                },
                "content": "# Code Review Reception\n\n## Overview\n\nCode review requires technical evaluation, not emotional performance.\n\n**Core principle:** Verify before implementing. Ask before assuming. Technical correctness over social comfort.\n\n## The Response Pattern\n\n```\nWHEN receiving code review feedback:\n\n1. READ: Complete feedback without reacting\n2. UNDERSTAND: Restate requirement in own words (or ask)\n3. VERIFY: Check against codebase reality\n4. EVALUATE: Technically sound for THIS codebase?\n5. RESPOND: Technical acknowledgment or reasoned pushback\n6. IMPLEMENT: One item at a time, test each\n```\n\n## Forbidden Responses\n\n**NEVER:**\n- \"You're absolutely right!\" (explicit CLAUDE.md violation)\n- \"Great point!\" / \"Excellent feedback!\" (performative)\n- \"Let me implement that now\" (before verification)\n\n**INSTEAD:**\n- Restate the technical requirement\n- Ask clarifying questions\n- Push back with technical reasoning if wrong\n- Just start working (actions > words)\n\n## Handling Unclear Feedback\n\n```\nIF any item is unclear:\n  STOP - do not implement anything yet\n  ASK for clarification on unclear items\n\nWHY: Items may be related. Partial understanding = wrong implementation.\n```\n\n**Example:**\n```\nyour human partner: \"Fix 1-6\"\nYou understand 1,2,3,6. Unclear on 4,5.\n\n❌ WRONG: Implement 1,2,3,6 now, ask about 4,5 later\n✅ RIGHT: \"I understand items 1,2,3,6. Need clarification on 4 and 5 before proceeding.\"\n```\n\n## Source-Specific Handling\n\n### From your human partner\n- **Trusted** - implement after understanding\n- **Still ask** if scope unclear\n- **No performative agreement**\n- **Skip to action** or technical acknowledgment\n\n### From External Reviewers\n```\nBEFORE implementing:\n  1. Check: Technically correct for THIS codebase?\n  2. Check: Breaks existing functionality?\n  3. Check: Reason for current implementation?\n  4. Check: Works on all platforms/versions?\n  5. Check: Does reviewer understand full context?\n\nIF suggestion seems wrong:\n  Push back with technical reasoning\n\nIF can't easily verify:\n  Say so: \"I can't verify this without [X]. Should I [investigate/ask/proceed]?\"\n\nIF conflicts with your human partner's prior decisions:\n  Stop and discuss with your human partner first\n```\n\n**your human partner's rule:** \"External feedback - be skeptical, but check carefully\"\n\n## YAGNI Check for \"Professional\" Features\n\n```\nIF reviewer suggests \"implementing properly\":\n  grep codebase for actual usage\n\n  IF unused: \"This endpoint isn't called. Remove it (YAGNI)?\"\n  IF used: Then implement properly\n```\n\n**your human partner's rule:** \"You and reviewer both report to me. If we don't need this feature, don't add it.\"\n\n## Implementation Order\n\n```\nFOR multi-item feedback:\n  1. Clarify anything unclear FIRST\n  2. Then implement in this order:\n     - Blocking issues (breaks, security)\n     - Simple fixes (typos, imports)\n     - Complex fixes (refactoring, logic)\n  3. Test each fix individually\n  4. Verify no regressions\n```\n\n## When To Push Back\n\nPush back when:\n- Suggestion breaks existing functionality\n- Reviewer lacks full context\n- Violates YAGNI (unused feature)\n- Technically incorrect for this stack\n- Legacy/compatibility reasons exist\n- Conflicts with your human partner's architectural decisions\n\n**How to push back:**\n- Use technical reasoning, not defensiveness\n- Ask specific questions\n- Reference working tests/code\n- Involve your human partner if architectural\n\n**Signal if uncomfortable pushing back out loud:** \"Strange things are afoot at the Circle K\"\n\n## Acknowledging Correct Feedback\n\nWhen feedback IS correct:\n```\n✅ \"Fixed. [Brief description of what changed]\"\n✅ \"Good catch - [specific issue]. Fixed in [location].\"\n✅ [Just fix it and show in the code]\n\n❌ \"You're absolutely right!\"\n❌ \"Great point!\"\n❌ \"Thanks for catching that!\"\n❌ \"Thanks for [anything]\"\n❌ ANY gratitude expression\n```\n\n**Why no thanks:** Actions speak. Just fix it. The code itself shows you heard the feedback.\n\n**If you catch yourself about to write \"Thanks\":** DELETE IT. State the fix instead.\n\n## Gracefully Correcting Your Pushback\n\nIf you pushed back and were wrong:\n```\n✅ \"You were right - I checked [X] and it does [Y]. Implementing now.\"\n✅ \"Verified this and you're correct. My initial understanding was wrong because [reason]. Fixing.\"\n\n❌ Long apology\n❌ Defending why you pushed back\n❌ Over-explaining\n```\n\nState the correction factually and move on.\n\n## Common Mistakes\n\n| Mistake | Fix |\n|---------|-----|\n| Performative agreement | State requirement or just act |\n| Blind implementation | Verify against codebase first |\n| Batch without testing | One at a time, test each |\n| Assuming reviewer is right | Check if breaks things |\n| Avoiding pushback | Technical correctness > comfort |\n| Partial implementation | Clarify all items first |\n| Can't verify, proceed anyway | State limitation, ask for direction |\n\n## Real Examples\n\n**Performative Agreement (Bad):**\n```\nReviewer: \"Remove legacy code\"\n❌ \"You're absolutely right! Let me remove that...\"\n```\n\n**Technical Verification (Good):**\n```\nReviewer: \"Remove legacy code\"\n✅ \"Checking... build target is 10.15+, this API needs 13+. Need legacy for backward compat. Current impl has wrong bundle ID - fix it or drop pre-13 support?\"\n```\n\n**YAGNI (Good):**\n```\nReviewer: \"Implement proper metrics tracking with database, date filters, CSV export\"\n✅ \"Grepped codebase - nothing calls this endpoint. Remove it (YAGNI)? Or is there usage I'm missing?\"\n```\n\n**Unclear Item (Good):**\n```\nyour human partner: \"Fix items 1-6\"\nYou understand 1,2,3,6. Unclear on 4,5.\n✅ \"Understand 1,2,3,6. Need clarification on 4 and 5 before implementing.\"\n```\n\n## GitHub Thread Replies\n\nWhen replying to inline review comments on GitHub, reply in the comment thread (`gh api repos/{owner}/{repo}/pulls/{pr}/comments/{id}/replies`), not as a top-level PR comment.\n\n## The Bottom Line\n\n**External feedback = suggestions to evaluate, not orders to follow.**\n\nVerify. Question. Then implement.\n\nNo performative agreement. Technical rigor always."
              },
              {
                "name": "requesting-code-review",
                "description": "Use when completing tasks, implementing major features, or before merging to verify work meets requirements",
                "path": "skills/requesting-code-review/SKILL.md",
                "frontmatter": {
                  "name": "requesting-code-review",
                  "description": "Use when completing tasks, implementing major features, or before merging to verify work meets requirements"
                },
                "content": "# Requesting Code Review\n\nDispatch superpowers:code-reviewer subagent to catch issues before they cascade.\n\n**Core principle:** Review early, review often.\n\n## When to Request Review\n\n**Mandatory:**\n- After each task in subagent-driven development\n- After completing major feature\n- Before merge to main\n\n**Optional but valuable:**\n- When stuck (fresh perspective)\n- Before refactoring (baseline check)\n- After fixing complex bug\n\n## How to Request\n\n**1. Get git SHAs:**\n```bash\nBASE_SHA=$(git rev-parse HEAD~1)  # or origin/main\nHEAD_SHA=$(git rev-parse HEAD)\n```\n\n**2. Dispatch code-reviewer subagent:**\n\nUse Task tool with superpowers:code-reviewer type, fill template at `code-reviewer.md`\n\n**Placeholders:**\n- `{WHAT_WAS_IMPLEMENTED}` - What you just built\n- `{PLAN_OR_REQUIREMENTS}` - What it should do\n- `{BASE_SHA}` - Starting commit\n- `{HEAD_SHA}` - Ending commit\n- `{DESCRIPTION}` - Brief summary\n\n**3. Act on feedback:**\n- Fix Critical issues immediately\n- Fix Important issues before proceeding\n- Note Minor issues for later\n- Push back if reviewer is wrong (with reasoning)\n\n## Example\n\n```\n[Just completed Task 2: Add verification function]\n\nYou: Let me request code review before proceeding.\n\nBASE_SHA=$(git log --oneline | grep \"Task 1\" | head -1 | awk '{print $1}')\nHEAD_SHA=$(git rev-parse HEAD)\n\n[Dispatch superpowers:code-reviewer subagent]\n  WHAT_WAS_IMPLEMENTED: Verification and repair functions for conversation index\n  PLAN_OR_REQUIREMENTS: Task 2 from docs/plans/deployment-plan.md\n  BASE_SHA: a7981ec\n  HEAD_SHA: 3df7661\n  DESCRIPTION: Added verifyIndex() and repairIndex() with 4 issue types\n\n[Subagent returns]:\n  Strengths: Clean architecture, real tests\n  Issues:\n    Important: Missing progress indicators\n    Minor: Magic number (100) for reporting interval\n  Assessment: Ready to proceed\n\nYou: [Fix progress indicators]\n[Continue to Task 3]\n```\n\n## Integration with Workflows\n\n**Subagent-Driven Development:**\n- Review after EACH task\n- Catch issues before they compound\n- Fix before moving to next task\n\n**Executing Plans:**\n- Review after each batch (3 tasks)\n- Get feedback, apply, continue\n\n**Ad-Hoc Development:**\n- Review before merge\n- Review when stuck\n\n## Red Flags\n\n**Never:**\n- Skip review because \"it's simple\"\n- Ignore Critical issues\n- Proceed with unfixed Important issues\n- Argue with valid technical feedback\n\n**If reviewer wrong:**\n- Push back with technical reasoning\n- Show code/tests that prove it works\n- Request clarification\n\nSee template at: requesting-code-review/code-reviewer.md"
              },
              {
                "name": "supabase-setup",
                "description": "Use when setting up Supabase, creating database tables, writing RLS policies, configuring Auth (especially Apple Sign-In), creating storage buckets, writing Edge Functions in TypeScript/Deno, or running migrations. Triggers on \"Supabase setup\", \"RLS policy\", \"Edge Function\", \"database schema\", \"storage bucket\", \"Apple Sign-In auth\".",
                "path": "skills/supabase-setup/SKILL.md",
                "frontmatter": {
                  "name": "supabase-setup",
                  "description": "Use when setting up Supabase, creating database tables, writing RLS policies, configuring Auth (especially Apple Sign-In), creating storage buckets, writing Edge Functions in TypeScript/Deno, or running migrations. Triggers on \"Supabase setup\", \"RLS policy\", \"Edge Function\", \"database schema\", \"storage bucket\", \"Apple Sign-In auth\"."
                },
                "content": "# Supabase Setup\n\nGuide for configuring Supabase backend with proper security, RLS policies, and Edge Functions.\n\n## When to Use\n\n- Starting a new project with Supabase backend\n- Adding new tables or features to existing Supabase project\n- Setting up authentication (especially Apple Sign-In)\n- Creating Edge Functions for AI or external APIs\n- Reviewing security policies\n\n## Project Structure\n\n```\nsupabase/\n├── config.toml              # Local dev config\n├── functions/\n│   └── function-name/       # Edge Function\n│       ├── index.ts         # Request handling\n│       └── helpers.ts       # Utilities\n└── migrations/\n    ├── 001_initial.sql      # Initial tables + RLS\n    ├── 002_storage.sql      # Storage buckets + policies\n    └── 003_new_feature.sql  # Incremental changes\n```\n\n## Database Setup\n\n### 1. Table Design Pattern\n\n```sql\n-- Standard table structure\nCREATE TABLE items (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n\n    -- Your columns\n    title TEXT NOT NULL,\n    status TEXT NOT NULL DEFAULT 'pending',\n    score INTEGER,\n\n    -- Constraints\n    CONSTRAINT valid_status CHECK (status IN ('pending', 'success', 'failed'))\n);\n\n-- Auto-update updated_at\nCREATE TRIGGER update_items_updated_at\n    BEFORE UPDATE ON items\n    FOR EACH ROW\n    EXECUTE FUNCTION moddatetime(updated_at);\n\n-- Index for user queries\nCREATE INDEX items_user_id_idx ON items(user_id);\nCREATE INDEX items_created_at_idx ON items(created_at DESC);\n```\n\n### 2. RLS Policies (CRITICAL)\n\n```sql\n-- Enable RLS (required!)\nALTER TABLE items ENABLE ROW LEVEL SECURITY;\n\n-- Users can only see their own items\nCREATE POLICY \"Users can view own items\"\n    ON items FOR SELECT\n    USING (auth.uid() = user_id);\n\n-- Users can insert their own items\nCREATE POLICY \"Users can insert own items\"\n    ON items FOR INSERT\n    WITH CHECK (auth.uid() = user_id);\n\n-- Users can update their own items\nCREATE POLICY \"Users can update own items\"\n    ON items FOR UPDATE\n    USING (auth.uid() = user_id)\n    WITH CHECK (auth.uid() = user_id);\n\n-- Users can delete their own items\nCREATE POLICY \"Users can delete own items\"\n    ON items FOR DELETE\n    USING (auth.uid() = user_id);\n```\n\n### 3. Profiles Table (Auto-created on signup)\n\n```sql\n-- Profiles table\nCREATE TABLE profiles (\n    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\n    email TEXT,\n    display_name TEXT,\n    avatar_url TEXT,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),\n    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()\n);\n\nALTER TABLE profiles ENABLE ROW LEVEL SECURITY;\n\n-- Users can view and update their own profile\nCREATE POLICY \"Users can view own profile\"\n    ON profiles FOR SELECT\n    USING (auth.uid() = id);\n\nCREATE POLICY \"Users can update own profile\"\n    ON profiles FOR UPDATE\n    USING (auth.uid() = id);\n\n-- Auto-create profile on signup\nCREATE OR REPLACE FUNCTION handle_new_user()\nRETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO profiles (id, email)\n    VALUES (NEW.id, NEW.email);\n    RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nCREATE TRIGGER on_auth_user_created\n    AFTER INSERT ON auth.users\n    FOR EACH ROW\n    EXECUTE FUNCTION handle_new_user();\n```\n\n## Storage Setup\n\n### 1. Create Bucket\n\n```sql\n-- Create storage bucket\nINSERT INTO storage.buckets (id, name, public)\nVALUES ('item-images', 'item-images', false);\n```\n\n### 2. Storage Policies\n\n```sql\n-- Users can upload to their own folder\nCREATE POLICY \"Users can upload own images\"\n    ON storage.objects FOR INSERT\n    WITH CHECK (\n        bucket_id = 'item-images' AND\n        auth.uid()::text = (storage.foldername(name))[1]\n    );\n\n-- Users can view their own images\nCREATE POLICY \"Users can view own images\"\n    ON storage.objects FOR SELECT\n    USING (\n        bucket_id = 'item-images' AND\n        auth.uid()::text = (storage.foldername(name))[1]\n    );\n\n-- Users can delete their own images\nCREATE POLICY \"Users can delete own images\"\n    ON storage.objects FOR DELETE\n    USING (\n        bucket_id = 'item-images' AND\n        auth.uid()::text = (storage.foldername(name))[1]\n    );\n```\n\n### 3. File Path Convention\n\n```\n{bucket}/{user_id}/{item_id}.{ext}\n```\n\nExample: `item-images/abc123/def456.jpg`\n\n## Authentication\n\n### Apple Sign-In Setup\n\n1. **Supabase Dashboard:**\n   - Auth → Providers → Apple\n   - Enable Apple provider\n   - Add Service ID and Team ID\n\n2. **config.toml (local dev):**\n```toml\n[auth.external.apple]\nenabled = true\nclient_id = \"your.service.id\"\n```\n\n3. **iOS App:**\n```swift\n// Use Supabase Swift SDK\nlet credentials = try await supabase.auth.signInWithApple()\n```\n\n### Session Handling\n\n- Access tokens expire (default: 1 hour)\n- Refresh tokens stored in Keychain\n- SDK handles refresh automatically\n- Handle 401 errors with manual refresh fallback\n\n## Edge Functions\n\n### 1. Basic Structure\n\n```typescript\n// supabase/functions/process-item/index.ts\nimport { serve } from \"https://deno.land/std@0.168.0/http/server.ts\"\nimport { createClient } from \"https://esm.sh/@supabase/supabase-js@2\"\n\nconst corsHeaders = {\n  'Access-Control-Allow-Origin': '*',\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\n}\n\nserve(async (req) => {\n  // Handle CORS preflight\n  if (req.method === 'OPTIONS') {\n    return new Response('ok', { headers: corsHeaders })\n  }\n\n  try {\n    // Verify auth\n    const authHeader = req.headers.get('Authorization')\n    if (!authHeader) {\n      return new Response(\n        JSON.stringify({ error: 'Missing authorization' }),\n        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      )\n    }\n\n    // Create authenticated client\n    const supabase = createClient(\n      Deno.env.get('SUPABASE_URL') ?? '',\n      Deno.env.get('SUPABASE_ANON_KEY') ?? '',\n      { global: { headers: { Authorization: authHeader } } }\n    )\n\n    // Verify user\n    const { data: { user }, error: userError } = await supabase.auth.getUser()\n    if (userError || !user) {\n      return new Response(\n        JSON.stringify({ error: 'Invalid token' }),\n        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n      )\n    }\n\n    // Parse request\n    const { itemId, data } = await req.json()\n\n    // Your logic here\n    const result = await processItem(itemId, data)\n\n    return new Response(\n      JSON.stringify(result),\n      { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n\n  } catch (error) {\n    console.error('Error:', error)\n    return new Response(\n      JSON.stringify({ error: 'Internal server error' }),\n      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }\n    )\n  }\n})\n```\n\n### 2. Calling External APIs (e.g., Gemini)\n\n```typescript\n// Get API key from environment\nconst GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY')\n\nasync function callGemini(prompt: string, imageBase64: string) {\n  const response = await fetch(\n    `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`,\n    {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        contents: [{\n          parts: [\n            { text: prompt },\n            { inline_data: { mime_type: 'image/jpeg', data: imageBase64 } }\n          ]\n        }],\n        generationConfig: {\n          responseMimeType: 'application/json'\n        }\n      })\n    }\n  )\n\n  if (!response.ok) {\n    throw new Error(`Gemini API error: ${response.status}`)\n  }\n\n  const result = await response.json()\n  return JSON.parse(result.candidates[0].content.parts[0].text)\n}\n```\n\n### 3. Setting Secrets\n\n```bash\n# Set secret in Supabase\nsupabase secrets set GEMINI_API_KEY=your-key-here\n\n# List secrets\nsupabase secrets list\n```\n\n## Migration Workflow\n\n### Creating Migrations\n\n```bash\n# Create new migration\nsupabase migration new add_feature_x\n\n# Edit the generated file\n# supabase/migrations/YYYYMMDDHHMMSS_add_feature_x.sql\n```\n\n### Applying Migrations\n\n```bash\n# Local development\nsupabase db reset  # Resets and applies all migrations\n\n# Push to remote\nsupabase db push\n\n# Check status\nsupabase db diff\n```\n\n### Migration Best Practices\n\n- One logical change per migration\n- Always include RLS policies with new tables\n- Use transactions for complex changes\n- Test migrations locally before pushing\n\n## Security Checklist\n\n```\n[ ] RLS enabled on ALL tables\n[ ] Policies cover SELECT, INSERT, UPDATE, DELETE\n[ ] Storage policies match table patterns\n[ ] service_role key NEVER in client code\n[ ] API keys in environment variables\n[ ] Edge Functions verify auth before processing\n[ ] No sensitive data in error messages\n[ ] Indexes on frequently queried columns\n```\n\n## Common Commands\n\n```bash\n# Start local Supabase\nsupabase start\n\n# Stop local Supabase\nsupabase stop\n\n# Deploy Edge Function\nsupabase functions deploy function-name\n\n# Serve Edge Function locally\nsupabase functions serve function-name\n\n# Generate TypeScript types\nsupabase gen types typescript --local > types.ts\n\n# View logs\nsupabase functions logs function-name\n```"
              },
              {
                "name": "swift-ios-app",
                "description": "Use when creating iOS apps, setting up Xcode projects, designing app architecture, implementing SwiftUI views, using SwiftData models, adding Swift 6 concurrency with actors, or integrating Supabase backend. Triggers on \"new iOS app\", \"Swift architecture\", \"SwiftData setup\", \"actor pattern\", \"iOS project structure\".",
                "path": "skills/swift-ios-app/SKILL.md",
                "frontmatter": {
                  "name": "swift-ios-app",
                  "description": "Use when creating iOS apps, setting up Xcode projects, designing app architecture, implementing SwiftUI views, using SwiftData models, adding Swift 6 concurrency with actors, or integrating Supabase backend. Triggers on \"new iOS app\", \"Swift architecture\", \"SwiftData setup\", \"actor pattern\", \"iOS project structure\"."
                },
                "content": "# Swift iOS App Architecture\n\nGuide for building iOS apps with SwiftUI, SwiftData, Swift 6 concurrency, and Supabase backend.\n\n## When to Use\n\n- Starting a new iOS project\n- Understanding existing iOS app architecture\n- Adding a major new feature that needs architectural guidance\n- Reviewing project structure decisions\n\n## Project Structure\n\n```\nAppName/\n├── AppNameApp.swift          # App entry, configures appearance and SwiftData\n├── Models/\n│   ├── Item.swift            # SwiftData models (local persistence)\n│   ├── ItemResult.swift      # Enum: pending/success/failed states\n│   └── Enums/                # Supporting enums (ItemType, etc.)\n├── Services/\n│   ├── AuthService.swift     # @Observable auth state, trial flow\n│   ├── SupabaseClient.swift  # Actor for auth/token management\n│   ├── SupabaseService.swift # Actor: storage upload and DB sync\n│   ├── SyncService.swift     # Actor: bidirectional sync\n│   ├── ItemService.swift     # Actor: business logic for items\n│   ├── ImageManager.swift    # Local image caching\n│   ├── NetworkMonitor.swift  # NWPathMonitor for connectivity\n│   └── PermissionsManager.swift # Camera, photos, etc.\n├── Utilities/\n│   ├── Constants.swift       # Supabase URL, anon key\n│   └── Theme.swift           # Design system, colors, typography\n├── ViewModels/\n│   └── FeatureViewModel.swift # Complex feature state machines\n└── Views/\n    ├── RootView.swift        # Routes based on auth state\n    ├── MainTabView.swift     # Tab navigation\n    ├── SplashView.swift      # Launch animation\n    ├── Auth/                 # SignInView, TrialPrompt\n    ├── Feature/              # Feature-specific views\n    ├── Components/           # Reusable: badges, cards, empty states\n    ├── Onboarding/           # OnboardingFlow\n    └── Settings/             # SettingsView\n```\n\n## Key Patterns\n\n### 1. Swift 6 Concurrency\n\n**Services as Actors:**\n```swift\nactor SupabaseService {\n    private let client: SupabaseClient\n\n    func uploadImage(_ data: Data, path: String) async throws -> URL {\n        // Actor-isolated state is thread-safe\n    }\n}\n```\n\n**UI-Bound State with @MainActor:**\n```swift\n@MainActor @Observable\nfinal class AuthService {\n    var isAuthenticated = false\n    var currentUser: User?\n\n    func signIn() async throws {\n        // All state mutations happen on MainActor\n    }\n}\n```\n\n**Sendable Data Transfer:**\n```swift\nstruct ItemSyncData: Sendable {\n    let id: UUID\n    let title: String\n    let createdAt: Date\n}\n```\n\n**Bridging SwiftData:**\n```swift\n@preconcurrency import SwiftData\n\n@Model\nfinal class Item: @unchecked Sendable {\n    // All access via MainActor\n}\n```\n\n### 2. SwiftData Models\n\n**Model with Denormalized Fields:**\n```swift\n@Model\nfinal class Item {\n    var id: UUID\n    var createdAt: Date\n    var title: String\n\n    // Denormalized for efficient queries\n    var resultType: String  // \"pending\", \"success\", \"failed\"\n    var score: Int?\n\n    // Full result stored as associated value\n    var result: ItemResult = .pending\n\n    init(title: String) {\n        self.id = UUID()\n        self.createdAt = Date()\n        self.title = title\n        self.resultType = \"pending\"\n    }\n}\n```\n\n**Result Enum Pattern:**\n```swift\nenum ItemResult: Codable, Equatable {\n    case pending\n    case success(SuccessData)\n    case failed(String)\n}\n```\n\n### 3. Authentication Flow\n\n**AuthService Structure:**\n```swift\n@MainActor @Observable\nfinal class AuthService {\n    private let supabaseClient: SupabaseClient\n\n    var isAuthenticated = false\n    var isTrialUsed = false\n    var currentUser: User?\n\n    func checkAuthState() async {\n        // Check Keychain for existing session\n    }\n\n    func signInWithApple() async throws {\n        // Apple Sign-In → Supabase Auth\n    }\n\n    func signOut() async {\n        // Clear Keychain, reset state\n    }\n}\n```\n\n**Root View Routing:**\n```swift\nstruct RootView: View {\n    @Environment(AuthService.self) var authService\n\n    var body: some View {\n        Group {\n            if authService.isAuthenticated {\n                MainTabView()\n            } else {\n                SignInView()\n            }\n        }\n    }\n}\n```\n\n### 4. Data Sync Pattern\n\n**Upload on Create:**\n```swift\n// In ViewModel after creating local item\nTask {\n    await supabaseService.syncItem(item)\n}\n```\n\n**Download on Login:**\n```swift\n// In AuthService after successful login\nawait syncService.syncRemoteItems()\n```\n\n**Conflict Resolution:**\n```swift\n// Use upsert to handle conflicts\nfunc syncItem(_ item: Item) async throws {\n    try await client\n        .from(\"items\")\n        .upsert(item.toRemoteData(), onConflict: \"id\")\n        .execute()\n}\n```\n\n### 5. Token Refresh Pattern\n\n**Automatic 401 Retry:**\n```swift\nfunc makeAuthenticatedRequest<T>(_ request: () async throws -> T) async throws -> T {\n    do {\n        return try await request()\n    } catch let error as HTTPError where error.statusCode == 401 {\n        try await refreshToken()\n        return try await request()  // Retry once\n    }\n}\n```\n\n## Design System Integration\n\n**Theme.swift Structure:**\n```swift\n// Colors\nextension Color {\n    static let appAccent = Color(\"AccentColor\")\n    static let cardBackground = Color(\"CardBackground\")\n}\n\n// Typography\nextension View {\n    func appHeadline() -> some View {\n        self.font(.system(.headline, design: .rounded))\n    }\n}\n\n// View Modifiers\nextension View {\n    func appCard() -> some View {\n        self.padding()\n            .background(Color.cardBackground)\n            .cornerRadius(12)\n    }\n}\n\n// Haptics\nstruct HapticManager {\n    static func impact(_ style: UIImpactFeedbackGenerator.FeedbackStyle) {\n        let generator = UIImpactFeedbackGenerator(style: style)\n        generator.impactOccurred()\n    }\n}\n```\n\n## File Naming Conventions\n\n| Type | Convention | Example |\n|------|------------|---------|\n| SwiftData Model | Singular noun | `Pour.swift` |\n| Service Actor | `*Service.swift` | `GradingService.swift` |\n| View | `*View.swift` | `CaptureView.swift` |\n| ViewModel | `*ViewModel.swift` | `CaptureViewModel.swift` |\n| Result Enum | `*Result.swift` | `PourResult.swift` |\n| Manager | `*Manager.swift` | `ImageManager.swift` |\n\n## Common Gotchas\n\n### SwiftData + Actors\n- Never pass `ModelContext` across actor boundaries\n- Use `@preconcurrency import SwiftData`\n- Mark models as `@unchecked Sendable` if accessed only via MainActor\n\n### Swift 6 Concurrency\n- Use `nonisolated` for pure functions that don't access actor state\n- Check `SWIFT_APPROACHABLE_CONCURRENCY = YES` build setting\n- Use `Sendable` structs for data transfer between actors\n\n### Supabase Auth\n- Store refresh tokens in Keychain, not UserDefaults\n- Handle token refresh on 401 automatically\n- Use service_role key only in Edge Functions, never in app\n\n## Checklist: New iOS App\n\n```\n[ ] Create Xcode project with SwiftData\n[ ] Set up folder structure (Models, Services, Views, etc.)\n[ ] Add Supabase Swift SDK\n[ ] Create Constants.swift with Supabase URL/key\n[ ] Create Theme.swift with design system\n[ ] Set up AuthService with Apple Sign-In\n[ ] Create SupabaseClient actor\n[ ] Add NetworkMonitor for connectivity\n[ ] Create RootView with auth routing\n[ ] Set up MainTabView navigation\n[ ] Enable Swift 6 strict concurrency mode\n```"
              },
              {
                "name": "systematic-debugging",
                "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes",
                "path": "skills/systematic-debugging/SKILL.md",
                "frontmatter": {
                  "name": "systematic-debugging",
                  "description": "Use when encountering any bug, test failure, or unexpected behavior, before proposing fixes"
                },
                "content": "# Systematic Debugging\n\n## Overview\n\nRandom fixes waste time and create new bugs. Quick patches mask underlying issues.\n\n**Core principle:** ALWAYS find root cause before attempting fixes. Symptom fixes are failure.\n\n**Violating the letter of this process is violating the spirit of debugging.**\n\n## The Iron Law\n\n```\nNO FIXES WITHOUT ROOT CAUSE INVESTIGATION FIRST\n```\n\nIf you haven't completed Phase 1, you cannot propose fixes.\n\n## When to Use\n\nUse for ANY technical issue:\n- Test failures\n- Bugs in production\n- Unexpected behavior\n- Performance problems\n- Build failures\n- Integration issues\n\n**Use this ESPECIALLY when:**\n- Under time pressure (emergencies make guessing tempting)\n- \"Just one quick fix\" seems obvious\n- You've already tried multiple fixes\n- Previous fix didn't work\n- You don't fully understand the issue\n\n**Don't skip when:**\n- Issue seems simple (simple bugs have root causes too)\n- You're in a hurry (rushing guarantees rework)\n- Manager wants it fixed NOW (systematic is faster than thrashing)\n\n## The Four Phases\n\nYou MUST complete each phase before proceeding to the next.\n\n### Phase 1: Root Cause Investigation\n\n**BEFORE attempting ANY fix:**\n\n1. **Read Error Messages Carefully**\n   - Don't skip past errors or warnings\n   - They often contain the exact solution\n   - Read stack traces completely\n   - Note line numbers, file paths, error codes\n\n2. **Reproduce Consistently**\n   - Can you trigger it reliably?\n   - What are the exact steps?\n   - Does it happen every time?\n   - If not reproducible → gather more data, don't guess\n\n3. **Check Recent Changes**\n   - What changed that could cause this?\n   - Git diff, recent commits\n   - New dependencies, config changes\n   - Environmental differences\n\n4. **Gather Evidence in Multi-Component Systems**\n\n   **WHEN system has multiple components (CI → build → signing, API → service → database):**\n\n   **BEFORE proposing fixes, add diagnostic instrumentation:**\n   ```\n   For EACH component boundary:\n     - Log what data enters component\n     - Log what data exits component\n     - Verify environment/config propagation\n     - Check state at each layer\n\n   Run once to gather evidence showing WHERE it breaks\n   THEN analyze evidence to identify failing component\n   THEN investigate that specific component\n   ```\n\n   **Example (multi-layer system):**\n   ```bash\n   # Layer 1: Workflow\n   echo \"=== Secrets available in workflow: ===\"\n   echo \"IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}\"\n\n   # Layer 2: Build script\n   echo \"=== Env vars in build script: ===\"\n   env | grep IDENTITY || echo \"IDENTITY not in environment\"\n\n   # Layer 3: Signing script\n   echo \"=== Keychain state: ===\"\n   security list-keychains\n   security find-identity -v\n\n   # Layer 4: Actual signing\n   codesign --sign \"$IDENTITY\" --verbose=4 \"$APP\"\n   ```\n\n   **This reveals:** Which layer fails (secrets → workflow ✓, workflow → build ✗)\n\n5. **Trace Data Flow**\n\n   **WHEN error is deep in call stack:**\n\n   See `root-cause-tracing.md` in this directory for the complete backward tracing technique.\n\n   **Quick version:**\n   - Where does bad value originate?\n   - What called this with bad value?\n   - Keep tracing up until you find the source\n   - Fix at source, not at symptom\n\n### Phase 2: Pattern Analysis\n\n**Find the pattern before fixing:**\n\n1. **Find Working Examples**\n   - Locate similar working code in same codebase\n   - What works that's similar to what's broken?\n\n2. **Compare Against References**\n   - If implementing pattern, read reference implementation COMPLETELY\n   - Don't skim - read every line\n   - Understand the pattern fully before applying\n\n3. **Identify Differences**\n   - What's different between working and broken?\n   - List every difference, however small\n   - Don't assume \"that can't matter\"\n\n4. **Understand Dependencies**\n   - What other components does this need?\n   - What settings, config, environment?\n   - What assumptions does it make?\n\n### Phase 3: Hypothesis and Testing\n\n**Scientific method:**\n\n1. **Form Single Hypothesis**\n   - State clearly: \"I think X is the root cause because Y\"\n   - Write it down\n   - Be specific, not vague\n\n2. **Test Minimally**\n   - Make the SMALLEST possible change to test hypothesis\n   - One variable at a time\n   - Don't fix multiple things at once\n\n3. **Verify Before Continuing**\n   - Did it work? Yes → Phase 4\n   - Didn't work? Form NEW hypothesis\n   - DON'T add more fixes on top\n\n4. **When You Don't Know**\n   - Say \"I don't understand X\"\n   - Don't pretend to know\n   - Ask for help\n   - Research more\n\n### Phase 4: Implementation\n\n**Fix the root cause, not the symptom:**\n\n1. **Create Failing Test Case**\n   - Simplest possible reproduction\n   - Automated test if possible\n   - One-off test script if no framework\n   - MUST have before fixing\n   - Use the `superpowers:test-driven-development` skill for writing proper failing tests\n\n2. **Implement Single Fix**\n   - Address the root cause identified\n   - ONE change at a time\n   - No \"while I'm here\" improvements\n   - No bundled refactoring\n\n3. **Verify Fix**\n   - Test passes now?\n   - No other tests broken?\n   - Issue actually resolved?\n\n4. **If Fix Doesn't Work**\n   - STOP\n   - Count: How many fixes have you tried?\n   - If < 3: Return to Phase 1, re-analyze with new information\n   - **If ≥ 3: STOP and question the architecture (step 5 below)**\n   - DON'T attempt Fix #4 without architectural discussion\n\n5. **If 3+ Fixes Failed: Question Architecture**\n\n   **Pattern indicating architectural problem:**\n   - Each fix reveals new shared state/coupling/problem in different place\n   - Fixes require \"massive refactoring\" to implement\n   - Each fix creates new symptoms elsewhere\n\n   **STOP and question fundamentals:**\n   - Is this pattern fundamentally sound?\n   - Are we \"sticking with it through sheer inertia\"?\n   - Should we refactor architecture vs. continue fixing symptoms?\n\n   **Discuss with your human partner before attempting more fixes**\n\n   This is NOT a failed hypothesis - this is a wrong architecture.\n\n## Red Flags - STOP and Follow Process\n\nIf you catch yourself thinking:\n- \"Quick fix for now, investigate later\"\n- \"Just try changing X and see if it works\"\n- \"Add multiple changes, run tests\"\n- \"Skip the test, I'll manually verify\"\n- \"It's probably X, let me fix that\"\n- \"I don't fully understand but this might work\"\n- \"Pattern says X but I'll adapt it differently\"\n- \"Here are the main problems: [lists fixes without investigation]\"\n- Proposing solutions before tracing data flow\n- **\"One more fix attempt\" (when already tried 2+)**\n- **Each fix reveals new problem in different place**\n\n**ALL of these mean: STOP. Return to Phase 1.**\n\n**If 3+ fixes failed:** Question the architecture (see Phase 4.5)\n\n## your human partner's Signals You're Doing It Wrong\n\n**Watch for these redirections:**\n- \"Is that not happening?\" - You assumed without verifying\n- \"Will it show us...?\" - You should have added evidence gathering\n- \"Stop guessing\" - You're proposing fixes without understanding\n- \"Ultrathink this\" - Question fundamentals, not just symptoms\n- \"We're stuck?\" (frustrated) - Your approach isn't working\n\n**When you see these:** STOP. Return to Phase 1.\n\n## Common Rationalizations\n\n| Excuse | Reality |\n|--------|---------|\n| \"Issue is simple, don't need process\" | Simple issues have root causes too. Process is fast for simple bugs. |\n| \"Emergency, no time for process\" | Systematic debugging is FASTER than guess-and-check thrashing. |\n| \"Just try this first, then investigate\" | First fix sets the pattern. Do it right from the start. |\n| \"I'll write test after confirming fix works\" | Untested fixes don't stick. Test first proves it. |\n| \"Multiple fixes at once saves time\" | Can't isolate what worked. Causes new bugs. |\n| \"Reference too long, I'll adapt the pattern\" | Partial understanding guarantees bugs. Read it completely. |\n| \"I see the problem, let me fix it\" | Seeing symptoms ≠ understanding root cause. |\n| \"One more fix attempt\" (after 2+ failures) | 3+ failures = architectural problem. Question pattern, don't fix again. |\n\n## Quick Reference\n\n| Phase | Key Activities | Success Criteria |\n|-------|---------------|------------------|\n| **1. Root Cause** | Read errors, reproduce, check changes, gather evidence | Understand WHAT and WHY |\n| **2. Pattern** | Find working examples, compare | Identify differences |\n| **3. Hypothesis** | Form theory, test minimally | Confirmed or new hypothesis |\n| **4. Implementation** | Create test, fix, verify | Bug resolved, tests pass |\n\n## When Process Reveals \"No Root Cause\"\n\nIf systematic investigation reveals issue is truly environmental, timing-dependent, or external:\n\n1. You've completed the process\n2. Document what you investigated\n3. Implement appropriate handling (retry, timeout, error message)\n4. Add monitoring/logging for future investigation\n\n**But:** 95% of \"no root cause\" cases are incomplete investigation.\n\n## Supporting Techniques\n\nThese techniques are part of systematic debugging and available in this directory:\n\n- **`root-cause-tracing.md`** - Trace bugs backward through call stack to find original trigger\n- **`defense-in-depth.md`** - Add validation at multiple layers after finding root cause\n- **`condition-based-waiting.md`** - Replace arbitrary timeouts with condition polling\n\n**Related skills:**\n- **superpowers:test-driven-development** - For creating failing test case (Phase 4, Step 1)\n- **superpowers:verification-before-completion** - Verify fix worked before claiming success\n\n## Real-World Impact\n\nFrom debugging sessions:\n- Systematic approach: 15-30 minutes to fix\n- Random fixes approach: 2-3 hours of thrashing\n- First-time fix rate: 95% vs 40%\n- New bugs introduced: Near zero vs common"
              },
              {
                "name": "testing-flexible",
                "description": "Use when implementing features to write effective tests. Encourages test-first but allows prototyping.",
                "path": "skills/testing-flexible/SKILL.md",
                "frontmatter": {
                  "name": "testing-flexible",
                  "description": "Use when implementing features to write effective tests. Encourages test-first but allows prototyping."
                },
                "content": "# Flexible Testing\n\n## Overview\n\nWrite tests for critical paths and complex logic. Test-first is encouraged but not mandatory.\n\n**Core principle:** Tests should give you confidence, not slow you down.\n\n## When to Use\n\n**Strong recommendation (test-first):**\n- Complex business logic\n- Edge cases and error handling\n- Security-critical code\n- Bug fixes (test reproduces bug first)\n- Public API surfaces\n\n**Optional (test-after or skip):**\n- UI/view code that changes frequently\n- Prototype/exploration phase\n- Configuration and setup\n- Generated code\n- Simple CRUD operations\n\n## Two Modes\n\n### Production Mode (Default)\n\nWrite tests for critical functionality. Test-first encouraged.\n\n```\n1. Write failing test for critical behavior\n2. Implement minimal code to pass\n3. Add tests for edge cases\n4. Refactor with confidence\n```\n\n### Prototype Mode\n\nExploring ideas? Skip tests temporarily.\n\n```\n1. Build the prototype\n2. Get feedback, iterate\n3. Once design is stable: write tests\n4. Or: throw away prototype, rebuild with tests\n```\n\n**To enter prototype mode:** Tell Claude \"I'm prototyping\" or \"skip tests for now\"\n\n## What to Test\n\n### Always Test\n\n| Area | Why |\n|------|-----|\n| Business logic | Core value of your app |\n| Data transformations | Easy to get wrong |\n| API responses | Contract with clients |\n| Auth/permissions | Security critical |\n| Error handling | Users will hit edge cases |\n\n### Consider Testing\n\n| Area | When |\n|------|------|\n| UI components | When logic is complex |\n| Integration points | When external APIs involved |\n| Performance | When SLAs matter |\n\n### Usually Skip\n\n| Area | Why |\n|------|-----|\n| UI layout | Changes frequently, hard to test |\n| Third-party code | Already tested |\n| Trivial getters/setters | No logic to test |\n| Generated code | Trust the generator |\n\n## Test-First Pattern\n\nWhen you do write test-first, follow RED-GREEN-REFACTOR:\n\n### RED - Failing Test\n```typescript\ntest('retries failed operations 3 times', async () => {\n  let attempts = 0;\n  const operation = () => {\n    attempts++;\n    if (attempts < 3) throw new Error('fail');\n    return 'success';\n  };\n\n  const result = await retryOperation(operation);\n\n  expect(result).toBe('success');\n  expect(attempts).toBe(3);\n});\n```\n\n### GREEN - Make It Pass\n```typescript\nasync function retryOperation<T>(fn: () => Promise<T>): Promise<T> {\n  for (let i = 0; i < 3; i++) {\n    try {\n      return await fn();\n    } catch (e) {\n      if (i === 2) throw e;\n    }\n  }\n  throw new Error('unreachable');\n}\n```\n\n### REFACTOR - Clean Up\nOnce tests pass, improve the code while keeping tests green.\n\n## Swift/XCTest Specifics\n\n### Basic Test Structure\n```swift\nimport XCTest\n@testable import YourApp\n\nfinal class GradingServiceTests: XCTestCase {\n\n    func test_gradeReturnsScoreForValidImage() async throws {\n        let service = GradingService()\n        let result = try await service.grade(image: testImage)\n\n        XCTAssertNotNil(result.score)\n        XCTAssertGreaterThan(result.score!, 0)\n    }\n\n    func test_gradeThrowsForInvalidImage() async {\n        let service = GradingService()\n\n        do {\n            _ = try await service.grade(image: Data())\n            XCTFail(\"Expected error\")\n        } catch {\n            // Expected\n        }\n    }\n}\n```\n\n### Testing Actors\n```swift\nfunc test_actorStateIsolated() async {\n    let service = SyncService()\n\n    // Actor methods are async\n    await service.sync(item: testItem)\n\n    let synced = await service.pendingItems\n    XCTAssertTrue(synced.isEmpty)\n}\n```\n\n### Testing @Observable\n```swift\nfunc test_authStateUpdatesOnSignIn() async throws {\n    let authService = AuthService()\n\n    XCTAssertFalse(authService.isAuthenticated)\n\n    try await authService.signIn(with: mockCredentials)\n\n    XCTAssertTrue(authService.isAuthenticated)\n}\n```\n\n## TypeScript/Vitest Specifics\n\n### Basic Test Structure\n```typescript\nimport { describe, it, expect } from 'vitest'\nimport { gradeImage } from './grading'\n\ndescribe('gradeImage', () => {\n  it('returns score for valid image', async () => {\n    const result = await gradeImage(testImageBase64)\n\n    expect(result.score).toBeDefined()\n    expect(result.score).toBeGreaterThan(0)\n  })\n\n  it('throws for invalid image', async () => {\n    await expect(gradeImage('')).rejects.toThrow()\n  })\n})\n```\n\n### Testing Edge Functions\n```typescript\nimport { createClient } from '@supabase/supabase-js'\n\ndescribe('process-item function', () => {\n  it('returns 401 without auth', async () => {\n    const response = await fetch(`${FUNCTION_URL}/process-item`, {\n      method: 'POST',\n      body: JSON.stringify({ itemId: '123' })\n    })\n\n    expect(response.status).toBe(401)\n  })\n})\n```\n\n## Good Tests\n\n| Quality | Good | Bad |\n|---------|------|-----|\n| **Focused** | One behavior per test | `test('validates, saves, and notifies')` |\n| **Readable** | Clear name describes what's tested | `test('test1')` |\n| **Independent** | No shared state between tests | Tests fail in isolation |\n| **Fast** | Milliseconds, not seconds | Slow tests get skipped |\n\n## When Tests Are Hard\n\nIf testing is painful, the design might be the problem:\n\n| Symptom | Likely Cause | Fix |\n|---------|--------------|-----|\n| Need many mocks | Too coupled | Dependency injection |\n| Huge setup | Complex object graph | Simplify design |\n| Flaky tests | Hidden state/timing | Make dependencies explicit |\n| Can't test in isolation | God objects | Break into smaller units |\n\n## Checklist Before Shipping\n\n```\n[ ] Critical paths have tests\n[ ] Edge cases covered\n[ ] Error cases handled\n[ ] Tests pass\n[ ] No flaky tests\n```\n\nDon't need 100% coverage. Need confidence in critical functionality."
              },
              {
                "name": "verification-before-completion",
                "description": "Use when about to claim work is complete, fixed, or passing, before committing or creating PRs - requires running verification commands and confirming output before making any success claims; evidence before assertions always",
                "path": "skills/verification-before-completion/SKILL.md",
                "frontmatter": {
                  "name": "verification-before-completion",
                  "description": "Use when about to claim work is complete, fixed, or passing, before committing or creating PRs - requires running verification commands and confirming output before making any success claims; evidence before assertions always"
                },
                "content": "# Verification Before Completion\n\n## Overview\n\nClaiming work is complete without verification is dishonesty, not efficiency.\n\n**Core principle:** Evidence before claims, always.\n\n**Violating the letter of this rule is violating the spirit of this rule.**\n\n## The Iron Law\n\n```\nNO COMPLETION CLAIMS WITHOUT FRESH VERIFICATION EVIDENCE\n```\n\nIf you haven't run the verification command in this message, you cannot claim it passes.\n\n## The Gate Function\n\n```\nBEFORE claiming any status or expressing satisfaction:\n\n1. IDENTIFY: What command proves this claim?\n2. RUN: Execute the FULL command (fresh, complete)\n3. READ: Full output, check exit code, count failures\n4. VERIFY: Does output confirm the claim?\n   - If NO: State actual status with evidence\n   - If YES: State claim WITH evidence\n5. ONLY THEN: Make the claim\n\nSkip any step = lying, not verifying\n```\n\n## Common Failures\n\n| Claim | Requires | Not Sufficient |\n|-------|----------|----------------|\n| Tests pass | Test command output: 0 failures | Previous run, \"should pass\" |\n| Linter clean | Linter output: 0 errors | Partial check, extrapolation |\n| Build succeeds | Build command: exit 0 | Linter passing, logs look good |\n| Bug fixed | Test original symptom: passes | Code changed, assumed fixed |\n| Regression test works | Red-green cycle verified | Test passes once |\n| Agent completed | VCS diff shows changes | Agent reports \"success\" |\n| Requirements met | Line-by-line checklist | Tests passing |\n\n## Red Flags - STOP\n\n- Using \"should\", \"probably\", \"seems to\"\n- Expressing satisfaction before verification (\"Great!\", \"Perfect!\", \"Done!\", etc.)\n- About to commit/push/PR without verification\n- Trusting agent success reports\n- Relying on partial verification\n- Thinking \"just this once\"\n- Tired and wanting work over\n- **ANY wording implying success without having run verification**\n\n## Rationalization Prevention\n\n| Excuse | Reality |\n|--------|---------|\n| \"Should work now\" | RUN the verification |\n| \"I'm confident\" | Confidence ≠ evidence |\n| \"Just this once\" | No exceptions |\n| \"Linter passed\" | Linter ≠ compiler |\n| \"Agent said success\" | Verify independently |\n| \"I'm tired\" | Exhaustion ≠ excuse |\n| \"Partial check is enough\" | Partial proves nothing |\n| \"Different words so rule doesn't apply\" | Spirit over letter |\n\n## Key Patterns\n\n**Tests:**\n```\n✅ [Run test command] [See: 34/34 pass] \"All tests pass\"\n❌ \"Should pass now\" / \"Looks correct\"\n```\n\n**Regression tests (TDD Red-Green):**\n```\n✅ Write → Run (pass) → Revert fix → Run (MUST FAIL) → Restore → Run (pass)\n❌ \"I've written a regression test\" (without red-green verification)\n```\n\n**Build:**\n```\n✅ [Run build] [See: exit 0] \"Build passes\"\n❌ \"Linter passed\" (linter doesn't check compilation)\n```\n\n**Requirements:**\n```\n✅ Re-read plan → Create checklist → Verify each → Report gaps or completion\n❌ \"Tests pass, phase complete\"\n```\n\n**Agent delegation:**\n```\n✅ Agent reports success → Check VCS diff → Verify changes → Report actual state\n❌ Trust agent report\n```\n\n## Why This Matters\n\nFrom 24 failure memories:\n- your human partner said \"I don't believe you\" - trust broken\n- Undefined functions shipped - would crash\n- Missing requirements shipped - incomplete features\n- Time wasted on false completion → redirect → rework\n- Violates: \"Honesty is a core value. If you lie, you'll be replaced.\"\n\n## When To Apply\n\n**ALWAYS before:**\n- ANY variation of success/completion claims\n- ANY expression of satisfaction\n- ANY positive statement about work state\n- Committing, PR creation, task completion\n- Moving to next task\n- Delegating to agents\n\n**Rule applies to:**\n- Exact phrases\n- Paraphrases and synonyms\n- Implications of success\n- ANY communication suggesting completion/correctness\n\n## The Bottom Line\n\n**No shortcuts for verification.**\n\nRun the command. Read the output. THEN claim the result.\n\nThis is non-negotiable."
              },
              {
                "name": "writing-plans",
                "description": "Use when you have a spec or requirements for a multi-step task, before touching code",
                "path": "skills/writing-plans/SKILL.md",
                "frontmatter": {
                  "name": "writing-plans",
                  "description": "Use when you have a spec or requirements for a multi-step task, before touching code"
                },
                "content": "# Writing Plans\n\n## Overview\n\nWrite comprehensive implementation plans assuming the engineer has zero context for our codebase and questionable taste. Document everything they need to know: which files to touch for each task, code, testing, docs they might need to check, how to test it. Give them the whole plan as bite-sized tasks. DRY. YAGNI. TDD. Frequent commits.\n\nAssume they are a skilled developer, but know almost nothing about our toolset or problem domain. Assume they don't know good test design very well.\n\n**Announce at start:** \"I'm using the writing-plans skill to create the implementation plan.\"\n\n**Context:** This should be run in a dedicated worktree (created by brainstorming skill).\n\n**Save plans to:** `docs/plans/YYYY-MM-DD-<feature-name>.md`\n\n## Bite-Sized Task Granularity\n\n**Each step is one action (2-5 minutes):**\n- \"Write the failing test\" - step\n- \"Run it to make sure it fails\" - step\n- \"Implement the minimal code to make the test pass\" - step\n- \"Run the tests and make sure they pass\" - step\n- \"Commit\" - step\n\n## Plan Document Header\n\n**Every plan MUST start with this header:**\n\n```markdown\n# [Feature Name] Implementation Plan\n\n> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.\n\n**Goal:** [One sentence describing what this builds]\n\n**Architecture:** [2-3 sentences about approach]\n\n**Tech Stack:** [Key technologies/libraries]\n\n---\n```\n\n## Task Structure\n\n```markdown\n### Task N: [Component Name]\n\n**Files:**\n- Create: `exact/path/to/file.py`\n- Modify: `exact/path/to/existing.py:123-145`\n- Test: `tests/exact/path/to/test.py`\n\n**Step 1: Write the failing test**\n\n```python\ndef test_specific_behavior():\n    result = function(input)\n    assert result == expected\n```\n\n**Step 2: Run test to verify it fails**\n\nRun: `pytest tests/path/test.py::test_name -v`\nExpected: FAIL with \"function not defined\"\n\n**Step 3: Write minimal implementation**\n\n```python\ndef function(input):\n    return expected\n```\n\n**Step 4: Run test to verify it passes**\n\nRun: `pytest tests/path/test.py::test_name -v`\nExpected: PASS\n\n**Step 5: Commit**\n\n```bash\ngit add tests/path/test.py src/path/file.py\ngit commit -m \"feat: add specific feature\"\n```\n```\n\n## Remember\n- Exact file paths always\n- Complete code in plan (not \"add validation\")\n- Exact commands with expected output\n- Reference relevant skills with @ syntax\n- DRY, YAGNI, TDD, frequent commits\n\n## Execution Handoff\n\nAfter saving the plan, offer execution choice:\n\n**\"Plan complete and saved to `docs/plans/<filename>.md`. Two execution options:**\n\n**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration\n\n**2. Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints\n\n**Which approach?\"**\n\n**If Subagent-Driven chosen:**\n- **REQUIRED SUB-SKILL:** Use superpowers:subagent-driven-development\n- Stay in this session\n- Fresh subagent per task + code review\n\n**If Parallel Session chosen:**\n- Guide them to open new session in worktree\n- **REQUIRED SUB-SKILL:** New session uses superpowers:executing-plans"
              }
            ]
          }
        ]
      }
    }
  ]
}